_QWORD *llvm::SmallVector<unsigned int,4u>::SmallVector(_QWORD *a1, unint64_t a2)
{
  uint64_t v4;
  unint64_t v5;

  *a1 = a1 + 2;
  a1[1] = *(_QWORD *)"";
  if (a2)
  {
    if (a2 < 5)
    {
      v4 = 0;
      v5 = a2;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, a1 + 2, a2, 4);
      v4 = *((unsigned int *)a1 + 2);
      v5 = a2 - v4;
      if (a2 == v4)
        goto LABEL_7;
    }
    bzero((void *)(*a1 + 4 * v4), 4 * v5);
LABEL_7:
    *((_DWORD *)a1 + 2) = a2;
  }
  return a1;
}

_QWORD *llvm::SmallVector<unsigned int,4u>::SmallVector<llvm::mapped_iterator<std::pair<unsigned int,unsigned long long> *,mlir::BytecodeReader::Impl::sortUseListOrder(mlir::Value)::$_1,unsigned int>>(_QWORD *a1, unsigned int **a2)
{
  unsigned int *v3;
  uint64_t *v4;
  unsigned int *v5;
  uint64_t v6;
  unsigned int v7;
  _DWORD *v8;
  uint64_t v9;
  unsigned int v10;

  *a1 = a1 + 2;
  a1[1] = *(_QWORD *)"";
  v3 = *a2;
  v4 = (uint64_t *)a2[1];
  v5 = a2[3];
  v6 = (char *)v5 - (char *)*a2;
  if ((unint64_t)v6 < 0x41)
  {
    v7 = 0;
    if (v3 == v5)
      goto LABEL_8;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, a1 + 2, v6 >> 4, 4);
    v7 = *((_DWORD *)a1 + 2);
    if (v3 == v5)
      goto LABEL_8;
  }
  v8 = (_DWORD *)(*a1 + 4 * v7);
  v9 = *v4;
  do
  {
    v10 = *v3;
    v3 += 4;
    *v8++ = *(_DWORD *)(v9 + 4 * v10);
  }
  while (v3 != v5);
  v7 = *((_DWORD *)a1 + 2);
LABEL_8:
  *((_DWORD *)a1 + 2) = v7 + ((unint64_t)v6 >> 4);
  return a1;
}

uint64_t mlir::BytecodeReader::Impl::parseBlockHeader(uint64_t a1, _anonymous_namespace_::EncodingReader *this, uint64_t a3)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v9;
  _QWORD *v10;
  mlir::MLIRContext *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30[2];
  unint64_t v31[2];
  void *v32;
  uint64_t v33;
  _BYTE v34[48];
  llvm *v35;
  uint64_t v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v6 = (uint64_t *)(a3 + 112);
    return 0;
  v7 = *v6;
  *v6 = (unint64_t)*v6 >> 1;
  if ((v7 & 1) == 0)
    return 1;
  v9 = *(_QWORD *)(a3 + 104);
  v10 = v9 ? (_QWORD *)(v9 - 8) : 0;
  v28 = 0;
    return 0;
  v35 = (llvm *)&v37;
  v36 = 0x600000000;
  v32 = v34;
  v33 = 0x600000000;
  v12 = v28;
  if (v28 >= 7)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, &v37, v28, 8);
    if (v12 > HIDWORD(v33))
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v32, v34, v12, 8);
  }
  v13 = mlir::UnknownLoc::get(**(mlir::UnknownLoc ***)a1, v11);
  if (!v12)
  {
LABEL_27:
    mlir::ValueRange::ValueRange(v31, (uint64_t)v35, v36);
    mlir::Block::addArguments(v10, v31[0], v31[1], (uint64_t)v32, v33);
    mlir::ValueRange::ValueRange(v30, v10[6], (uint64_t)(v10[7] - v10[6]) >> 3);
    v22 = mlir::BytecodeReader::Impl::defineValues((_QWORD *)a1, *((_QWORD *)this + 3), v30[0], v30[1]);
    v23 = v32;
    if (v32 == v34)
      goto LABEL_29;
    goto LABEL_28;
  }
  v14 = v13;
  while (1)
  {
    v27 = v14;
    if (*(_QWORD *)(a1 + 248) < 4uLL)
      break;
    v29 = 0;
      goto LABEL_34;
    v15 = v29;
    if (!v16)
      goto LABEL_34;
    v17 = v16;
    if ((v15 & 1) != 0)
      goto LABEL_21;
LABEL_22:
    v19 = v36;
    if (v36 >= (unint64_t)HIDWORD(v36))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, &v37, v36 + 1, 8);
      v19 = v36;
    }
    *((_QWORD *)v35 + v19) = v17;
    LODWORD(v36) = v36 + 1;
    v20 = v27;
    v21 = v33;
    if (v33 >= (unint64_t)HIDWORD(v33))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v32, v34, v33 + 1, 8);
      v21 = v33;
    }
    *((_QWORD *)v32 + v21) = v20;
    LODWORD(v33) = v33 + 1;
    if (!--v12)
      goto LABEL_27;
  }
  v29 = 0;
  {
    if (v18)
    {
      v17 = v18;
LABEL_21:
      if (!mlir::BytecodeReader::Impl::parseAttribute<mlir::LocationAttr>(a1, this, &v27))
        goto LABEL_34;
      goto LABEL_22;
    }
  }
LABEL_34:
  v22 = 0;
  v23 = v32;
  if (v32 != v34)
LABEL_28:
    free(v23);
LABEL_29:
  if (v35 != (llvm *)&v37)
    free(v35);
  if (!v22)
    return 0;
  if (*(_QWORD *)(a1 + 248) < 3uLL)
    return 1;
  LOBYTE(v31[0]) = 0;
    return 0;
  if (LOBYTE(v31[0]))
  {
    v24 = *(_QWORD *)(a3 + 104);
    if (v24)
      v25 = v24 - 8;
    else
      v25 = 0;
    mlir::BytecodeReader::Impl::parseUseListOrderForRange((mlir::BytecodeReader::Impl *)&v35, this, ((*(_QWORD *)(v25 + 56) - *(_QWORD *)(v25 + 48)) >> 3));
  }
  return 1;
}

uint64_t mlir::BytecodeReader::Impl::parseRegions(unsigned int *a1, void **a2, uint64_t a3)
{
  uint64_t v3;
  _anonymous_namespace_::AttrTypeReader *v7;
  uint64_t v8;
  _anonymous_namespace_::EncodingReader *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  std::string::size_type v14;
  _QWORD *v15;
  unsigned int v16;
  char v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  mlir::Region *v29;
  uint64_t v30;
  uint64_t v31;
  std::string *v32;
  std::string::size_type size;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  char v39;
  char v40;
  _QWORD *v41;
  _QWORD *v42;
  void *v43;
  _QWORD *v44;
  _QWORD *v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  const mlir::OperationState *v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  char *v55;
  unint64_t v56;
  uint64_t v57;
  mlir::Region *v58;
  unint64_t v59;
  char v60;
  _QWORD *v61;
  _QWORD *v62;
  void *v63;
  _QWORD *v64;
  _QWORD *v65;
  void *v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  _QWORD *v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t (**v73)(mlir::Region **, mlir::Region ***);
  char v74;
  mlir::Region *AttrData;
  uint64_t v76;
  _QWORD *v77;
  _QWORD *v78;
  void *v79;
  _QWORD *v80;
  _QWORD *v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  uint64_t v86;
  mlir::Region *v87;
  uint64_t v88;
  _QWORD *v89;
  _QWORD *v90;
  void *v91;
  _QWORD *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  void *v99;
  _QWORD *v100;
  uint64_t v101;
  uint64_t v102;
  _anonymous_namespace_::AttrTypeReader *v103;
  mlir::Region *v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  uint64_t v111;
  _QWORD *v112;
  unint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t ForwardRef;
  unint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  unint64_t v124;
  char v125;
  _QWORD *v126;
  _QWORD *v127;
  void *v128;
  _QWORD *v129;
  _QWORD *v130;
  void *v131;
  uint64_t v132;
  uint64_t v133;
  BOOL v134;
  int v135;
  int v136;
  uint64_t *v137;
  char v138;
  unint64_t v139;
  uint64_t v140;
  unsigned int *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  _QWORD *v145;
  unint64_t v146;
  mlir::Region *v147;
  char *Address;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  mlir::Region *v152;
  unint64_t v153;
  uint64_t v154;
  unsigned int v155;
  unsigned int v156;
  llvm *v157;
  _QWORD *v158;
  unsigned int v159;
  unsigned int v160;
  char *v161;
  uint64_t v162;
  unsigned int v163;
  int *v164;
  int v165;
  uint64_t v166;
  unsigned int v167;
  char *v168;
  int v169;
  int v170;
  unsigned int v171;
  unsigned int v172;
  int v173;
  unsigned int v174;
  char *v175;
  int v176;
  BOOL v177;
  unsigned int v178;
  llvm *v179;
  unsigned int v180;
  uint64_t v181;
  uint64_t v182;
  char *v183;
  char *v184;
  uint64_t v185;
  unint64_t v186;
  _BYTE *v187;
  _QWORD *v188;
  _QWORD *v189;
  std::string::size_type v190;
  void *v191;
  _QWORD *v192;
  __int128 *v193;
  __int128 v194;
  void *v195;
  void *v196;
  int v197;
  _QWORD *v198;
  char *v199;
  int v200;
  uint64_t v201;
  _QWORD *v202;
  _QWORD *v203;
  void *v204;
  _QWORD *v205;
  _QWORD *v206;
  void *v207;
  uint64_t v208;
  uint64_t v209;
  _anonymous_namespace_::AttrTypeReader *v210;
  uint64_t v211;
  void *v212;
  char *v213;
  char *v214;
  unint64_t v215;
  void *v216;
  void **v217;
  int v218;
  __int128 v219;
  unint64_t v220;
  void *v221;
  _BYTE *v222;
  _QWORD *v223;
  _QWORD **v224;
  unsigned int v225;
  _QWORD *v226;
  unsigned int v227;
  unsigned int **v228;
  unsigned int *v229;
  unsigned int **v230;
  int v231;
  BOOL v232;
  unsigned int v233;
  unsigned int *v234;
  void *v235;
  uint64_t v236;
  unsigned int **v237;
  unsigned int v238;
  _QWORD *v239;
  int v240;
  unsigned int v241;
  unsigned int *v242;
  unsigned int **v243;
  int v244;
  BOOL v245;
  unsigned int v246;
  unsigned int *v247;
  void **v248;
  uint64_t v249;
  unint64_t v250;
  uint64_t v251;
  unint64_t v252;
  uint64_t v253;
  _QWORD *v254;
  void **v255;
  _QWORD *v256;
  void *v257;
  _QWORD *v258;
  char *v259;
  uint64_t v260;
  _QWORD *v261;
  _QWORD *v262;
  void *v263;
  _QWORD *v264;
  _QWORD *v265;
  void *v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v270;
  std::string::size_type v271;
  std::string *v272;
  char *v273;
  char *v274;
  __int128 v275;
  uint64_t v276;
  std::string *v277;
  char *v278;
  char *v279;
  __int128 v280;
  _QWORD *v281;
  _QWORD *v282;
  void *v283;
  _QWORD *v284;
  _QWORD *v285;
  void *v286;
  uint64_t v287;
  uint64_t v288;
  mlir::Region **v289;
  char *v290;
  char *v291;
  __int128 v292;
  uint64_t v293;
  uint64_t v294;
  mlir::Region *v295;
  mlir::Region **v296;
  char *v297;
  char *v298;
  __int128 v299;
  _QWORD *v300;
  _QWORD *v301;
  void *v302;
  _QWORD *v303;
  _QWORD *v304;
  void *v305;
  uint64_t v306;
  uint64_t v307;
  unint64_t v308;
  unint64_t v309;
  BOOL v310;
  unint64_t v311;
  unint64_t v312;
  int64_t v313;
  int64_t v314;
  int64_t v315;
  int64_t v316;
  _QWORD **v317;
  void **v318;
  _QWORD **v319;
  uint64_t *v320;
  uint64_t *v321;
  unsigned int *v322;
  uint64_t *v323;
  void **p_dst;
  void **v325;
  uint64_t *v326;
  uint64_t *v327;
  uint64_t *v328;
  uint64_t v329;
  void **v330;
  uint64_t *v331;
  _BYTE *v332;
  unsigned int v333;
  void *__src;
  _BYTE *v335;
  uint64_t *v336;
  _QWORD **v337;
  _QWORD **v338;
  void *v339;
  std::string::size_type v340;
  llvm *v341;
  unsigned int v342;
  void **v343;
  std::string::size_type *v344;
  std::string::size_type v345;
  std::string v346;
  __int128 v347;
  _anonymous_namespace_::EncodingReader *v348;
  std::string::size_type *v349;
  uint64_t v350;
  unint64_t v351[4];
  __int16 v352;
  mlir::Region *v353;
  __int128 v354;
  __int128 v355;
  _anonymous_namespace_::EncodingReader *v356;
  std::string::size_type *v357;
  _QWORD v358[4];
  unint64_t v359;
  unint64_t v360[4];
  __int16 v361;
  unint64_t v362[2];
  mlir::Region **v363;
  uint64_t v364;
  uint64_t v365;
  void *v366;
  unsigned int v367;
  unsigned int v368;
  _BYTE v369[24];
  uint64_t v370;
  unsigned int v371;
  unsigned int v372;
  uint64_t v373;
  void *__dst;
  uint64_t v375;
  uint64_t v376;
  void *v377;
  _QWORD *v378;
  void *__p;
  _QWORD *v380;
  char v381;
  uint64_t v382;
  uint64_t v383;
  unsigned int v384;
  unsigned int v385;
  uint64_t v386;
  uint64_t v387;
  unsigned int v388;
  uint64_t v389;
  __int128 v390;
  _anonymous_namespace_::EncodingReader *v391;
  void *v392;
  _QWORD **v393;
  void *v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  _BYTE v398[32];
  void *v399;
  _QWORD *v400;
  void *v401;
  _QWORD *v402;
  char v403;
  uint64_t v404;

  v404 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)a3 == *(_QWORD *)(a3 + 8))
  {
LABEL_442:
    if (*(_BYTE *)(a3 + 120))
    {
      v254 = (_QWORD *)*((_QWORD *)a1 + 86);
      v255 = (void **)(v254 - 7);
      v256 = (_QWORD *)*(v254 - 4);
      if (v256 != v254 - 2)
        free(v256);
      v257 = *v255;
      if (*v255)
      {
        *(v254 - 6) = v257;
        operator delete(v257);
      }
      *((_QWORD *)a1 + 86) = v255;
    }
    v258 = a2[1];
    v259 = (char *)*(v258 - 11);
    if (v259 != (char *)(v258 - 9))
      free(v259);
    v260 = *(v258 - 13);
    *(v258 - 13) = 0;
    if (v260)
      MEMORY[0x20BD002F8](v260, 0x1070C401CF53446);
    a2[1] = v258 - 16;
    return 1;
  }
  v7 = (_anonymous_namespace_::AttrTypeReader *)(a1 + 22);
  v340 = (std::string::size_type)(a1 + 134);
  v339 = a1 + 106;
  v338 = (_QWORD **)(a1 + 84);
  v344 = (std::string::size_type *)(a1 + 62);
  v343 = &v394;
  p_dst = &__dst;
  __src = &v391;
  v335 = v369;
  v331 = &v376;
  v318 = &v392;
  v327 = &v370;
  v326 = &v373;
  v323 = &v365;
  v322 = &v367;
  v321 = &v383;
  v328 = &v387;
  v329 = (uint64_t)&v390 + 8;
  v336 = &v396;
  v337 = (_QWORD **)(a1 + 128);
  v332 = v398;
  v319 = (_QWORD **)(a1 + 6);
  v320 = &v386;
  v317 = (_QWORD **)(a1 + 12);
  v325 = (void **)(a1 + 170);
  v345 = (std::string::size_type)(a1 + 22);
  while (!*(_QWORD *)(a3 + 104))
  {
    if (!mlir::BytecodeReader::Impl::parseRegion((uint64_t)a1, a3))
      return 0;
    v8 = *(_QWORD *)a3;
    if (**(_QWORD **)a3 != *(_QWORD *)a3)
      break;
LABEL_441:
    v253 = v8 + 24;
    *(_QWORD *)a3 = v253;
    if (v253 == *(_QWORD *)(a3 + 8))
      goto LABEL_442;
  }
  v330 = a2;
  v9 = *(_anonymous_namespace_::EncodingReader **)(a3 + 16);
  while (1)
  {
    v10 = *(_QWORD *)(a3 + 112);
    *(_QWORD *)(a3 + 112) = v10 - 1;
    v11 = v3;
    if (v10)
      break;
LABEL_433:
    v8 = *(_QWORD *)(*(_QWORD *)(a3 + 104) + 8);
    *(_QWORD *)(a3 + 104) = v8;
    if (v8 == *(_QWORD *)a3)
    {
      *(_QWORD *)(a3 + 104) = 0;
      v248 = (void **)*((_QWORD *)a1 + 86);
      v249 = (uint64_t)*(v248 - 7);
      v250 = ((uint64_t)*(v248 - 6) - v249) >> 3;
      v251 = *(unsigned int *)(a3 + 32);
      v252 = v250 - v251;
      if (v250 >= v251)
      {
        a2 = v330;
        if (v250 > v252)
          *(v248 - 6) = (void *)(v249 + 8 * v252);
      }
      else
      {
        std::vector<mlir::Value>::__append(v248 - 7, -v251);
        v8 = *(_QWORD *)a3;
        a2 = v330;
      }
      --*((_DWORD *)v248 - 6);
      v3 = v11;
      goto LABEL_441;
    }
    v3 = v11;
    v11 = 0;
    if (!mlir::BytecodeReader::Impl::parseBlockHeader((uint64_t)a1, v9, a3))
      return v11;
  }
  while (1)
  {
    v346.__r_.__value_.__r.__words[0] = 0;
      return 0;
    v12 = *((_QWORD *)v9 + 3);
    v13 = (_QWORD *)*((_QWORD *)a1 + 45);
    v14 = a1[92];
    *(_QWORD *)&v390 = "operation name";
    *((_QWORD *)&v390 + 1) = 14;
    v353 = (mlir::Region *)v346.__r_.__value_.__r.__words[0];
    if (v346.__r_.__value_.__r.__words[0] >= v14)
    {
      v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v363);
      if (v363)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v363);
      if (v381)
      {
        v18 = __p;
        if (__p)
        {
          v19 = v380;
          v20 = __p;
          if (v380 != __p)
          {
            do
              v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
            while (v19 != v18);
            v20 = __p;
          }
          v380 = v18;
          operator delete(v20);
        }
        v21 = v377;
        if (v377)
        {
          v22 = v378;
          v23 = v377;
          if (v378 != v377)
          {
            do
            {
              v25 = *--v22;
              v24 = v25;
              *v22 = 0;
              if (v25)
                MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
            }
            while (v22 != v21);
            v23 = v377;
          }
          v378 = v21;
          operator delete(v23);
        }
        if (v366 != v335)
          free(v366);
      }
      if (!v17)
        return 0;
      v15 = 0;
      v16 = MEMORY[0x28];
      if (MEMORY[8])
        goto LABEL_48;
    }
    else
    {
      v15 = &v13[6 * v346.__r_.__value_.__r.__words[0]];
      v16 = *((unsigned __int16 *)v15 + 20);
      if (*((_BYTE *)v15 + 8))
        goto LABEL_48;
    }
    *(_QWORD *)&v390 = &off_24C028780;
    *((_QWORD *)&v390 + 1) = v7;
    v391 = (_anonymous_namespace_::EncodingReader *)v340;
    v392 = v339;
    v393 = v338;
    v394 = v9;
    v395 = (uint64_t)v344;
      return 0;
    v26 = (void *)v15[4];
    if (v26)
    {
      v27 = v15[2];
      WORD4(v355) = 773;
      v29 = *(mlir::Region **)(v27 + 24);
      v28 = *(_QWORD *)(v27 + 32);
      v353 = v29;
      *(_QWORD *)&v354 = v28;
      *((_QWORD *)&v354 + 1) = ".";
      v30 = v15[3];
      v363 = &v353;
      v365 = v30;
      v366 = v26;
      LOWORD(v367) = 1282;
      llvm::Twine::str((llvm::Twine *)&v363, &v346);
      v31 = **(_QWORD **)a1;
      if (*((_BYTE *)v15 + 8))
        *((_BYTE *)v15 + 8) = 0;
      if ((v346.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v32 = &v346;
      else
        v32 = (std::string *)v346.__r_.__value_.__r.__words[0];
      if ((v346.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        size = HIBYTE(v346.__r_.__value_.__r.__words[2]);
      else
        size = v346.__r_.__value_.__l.__size_;
      mlir::OperationName::OperationName(v15, v32, size, v31);
      *((_BYTE *)v15 + 8) = 1;
      if (SHIBYTE(v346.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v346.__r_.__value_.__l.__data_);
    }
    else
    {
      v34 = (_QWORD *)v15[2];
      if (*v34)
      {
        mlir::emitError(*((_QWORD *)a1 + 1), (uint64_t)&v363);
        if (v363)
        {
          LODWORD(v353) = 3;
          *(_QWORD *)&v354 = "has an empty opname for dialect '";
          *((_QWORD *)&v354 + 1) = 33;
          v289 = &v353;
          v290 = (char *)v366;
          if (v367 >= v368)
          {
            v311 = v367 + 1;
            if (v366 <= &v353 && (char *)v366 + 24 * v367 > (char *)&v353)
            {
              v315 = (char *)&v353 - (_BYTE *)v366;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v366, v369, v311, 24);
              v290 = (char *)v366;
              v289 = (mlir::Region **)((char *)v366 + v315);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v366, v369, v311, 24);
              v289 = &v353;
              v290 = (char *)v366;
            }
          }
          v291 = &v290[24 * v367];
          v292 = *(_OWORD *)v289;
          *((_QWORD *)v291 + 2) = v289[2];
          *(_OWORD *)v291 = v292;
          ++v367;
          if (v363)
          {
            v293 = v15[2];
            WORD4(v355) = 261;
            v295 = *(mlir::Region **)(v293 + 24);
            v294 = *(_QWORD *)(v293 + 32);
            v353 = v295;
            *(_QWORD *)&v354 = v294;
            mlir::Diagnostic::operator<<((uint64_t)&v364, (const void ***)&v353);
            if (v363)
            {
              LODWORD(v353) = 3;
              *(_QWORD *)&v354 = "'\n";
              *((_QWORD *)&v354 + 1) = 2;
              v296 = &v353;
              v297 = (char *)v366;
              if (v367 >= v368)
              {
                v312 = v367 + 1;
                if (v366 <= &v353 && (char *)v366 + 24 * v367 > (char *)&v353)
                {
                  v316 = (char *)&v353 - (_BYTE *)v366;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v366, v369, v312, 24);
                  v297 = (char *)v366;
                  v296 = (mlir::Region **)((char *)v366 + v316);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v366, v369, v312, 24);
                  v296 = &v353;
                  v297 = (char *)v366;
                }
              }
              v298 = &v297[24 * v367];
              v299 = *(_OWORD *)v296;
              *((_QWORD *)v298 + 2) = v296[2];
              *(_OWORD *)v298 = v299;
              ++v367;
              if (v363)
                mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v363);
            }
          }
        }
        if (v381)
        {
          v300 = __p;
          if (__p)
          {
            v301 = v380;
            v302 = __p;
            if (v380 != __p)
            {
              do
                v301 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v301 - 1);
              while (v301 != v300);
              v302 = __p;
            }
            v380 = v300;
            operator delete(v302);
          }
          v303 = v377;
          if (v377)
          {
            v304 = v378;
            v305 = v377;
            if (v378 != v377)
            {
              do
              {
                v307 = *--v304;
                v306 = v307;
                *v304 = 0;
                if (v307)
                  MEMORY[0x20BD002D4](v306, 0x1000C8077774924);
              }
              while (v304 != v303);
              v305 = v377;
            }
            v378 = v303;
            operator delete(v305);
          }
          if (v366 != v369)
            free(v366);
        }
        return 0;
      }
      v35 = **(_QWORD **)a1;
      if (*((_BYTE *)v15 + 8))
        *((_BYTE *)v15 + 8) = 0;
      mlir::OperationName::OperationName(v15, v34[3], v34[4], v35);
      *((_BYTE *)v15 + 8) = 1;
    }
LABEL_48:
    v36 = *v15;
    v37 = (char *)*((_QWORD *)v9 + 2);
    v38 = (char *)(*(_QWORD *)v9 + *((_QWORD *)v9 + 1));
    v342 = v11;
    if (v37 == v38)
    {
      v40 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v363);
      if (v363)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v363);
      if (v381)
      {
        v41 = __p;
        if (__p)
        {
          v42 = v380;
          v43 = __p;
          if (v380 != __p)
          {
            do
              v42 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v42 - 1);
            while (v42 != v41);
            v43 = __p;
          }
          v380 = v41;
          operator delete(v43);
        }
        v44 = v377;
        if (v377)
        {
          v45 = v378;
          v46 = v377;
          if (v378 != v377)
          {
            do
            {
              v48 = *--v45;
              v47 = v48;
              *v45 = 0;
              if (v48)
                MEMORY[0x20BD002D4](v47, 0x1000C8077774924);
            }
            while (v45 != v44);
            v46 = v377;
          }
          v378 = v44;
          operator delete(v46);
        }
        if (v366 != v335)
          free(v366);
      }
      if (!v40)
        return 0;
      v39 = 0;
    }
    else
    {
      *((_QWORD *)v9 + 2) = v37 + 1;
      v39 = *v37;
    }
    v350 = 0;
    if (!mlir::BytecodeReader::Impl::parseAttribute<mlir::LocationAttr>((uint64_t)a1, v9, &v350))
      return 0;
    mlir::OperationState::OperationState(&v363, v350, v36);
    if ((v39 & 1) != 0)
    {
      *(_QWORD *)&v390 = 0;
        goto LABEL_472;
      v346.__r_.__value_.__r.__words[0] = v50;
      if (!v50)
        goto LABEL_472;
      v51 = *(void **)(*(_QWORD *)v50 + 136);
      if (v51 == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
        v52 = v50;
      else
        v52 = 0;
      if (v51 == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
      {
        v52 = v50;
      }
      else
      {
        v353 = (mlir::Region *)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::DictionaryAttr]";
        *(_QWORD *)&v354 = 70;
        v53 = llvm::StringRef::find((uint64_t *)&v353, "DesiredTypeName = ", 0x12uLL, 0);
        if ((unint64_t)v354 >= v53)
          v54 = v53;
        else
          v54 = v354;
        v55 = (char *)v353 + v54;
        v56 = v354 - v54;
        v57 = 18;
        if (v56 < 0x12)
          v57 = v56;
        v58 = (mlir::Region *)&v55[v57];
        v59 = v56 - v57;
        if (v59 >= v59 - 1)
          --v59;
        v353 = v58;
        *(_QWORD *)&v354 = v59;
        v60 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v390);
        if ((_QWORD)v390)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v390);
        if (v403)
        {
          v61 = v401;
          if (v401)
          {
            v62 = v402;
            v63 = v401;
            if (v402 != v401)
            {
              do
                v62 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v62 - 1);
              while (v62 != v61);
              v63 = v401;
            }
            v402 = v61;
            operator delete(v63);
          }
          v64 = v399;
          if (v399)
          {
            v65 = v400;
            v66 = v399;
            if (v400 != v399)
            {
              do
              {
                v68 = *--v65;
                v67 = v68;
                *v65 = 0;
                if (v68)
                  MEMORY[0x20BD002D4](v67, 0x1000C8077774924);
              }
              while (v65 != v64);
              v66 = v399;
            }
            v400 = v64;
            operator delete(v66);
          }
          if (v392 != v343)
            free(v392);
        }
        if (!v60)
          goto LABEL_472;
      }
      mlir::NamedAttrList::NamedAttrList(&v390, v52);
      v69 = (void *)v390;
      if ((void *)v390 != __src)
      {
        if (__dst != v331)
        {
          free(__dst);
          v69 = (void *)v390;
        }
        __dst = v69;
        v375 = *((_QWORD *)&v390 + 1);
        v390 = (unint64_t)__src;
        v382 = v397;
        goto LABEL_110;
      }
      v85 = DWORD2(v390);
      v86 = v375;
      if (v375 >= DWORD2(v390))
      {
        if (DWORD2(v390))
          memmove(__dst, __src, 16 * DWORD2(v390));
        goto LABEL_161;
      }
      if (HIDWORD(v375) >= DWORD2(v390))
      {
        if ((_DWORD)v375)
        {
          memmove(__dst, __src, 16 * v375);
          goto LABEL_159;
        }
      }
      else
      {
        LODWORD(v375) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)p_dst, v331, DWORD2(v390), 16);
      }
      v86 = 0;
LABEL_159:
      if (v86 != DWORD2(v390))
        memcpy((char *)__dst + 16 * v86, (const void *)(v390 + 16 * v86), 16 * DWORD2(v390) - 16 * v86);
LABEL_161:
      LODWORD(v375) = v85;
      DWORD2(v390) = 0;
      v382 = v397;
      if ((void *)v390 != __src)
        free((void *)v390);
    }
LABEL_110:
    if ((v39 & 0x40) != 0)
    {
      if (v16 <= 0xFF)
      {
        v270 = *((_QWORD *)a1 + 1);
        WORD4(v355) = 259;
        mlir::emitError(v270, (uint64_t)&v353, (uint64_t)&v390);
        if ((_QWORD)v390)
        {
          v271 = *v344;
          LODWORD(v346.__r_.__value_.__l.__data_) = 5;
          v346.__r_.__value_.__l.__size_ = v271;
          v272 = &v346;
          v273 = (char *)v392;
          if (v393 >= HIDWORD(v393))
          {
            v308 = v393 + 1;
            if (v392 <= &v346 && (char *)v392 + 24 * v393 > (char *)&v346)
            {
              v313 = (char *)&v346 - (_BYTE *)v392;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v318, v343, v308, 24);
              v273 = (char *)v392;
              v272 = (std::string *)((char *)v392 + v313);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v318, v343, v308, 24);
              v272 = &v346;
              v273 = (char *)v392;
            }
          }
          v274 = &v273[24 * v393];
          v275 = *(_OWORD *)&v272->__r_.__value_.__l.__data_;
          *((_QWORD *)v274 + 2) = *((_QWORD *)&v272->__r_.__value_.__l + 2);
          *(_OWORD *)v274 = v275;
          v276 = ((_DWORD)v393 + 1);
          LODWORD(v393) = (_DWORD)v393 + 1;
          if ((_QWORD)v390)
          {
            LODWORD(v346.__r_.__value_.__l.__data_) = 3;
            v346.__r_.__value_.__l.__size_ = (std::string::size_type)" with properties.";
            v346.__r_.__value_.__r.__words[2] = 17;
            v277 = &v346;
            v278 = (char *)v392;
            if (v276 >= HIDWORD(v393))
            {
              v309 = v276 + 1;
              v310 = (char *)v392 + 24 * v276 > (char *)&v346;
              if (v392 <= &v346 && v310)
              {
                v314 = (char *)&v346 - (_BYTE *)v392;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v318, v343, v309, 24);
                v278 = (char *)v392;
                v277 = (std::string *)((char *)v392 + v314);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v318, v343, v309, 24);
                v277 = &v346;
                v278 = (char *)v392;
              }
            }
            v279 = &v278[24 * v393];
            v280 = *(_OWORD *)&v277->__r_.__value_.__l.__data_;
            *((_QWORD *)v279 + 2) = *((_QWORD *)&v277->__r_.__value_.__l + 2);
            *(_OWORD *)v279 = v280;
            LODWORD(v393) = (_DWORD)v393 + 1;
            if ((_QWORD)v390)
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v390);
          }
        }
        if (v403)
        {
          v281 = v401;
          if (v401)
          {
            v282 = v402;
            v283 = v401;
            if (v402 != v401)
            {
              do
                v282 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v282 - 1);
              while (v282 != v281);
              v283 = v401;
            }
            v402 = v281;
            operator delete(v283);
          }
          v284 = v399;
          if (v399)
          {
            v285 = v400;
            v286 = v399;
            if (v400 != v399)
            {
              do
              {
                v288 = *--v285;
                v287 = v288;
                *v285 = 0;
                if (v288)
                  MEMORY[0x20BD002D4](v287, 0x1000C8077774924);
              }
              while (v285 != v284);
              v286 = v399;
            }
            v400 = v284;
            operator delete(v286);
          }
          if (v392 != v343)
            free(v392);
        }
        goto LABEL_472;
      }
      v346.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_24C028780;
      v346.__r_.__value_.__l.__size_ = v345;
      v346.__r_.__value_.__r.__words[2] = v340;
      *(_QWORD *)&v347 = v339;
      *((_QWORD *)&v347 + 1) = v338;
      v348 = v9;
      v349 = v344;
      v70 = (_QWORD *)*((_QWORD *)a1 + 1);
      v359 = 0;
        goto LABEL_472;
      if (v359 >= a1[156])
      {
        v360[0] = (unint64_t)"Properties idx out-of-bound for ";
        v361 = 259;
        (*(void (**)(__int128 *__return_ptr, std::string *, unint64_t *))(v346.__r_.__value_.__r.__words[0]
                                                                                          + 16))(&v390, &v346, v360);
        v353 = *(mlir::Region **)(v36 + 8);
        AttrData = (mlir::Region *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v353);
        if ((_QWORD)v390)
        {
          WORD4(v355) = 261;
          v353 = AttrData;
          *(_QWORD *)&v354 = v76;
          mlir::Diagnostic::operator<<(v329, (const void ***)&v353);
        }
        v74 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v390);
        if ((_QWORD)v390)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v390);
        if (v403)
        {
          v77 = v401;
          if (v401)
          {
            v78 = v402;
            v79 = v401;
            if (v402 != v401)
            {
              do
                v78 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v78 - 1);
              while (v78 != v77);
              v79 = v401;
            }
            v402 = v77;
            operator delete(v79);
          }
          v80 = v399;
          if (!v399)
            goto LABEL_182;
          v81 = v400;
          v82 = v399;
          if (v400 == v399)
            goto LABEL_181;
          do
          {
            v84 = *--v81;
            v83 = v84;
            *v81 = 0;
            if (v84)
              MEMORY[0x20BD002D4](v83, 0x1000C8077774924);
          }
          while (v81 != v80);
          goto LABEL_180;
        }
      }
      else
      {
        v71 = *((_QWORD *)a1 + 76);
        if (v359 >= v71)
        {
          v360[0] = (unint64_t)"Properties offset out-of-bound for ";
          v361 = 259;
          (*(void (**)(__int128 *__return_ptr, std::string *, unint64_t *))(v346.__r_.__value_.__r.__words[0]
                                                                                            + 16))(&v390, &v346, v360);
          v353 = *(mlir::Region **)(v36 + 8);
          v87 = (mlir::Region *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v353);
          if ((_QWORD)v390)
          {
            WORD4(v355) = 261;
            v353 = v87;
            *(_QWORD *)&v354 = v88;
            mlir::Diagnostic::operator<<(v329, (const void ***)&v353);
          }
          v74 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v390);
          if ((_QWORD)v390)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v390);
          if (v403)
          {
            v89 = v401;
            if (v401)
            {
              v90 = v402;
              v91 = v401;
              if (v402 != v401)
              {
                do
                  v90 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v90 - 1);
                while (v90 != v89);
                v91 = v401;
              }
              v402 = v89;
              operator delete(v91);
            }
            v80 = v399;
            if (!v399)
              goto LABEL_182;
            v92 = v400;
            v82 = v399;
            if (v400 == v399)
              goto LABEL_181;
            do
            {
              v94 = *--v92;
              v93 = v94;
              *v92 = 0;
              if (v94)
                MEMORY[0x20BD002D4](v93, 0x1000C8077774924);
            }
            while (v92 != v80);
            goto LABEL_180;
          }
        }
        else
        {
          v72 = *(_QWORD *)(*((_QWORD *)a1 + 77) + 8 * v359);
          *(_QWORD *)&v390 = *((_QWORD *)a1 + 75) + v72;
          *((_QWORD *)&v390 + 1) = v71 - v72;
          v391 = (_anonymous_namespace_::EncodingReader *)v390;
          v392 = v70;
          v360[0] = 0;
          v353 = 0;
          *(_QWORD *)&v354 = 0;
          {
            goto LABEL_472;
          }
          v358[0] = v353;
          v358[1] = v354;
          v358[2] = v353;
          v358[3] = v70;
          v353 = (mlir::Region *)&off_24C028780;
          v354 = *(_OWORD *)&v346.__r_.__value_.__r.__words[1];
          v355 = v347;
          v356 = (_anonymous_namespace_::EncodingReader *)v358;
          v357 = v349;
          v73 = (uint64_t (**)(mlir::Region **, mlir::Region ***))mlir::detail::InterfaceMap::lookup<mlir::BytecodeOpInterface>(v36 + 32);
          if (v73)
          {
            v74 = (*v73)(&v353, &v363);
            goto LABEL_184;
          }
          if (*(_UNKNOWN **)(v36 + 16) == &mlir::detail::TypeIDResolver<void,void>::id)
          {
            v210 = (_anonymous_namespace_::AttrTypeReader *)v354;
            *(_QWORD *)&v390 = 0;
            {
              v74 = v389 != 0;
            }
            else
            {
              v74 = 0;
            }
            goto LABEL_184;
          }
          v351[0] = (unint64_t)"has properties but missing BytecodeOpInterface for ";
          v352 = 259;
          v360[0] = *(_QWORD *)(v36 + 8);
          v95 = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v360);
          if ((_QWORD)v390)
          {
            v361 = 261;
            v360[0] = v95;
            v360[1] = v96;
            mlir::Diagnostic::operator<<(v329, (const void ***)v360);
          }
          v74 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v390);
          if ((_QWORD)v390)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v390);
          if (v403)
          {
            v97 = v401;
            if (v401)
            {
              v98 = v402;
              v99 = v401;
              if (v402 != v401)
              {
                do
                  v98 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v98 - 1);
                while (v98 != v97);
                v99 = v401;
              }
              v402 = v97;
              operator delete(v99);
            }
            v80 = v399;
            if (!v399)
              goto LABEL_182;
            v100 = v400;
            v82 = v399;
            if (v400 == v399)
            {
LABEL_181:
              v400 = v80;
              operator delete(v82);
LABEL_182:
              if (v392 != v343)
                free(v392);
              goto LABEL_184;
            }
            do
            {
              v102 = *--v100;
              v101 = v102;
              *v100 = 0;
              if (v102)
                MEMORY[0x20BD002D4](v101, 0x1000C8077774924);
            }
            while (v100 != v80);
LABEL_180:
            v82 = v399;
            goto LABEL_181;
          }
        }
      }
LABEL_184:
      if (!v74)
        goto LABEL_472;
    }
    v103 = (_anonymous_namespace_::AttrTypeReader *)v345;
    if ((v39 & 2) != 0)
    {
      v353 = 0;
        goto LABEL_472;
      v104 = v353;
      v105 = v371;
      if (v353 != (mlir::Region *)v371)
      {
        if ((unint64_t)v353 >= v371)
        {
          if ((unint64_t)v353 > v372)
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v327, v326, (unint64_t)v353, 8);
            v105 = v371;
          }
          if (v104 != (mlir::Region *)v105)
            bzero((void *)(v370 + 8 * v105), 8 * ((_QWORD)v104 - v105));
        }
        v371 = v104;
      }
      if ((int)v104 >= 1)
        break;
    }
LABEL_199:
    if ((v39 & 4) != 0)
    {
      v351[0] = 0;
        goto LABEL_472;
      v109 = v351[0];
      v110 = v366;
      if (v351[0] != v366)
      {
        if (v351[0] >= v366)
        {
          if (v351[0] > HIDWORD(v366))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v323, v322, v351[0], 8);
            v110 = v366;
          }
          if (v109 != v110)
            bzero((void *)(v365 + 8 * v110), 8 * (v109 - v110));
        }
        LODWORD(v366) = v109;
      }
      if ((int)v109 >= 1)
      {
        v111 = 0;
        while (1)
        {
          v112 = (_QWORD *)*((_QWORD *)a1 + 86);
          v360[0] = 0;
            break;
          v113 = v360[0];
          v49 = (const mlir::OperationState *)*((_QWORD *)v9 + 3);
          v115 = *(v112 - 7);
          v114 = *(v112 - 6);
          v353 = (mlir::Region *)"value";
          *(_QWORD *)&v354 = 5;
          v346.__r_.__value_.__r.__words[0] = v360[0];
          if (v360[0] >= (v114 - v115) >> 3)
          {
            mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v390);
            if ((_QWORD)v390)
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v390);
            if (v403)
            {
              v261 = v401;
              if (v401)
              {
                v262 = v402;
                v263 = v401;
                if (v402 != v401)
                {
                  do
                    v262 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v262 - 1);
                  while (v262 != v261);
                  v263 = v401;
                }
                v402 = v261;
                operator delete(v263);
              }
              v264 = v399;
              if (v399)
              {
                v265 = v400;
                v266 = v399;
                if (v400 != v399)
                {
                  do
                  {
                    v268 = *--v265;
                    v267 = v268;
                    *v265 = 0;
                    if (v268)
                      MEMORY[0x20BD002D4](v267, 0x1000C8077774924);
                  }
                  while (v265 != v264);
                  v266 = v399;
                }
                v400 = v264;
                operator delete(v266);
              }
              if (v392 != v343)
                free(v392);
            }
            break;
          }
          v116 = *(_QWORD *)(v115 + 8 * v360[0]);
          if (v116)
          {
            *(_QWORD *)(v365 + 8 * v111) = v116;
          }
          else
          {
            ForwardRef = mlir::BytecodeReader::Impl::createForwardRef((mlir::BytecodeReader::Impl *)a1, v49);
            *(_QWORD *)(v115 + 8 * v113) = ForwardRef;
            *(_QWORD *)(v365 + 8 * v111) = ForwardRef;
            if (!ForwardRef)
              goto LABEL_472;
          }
          if (v109 == ++v111)
            goto LABEL_217;
        }
        *(_QWORD *)(v365 + 8 * v111) = 0;
        goto LABEL_472;
      }
    }
LABEL_217:
    if ((v39 & 8) != 0)
    {
      v351[0] = 0;
        goto LABEL_472;
      v118 = v351[0];
      v119 = v384;
      if (v351[0] != v384)
      {
        if (v351[0] >= v384)
        {
          if (v351[0] > v385)
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v321, v320, v351[0], 8);
            v119 = v384;
          }
          if (v118 != v119)
            bzero((void *)(v383 + 8 * v119), 8 * (v118 - v119));
        }
        v384 = v118;
      }
      if ((int)v118 >= 1)
      {
        v120 = 0;
        v121 = v118;
        do
        {
          v122 = v383;
          v360[0] = 0;
            goto LABEL_472;
          v49 = (const mlir::OperationState *)*((_QWORD *)v9 + 3);
          v123 = *(_QWORD *)(a3 + 40);
          v124 = *(unsigned int *)(a3 + 48);
          v353 = (mlir::Region *)"successor";
          *(_QWORD *)&v354 = 9;
          v346.__r_.__value_.__r.__words[0] = v360[0];
          if (v360[0] < v124)
          {
            *(_QWORD *)(v122 + 8 * v120) = *(_QWORD *)(v123 + 8 * v360[0]);
          }
          else
          {
            v125 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v390);
            if ((_QWORD)v390)
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v390);
            if (v403)
            {
              v126 = v401;
              if (v401)
              {
                v127 = v402;
                v128 = v401;
                if (v402 != v401)
                {
                  do
                    v127 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v127 - 1);
                  while (v127 != v126);
                  v128 = v401;
                }
                v402 = v126;
                operator delete(v128);
              }
              v129 = v399;
              if (v399)
              {
                v130 = v400;
                v131 = v399;
                if (v400 != v399)
                {
                  do
                  {
                    v133 = *--v130;
                    v132 = v133;
                    *v130 = 0;
                    if (v133)
                      MEMORY[0x20BD002D4](v132, 0x1000C8077774924);
                  }
                  while (v130 != v129);
                  v131 = v399;
                }
                v400 = v129;
                operator delete(v131);
              }
              if (v392 != v343)
                free(v392);
            }
            if (!v125)
              goto LABEL_472;
          }
        }
        while (++v120 != v121);
      }
    }
    v134 = (v39 & 0x20) != 0 && *v344 >= 3;
    v135 = !v134;
    if (v134)
      mlir::BytecodeReader::Impl::parseUseListOrderForRange((mlir::BytecodeReader::Impl *)&v390, v9, v371);
    v341 = (llvm *)((unint64_t)v341 & 0xFFFFFFFFFFFFFF00);
    if ((v39 & 0x10) != 0)
    {
      *(_QWORD *)&v390 = 0;
      {
        if ((v135 & 1) != 0)
        {
LABEL_322:
          mlir::OperationState::~OperationState((mlir::OperationState *)&v363);
          return 0;
        }
LABEL_312:
        v179 = v341;
        v180 = v333;
        if (!v333)
        {
LABEL_320:
          v185 = 0;
          goto LABEL_321;
        }
LABEL_313:
        v181 = v180;
        v182 = 48 * v180;
        v183 = (char *)v179 + 24;
        do
        {
          if (*((_DWORD *)v183 - 6) <= 0xFFFFFFFD)
          {
            v184 = (char *)*((_QWORD *)v183 - 2);
            if (v183 != v184)
              free(v184);
          }
          v183 += 48;
          v182 -= 48;
        }
        while (v182);
        v185 = 48 * v181;
        v179 = v341;
LABEL_321:
        llvm::deallocate_buffer(v179, (void *)v185);
      }
      v138 = v390;
      v139 = (unint64_t)v390 >> 1;
      v140 = (uint64_t)v328;
      llvm::SmallVectorImpl<std::unique_ptr<mlir::Region>>::reserve((uint64_t)v328, (unint64_t)v390 >> 1);
      v137 = v336;
      v11 = v342;
      if ((int)v139 >= 1)
      {
        do
        {
          v147 = (mlir::Region *)operator new();
          *(_QWORD *)v147 = v147;
          *((_QWORD *)v147 + 1) = v147;
          *((_QWORD *)v147 + 2) = 0;
          v353 = v147;
          Address = llvm::SmallVectorTemplateBase<std::unique_ptr<mlir::Region>,false>::reserveForParamAndGetAddress(v140, (unint64_t)&v353, 1);
          v149 = v387;
          v150 = v388;
          v151 = *(_QWORD *)Address;
          *(_QWORD *)Address = 0;
          *(_QWORD *)(v149 + 8 * v150) = v151;
          v388 = v150 + 1;
          v152 = v353;
          v353 = 0;
          if (v152)
          {
            mlir::Region::~Region(v152);
            MEMORY[0x20BD002F8]();
          }
          LODWORD(v139) = v139 - 1;
        }
        while ((_DWORD)v139);
      }
      v136 = v138 & 1;
    }
    else
    {
      v136 = 0;
      v137 = v336;
      v11 = v342;
    }
    v141 = (unsigned int *)mlir::Operation::create((mlir::Operation *)&v363, v49);
    v142 = *(_QWORD *)(a3 + 104);
    if (v142)
      v143 = v142 - 8;
    else
      v143 = 0;
    llvm::ilist_traits<mlir::Operation>::addNodeToList(v143 + 32, (uint64_t)v141);
    ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)v141);
    v144 = *(_QWORD *)(v143 + 32);
    *v145 = v144;
    v145[1] = v143 + 32;
    *(_QWORD *)(v144 + 8) = v145;
    *(_QWORD *)(v143 + 32) = v145;
    ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)v141);
    v146 = v141[9];
    if ((_DWORD)v146)
    {
      mlir::ValueRange::ValueRange(v362, (uint64_t)(v141 - 4), v146);
      if (!mlir::BytecodeReader::Impl::defineValues(a1, *((_QWORD *)v9 + 3), v362[0], v362[1]))
      {
        if ((v135 & 1) != 0)
          goto LABEL_322;
        goto LABEL_312;
      }
    }
    if (!v135)
    {
      v153 = v141[9];
      if ((_DWORD)v153)
      {
        v154 = 0;
        v155 = v333;
        v156 = v333 - 1;
        v157 = v341;
        while (1)
        {
          if (v155)
          {
            v163 = (37 * v154) & v156;
            v164 = (int *)((char *)v157 + 48 * v163);
            v165 = *v164;
            if (*v164 != (_DWORD)v154)
            {
              v169 = 1;
              v170 = *v164;
              v171 = (37 * v154) & v156;
              while (v170 != -1)
              {
                v172 = v171 + v169++;
                v171 = v172 & v156;
                v170 = *((_DWORD *)v157 + 12 * v171);
                if (v170 == (_DWORD)v154)
                  goto LABEL_281;
              }
              goto LABEL_278;
            }
LABEL_281:
            v166 = (uint64_t)&v141[-6 * (v154 - 5) - 24];
            if (v154 <= 5)
              v166 = (uint64_t)&v141[4 * ~v154];
            *(_QWORD *)&v390 = v166;
            if (v165 != (_DWORD)v154)
            {
              v173 = 1;
              while (v165 != -1)
              {
                v174 = v163 + v173++;
                v163 = v174 & v156;
                v164 = (int *)((char *)v157 + 48 * (v174 & v156));
                v165 = *v164;
                if (*v164 == (_DWORD)v154)
                  goto LABEL_284;
              }
              v164 = (int *)((char *)v341 + 48 * v333);
            }
LABEL_284:
            v167 = a1[132];
            if (!v167)
            {
              v168 = 0;
LABEL_286:
              llvm::DenseMapBase<llvm::DenseMap<void *,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::BytecodeReader::Impl::UseListOrderStorage>>,void *,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::BytecodeReader::Impl::UseListOrderStorage>>::InsertIntoBucket<void *,mlir::BytecodeReader::Impl::UseListOrderStorage const&>((uint64_t)v337, v168, (uint64_t *)&v390, (uint64_t)(v164 + 2));
              v153 = v141[9];
              v157 = v341;
              v155 = v333;
              goto LABEL_278;
            }
            v158 = (_QWORD *)*((_QWORD *)a1 + 64);
            v159 = v167 - 1;
            v160 = v159 & ((v166 >> 4) ^ (v166 >> 9));
            v161 = (char *)&v158[6 * v160];
            v162 = *(_QWORD *)v161;
            if (v166 != *(_QWORD *)v161)
            {
              v175 = 0;
              v176 = 1;
              while (v162 != -4096)
              {
                if (v175)
                  v177 = 0;
                else
                  v177 = v162 == -8192;
                v157 = v341;
                if (v177)
                  v175 = v161;
                v178 = v160 + v176++;
                v160 = v178 & v159;
                v161 = (char *)&v158[6 * v160];
                v162 = *(_QWORD *)v161;
                if (v166 == *(_QWORD *)v161)
                  goto LABEL_278;
              }
              if (v175)
                v168 = v175;
              else
                v168 = v161;
              goto LABEL_286;
            }
          }
LABEL_278:
          if (++v154 >= v153)
            goto LABEL_312;
        }
      }
      v179 = v341;
      v180 = v333;
      if (!v333)
        goto LABEL_320;
      goto LABEL_313;
    }
    mlir::OperationState::~OperationState((mlir::OperationState *)&v363);
    v186 = v141[11];
    if ((v186 & 0x7FFFFF) == 0)
    {
      v7 = (_anonymous_namespace_::AttrTypeReader *)v345;
      goto LABEL_410;
    }
    *(_QWORD *)&v390 = (((unint64_t)&v141[4 * ((v186 >> 23) & 1) + 17] + ((v186 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
                     + 32 * v141[10];
    *((_QWORD *)&v390 + 1) = v390 + 24 * (v186 & 0x7FFFFF);
    v391 = v9;
    v392 = 0;
    LODWORD(v393) = 0;
    v394 = v137;
    v395 = 0x600000000;
    v187 = v332;
    *(_QWORD *)v332 = 0;
    *((_QWORD *)v187 + 1) = 0;
    v398[16] = v136;
    if (!v136 || *v344 < 2)
      goto LABEL_333;
    LOBYTE(v360[0]) = 0;
    *(_OWORD *)&v346.__r_.__value_.__l.__data_ = 0uLL;
    {
      v11 = 0;
      v200 = 1;
      goto LABEL_404;
    }
    if (LOBYTE(v360[0]) == 4)
    {
      v188 = (_QWORD *)operator new();
      v189 = (_QWORD *)*((_QWORD *)a1 + 1);
      v190 = v346.__r_.__value_.__r.__words[0];
      *(_OWORD *)v188 = *(_OWORD *)&v346.__r_.__value_.__l.__data_;
      v188[2] = v190;
      v188[3] = v189;
      v191 = v392;
      v392 = v188;
      if (v191)
      {
        MEMORY[0x20BD002F8](v191, 0x1070C401CF53446);
        v188 = v392;
      }
      v391 = (_anonymous_namespace_::EncodingReader *)v188;
      if (*((_BYTE *)a1 + 16))
      {
        v192 = (_QWORD *)*((_QWORD *)a1 + 9);
        if (!v192)
          goto LABEL_370;
        if ((((uint64_t (*)(_QWORD, unsigned int *))v192)(*((_QWORD *)a1 + 10), v141) & 1) == 0)
        {
          v188 = v392;
LABEL_370:
          v213 = (char *)operator new(0x98uLL);
          v214 = v213;
          *(_QWORD *)v213 = 0;
          *((_QWORD *)v213 + 1) = 0;
          *((_QWORD *)v213 + 2) = v141;
          *(_OWORD *)(v213 + 24) = v390;
          v392 = 0;
          *((_QWORD *)v213 + 5) = v391;
          *((_QWORD *)v213 + 6) = v188;
          v215 = v395;
          *((_DWORD *)v213 + 14) = (_DWORD)v393;
          v216 = v213 + 80;
          *((_QWORD *)v213 + 8) = v213 + 80;
          v217 = (void **)(v213 + 64);
          *((_QWORD *)v213 + 9) = 0x600000000;
          if ((_DWORD)v215)
          {
            if (v394 != v137)
            {
              *((_QWORD *)v213 + 8) = v394;
              v218 = HIDWORD(v395);
              *((_DWORD *)v213 + 18) = v215;
              *((_DWORD *)v213 + 19) = v218;
              v394 = v137;
              HIDWORD(v395) = 0;
              goto LABEL_386;
            }
            if (v215 < 7)
            {
              v221 = v137;
              v220 = v215;
LABEL_384:
              memcpy(v216, v221, 8 * v220);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v213 + 64), v216, v215, 8);
              v220 = v395;
              if ((_DWORD)v395)
              {
                v221 = v394;
                v216 = *v217;
                goto LABEL_384;
              }
            }
            *((_DWORD *)v214 + 18) = v215;
LABEL_386:
            LODWORD(v395) = 0;
          }
          v222 = v332;
          *((_OWORD *)v214 + 8) = *(_OWORD *)v332;
          v214[144] = v222[16];
          v223 = (_QWORD *)*((_QWORD *)a1 + 3);
          v224 = v319;
          *(_QWORD *)v214 = v223;
          *((_QWORD *)v214 + 1) = v224;
          v223[1] = v214;
          *((_QWORD *)a1 + 3) = v214;
          ++*((_QWORD *)a1 + 5);
          v225 = a1[16];
          if (v225)
          {
            v226 = (_QWORD *)*((_QWORD *)a1 + 6);
            v227 = (v225 - 1) & ((v141 >> 4) ^ (v141 >> 9));
            v228 = (unsigned int **)&v226[2 * v227];
            v229 = *v228;
            if (v141 == *v228)
              goto LABEL_403;
            v230 = 0;
            v231 = 1;
            while (v229 != (unsigned int *)-4096)
            {
              if (v230)
                v232 = 0;
              else
                v232 = v229 == (unsigned int *)-8192;
              if (v232)
                v230 = v228;
              v233 = v227 + v231++;
              v227 = v233 & (v225 - 1);
              v228 = (unsigned int **)&v226[2 * v227];
              v229 = *v228;
              v200 = 7;
              if (v141 == *v228)
              {
                v7 = (_anonymous_namespace_::AttrTypeReader *)v345;
                v137 = v336;
                v11 = v342;
                goto LABEL_405;
              }
            }
            if (v230)
              v237 = v230;
            else
              v237 = v228;
            v137 = v336;
            v11 = v342;
            v238 = a1[14];
            if (4 * v238 + 4 >= 3 * v225)
              goto LABEL_416;
            if (v225 + ~v238 - a1[15] > v225 >> 3)
            {
              v234 = *v237;
              ++a1[14];
              if (v234 != (unsigned int *)-4096)
                goto LABEL_401;
LABEL_402:
              *v237 = v141;
              v237[1] = (unsigned int *)v214;
LABEL_403:
              v200 = 7;
LABEL_404:
              v7 = (_anonymous_namespace_::AttrTypeReader *)v345;
              goto LABEL_405;
            }
          }
          else
          {
LABEL_416:
            v225 *= 2;
          }
          llvm::DenseMap<mlir::Block *,llvm::SMLoc,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,llvm::SMLoc>>::grow((uint64_t)v317, v225);
          v239 = (_QWORD *)*((_QWORD *)a1 + 6);
          v240 = a1[16] - 1;
          v241 = v240 & ((v141 >> 4) ^ (v141 >> 9));
          v237 = (unsigned int **)&v239[2 * v241];
          v242 = *v237;
          if (v141 == *v237)
          {
LABEL_418:
            v137 = v336;
            v11 = v342;
            ++a1[14];
            if (v141 == (unsigned int *)-4096)
              goto LABEL_402;
          }
          else
          {
            v243 = 0;
            v244 = 1;
            while (v242 != (unsigned int *)-4096)
            {
              if (v243)
                v245 = 0;
              else
                v245 = v242 == (unsigned int *)-8192;
              if (v245)
                v243 = v237;
              v246 = v241 + v244++;
              v241 = v246 & v240;
              v237 = (unsigned int **)&v239[2 * (v246 & v240)];
              v242 = *v237;
              if (v141 == *v237)
                goto LABEL_418;
            }
            if (v243)
              v237 = v243;
            v137 = v336;
            v11 = v342;
            v247 = *v237;
            ++a1[14];
            if (v247 == (unsigned int *)-4096)
              goto LABEL_402;
          }
LABEL_401:
          --a1[15];
          goto LABEL_402;
        }
      }
LABEL_333:
      v193 = (__int128 *)v330[1];
      if (v193 >= v330[2])
      {
        v330[1] = std::vector<mlir::BytecodeReader::Impl::RegionReadState>::__push_back_slow_path<mlir::BytecodeReader::Impl::RegionReadState>(v330, (uint64_t)&v390);
        if (!v136)
          goto LABEL_378;
      }
      else
      {
        v194 = v390;
        *((_QWORD *)v193 + 2) = v391;
        *v193 = v194;
        v195 = v392;
        v392 = 0;
        *((_QWORD *)v193 + 3) = v195;
        *((_DWORD *)v193 + 8) = (_DWORD)v393;
        v196 = (char *)v193 + 56;
        *((_QWORD *)v193 + 5) = (char *)v193 + 56;
        *((_QWORD *)v193 + 6) = 0x600000000;
        if (v193 != &v390)
        {
          v197 = v395;
          if ((_DWORD)v395)
          {
            if (v394 != v137)
            {
              *((_QWORD *)v193 + 5) = v394;
              *((_DWORD *)v193 + 12) = v197;
              *((_DWORD *)v193 + 13) = HIDWORD(v395);
              v394 = v137;
              HIDWORD(v395) = 0;
              goto LABEL_376;
            }
            if (v395 < 7)
            {
              v212 = v137;
              v211 = v395;
LABEL_374:
              memcpy(v196, v212, 8 * v211);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v193 + 40, (char *)v193 + 56, v395, 8);
              v211 = v395;
              if ((_DWORD)v395)
              {
                v212 = v394;
                v196 = (void *)*((_QWORD *)v193 + 5);
                goto LABEL_374;
              }
            }
            *((_DWORD *)v193 + 12) = v197;
LABEL_376:
            LODWORD(v395) = 0;
          }
        }
        v219 = *(_OWORD *)v332;
        *((_BYTE *)v193 + 120) = v332[16];
        *(__int128 *)((char *)v193 + 104) = v219;
        v330[1] = v193 + 8;
        if (!v136)
        {
LABEL_378:
          v200 = 1;
          v11 = 1;
          goto LABEL_404;
        }
      }
      v198 = (_QWORD *)*((_QWORD *)a1 + 86);
      if ((unint64_t)v198 >= *((_QWORD *)a1 + 87))
      {
        v199 = std::vector<mlir::BytecodeReader::Impl::ValueScope>::__emplace_back_slow_path<>(v325);
      }
      else
      {
        *((_OWORD *)v198 + 1) = 0u;
        *((_OWORD *)v198 + 2) = 0u;
        v198[6] = 0;
        *(_OWORD *)v198 = 0u;
        v198[3] = v198 + 5;
        v199 = (char *)(v198 + 7);
        *((_DWORD *)v198 + 9) = 4;
      }
      v7 = (_anonymous_namespace_::AttrTypeReader *)v345;
      *((_QWORD *)a1 + 86) = v199;
      v200 = 1;
      v11 = 1;
      goto LABEL_405;
    }
    v201 = *((_QWORD *)a1 + 1);
    v353 = (mlir::Region *)"expected IR section for region";
    WORD4(v355) = 259;
    mlir::emitError(v201, (uint64_t)&v353, (uint64_t)&v363);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v363);
    if (v363)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v363);
    v7 = (_anonymous_namespace_::AttrTypeReader *)v345;
    if (v381)
    {
      v202 = __p;
      if (__p)
      {
        v203 = v380;
        v204 = __p;
        if (v380 != __p)
        {
          do
            v203 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v203 - 1);
          while (v203 != v202);
          v204 = __p;
        }
        v380 = v202;
        operator delete(v204);
      }
      v205 = v377;
      if (v377)
      {
        v206 = v378;
        v207 = v377;
        if (v378 != v377)
        {
          do
          {
            v209 = *--v206;
            v208 = v209;
            *v206 = 0;
            if (v209)
              MEMORY[0x20BD002D4](v208, 0x1000C8077774924);
          }
          while (v206 != v205);
          v207 = v377;
        }
        v378 = v205;
        operator delete(v207);
      }
      if (v366 != v335)
        free(v366);
    }
    v200 = 1;
LABEL_405:
    if (v394 != v137)
      free(v394);
    v235 = v392;
    v392 = 0;
    if (v235)
      MEMORY[0x20BD002F8](v235, 0x1070C401CF53446);
    if (v200 != 7)
      return v11;
LABEL_410:
    v236 = *(_QWORD *)(a3 + 112);
    *(_QWORD *)(a3 + 112) = v236 - 1;
    if (!v236)
      goto LABEL_433;
  }
  v106 = 0;
  while (1)
  {
    v107 = v370;
    *(_QWORD *)&v390 = 0;
      break;
    *(_QWORD *)(v107 + 8 * v106) = v108;
    if (!v108)
      break;
    if (v104 == ++v106)
      goto LABEL_199;
  }
LABEL_472:
  mlir::OperationState::~OperationState((mlir::OperationState *)&v363);
  return 0;
}

void `anonymous namespace'::EncodingReader::emitError<char const(&)[54]>(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t v5;
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unsigned int v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  int64_t v32;
  int v33;
  const char *v34;
  size_t v35;
  _QWORD v36[2];
  int v37;
  void *__src;
  unsigned int v39;
  unsigned int v40;
  _BYTE v41[96];
  __int128 v42;
  uint64_t v43;
  __int128 __p;
  uint64_t v45;
  unsigned __int8 v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  mlir::emitError(a2, (uint64_t)v36);
  v5 = v36[0];
  if (v36[0])
  {
    v33 = 3;
    v34 = a3;
    v35 = strlen(a3);
    v6 = &v33;
    v7 = (char *)__src;
    if (v39 >= v40)
    {
      v31 = v39 + 1;
      if (__src <= &v33 && (char *)__src + 24 * v39 > (char *)&v33)
      {
        v32 = (char *)&v33 - (_BYTE *)__src;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v41, v31, 24);
        v7 = (char *)__src;
        v6 = (int *)((char *)__src + v32);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v41, v31, 24);
        v6 = &v33;
        v7 = (char *)__src;
      }
    }
    v8 = &v7[24 * v39];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v39;
    v5 = v36[0];
  }
  *(_QWORD *)a1 = v5;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  if (v46)
  {
    *(_QWORD *)(a1 + 8) = v36[1];
    v10 = v39;
    *(_DWORD *)(a1 + 16) = v37;
    *(_QWORD *)(a1 + 24) = a1 + 40;
    *(_QWORD *)(a1 + 32) = *(_QWORD *)"";
    if (!(_DWORD)v10 || v36 == (_QWORD *)a1)
    {
      v12 = 1;
      goto LABEL_17;
    }
    if (__src != v41)
    {
      *(_QWORD *)(a1 + 24) = __src;
      v11 = v40;
      *(_DWORD *)(a1 + 32) = v10;
      *(_DWORD *)(a1 + 36) = v11;
      __src = v41;
      v40 = 0;
      v12 = 1;
LABEL_16:
      v39 = 0;
LABEL_17:
      v14 = v45;
      *(_QWORD *)(a1 + 152) = v43;
      *(_OWORD *)(a1 + 136) = v42;
      v42 = 0uLL;
      *(_OWORD *)(a1 + 160) = __p;
      *(_QWORD *)(a1 + 176) = v14;
      v43 = 0;
      __p = 0uLL;
      v45 = 0;
      *(_BYTE *)(a1 + 184) = 1;
      if (v12)
      {
        v15 = (_QWORD *)__p;
        if ((_QWORD)__p)
        {
          v16 = (_QWORD *)*((_QWORD *)&__p + 1);
          v17 = (void *)__p;
          if (*((_QWORD *)&__p + 1) != (_QWORD)__p)
          {
            do
              v16 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v16 - 1);
            while (v16 != v15);
            v17 = (void *)__p;
          }
          *((_QWORD *)&__p + 1) = v15;
          operator delete(v17);
        }
        v18 = (_QWORD *)v42;
        if ((_QWORD)v42)
        {
          v19 = (_QWORD *)*((_QWORD *)&v42 + 1);
          v20 = (void *)v42;
          if (*((_QWORD *)&v42 + 1) != (_QWORD)v42)
          {
            do
            {
              v22 = *--v19;
              v21 = v22;
              *v19 = 0;
              if (v22)
                MEMORY[0x20BD002D4](v21, 0x1000C8077774924);
            }
            while (v19 != v18);
            v20 = (void *)v42;
          }
          *((_QWORD *)&v42 + 1) = v18;
          operator delete(v20);
        }
        if (__src != v41)
          free(__src);
        v46 = 0;
      }
      goto LABEL_34;
    }
    if (v10 < 5)
    {
      v13 = v10;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v10, 24);
      v13 = v39;
      if (!v39)
        goto LABEL_15;
    }
    memcpy(*(void **)(a1 + 24), __src, 24 * v13);
LABEL_15:
    *(_DWORD *)(a1 + 32) = v10;
    v12 = v46;
    goto LABEL_16;
  }
LABEL_34:
  mlir::InFlightDiagnostic::abandon(v36);
  if (v36[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v36);
  if (v46)
  {
    v23 = (_QWORD *)__p;
    if ((_QWORD)__p)
    {
      v24 = (_QWORD *)*((_QWORD *)&__p + 1);
      v25 = (void *)__p;
      if (*((_QWORD *)&__p + 1) != (_QWORD)__p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = (void *)__p;
      }
      *((_QWORD *)&__p + 1) = v23;
      operator delete(v25);
    }
    v26 = (_QWORD *)v42;
    if ((_QWORD)v42)
    {
      v27 = (_QWORD *)*((_QWORD *)&v42 + 1);
      v28 = (void *)v42;
      if (*((_QWORD *)&v42 + 1) != (_QWORD)v42)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = (void *)v42;
      }
      *((_QWORD *)&v42 + 1) = v26;
      operator delete(v28);
    }
    if (__src != v41)
      free(__src);
  }
}

uint64_t llvm::iplist_impl<llvm::simple_ilist<mlir::Operation>,llvm::ilist_traits<mlir::Operation>>::splice(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a4 != a5 && a2 != a5)
  {
    result = llvm::ilist_traits<mlir::Operation>::transferNodesFromList(result, a3, (uint64_t)a4, (uint64_t)a5);
    v8 = *a5;
    v9 = *a4;
    *(_QWORD *)(v9 + 8) = a5;
    *a5 = v9;
    v10 = *a2;
    *(_QWORD *)(v8 + 8) = a2;
    *a4 = v10;
    *(_QWORD *)(v10 + 8) = a4;
    *a2 = v8;
  }
  return result;
}

uint64_t mlir::BytecodeReader::Impl::parseRegion(uint64_t a1, uint64_t a2)
{
  _anonymous_namespace_::EncodingReader *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unsigned int v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;

  v4 = *(_anonymous_namespace_::EncodingReader **)(a2 + 16);
  v20 = 0;
    return 0;
  v5 = v20;
  if (!v20)
    return 1;
  v19 = 0;
    return 0;
  *(_DWORD *)(a2 + 32) = v19;
  *(_DWORD *)(a2 + 48) = 0;
  if (v5 > *(unsigned int *)(a2 + 52))
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 40, (void *)(a2 + 56), v5, 8);
  do
  {
    v6 = operator new();
    *(_OWORD *)v6 = 0u;
    *(_OWORD *)(v6 + 16) = 0u;
    *(_QWORD *)(v6 + 32) = v6 + 32;
    *(_QWORD *)(v6 + 40) = v6 + 32;
    *(_QWORD *)(v6 + 56) = 0;
    *(_QWORD *)(v6 + 64) = 0;
    *(_QWORD *)(v6 + 48) = 0;
    v7 = *(unsigned int *)(a2 + 48);
    if (v7 >= *(unsigned int *)(a2 + 52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 40, (void *)(a2 + 56), v7 + 1, 8);
      v7 = *(unsigned int *)(a2 + 48);
    }
    *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * v7) = v6;
    v8 = *(_DWORD *)(a2 + 48) + 1;
    *(_DWORD *)(a2 + 48) = v8;
    v9 = *(uint64_t **)a2;
    v10 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 8 * v8 - 8);
    llvm::ilist_traits<mlir::Block>::addNodeToList(*(_QWORD *)a2, v10);
    v11 = *v9;
    *(_QWORD *)(v10 + 8) = *v9;
    *(_QWORD *)(v10 + 16) = v9;
    v10 += 8;
    *(_QWORD *)(v11 + 8) = v10;
    *v9 = v10;
    --v5;
  }
  while (v5);
  v13 = *(_QWORD *)(a1 + 688);
  v14 = (*(_QWORD *)(v13 - 48) - *(_QWORD *)(v13 - 56)) >> 3;
  v15 = *(unsigned int *)(v13 - 24);
  if (v15 >= *(_DWORD *)(v13 - 20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v13 - 32, (void *)(v13 - 16), v15 + 1, 4);
    LODWORD(v15) = *(_DWORD *)(v13 - 24);
  }
  *(_DWORD *)(*(_QWORD *)(v13 - 32) + 4 * v15) = v14;
  ++*(_DWORD *)(v13 - 24);
  v16 = *(_QWORD *)(v13 - 56);
  v17 = (*(_QWORD *)(v13 - 48) - v16) >> 3;
  v18 = *(unsigned int *)(a2 + 32);
  if (v17 >= v17 + v18)
  {
    if (v17 > v17 + v18)
      *(_QWORD *)(v13 - 48) = v16 + 8 * (v17 + v18);
  }
  else
  {
    std::vector<mlir::Value>::__append((void **)(v13 - 56), v18);
  }
  *(_QWORD *)(a2 + 104) = *(_QWORD *)(*(_QWORD *)a2 + 8);
  return mlir::BytecodeReader::Impl::parseBlockHeader(a1, v4, a2);
}

uint64_t mlir::BytecodeReader::Impl::createForwardRef(mlir::BytecodeReader::Impl *this, const mlir::OperationState *a2)
{
  ZinIrHalH13g *v3;
  ZinIrHalH13g *v4;
  ZinIrHalH13g **v5;
  uint64_t v6;
  ZinIrHalH13g *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;

  v3 = (mlir::BytecodeReader::Impl *)((char *)this + 832);
  v4 = (ZinIrHalH13g *)*((_QWORD *)this + 104);
  v5 = (ZinIrHalH13g **)((char *)this + 760);
  if (v4 == v3)
  {
    v7 = (ZinIrHalH13g *)mlir::Operation::create((mlir::BytecodeReader::Impl *)((char *)this + 872), a2);
    llvm::ilist_traits<mlir::Operation>::addNodeToList((uint64_t)this + 760, (uint64_t)v7);
    ZinIrHalH13g::~ZinIrHalH13g(v7);
    v8 = *((_QWORD *)this + 95);
    *v9 = v8;
    v9[1] = v5;
    *(_QWORD *)(v8 + 8) = v9;
    *((_QWORD *)this + 95) = v9;
    ZinIrHalH13g::~ZinIrHalH13g(v7);
  }
  else
  {
    ZinIrHalH13g::~ZinIrHalH13g(v4);
    mlir::Operation::moveBefore(v6, (mlir::BytecodeReader::Impl *)((char *)this + 728), (uint64_t *)this + 95);
  }
  ZinIrHalH13g::~ZinIrHalH13g(*v5);
  return v10 - 16;
}

BOOL mlir::isBytecode(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) >= 4uLL && **(_DWORD **)a1 == 1391414349;
}

uint64_t mlir::readBytecodeFile(_OWORD *a1, uint64_t a2, mlir::StringAttr **a3)
{
  __int128 v3;
  uint64_t result;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  std::__shared_weak_count *v10;
  _OWORD v11[2];

  v3 = a1[1];
  v11[0] = *a1;
  v11[1] = v3;
  v9 = 0;
  v10 = 0;
  result = readBytecodeFileImpl((uint64_t)v11, a2, a3, (uint64_t)&v9);
  v5 = result;
  v6 = v10;
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
      return v5;
    }
  }
  return result;
}

uint64_t readBytecodeFileImpl(uint64_t a1, uint64_t a2, mlir::StringAttr **a3, uint64_t a4)
{
  mlir::MLIRContext *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v19;
  uint64_t v20;
  _OWORD v21[2];
  const char *v22;
  __int16 v23;
  llvm *v24[3];
  void *v25;
  uint64_t v26;
  void *v27;
  _QWORD *v28;
  void *__p;
  _QWORD *v30;
  char v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v8 = (mlir::MLIRContext *)mlir::FileLineColLoc::get(*a3, *(const char **)(a1 + 16), *(_QWORD *)(a1 + 24), 0, 0);
  if (*(_QWORD *)(a1 + 8) >= 4uLL && **(_DWORD **)a1 == 1391414349)
  {
    v19 = *(_OWORD *)(a1 + 16);
    v21[0] = *(_OWORD *)a1;
    v21[1] = v19;
    mlir::BytecodeReader::Impl::Impl((uint64_t)v24, v8, a3, 0, v21, a4);
    mlir::BytecodeReader::Impl::read((uint64_t *)v24, a2, 0, v20);
    mlir::BytecodeReader::Impl::~Impl(v24);
  }
  v22 = "input buffer is not an MLIR bytecode file";
  v23 = 259;
  mlir::emitError((uint64_t)v8, (uint64_t)&v22, (uint64_t)v24);
  v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v24);
  if (v24[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  if (v31)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v30;
      v12 = __p;
      if (v30 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v30 = v10;
      operator delete(v12);
    }
    v13 = v27;
    if (v27)
    {
      v14 = v28;
      v15 = v27;
      if (v28 != v27)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v27;
      }
      v28 = v13;
      operator delete(v15);
    }
    if (v25 != &v26)
      free(v25);
  }
  return v9;
}

uint64_t mlir::readBytecodeFile(const llvm::MemoryBuffer ****a1, uint64_t a2, mlir::StringAttr **a3)
{
  _BYTE v7[32];

  llvm::MemoryBufferRef::MemoryBufferRef((llvm::MemoryBufferRef *)v7, ***a1);
  return readBytecodeFileImpl((uint64_t)v7, a2, a3, (uint64_t)a1);
}

uint64_t mlir::Diagnostic::append<char const(&)[20],unsigned long &,char const(&)[18],unsigned long,char const(&)[8]>(uint64_t a1, char *__s, char **a3, char *a4, char **a5, char *a6)
{
  size_t v12;
  unint64_t v13;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  __int128 v17;
  unsigned int v18;
  uint64_t v19;
  char *v20;
  unint64_t v21;
  int *v22;
  uint64_t v23;
  __int128 v24;
  unint64_t v26;
  BOOL v27;
  unint64_t v28;
  BOOL v29;
  char *v30;
  char *v31;
  int v32;
  char *v33;
  size_t v34;

  v12 = strlen(__s);
  v13 = *(_QWORD *)(a1 + 16);
  v32 = 3;
  v33 = __s;
  v34 = v12;
  v14 = *(unsigned int *)(a1 + 24);
  v15 = &v32;
  if (v14 >= *(_DWORD *)(a1 + 28))
  {
    v26 = v14 + 1;
    v27 = v13 + 24 * v14 > (unint64_t)&v32;
    if (v13 <= (unint64_t)&v32 && v27)
    {
      v30 = (char *)&v32 - v13;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v26, 24);
      v13 = *(_QWORD *)(a1 + 16);
      v15 = (int *)&v30[v13];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v26, 24);
      v13 = *(_QWORD *)(a1 + 16);
      v15 = &v32;
    }
  }
  v16 = v13 + 24 * *(unsigned int *)(a1 + 24);
  v17 = *(_OWORD *)v15;
  *(_QWORD *)(v16 + 16) = *((_QWORD *)v15 + 2);
  *(_OWORD *)v16 = v17;
  v18 = *(_DWORD *)(a1 + 28);
  v19 = (*(_DWORD *)(a1 + 24) + 1);
  *(_DWORD *)(a1 + 24) = v19;
  v20 = *a3;
  v32 = 5;
  v33 = v20;
  v21 = *(_QWORD *)(a1 + 16);
  v22 = &v32;
  if (v19 >= v18)
  {
    v28 = v19 + 1;
    v29 = v21 + 24 * v19 > (unint64_t)&v32;
    if (v21 <= (unint64_t)&v32 && v29)
    {
      v31 = (char *)&v32 - v21;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v28, 24);
      v21 = *(_QWORD *)(a1 + 16);
      v22 = (int *)&v31[v21];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v28, 24);
      v21 = *(_QWORD *)(a1 + 16);
      v22 = &v32;
    }
  }
  v23 = v21 + 24 * *(unsigned int *)(a1 + 24);
  v24 = *(_OWORD *)v22;
  *(_QWORD *)(v23 + 16) = *((_QWORD *)v22 + 2);
  *(_OWORD *)v23 = v24;
  ++*(_DWORD *)(a1 + 24);
  return mlir::Diagnostic::append<char const(&)[18],unsigned long,char const(&)[8]>(a1, a4, a5, a6);
}

uint64_t mlir::Diagnostic::append<char const(&)[18],unsigned long,char const(&)[8]>(uint64_t a1, char *__s, char **a3, char *a4)
{
  size_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int *v12;
  uint64_t v13;
  __int128 v14;
  unint64_t v16;
  BOOL v17;
  char *v18;
  int v19;
  char *v20;
  size_t v21;

  v8 = strlen(__s);
  v9 = a1 + 16;
  v10 = *(_QWORD *)(a1 + 16);
  v19 = 3;
  v20 = __s;
  v21 = v8;
  v11 = *(unsigned int *)(a1 + 24);
  v12 = &v19;
  if (v11 >= *(_DWORD *)(a1 + 28))
  {
    v16 = v11 + 1;
    v17 = v10 + 24 * v11 > (unint64_t)&v19;
    if (v10 <= (unint64_t)&v19 && v17)
    {
      v18 = (char *)&v19 - v10;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v9, (void *)(a1 + 32), v16, 24);
      v10 = *(_QWORD *)(a1 + 16);
      v12 = (int *)&v18[v10];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v9, (void *)(a1 + 32), v16, 24);
      v10 = *(_QWORD *)(a1 + 16);
      v12 = &v19;
    }
  }
  v13 = v10 + 24 * *(unsigned int *)(a1 + 24);
  v14 = *(_OWORD *)v12;
  *(_QWORD *)(v13 + 16) = *((_QWORD *)v12 + 2);
  *(_OWORD *)v13 = v14;
  ++*(_DWORD *)(a1 + 24);
  return mlir::Diagnostic::append<unsigned long,char const(&)[8]>(a1, a3, a4);
}

uint64_t mlir::Diagnostic::append<unsigned long,char const(&)[8]>(uint64_t a1, char **a2, char *__s)
{
  unint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  int *v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  size_t v13;
  unint64_t v14;
  int *v15;
  uint64_t v16;
  __int128 v17;
  unint64_t v19;
  BOOL v20;
  unint64_t v21;
  char *v22;
  char *v23;
  int v24;
  char *v25;
  size_t v26;

  v6 = a1 + 16;
  v5 = *(_QWORD *)(a1 + 16);
  v7 = *a2;
  v24 = 5;
  v25 = v7;
  v8 = *(unsigned int *)(a1 + 24);
  v9 = &v24;
  if (v8 >= *(_DWORD *)(a1 + 28))
  {
    v19 = v8 + 1;
    v20 = v5 + 24 * v8 > (unint64_t)&v24;
    if (v5 <= (unint64_t)&v24 && v20)
    {
      v22 = (char *)&v24 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v19, 24);
      v5 = *(_QWORD *)(a1 + 16);
      v9 = (int *)&v22[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v19, 24);
      v5 = *(_QWORD *)(a1 + 16);
      v9 = &v24;
    }
  }
  v10 = v5 + 24 * *(unsigned int *)(a1 + 24);
  v11 = *(_OWORD *)v9;
  *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
  *(_OWORD *)v10 = v11;
  v12 = (*(_DWORD *)(a1 + 24) + 1);
  *(_DWORD *)(a1 + 24) = v12;
  v13 = strlen(__s);
  v24 = 3;
  v25 = __s;
  v26 = v13;
  v14 = *(_QWORD *)(a1 + 16);
  v15 = &v24;
  if (v12 >= *(_DWORD *)(a1 + 28))
  {
    v21 = v12 + 1;
    if (v14 <= (unint64_t)&v24 && v14 + 24 * v12 > (unint64_t)&v24)
    {
      v23 = (char *)&v24 - v14;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(a1 + 32), v21, 24);
      v14 = *(_QWORD *)(a1 + 16);
      v15 = (int *)&v23[v14];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(a1 + 32), v21, 24);
      v14 = *(_QWORD *)(a1 + 16);
      v15 = &v24;
    }
  }
  v16 = v14 + 24 * *(unsigned int *)(a1 + 24);
  v17 = *(_OWORD *)v15;
  *(_QWORD *)(v16 + 16) = *((_QWORD *)v15 + 2);
  *(_OWORD *)v16 = v17;
  ++*(_DWORD *)(a1 + 24);
  return a1;
}

uint64_t `anonymous namespace'::EncodingReader::parseByte<unsigned char>(_QWORD *a1, _BYTE *a2)
{
  _BYTE *v2;
  uint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[3];
  void *v14;
  uint64_t v15;
  void *v16;
  _QWORD *v17;
  void *__p;
  _QWORD *v19;
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v2 = (_BYTE *)a1[2];
  if (v2 == (_BYTE *)(*a1 + a1[1]))
  {
    v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v13);
    if (v13[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v13);
    if (v20)
    {
      v5 = __p;
      if (__p)
      {
        v6 = v19;
        v7 = __p;
        if (v19 != __p)
        {
          do
            v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
          while (v6 != v5);
          v7 = __p;
        }
        v19 = v5;
        operator delete(v7);
      }
      v8 = v16;
      if (v16)
      {
        v9 = v17;
        v10 = v16;
        if (v17 != v16)
        {
          do
          {
            v12 = *--v9;
            v11 = v12;
            *v9 = 0;
            if (v12)
              MEMORY[0x20BD002D4](v11, 0x1000C8077774924);
          }
          while (v9 != v8);
          v10 = v16;
        }
        v17 = v8;
        operator delete(v10);
      }
      if (v14 != &v15)
        free(v14);
    }
  }
  else
  {
    a1[2] = v2 + 1;
    *a2 = *v2;
    return 1;
  }
  return v3;
}

uint64_t `anonymous namespace'::EncodingReader::alignTo(_anonymous_namespace_::EncodingReader *this, __int32 a2, int8x8_t a3)
{
  uint8x8_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  std::string::size_type v10;
  std::string *p_dst;
  const void **v12;
  void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  int v17;
  _BYTE *v18;
  _BYTE *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  std::string *v25;
  std::string::size_type v26;
  std::string *v27;
  std::string::size_type v28;
  const void **v29;
  int v30;
  _BYTE *v31;
  void *v32;
  int v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  _QWORD *v52;
  void *v53;
  _QWORD *v54;
  _QWORD *v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  _QWORD *v62;
  _QWORD *v63;
  void *v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v68;
  int64_t v69;
  std::string __dst;
  std::string v71;
  void *v72[2];
  std::string::size_type v73;
  unsigned __int8 v74;
  void **v75;
  const char *v76;
  uint64_t v77;
  void *v78;
  uint64_t v79;
  _BYTE v80[57];
  __int128 v81;
  uint64_t v82;
  __int128 v83;
  uint64_t v84;
  char v85;
  const void **v86;
  const char *v87;
  int v88;
  void *__src;
  uint64_t v90;
  _BYTE v91[96];
  __int128 v92;
  uint64_t v93;
  __int128 __p;
  uint64_t v95;
  unsigned __int8 v96;
  uint64_t v97;

  v97 = *MEMORY[0x24BDAC8D0];
  a3.i32[0] = a2;
  v4 = (uint8x8_t)vcnt_s8(a3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.i32[0] == 1)
  {
    v5 = (a2 - 1);
    do
    {
      if ((v5 & *((_QWORD *)this + 2)) == 0)
        return 1;
      v74 = 0;
        return 0;
      v6 = v74;
    }
    while (v74 == 203);
    if (v74)
    {
      v7 = 16;
      do
      {
        *((_BYTE *)&v86 + v7--) = llvm::hexdigit(unsigned int,BOOL)::LUT[v6 & 0xF];
        v8 = v6 > 0xF;
        v6 >>= 4;
      }
      while (v8);
      v9 = v7 + 1;
      v10 = 16 - v7;
      if ((unint64_t)(16 - v7) >= 0x7FFFFFFFFFFFFFF8)
        abort();
    }
    else
    {
      LOBYTE(v88) = 48;
      v9 = 16;
      v10 = 1;
    }
    if (v10 > 0x16)
    {
      v23 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v10 | 7) != 0x17)
        v23 = v10 | 7;
      v24 = v23 + 1;
      p_dst = (std::string *)operator new(v23 + 1);
      __dst.__r_.__value_.__l.__size_ = v10;
      __dst.__r_.__value_.__r.__words[2] = v24 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
      if (v9 == 17)
      {
LABEL_30:
        p_dst->__r_.__value_.__s.__data_[0] = 0;
        v25 = std::string::insert(&__dst, 0, "expected alignment byte (0xCB), but got: '0x");
        v26 = v25->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v71.__r_.__value_.__l.__data_ = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
        v71.__r_.__value_.__r.__words[2] = v26;
        v25->__r_.__value_.__l.__size_ = 0;
        v25->__r_.__value_.__r.__words[2] = 0;
        v25->__r_.__value_.__r.__words[0] = 0;
        v27 = std::string::append(&v71, "'");
        v28 = v27->__r_.__value_.__r.__words[2];
        *(_OWORD *)v72 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
        v73 = v28;
        v27->__r_.__value_.__l.__size_ = 0;
        v27->__r_.__value_.__r.__words[2] = 0;
        v27->__r_.__value_.__r.__words[0] = 0;
        mlir::emitError(*((_QWORD *)this + 3), (uint64_t)&v86);
        v29 = v86;
        if (v86)
        {
          LOWORD(v79) = 260;
          v75 = v72;
          mlir::Diagnostic::operator<<((uint64_t)&v87, (const void ***)&v75);
          v29 = v86;
        }
        v75 = (void **)v29;
        LOBYTE(v76) = 0;
        v85 = 0;
        if (!v96)
        {
LABEL_94:
          mlir::InFlightDiagnostic::abandon(&v86);
          if (v86)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v86);
          if (v96)
          {
            v51 = (_QWORD *)__p;
            if ((_QWORD)__p)
            {
              v52 = (_QWORD *)*((_QWORD *)&__p + 1);
              v53 = (void *)__p;
              if (*((_QWORD *)&__p + 1) != (_QWORD)__p)
              {
                do
                  v52 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v52 - 1);
                while (v52 != v51);
                v53 = (void *)__p;
              }
              *((_QWORD *)&__p + 1) = v51;
              operator delete(v53);
            }
            v54 = (_QWORD *)v92;
            if ((_QWORD)v92)
            {
              v55 = (_QWORD *)*((_QWORD *)&v92 + 1);
              v56 = (void *)v92;
              if (*((_QWORD *)&v92 + 1) != (_QWORD)v92)
              {
                do
                {
                  v58 = *--v55;
                  v57 = v58;
                  *v55 = 0;
                  if (v58)
                    MEMORY[0x20BD002D4](v57, 0x1000C8077774924);
                }
                while (v55 != v54);
                v56 = (void *)v92;
              }
              *((_QWORD *)&v92 + 1) = v54;
              operator delete(v56);
            }
            if (__src != v91)
              free(__src);
          }
          v21 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v75);
          if (v75)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v75);
          if (v85)
          {
            v59 = (_QWORD *)v83;
            if ((_QWORD)v83)
            {
              v60 = (_QWORD *)*((_QWORD *)&v83 + 1);
              v61 = (void *)v83;
              if (*((_QWORD *)&v83 + 1) != (_QWORD)v83)
              {
                do
                  v60 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v60 - 1);
                while (v60 != v59);
                v61 = (void *)v83;
              }
              *((_QWORD *)&v83 + 1) = v59;
              operator delete(v61);
            }
            v62 = (_QWORD *)v81;
            if ((_QWORD)v81)
            {
              v63 = (_QWORD *)*((_QWORD *)&v81 + 1);
              v64 = (void *)v81;
              if (*((_QWORD *)&v81 + 1) != (_QWORD)v81)
              {
                do
                {
                  v66 = *--v63;
                  v65 = v66;
                  *v63 = 0;
                  if (v66)
                    MEMORY[0x20BD002D4](v65, 0x1000C8077774924);
                }
                while (v63 != v62);
                v64 = (void *)v81;
              }
              *((_QWORD *)&v81 + 1) = v62;
              operator delete(v64);
            }
            if (v78 != v80)
              free(v78);
          }
          if (SHIBYTE(v73) < 0)
          {
            operator delete(v72[0]);
            if ((SHIBYTE(v71.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_132:
              if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                return v21;
LABEL_136:
              operator delete(__dst.__r_.__value_.__l.__data_);
              return v21;
            }
          }
          else if ((SHIBYTE(v71.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
            goto LABEL_132;
          }
          operator delete(v71.__r_.__value_.__l.__data_);
          if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            return v21;
          goto LABEL_136;
        }
        v76 = v87;
        v30 = v90;
        LODWORD(v77) = v88;
        v31 = v80;
        v78 = v80;
        v79 = *(_QWORD *)"";
        if (!(_DWORD)v90)
        {
          v33 = 1;
          goto LABEL_90;
        }
        v32 = __src;
        if (__src != v91)
        {
          v78 = __src;
          v79 = v90;
          __src = v91;
          HIDWORD(v90) = 0;
          v33 = 1;
LABEL_89:
          LODWORD(v90) = 0;
LABEL_90:
          v81 = v92;
          v82 = v93;
          v92 = 0uLL;
          v83 = __p;
          v84 = v95;
          v93 = 0;
          __p = 0uLL;
          v95 = 0;
          v85 = 1;
          if (v33)
          {
            if (__src != v91)
              free(__src);
            v96 = 0;
          }
          goto LABEL_94;
        }
        if (v90 < 5)
        {
          v50 = v90;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v80, v90, 24);
          v50 = v90;
          if (!(_DWORD)v90)
          {
LABEL_88:
            LODWORD(v79) = v30;
            v33 = v96;
            goto LABEL_89;
          }
          v32 = __src;
          v31 = v78;
        }
        memcpy(v31, v32, 24 * v50);
        goto LABEL_88;
      }
    }
    else
    {
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v10;
      p_dst = &__dst;
      if (v9 == 17)
        goto LABEL_30;
    }
    memcpy(p_dst, (char *)&v86 + v9, v10);
    p_dst = (std::string *)((char *)p_dst + v10);
    goto LABEL_30;
  }
  mlir::emitError(*((_QWORD *)this + 3), (uint64_t)&v86);
  v12 = v86;
  if (v86)
  {
    LODWORD(v75) = 3;
    v76 = "expected alignment to be a power-of-two";
    v77 = 39;
    v13 = &v75;
    v14 = (char *)__src;
    if (v90 >= HIDWORD(v90))
    {
      v68 = v90 + 1;
      if (__src <= &v75 && (char *)__src + 24 * v90 > (char *)&v75)
      {
        v69 = (char *)&v75 - (_BYTE *)__src;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v91, v68, 24);
        v14 = (char *)__src;
        v13 = (void ***)((char *)__src + v69);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v91, v68, 24);
        v13 = &v75;
        v14 = (char *)__src;
      }
    }
    v15 = &v14[24 * v90];
    v16 = *(_OWORD *)v13;
    *((_QWORD *)v15 + 2) = v13[2];
    *(_OWORD *)v15 = v16;
    LODWORD(v90) = v90 + 1;
    v12 = v86;
  }
  v75 = (void **)v12;
  LOBYTE(v76) = 0;
  v85 = 0;
  if (v96)
  {
    v76 = v87;
    v17 = v90;
    LODWORD(v77) = v88;
    v18 = v80;
    v78 = v80;
    v79 = *(_QWORD *)"";
    if (!(_DWORD)v90)
    {
      v20 = 1;
      goto LABEL_42;
    }
    v19 = v91;
    if (__src != v91)
    {
      v78 = __src;
      v79 = v90;
      __src = v91;
      HIDWORD(v90) = 0;
      v20 = 1;
LABEL_41:
      LODWORD(v90) = 0;
LABEL_42:
      v81 = v92;
      v82 = v93;
      v92 = 0uLL;
      v83 = __p;
      v84 = v95;
      v93 = 0;
      __p = 0uLL;
      v95 = 0;
      v85 = 1;
      if (v20)
      {
        if (__src != v91)
          free(__src);
        v96 = 0;
      }
      goto LABEL_46;
    }
    if (v90 < 5)
    {
      v22 = v90;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v80, v90, 24);
      v22 = v90;
      if (!(_DWORD)v90)
      {
LABEL_40:
        LODWORD(v79) = v17;
        v20 = v96;
        goto LABEL_41;
      }
      v19 = __src;
      v18 = v78;
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_40;
  }
LABEL_46:
  mlir::InFlightDiagnostic::abandon(&v86);
  if (v86)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v86);
  if (v96)
  {
    v34 = (_QWORD *)__p;
    if ((_QWORD)__p)
    {
      v35 = (_QWORD *)*((_QWORD *)&__p + 1);
      v36 = (void *)__p;
      if (*((_QWORD *)&__p + 1) != (_QWORD)__p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = (void *)__p;
      }
      *((_QWORD *)&__p + 1) = v34;
      operator delete(v36);
    }
    v37 = (_QWORD *)v92;
    if ((_QWORD)v92)
    {
      v38 = (_QWORD *)*((_QWORD *)&v92 + 1);
      v39 = (void *)v92;
      if (*((_QWORD *)&v92 + 1) != (_QWORD)v92)
      {
        do
        {
          v41 = *--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            MEMORY[0x20BD002D4](v40, 0x1000C8077774924);
        }
        while (v38 != v37);
        v39 = (void *)v92;
      }
      *((_QWORD *)&v92 + 1) = v37;
      operator delete(v39);
    }
    if (__src != v91)
      free(__src);
  }
  v21 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v75);
  if (v75)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v75);
  if (v85)
  {
    v42 = (_QWORD *)v83;
    if ((_QWORD)v83)
    {
      v43 = (_QWORD *)*((_QWORD *)&v83 + 1);
      v44 = (void *)v83;
      if (*((_QWORD *)&v83 + 1) != (_QWORD)v83)
      {
        do
          v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
        while (v43 != v42);
        v44 = (void *)v83;
      }
      *((_QWORD *)&v83 + 1) = v42;
      operator delete(v44);
    }
    v45 = (_QWORD *)v81;
    if ((_QWORD)v81)
    {
      v46 = (_QWORD *)*((_QWORD *)&v81 + 1);
      v47 = (void *)v81;
      if (*((_QWORD *)&v81 + 1) != (_QWORD)v81)
      {
        do
        {
          v49 = *--v46;
          v48 = v49;
          *v46 = 0;
          if (v49)
            MEMORY[0x20BD002D4](v48, 0x1000C8077774924);
        }
        while (v46 != v45);
        v47 = (void *)v81;
      }
      *((_QWORD *)&v81 + 1) = v45;
      operator delete(v47);
    }
    if (v78 != v80)
      free(v78);
  }
  return v21;
}

uint64_t `anonymous namespace'::EncodingReader::parseBytes(_QWORD *a1, char *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  char *v14;
  char *v15;
  _QWORD v16[3];
  void *v17;
  uint64_t v18;
  void *v19;
  _QWORD *v20;
  void *__p;
  _QWORD *v22;
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v15 = a2;
  v3 = a1[2];
  if (*a1 + a1[1] - v3 >= (unint64_t)a2)
  {
    *a3 = v3;
    a3[1] = a2;
    a1[2] += a2;
    return 1;
  }
  else
  {
    v14 = (char *)(*a1 + a1[1] - v3);
    v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v16);
    if (v16[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v16);
    if (v23)
    {
      v5 = __p;
      if (__p)
      {
        v6 = v22;
        v7 = __p;
        if (v22 != __p)
        {
          do
            v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
          while (v6 != v5);
          v7 = __p;
        }
        v22 = v5;
        operator delete(v7);
      }
      v8 = v19;
      if (v19)
      {
        v9 = v20;
        v10 = v19;
        if (v20 != v19)
        {
          do
          {
            v12 = *--v9;
            v11 = v12;
            *v9 = 0;
            if (v12)
              MEMORY[0x20BD002D4](v11, 0x1000C8077774924);
          }
          while (v9 != v8);
          v10 = v19;
        }
        v20 = v8;
        operator delete(v10);
      }
      if (v17 != &v18)
        free(v17);
    }
  }
  return v4;
}

uint64_t mlir::Diagnostic::append<char const(&)[21],unsigned int>(uint64_t a1, char *__s, unsigned int *a3)
{
  size_t v6;
  unint64_t v7;
  uint64_t v8;
  int *v9;
  uint64_t v10;
  __int128 v11;
  unsigned int v12;
  uint64_t v13;
  char *v14;
  unint64_t v15;
  int *v16;
  uint64_t v17;
  __int128 v18;
  unint64_t v20;
  BOOL v21;
  unint64_t v22;
  BOOL v23;
  char *v24;
  char *v25;
  int v26;
  char *v27;
  size_t v28;

  v6 = strlen(__s);
  v7 = *(_QWORD *)(a1 + 16);
  v26 = 3;
  v27 = __s;
  v28 = v6;
  v8 = *(unsigned int *)(a1 + 24);
  v9 = &v26;
  if (v8 >= *(_DWORD *)(a1 + 28))
  {
    v20 = v8 + 1;
    v21 = v7 + 24 * v8 > (unint64_t)&v26;
    if (v7 <= (unint64_t)&v26 && v21)
    {
      v24 = (char *)&v26 - v7;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v20, 24);
      v7 = *(_QWORD *)(a1 + 16);
      v9 = (int *)&v24[v7];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v20, 24);
      v7 = *(_QWORD *)(a1 + 16);
      v9 = &v26;
    }
  }
  v10 = v7 + 24 * *(unsigned int *)(a1 + 24);
  v11 = *(_OWORD *)v9;
  *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
  *(_OWORD *)v10 = v11;
  v12 = *(_DWORD *)(a1 + 28);
  v13 = (*(_DWORD *)(a1 + 24) + 1);
  *(_DWORD *)(a1 + 24) = v13;
  v14 = (char *)*a3;
  v26 = 5;
  v27 = v14;
  v15 = *(_QWORD *)(a1 + 16);
  v16 = &v26;
  if (v13 >= v12)
  {
    v22 = v13 + 1;
    v23 = v15 + 24 * v13 > (unint64_t)&v26;
    if (v15 <= (unint64_t)&v26 && v23)
    {
      v25 = (char *)&v26 - v15;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v22, 24);
      v15 = *(_QWORD *)(a1 + 16);
      v16 = (int *)&v25[v15];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v22, 24);
      v15 = *(_QWORD *)(a1 + 16);
      v16 = &v26;
    }
  }
  v17 = v15 + 24 * *(unsigned int *)(a1 + 24);
  v18 = *(_OWORD *)v16;
  *(_QWORD *)(v17 + 16) = *((_QWORD *)v16 + 2);
  *(_OWORD *)v17 = v18;
  ++*(_DWORD *)(a1 + 24);
  return a1;
}

void `anonymous namespace'::EncodingReader::emitError<char const(&)[21],unsigned long &,char const(&)[18],unsigned long,char const(&)[8]>(uint64_t a1, uint64_t a2, char **a3, char **a4)
{
  uint64_t v7;
  unint64_t v8;
  int v9;
  int v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  void *__src;
  unsigned int v32;
  int v33;
  _BYTE v34[96];
  void *v35[2];
  uint64_t v36;
  void *__p[2];
  uint64_t v38;
  unsigned __int8 v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  mlir::emitError(a2, (uint64_t)&v28);
  v7 = v28;
  if (v28)
  {
    mlir::Diagnostic::append<char const(&)[20],unsigned long &,char const(&)[18],unsigned long,char const(&)[8]>((uint64_t)&v29, "attempting to parse ", a3, " bytes when only ", a4, " remain");
    v7 = v28;
  }
  *(_QWORD *)a1 = v7;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  if (v39)
  {
    *(_QWORD *)(a1 + 8) = v29;
    v8 = v32;
    *(_DWORD *)(a1 + 16) = v30;
    *(_QWORD *)(a1 + 24) = a1 + 40;
    *(_QWORD *)(a1 + 32) = *(_QWORD *)"";
    if (!(_DWORD)v8 || &v28 == (uint64_t *)a1)
    {
      v10 = 1;
      goto LABEL_16;
    }
    if (__src != v34)
    {
      *(_QWORD *)(a1 + 24) = __src;
      v9 = v33;
      *(_DWORD *)(a1 + 32) = v8;
      *(_DWORD *)(a1 + 36) = v9;
      __src = v34;
      v33 = 0;
      v10 = 1;
LABEL_15:
      v32 = 0;
LABEL_16:
      *(_OWORD *)(a1 + 136) = *(_OWORD *)v35;
      *(_QWORD *)(a1 + 152) = v36;
      v35[0] = 0;
      v35[1] = 0;
      *(_OWORD *)(a1 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a1 + 176) = v38;
      v36 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v38 = 0;
      *(_BYTE *)(a1 + 184) = 1;
      if (v10)
      {
        v12 = __p[0];
        if (__p[0])
        {
          v13 = __p[1];
          v14 = __p[0];
          if (__p[1] != __p[0])
          {
            do
              v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
            while (v13 != v12);
            v14 = __p[0];
          }
          __p[1] = v12;
          operator delete(v14);
        }
        v15 = v35[0];
        if (v35[0])
        {
          v16 = v35[1];
          v17 = v35[0];
          if (v35[1] != v35[0])
          {
            do
            {
              v19 = *--v16;
              v18 = v19;
              *v16 = 0;
              if (v19)
                MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
            }
            while (v16 != v15);
            v17 = v35[0];
          }
          v35[1] = v15;
          operator delete(v17);
        }
        if (__src != v34)
          free(__src);
        v39 = 0;
      }
      goto LABEL_33;
    }
    if (v8 < 5)
    {
      v11 = v8;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v8, 24);
      v11 = v32;
      if (!v32)
        goto LABEL_14;
    }
    memcpy(*(void **)(a1 + 24), __src, 24 * v11);
LABEL_14:
    *(_DWORD *)(a1 + 32) = v8;
    v10 = v39;
    goto LABEL_15;
  }
LABEL_33:
  mlir::InFlightDiagnostic::abandon(&v28);
  if (v28)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v28);
  if (v39)
  {
    v20 = __p[0];
    if (__p[0])
    {
      v21 = __p[1];
      v22 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
        while (v21 != v20);
        v22 = __p[0];
      }
      __p[1] = v20;
      operator delete(v22);
    }
    v23 = v35[0];
    if (v35[0])
    {
      v24 = v35[1];
      v25 = v35[0];
      if (v35[1] != v35[0])
      {
        do
        {
          v27 = *--v24;
          v26 = v27;
          *v24 = 0;
          if (v27)
            MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
        }
        while (v24 != v23);
        v25 = v35[0];
      }
      v35[1] = v23;
      operator delete(v25);
    }
    if (__src != v34)
      free(__src);
  }
}

uint64_t mlir::Diagnostic::append<char const(&)[18],unsigned long long &,char const(&)[36],unsigned long long &>(uint64_t a1, char *__s, char **a3, char *a4, char **a5)
{
  size_t v10;
  unint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  __int128 v15;
  unsigned int v16;
  uint64_t v17;
  char *v18;
  unint64_t v19;
  int *v20;
  uint64_t v21;
  __int128 v22;
  unint64_t v24;
  BOOL v25;
  unint64_t v26;
  BOOL v27;
  char *v28;
  char *v29;
  int v30;
  char *v31;
  size_t v32;

  v10 = strlen(__s);
  v11 = *(_QWORD *)(a1 + 16);
  v30 = 3;
  v31 = __s;
  v32 = v10;
  v12 = *(unsigned int *)(a1 + 24);
  v13 = &v30;
  if (v12 >= *(_DWORD *)(a1 + 28))
  {
    v24 = v12 + 1;
    v25 = v11 + 24 * v12 > (unint64_t)&v30;
    if (v11 <= (unint64_t)&v30 && v25)
    {
      v28 = (char *)&v30 - v11;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v24, 24);
      v11 = *(_QWORD *)(a1 + 16);
      v13 = (int *)&v28[v11];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v24, 24);
      v11 = *(_QWORD *)(a1 + 16);
      v13 = &v30;
    }
  }
  v14 = v11 + 24 * *(unsigned int *)(a1 + 24);
  v15 = *(_OWORD *)v13;
  *(_QWORD *)(v14 + 16) = *((_QWORD *)v13 + 2);
  *(_OWORD *)v14 = v15;
  v16 = *(_DWORD *)(a1 + 28);
  v17 = (*(_DWORD *)(a1 + 24) + 1);
  *(_DWORD *)(a1 + 24) = v17;
  v18 = *a3;
  v30 = 5;
  v31 = v18;
  v19 = *(_QWORD *)(a1 + 16);
  v20 = &v30;
  if (v17 >= v16)
  {
    v26 = v17 + 1;
    v27 = v19 + 24 * v17 > (unint64_t)&v30;
    if (v19 <= (unint64_t)&v30 && v27)
    {
      v29 = (char *)&v30 - v19;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v26, 24);
      v19 = *(_QWORD *)(a1 + 16);
      v20 = (int *)&v29[v19];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v26, 24);
      v19 = *(_QWORD *)(a1 + 16);
      v20 = &v30;
    }
  }
  v21 = v19 + 24 * *(unsigned int *)(a1 + 24);
  v22 = *(_OWORD *)v20;
  *(_QWORD *)(v21 + 16) = *((_QWORD *)v20 + 2);
  *(_OWORD *)v21 = v22;
  ++*(_DWORD *)(a1 + 24);
  return mlir::Diagnostic::append<char const(&)[36],unsigned long long &>(a1, a4, a5);
}

uint64_t mlir::Diagnostic::append<char const(&)[36],unsigned long long &>(uint64_t a1, char *__s, char **a3)
{
  size_t v6;
  unint64_t v7;
  uint64_t v8;
  int *v9;
  uint64_t v10;
  __int128 v11;
  unsigned int v12;
  uint64_t v13;
  char *v14;
  unint64_t v15;
  int *v16;
  uint64_t v17;
  __int128 v18;
  unint64_t v20;
  BOOL v21;
  unint64_t v22;
  BOOL v23;
  char *v24;
  char *v25;
  int v26;
  char *v27;
  size_t v28;

  v6 = strlen(__s);
  v7 = *(_QWORD *)(a1 + 16);
  v26 = 3;
  v27 = __s;
  v28 = v6;
  v8 = *(unsigned int *)(a1 + 24);
  v9 = &v26;
  if (v8 >= *(_DWORD *)(a1 + 28))
  {
    v20 = v8 + 1;
    v21 = v7 + 24 * v8 > (unint64_t)&v26;
    if (v7 <= (unint64_t)&v26 && v21)
    {
      v24 = (char *)&v26 - v7;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v20, 24);
      v7 = *(_QWORD *)(a1 + 16);
      v9 = (int *)&v24[v7];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v20, 24);
      v7 = *(_QWORD *)(a1 + 16);
      v9 = &v26;
    }
  }
  v10 = v7 + 24 * *(unsigned int *)(a1 + 24);
  v11 = *(_OWORD *)v9;
  *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
  *(_OWORD *)v10 = v11;
  v12 = *(_DWORD *)(a1 + 28);
  v13 = (*(_DWORD *)(a1 + 24) + 1);
  *(_DWORD *)(a1 + 24) = v13;
  v14 = *a3;
  v26 = 5;
  v27 = v14;
  v15 = *(_QWORD *)(a1 + 16);
  v16 = &v26;
  if (v13 >= v12)
  {
    v22 = v13 + 1;
    v23 = v15 + 24 * v13 > (unint64_t)&v26;
    if (v15 <= (unint64_t)&v26 && v23)
    {
      v25 = (char *)&v26 - v15;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v22, 24);
      v15 = *(_QWORD *)(a1 + 16);
      v16 = (int *)&v25[v15];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v22, 24);
      v15 = *(_QWORD *)(a1 + 16);
      v16 = &v26;
    }
  }
  v17 = v15 + 24 * *(unsigned int *)(a1 + 24);
  v18 = *(_OWORD *)v16;
  *(_QWORD *)(v17 + 16) = *((_QWORD *)v16 + 2);
  *(_OWORD *)v17 = v18;
  ++*(_DWORD *)(a1 + 24);
  return a1;
}

uint64_t `anonymous namespace'::EncodingReader::parseBytes(_anonymous_namespace_::EncodingReader *this, size_t __n, unsigned __int8 *__dst)
{
  const void *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  char *v16;
  char *v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD *v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v17 = (char *)__n;
  v5 = (const void *)*((_QWORD *)this + 2);
  if (*(_QWORD *)this + *((_QWORD *)this + 1) - (_QWORD)v5 >= __n)
  {
    memcpy(__dst, v5, __n);
    *((_QWORD *)this + 2) += __n;
    return 1;
  }
  else
  {
    v16 = (char *)(*(_QWORD *)this + *((_QWORD *)this + 1) - (_QWORD)v5);
    v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
    if (v18[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
    if (v25)
    {
      v7 = __p;
      if (__p)
      {
        v8 = v24;
        v9 = __p;
        if (v24 != __p)
        {
          do
            v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
          while (v8 != v7);
          v9 = __p;
        }
        v24 = v7;
        operator delete(v9);
      }
      v10 = v21;
      if (v21)
      {
        v11 = v22;
        v12 = v21;
        if (v22 != v21)
        {
          do
          {
            v14 = *--v11;
            v13 = v14;
            *v11 = 0;
            if (v14)
              MEMORY[0x20BD002D4](v13, 0x1000C8077774924);
          }
          while (v11 != v10);
          v12 = v21;
        }
        v22 = v10;
        operator delete(v12);
      }
      if (v19 != &v20)
        free(v19);
    }
  }
  return v6;
}

uint64_t `anonymous namespace'::EncodingReader::parseMultiByteVarInt(_anonymous_namespace_::EncodingReader *this, unint64_t *a2)
{
  size_t v3;
  _QWORD v5[2];

  v5[1] = *MEMORY[0x24BDAC8D0];
  v3 = __clz(__rbit32(*a2));
  v5[0] = *a2;
    return 0;
  *a2 = v5[0] >> (v3 + 1);
  return 1;
}

uint64_t resolveEntry<llvm::SmallVector<llvm::StringRef,3u>,llvm::StringRef>(uint64_t a1, uint64_t a2, unsigned int a3, char *a4, _OWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  char *v17;
  _QWORD v18[2];
  _QWORD v19[3];
  void *v20;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  void *__p;
  _QWORD *v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v18[0] = a6;
  v18[1] = a7;
  v17 = a4;
  if (a3 <= (unint64_t)a4)
  {
    v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
    if (v19[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
    if (v26)
    {
      v8 = __p;
      if (__p)
      {
        v9 = v25;
        v10 = __p;
        if (v25 != __p)
        {
          do
            v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
          while (v9 != v8);
          v10 = __p;
        }
        v25 = v8;
        operator delete(v10);
      }
      v11 = v22;
      if (v22)
      {
        v12 = v23;
        v13 = v22;
        if (v23 != v22)
        {
          do
          {
            v15 = *--v12;
            v14 = v15;
            *v12 = 0;
            if (v15)
              MEMORY[0x20BD002D4](v14, 0x1000C8077774924);
          }
          while (v12 != v11);
          v13 = v22;
        }
        v23 = v11;
        operator delete(v13);
      }
      if (v20 != &v21)
        free(v20);
    }
  }
  else
  {
    *a5 = *(_OWORD *)(a2 + 16 * (_QWORD)a4);
    return 1;
  }
  return v7;
}

void `anonymous namespace'::EncodingReader::emitError<char const(&)[9],llvm::StringRef &,char const(&)[9],unsigned long long &>(uint64_t a1, uint64_t a2, uint64_t a3, char **a4)
{
  uint64_t v7;
  unint64_t v8;
  int v9;
  int v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  void *__src;
  unsigned int v32;
  int v33;
  _BYTE v34[96];
  void *v35[2];
  uint64_t v36;
  void *__p[2];
  uint64_t v38;
  unsigned __int8 v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  mlir::emitError(a2, (uint64_t)&v28);
  v7 = v28;
  if (v28)
  {
    mlir::Diagnostic::append<char const(&)[9],llvm::StringRef &,char const(&)[9],unsigned long long &>((uint64_t)&v29, "invalid ", a3, " index: ", a4);
    v7 = v28;
  }
  *(_QWORD *)a1 = v7;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  if (v39)
  {
    *(_QWORD *)(a1 + 8) = v29;
    v8 = v32;
    *(_DWORD *)(a1 + 16) = v30;
    *(_QWORD *)(a1 + 24) = a1 + 40;
    *(_QWORD *)(a1 + 32) = *(_QWORD *)"";
    if (!(_DWORD)v8 || &v28 == (uint64_t *)a1)
    {
      v10 = 1;
      goto LABEL_16;
    }
    if (__src != v34)
    {
      *(_QWORD *)(a1 + 24) = __src;
      v9 = v33;
      *(_DWORD *)(a1 + 32) = v8;
      *(_DWORD *)(a1 + 36) = v9;
      __src = v34;
      v33 = 0;
      v10 = 1;
LABEL_15:
      v32 = 0;
LABEL_16:
      *(_OWORD *)(a1 + 136) = *(_OWORD *)v35;
      *(_QWORD *)(a1 + 152) = v36;
      v35[0] = 0;
      v35[1] = 0;
      *(_OWORD *)(a1 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a1 + 176) = v38;
      v36 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v38 = 0;
      *(_BYTE *)(a1 + 184) = 1;
      if (v10)
      {
        v12 = __p[0];
        if (__p[0])
        {
          v13 = __p[1];
          v14 = __p[0];
          if (__p[1] != __p[0])
          {
            do
              v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
            while (v13 != v12);
            v14 = __p[0];
          }
          __p[1] = v12;
          operator delete(v14);
        }
        v15 = v35[0];
        if (v35[0])
        {
          v16 = v35[1];
          v17 = v35[0];
          if (v35[1] != v35[0])
          {
            do
            {
              v19 = *--v16;
              v18 = v19;
              *v16 = 0;
              if (v19)
                MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
            }
            while (v16 != v15);
            v17 = v35[0];
          }
          v35[1] = v15;
          operator delete(v17);
        }
        if (__src != v34)
          free(__src);
        v39 = 0;
      }
      goto LABEL_33;
    }
    if (v8 < 5)
    {
      v11 = v8;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v8, 24);
      v11 = v32;
      if (!v32)
        goto LABEL_14;
    }
    memcpy(*(void **)(a1 + 24), __src, 24 * v11);
LABEL_14:
    *(_DWORD *)(a1 + 32) = v8;
    v10 = v39;
    goto LABEL_15;
  }
LABEL_33:
  mlir::InFlightDiagnostic::abandon(&v28);
  if (v28)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v28);
  if (v39)
  {
    v20 = __p[0];
    if (__p[0])
    {
      v21 = __p[1];
      v22 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
        while (v21 != v20);
        v22 = __p[0];
      }
      __p[1] = v20;
      operator delete(v22);
    }
    v23 = v35[0];
    if (v35[0])
    {
      v24 = v35[1];
      v25 = v35[0];
      if (v35[1] != v35[0])
      {
        do
        {
          v27 = *--v24;
          v26 = v27;
          *v24 = 0;
          if (v27)
            MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
        }
        while (v24 != v23);
        v25 = v35[0];
      }
      v35[1] = v23;
      operator delete(v25);
    }
    if (__src != v34)
      free(__src);
  }
}

uint64_t mlir::Diagnostic::append<char const(&)[9],llvm::StringRef &,char const(&)[9],unsigned long long &>(uint64_t a1, char *__s, uint64_t a3, char *a4, char **a5)
{
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const void ***v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  unint64_t v19;
  BOOL v20;
  char *v21;
  const void **v22;
  char *v23;
  size_t v24;
  __int16 v25;

  v10 = strlen(__s);
  v11 = a1 + 16;
  v12 = *(_QWORD *)(a1 + 16);
  LODWORD(v22) = 3;
  v23 = __s;
  v24 = v10;
  v13 = *(unsigned int *)(a1 + 24);
  v14 = &v22;
  if (v13 >= *(_DWORD *)(a1 + 28))
  {
    v19 = v13 + 1;
    v20 = v12 + 24 * v13 > (unint64_t)&v22;
    if (v12 <= (unint64_t)&v22 && v20)
    {
      v21 = (char *)&v22 - v12;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v11, (void *)(a1 + 32), v19, 24);
      v12 = *(_QWORD *)(a1 + 16);
      v14 = (const void ***)&v21[v12];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v11, (void *)(a1 + 32), v19, 24);
      v12 = *(_QWORD *)(a1 + 16);
      v14 = &v22;
    }
  }
  v15 = v12 + 24 * *(unsigned int *)(a1 + 24);
  v16 = *(_OWORD *)v14;
  *(_QWORD *)(v15 + 16) = v14[2];
  *(_OWORD *)v15 = v16;
  ++*(_DWORD *)(a1 + 24);
  v25 = 261;
  v17 = *(char **)(a3 + 8);
  v22 = *(const void ***)a3;
  v23 = v17;
  mlir::Diagnostic::operator<<(a1, &v22);
  return mlir::Diagnostic::append<char const(&)[36],unsigned long long &>(a1, a4, a5);
}

uint64_t parseEntry<llvm::MutableArrayRef<std::unique_ptr<`anonymous namespace'::BytecodeDialect>>,std::unique_ptr<`anonymous namespace'::BytecodeDialect>*>(_anonymous_namespace_::EncodingReader *a1, uint64_t *a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v23;
  char *v24;
  _QWORD v25[2];
  _QWORD v26[3];
  void *v27;
  uint64_t v28;
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v23 = 0;
    return 0;
  v10 = *((_QWORD *)a1 + 3);
  v11 = *a2;
  v12 = a2[1];
  v25[0] = a4;
  v25[1] = a5;
  v24 = (char *)v23;
  if (v12 <= v23)
  {
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v26);
    if (v26[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v26);
    if (v33)
    {
      v14 = __p;
      if (__p)
      {
        v15 = v32;
        v16 = __p;
        if (v32 != __p)
        {
          do
            v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          v16 = __p;
        }
        v32 = v14;
        operator delete(v16);
      }
      v17 = v29;
      if (v29)
      {
        v18 = v30;
        v19 = v29;
        if (v30 != v29)
        {
          do
          {
            v21 = *--v18;
            v20 = v21;
            *v18 = 0;
            if (v21)
              MEMORY[0x20BD002D4](v20, 0x1000C8077774924);
          }
          while (v18 != v17);
          v19 = v29;
        }
        v30 = v17;
        operator delete(v19);
      }
      if (v27 != &v28)
        free(v27);
    }
  }
  else
  {
    *a3 = v11 + 8 * v23;
    return 1;
  }
  return v13;
}

void `anonymous namespace'::DialectReader::~DialectReader(_anonymous_namespace_::DialectReader *this)
{
  JUMPOUT(0x20BD002F8);
}

void `anonymous namespace'::DialectReader::emitError(uint64_t a1@<X0>, const void ***a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  unint64_t v6;
  void *v7;
  void *v8;
  int v9;
  int v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  void *__src;
  unsigned int v24;
  int v25;
  _BYTE v26[96];
  void *v27[2];
  uint64_t v28;
  void *__p[2];
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  mlir::emitError(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 24), (uint64_t)&v20);
  v5 = v20;
  if (v20)
  {
    mlir::Diagnostic::operator<<((uint64_t)&v21, a2);
    v5 = v20;
  }
  *(_QWORD *)a3 = v5;
  *(_BYTE *)(a3 + 8) = 0;
  *(_BYTE *)(a3 + 184) = 0;
  if (v31)
  {
    *(_QWORD *)(a3 + 8) = v21;
    v6 = v24;
    *(_DWORD *)(a3 + 16) = v22;
    v7 = (void *)(a3 + 40);
    *(_QWORD *)(a3 + 24) = a3 + 40;
    *(_QWORD *)(a3 + 32) = *(_QWORD *)"";
    if (!(_DWORD)v6 || &v20 == (uint64_t *)a3)
    {
      v10 = 1;
      goto LABEL_16;
    }
    v8 = __src;
    if (__src != v26)
    {
      *(_QWORD *)(a3 + 24) = __src;
      v9 = v25;
      *(_DWORD *)(a3 + 32) = v6;
      *(_DWORD *)(a3 + 36) = v9;
      __src = v26;
      v25 = 0;
      v10 = 1;
LABEL_15:
      v24 = 0;
LABEL_16:
      *(_OWORD *)(a3 + 136) = *(_OWORD *)v27;
      *(_QWORD *)(a3 + 152) = v28;
      v27[0] = 0;
      v27[1] = 0;
      *(_OWORD *)(a3 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a3 + 176) = v30;
      v28 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v30 = 0;
      *(_BYTE *)(a3 + 184) = 1;
      if (v10)
      {
        if (__src != v26)
          free(__src);
        v31 = 0;
      }
      goto LABEL_20;
    }
    if (v6 < 5)
    {
      v11 = v6;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3 + 24, (void *)(a3 + 40), v6, 24);
      v11 = v24;
      if (!v24)
      {
LABEL_14:
        *(_DWORD *)(a3 + 32) = v6;
        v10 = v31;
        goto LABEL_15;
      }
      v8 = __src;
      v7 = *(void **)(a3 + 24);
    }
    memcpy(v7, v8, 24 * v11);
    goto LABEL_14;
  }
LABEL_20:
  mlir::InFlightDiagnostic::abandon(&v20);
  if (v20)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v20);
  if (v31)
  {
    v12 = __p[0];
    if (__p[0])
    {
      v13 = __p[1];
      v14 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
        while (v13 != v12);
        v14 = __p[0];
      }
      __p[1] = v12;
      operator delete(v14);
    }
    v15 = v27[0];
    if (v27[0])
    {
      v16 = v27[1];
      v17 = v27[0];
      if (v27[1] != v27[0])
      {
        do
        {
          v19 = *--v16;
          v18 = v19;
          *v16 = 0;
          if (v19)
            MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
        }
        while (v16 != v15);
        v17 = v27[0];
      }
      v27[1] = v15;
      operator delete(v17);
    }
    if (__src != v26)
      free(__src);
  }
}

uint64_t `anonymous namespace'::DialectReader::getDialectVersion(uint64_t a1, int8x16_t *a2, const unsigned __int8 *a3)
{
  uint64_t v4;
  int Key;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  mlir::MLIRContext *Context;
  uint64_t v11;

  v4 = *(_QWORD *)(a1 + 32);
  Key = llvm::StringMapImpl::FindKey((uint64_t *)v4, a2, a3);
  if (Key == -1)
    v6 = *(unsigned int *)(v4 + 8);
  else
    v6 = Key;
  v7 = *(_QWORD *)v4 + 8 * v6;
  if (v7 == **(_QWORD **)(a1 + 32) + 8 * *(unsigned int *)(*(_QWORD *)(a1 + 32) + 8))
    return 0;
  v8 = *(_QWORD *)(*(_QWORD *)v7 + 8);
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 24);
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v11);
    return 0;
  else
    return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v7 + 8) + 56);
}

uint64_t `anonymous namespace'::DialectReader::getContext(_anonymous_namespace_::DialectReader *this)
{
  uint64_t v2;

  v2 = *(_QWORD *)(*((_QWORD *)this + 5) + 24);
  return mlir::Attribute::getContext((mlir::Attribute *)&v2);
}

uint64_t `anonymous namespace'::DialectReader::getBytecodeVersion(_anonymous_namespace_::DialectReader *this)
{
  return **((_QWORD **)this + 6);
}

BOOL `anonymous namespace'::DialectReader::readAttribute(_anonymous_namespace_::DialectReader *this, mlir::Attribute *a2)
{
  _anonymous_namespace_::AttrTypeReader *v3;
  _anonymous_namespace_::EncodingReader *v4;
  uint64_t v5;
  unint64_t v7;

  v3 = (_anonymous_namespace_::AttrTypeReader *)*((_QWORD *)this + 1);
  v4 = (_anonymous_namespace_::EncodingReader *)*((_QWORD *)this + 5);
  v7 = 0;
    return 0;
  *(_QWORD *)a2 = v5;
  return v5 != 0;
}

BOOL `anonymous namespace'::DialectReader::readOptionalAttribute(_anonymous_namespace_::DialectReader *this, mlir::Attribute *a2)
{
  _anonymous_namespace_::AttrTypeReader *v3;
  _anonymous_namespace_::EncodingReader *v4;
  uint64_t v6;
  unint64_t v7;

  v3 = (_anonymous_namespace_::AttrTypeReader *)*((_QWORD *)this + 1);
  v4 = (_anonymous_namespace_::EncodingReader *)*((_QWORD *)this + 5);
  v7 = 0;
    return 0;
  if ((v7 & 1) == 0)
    return 1;
  *(_QWORD *)a2 = v6;
  return v6 != 0;
}

BOOL `anonymous namespace'::DialectReader::readType(_anonymous_namespace_::DialectReader *this, mlir::Type *a2)
{
  _anonymous_namespace_::AttrTypeReader *v3;
  _anonymous_namespace_::EncodingReader *v4;
  uint64_t v5;
  unint64_t v7;

  v3 = (_anonymous_namespace_::AttrTypeReader *)*((_QWORD *)this + 1);
  v4 = (_anonymous_namespace_::EncodingReader *)*((_QWORD *)this + 5);
  v7 = 0;
    return 0;
  *(_QWORD *)a2 = v5;
  return v5 != 0;
}

uint64_t `anonymous namespace'::DialectReader::readVarInt(_anonymous_namespace_::EncodingReader **this, unint64_t *a2)
{
}

uint64_t `anonymous namespace'::DialectReader::readSignedVarInt(_anonymous_namespace_::EncodingReader **this, unint64_t *a2)
{
  unint64_t v4;

  v4 = 0;
    return 0;
  *a2 = -(uint64_t)(v4 & 1) ^ (v4 >> 1);
  return 1;
}

void `anonymous namespace'::DialectReader::readAPIntWithKnownWidth(_anonymous_namespace_::DialectReader *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t *v13;
  void *v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  void *v18;
  uint64_t v19;
  _QWORD v20[5];

  v20[4] = *MEMORY[0x24BDAC8D0];
  if (a2 <= 8)
  {
    LOBYTE(v18) = 0;
    {
      v6 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a2;
      if (!a2)
        LOBYTE(v6) = 0;
      v7 = v6 & v18;
      goto LABEL_9;
    }
    goto LABEL_15;
  }
  if (a2 <= 0x40)
  {
    v18 = 0;
    {
      v7 = (-(uint64_t)(v18 & 1) ^ ((unint64_t)v18 >> 1)) & (0xFFFFFFFFFFFFFFFFLL >> -(char)a2);
LABEL_9:
      *(_DWORD *)(a3 + 8) = a2;
      *(_QWORD *)a3 = v7;
      *(_BYTE *)(a3 + 16) = 1;
      return;
    }
    goto LABEL_15;
  }
  v17 = 0;
  {
LABEL_15:
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 16) = 0;
    return;
  }
  v8 = v17;
  v18 = v20;
  v19 = 0x400000000;
  if (v17)
  {
    if (v17 < 5)
    {
      v9 = 0;
      v10 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v18, v20, v17, 8);
      v9 = v19;
      v10 = v8 - v19;
      if (v8 == v19)
        goto LABEL_19;
    }
    bzero((char *)v18 + 8 * v9, 8 * v10);
LABEL_19:
    v12 = 0;
    LODWORD(v19) = v8;
    while (1)
    {
      v13 = (uint64_t *)((char *)v18 + v12);
      *v13 = -(*v13 & 1) ^ ((unint64_t)*v13 >> 1);
      v12 += 8;
      if (!--v8)
      {
        v11 = v19;
        goto LABEL_23;
      }
    }
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 16) = 0;
    v14 = v18;
    if (v18 == v20)
      return;
LABEL_24:
    free(v14);
    return;
  }
  v11 = 0;
LABEL_23:
  llvm::APInt::APInt((uint64_t)&v15, a2, (uint64_t *)v18, v11);
  *(_DWORD *)(a3 + 8) = v16;
  *(_QWORD *)a3 = v15;
  *(_BYTE *)(a3 + 16) = 1;
  v14 = v18;
  if (v18 != v20)
    goto LABEL_24;
}

void `anonymous namespace'::DialectReader::readAPFloatWithKnownSemantics(uint64_t a1@<X0>, void *a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t SizeInBits;
  llvm::APFloatBase *v7;
  void *v8;
  _QWORD *v9;
  const llvm::APInt *v10;
  unsigned int v11;
  char v12;
  _QWORD v13[4];

  v13[3] = *MEMORY[0x24BDAC8D0];
  SizeInBits = llvm::APFloatBase::getSizeInBits((uint64_t)a2);
  v7 = (llvm::APFloatBase *)(*(_QWORD *(**)(const llvm::APInt **__return_ptr, uint64_t, uint64_t))(*(_QWORD *)a1 + 88))(&v10, a1, SizeInBits);
  if (!v12)
  {
    *a3 = 0;
    a3[32] = 0;
    return;
  }
  v8 = llvm::APFloatBase::PPCDoubleDouble(v7);
  if (v8 == a2)
  {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v13, (uint64_t)a2, (uint64_t)&v10);
    v9 = a3 + 8;
    if (v8 != (void *)v13[0])
    {
LABEL_4:
      llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v9, (uint64_t)v13);
      a3[32] = 1;
      if (v8 != (void *)v13[0])
        goto LABEL_5;
      goto LABEL_10;
    }
  }
  else
  {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v13, a2, &v10);
    v9 = a3 + 8;
    if (v8 != (void *)v13[0])
      goto LABEL_4;
  }
  llvm::detail::DoubleAPFloat::DoubleAPFloat(v9, v13);
  a3[32] = 1;
  if (v8 != (void *)v13[0])
  {
LABEL_5:
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v13);
    if (!v12)
      return;
    goto LABEL_11;
  }
LABEL_10:
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v13);
  if (!v12)
    return;
LABEL_11:
  if (v11 >= 0x41)
  {
    if (v10)
      MEMORY[0x20BD002D4](v10, 0x1000C8000313F17);
  }
}

uint64_t `anonymous namespace'::DialectReader::readString(_anonymous_namespace_::DialectReader *this, llvm::StringRef *a2)
{
  uint64_t v3;
  uint64_t *v4;
  unint64_t v6;

  v3 = *((_QWORD *)this + 2);
  v4 = (uint64_t *)*((_QWORD *)this + 5);
  v6 = 0;
  else
    return 0;
}

uint64_t `anonymous namespace'::DialectReader::readBlob(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v7 = 0;
  v8 = 0;
  v6 = 0;
  {
    return 0;
  }
  v4 = v7;
  *a2 = v6;
  a2[1] = v4;
  return 1;
}

uint64_t `anonymous namespace'::DialectReader::readBool(_anonymous_namespace_::DialectReader *this, BOOL *a2)
{
}

void `anonymous namespace'::DialectReader::readResourceHandle(_anonymous_namespace_::DialectReader *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v3;
  _anonymous_namespace_::EncodingReader *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  __int128 v10;
  char v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  unint64_t v21;
  char *v22;
  _QWORD v23[2];
  _QWORD v24[3];
  void *v25;
  uint64_t v26;
  void *v27;
  _QWORD *v28;
  void *__p;
  _QWORD *v30;
  char v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v3 = (uint64_t *)*((_QWORD *)this + 3);
  v4 = (_anonymous_namespace_::EncodingReader *)*((_QWORD *)this + 5);
  v21 = 0;
    goto LABEL_25;
  v5 = *((_QWORD *)v4 + 3);
  v6 = *v3;
  v7 = *((unsigned int *)v3 + 2);
  v23[0] = "resource handle";
  v23[1] = 15;
  v22 = (char *)v21;
  if (v21 >= v7)
  {
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v24);
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    if (v31)
    {
      v12 = __p;
      if (__p)
      {
        v13 = v30;
        v14 = __p;
        if (v30 != __p)
        {
          do
            v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          v14 = __p;
        }
        v30 = v12;
        operator delete(v14);
      }
      v15 = v27;
      if (v27)
      {
        v16 = v28;
        v17 = v27;
        if (v28 != v27)
        {
          do
          {
            v19 = *--v16;
            v18 = v19;
            *v16 = 0;
            if (v19)
              MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
          }
          while (v16 != v15);
          v17 = v27;
        }
        v28 = v15;
        operator delete(v17);
      }
      if (v25 != &v26)
        free(v25);
    }
    if (v11)
    {
      v9 = 0;
      *(_QWORD *)&v10 = &mlir::detail::TypeIDResolver<void,void>::id;
      goto LABEL_24;
    }
LABEL_25:
    v20 = 0;
    *(_BYTE *)a2 = 0;
    goto LABEL_26;
  }
  v8 = (uint64_t *)(v6 + 24 * v21);
  v9 = *v8;
  v10 = *(_OWORD *)(v8 + 1);
LABEL_24:
  *(_QWORD *)a2 = v9;
  *(_OWORD *)(a2 + 8) = v10;
  v20 = 1;
LABEL_26:
  *(_BYTE *)(a2 + 24) = v20;
}

BOOL `anonymous namespace'::BytecodeDialect::load(uint64_t a1, uint64_t a2, mlir::MLIRContext *a3)
{
  uint64_t v3;
  uint64_t **(*Dialect)(uint64_t, uint64_t);
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  const void ***v20;
  char *v21;
  char *v22;
  __int128 v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  const void ***v33;
  char *v34;
  char *v35;
  __int128 v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  int64_t v45;
  int64_t v46;
  _QWORD v47[4];
  __int16 v48;
  const void **v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  __int16 v53;
  void (**v54)(_anonymous_namespace_::DialectReader *__hidden);
  __int128 v55;
  void *v56[2];
  _QWORD v57[12];
  void *v58;
  _QWORD *v59;
  void *__p;
  _QWORD *v61;
  char v62;
  uint64_t v63;

  v63 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 8))
    return 1;
  Dialect = mlir::MLIRContext::getOrLoadDialect((uint64_t)a3, *(void **)(a1 + 24), *(_QWORD *)(a1 + 32));
  if (Dialect)
  {
    v9 = (uint64_t)Dialect;
    *(_QWORD *)a1 = Dialect;
    *(_BYTE *)(a1 + 8) = 1;
    v10 = mlir::Dialect::getRegisteredInterface<mlir::BytecodeDialectInterface>((uint64_t)Dialect);
    if (v10)
      v10 = mlir::Dialect::getRegisteredInterface<mlir::BytecodeDialectInterface>(v9);
    *(_QWORD *)(a1 + 16) = v10;
    v11 = *(const char **)(a1 + 48);
    if (!v11)
      return 1;
    goto LABEL_11;
  }
  if (mlir::MLIRContext::allowsUnregisteredDialects(a3))
  {
    *(_QWORD *)a1 = 0;
    *(_BYTE *)(a1 + 8) = 1;
    v11 = *(const char **)(a1 + 48);
    if (!v11)
      return 1;
LABEL_11:
    v12 = *(_QWORD *)(a1 + 16);
    if (v12)
    {
      v13 = *(_QWORD *)(a2 + 48);
      v14 = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 24);
      v49 = *(const void ***)(a1 + 40);
      v50 = v11;
      v51 = (uint64_t)v49;
      v52 = v14;
      v54 = &off_24C028780;
      v15 = *(_OWORD *)(a2 + 24);
      v55 = *(_OWORD *)(a2 + 8);
      *(_OWORD *)v56 = v15;
      v57[0] = &v49;
      v57[1] = v13;
      (*(void (**)(_QWORD *__return_ptr, uint64_t, void (***)(_anonymous_namespace_::DialectReader *__hidden)))(*(_QWORD *)v12 + 56))(v47, v12, &v54);
      v16 = v47[0];
      v47[0] = 0;
      v17 = *(_QWORD *)(a1 + 56);
      *(_QWORD *)(a1 + 56) = v16;
      if (v17)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
        v18 = v47[0];
        v47[0] = 0;
        if (v18)
          (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
        v16 = *(_QWORD *)(a1 + 56);
      }
      return v16 != 0;
    }
    v47[0] = "dialect '";
    v48 = 259;
    (*(void (**)(void (***__return_ptr)(_anonymous_namespace_::DialectReader *__hidden), uint64_t, _QWORD *))(*(_QWORD *)a2 + 16))(&v54, a2, v47);
    if (v54)
    {
      v53 = 261;
      v19 = *(const char **)(a1 + 32);
      v49 = *(const void ***)(a1 + 24);
      v50 = v19;
      mlir::Diagnostic::operator<<((uint64_t)&v55, &v49);
      if (v54)
      {
        LODWORD(v49) = 3;
        v50 = "' does not implement the bytecode interface, but found a version entry";
        v51 = 70;
        v20 = &v49;
        v21 = (char *)v56[0];
        if (LODWORD(v56[1]) >= HIDWORD(v56[1]))
        {
          v43 = LODWORD(v56[1]) + 1;
          if (v56[0] <= &v49 && (char *)v56[0] + 24 * LODWORD(v56[1]) > (char *)&v49)
          {
            v45 = (char *)&v49 - (char *)v56[0];
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v56, v57, v43, 24);
            v21 = (char *)v56[0];
            v20 = (const void ***)((char *)v56[0] + v45);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v56, v57, v43, 24);
            v20 = &v49;
            v21 = (char *)v56[0];
          }
        }
        v22 = &v21[24 * LODWORD(v56[1])];
        v23 = *(_OWORD *)v20;
        *((_QWORD *)v22 + 2) = v20[2];
        *(_OWORD *)v22 = v23;
        ++LODWORD(v56[1]);
      }
    }
    v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v54);
    if (v54)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v54);
    if (v62)
    {
      v24 = __p;
      if (__p)
      {
        v25 = v61;
        v26 = __p;
        if (v61 != __p)
        {
          do
            v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
          while (v25 != v24);
          v26 = __p;
        }
        v61 = v24;
        operator delete(v26);
      }
      v27 = v58;
      if (!v58)
        goto LABEL_56;
      v28 = v59;
      v29 = v58;
      if (v59 == v58)
      {
LABEL_55:
        v59 = v27;
        operator delete(v29);
LABEL_56:
        if (v56[0] != v57)
          free(v56[0]);
        return v3;
      }
      do
      {
        v31 = *--v28;
        v30 = v31;
        *v28 = 0;
        if (v31)
          MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
      }
      while (v28 != v27);
LABEL_54:
      v29 = v58;
      goto LABEL_55;
    }
    return v3;
  }
  v47[0] = "dialect '";
  v48 = 259;
  (*(void (**)(void (***__return_ptr)(_anonymous_namespace_::DialectReader *__hidden), uint64_t, _QWORD *))(*(_QWORD *)a2 + 16))(&v54, a2, v47);
  if (v54)
  {
    v53 = 261;
    v32 = *(const char **)(a1 + 32);
    v49 = *(const void ***)(a1 + 24);
    v50 = v32;
    mlir::Diagnostic::operator<<((uint64_t)&v55, &v49);
    if (v54)
    {
      LODWORD(v49) = 3;
      v50 = "' is unknown. If this is intended, please call allowUnregisteredDialects() on the MLIRContext, or use -allow"
            "-unregistered-dialect with the MLIR tool used.";
      v51 = 154;
      v33 = &v49;
      v34 = (char *)v56[0];
      if (LODWORD(v56[1]) >= HIDWORD(v56[1]))
      {
        v44 = LODWORD(v56[1]) + 1;
        if (v56[0] <= &v49 && (char *)v56[0] + 24 * LODWORD(v56[1]) > (char *)&v49)
        {
          v46 = (char *)&v49 - (char *)v56[0];
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v56, v57, v44, 24);
          v34 = (char *)v56[0];
          v33 = (const void ***)((char *)v56[0] + v46);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v56, v57, v44, 24);
          v33 = &v49;
          v34 = (char *)v56[0];
        }
      }
      v35 = &v34[24 * LODWORD(v56[1])];
      v36 = *(_OWORD *)v33;
      *((_QWORD *)v35 + 2) = v33[2];
      *(_OWORD *)v35 = v36;
      ++LODWORD(v56[1]);
    }
  }
  v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v54);
  if (v54)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v54);
  if (v62)
  {
    v37 = __p;
    if (__p)
    {
      v38 = v61;
      v39 = __p;
      if (v61 != __p)
      {
        do
          v38 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v38 - 1);
        while (v38 != v37);
        v39 = __p;
      }
      v61 = v37;
      operator delete(v39);
    }
    v27 = v58;
    if (!v58)
      goto LABEL_56;
    v40 = v59;
    v29 = v58;
    if (v59 == v58)
      goto LABEL_55;
    do
    {
      v42 = *--v40;
      v41 = v42;
      *v40 = 0;
      if (v42)
        MEMORY[0x20BD002D4](v41, 0x1000C8077774924);
    }
    while (v40 != v27);
    goto LABEL_54;
  }
  return v3;
}

uint64_t mlir::Dialect::getRegisteredInterface<mlir::BytecodeDialectInterface>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;
  int v10;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  unint64_t v23;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v21 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v13 = v12;
    a1 = v21;
    if (v13)
    {
      v22 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeDialectInterface]";
      v23 = 80;
      v14 = llvm::StringRef::find((uint64_t *)&v22, "DesiredTypeName = ", 0x12uLL, 0);
      if (v23 >= v14)
        v15 = v14;
      else
        v15 = v23;
      v16 = &v22[v15];
      v17 = v23 - v15;
      if (v23 - v15 >= 0x12)
        v18 = 18;
      else
        v18 = v23 - v15;
      v19 = v17 - v18;
      if (v19 >= v19 - 1)
        v20 = v19 - 1;
      else
        v20 = v19;
      mlir::detail::TypeIDResolver<mlir::BytecodeDialectInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v21;
    }
  }
  v3 = *(_QWORD *)(a1 + 48);
  v4 = *(unsigned int *)(a1 + 64);
  if ((_DWORD)v4)
  {
    v5 = v2[390];
    LODWORD(v6) = ((v5 >> 4) ^ (v5 >> 9)) & (v4 - 1);
    v7 = (uint64_t *)(v3 + 16 * v6);
    v8 = *v7;
    if (*v7 == v5)
      goto LABEL_9;
    v9 = 1;
    while (v8 != -4096)
    {
      v10 = v6 + v9++;
      v6 = v10 & (v4 - 1);
      v8 = *(_QWORD *)(v3 + 16 * v6);
      if (v8 == v5)
      {
        v7 = (uint64_t *)(v3 + 16 * v6);
        goto LABEL_9;
      }
    }
  }
  v7 = (uint64_t *)(v3 + 16 * v4);
LABEL_9:
  if (v7 == (uint64_t *)(v3 + 16 * v4))
    return 0;
  else
    return v7[1];
}

uint64_t `anonymous namespace'::AttrTypeReader::resolveAttribute(_anonymous_namespace_::AttrTypeReader *this, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  _OWORD *v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  mlir::MLIRContext *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  const void ***v24;
  char *v25;
  char *v26;
  __int128 v27;
  const void ***v28;
  char *v29;
  char *v30;
  __int128 v31;
  uint64_t v32;
  const void ***v33;
  char *v34;
  char *v35;
  __int128 v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t **Context;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  _QWORD *v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  void *v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  BOOL v63;
  int64_t v64;
  int64_t v65;
  int64_t v66;
  char *v67;
  unint64_t v68;
  const char *v69;
  uint64_t v70;
  __int16 v71;
  __int128 v72;
  uint64_t v73;
  uint64_t v74;
  const void **v75;
  uint64_t v76;
  __int128 v77;
  uint64_t v78;
  __int128 *v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void *v84;
  unsigned int v85;
  unsigned int v86;
  _BYTE v87[96];
  void *v88;
  _QWORD *v89;
  void *__p;
  _QWORD *v91;
  char v92;
  uint64_t v93;

  v93 = *MEMORY[0x24BDAC8D0];
  if (*((unsigned int *)this + 8) <= a2)
  {
    mlir::emitError(*((_QWORD *)this + 17), (uint64_t)&v82);
    if (v82)
    {
      LODWORD(v75) = 3;
      v76 = (uint64_t)"invalid ";
      *(_QWORD *)&v77 = 8;
      v24 = &v75;
      v25 = (char *)v84;
      if (v85 >= v86)
      {
        v60 = v85 + 1;
        if (v84 <= &v75 && (char *)v84 + 24 * v85 > (char *)&v75)
        {
          v64 = (char *)&v75 - (_BYTE *)v84;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v60, 24);
          v25 = (char *)v84;
          v24 = (const void ***)((char *)v84 + v64);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v60, 24);
          v24 = &v75;
          v25 = (char *)v84;
        }
      }
      v26 = &v25[24 * v85];
      v27 = *(_OWORD *)v24;
      *((_QWORD *)v26 + 2) = v24[2];
      *(_OWORD *)v26 = v27;
      ++v85;
      if (v82)
      {
        LOWORD(v78) = 261;
        v75 = (const void **)"Attribute";
        v76 = 9;
        mlir::Diagnostic::operator<<((uint64_t)&v83, &v75);
        if (v82)
        {
          LODWORD(v75) = 3;
          v76 = (uint64_t)" index: ";
          *(_QWORD *)&v77 = 8;
          v28 = &v75;
          v29 = (char *)v84;
          if (v85 >= v86)
          {
            v61 = v85 + 1;
            if (v84 <= &v75 && (char *)v84 + 24 * v85 > (char *)&v75)
            {
              v65 = (char *)&v75 - (_BYTE *)v84;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v61, 24);
              v29 = (char *)v84;
              v28 = (const void ***)((char *)v84 + v65);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v61, 24);
              v28 = &v75;
              v29 = (char *)v84;
            }
          }
          v30 = &v29[24 * v85];
          v31 = *(_OWORD *)v28;
          *((_QWORD *)v30 + 2) = v28[2];
          *(_OWORD *)v30 = v31;
          v32 = ++v85;
          if (v82)
          {
            LODWORD(v75) = 5;
            v76 = a2;
            v33 = &v75;
            v34 = (char *)v84;
            if (v32 >= v86)
            {
              v62 = v32 + 1;
              v63 = (char *)v84 + 24 * v32 > (char *)&v75;
              if (v84 <= &v75 && v63)
              {
                v66 = (char *)&v75 - (_BYTE *)v84;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v62, 24);
                v34 = (char *)v84;
                v33 = (const void ***)((char *)v84 + v66);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v62, 24);
                v33 = &v75;
                v34 = (char *)v84;
              }
            }
            v35 = &v34[24 * v85];
            v36 = *(_OWORD *)v33;
            *((_QWORD *)v35 + 2) = v33[2];
            *(_OWORD *)v35 = v36;
            ++v85;
            if (v82)
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v82);
          }
        }
      }
    }
    if (!v92)
      return 0;
    v37 = __p;
    if (__p)
    {
      v38 = v91;
      v39 = __p;
      if (v91 != __p)
      {
        do
          v38 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v38 - 1);
        while (v38 != v37);
        v39 = __p;
      }
      v91 = v37;
      operator delete(v39);
    }
    v40 = v88;
    if (!v88)
      goto LABEL_71;
    v41 = v89;
    v42 = v88;
    if (v89 == v88)
      goto LABEL_70;
    do
    {
      v44 = *--v41;
      v43 = v44;
      *v41 = 0;
      if (v44)
        MEMORY[0x20BD002D4](v43, 0x1000C8077774924);
    }
    while (v41 != v40);
    goto LABEL_69;
  }
  v4 = *((_QWORD *)this + 3);
  v5 = v4 + 40 * a2;
  result = *(_QWORD *)v5;
  if (*(_QWORD *)v5)
    return result;
  v7 = v4 + 40 * a2;
  v9 = *(_OWORD *)(v7 + 24);
  v8 = (_OWORD *)(v7 + 24);
  v10 = *((_QWORD *)this + 17);
  v72 = v9;
  v73 = v9;
  v74 = v10;
  if (!*((_BYTE *)v8 - 8))
  {
    v75 = (const void **)"Attribute";
    v76 = 9;
    v67 = 0;
    v68 = 0;
    {
      v81 = 0;
      Context = (uint64_t **)mlir::Attribute::getContext((_anonymous_namespace_::AttrTypeReader *)((char *)this + 136));
      mlir::parseAttribute(v67, v68, Context, 0, &v81, 1);
    }
    return 0;
  }
  v11 = *((_QWORD *)this + 2);
  v12 = *((_QWORD *)this + 18);
  v75 = (const void **)&off_24C028780;
  v76 = (uint64_t)this;
  v77 = *(_OWORD *)this;
  v78 = v11;
  v79 = &v72;
  v80 = v12;
  v13 = v4 + 40 * a2;
  v15 = *(_QWORD *)(v13 + 8);
  v14 = v13 + 8;
  v16 = (mlir::MLIRContext *)mlir::Attribute::getContext((_anonymous_namespace_::AttrTypeReader *)((char *)this + 136));
  {
    v17 = *((_QWORD *)this + 19);
    v18 = *(unsigned int *)(v17 + 56);
    if ((_DWORD)v18)
    {
      v19 = *(_QWORD **)(v17 + 48);
      v20 = 8 * v18;
      while ((*(unsigned __int8 (**)(_QWORD, const void ***, _QWORD, _QWORD, uint64_t))(*(_QWORD *)*v19 + 16))(*v19, &v75, *(_QWORD *)(*(_QWORD *)v14 + 24), *(_QWORD *)(*(_QWORD *)v14 + 32), v5))
      {
        if (*(_QWORD *)v5)
          goto LABEL_54;
        v72 = *v8;
        v73 = v72;
        ++v19;
        v20 -= 8;
        if (!v20)
          goto LABEL_10;
      }
      return 0;
    }
LABEL_10:
    v21 = *(_QWORD *)(*(_QWORD *)v14 + 16);
    if (v21)
    {
      v22 = (*(uint64_t (**)(uint64_t, const void ***))(*(_QWORD *)v21 + 16))(v21, &v75);
      *(_QWORD *)v5 = v22;
      v23 = v22 != 0;
    }
    else
    {
      v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v82);
      if (v82)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v82);
      if (v92)
      {
        v46 = __p;
        if (__p)
        {
          v47 = v91;
          v48 = __p;
          if (v91 != __p)
          {
            do
              v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
            while (v47 != v46);
            v48 = __p;
          }
          v91 = v46;
          operator delete(v48);
        }
        v49 = v88;
        if (v88)
        {
          v50 = v89;
          v51 = v88;
          if (v89 != v88)
          {
            do
            {
              v53 = *--v50;
              v52 = v53;
              *v50 = 0;
              if (v53)
                MEMORY[0x20BD002D4](v52, 0x1000C8077774924);
            }
            while (v50 != v49);
            v51 = v88;
          }
          v89 = v49;
          operator delete(v51);
        }
        if (v84 != v87)
          free(v84);
      }
    }
    if (v23)
    {
LABEL_54:
      if (v73 == (_QWORD)v72 + *((_QWORD *)&v72 + 1))
        return *(_QWORD *)v5;
      v71 = 1283;
      v67 = "unexpected trailing bytes after ";
      v69 = "Attribute";
      v70 = 9;
      v75 = (const void **)&v67;
      *(_QWORD *)&v77 = " entry";
      LOWORD(v78) = 770;
      if (v82)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v82);
      if (!v92)
        return 0;
      v54 = __p;
      if (__p)
      {
        v55 = v91;
        v56 = __p;
        if (v91 != __p)
        {
          do
            v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
          while (v55 != v54);
          v56 = __p;
        }
        v91 = v54;
        operator delete(v56);
      }
      v40 = v88;
      if (!v88)
        goto LABEL_71;
      v57 = v89;
      v42 = v88;
      if (v89 == v88)
      {
LABEL_70:
        v89 = v40;
        operator delete(v42);
LABEL_71:
        if (v84 != v87)
          free(v84);
        return 0;
      }
      do
      {
        v59 = *--v57;
        v58 = v59;
        *v57 = 0;
        if (v59)
          MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
      }
      while (v57 != v40);
LABEL_69:
      v42 = v88;
      goto LABEL_70;
    }
  }
  return 0;
}

void `anonymous namespace'::EncodingReader::emitError<llvm::Twine>(uint64_t a1, uint64_t a2, const void ***a3)
{
  uint64_t v5;
  unint64_t v6;
  int v7;
  int v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  void *__src;
  unsigned int v30;
  int v31;
  _BYTE v32[96];
  void *v33[2];
  uint64_t v34;
  void *__p[2];
  uint64_t v36;
  unsigned __int8 v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  mlir::emitError(a2, (uint64_t)&v26);
  v5 = v26;
  if (v26)
  {
    mlir::Diagnostic::operator<<((uint64_t)&v27, a3);
    v5 = v26;
  }
  *(_QWORD *)a1 = v5;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  if (v37)
  {
    *(_QWORD *)(a1 + 8) = v27;
    v6 = v30;
    *(_DWORD *)(a1 + 16) = v28;
    *(_QWORD *)(a1 + 24) = a1 + 40;
    *(_QWORD *)(a1 + 32) = *(_QWORD *)"";
    if (!(_DWORD)v6 || &v26 == (uint64_t *)a1)
    {
      v8 = 1;
      goto LABEL_16;
    }
    if (__src != v32)
    {
      *(_QWORD *)(a1 + 24) = __src;
      v7 = v31;
      *(_DWORD *)(a1 + 32) = v6;
      *(_DWORD *)(a1 + 36) = v7;
      __src = v32;
      v31 = 0;
      v8 = 1;
LABEL_15:
      v30 = 0;
LABEL_16:
      *(_OWORD *)(a1 + 136) = *(_OWORD *)v33;
      *(_QWORD *)(a1 + 152) = v34;
      v33[0] = 0;
      v33[1] = 0;
      *(_OWORD *)(a1 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a1 + 176) = v36;
      v34 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v36 = 0;
      *(_BYTE *)(a1 + 184) = 1;
      if (v8)
      {
        v10 = __p[0];
        if (__p[0])
        {
          v11 = __p[1];
          v12 = __p[0];
          if (__p[1] != __p[0])
          {
            do
              v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
            while (v11 != v10);
            v12 = __p[0];
          }
          __p[1] = v10;
          operator delete(v12);
        }
        v13 = v33[0];
        if (v33[0])
        {
          v14 = v33[1];
          v15 = v33[0];
          if (v33[1] != v33[0])
          {
            do
            {
              v17 = *--v14;
              v16 = v17;
              *v14 = 0;
              if (v17)
                MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
            }
            while (v14 != v13);
            v15 = v33[0];
          }
          v33[1] = v13;
          operator delete(v15);
        }
        if (__src != v32)
          free(__src);
        v37 = 0;
      }
      goto LABEL_33;
    }
    if (v6 < 5)
    {
      v9 = v6;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v6, 24);
      v9 = v30;
      if (!v30)
        goto LABEL_14;
    }
    memcpy(*(void **)(a1 + 24), __src, 24 * v9);
LABEL_14:
    *(_DWORD *)(a1 + 32) = v6;
    v8 = v37;
    goto LABEL_15;
  }
LABEL_33:
  mlir::InFlightDiagnostic::abandon(&v26);
  if (v26)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v26);
  if (v37)
  {
    v18 = __p[0];
    if (__p[0])
    {
      v19 = __p[1];
      v20 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p[0];
      }
      __p[1] = v18;
      operator delete(v20);
    }
    v21 = v33[0];
    if (v33[0])
    {
      v22 = v33[1];
      v23 = v33[0];
      if (v33[1] != v33[0])
      {
        do
        {
          v25 = *--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
            MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
        }
        while (v22 != v21);
        v23 = v33[0];
      }
      v33[1] = v21;
      operator delete(v23);
    }
    if (__src != v32)
      free(__src);
  }
}

void `anonymous namespace'::EncodingReader::emitError<char const(&)[10],llvm::StringRef &,char const(&)[44]>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;
  int v7;
  int v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  void *__src;
  unsigned int v30;
  int v31;
  _BYTE v32[96];
  void *v33[2];
  uint64_t v34;
  void *__p[2];
  uint64_t v36;
  unsigned __int8 v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  mlir::emitError(a2, (uint64_t)&v26);
  v5 = v26;
  if (v26)
  {
    mlir::Diagnostic::append<char const(&)[28],llvm::StringRef &,char const(&)[2]>((uint64_t)&v27, "dialect '", a3, "' does not implement the bytecode interface");
    v5 = v26;
  }
  *(_QWORD *)a1 = v5;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  if (v37)
  {
    *(_QWORD *)(a1 + 8) = v27;
    v6 = v30;
    *(_DWORD *)(a1 + 16) = v28;
    *(_QWORD *)(a1 + 24) = a1 + 40;
    *(_QWORD *)(a1 + 32) = *(_QWORD *)"";
    if (!(_DWORD)v6 || &v26 == (uint64_t *)a1)
    {
      v8 = 1;
      goto LABEL_16;
    }
    if (__src != v32)
    {
      *(_QWORD *)(a1 + 24) = __src;
      v7 = v31;
      *(_DWORD *)(a1 + 32) = v6;
      *(_DWORD *)(a1 + 36) = v7;
      __src = v32;
      v31 = 0;
      v8 = 1;
LABEL_15:
      v30 = 0;
LABEL_16:
      *(_OWORD *)(a1 + 136) = *(_OWORD *)v33;
      *(_QWORD *)(a1 + 152) = v34;
      v33[0] = 0;
      v33[1] = 0;
      *(_OWORD *)(a1 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a1 + 176) = v36;
      v34 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v36 = 0;
      *(_BYTE *)(a1 + 184) = 1;
      if (v8)
      {
        v10 = __p[0];
        if (__p[0])
        {
          v11 = __p[1];
          v12 = __p[0];
          if (__p[1] != __p[0])
          {
            do
              v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
            while (v11 != v10);
            v12 = __p[0];
          }
          __p[1] = v10;
          operator delete(v12);
        }
        v13 = v33[0];
        if (v33[0])
        {
          v14 = v33[1];
          v15 = v33[0];
          if (v33[1] != v33[0])
          {
            do
            {
              v17 = *--v14;
              v16 = v17;
              *v14 = 0;
              if (v17)
                MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
            }
            while (v14 != v13);
            v15 = v33[0];
          }
          v33[1] = v13;
          operator delete(v15);
        }
        if (__src != v32)
          free(__src);
        v37 = 0;
      }
      goto LABEL_33;
    }
    if (v6 < 5)
    {
      v9 = v6;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v6, 24);
      v9 = v30;
      if (!v30)
        goto LABEL_14;
    }
    memcpy(*(void **)(a1 + 24), __src, 24 * v9);
LABEL_14:
    *(_DWORD *)(a1 + 32) = v6;
    v8 = v37;
    goto LABEL_15;
  }
LABEL_33:
  mlir::InFlightDiagnostic::abandon(&v26);
  if (v26)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v26);
  if (v37)
  {
    v18 = __p[0];
    if (__p[0])
    {
      v19 = __p[1];
      v20 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p[0];
      }
      __p[1] = v18;
      operator delete(v20);
    }
    v21 = v33[0];
    if (v33[0])
    {
      v22 = v33[1];
      v23 = v33[0];
      if (v33[1] != v33[0])
      {
        do
        {
          v25 = *--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
            MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
        }
        while (v22 != v21);
        v23 = v33[0];
      }
      v33[1] = v21;
      operator delete(v23);
    }
    if (__src != v32)
      free(__src);
  }
}

void `anonymous namespace'::EncodingReader::emitError<char const(&)[33],llvm::StringRef &,char const(&)[19],llvm::StringRef>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  int v9;
  int v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  void *__src;
  unsigned int v32;
  int v33;
  _BYTE v34[96];
  void *v35[2];
  uint64_t v36;
  void *__p[2];
  uint64_t v38;
  unsigned __int8 v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  mlir::emitError(a2, (uint64_t)&v28);
  v7 = v28;
  if (v28)
  {
    mlir::Diagnostic::append<char const(&)[33],llvm::StringRef &,char const(&)[19],llvm::StringRef>((uint64_t)&v29, "trailing characters found after ", a3, " assembly format: ", a4);
    v7 = v28;
  }
  *(_QWORD *)a1 = v7;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  if (v39)
  {
    *(_QWORD *)(a1 + 8) = v29;
    v8 = v32;
    *(_DWORD *)(a1 + 16) = v30;
    *(_QWORD *)(a1 + 24) = a1 + 40;
    *(_QWORD *)(a1 + 32) = *(_QWORD *)"";
    if (!(_DWORD)v8 || &v28 == (uint64_t *)a1)
    {
      v10 = 1;
      goto LABEL_16;
    }
    if (__src != v34)
    {
      *(_QWORD *)(a1 + 24) = __src;
      v9 = v33;
      *(_DWORD *)(a1 + 32) = v8;
      *(_DWORD *)(a1 + 36) = v9;
      __src = v34;
      v33 = 0;
      v10 = 1;
LABEL_15:
      v32 = 0;
LABEL_16:
      *(_OWORD *)(a1 + 136) = *(_OWORD *)v35;
      *(_QWORD *)(a1 + 152) = v36;
      v35[0] = 0;
      v35[1] = 0;
      *(_OWORD *)(a1 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a1 + 176) = v38;
      v36 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v38 = 0;
      *(_BYTE *)(a1 + 184) = 1;
      if (v10)
      {
        v12 = __p[0];
        if (__p[0])
        {
          v13 = __p[1];
          v14 = __p[0];
          if (__p[1] != __p[0])
          {
            do
              v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
            while (v13 != v12);
            v14 = __p[0];
          }
          __p[1] = v12;
          operator delete(v14);
        }
        v15 = v35[0];
        if (v35[0])
        {
          v16 = v35[1];
          v17 = v35[0];
          if (v35[1] != v35[0])
          {
            do
            {
              v19 = *--v16;
              v18 = v19;
              *v16 = 0;
              if (v19)
                MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
            }
            while (v16 != v15);
            v17 = v35[0];
          }
          v35[1] = v15;
          operator delete(v17);
        }
        if (__src != v34)
          free(__src);
        v39 = 0;
      }
      goto LABEL_33;
    }
    if (v8 < 5)
    {
      v11 = v8;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v8, 24);
      v11 = v32;
      if (!v32)
        goto LABEL_14;
    }
    memcpy(*(void **)(a1 + 24), __src, 24 * v11);
LABEL_14:
    *(_DWORD *)(a1 + 32) = v8;
    v10 = v39;
    goto LABEL_15;
  }
LABEL_33:
  mlir::InFlightDiagnostic::abandon(&v28);
  if (v28)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v28);
  if (v39)
  {
    v20 = __p[0];
    if (__p[0])
    {
      v21 = __p[1];
      v22 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
        while (v21 != v20);
        v22 = __p[0];
      }
      __p[1] = v20;
      operator delete(v22);
    }
    v23 = v35[0];
    if (v35[0])
    {
      v24 = v35[1];
      v25 = v35[0];
      if (v35[1] != v35[0])
      {
        do
        {
          v27 = *--v24;
          v26 = v27;
          *v24 = 0;
          if (v27)
            MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
        }
        while (v24 != v23);
        v25 = v35[0];
      }
      v35[1] = v23;
      operator delete(v25);
    }
    if (__src != v34)
      free(__src);
  }
}

uint64_t mlir::Diagnostic::append<char const(&)[33],llvm::StringRef &,char const(&)[19],llvm::StringRef>(uint64_t a1, char *__s, uint64_t a3, char *a4, uint64_t a5)
{
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const void ***v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  unint64_t v19;
  BOOL v20;
  char *v21;
  const void **v22;
  char *v23;
  size_t v24;
  __int16 v25;

  v10 = strlen(__s);
  v11 = a1 + 16;
  v12 = *(_QWORD *)(a1 + 16);
  LODWORD(v22) = 3;
  v23 = __s;
  v24 = v10;
  v13 = *(unsigned int *)(a1 + 24);
  v14 = &v22;
  if (v13 >= *(_DWORD *)(a1 + 28))
  {
    v19 = v13 + 1;
    v20 = v12 + 24 * v13 > (unint64_t)&v22;
    if (v12 <= (unint64_t)&v22 && v20)
    {
      v21 = (char *)&v22 - v12;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v11, (void *)(a1 + 32), v19, 24);
      v12 = *(_QWORD *)(a1 + 16);
      v14 = (const void ***)&v21[v12];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v11, (void *)(a1 + 32), v19, 24);
      v12 = *(_QWORD *)(a1 + 16);
      v14 = &v22;
    }
  }
  v15 = v12 + 24 * *(unsigned int *)(a1 + 24);
  v16 = *(_OWORD *)v14;
  *(_QWORD *)(v15 + 16) = v14[2];
  *(_OWORD *)v15 = v16;
  ++*(_DWORD *)(a1 + 24);
  v25 = 261;
  v17 = *(char **)(a3 + 8);
  v22 = *(const void ***)a3;
  v23 = v17;
  mlir::Diagnostic::operator<<(a1, &v22);
  return mlir::Diagnostic::append<char const(&)[19],llvm::StringRef>(a1, a4, a5);
}

uint64_t mlir::Diagnostic::append<char const(&)[19],llvm::StringRef>(uint64_t a1, char *__s, uint64_t a3)
{
  size_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  const void ***v10;
  uint64_t v11;
  __int128 v12;
  char *v13;
  unint64_t v15;
  BOOL v16;
  char *v17;
  const void **v18;
  char *v19;
  size_t v20;
  __int16 v21;

  v6 = strlen(__s);
  v7 = a1 + 16;
  v8 = *(_QWORD *)(a1 + 16);
  LODWORD(v18) = 3;
  v19 = __s;
  v20 = v6;
  v9 = *(unsigned int *)(a1 + 24);
  v10 = &v18;
  if (v9 >= *(_DWORD *)(a1 + 28))
  {
    v15 = v9 + 1;
    v16 = v8 + 24 * v9 > (unint64_t)&v18;
    if (v8 <= (unint64_t)&v18 && v16)
    {
      v17 = (char *)&v18 - v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v7, (void *)(a1 + 32), v15, 24);
      v8 = *(_QWORD *)(a1 + 16);
      v10 = (const void ***)&v17[v8];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v7, (void *)(a1 + 32), v15, 24);
      v8 = *(_QWORD *)(a1 + 16);
      v10 = &v18;
    }
  }
  v11 = v8 + 24 * *(unsigned int *)(a1 + 24);
  v12 = *(_OWORD *)v10;
  *(_QWORD *)(v11 + 16) = v10[2];
  *(_OWORD *)v11 = v12;
  ++*(_DWORD *)(a1 + 24);
  v21 = 261;
  v13 = *(char **)(a3 + 8);
  v18 = *(const void ***)a3;
  v19 = v13;
  mlir::Diagnostic::operator<<(a1, &v18);
  return a1;
}

uint64_t `anonymous namespace'::AttrTypeReader::resolveType(_anonymous_namespace_::AttrTypeReader *this, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  _OWORD *v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  mlir::MLIRContext *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  const void ***v24;
  char *v25;
  char *v26;
  __int128 v27;
  const void ***v28;
  char *v29;
  char *v30;
  __int128 v31;
  uint64_t v32;
  const void ***v33;
  char *v34;
  char *v35;
  __int128 v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t **Context;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  _QWORD *v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  void *v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  BOOL v63;
  int64_t v64;
  int64_t v65;
  int64_t v66;
  char *v67;
  unint64_t v68;
  const char *v69;
  uint64_t v70;
  __int16 v71;
  __int128 v72;
  uint64_t v73;
  uint64_t v74;
  const void **v75;
  uint64_t v76;
  __int128 v77;
  uint64_t v78;
  __int128 *v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void *v84;
  unsigned int v85;
  unsigned int v86;
  _BYTE v87[96];
  void *v88;
  _QWORD *v89;
  void *__p;
  _QWORD *v91;
  char v92;
  uint64_t v93;

  v93 = *MEMORY[0x24BDAC8D0];
  if (*((unsigned int *)this + 22) <= a2)
  {
    mlir::emitError(*((_QWORD *)this + 17), (uint64_t)&v82);
    if (v82)
    {
      LODWORD(v75) = 3;
      v76 = (uint64_t)"invalid ";
      *(_QWORD *)&v77 = 8;
      v24 = &v75;
      v25 = (char *)v84;
      if (v85 >= v86)
      {
        v60 = v85 + 1;
        if (v84 <= &v75 && (char *)v84 + 24 * v85 > (char *)&v75)
        {
          v64 = (char *)&v75 - (_BYTE *)v84;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v60, 24);
          v25 = (char *)v84;
          v24 = (const void ***)((char *)v84 + v64);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v60, 24);
          v24 = &v75;
          v25 = (char *)v84;
        }
      }
      v26 = &v25[24 * v85];
      v27 = *(_OWORD *)v24;
      *((_QWORD *)v26 + 2) = v24[2];
      *(_OWORD *)v26 = v27;
      ++v85;
      if (v82)
      {
        LOWORD(v78) = 261;
        v75 = (const void **)"Type";
        v76 = 4;
        mlir::Diagnostic::operator<<((uint64_t)&v83, &v75);
        if (v82)
        {
          LODWORD(v75) = 3;
          v76 = (uint64_t)" index: ";
          *(_QWORD *)&v77 = 8;
          v28 = &v75;
          v29 = (char *)v84;
          if (v85 >= v86)
          {
            v61 = v85 + 1;
            if (v84 <= &v75 && (char *)v84 + 24 * v85 > (char *)&v75)
            {
              v65 = (char *)&v75 - (_BYTE *)v84;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v61, 24);
              v29 = (char *)v84;
              v28 = (const void ***)((char *)v84 + v65);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v61, 24);
              v28 = &v75;
              v29 = (char *)v84;
            }
          }
          v30 = &v29[24 * v85];
          v31 = *(_OWORD *)v28;
          *((_QWORD *)v30 + 2) = v28[2];
          *(_OWORD *)v30 = v31;
          v32 = ++v85;
          if (v82)
          {
            LODWORD(v75) = 5;
            v76 = a2;
            v33 = &v75;
            v34 = (char *)v84;
            if (v32 >= v86)
            {
              v62 = v32 + 1;
              v63 = (char *)v84 + 24 * v32 > (char *)&v75;
              if (v84 <= &v75 && v63)
              {
                v66 = (char *)&v75 - (_BYTE *)v84;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v62, 24);
                v34 = (char *)v84;
                v33 = (const void ***)((char *)v84 + v66);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v87, v62, 24);
                v33 = &v75;
                v34 = (char *)v84;
              }
            }
            v35 = &v34[24 * v85];
            v36 = *(_OWORD *)v33;
            *((_QWORD *)v35 + 2) = v33[2];
            *(_OWORD *)v35 = v36;
            ++v85;
            if (v82)
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v82);
          }
        }
      }
    }
    if (!v92)
      return 0;
    v37 = __p;
    if (__p)
    {
      v38 = v91;
      v39 = __p;
      if (v91 != __p)
      {
        do
          v38 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v38 - 1);
        while (v38 != v37);
        v39 = __p;
      }
      v91 = v37;
      operator delete(v39);
    }
    v40 = v88;
    if (!v88)
      goto LABEL_71;
    v41 = v89;
    v42 = v88;
    if (v89 == v88)
      goto LABEL_70;
    do
    {
      v44 = *--v41;
      v43 = v44;
      *v41 = 0;
      if (v44)
        MEMORY[0x20BD002D4](v43, 0x1000C8077774924);
    }
    while (v41 != v40);
    goto LABEL_69;
  }
  v4 = *((_QWORD *)this + 10);
  v5 = v4 + 40 * a2;
  result = *(_QWORD *)v5;
  if (*(_QWORD *)v5)
    return result;
  v7 = v4 + 40 * a2;
  v9 = *(_OWORD *)(v7 + 24);
  v8 = (_OWORD *)(v7 + 24);
  v10 = *((_QWORD *)this + 17);
  v72 = v9;
  v73 = v9;
  v74 = v10;
  if (!*((_BYTE *)v8 - 8))
  {
    v75 = (const void **)"Type";
    v76 = 4;
    v67 = 0;
    v68 = 0;
    {
      v81 = 0;
      Context = (uint64_t **)mlir::Attribute::getContext((_anonymous_namespace_::AttrTypeReader *)((char *)this + 136));
      mlir::parseType(v67, v68, Context, &v81, 1);
    }
    return 0;
  }
  v11 = *((_QWORD *)this + 2);
  v12 = *((_QWORD *)this + 18);
  v75 = (const void **)&off_24C028780;
  v76 = (uint64_t)this;
  v77 = *(_OWORD *)this;
  v78 = v11;
  v79 = &v72;
  v80 = v12;
  v13 = v4 + 40 * a2;
  v15 = *(_QWORD *)(v13 + 8);
  v14 = v13 + 8;
  v16 = (mlir::MLIRContext *)mlir::Attribute::getContext((_anonymous_namespace_::AttrTypeReader *)((char *)this + 136));
  {
    v17 = *((_QWORD *)this + 19);
    v18 = *(unsigned int *)(v17 + 120);
    if ((_DWORD)v18)
    {
      v19 = *(_QWORD **)(v17 + 112);
      v20 = 8 * v18;
      while ((*(unsigned __int8 (**)(_QWORD, const void ***, _QWORD, _QWORD, uint64_t))(*(_QWORD *)*v19 + 16))(*v19, &v75, *(_QWORD *)(*(_QWORD *)v14 + 24), *(_QWORD *)(*(_QWORD *)v14 + 32), v5))
      {
        if (*(_QWORD *)v5)
          goto LABEL_54;
        v72 = *v8;
        v73 = v72;
        ++v19;
        v20 -= 8;
        if (!v20)
          goto LABEL_10;
      }
      return 0;
    }
LABEL_10:
    v21 = *(_QWORD *)(*(_QWORD *)v14 + 16);
    if (v21)
    {
      v22 = (*(uint64_t (**)(uint64_t, const void ***))(*(_QWORD *)v21 + 24))(v21, &v75);
      *(_QWORD *)v5 = v22;
      v23 = v22 != 0;
    }
    else
    {
      v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v82);
      if (v82)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v82);
      if (v92)
      {
        v46 = __p;
        if (__p)
        {
          v47 = v91;
          v48 = __p;
          if (v91 != __p)
          {
            do
              v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
            while (v47 != v46);
            v48 = __p;
          }
          v91 = v46;
          operator delete(v48);
        }
        v49 = v88;
        if (v88)
        {
          v50 = v89;
          v51 = v88;
          if (v89 != v88)
          {
            do
            {
              v53 = *--v50;
              v52 = v53;
              *v50 = 0;
              if (v53)
                MEMORY[0x20BD002D4](v52, 0x1000C8077774924);
            }
            while (v50 != v49);
            v51 = v88;
          }
          v89 = v49;
          operator delete(v51);
        }
        if (v84 != v87)
          free(v84);
      }
    }
    if (v23)
    {
LABEL_54:
      if (v73 == (_QWORD)v72 + *((_QWORD *)&v72 + 1))
        return *(_QWORD *)v5;
      v71 = 1283;
      v67 = "unexpected trailing bytes after ";
      v69 = "Type";
      v70 = 4;
      v75 = (const void **)&v67;
      *(_QWORD *)&v77 = " entry";
      LOWORD(v78) = 770;
      if (v82)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v82);
      if (!v92)
        return 0;
      v54 = __p;
      if (__p)
      {
        v55 = v91;
        v56 = __p;
        if (v91 != __p)
        {
          do
            v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
          while (v55 != v54);
          v56 = __p;
        }
        v91 = v54;
        operator delete(v56);
      }
      v40 = v88;
      if (!v88)
        goto LABEL_71;
      v57 = v89;
      v42 = v88;
      if (v89 == v88)
      {
LABEL_70:
        v89 = v40;
        operator delete(v42);
LABEL_71:
        if (v84 != v87)
          free(v84);
        return 0;
      }
      do
      {
        v59 = *--v57;
        v58 = v59;
        *v57 = 0;
        if (v59)
          MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
      }
      while (v57 != v40);
LABEL_69:
      v42 = v88;
      goto LABEL_70;
    }
  }
  return 0;
}

uint64_t `anonymous namespace'::EncodingReader::parseByte<BOOL>(_QWORD *a1, BOOL *a2)
{
  _BYTE *v2;
  uint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[3];
  void *v14;
  uint64_t v15;
  void *v16;
  _QWORD *v17;
  void *__p;
  _QWORD *v19;
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v2 = (_BYTE *)a1[2];
  if (v2 == (_BYTE *)(*a1 + a1[1]))
  {
    v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v13);
    if (v13[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v13);
    if (v20)
    {
      v5 = __p;
      if (__p)
      {
        v6 = v19;
        v7 = __p;
        if (v19 != __p)
        {
          do
            v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
          while (v6 != v5);
          v7 = __p;
        }
        v19 = v5;
        operator delete(v7);
      }
      v8 = v16;
      if (v16)
      {
        v9 = v17;
        v10 = v16;
        if (v17 != v16)
        {
          do
          {
            v12 = *--v9;
            v11 = v12;
            *v9 = 0;
            if (v12)
              MEMORY[0x20BD002D4](v11, 0x1000C8077774924);
          }
          while (v9 != v8);
          v10 = v16;
        }
        v17 = v8;
        operator delete(v10);
      }
      if (v14 != &v15)
        free(v14);
    }
  }
  else
  {
    a1[2] = v2 + 1;
    *a2 = *v2 != 0;
    return 1;
  }
  return v3;
}

uint64_t `anonymous namespace'::EncodingReader::parseByte<mlir::AsmResourceEntryKind>(_QWORD *a1, _DWORD *a2)
{
  unsigned __int8 *v2;
  uint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[3];
  void *v14;
  uint64_t v15;
  void *v16;
  _QWORD *v17;
  void *__p;
  _QWORD *v19;
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  v2 = (unsigned __int8 *)a1[2];
  if (v2 == (unsigned __int8 *)(*a1 + a1[1]))
  {
    v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v13);
    if (v13[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v13);
    if (v20)
    {
      v5 = __p;
      if (__p)
      {
        v6 = v19;
        v7 = __p;
        if (v19 != __p)
        {
          do
            v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
          while (v6 != v5);
          v7 = __p;
        }
        v19 = v5;
        operator delete(v7);
      }
      v8 = v16;
      if (v16)
      {
        v9 = v17;
        v10 = v16;
        if (v17 != v16)
        {
          do
          {
            v12 = *--v9;
            v11 = v12;
            *v9 = 0;
            if (v12)
              MEMORY[0x20BD002D4](v11, 0x1000C8077774924);
          }
          while (v9 != v8);
          v10 = v16;
        }
        v17 = v8;
        operator delete(v10);
      }
      if (v14 != &v15)
        free(v14);
    }
  }
  else
  {
    a1[2] = v2 + 1;
    *a2 = *v2;
    return 1;
  }
  return v3;
}

void `anonymous namespace'::EncodingReader::emitError<char const(&)[46],llvm::StringRef &,char const(&)[2]>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;
  int v7;
  int v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  void *__src;
  unsigned int v30;
  int v31;
  _BYTE v32[96];
  void *v33[2];
  uint64_t v34;
  void *__p[2];
  uint64_t v36;
  unsigned __int8 v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  mlir::emitError(a2, (uint64_t)&v26);
  v5 = v26;
  if (v26)
  {
    mlir::Diagnostic::append<char const(&)[28],llvm::StringRef &,char const(&)[2]>((uint64_t)&v27, "unexpected trailing bytes in resource entry '", a3, "'");
    v5 = v26;
  }
  *(_QWORD *)a1 = v5;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  if (v37)
  {
    *(_QWORD *)(a1 + 8) = v27;
    v6 = v30;
    *(_DWORD *)(a1 + 16) = v28;
    *(_QWORD *)(a1 + 24) = a1 + 40;
    *(_QWORD *)(a1 + 32) = *(_QWORD *)"";
    if (!(_DWORD)v6 || &v26 == (uint64_t *)a1)
    {
      v8 = 1;
      goto LABEL_16;
    }
    if (__src != v32)
    {
      *(_QWORD *)(a1 + 24) = __src;
      v7 = v31;
      *(_DWORD *)(a1 + 32) = v6;
      *(_DWORD *)(a1 + 36) = v7;
      __src = v32;
      v31 = 0;
      v8 = 1;
LABEL_15:
      v30 = 0;
LABEL_16:
      *(_OWORD *)(a1 + 136) = *(_OWORD *)v33;
      *(_QWORD *)(a1 + 152) = v34;
      v33[0] = 0;
      v33[1] = 0;
      *(_OWORD *)(a1 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a1 + 176) = v36;
      v34 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v36 = 0;
      *(_BYTE *)(a1 + 184) = 1;
      if (v8)
      {
        v10 = __p[0];
        if (__p[0])
        {
          v11 = __p[1];
          v12 = __p[0];
          if (__p[1] != __p[0])
          {
            do
              v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
            while (v11 != v10);
            v12 = __p[0];
          }
          __p[1] = v10;
          operator delete(v12);
        }
        v13 = v33[0];
        if (v33[0])
        {
          v14 = v33[1];
          v15 = v33[0];
          if (v33[1] != v33[0])
          {
            do
            {
              v17 = *--v14;
              v16 = v17;
              *v14 = 0;
              if (v17)
                MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
            }
            while (v14 != v13);
            v15 = v33[0];
          }
          v33[1] = v13;
          operator delete(v15);
        }
        if (__src != v32)
          free(__src);
        v37 = 0;
      }
      goto LABEL_33;
    }
    if (v6 < 5)
    {
      v9 = v6;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v6, 24);
      v9 = v30;
      if (!v30)
        goto LABEL_14;
    }
    memcpy(*(void **)(a1 + 24), __src, 24 * v9);
LABEL_14:
    *(_DWORD *)(a1 + 32) = v6;
    v8 = v37;
    goto LABEL_15;
  }
LABEL_33:
  mlir::InFlightDiagnostic::abandon(&v26);
  if (v26)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v26);
  if (v37)
  {
    v18 = __p[0];
    if (__p[0])
    {
      v19 = __p[1];
      v20 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p[0];
      }
      __p[1] = v18;
      operator delete(v20);
    }
    v21 = v33[0];
    if (v33[0])
    {
      v22 = v33[1];
      v23 = v33[0];
      if (v33[1] != v33[0])
      {
        do
        {
          v25 = *--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
            MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
        }
        while (v22 != v21);
        v23 = v33[0];
      }
      v33[1] = v21;
      operator delete(v23);
    }
    if (__src != v32)
      free(__src);
  }
}

void `anonymous namespace'::ParsedResourceEntry::emitError(_anonymous_namespace_::ParsedResourceEntry *this@<X0>, uint64_t a2@<X8>)
{
  mlir::emitError(*(_QWORD *)(*((_QWORD *)this + 4) + 24), a2);
}

double `anonymous namespace'::ParsedResourceEntry::parseAsString@<D0>(_anonymous_namespace_::ParsedResourceEntry *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v4;
  uint64_t v5;
  __int128 v6;
  const void *v7;
  size_t v8;
  __int128 *p_dst;
  __int128 *p_src;
  char *v11;
  char *v12;
  __int128 v13;
  char *v14;
  uint64_t v15;
  __int128 *v16;
  char *v17;
  char *v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  int64_t v32;
  int64_t v33;
  __int128 __src;
  uint64_t v36;
  __int16 v37;
  __int128 __dst;
  unint64_t v39;
  void *v40;
  unsigned int v41;
  unsigned int v42;
  _BYTE v43[96];
  void *v44;
  _QWORD *v45;
  void *__p;
  _QWORD *v47;
  char v48;
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)this + 6) == 2)
  {
    __src = 0uLL;
    v4 = (uint64_t *)*((_QWORD *)this + 4);
    v5 = *((_QWORD *)this + 5);
    *(_QWORD *)&__dst = 0;
    {
      v7 = (const void *)__src;
      if (!(_QWORD)__src)
      {
        __dst = 0uLL;
        v39 = 0;
LABEL_41:
        *(_QWORD *)&v6 = __dst;
        *(_OWORD *)a2 = __dst;
        *(_QWORD *)(a2 + 16) = v39;
        *(_BYTE *)(a2 + 24) = 1;
        return *(double *)&v6;
      }
      v8 = *((_QWORD *)&__src + 1);
      if (*((_QWORD *)&__src + 1) >= 0x7FFFFFFFFFFFFFF8uLL)
        abort();
      if (*((_QWORD *)&__src + 1) >= 0x17uLL)
      {
        v28 = (*((_QWORD *)&__src + 1) & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((*((_QWORD *)&__src + 1) | 7) != 0x17)
          v28 = *((_QWORD *)&__src + 1) | 7;
        v29 = v28 + 1;
        p_dst = (__int128 *)operator new(v28 + 1);
        *((_QWORD *)&__dst + 1) = v8;
        v39 = v29 | 0x8000000000000000;
        *(_QWORD *)&__dst = p_dst;
      }
      else
      {
        HIBYTE(v39) = BYTE8(__src);
        p_dst = &__dst;
        if (!*((_QWORD *)&__src + 1))
          goto LABEL_40;
      }
      memmove(p_dst, v7, v8);
LABEL_40:
      *((_BYTE *)p_dst + v8) = 0;
      goto LABEL_41;
    }
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 24) = 0;
  }
  else
  {
    mlir::emitError(*(_QWORD *)(*((_QWORD *)this + 4) + 24), (uint64_t)&__dst);
    if ((_QWORD)__dst)
    {
      LODWORD(__src) = 3;
      *((_QWORD *)&__src + 1) = "expected a string resource entry, but found a ";
      v36 = 46;
      p_src = &__src;
      v11 = (char *)v40;
      if (v41 >= v42)
      {
        v30 = v41 + 1;
        if (v40 <= &__src && (char *)v40 + 24 * v41 > (char *)&__src)
        {
          v32 = (char *)&__src - (_BYTE *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          v11 = (char *)v40;
          p_src = (__int128 *)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          p_src = &__src;
          v11 = (char *)v40;
        }
      }
      v12 = &v11[24 * v41];
      v13 = *p_src;
      *((_QWORD *)v12 + 2) = *((_QWORD *)p_src + 2);
      *(_OWORD *)v12 = v13;
      ++v41;
    }
    v14 = mlir::toString(*((_DWORD *)this + 6));
    if ((_QWORD)__dst
      && (v37 = 261,
          *(_QWORD *)&__src = v14,
          *((_QWORD *)&__src + 1) = v15,
          mlir::Diagnostic::operator<<((uint64_t)&__dst + 8, (const void ***)&__src),
          (_QWORD)__dst))
    {
      LODWORD(__src) = 3;
      *((_QWORD *)&__src + 1) = " entry instead";
      v36 = 14;
      v16 = &__src;
      v17 = (char *)v40;
      if (v41 >= v42)
      {
        v31 = v41 + 1;
        if (v40 <= &__src && (char *)v40 + 24 * v41 > (char *)&__src)
        {
          v33 = (char *)&__src - (_BYTE *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v31, 24);
          v17 = (char *)v40;
          v16 = (__int128 *)((char *)v40 + v33);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v31, 24);
          v16 = &__src;
          v17 = (char *)v40;
        }
      }
      v18 = &v17[24 * v41];
      v6 = *v16;
      *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
      *(_OWORD *)v18 = v6;
      ++v41;
      v19 = __dst;
      *(_BYTE *)a2 = 0;
      *(_BYTE *)(a2 + 24) = 0;
      if (v19)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&__dst);
    }
    else
    {
      *(_BYTE *)a2 = 0;
      *(_BYTE *)(a2 + 24) = 0;
    }
    if (v48)
    {
      v20 = __p;
      if (__p)
      {
        v21 = v47;
        v22 = __p;
        if (v47 != __p)
        {
          do
            v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
          while (v21 != v20);
          v22 = __p;
        }
        v47 = v20;
        operator delete(v22);
      }
      v23 = v44;
      if (v44)
      {
        v24 = v45;
        v25 = v44;
        if (v45 != v44)
        {
          do
          {
            v27 = *--v24;
            v26 = v27;
            *v24 = 0;
            if (v27)
              MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
          }
          while (v24 != v23);
          v25 = v44;
        }
        v45 = v23;
        operator delete(v25);
      }
      if (v40 != v43)
        free(v40);
    }
  }
  return *(double *)&v6;
}

void `anonymous namespace'::ParsedResourceEntry::parseAsBlob(uint64_t a1@<X0>, void (*a2)(void **__return_ptr, uint64_t, void *, uint64_t)@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  __n128 *v6;
  unint64_t v7;
  unint64_t v8;
  __n128 v9;
  char *v10;
  unint64_t v11;
  __n128 *v12;
  unint64_t v13;
  unint64_t v14;
  __n128 v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  _anonymous_namespace_::EncodingReader *v27;
  int8x8_t v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  void *v32;
  void *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t v37;
  size_t v38;
  unint64_t v39;
  __n128 *v40;
  char v41;
  __n128 *v42;
  char v43;
  __n128 *v44;
  unint64_t v45;
  unint64_t v46;
  char *v47;
  char *v48;
  unsigned int v49[2];
  void *__src;
  void *v51;
  __n128 v52;
  unint64_t v53;
  void *__dst[2];
  uint64_t v55;
  __n128 v56;
  uint64_t v57;
  char *v58;
  char v59;
  void *v60;
  _QWORD *v61;
  void *__p;
  _QWORD *v63;
  char v64;
  __n128 v65;
  uint64_t v66;
  unint64_t v67;
  __int16 v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)(a1 + 24))
  {
    mlir::emitError(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 24), (uint64_t)__dst);
    if (__dst[0])
    {
      v65.n128_u32[0] = 3;
      v65.n128_u64[1] = (unint64_t)"expected a blob resource entry, but found a ";
      v66 = 44;
      v6 = &v65;
      v7 = v56.n128_u64[0];
      if (v56.n128_u32[2] >= v56.n128_u32[3])
      {
        v45 = v56.n128_u32[2] + 1;
        if (v56.n128_u64[0] <= (unint64_t)&v65
          && v56.n128_u64[0] + 24 * (unint64_t)v56.n128_u32[2] > (unint64_t)&v65)
        {
          v47 = (char *)&v65 - v56.n128_u64[0];
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, &v57, v45, 24);
          v7 = v56.n128_u64[0];
          v6 = (__n128 *)&v47[v56.n128_u64[0]];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, &v57, v45, 24);
          v6 = &v65;
          v7 = v56.n128_u64[0];
        }
      }
      v8 = v7 + 24 * v56.n128_u32[2];
      v9 = *v6;
      *(_QWORD *)(v8 + 16) = v6[1].n128_u64[0];
      *(__n128 *)v8 = v9;
      ++v56.n128_u32[2];
    }
    v10 = mlir::toString(*(_DWORD *)(a1 + 24));
    if (__dst[0]
      && (v68 = 261,
          v65.n128_u64[0] = (unint64_t)v10,
          v65.n128_u64[1] = v11,
          mlir::Diagnostic::operator<<((uint64_t)&__dst[1], (const void ***)&v65),
          __dst[0]))
    {
      v65.n128_u32[0] = 3;
      v65.n128_u64[1] = (unint64_t)" entry instead";
      v66 = 14;
      v12 = &v65;
      v13 = v56.n128_u64[0];
      if (v56.n128_u32[2] >= v56.n128_u32[3])
      {
        v46 = v56.n128_u32[2] + 1;
        if (v56.n128_u64[0] <= (unint64_t)&v65
          && v56.n128_u64[0] + 24 * (unint64_t)v56.n128_u32[2] > (unint64_t)&v65)
        {
          v48 = (char *)&v65 - v56.n128_u64[0];
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, &v57, v46, 24);
          v13 = v56.n128_u64[0];
          v12 = (__n128 *)&v48[v56.n128_u64[0]];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, &v57, v46, 24);
          v12 = &v65;
          v13 = v56.n128_u64[0];
        }
      }
      v14 = v13 + 24 * v56.n128_u32[2];
      v15 = *v12;
      *(_QWORD *)(v14 + 16) = v12[1].n128_u64[0];
      *(__n128 *)v14 = v15;
      ++v56.n128_u32[2];
      v16 = __dst[0];
      *(_BYTE *)a4 = 0;
      *(_BYTE *)(a4 + 64) = 0;
      if (v16)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)__dst);
    }
    else
    {
      *(_BYTE *)a4 = 0;
      *(_BYTE *)(a4 + 64) = 0;
    }
    if (v64)
    {
      v17 = __p;
      if (__p)
      {
        v18 = v63;
        v19 = __p;
        if (v63 != __p)
        {
          do
            v18 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v18 - 1);
          while (v18 != v17);
          v19 = __p;
        }
        v63 = v17;
        operator delete(v19);
      }
      v20 = v60;
      if (v60)
      {
        v21 = v61;
        v22 = v60;
        if (v61 != v60)
        {
          do
          {
            v24 = *--v21;
            v23 = v24;
            *v21 = 0;
            if (v24)
              MEMORY[0x20BD002D4](v23, 0x1000C8077774924);
          }
          while (v21 != v20);
          v22 = v60;
        }
        v61 = v20;
        operator delete(v22);
      }
      if ((uint64_t *)v56.n128_u64[0] != &v57)
        free((void *)v56.n128_u64[0]);
    }
    return;
  }
  __src = 0;
  v51 = 0;
  *(_QWORD *)v49 = 0;
  v27 = *(_anonymous_namespace_::EncodingReader **)(a1 + 32);
    || (__dst[0] = 0,
  {
    *(_BYTE *)a4 = 0;
    *(_BYTE *)(a4 + 64) = 0;
    return;
  }
  v30 = *(unint64_t **)(a1 + 48);
  v31 = *v30;
  if (*v30)
  {
    v33 = __src;
    v32 = v51;
    v34 = v30[1];
    if (v34)
    {
      v35 = (unint64_t *)(v34 + 8);
      do
        v36 = __ldxr(v35);
      while (__stxr(v36 + 1, v35));
    }
    v52.n128_u64[0] = v31;
    v52.n128_u64[1] = v34;
        + 6;
        + 6;
        + 6;
       + 6 <= 7)
    {
      __dst[0] = v33;
      __dst[1] = v32;
      v55 = v29;
          + 6;
    }
    else
    {
                                                 + 8))(&v65, &v52);
      v37 = v67;
      v53 = 0;
      __dst[0] = v33;
      __dst[1] = v32;
      v55 = v29;
      v58 = (char *)v67;
      if (v67 <= 7)
      {
        v41 = 0;
        v59 = 0;
        *(_OWORD *)a4 = *(_OWORD *)__dst;
        *(_QWORD *)(a4 + 16) = v55;
        *(_QWORD *)(a4 + 48) = v37;
        goto LABEL_55;
      }
      if ((~(_BYTE)v67 & 6) != 0)
      {
        v56 = v65;
        v57 = v66;
        v59 = 0;
        *(_OWORD *)a4 = *(_OWORD *)__dst;
        *(_QWORD *)(a4 + 16) = v55;
        *(_QWORD *)(a4 + 48) = v37;
LABEL_50:
        v42 = (__n128 *)(a4 + 24);
        if ((v37 & 2) != 0 && (v37 & 4) != 0)
        {
          (*(void (**)(__n128 *, __n128 *))((v37 & 0xFFFFFFFFFFFFFFF8) + 8))(v42, &v56);
          v41 = v59;
        }
        else
        {
          v41 = 0;
          *v42 = v56;
          *(_QWORD *)(a4 + 40) = v57;
        }
        v58 = 0;
LABEL_55:
        *(_BYTE *)(a4 + 56) = v41;
        *(_BYTE *)(a4 + 64) = 1;
        v43 = v53;
        if (v53 >= 8)
        {
          if ((v53 & 4) != 0)
          {
            if ((v53 & 2) != 0)
              v44 = &v52;
            else
              v44 = (__n128 *)v52.n128_u64[0];
            (*(void (**)(__n128 *))((v53 & 0xFFFFFFFFFFFFFFF8) + 16))(v44);
          }
          if ((v43 & 2) == 0)
            llvm::deallocate_buffer((llvm *)v52.n128_u64[0], (void *)v52.n128_u64[1]);
        }
        return;
      }
      (*(void (**)(__n128 *, __n128 *))((v67 & 0xFFFFFFFFFFFFFFF8) + 8))(&v56, &v65);
      v37 = (unint64_t)v58;
    }
    v41 = 0;
    v59 = 0;
    *(_OWORD *)a4 = *(_OWORD *)__dst;
    *(_QWORD *)(a4 + 16) = v55;
    *(_QWORD *)(a4 + 48) = v37;
    if (v37 < 8)
      goto LABEL_55;
    goto LABEL_50;
  }
  v38 = (size_t)v51;
  a2(__dst, a3, v51, v29);
  memcpy(__dst[0], __src, v38);
  *(_OWORD *)a4 = *(_OWORD *)__dst;
  v39 = (unint64_t)v58;
  *(_QWORD *)(a4 + 16) = v55;
  *(_QWORD *)(a4 + 48) = v39;
  if (v39 >= 8)
  {
    v40 = (__n128 *)(a4 + 24);
    if ((v39 & 2) != 0 && (v39 & 4) != 0)
    {
      (*(void (**)(__n128 *, __n128 *))((v39 & 0xFFFFFFFFFFFFFFF8) + 8))(v40, &v56);
    }
    else
    {
      *v40 = v56;
      *(_QWORD *)(a4 + 40) = v57;
    }
  }
  *(_BYTE *)(a4 + 56) = v59;
  *(_BYTE *)(a4 + 64) = 1;
}

__n128 llvm::detail::UniqueFunctionBase<void,void *,unsigned long,unsigned long>::MoveImpl<`anonymous namespace'::ParsedResourceEntry::parseAsBlob(llvm::function_ref<mlir::AsmResourceBlob ()(unsigned long,unsigned long)>)::{lambda(void *,unsigned long,unsigned long)#1}>(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = *a2;
  *a1 = *a2;
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  return result;
}

void llvm::detail::UniqueFunctionBase<void,void *,unsigned long,unsigned long>::DestroyImpl<`anonymous namespace'::ParsedResourceEntry::parseAsBlob(llvm::function_ref<mlir::AsmResourceBlob ()(unsigned long,unsigned long)>)::{lambda(void *,unsigned long,unsigned long)#1}>(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 8);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

uint64_t *llvm::StringMap<std::string,llvm::MallocAllocator>::try_emplace<>(uint64_t a1, int8x16_t *a2, const unsigned __int8 *a3)
{
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  _QWORD *buffer;
  void *v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;

  v6 = llvm::StringMapImpl::LookupBucketFor((uint64_t *)a1, a2, a3);
  v7 = (uint64_t *)(*(_QWORD *)a1 + 8 * v6);
  v8 = *v7;
  if (*v7 == -8)
  {
    --*(_DWORD *)(a1 + 16);
    buffer = llvm::allocate_buffer((size_t)(a3 + 33), (std::align_val_t)8uLL);
    v10 = buffer + 4;
    if (a3)
LABEL_4:
      memcpy(v10, a2, (size_t)a3);
  }
  else
  {
    if (v8)
    {
      while (!v8 || v8 == -8)
      {
        v15 = v7[1];
        ++v7;
        v8 = v15;
      }
      return v7;
    }
    buffer = llvm::allocate_buffer((size_t)(a3 + 33), (std::align_val_t)8uLL);
    v10 = buffer + 4;
    if (a3)
      goto LABEL_4;
  }
  a3[(_QWORD)v10] = 0;
  *buffer = a3;
  buffer[1] = 0;
  buffer[2] = 0;
  buffer[3] = 0;
  *v7 = (uint64_t)buffer;
  ++*(_DWORD *)(a1 + 12);
  v7 = (uint64_t *)(*(_QWORD *)a1 + 8 * llvm::StringMapImpl::RehashTable((llvm::StringMapImpl *)a1, v6));
  if (*v7)
    v11 = *v7 == -8;
  else
    v11 = 1;
  if (v11)
  {
    do
    {
      v13 = v7[1];
      ++v7;
      v12 = v13;
      if (v13)
        v14 = v12 == -8;
      else
        v14 = 1;
    }
    while (v14);
  }
  return v7;
}

void std::vector<mlir::Value>::__append(void **a1, unint64_t a2)
{
  _BYTE *v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _BYTE *v13;
  char *v14;
  size_t v15;
  char *v16;
  char *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD *v21;
  char *v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;

  v5 = (char *)a1[1];
  v4 = a1[2];
  v6 = v5;
  if (a2 <= (v4 - v5) >> 3)
  {
    if (a2)
    {
      bzero(v5, 8 * a2);
      v6 = &v5[8 * a2];
    }
    a1[1] = v6;
  }
  else
  {
    v7 = (char *)*a1;
    v8 = v5 - (_BYTE *)*a1;
    v9 = v8 >> 3;
    v10 = (v8 >> 3) + a2;
    if (v10 >> 61)
      abort();
    v11 = v4 - v7;
    if (v11 >> 2 > v10)
      v10 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      if (v12 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v13 = operator new(8 * v12);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[8 * v9];
    v15 = 8 * a2;
    v16 = &v13[8 * v12];
    bzero(v14, v15);
    v17 = &v14[v15];
    if (v5 != v7)
    {
      v18 = v5 - v7 - 8;
      if (v18 < 0x58)
        goto LABEL_30;
      if ((unint64_t)(v5 - v13 - v8) < 0x20)
        goto LABEL_30;
      v19 = (v18 >> 3) + 1;
      v20 = 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
      v6 = &v5[-v20];
      v14 -= v20;
      v21 = &v13[8 * v9 - 16];
      v22 = v5 - 16;
      v23 = v19 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v24 = *(_OWORD *)v22;
        *(v21 - 1) = *((_OWORD *)v22 - 1);
        *v21 = v24;
        v21 -= 2;
        v22 -= 32;
        v23 -= 4;
      }
      while (v23);
      if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_30:
        do
        {
          v25 = *((_QWORD *)v6 - 1);
          v6 -= 8;
          *((_QWORD *)v14 - 1) = v25;
          v14 -= 8;
        }
        while (v6 != v7);
      }
      v6 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v16;
    if (v6)
      operator delete(v6);
  }
}

uint64_t mlir::BytecodeReader::Impl::parseAttribute<mlir::LocationAttr>(uint64_t a1, _anonymous_namespace_::EncodingReader *this, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD v26[2];
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  void *v30;
  uint64_t v31;
  void *v32;
  _QWORD *v33;
  void *__p;
  _QWORD *v35;
  char v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v28 = 0;
    return 0;
  v27 = v6;
  if (!v6)
    return 0;
  v7 = v6;
  if (mlir::LocationAttr::classof(v6))
    v8 = v7;
  else
    v8 = 0;
  *a3 = v8;
  if (v8)
    return 1;
  v28 = (unint64_t)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::LocationAttr]";
  v29 = 68;
  v11 = llvm::StringRef::find((uint64_t *)&v28, "DesiredTypeName = ", 0x12uLL, 0);
  if (v29 >= v11)
    v12 = v11;
  else
    v12 = v29;
  v13 = v28 + v12;
  v14 = v29 - v12;
  if (v29 - v12 >= 0x12)
    v15 = 18;
  else
    v15 = v29 - v12;
  v16 = v13 + v15;
  v17 = v14 - v15;
  if (v17 >= v17 - 1)
    --v17;
  v26[0] = v16;
  v26[1] = v17;
  v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v28);
  if (v28)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v28);
  if (v36)
  {
    v18 = __p;
    if (__p)
    {
      v19 = v35;
      v20 = __p;
      if (v35 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v35 = v18;
      operator delete(v20);
    }
    v21 = v32;
    if (v32)
    {
      v22 = v33;
      v23 = v32;
      if (v33 != v32)
      {
        do
        {
          v25 = *--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
            MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
        }
        while (v22 != v21);
        v23 = v32;
      }
      v33 = v21;
      operator delete(v23);
    }
    if (v30 != &v31)
      free(v30);
  }
  return v9;
}

void mlir::BytecodeReader::Impl::parseUseListOrderForRange(mlir::BytecodeReader::Impl *this, _anonymous_namespace_::EncodingReader *a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  unsigned int v17;
  char *v18;
  int v19;
  char *v20;
  int v21;
  BOOL v22;
  unsigned int v23;
  char *v24;
  void *v25;
  BOOL v26;
  unsigned int v27;
  llvm *v28;
  uint64_t v29;
  char *v30;
  char *v31;
  uint64_t v32;
  int v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  llvm *v38;
  uint64_t v39;
  unsigned int v40;
  void *__dst;
  unint64_t v42;
  _BYTE v43[24];
  void *__src;
  uint64_t v45;
  _QWORD v46[4];

  v3 = a3;
  v46[2] = *MEMORY[0x24BDAC8D0];
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v5 = 1;
  v37 = 1;
  if (a3 < 2)
    goto LABEL_4;
  {
    v5 = v37;
    if (v37)
    {
LABEL_4:
      v6 = 0;
      while (1)
      {
        v36 = 0;
          goto LABEL_54;
        v35 = 0;
          goto LABEL_54;
        v7 = v35;
        v8 = v35 >> 1;
        v35 >>= 1;
        __src = v46;
        v45 = *(_QWORD *)"";
        if (v7 <= 1)
        {
          v34 = v36;
          __dst = v43;
          v42 = *(_QWORD *)"";
          goto LABEL_20;
        }
        v9 = v5;
        v10 = v3;
        v11 = v8 <= 1 ? 1 : v8;
        __dst = 0;
          break;
        v26 = 1;
LABEL_44:
        *(_BYTE *)this = 0;
        *((_BYTE *)this + 24) = 0;
        v3 = v10;
        v5 = v9;
        v25 = __src;
        if (__src == v46)
          goto LABEL_37;
LABEL_36:
        free(v25);
LABEL_37:
        if (v26)
          goto LABEL_55;
        if (++v6 == v5)
          goto LABEL_62;
      }
      v12 = 0;
      v13 = v11 - 1;
      while (1)
      {
        v14 = (int)__dst;
        v15 = v45;
        if (v45 >= (unint64_t)HIDWORD(v45))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v46, v45 + 1, 4);
          v15 = v45;
        }
        *((_DWORD *)__src + v15) = v14;
        v16 = (v45 + 1);
        LODWORD(v45) = v45 + 1;
        if (v13 == v12)
          break;
        __dst = 0;
        ++v12;
        {
          v26 = v12 < v8;
          goto LABEL_44;
        }
      }
      v34 = v36;
      __dst = v43;
      v42 = *(_QWORD *)"";
      v3 = v10;
      v5 = v9;
      if ((_DWORD)v16)
      {
        if (__src == v46)
        {
          v27 = v16;
          if (v16 < 5
            || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v43, v16, 4), (v27 = v45) != 0))
          {
            memcpy(__dst, __src, 4 * v27);
          }
          LODWORD(v42) = v16;
        }
        else
        {
          __dst = __src;
          v42 = __PAIR64__(HIDWORD(v45), v16);
          __src = v46;
          HIDWORD(v45) = 0;
        }
        LODWORD(v45) = 0;
      }
LABEL_20:
      v43[16] = v7 & 1;
      if (v40)
      {
        v17 = (37 * v34) & (v40 - 1);
        v18 = (char *)v38 + 48 * v17;
        v19 = *(_DWORD *)v18;
        if (v34 == *(_DWORD *)v18)
          goto LABEL_33;
        v20 = 0;
        v21 = 1;
        while (v19 != -1)
        {
          if (v20)
            v22 = 0;
          else
            v22 = v19 == -2;
          if (v22)
            v20 = v18;
          v23 = v17 + v21++;
          v17 = v23 & (v40 - 1);
          v18 = (char *)v38 + 48 * v17;
          v19 = *(_DWORD *)v18;
          if (v34 == *(_DWORD *)v18)
            goto LABEL_33;
        }
        if (v20)
          v24 = v20;
        else
          v24 = v18;
      }
      else
      {
        v24 = 0;
      }
      llvm::DenseMapBase<llvm::DenseMap<unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage>>,unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage>>::InsertIntoBucket<unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage>((uint64_t)&v38, v24, &v34, (uint64_t)&__dst);
LABEL_33:
      if (__dst != v43)
        free(__dst);
      v26 = 0;
      v25 = __src;
      if (__src == v46)
        goto LABEL_37;
      goto LABEL_36;
    }
LABEL_62:
    *(_QWORD *)this = v38;
    *((_QWORD *)this + 1) = v39;
    v38 = 0;
    v39 = 0;
    *((_DWORD *)this + 4) = v40;
    v40 = 0;
    *((_BYTE *)this + 24) = 1;
    v28 = v38;
  }
  else
  {
LABEL_54:
    *(_BYTE *)this = 0;
    *((_BYTE *)this + 24) = 0;
LABEL_55:
    v28 = v38;
    if (v40)
    {
      v29 = 48 * v40;
      v30 = (char *)v38 + 24;
      do
      {
        if (*((_DWORD *)v30 - 6) <= 0xFFFFFFFD)
        {
          v31 = (char *)*((_QWORD *)v30 - 2);
          if (v30 != v31)
            free(v31);
        }
        v30 += 48;
        v29 -= 48;
      }
      while (v29);
      v28 = v38;
      v32 = 48 * v40;
LABEL_64:
      llvm::deallocate_buffer(v28, (void *)v32);
    }
  }
  v32 = 0;
  goto LABEL_64;
}

void llvm::SmallVectorImpl<std::unique_ptr<mlir::Region>>::reserve(uint64_t a1, unint64_t a2)
{
  char *v3;
  char *v4;
  char *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  BOOL v11;
  unint64_t v12;
  uint64_t v13;
  __int128 *v14;
  _OWORD *v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  mlir::Region *v22;
  int v23;
  unint64_t v24;

  if (*(unsigned int *)(a1 + 12) >= a2)
    return;
  v24 = 0;
  v3 = (char *)(a1 + 16);
  v4 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 8, &v24);
  v5 = *(char **)a1;
  v6 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v6)
  {
    v7 = (v6 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    v8 = 8 * v6;
    if (v7 >= 0xB)
    {
      v11 = v5 >= &v4[v8] || v4 >= &v5[v8];
      v9 = v4;
      v10 = *(char **)a1;
      if (v11)
      {
        v12 = v7 + 1;
        v13 = 8 * (v12 & 0x3FFFFFFFFFFFFFFCLL);
        v9 = &v4[v13];
        v10 = &v5[v13];
        v14 = (__int128 *)(v5 + 16);
        v15 = v4 + 16;
        v16 = v12 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v17 = *(v14 - 1);
          v18 = *v14;
          *(v14 - 1) = 0uLL;
          *v14 = 0uLL;
          *(v15 - 1) = v17;
          *v15 = v18;
          v14 += 2;
          v15 += 2;
          v16 -= 4;
        }
        while (v16);
        if (v12 == (v12 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_15:
          v21 = *(_QWORD *)a1 - 8;
          do
          {
            v22 = *(mlir::Region **)(v21 + v8);
            *(_QWORD *)(v21 + v8) = 0;
            if (v22)
            {
              mlir::Region::~Region(v22);
              MEMORY[0x20BD002F8]();
            }
            v8 -= 8;
          }
          while (v8);
          v5 = *(char **)a1;
          goto LABEL_20;
        }
      }
    }
    else
    {
      v9 = v4;
      v10 = *(char **)a1;
    }
    v19 = &v5[8 * v6];
    do
    {
      v20 = *(_QWORD *)v10;
      *(_QWORD *)v10 = 0;
      v10 += 8;
      *(_QWORD *)v9 = v20;
      v9 += 8;
    }
    while (v10 != v19);
    goto LABEL_15;
  }
LABEL_20:
  v23 = v24;
  if (v5 != v3)
    free(v5);
  *(_QWORD *)a1 = v4;
  *(_DWORD *)(a1 + 12) = v23;
}

uint64_t mlir::BytecodeReader::Impl::defineValues(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  int v7;
  unint64_t v8;
  _QWORD **v9;
  int v10;
  _BYTE *v11;
  void *v12;
  int v13;
  uint64_t v14;
  mlir::Block *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD **v21;
  uint64_t *v22;
  uint64_t DefiningOp;
  uint64_t **v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  _QWORD *v41;
  _QWORD *v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  char *v47;
  unsigned int v48;
  _QWORD **v49;
  uint64_t v50;
  int v51;
  void *__dst;
  uint64_t v53;
  _BYTE v54[49];
  void *v55[2];
  uint64_t v56;
  void *v57[2];
  uint64_t v58;
  char v59;
  _QWORD v60[2];
  _QWORD **v61;
  uint64_t v62;
  int v63;
  void *__src;
  uint64_t v65;
  _BYTE v66[96];
  __int128 v67;
  uint64_t v68;
  __int128 __p;
  uint64_t v70;
  unsigned __int8 v71;
  uint64_t v72;

  v72 = *MEMORY[0x24BDAC8D0];
  v60[0] = a3;
  v60[1] = a4;
  v4 = a1[86];
  v5 = *(_QWORD *)(v4 - 32) + 4 * *(unsigned int *)(v4 - 24);
  v7 = *(_DWORD *)(v5 - 4);
  v6 = (unsigned int *)(v5 - 4);
  v48 = v7 + a4;
  v8 = (uint64_t)(*(_QWORD *)(v4 - 48) - *(_QWORD *)(v4 - 56)) >> 3;
  if (v8 < (v7 + a4))
  {
    v47 = (char *)(v8 - 1);
    mlir::emitError(a2, (uint64_t)&v61);
    v9 = v61;
    if (v61)
    {
      mlir::Diagnostic::append<char const(&)[81],unsigned int &,char const(&)[3],unsigned int &,char const(&)[30],unsigned long>((uint64_t)&v62, "value index range was outside of the expected range for the parent region, got [", v6, ", ", &v48, "), but the maximum index was ", &v47);
      v9 = v61;
    }
    v49 = v9;
    LOBYTE(v50) = 0;
    v59 = 0;
    if (!v71)
      goto LABEL_34;
    v50 = v62;
    v10 = v65;
    v51 = v63;
    v11 = v54;
    __dst = v54;
    v53 = *(_QWORD *)"";
    if (!(_DWORD)v65)
    {
      v13 = 1;
      goto LABEL_30;
    }
    v12 = __src;
    if (__src != v66)
    {
      __dst = __src;
      v53 = v65;
      __src = v66;
      HIDWORD(v65) = 0;
      v13 = 1;
LABEL_29:
      LODWORD(v65) = 0;
LABEL_30:
      *(_OWORD *)v55 = v67;
      v56 = v68;
      v67 = 0uLL;
      *(_OWORD *)v57 = __p;
      v58 = v70;
      v68 = 0;
      __p = 0uLL;
      v70 = 0;
      v59 = 1;
      if (v13)
      {
        if (__src != v66)
          free(__src);
        v71 = 0;
      }
LABEL_34:
      mlir::InFlightDiagnostic::abandon(&v61);
      if (v61)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v61);
      if (v71)
      {
        v30 = (_QWORD *)__p;
        if ((_QWORD)__p)
        {
          v31 = (_QWORD *)*((_QWORD *)&__p + 1);
          v32 = (void *)__p;
          if (*((_QWORD *)&__p + 1) != (_QWORD)__p)
          {
            do
              v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
            while (v31 != v30);
            v32 = (void *)__p;
          }
          *((_QWORD *)&__p + 1) = v30;
          operator delete(v32);
        }
        v33 = (_QWORD *)v67;
        if ((_QWORD)v67)
        {
          v34 = (_QWORD *)*((_QWORD *)&v67 + 1);
          v35 = (void *)v67;
          if (*((_QWORD *)&v67 + 1) != (_QWORD)v67)
          {
            do
            {
              v37 = *--v34;
              v36 = v37;
              *v34 = 0;
              if (v37)
                MEMORY[0x20BD002D4](v36, 0x1000C8077774924);
            }
            while (v34 != v33);
            v35 = (void *)v67;
          }
          *((_QWORD *)&v67 + 1) = v33;
          operator delete(v35);
        }
        if (__src != v66)
          free(__src);
      }
      v28 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v49);
      if (v49)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v49);
      if (v59)
      {
        v38 = v57[0];
        if (v57[0])
        {
          v39 = v57[1];
          v40 = v57[0];
          if (v57[1] != v57[0])
          {
            do
              v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
            while (v39 != v38);
            v40 = v57[0];
          }
          v57[1] = v38;
          operator delete(v40);
        }
        v41 = v55[0];
        if (v55[0])
        {
          v42 = v55[1];
          v43 = v55[0];
          if (v55[1] != v55[0])
          {
            do
            {
              v45 = *--v42;
              v44 = v45;
              *v42 = 0;
              if (v45)
                MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
            }
            while (v42 != v41);
            v43 = v55[0];
          }
          v55[1] = v41;
          operator delete(v43);
        }
        if (__dst != v54)
          free(__dst);
      }
      return v28;
    }
    if (v65 < 5)
    {
      v29 = v65;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v54, v65, 24);
      v29 = v65;
      if (!(_DWORD)v65)
      {
LABEL_28:
        LODWORD(v53) = v10;
        v13 = v71;
        goto LABEL_29;
      }
      v12 = __src;
      v11 = __dst;
    }
    memcpy(v11, v12, 24 * v29);
    goto LABEL_28;
  }
  if ((_DWORD)a4)
  {
    v14 = 0;
    v15 = (mlir::Block *)(a1 + 100);
    v16 = a1 + 104;
    v17 = a4;
    do
    {
      v19 = mlir::ValueRange::dereference_iterator(v60, v14);
      v18 = *v6;
      v20 = *(_QWORD *)(v4 - 56);
      v21 = *(_QWORD ***)(v20 + 8 * v18);
      *(_QWORD *)(v20 + 8 * v18) = v19;
      v61 = v21;
      if (v21)
      {
        v22 = (uint64_t *)v19;
        DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v61);
        v24 = v61;
        while (1)
        {
          v25 = *v24;
          if (!*v24)
            break;
          v26 = (uint64_t *)v25[1];
          if (v26)
          {
            *v26 = *v25;
            if (*v25)
              *(_QWORD *)(*v25 + 8) = v25[1];
          }
          v25[3] = (uint64_t)v22;
          v25[1] = (uint64_t)v22;
          v27 = *v22;
          *v25 = *v22;
          if (v27)
            *(_QWORD *)(v27 + 8) = v25;
          *v22 = (uint64_t)v25;
        }
        mlir::Operation::moveBefore(DefiningOp, v15, v16);
        LODWORD(v18) = *v6;
      }
      ++v14;
      *v6 = v18 + 1;
    }
    while (v14 != v17);
  }
  return 1;
}

void `anonymous namespace'::EncodingReader::emitError<char const(&)[29],llvm::StringRef,char const(&)[12],mlir::Attribute &>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v7;
  unint64_t v8;
  int v9;
  int v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  void *__src;
  unsigned int v32;
  int v33;
  _BYTE v34[96];
  void *v35[2];
  uint64_t v36;
  void *__p[2];
  uint64_t v38;
  unsigned __int8 v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  mlir::emitError(a2, (uint64_t)&v28);
  v7 = v28;
  if (v28)
  {
    mlir::Diagnostic::append<char const(&)[29],llvm::StringRef,char const(&)[12],mlir::Attribute &>((uint64_t)&v29, "expected attribute of type: ", a3, ", but got: ", a4);
    v7 = v28;
  }
  *(_QWORD *)a1 = v7;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  if (v39)
  {
    *(_QWORD *)(a1 + 8) = v29;
    v8 = v32;
    *(_DWORD *)(a1 + 16) = v30;
    *(_QWORD *)(a1 + 24) = a1 + 40;
    *(_QWORD *)(a1 + 32) = *(_QWORD *)"";
    if (!(_DWORD)v8 || &v28 == (uint64_t *)a1)
    {
      v10 = 1;
      goto LABEL_16;
    }
    if (__src != v34)
    {
      *(_QWORD *)(a1 + 24) = __src;
      v9 = v33;
      *(_DWORD *)(a1 + 32) = v8;
      *(_DWORD *)(a1 + 36) = v9;
      __src = v34;
      v33 = 0;
      v10 = 1;
LABEL_15:
      v32 = 0;
LABEL_16:
      *(_OWORD *)(a1 + 136) = *(_OWORD *)v35;
      *(_QWORD *)(a1 + 152) = v36;
      v35[0] = 0;
      v35[1] = 0;
      *(_OWORD *)(a1 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a1 + 176) = v38;
      v36 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v38 = 0;
      *(_BYTE *)(a1 + 184) = 1;
      if (v10)
      {
        v12 = __p[0];
        if (__p[0])
        {
          v13 = __p[1];
          v14 = __p[0];
          if (__p[1] != __p[0])
          {
            do
              v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
            while (v13 != v12);
            v14 = __p[0];
          }
          __p[1] = v12;
          operator delete(v14);
        }
        v15 = v35[0];
        if (v35[0])
        {
          v16 = v35[1];
          v17 = v35[0];
          if (v35[1] != v35[0])
          {
            do
            {
              v19 = *--v16;
              v18 = v19;
              *v16 = 0;
              if (v19)
                MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
            }
            while (v16 != v15);
            v17 = v35[0];
          }
          v35[1] = v15;
          operator delete(v17);
        }
        if (__src != v34)
          free(__src);
        v39 = 0;
      }
      goto LABEL_33;
    }
    if (v8 < 5)
    {
      v11 = v8;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v8, 24);
      v11 = v32;
      if (!v32)
        goto LABEL_14;
    }
    memcpy(*(void **)(a1 + 24), __src, 24 * v11);
LABEL_14:
    *(_DWORD *)(a1 + 32) = v8;
    v10 = v39;
    goto LABEL_15;
  }
LABEL_33:
  mlir::InFlightDiagnostic::abandon(&v28);
  if (v28)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v28);
  if (v39)
  {
    v20 = __p[0];
    if (__p[0])
    {
      v21 = __p[1];
      v22 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
        while (v21 != v20);
        v22 = __p[0];
      }
      __p[1] = v20;
      operator delete(v22);
    }
    v23 = v35[0];
    if (v35[0])
    {
      v24 = v35[1];
      v25 = v35[0];
      if (v35[1] != v35[0])
      {
        do
        {
          v27 = *--v24;
          v26 = v27;
          *v24 = 0;
          if (v27)
            MEMORY[0x20BD002D4](v26, 0x1000C8077774924);
        }
        while (v24 != v23);
        v25 = v35[0];
      }
      v35[1] = v23;
      operator delete(v25);
    }
    if (__src != v34)
      free(__src);
  }
}

uint64_t mlir::Diagnostic::append<char const(&)[29],llvm::StringRef,char const(&)[12],mlir::Attribute &>(uint64_t a1, char *__s, uint64_t a3, char *a4, uint64_t *a5)
{
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const void ***v14;
  uint64_t v15;
  __int128 v16;
  char *v17;
  unint64_t v19;
  BOOL v20;
  char *v21;
  const void **v22;
  char *v23;
  size_t v24;
  __int16 v25;

  v10 = strlen(__s);
  v11 = a1 + 16;
  v12 = *(_QWORD *)(a1 + 16);
  LODWORD(v22) = 3;
  v23 = __s;
  v24 = v10;
  v13 = *(unsigned int *)(a1 + 24);
  v14 = &v22;
  if (v13 >= *(_DWORD *)(a1 + 28))
  {
    v19 = v13 + 1;
    v20 = v12 + 24 * v13 > (unint64_t)&v22;
    if (v12 <= (unint64_t)&v22 && v20)
    {
      v21 = (char *)&v22 - v12;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v11, (void *)(a1 + 32), v19, 24);
      v12 = *(_QWORD *)(a1 + 16);
      v14 = (const void ***)&v21[v12];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v11, (void *)(a1 + 32), v19, 24);
      v12 = *(_QWORD *)(a1 + 16);
      v14 = &v22;
    }
  }
  v15 = v12 + 24 * *(unsigned int *)(a1 + 24);
  v16 = *(_OWORD *)v14;
  *(_QWORD *)(v15 + 16) = v14[2];
  *(_OWORD *)v15 = v16;
  ++*(_DWORD *)(a1 + 24);
  v25 = 261;
  v17 = *(char **)(a3 + 8);
  v22 = *(const void ***)a3;
  v23 = v17;
  mlir::Diagnostic::operator<<(a1, &v22);
  return mlir::Diagnostic::append<char const(&)[12],mlir::Attribute &>(a1, a4, a5);
}

uint64_t mlir::Diagnostic::append<char const(&)[12],mlir::Attribute &>(uint64_t a1, char *__s, uint64_t *a3)
{
  size_t v6;
  unint64_t v7;
  uint64_t v8;
  int *v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  __int128 v17;
  unint64_t v19;
  BOOL v20;
  unint64_t v21;
  BOOL v22;
  char *v23;
  char *v24;
  int v25;
  char *v26;
  size_t v27;

  v6 = strlen(__s);
  v7 = *(_QWORD *)(a1 + 16);
  v25 = 3;
  v26 = __s;
  v27 = v6;
  v8 = *(unsigned int *)(a1 + 24);
  v9 = &v25;
  if (v8 >= *(_DWORD *)(a1 + 28))
  {
    v19 = v8 + 1;
    v20 = v7 + 24 * v8 > (unint64_t)&v25;
    if (v7 <= (unint64_t)&v25 && v20)
    {
      v23 = (char *)&v25 - v7;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v19, 24);
      v7 = *(_QWORD *)(a1 + 16);
      v9 = (int *)&v23[v7];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v19, 24);
      v7 = *(_QWORD *)(a1 + 16);
      v9 = &v25;
    }
  }
  v10 = v7 + 24 * *(unsigned int *)(a1 + 24);
  v11 = *(_OWORD *)v9;
  *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
  *(_OWORD *)v10 = v11;
  ++*(_DWORD *)(a1 + 24);
  v12 = *a3;
  v13 = &v25;
  mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v25, v12);
  v14 = *(unsigned int *)(a1 + 24);
  v15 = *(_QWORD *)(a1 + 16);
  if (v14 >= *(_DWORD *)(a1 + 28))
  {
    v21 = v14 + 1;
    v22 = v15 + 24 * v14 > (unint64_t)&v25;
    if (v15 <= (unint64_t)&v25 && v22)
    {
      v24 = (char *)&v25 - v15;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v21, 24);
      v15 = *(_QWORD *)(a1 + 16);
      v13 = (int *)&v24[v15];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v21, 24);
      v15 = *(_QWORD *)(a1 + 16);
      v13 = &v25;
    }
  }
  v16 = v15 + 24 * *(unsigned int *)(a1 + 24);
  v17 = *(_OWORD *)v13;
  *(_QWORD *)(v16 + 16) = *((_QWORD *)v13 + 2);
  *(_OWORD *)v16 = v17;
  ++*(_DWORD *)(a1 + 24);
  return a1;
}

uint64_t mlir::detail::InterfaceMap::lookup<mlir::BytecodeOpInterface>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  _QWORD *v9;
  unint64_t v10;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  unint64_t v23;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v21 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v13 = v12;
    a1 = v21;
    if (v13)
    {
      v22 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v23 = 75;
      v14 = llvm::StringRef::find((uint64_t *)&v22, "DesiredTypeName = ", 0x12uLL, 0);
      if (v23 >= v14)
        v15 = v14;
      else
        v15 = v23;
      v16 = &v22[v15];
      v17 = v23 - v15;
      if (v23 - v15 >= 0x12)
        v18 = 18;
      else
        v18 = v23 - v15;
      v19 = v17 - v18;
      if (v19 >= v19 - 1)
        v20 = v19 - 1;
      else
        v20 = v19;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v21;
    }
  }
  v3 = *(unsigned int *)(a1 + 8);
  if (!(_DWORD)v3)
    return 0;
  v4 = v2[302];
  v5 = *(_QWORD **)a1;
  v6 = *(_QWORD *)a1 + 16 * v3;
  do
  {
    v7 = v3 >> 1;
    v8 = &v5[2 * (v3 >> 1)];
    v10 = *v8;
    v9 = v8 + 2;
    v3 += ~(v3 >> 1);
    if (v10 < v4)
      v5 = v9;
    else
      v3 = v7;
  }
  while (v3);
  if (v5 != (_QWORD *)v6 && *v5 == v4)
    return v5[1];
  else
    return 0;
}

char *llvm::DenseMapBase<llvm::DenseMap<unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage>>,unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage>>::InsertIntoBucket<unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage>(uint64_t a1, char *a2, _DWORD *a3, uint64_t a4)
{
  int v7;
  uint64_t v8;
  int v11;
  int *v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  unsigned int v16;
  _DWORD *buffer;
  unsigned int v18;
  unint64_t v19;
  _DWORD *v20;
  unint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  char *v27;
  int v28;
  BOOL v29;
  unsigned int v30;

  v7 = *(_DWORD *)(a1 + 8);
  v8 = *(unsigned int *)(a1 + 16);
  if (4 * v7 + 4 >= (3 * v8))
  {
    v11 = 2 * v8;
  }
  else
  {
    if ((int)v8 + ~v7 - *(_DWORD *)(a1 + 12) > v8 >> 3)
      goto LABEL_3;
    v11 = *(_DWORD *)(a1 + 16);
  }
  v12 = *(int **)a1;
  v13 = (v11 - 1) | ((unint64_t)(v11 - 1) >> 1);
  v14 = v13 | (v13 >> 2) | ((v13 | (v13 >> 2)) >> 4);
  v15 = ((v14 | (v14 >> 8)) >> 16) | v14 | (v14 >> 8);
  if ((v15 + 1) > 0x40)
    v16 = v15 + 1;
  else
    v16 = 64;
  *(_DWORD *)(a1 + 16) = v16;
  buffer = llvm::allocate_buffer(48 * v16, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = buffer;
  if (v12)
  {
    llvm::DenseMapBase<llvm::DenseMap<unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage>>,unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage>>::moveFromOldBuckets(a1, v12, &v12[12 * v8]);
    llvm::deallocate_buffer((llvm *)v12, (void *)(48 * v8));
  }
  *(_QWORD *)(a1 + 8) = 0;
  v18 = *(_DWORD *)(a1 + 16);
  if (v18)
  {
    v19 = 48 * v18 - 48;
    v20 = buffer;
    if (v19 < 0x30)
      goto LABEL_37;
    v21 = v19 / 0x30 + 1;
    v20 = &buffer[12 * (v21 & 0xFFFFFFFFFFFFFFELL)];
    v22 = v21 & 0xFFFFFFFFFFFFFFELL;
    v23 = buffer;
    do
    {
      *v23 = -1;
      v23[12] = -1;
      v23 += 24;
      v22 -= 2;
    }
    while (v22);
    if (v21 != (v21 & 0xFFFFFFFFFFFFFFELL))
    {
LABEL_37:
      do
      {
        *v20 = -1;
        v20 += 12;
      }
      while (v20 != &buffer[12 * v18]);
    }
    v24 = v18 - 1;
    v25 = (37 * *a3) & v24;
    a2 = (char *)&buffer[12 * v25];
    v26 = *(_DWORD *)a2;
    if (*a3 != *(_DWORD *)a2)
    {
      v27 = 0;
      v28 = 1;
      while (v26 != -1)
      {
        if (v27)
          v29 = 0;
        else
          v29 = v26 == -2;
        if (v29)
          v27 = a2;
        v30 = v25 + v28++;
        v25 = v30 & v24;
        a2 = (char *)&buffer[12 * v25];
        v26 = *(_DWORD *)a2;
        if (*a3 == *(_DWORD *)a2)
          goto LABEL_3;
      }
      if (v27)
        a2 = v27;
    }
  }
  else
  {
    a2 = 0;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*(_DWORD *)a2 != -1)
    --*(_DWORD *)(a1 + 12);
  *(_DWORD *)a2 = *a3;
  *((_QWORD *)a2 + 1) = a2 + 24;
  *((_QWORD *)a2 + 2) = *(_QWORD *)"";
  if (*(_DWORD *)(a4 + 8))
    llvm::SmallVectorImpl<unsigned int>::operator=((uint64_t)(a2 + 8), a4);
  a2[40] = *(_BYTE *)(a4 + 32);
  return a2;
}

void llvm::DenseMapBase<llvm::DenseMap<unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage>>,unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseMapPair<unsigned int,mlir::BytecodeReader::Impl::UseListOrderStorage>>::moveFromOldBuckets(uint64_t a1, int *a2, int *a3)
{
  int *v4;
  unsigned int v6;
  _DWORD *v7;
  unint64_t v8;
  _DWORD *v9;
  unint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  _DWORD *v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  BOOL v22;
  unsigned int v23;
  int *v24;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    v7 = *(_DWORD **)a1;
    v8 = 48 * v6 - 48;
    if (v8 < 0x30)
    {
      v9 = *(_DWORD **)a1;
LABEL_7:
      v13 = &v7[12 * v6];
      do
      {
        *v9 = -1;
        v9 += 12;
      }
      while (v9 != v13);
      goto LABEL_9;
    }
    v10 = v8 / 0x30 + 1;
    v9 = &v7[12 * (v10 & 0xFFFFFFFFFFFFFFELL)];
    v11 = v10 & 0xFFFFFFFFFFFFFFELL;
    v12 = *(_DWORD **)a1;
    do
    {
      *v12 = -1;
      v12[12] = -1;
      v12 += 24;
      v11 -= 2;
    }
    while (v11);
    if (v10 != (v10 & 0xFFFFFFFFFFFFFFELL))
      goto LABEL_7;
  }
LABEL_9:
  if (a2 != a3)
  {
    do
    {
      v14 = *v4;
      if (*v4 <= 0xFFFFFFFD)
      {
        v15 = *(_DWORD *)(a1 + 16);
        if (v15)
        {
          v16 = v15 - 1;
          v17 = v16 & (37 * v14);
          v18 = *(_QWORD *)a1 + 48 * v17;
          v19 = *(_DWORD *)v18;
          if (v14 != *(_DWORD *)v18)
          {
            v20 = 0;
            v21 = 1;
            while (v19 != -1)
            {
              if (v20)
                v22 = 0;
              else
                v22 = v19 == -2;
              if (v22)
                v20 = v18;
              v23 = v17 + v21++;
              v17 = v23 & v16;
              v18 = *(_QWORD *)a1 + 48 * v17;
              v19 = *(_DWORD *)v18;
              if (v14 == *(_DWORD *)v18)
                goto LABEL_25;
            }
            if (v20)
              v18 = v20;
          }
        }
        else
        {
          v18 = 0;
        }
LABEL_25:
        *(_DWORD *)v18 = v14;
        *(_QWORD *)(v18 + 8) = v18 + 24;
        *(_QWORD *)(v18 + 16) = *(_QWORD *)"";
        if (v4[4])
          llvm::SmallVectorImpl<unsigned int>::operator=(v18 + 8, (uint64_t)(v4 + 2));
        *(_BYTE *)(v18 + 40) = *((_BYTE *)v4 + 40);
        ++*(_DWORD *)(a1 + 8);
        v24 = (int *)*((_QWORD *)v4 + 1);
        if (v24 != v4 + 6)
          free(v24);
      }
      v4 += 12;
    }
    while (v4 != a3);
  }
}

char *llvm::SmallVectorTemplateBase<std::unique_ptr<mlir::Region>,false>::reserveForParamAndGetAddress(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v8;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  unint64_t v18;
  uint64_t v19;
  __int128 *v20;
  _OWORD *v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  mlir::Region *v28;
  int v29;
  uint64_t v30;
  char *v31;
  char *v32;
  char *v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  unint64_t v39;
  uint64_t v40;
  __int128 *v41;
  _OWORD *v42;
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  mlir::Region *v49;
  uint64_t v50;
  int v51;
  unint64_t v52;

  v3 = a2;
  v4 = *(unsigned int *)(a1 + 8);
  v5 = v4 + a3;
  if (v5 <= *(unsigned int *)(a1 + 12))
    return (char *)v3;
  v8 = *(_QWORD *)a1 + 8 * v4;
  if (*(_QWORD *)a1 > a2 || v8 <= a2)
  {
    v52 = 0;
    v10 = (char *)(a1 + 16);
    v11 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), v5, 8, &v52);
    v12 = *(char **)a1;
    v13 = *(unsigned int *)(a1 + 8);
    if (!(_DWORD)v13)
    {
LABEL_22:
      v29 = v52;
      if (v12 != v10)
        free(v12);
      *(_QWORD *)a1 = v11;
      *(_DWORD *)(a1 + 12) = v29;
      return (char *)v3;
    }
    v14 = (v13 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    v15 = 8 * v13;
    if (v14 >= 0xB)
    {
      if (v12 >= &v11[v15] || (v16 = v11, v17 = *(char **)a1, v11 >= &v12[v15]))
      {
        v18 = v14 + 1;
        v19 = 8 * (v18 & 0x3FFFFFFFFFFFFFFCLL);
        v16 = &v11[v19];
        v17 = &v12[v19];
        v20 = (__int128 *)(v12 + 16);
        v21 = v11 + 16;
        v22 = v18 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v23 = *(v20 - 1);
          v24 = *v20;
          *(v20 - 1) = 0uLL;
          *v20 = 0uLL;
          *(v21 - 1) = v23;
          *v21 = v24;
          v20 += 2;
          v21 += 2;
          v22 -= 4;
        }
        while (v22);
        if (v18 == (v18 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_17:
          v27 = *(_QWORD *)a1 - 8;
          do
          {
            v28 = *(mlir::Region **)(v27 + v15);
            *(_QWORD *)(v27 + v15) = 0;
            if (v28)
            {
              mlir::Region::~Region(v28);
              MEMORY[0x20BD002F8]();
            }
            v15 -= 8;
          }
          while (v15);
          v12 = *(char **)a1;
          goto LABEL_22;
        }
      }
    }
    else
    {
      v16 = v11;
      v17 = *(char **)a1;
    }
    v25 = &v12[8 * v13];
    do
    {
      v26 = *(_QWORD *)v17;
      *(_QWORD *)v17 = 0;
      v17 += 8;
      *(_QWORD *)v16 = v26;
      v16 += 8;
    }
    while (v17 != v25);
    goto LABEL_17;
  }
  v30 = a2 - *(_QWORD *)a1;
  v52 = 0;
  v31 = (char *)(a1 + 16);
  v32 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), v5, 8, &v52);
  v33 = *(char **)a1;
  v34 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v34)
  {
    v35 = (v34 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    v36 = 8 * v34;
    if (v35 >= 0xB)
    {
      if (v33 >= &v32[v36] || (v37 = v32, v38 = *(char **)a1, v32 >= &v33[v36]))
      {
        v39 = v35 + 1;
        v40 = 8 * (v39 & 0x3FFFFFFFFFFFFFFCLL);
        v37 = &v32[v40];
        v38 = &v33[v40];
        v41 = (__int128 *)(v33 + 16);
        v42 = v32 + 16;
        v43 = v39 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v44 = *(v41 - 1);
          v45 = *v41;
          *(v41 - 1) = 0uLL;
          *v41 = 0uLL;
          *(v42 - 1) = v44;
          *v42 = v45;
          v41 += 2;
          v42 += 2;
          v43 -= 4;
        }
        while (v43);
        if (v39 == (v39 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_35:
          v48 = *(_QWORD *)a1 - 8;
          do
          {
            v49 = *(mlir::Region **)(v48 + v36);
            *(_QWORD *)(v48 + v36) = 0;
            if (v49)
            {
              mlir::Region::~Region(v49);
              MEMORY[0x20BD002F8]();
            }
            v36 -= 8;
          }
          while (v36);
          v33 = *(char **)a1;
          goto LABEL_40;
        }
      }
    }
    else
    {
      v37 = v32;
      v38 = *(char **)a1;
    }
    v46 = &v33[8 * v34];
    do
    {
      v47 = *(_QWORD *)v38;
      *(_QWORD *)v38 = 0;
      v38 += 8;
      *(_QWORD *)v37 = v47;
      v37 += 8;
    }
    while (v38 != v46);
    goto LABEL_35;
  }
LABEL_40:
  v50 = v30 >> 3;
  v51 = v52;
  if (v33 != v31)
    free(v33);
  *(_QWORD *)a1 = v32;
  *(_DWORD *)(a1 + 12) = v51;
  return &v32[8 * v50];
}

uint64_t mlir::Diagnostic::append<char const(&)[81],unsigned int &,char const(&)[3],unsigned int &,char const(&)[30],unsigned long>(uint64_t a1, char *__s, unsigned int *a3, char *a4, unsigned int *a5, char *a6, char **a7)
{
  size_t v14;
  unint64_t v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  __int128 v19;
  unsigned int v20;
  uint64_t v21;
  char *v22;
  unint64_t v23;
  int *v24;
  uint64_t v25;
  __int128 v26;
  unint64_t v28;
  BOOL v29;
  unint64_t v30;
  BOOL v31;
  char *v32;
  char *v33;
  int v34;
  char *v35;
  size_t v36;

  v14 = strlen(__s);
  v15 = *(_QWORD *)(a1 + 16);
  v34 = 3;
  v35 = __s;
  v36 = v14;
  v16 = *(unsigned int *)(a1 + 24);
  v17 = &v34;
  if (v16 >= *(_DWORD *)(a1 + 28))
  {
    v28 = v16 + 1;
    v29 = v15 + 24 * v16 > (unint64_t)&v34;
    if (v15 <= (unint64_t)&v34 && v29)
    {
      v32 = (char *)&v34 - v15;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v28, 24);
      v15 = *(_QWORD *)(a1 + 16);
      v17 = (int *)&v32[v15];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v28, 24);
      v15 = *(_QWORD *)(a1 + 16);
      v17 = &v34;
    }
  }
  v18 = v15 + 24 * *(unsigned int *)(a1 + 24);
  v19 = *(_OWORD *)v17;
  *(_QWORD *)(v18 + 16) = *((_QWORD *)v17 + 2);
  *(_OWORD *)v18 = v19;
  v20 = *(_DWORD *)(a1 + 28);
  v21 = (*(_DWORD *)(a1 + 24) + 1);
  *(_DWORD *)(a1 + 24) = v21;
  v22 = (char *)*a3;
  v34 = 5;
  v35 = v22;
  v23 = *(_QWORD *)(a1 + 16);
  v24 = &v34;
  if (v21 >= v20)
  {
    v30 = v21 + 1;
    v31 = v23 + 24 * v21 > (unint64_t)&v34;
    if (v23 <= (unint64_t)&v34 && v31)
    {
      v33 = (char *)&v34 - v23;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v30, 24);
      v23 = *(_QWORD *)(a1 + 16);
      v24 = (int *)&v33[v23];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v30, 24);
      v23 = *(_QWORD *)(a1 + 16);
      v24 = &v34;
    }
  }
  v25 = v23 + 24 * *(unsigned int *)(a1 + 24);
  v26 = *(_OWORD *)v24;
  *(_QWORD *)(v25 + 16) = *((_QWORD *)v24 + 2);
  *(_OWORD *)v25 = v26;
  ++*(_DWORD *)(a1 + 24);
  return mlir::Diagnostic::append<char const(&)[3],unsigned int &,char const(&)[30],unsigned long>(a1, a4, a5, a6, a7);
}

uint64_t mlir::Diagnostic::append<char const(&)[3],unsigned int &,char const(&)[30],unsigned long>(uint64_t a1, char *__s, unsigned int *a3, char *a4, char **a5)
{
  size_t v10;
  unint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  __int128 v15;
  unsigned int v16;
  uint64_t v17;
  char *v18;
  unint64_t v19;
  int *v20;
  uint64_t v21;
  __int128 v22;
  unint64_t v24;
  BOOL v25;
  unint64_t v26;
  BOOL v27;
  char *v28;
  char *v29;
  int v30;
  char *v31;
  size_t v32;

  v10 = strlen(__s);
  v11 = *(_QWORD *)(a1 + 16);
  v30 = 3;
  v31 = __s;
  v32 = v10;
  v12 = *(unsigned int *)(a1 + 24);
  v13 = &v30;
  if (v12 >= *(_DWORD *)(a1 + 28))
  {
    v24 = v12 + 1;
    v25 = v11 + 24 * v12 > (unint64_t)&v30;
    if (v11 <= (unint64_t)&v30 && v25)
    {
      v28 = (char *)&v30 - v11;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v24, 24);
      v11 = *(_QWORD *)(a1 + 16);
      v13 = (int *)&v28[v11];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v24, 24);
      v11 = *(_QWORD *)(a1 + 16);
      v13 = &v30;
    }
  }
  v14 = v11 + 24 * *(unsigned int *)(a1 + 24);
  v15 = *(_OWORD *)v13;
  *(_QWORD *)(v14 + 16) = *((_QWORD *)v13 + 2);
  *(_OWORD *)v14 = v15;
  v16 = *(_DWORD *)(a1 + 28);
  v17 = (*(_DWORD *)(a1 + 24) + 1);
  *(_DWORD *)(a1 + 24) = v17;
  v18 = (char *)*a3;
  v30 = 5;
  v31 = v18;
  v19 = *(_QWORD *)(a1 + 16);
  v20 = &v30;
  if (v17 >= v16)
  {
    v26 = v17 + 1;
    v27 = v19 + 24 * v17 > (unint64_t)&v30;
    if (v19 <= (unint64_t)&v30 && v27)
    {
      v29 = (char *)&v30 - v19;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v26, 24);
      v19 = *(_QWORD *)(a1 + 16);
      v20 = (int *)&v29[v19];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v26, 24);
      v19 = *(_QWORD *)(a1 + 16);
      v20 = &v30;
    }
  }
  v21 = v19 + 24 * *(unsigned int *)(a1 + 24);
  v22 = *(_OWORD *)v20;
  *(_QWORD *)(v21 + 16) = *((_QWORD *)v20 + 2);
  *(_OWORD *)v21 = v22;
  ++*(_DWORD *)(a1 + 24);
  return mlir::Diagnostic::append<char const(&)[36],unsigned long long &>(a1, a4, a5);
}

char *llvm::DenseMapBase<llvm::DenseMap<void *,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::BytecodeReader::Impl::UseListOrderStorage>>,void *,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::BytecodeReader::Impl::UseListOrderStorage>>::InsertIntoBucket<void *,mlir::BytecodeReader::Impl::UseListOrderStorage const&>(uint64_t a1, char *a2, uint64_t *a3, uint64_t a4)
{
  int v7;
  uint64_t v8;
  uint64_t v10;
  void *v11;
  unsigned int v12;
  unsigned int v14;
  int v16;
  uint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  unsigned int v21;
  _QWORD *buffer;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  int v30;
  unsigned int v31;
  uint64_t v32;
  char *v33;
  int v34;
  BOOL v35;
  unsigned int v36;

  v7 = *(_DWORD *)(a1 + 8);
  v8 = *(unsigned int *)(a1 + 16);
  if (4 * v7 + 4 >= (3 * v8))
  {
    v16 = 2 * v8;
  }
  else
  {
    if ((int)v8 + ~v7 - *(_DWORD *)(a1 + 12) > v8 >> 3)
    {
LABEL_3:
      v10 = *(_QWORD *)a2;
      goto LABEL_4;
    }
    v16 = *(_DWORD *)(a1 + 16);
  }
  v17 = *(uint64_t **)a1;
  v18 = (v16 - 1) | ((unint64_t)(v16 - 1) >> 1);
  v19 = v18 | (v18 >> 2) | ((v18 | (v18 >> 2)) >> 4);
  v20 = ((v19 | (v19 >> 8)) >> 16) | v19 | (v19 >> 8);
  if ((v20 + 1) > 0x40)
    v21 = v20 + 1;
  else
    v21 = 64;
  *(_DWORD *)(a1 + 16) = v21;
  buffer = llvm::allocate_buffer(48 * v21, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = buffer;
  if (v17)
  {
    v23 = 6 * v8;
    llvm::DenseMapBase<llvm::DenseMap<void *,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::BytecodeReader::Impl::UseListOrderStorage>>,void *,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::BytecodeReader::Impl::UseListOrderStorage>>::moveFromOldBuckets(a1, v17, &v17[v23]);
    llvm::deallocate_buffer((llvm *)v17, (void *)(v23 * 8));
  }
  *(_QWORD *)(a1 + 8) = 0;
  v24 = *(unsigned int *)(a1 + 16);
  v25 = 48 * v24 - 48;
  v26 = buffer;
  if (v25 < 0x30)
    goto LABEL_44;
  v27 = v25 / 0x30 + 1;
  v26 = &buffer[6 * (v27 & 0xFFFFFFFFFFFFFFELL)];
  v28 = v27 & 0xFFFFFFFFFFFFFFELL;
  v29 = buffer;
  do
  {
    *v29 = -4096;
    v29[6] = -4096;
    v29 += 12;
    v28 -= 2;
  }
  while (v28);
  if (v27 != (v27 & 0xFFFFFFFFFFFFFFELL))
  {
LABEL_44:
    do
    {
      *v26 = -4096;
      v26 += 6;
    }
    while (v26 != &buffer[6 * v24]);
  }
  v10 = *a3;
  v30 = v24 - 1;
  v31 = ((*a3 >> 4) ^ (*a3 >> 9)) & v30;
  a2 = (char *)&buffer[6 * v31];
  v32 = *(_QWORD *)a2;
  if (*a3 != *(_QWORD *)a2)
  {
    v33 = 0;
    v34 = 1;
    while (v32 != -4096)
    {
      if (v33)
        v35 = 0;
      else
        v35 = v32 == -8192;
      if (v35)
        v33 = a2;
      v36 = v31 + v34++;
      v31 = v36 & v30;
      a2 = (char *)&buffer[6 * v31];
      v32 = *(_QWORD *)a2;
      if (v10 == *(_QWORD *)a2)
        goto LABEL_4;
    }
    if (v33)
      a2 = v33;
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v10 != -4096)
    --*(_DWORD *)(a1 + 12);
  *(_QWORD *)a2 = *a3;
  v11 = a2 + 24;
  *((_QWORD *)a2 + 1) = a2 + 24;
  *((_QWORD *)a2 + 2) = *(_QWORD *)"";
  v12 = *(_DWORD *)(a4 + 8);
  if (a2 + 8 != (char *)a4 && v12 != 0)
  {
    if (v12 < 5)
    {
      v14 = *(_DWORD *)(a4 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(a2 + 8), a2 + 24, *(unsigned int *)(a4 + 8), 4);
      v14 = *(_DWORD *)(a4 + 8);
      if (!v14)
      {
LABEL_15:
        *((_DWORD *)a2 + 4) = v12;
        goto LABEL_16;
      }
      v11 = (void *)*((_QWORD *)a2 + 1);
    }
    memcpy(v11, *(const void **)a4, 4 * v14);
    goto LABEL_15;
  }
LABEL_16:
  a2[40] = *(_BYTE *)(a4 + 32);
  return a2;
}

void llvm::DenseMapBase<llvm::DenseMap<void *,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::BytecodeReader::Impl::UseListOrderStorage>>,void *,mlir::BytecodeReader::Impl::UseListOrderStorage,llvm::DenseMapInfo<void *,void>,llvm::detail::DenseMapPair<void *,mlir::BytecodeReader::Impl::UseListOrderStorage>>::moveFromOldBuckets(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v4;
  unsigned int v6;
  _QWORD *v7;
  unint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  BOOL v22;
  unsigned int v23;
  uint64_t *v24;

  v4 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    v7 = *(_QWORD **)a1;
    v8 = 48 * v6 - 48;
    if (v8 < 0x30)
    {
      v9 = *(_QWORD **)a1;
LABEL_7:
      v13 = &v7[6 * v6];
      do
      {
        *v9 = -4096;
        v9 += 6;
      }
      while (v9 != v13);
      goto LABEL_9;
    }
    v10 = v8 / 0x30 + 1;
    v9 = &v7[6 * (v10 & 0xFFFFFFFFFFFFFFELL)];
    v11 = v10 & 0xFFFFFFFFFFFFFFELL;
    v12 = *(_QWORD **)a1;
    do
    {
      *v12 = -4096;
      v12[6] = -4096;
      v12 += 12;
      v11 -= 2;
    }
    while (v11);
    if (v10 != (v10 & 0xFFFFFFFFFFFFFFELL))
      goto LABEL_7;
  }
LABEL_9:
  if (a2 != a3)
  {
    do
    {
      v14 = *v4;
      if ((*v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        v15 = *(_DWORD *)(a1 + 16);
        if (v15)
        {
          v16 = v15 - 1;
          v17 = v16 & ((v14 >> 4) ^ (v14 >> 9));
          v18 = *(_QWORD *)a1 + 48 * v17;
          v19 = *(_QWORD *)v18;
          if (v14 != *(_QWORD *)v18)
          {
            v20 = 0;
            v21 = 1;
            while (v19 != -4096)
            {
              if (v20)
                v22 = 0;
              else
                v22 = v19 == -8192;
              if (v22)
                v20 = v18;
              v23 = v17 + v21++;
              v17 = v23 & v16;
              v18 = *(_QWORD *)a1 + 48 * v17;
              v19 = *(_QWORD *)v18;
              if (v14 == *(_QWORD *)v18)
                goto LABEL_25;
            }
            if (v20)
              v18 = v20;
          }
        }
        else
        {
          v18 = 0;
        }
LABEL_25:
        *(_QWORD *)v18 = v14;
        *(_QWORD *)(v18 + 8) = v18 + 24;
        *(_QWORD *)(v18 + 16) = *(_QWORD *)"";
        if (*((_DWORD *)v4 + 4))
          llvm::SmallVectorImpl<unsigned int>::operator=(v18 + 8, (uint64_t)(v4 + 1));
        *(_BYTE *)(v18 + 40) = *((_BYTE *)v4 + 40);
        ++*(_DWORD *)(a1 + 8);
        v24 = (uint64_t *)v4[1];
        if (v24 != v4 + 3)
          free(v24);
      }
      v4 += 6;
    }
    while (v4 != a3);
  }
}

uint64_t mlir::BytecodeReader::Impl::Impl(uint64_t a1, mlir::MLIRContext *a2, mlir::UnknownLoc **a3, char a4, _OWORD *a5, uint64_t a6)
{
  _QWORD *v10;
  uint64_t v11;
  mlir::MLIRContext *v12;
  __int128 v13;
  uint64_t v15;
  uint64_t v16[2];
  unint64_t v17[2];
  unint64_t v18[3];

  v18[2] = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = a3;
  *(_QWORD *)(a1 + 8) = a2;
  *(_BYTE *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 24) = a1 + 24;
  *(_QWORD *)(a1 + 32) = a1 + 24;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 88) = a1 + 536;
  *(_QWORD *)(a1 + 96) = a1 + 424;
  *(_QWORD *)(a1 + 104) = a1 + 336;
  *(_QWORD *)(a1 + 112) = a1 + 128;
  *(_QWORD *)(a1 + 120) = 0x100000000;
  *(_QWORD *)(a1 + 168) = a1 + 184;
  *(_QWORD *)(a1 + 176) = 0x100000000;
  *(_QWORD *)(a1 + 224) = a2;
  *(_QWORD *)(a1 + 232) = a1 + 248;
  *(_QWORD *)(a1 + 240) = a3;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 272) = a1 + 288;
  *(_QWORD *)(a1 + 280) = 0x600000000;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_QWORD *)(a1 + 352) = 0x1000000000;
  *(_QWORD *)(a1 + 360) = a1 + 376;
  *(_QWORD *)(a1 + 368) = 0x100000000;
  *(_QWORD *)(a1 + 424) = a1 + 440;
  *(_QWORD *)(a1 + 432) = 0x200000000;
  *(_OWORD *)(a1 + 488) = 0u;
  *(_QWORD *)(a1 + 504) = 0x2000000000;
  *(_OWORD *)(a1 + 512) = 0u;
  *(_DWORD *)(a1 + 528) = 0;
  *(_QWORD *)(a1 + 536) = a1 + 552;
  *(_QWORD *)(a1 + 544) = 0x300000000;
  *(_OWORD *)(a1 + 600) = 0u;
  *(_QWORD *)(a1 + 616) = a1 + 632;
  *(_QWORD *)(a1 + 624) = 0x600000000;
  *(_OWORD *)(a1 + 728) = 0u;
  *(_OWORD *)(a1 + 744) = 0u;
  *(_OWORD *)(a1 + 708) = 0u;
  *(_OWORD *)(a1 + 680) = 0u;
  *(_OWORD *)(a1 + 696) = 0u;
  *(_QWORD *)(a1 + 760) = a1 + 760;
  *(_QWORD *)(a1 + 768) = a1 + 760;
  *(_QWORD *)(a1 + 824) = 0;
  *(_OWORD *)(a1 + 792) = 0u;
  *(_OWORD *)(a1 + 808) = 0u;
  *(_OWORD *)(a1 + 776) = 0u;
  *(_QWORD *)(a1 + 832) = a1 + 832;
  *(_QWORD *)(a1 + 840) = a1 + 832;
  *(_QWORD *)(a1 + 864) = 0;
  *(_OWORD *)(a1 + 848) = 0u;
  v10 = (_QWORD *)(a1 + 872);
  v11 = mlir::UnknownLoc::get(*a3, a2);
  mlir::ValueRange::ValueRange(v18, 0, 0);
  v15 = mlir::NoneType::get(*a3, v12);
  mlir::ValueRange::ValueRange(v17, (uint64_t)&v15, 1uLL);
  mlir::BlockRange::BlockRange(v16, 0, 0);
  mlir::OperationState::OperationState(v10, v11, (uint64_t)"builtin.unrealized_conversion_cast", 34, v18[0], v18[1], v17[0], v17[1], 0, 0, v16[0], v16[1], 0, 0);
  v13 = a5[1];
  *(_OWORD *)(a1 + 1176) = *a5;
  *(_OWORD *)(a1 + 1192) = v13;
  *(_QWORD *)(a1 + 1208) = a6;
  return a1;
}

void mlir::BytecodeReader::Impl::~Impl(llvm **this)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)(this + 109));
  mlir::Block::~Block((mlir::Block *)(this + 100));
  mlir::Block::~Block((mlir::Block *)(this + 91));
  llvm::deallocate_buffer(this[88], (void *)(16 * *((unsigned int *)this + 180)));
}

char *std::vector<mlir::BytecodeReader::Impl::ValueScope>::__emplace_back_slow_path<>(void **a1)
{
  char *v1;
  char *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  void *v18;

  v2 = (char *)*a1;
  v1 = (char *)a1[1];
  v3 = 0x6DB6DB6DB6DB6DB7 * ((v1 - (_BYTE *)*a1) >> 3);
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > 0x492492492492492)
    abort();
  if (0xDB6DB6DB6DB6DB6ELL * (((_BYTE *)a1[2] - v2) >> 3) > v4)
    v4 = 0xDB6DB6DB6DB6DB6ELL * (((_BYTE *)a1[2] - v2) >> 3);
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * (((_BYTE *)a1[2] - v2) >> 3)) >= 0x249249249249249)
    v4 = 0x492492492492492;
  if (v4 > 0x492492492492492)
    std::__throw_bad_array_new_length[abi:nn180100]();
  v6 = 56 * v4;
  v7 = (char *)operator new(56 * v4);
  v8 = &v7[56 * v3];
  *((_OWORD *)v8 + 1) = 0u;
  *((_OWORD *)v8 + 2) = 0u;
  v9 = &v7[v6];
  *(_OWORD *)v8 = 0u;
  *((_QWORD *)v8 + 6) = 0;
  *((_QWORD *)v8 + 3) = v8 + 40;
  *((_DWORD *)v8 + 9) = 4;
  v10 = v8 + 56;
  if (v1 == v2)
  {
    *a1 = v8;
    a1[1] = v10;
    a1[2] = v9;
  }
  else
  {
    v11 = 0;
    do
    {
      v12 = &v8[v11];
      v13 = &v1[v11];
      *(_OWORD *)(v12 - 56) = *(_OWORD *)&v1[v11 - 56];
      *((_QWORD *)v12 - 5) = *(_QWORD *)&v1[v11 - 40];
      *((_QWORD *)v13 - 7) = 0;
      *((_QWORD *)v13 - 6) = 0;
      *((_QWORD *)v13 - 5) = 0;
      *((_QWORD *)v12 - 4) = &v8[v11 - 16];
      *(_QWORD *)&v8[v11 - 24] = *(_QWORD *)"";
      if (*(_DWORD *)&v1[v11 - 24])
        llvm::SmallVectorImpl<unsigned int>::operator=((uint64_t)&v8[v11 - 32], (uint64_t)(v13 - 32));
      v11 -= 56;
    }
    while (&v1[v11] != v2);
    v1 = (char *)*a1;
    v14 = (char *)a1[1];
    *a1 = &v8[v11];
    a1[1] = v10;
    a1[2] = v9;
    if (v14 != v1)
    {
      v15 = v14 - 16;
      do
      {
        v17 = (char *)*((_QWORD *)v15 - 2);
        if (v15 != v17)
          free(v17);
        v18 = (void *)*((_QWORD *)v15 - 5);
        if (v18)
        {
          *((_QWORD *)v15 - 4) = v18;
          operator delete(v18);
        }
        v16 = v15 - 40;
        v15 -= 56;
      }
      while (v16 != v1);
    }
  }
  if (v1)
    operator delete(v1);
  return v8 + 56;
}

char *std::vector<mlir::BytecodeReader::Impl::RegionReadState>::__push_back_slow_path<mlir::BytecodeReader::Impl::RegionReadState>(void **a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v6;
  unint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;
  __int128 v17;
  char *v18;
  char *v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  uint64_t v25;

  v2 = ((_BYTE *)a1[1] - (_BYTE *)*a1) >> 7;
  v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 57)
    abort();
  v6 = (_BYTE *)a1[2] - (_BYTE *)*a1;
  if (v6 >> 6 > v3)
    v3 = v6 >> 6;
  if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFF80)
    v7 = 0x1FFFFFFFFFFFFFFLL;
  else
    v7 = v3;
  if (v7)
  {
    if (v7 >> 57)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v8 = (char *)operator new(v7 << 7);
  }
  else
  {
    v8 = 0;
  }
  v9 = &v8[128 * v2];
  *(_OWORD *)v9 = *(_OWORD *)a2;
  v10 = *(_QWORD *)(a2 + 16);
  v11 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = 0;
  *((_QWORD *)v9 + 2) = v10;
  *((_QWORD *)v9 + 3) = v11;
  *((_DWORD *)v9 + 8) = *(_DWORD *)(a2 + 32);
  *((_QWORD *)v9 + 5) = v9 + 56;
  *((_QWORD *)v9 + 6) = 0x600000000;
  if (*(_DWORD *)(a2 + 48))
    llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)(v9 + 40), a2 + 40);
  v12 = &v8[128 * v7];
  *(_OWORD *)(v9 + 104) = *(_OWORD *)(a2 + 104);
  v9[120] = *(_BYTE *)(a2 + 120);
  v13 = v9 + 128;
  v15 = (char *)*a1;
  v14 = (char *)a1[1];
  if (v14 == *a1)
  {
    *a1 = v9;
    a1[1] = v13;
    a1[2] = v12;
  }
  else
  {
    v16 = 0;
    do
    {
      v18 = &v9[v16];
      v19 = &v14[v16];
      v20 = *(_OWORD *)&v14[v16 - 128];
      *((_QWORD *)v18 - 14) = *(_QWORD *)&v14[v16 - 112];
      *((_OWORD *)v18 - 8) = v20;
      v21 = *(_QWORD *)&v14[v16 - 104];
      *(_QWORD *)&v14[v16 - 104] = 0;
      *(_QWORD *)&v9[v16 - 88] = &v9[v16 - 72];
      v22 = (uint64_t)&v9[v16 - 88];
      *(_QWORD *)(v22 - 16) = v21;
      *(_DWORD *)(v22 - 8) = *(_DWORD *)&v14[v16 - 96];
      *(_QWORD *)(v22 + 8) = 0x600000000;
      if (*(_DWORD *)&v14[v16 - 80])
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v22, (uint64_t)(v19 - 88));
      v17 = *(_OWORD *)(v19 - 24);
      *(v18 - 8) = *(v19 - 8);
      *(_OWORD *)(v18 - 24) = v17;
      v16 -= 128;
    }
    while (&v14[v16] != v15);
    v14 = (char *)*a1;
    v23 = (char *)a1[1];
    *a1 = &v9[v16];
    a1[1] = v13;
    a1[2] = v12;
    while (v23 != v14)
    {
      v24 = (char *)*((_QWORD *)v23 - 11);
      if (v23 - 72 != v24)
        free(v24);
      v25 = *((_QWORD *)v23 - 13);
      *((_QWORD *)v23 - 13) = 0;
      if (v25)
        MEMORY[0x20BD002F8](v25, 0x1070C401CF53446);
      v23 -= 128;
    }
  }
  if (v14)
    operator delete(v14);
  return v9 + 128;
}

uint64_t llvm::SmallVectorImpl<unsigned int>::operator=(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  void *v6;
  _DWORD *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a1 != a2)
  {
    v5 = (const void *)(a2 + 16);
    v4 = *(const void **)a2;
    if (v4 != v5)
    {
      v6 = *(void **)a1;
      if (*(_QWORD *)a1 != a1 + 16)
      {
        free(v6);
        v4 = *(const void **)a2;
      }
      *(_QWORD *)a1 = v4;
      v7 = (_DWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
      goto LABEL_16;
    }
    v7 = (_DWORD *)(a2 + 8);
    v8 = *(unsigned int *)(a2 + 8);
    v9 = *(unsigned int *)(a1 + 8);
    if (v9 >= v8)
    {
      if ((_DWORD)v8)
        memmove(*(void **)a1, v4, 4 * v8);
      goto LABEL_15;
    }
    if (*(_DWORD *)(a1 + 12) >= v8)
    {
      if ((_DWORD)v9)
      {
        memmove(*(void **)a1, v4, 4 * v9);
        v10 = *v7;
        if (v9 == v10)
        {
LABEL_15:
          *(_DWORD *)(a1 + 8) = v8;
LABEL_16:
          *v7 = 0;
          return a1;
        }
      }
      else
      {
        v9 = 0;
        v10 = *v7;
        if (!*v7)
          goto LABEL_15;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v8, 4);
      v9 = 0;
      v10 = *v7;
      if (!*v7)
        goto LABEL_15;
    }
    memcpy((void *)(*(_QWORD *)a1 + 4 * v9), (const void *)(*(_QWORD *)a2 + 4 * v9), *(_QWORD *)a2 + 4 * v10 - (*(_QWORD *)a2 + 4 * v9));
    goto LABEL_15;
  }
  return a1;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Diagnostic &>::CallImpl<mlir::BytecodeReader::Impl::read(mlir::Block *,llvm::function_ref<BOOL ()(mlir::Operation *)>)::$_1>(_QWORD *a1, uint64_t *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const void ***v8;
  uint64_t v9;
  __int128 v10;
  unsigned int v11;
  uint64_t v12;
  const char *v13;
  unint64_t v14;
  const void ***v15;
  uint64_t v16;
  __int128 v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t v20;
  const void ***v21;
  uint64_t v22;
  __int128 v23;
  const char *v24;
  unint64_t v26;
  BOOL v27;
  unint64_t v28;
  BOOL v29;
  unint64_t v30;
  BOOL v31;
  char *v32;
  char *v33;
  char *v34;
  const void **v35;
  const char *v36;
  uint64_t v37;
  __int16 v38;

  v2 = (_QWORD *)*a1;
  v3 = mlir::Diagnostic::attachNote(a2, 0, 0);
  v4 = v3;
  v6 = v3 + 16;
  v5 = *(_QWORD *)(v3 + 16);
  LODWORD(v35) = 3;
  v36 = "in bytecode version ";
  v37 = 20;
  v7 = *(unsigned int *)(v3 + 24);
  v8 = &v35;
  if (v7 >= *(_DWORD *)(v3 + 28))
  {
    v26 = v7 + 1;
    v27 = v5 + 24 * v7 > (unint64_t)&v35;
    if (v5 <= (unint64_t)&v35 && v27)
    {
      v32 = (char *)&v35 - v5;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v3 + 16, (void *)(v3 + 32), v26, 24);
      v5 = *(_QWORD *)(v4 + 16);
      v8 = (const void ***)&v32[v5];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v3 + 16, (void *)(v3 + 32), v26, 24);
      v5 = *(_QWORD *)(v4 + 16);
      v8 = &v35;
    }
  }
  v9 = v5 + 24 * *(unsigned int *)(v4 + 24);
  v10 = *(_OWORD *)v8;
  *(_QWORD *)(v9 + 16) = v8[2];
  *(_OWORD *)v9 = v10;
  v11 = *(_DWORD *)(v4 + 28);
  v12 = (*(_DWORD *)(v4 + 24) + 1);
  *(_DWORD *)(v4 + 24) = v12;
  v13 = (const char *)v2[31];
  LODWORD(v35) = 5;
  v36 = v13;
  v14 = *(_QWORD *)(v4 + 16);
  v15 = &v35;
  if (v12 >= v11)
  {
    v28 = v12 + 1;
    v29 = v14 + 24 * v12 > (unint64_t)&v35;
    if (v14 <= (unint64_t)&v35 && v29)
    {
      v33 = (char *)&v35 - v14;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v4 + 32), v28, 24);
      v14 = *(_QWORD *)(v4 + 16);
      v15 = (const void ***)&v33[v14];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v4 + 32), v28, 24);
      v14 = *(_QWORD *)(v4 + 16);
      v15 = &v35;
    }
  }
  v16 = v14 + 24 * *(unsigned int *)(v4 + 24);
  v17 = *(_OWORD *)v15;
  *(_QWORD *)(v16 + 16) = v15[2];
  *(_OWORD *)v16 = v17;
  v18 = *(_DWORD *)(v4 + 28);
  v19 = (*(_DWORD *)(v4 + 24) + 1);
  *(_DWORD *)(v4 + 24) = v19;
  LODWORD(v35) = 3;
  v36 = " produced by: ";
  v37 = 14;
  v20 = *(_QWORD *)(v4 + 16);
  v21 = &v35;
  if (v19 >= v18)
  {
    v30 = v19 + 1;
    v31 = v20 + 24 * v19 > (unint64_t)&v35;
    if (v20 <= (unint64_t)&v35 && v31)
    {
      v34 = (char *)&v35 - v20;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v4 + 32), v30, 24);
      v20 = *(_QWORD *)(v4 + 16);
      v21 = (const void ***)&v34[v20];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v6, (void *)(v4 + 32), v30, 24);
      v20 = *(_QWORD *)(v4 + 16);
      v21 = &v35;
    }
  }
  v22 = v20 + 24 * *(unsigned int *)(v4 + 24);
  v23 = *(_OWORD *)v21;
  *(_QWORD *)(v22 + 16) = v21[2];
  *(_OWORD *)v22 = v23;
  ++*(_DWORD *)(v4 + 24);
  v38 = 261;
  v24 = (const char *)v2[33];
  v35 = (const void **)v2[32];
  v36 = v24;
  mlir::Diagnostic::operator<<(v4, &v35);
  return 0;
}

uint64_t mlir::Diagnostic::append<char const(&)[30],std::string>(uint64_t a1, char *__s, const void **a3)
{
  const void **v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  const void ***v10;
  uint64_t v11;
  __int128 v12;
  unint64_t v14;
  BOOL v15;
  char *v16;
  const void **v17[4];
  __int16 v18;

  v6 = (const void **)strlen(__s);
  v7 = a1 + 16;
  v8 = *(_QWORD *)(a1 + 16);
  LODWORD(v17[0]) = 3;
  v17[1] = (const void **)__s;
  v17[2] = v6;
  v9 = *(unsigned int *)(a1 + 24);
  v10 = v17;
  if (v9 >= *(_DWORD *)(a1 + 28))
  {
    v14 = v9 + 1;
    v15 = v8 + 24 * v9 > (unint64_t)v17;
    if (v8 <= (unint64_t)v17 && v15)
    {
      v16 = (char *)v17 - v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v7, (void *)(a1 + 32), v14, 24);
      v8 = *(_QWORD *)(a1 + 16);
      v10 = (const void ***)&v16[v8];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v7, (void *)(a1 + 32), v14, 24);
      v8 = *(_QWORD *)(a1 + 16);
      v10 = v17;
    }
  }
  v11 = v8 + 24 * *(unsigned int *)(a1 + 24);
  v12 = *(_OWORD *)v10;
  *(_QWORD *)(v11 + 16) = v10[2];
  *(_OWORD *)v11 = v12;
  ++*(_DWORD *)(a1 + 24);
  v18 = 260;
  v17[0] = a3;
  mlir::Diagnostic::operator<<(a1, v17);
  return a1;
}

int *std::__introsort<std::_ClassicAlgPolicy,mlir::BytecodeReader::Impl::sortUseListOrder(mlir::Value)::$_2 &,std::pair<unsigned int,unsigned long long> *,false>(int *result, int *a2, uint64_t a3, char a4)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  int v20;
  unint64_t v21;
  unint64_t v22;
  int v23;
  int v24;
  unint64_t v25;
  unint64_t v26;
  int v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  int v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  int v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  int v57;
  int v58;
  int v59;
  int v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  int *v66;
  int *v67;
  unint64_t v68;
  int *v69;
  unint64_t v70;
  unint64_t v71;
  int v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t v75;
  BOOL v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  int *v81;
  int *v82;
  unint64_t v83;
  int v84;
  uint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  int v97;
  unint64_t v98;
  unint64_t v99;
  int v100;
  int v101;
  unint64_t v102;
  int v103;
  unint64_t v104;
  int v105;
  int *v106;
  BOOL v108;
  uint64_t v109;
  int *v110;
  uint64_t v111;
  unint64_t v112;
  unint64_t v113;
  int v114;
  uint64_t v115;
  uint64_t v116;
  int64_t v117;
  int64_t v118;
  BOOL v119;
  uint64_t v120;
  unint64_t v121;
  unint64_t v122;
  unint64_t v123;
  int v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  int v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  unint64_t v137;
  uint64_t v138;
  unint64_t v139;
  int v140;
  uint64_t v141;
  int v142;
  unint64_t v143;
  unint64_t v144;
  int v145;
  unint64_t *v146;
  unint64_t v147;
  unint64_t v148;
  uint64_t v149;
  unint64_t *v150;
  unint64_t *v151;
  unint64_t v152;
  unint64_t v153;

  v7 = (uint64_t)result;
LABEL_2:
  v8 = v7;
  while (2)
  {
    v7 = v8;
    v9 = (uint64_t)a2 - v8;
    v10 = (uint64_t)((uint64_t)a2 - v8) >> 4;
    switch(v10)
    {
      case 0:
      case 1:
        return result;
      case 2:
        v88 = *((_QWORD *)a2 - 1);
        v89 = *(_QWORD *)(v8 + 8);
        if (v88 > v89)
        {
          v90 = *(_DWORD *)v8;
          *(_DWORD *)v8 = *(a2 - 4);
          *(a2 - 4) = v90;
          *(_QWORD *)(v8 + 8) = v88;
          *((_QWORD *)a2 - 1) = v89;
        }
        return result;
      case 3:
        v91 = *(_QWORD *)(v8 + 24);
        v92 = *(_QWORD *)(v8 + 8);
        v93 = *((_QWORD *)a2 - 1);
        if (v91 <= v92)
        {
          if (v93 > v91)
          {
            v142 = *(_DWORD *)(v8 + 16);
            *(_DWORD *)(v8 + 16) = *(a2 - 4);
            *(a2 - 4) = v142;
            *(_QWORD *)(v8 + 24) = v93;
            *((_QWORD *)a2 - 1) = v91;
            v143 = *(_QWORD *)(v8 + 24);
            v144 = *(_QWORD *)(v8 + 8);
            if (v143 > v144)
            {
              v145 = *(_DWORD *)v8;
              *(_DWORD *)v8 = *(_DWORD *)(v8 + 16);
              *(_DWORD *)(v8 + 16) = v145;
              *(_QWORD *)(v8 + 8) = v143;
              *(_QWORD *)(v8 + 24) = v144;
            }
          }
        }
        else
        {
          v94 = *(_DWORD *)v8;
          if (v93 <= v91)
          {
            *(_DWORD *)v8 = *(_DWORD *)(v8 + 16);
            *(_DWORD *)(v8 + 16) = v94;
            *(_QWORD *)(v8 + 8) = v91;
            *(_QWORD *)(v8 + 24) = v92;
            v153 = *((_QWORD *)a2 - 1);
            if (v153 <= v92)
              return result;
            *(_DWORD *)(v8 + 16) = *(a2 - 4);
            *(a2 - 4) = v94;
            *(_QWORD *)(v8 + 24) = v153;
          }
          else
          {
            *(_DWORD *)v8 = *(a2 - 4);
            *(a2 - 4) = v94;
            *(_QWORD *)(v8 + 8) = v93;
          }
          *((_QWORD *)a2 - 1) = v92;
        }
        return result;
      case 4:
        return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,mlir::BytecodeReader::Impl::sortUseListOrder(mlir::Value)::$_2 &,std::pair<unsigned int,unsigned long long> *>((int *)v8, (int *)(v8 + 16), (int *)(v8 + 32), a2 - 4);
      case 5:
        result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,mlir::BytecodeReader::Impl::sortUseListOrder(mlir::Value)::$_2 &,std::pair<unsigned int,unsigned long long> *>((int *)v8, (int *)(v8 + 16), (int *)(v8 + 32), (int *)(v8 + 48));
        v95 = *((_QWORD *)a2 - 1);
        v96 = *(_QWORD *)(v8 + 56);
        if (v95 > v96)
        {
          v97 = *(_DWORD *)(v8 + 48);
          *(_DWORD *)(v8 + 48) = *(a2 - 4);
          *(a2 - 4) = v97;
          *(_QWORD *)(v8 + 56) = v95;
          *((_QWORD *)a2 - 1) = v96;
          v98 = *(_QWORD *)(v8 + 56);
          v99 = *(_QWORD *)(v8 + 40);
          if (v98 > v99)
          {
            v100 = *(_DWORD *)(v8 + 32);
            v101 = *(_DWORD *)(v8 + 48);
            *(_DWORD *)(v8 + 32) = v101;
            *(_DWORD *)(v8 + 48) = v100;
            *(_QWORD *)(v8 + 40) = v98;
            *(_QWORD *)(v8 + 56) = v99;
            v102 = *(_QWORD *)(v8 + 24);
            if (v98 > v102)
            {
              v103 = *(_DWORD *)(v8 + 16);
              *(_DWORD *)(v8 + 16) = v101;
              *(_DWORD *)(v8 + 32) = v103;
              *(_QWORD *)(v8 + 24) = v98;
              *(_QWORD *)(v8 + 40) = v102;
              v104 = *(_QWORD *)(v8 + 8);
              if (v98 > v104)
              {
                v105 = *(_DWORD *)v8;
                *(_DWORD *)v8 = v101;
                *(_DWORD *)(v8 + 16) = v105;
                *(_QWORD *)(v8 + 8) = v98;
                *(_QWORD *)(v8 + 24) = v104;
              }
            }
          }
        }
        return result;
      default:
        if (v9 <= 383)
        {
          v106 = (int *)(v8 + 16);
          v108 = (int *)v8 == a2 || v106 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v108)
            {
              v109 = 0;
              v110 = (int *)v8;
              do
              {
                v112 = *((_QWORD *)v110 + 3);
                v113 = *((_QWORD *)v110 + 1);
                v110 = v106;
                if (v112 > v113)
                {
                  v114 = *v106;
                  v115 = v109;
                  do
                  {
                    v116 = v8 + v115;
                    *(_DWORD *)(v116 + 16) = *(_DWORD *)(v8 + v115);
                    *(_QWORD *)(v116 + 24) = *(_QWORD *)(v8 + v115 + 8);
                    if (!v115)
                    {
                      v111 = v8;
                      goto LABEL_121;
                    }
                    v115 -= 16;
                  }
                  while (v112 > *(_QWORD *)(v116 - 8));
                  v111 = v8 + v115 + 16;
LABEL_121:
                  *(_DWORD *)v111 = v114;
                  *(_QWORD *)(v111 + 8) = v112;
                }
                v106 = v110 + 4;
                v109 += 16;
              }
              while (v110 + 4 != a2);
            }
          }
          else if (!v108)
          {
            v146 = (unint64_t *)(v8 + 24);
            do
            {
              v147 = *(_QWORD *)(v7 + 24);
              v148 = *(_QWORD *)(v7 + 8);
              v7 = (uint64_t)v106;
              if (v147 > v148)
              {
                v149 = *(_QWORD *)v106;
                v150 = v146;
                do
                {
                  v151 = v150;
                  *((_DWORD *)v150 - 2) = *((_DWORD *)v150 - 6);
                  v152 = *(v150 - 2);
                  v150 -= 2;
                  *v151 = v152;
                }
                while (v147 > *(v151 - 4));
                *((_DWORD *)v150 - 2) = v149;
                *v150 = v147;
              }
              v106 = (int *)(v7 + 16);
              v146 += 2;
            }
            while ((int *)(v7 + 16) != a2);
          }
          return result;
        }
        if (!a3)
        {
          if ((int *)v8 != a2)
          {
            v117 = (unint64_t)(v10 - 2) >> 1;
            v118 = v117;
            do
            {
              if (v117 >= v118)
              {
                v120 = (2 * v118) | 1;
                v121 = v8 + 16 * v120;
                if (2 * v118 + 2 < v10)
                {
                  v119 = *(_QWORD *)(v121 + 8) > *(_QWORD *)(v121 + 24);
                  v121 += 16 * v119;
                  if (v119)
                    v120 = 2 * v118 + 2;
                }
                v122 = v8 + 16 * v118;
                v123 = *(_QWORD *)(v122 + 8);
                if (*(_QWORD *)(v121 + 8) <= v123)
                {
                  v124 = *(_DWORD *)v122;
                  do
                  {
                    v125 = v122;
                    v122 = v121;
                    *(_DWORD *)v125 = *(_DWORD *)v121;
                    *(_QWORD *)(v125 + 8) = *(_QWORD *)(v121 + 8);
                    if (v117 < v120)
                      break;
                    v126 = (2 * v120) | 1;
                    v121 = v8 + 16 * v126;
                    v127 = 2 * v120 + 2;
                    if (v127 < v10)
                    {
                      v119 = *(_QWORD *)(v121 + 8) > *(_QWORD *)(v121 + 24);
                      v121 += 16 * v119;
                      if (v119)
                        v126 = v127;
                    }
                    result = *(int **)(v121 + 8);
                    v120 = v126;
                  }
                  while ((unint64_t)result <= v123);
                  *(_DWORD *)v122 = v124;
                  *(_QWORD *)(v122 + 8) = v123;
                }
              }
              v119 = v118-- <= 0;
            }
            while (!v119);
            v128 = (unint64_t)v9 >> 4;
            do
            {
              v129 = 0;
              v130 = *(_DWORD *)v8;
              v131 = *(_QWORD *)(v8 + 8);
              v132 = v8;
              do
              {
                v133 = v132 + 16 * v129 + 16;
                v134 = (2 * v129) | 1;
                v135 = 2 * v129 + 2;
                if (v135 < v128)
                {
                  v119 = *(_QWORD *)(v133 + 8) > *(_QWORD *)(v133 + 24);
                  v133 += 16 * v119;
                  if (v119)
                    v134 = v135;
                }
                *(_DWORD *)v132 = *(_DWORD *)v133;
                *(_QWORD *)(v132 + 8) = *(_QWORD *)(v133 + 8);
                v132 = v133;
                v129 = v134;
              }
              while (v134 <= (uint64_t)((unint64_t)(v128 - 2) >> 1));
              if ((int *)v133 == a2 - 4)
              {
                *(_DWORD *)v133 = v130;
                *(_QWORD *)(v133 + 8) = v131;
              }
              else
              {
                *(_DWORD *)v133 = *(a2 - 4);
                *(_QWORD *)(v133 + 8) = *((_QWORD *)a2 - 1);
                *(a2 - 4) = v130;
                *((_QWORD *)a2 - 1) = v131;
                v136 = v133 - v8 + 16;
                if (v136 >= 17)
                {
                  v137 = (((unint64_t)v136 >> 4) - 2) >> 1;
                  v138 = v8 + 16 * v137;
                  v139 = *(_QWORD *)(v133 + 8);
                  if (*(_QWORD *)(v138 + 8) > v139)
                  {
                    v140 = *(_DWORD *)v133;
                    do
                    {
                      v141 = v133;
                      v133 = v138;
                      *(_DWORD *)v141 = *(_DWORD *)v138;
                      *(_QWORD *)(v141 + 8) = *(_QWORD *)(v138 + 8);
                      if (!v137)
                        break;
                      v137 = (v137 - 1) >> 1;
                      v138 = v8 + 16 * v137;
                    }
                    while (*(_QWORD *)(v138 + 8) > v139);
                    *(_DWORD *)v133 = v140;
                    *(_QWORD *)(v133 + 8) = v139;
                  }
                }
              }
              a2 -= 4;
              v119 = v128-- <= 2;
            }
            while (!v119);
          }
          return result;
        }
        v11 = (unint64_t)v10 >> 1;
        v12 = v8 + 16 * ((unint64_t)v10 >> 1);
        v13 = *((_QWORD *)a2 - 1);
        if ((unint64_t)v9 < 0x801)
        {
          v17 = *(_QWORD *)(v8 + 8);
          v18 = *(_QWORD *)(v12 + 8);
          if (v17 <= v18)
          {
            if (v13 > v17)
            {
              v24 = *(_DWORD *)v8;
              *(_DWORD *)v8 = *(a2 - 4);
              *(a2 - 4) = v24;
              *(_QWORD *)(v8 + 8) = v13;
              *((_QWORD *)a2 - 1) = v17;
              v25 = *(_QWORD *)(v8 + 8);
              v26 = *(_QWORD *)(v12 + 8);
              if (v25 > v26)
              {
                v27 = *(_DWORD *)v12;
                *(_DWORD *)v12 = *(_DWORD *)v8;
                *(_DWORD *)v8 = v27;
                *(_QWORD *)(v12 + 8) = v25;
                *(_QWORD *)(v8 + 8) = v26;
                --a3;
                v28 = *(_QWORD *)v8;
                if ((a4 & 1) != 0)
                  goto LABEL_33;
                goto LABEL_57;
              }
            }
          }
          else
          {
            v19 = *(_DWORD *)v12;
            if (v13 <= v17)
            {
              *(_DWORD *)v12 = *(_DWORD *)v8;
              *(_DWORD *)v8 = v19;
              *(_QWORD *)(v12 + 8) = v17;
              *(_QWORD *)(v8 + 8) = v18;
              v40 = *((_QWORD *)a2 - 1);
              if (v40 <= v18)
                goto LABEL_32;
              *(_DWORD *)v8 = *(a2 - 4);
              *(a2 - 4) = v19;
              *(_QWORD *)(v8 + 8) = v40;
            }
            else
            {
              *(_DWORD *)v12 = *(a2 - 4);
              *(a2 - 4) = v19;
              *(_QWORD *)(v12 + 8) = v13;
            }
            *((_QWORD *)a2 - 1) = v18;
          }
LABEL_32:
          --a3;
          v28 = *(_QWORD *)v8;
          if ((a4 & 1) != 0)
            goto LABEL_33;
LABEL_57:
          v41 = *(_QWORD *)(v8 + 8);
          if (*(_QWORD *)(v8 - 8) > v41)
            goto LABEL_58;
          if (v41 <= *((_QWORD *)a2 - 1))
          {
            v79 = v8 + 16;
            do
            {
              v8 = v79;
              if (v79 >= (unint64_t)a2)
                break;
              v80 = *(_QWORD *)(v79 + 8);
              v79 += 16;
            }
            while (v41 <= v80);
          }
          else
          {
            v77 = v8;
            do
            {
              v8 = v77 + 16;
              v78 = *(_QWORD *)(v77 + 24);
              v77 += 16;
            }
            while (v41 <= v78);
          }
          v81 = a2;
          if (v8 < (unint64_t)a2)
          {
            v82 = a2;
            do
            {
              v81 = v82 - 4;
              v83 = *((_QWORD *)v82 - 1);
              v82 -= 4;
            }
            while (v41 > v83);
          }
          while (v8 < (unint64_t)v81)
          {
            v84 = *(_DWORD *)v8;
            *(_DWORD *)v8 = *v81;
            *v81 = v84;
            v85 = *(_QWORD *)(v8 + 8);
            *(_QWORD *)(v8 + 8) = *((_QWORD *)v81 + 1);
            *((_QWORD *)v81 + 1) = v85;
            do
            {
              v86 = *(_QWORD *)(v8 + 24);
              v8 += 16;
            }
            while (v41 <= v86);
            do
            {
              v87 = *((_QWORD *)v81 - 1);
              v81 -= 4;
            }
            while (v41 > v87);
          }
          if (v8 - 16 != v7)
          {
            *(_DWORD *)v7 = *(_DWORD *)(v8 - 16);
            *(_QWORD *)(v7 + 8) = *(_QWORD *)(v8 - 8);
          }
          a4 = 0;
          *(_DWORD *)(v8 - 16) = v28;
          *(_QWORD *)(v8 - 8) = v41;
          continue;
        }
        v14 = *(_QWORD *)(v12 + 8);
        v15 = *(_QWORD *)(v8 + 8);
        if (v14 <= v15)
        {
          if (v13 > v14)
          {
            v20 = *(_DWORD *)v12;
            *(_DWORD *)v12 = *(a2 - 4);
            *(a2 - 4) = v20;
            *(_QWORD *)(v12 + 8) = v13;
            *((_QWORD *)a2 - 1) = v14;
            v21 = *(_QWORD *)(v12 + 8);
            v22 = *(_QWORD *)(v8 + 8);
            if (v21 > v22)
            {
              v23 = *(_DWORD *)v8;
              *(_DWORD *)v8 = *(_DWORD *)v12;
              *(_DWORD *)v12 = v23;
              *(_QWORD *)(v8 + 8) = v21;
              *(_QWORD *)(v12 + 8) = v22;
            }
          }
        }
        else
        {
          v16 = *(_DWORD *)v8;
          if (v13 > v14)
          {
            *(_DWORD *)v8 = *(a2 - 4);
            *(a2 - 4) = v16;
            *(_QWORD *)(v8 + 8) = v13;
            goto LABEL_22;
          }
          *(_DWORD *)v8 = *(_DWORD *)v12;
          *(_DWORD *)v12 = v16;
          *(_QWORD *)(v8 + 8) = v14;
          *(_QWORD *)(v12 + 8) = v15;
          v29 = *((_QWORD *)a2 - 1);
          if (v29 > v15)
          {
            *(_DWORD *)v12 = *(a2 - 4);
            *(a2 - 4) = v16;
            *(_QWORD *)(v12 + 8) = v29;
LABEL_22:
            *((_QWORD *)a2 - 1) = v15;
          }
        }
        v30 = v8 + 16 * v11;
        v31 = v30 - 16;
        v32 = *(_QWORD *)(v30 - 8);
        v33 = *(_QWORD *)(v8 + 24);
        v34 = *((_QWORD *)a2 - 3);
        if (v32 <= v33)
        {
          if (v34 > v32)
          {
            v36 = *(_DWORD *)v31;
            *(_DWORD *)v31 = *(a2 - 8);
            *(a2 - 8) = v36;
            *(_QWORD *)(v31 + 8) = v34;
            *((_QWORD *)a2 - 3) = v32;
            v37 = *(_QWORD *)(v31 + 8);
            v38 = *(_QWORD *)(v8 + 24);
            if (v37 > v38)
            {
              v39 = *(_DWORD *)(v8 + 16);
              *(_DWORD *)(v8 + 16) = *(_DWORD *)v31;
              *(_DWORD *)v31 = v39;
              *(_QWORD *)(v8 + 24) = v37;
              *(_QWORD *)(v31 + 8) = v38;
            }
          }
        }
        else
        {
          v35 = *(_DWORD *)(v8 + 16);
          if (v34 > v32)
          {
            *(_DWORD *)(v8 + 16) = *(a2 - 8);
            *(a2 - 8) = v35;
            *(_QWORD *)(v8 + 24) = v34;
            goto LABEL_36;
          }
          *(_DWORD *)(v8 + 16) = *(_DWORD *)v31;
          *(_DWORD *)v31 = v35;
          *(_QWORD *)(v8 + 24) = v32;
          *(_QWORD *)(v31 + 8) = v33;
          v42 = *((_QWORD *)a2 - 3);
          if (v42 > v33)
          {
            *(_DWORD *)v31 = *(a2 - 8);
            *(a2 - 8) = v35;
            *(_QWORD *)(v31 + 8) = v42;
LABEL_36:
            *((_QWORD *)a2 - 3) = v33;
          }
        }
        v43 = v8 + 16 * v11;
        v44 = v43 + 16;
        v45 = *(_QWORD *)(v43 + 24);
        v46 = *(_QWORD *)(v8 + 40);
        v47 = *((_QWORD *)a2 - 5);
        if (v45 <= v46)
        {
          if (v47 > v45)
          {
            v49 = *(_DWORD *)v44;
            *(_DWORD *)v44 = *(a2 - 12);
            *(a2 - 12) = v49;
            *(_QWORD *)(v44 + 8) = v47;
            *((_QWORD *)a2 - 5) = v45;
            v50 = *(_QWORD *)(v44 + 8);
            v51 = *(_QWORD *)(v8 + 40);
            if (v50 > v51)
            {
              v52 = *(_DWORD *)(v8 + 32);
              *(_DWORD *)(v8 + 32) = *(_DWORD *)v44;
              *(_DWORD *)v44 = v52;
              *(_QWORD *)(v8 + 40) = v50;
              *(_QWORD *)(v44 + 8) = v51;
            }
          }
        }
        else
        {
          v48 = *(_DWORD *)(v8 + 32);
          if (v47 > v45)
          {
            *(_DWORD *)(v8 + 32) = *(a2 - 12);
            *(a2 - 12) = v48;
            *(_QWORD *)(v8 + 40) = v47;
            goto LABEL_45;
          }
          *(_DWORD *)(v8 + 32) = *(_DWORD *)v44;
          *(_DWORD *)v44 = v48;
          *(_QWORD *)(v8 + 40) = v45;
          *(_QWORD *)(v44 + 8) = v46;
          v53 = *((_QWORD *)a2 - 5);
          if (v53 > v46)
          {
            *(_DWORD *)v44 = *(a2 - 12);
            *(a2 - 12) = v48;
            *(_QWORD *)(v44 + 8) = v53;
LABEL_45:
            *((_QWORD *)a2 - 5) = v46;
          }
        }
        v54 = *(_QWORD *)(v12 + 8);
        v55 = *(_QWORD *)(v31 + 8);
        v56 = *(_QWORD *)(v44 + 8);
        if (v54 <= v55)
        {
          v57 = *(_DWORD *)v12;
          if (v56 <= v54)
          {
            v55 = *(_QWORD *)(v12 + 8);
          }
          else
          {
            v58 = *(_DWORD *)v44;
            *(_DWORD *)v12 = *(_DWORD *)v44;
            *(_DWORD *)v44 = v57;
            *(_QWORD *)(v12 + 8) = v56;
            *(_QWORD *)(v44 + 8) = v54;
            if (v56 <= v55)
            {
              v55 = v56;
              v57 = v58;
            }
            else
            {
              v57 = *(_DWORD *)v31;
              *(_DWORD *)v31 = v58;
              *(_DWORD *)v12 = v57;
              *(_QWORD *)(v31 + 8) = v56;
              *(_QWORD *)(v12 + 8) = v55;
            }
          }
        }
        else
        {
          v57 = *(_DWORD *)v31;
          if (v56 <= v54)
          {
            *(_DWORD *)v31 = *(_DWORD *)v12;
            *(_DWORD *)v12 = v57;
            *(_QWORD *)(v31 + 8) = v54;
            *(_QWORD *)(v12 + 8) = v55;
            if (v56 > v55)
            {
              v59 = *(_DWORD *)v44;
              *(_DWORD *)v12 = *(_DWORD *)v44;
              *(_DWORD *)v44 = v57;
              *(_QWORD *)(v12 + 8) = v56;
              *(_QWORD *)(v44 + 8) = v55;
              v55 = v56;
              v57 = v59;
            }
          }
          else
          {
            *(_DWORD *)v31 = *(_DWORD *)v44;
            *(_DWORD *)v44 = v57;
            *(_QWORD *)(v31 + 8) = v56;
            *(_QWORD *)(v44 + 8) = v55;
            v57 = *(_DWORD *)v12;
            v55 = v54;
          }
        }
        v60 = *(_DWORD *)v8;
        *(_DWORD *)v8 = v57;
        *(_DWORD *)v12 = v60;
        v61 = v8 + 16 * v11;
        v62 = *(_QWORD *)(v8 + 8);
        *(_QWORD *)(v8 + 8) = v55;
        *(_QWORD *)(v61 + 8) = v62;
        --a3;
        v28 = *(_QWORD *)v8;
        if ((a4 & 1) == 0)
          goto LABEL_57;
LABEL_33:
        v41 = *(_QWORD *)(v8 + 8);
LABEL_58:
        v63 = 0;
        do
        {
          v64 = *(_QWORD *)(v8 + v63 + 24);
          v63 += 16;
        }
        while (v64 > v41);
        v65 = v8 + v63;
        v66 = a2;
        if (v63 == 16)
        {
          v69 = a2;
          while (v65 < (unint64_t)v69)
          {
            v67 = v69 - 4;
            v70 = *((_QWORD *)v69 - 1);
            v69 -= 4;
            if (v70 > v41)
              goto LABEL_66;
          }
          v67 = v69;
          v8 = v65;
        }
        else
        {
          do
          {
            v67 = v66 - 4;
            v68 = *((_QWORD *)v66 - 1);
            v66 -= 4;
          }
          while (v68 <= v41);
LABEL_66:
          v8 = v65;
          if (v65 < (unint64_t)v67)
          {
            v71 = (unint64_t)v67;
            do
            {
              v72 = *(_DWORD *)v8;
              *(_DWORD *)v8 = *(_DWORD *)v71;
              *(_DWORD *)v71 = v72;
              v73 = *(_QWORD *)(v8 + 8);
              *(_QWORD *)(v8 + 8) = *(_QWORD *)(v71 + 8);
              *(_QWORD *)(v71 + 8) = v73;
              do
              {
                v74 = *(_QWORD *)(v8 + 24);
                v8 += 16;
              }
              while (v74 > v41);
              do
              {
                v75 = *(_QWORD *)(v71 - 8);
                v71 -= 16;
              }
              while (v75 <= v41);
            }
            while (v8 < v71);
          }
        }
        if (v8 - 16 != v7)
        {
          *(_DWORD *)v7 = *(_DWORD *)(v8 - 16);
          *(_QWORD *)(v7 + 8) = *(_QWORD *)(v8 - 8);
        }
        *(_DWORD *)(v8 - 16) = v28;
        *(_QWORD *)(v8 - 8) = v41;
        if (v65 < (unint64_t)v67)
        {
LABEL_77:
          result = (int *)std::__introsort<std::_ClassicAlgPolicy,mlir::BytecodeReader::Impl::sortUseListOrder(mlir::Value)::$_2 &,std::pair<unsigned int,unsigned long long> *,false>(v7, v8 - 16, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v76 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,mlir::BytecodeReader::Impl::sortUseListOrder(mlir::Value)::$_2 &,std::pair<unsigned int,unsigned long long> *>(v7, (int *)(v8 - 16));
        result = (int *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,mlir::BytecodeReader::Impl::sortUseListOrder(mlir::Value)::$_2 &,std::pair<unsigned int,unsigned long long> *>(v8, a2);
        if (!(_DWORD)result)
        {
          if (v76)
            continue;
          goto LABEL_77;
        }
        a2 = (int *)(v8 - 16);
        if (!v76)
          goto LABEL_2;
        return result;
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,mlir::BytecodeReader::Impl::sortUseListOrder(mlir::Value)::$_2 &,std::pair<unsigned int,unsigned long long> *>(uint64_t a1, int *a2)
{
  uint64_t v4;
  _BOOL8 result;
  unint64_t v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  int v25;
  unint64_t v26;
  int v27;
  unint64_t v28;
  int v29;
  int v30;
  unint64_t v31;
  unint64_t v32;
  int v33;
  int v34;
  int v35;
  int v36;
  unint64_t v37;
  int *v38;
  uint64_t v39;
  int v40;
  int *v41;
  unint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;

  v4 = ((uint64_t)a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *((_QWORD *)a2 - 1);
      v7 = *(_QWORD *)(a1 + 8);
      if (v6 > v7)
      {
        v8 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(a2 - 4);
        *(a2 - 4) = v8;
        *(_QWORD *)(a1 + 8) = v6;
        *((_QWORD *)a2 - 1) = v7;
      }
      return result;
    case 3:
      v9 = *(_QWORD *)(a1 + 24);
      v10 = *(_QWORD *)(a1 + 8);
      v11 = *((_QWORD *)a2 - 1);
      if (v9 <= v10)
      {
        if (v11 > v9)
        {
          v30 = *(_DWORD *)(a1 + 16);
          *(_DWORD *)(a1 + 16) = *(a2 - 4);
          *(a2 - 4) = v30;
          *(_QWORD *)(a1 + 24) = v11;
          *((_QWORD *)a2 - 1) = v9;
          v31 = *(_QWORD *)(a1 + 24);
          v32 = *(_QWORD *)(a1 + 8);
          if (v31 > v32)
          {
            v33 = *(_DWORD *)a1;
            *(_DWORD *)a1 = *(_DWORD *)(a1 + 16);
            *(_DWORD *)(a1 + 16) = v33;
            *(_QWORD *)(a1 + 8) = v31;
            *(_QWORD *)(a1 + 24) = v32;
          }
        }
      }
      else
      {
        v12 = *(_DWORD *)a1;
        if (v11 <= v9)
        {
          *(_DWORD *)a1 = *(_DWORD *)(a1 + 16);
          *(_DWORD *)(a1 + 16) = v12;
          *(_QWORD *)(a1 + 8) = v9;
          *(_QWORD *)(a1 + 24) = v10;
          v37 = *((_QWORD *)a2 - 1);
          if (v37 > v10)
          {
            *(_DWORD *)(a1 + 16) = *(a2 - 4);
            *(a2 - 4) = v12;
            *(_QWORD *)(a1 + 24) = v37;
            *((_QWORD *)a2 - 1) = v10;
          }
        }
        else
        {
          *(_DWORD *)a1 = *(a2 - 4);
          *(a2 - 4) = v12;
          *(_QWORD *)(a1 + 8) = v11;
          *((_QWORD *)a2 - 1) = v10;
        }
      }
      return result;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,mlir::BytecodeReader::Impl::sortUseListOrder(mlir::Value)::$_2 &,std::pair<unsigned int,unsigned long long> *>((int *)a1, (int *)(a1 + 16), (int *)(a1 + 32), a2 - 4);
      return 1;
    case 5:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,mlir::BytecodeReader::Impl::sortUseListOrder(mlir::Value)::$_2 &,std::pair<unsigned int,unsigned long long> *>((int *)a1, (int *)(a1 + 16), (int *)(a1 + 32), (int *)(a1 + 48));
      v19 = *((_QWORD *)a2 - 1);
      v20 = *(_QWORD *)(a1 + 56);
      if (v19 <= v20)
        return 1;
      v21 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)(a1 + 48) = *(a2 - 4);
      *(a2 - 4) = v21;
      *(_QWORD *)(a1 + 56) = v19;
      *((_QWORD *)a2 - 1) = v20;
      v22 = *(_QWORD *)(a1 + 56);
      v23 = *(_QWORD *)(a1 + 40);
      if (v22 <= v23)
        return 1;
      v24 = *(_DWORD *)(a1 + 32);
      v25 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)(a1 + 32) = v25;
      *(_DWORD *)(a1 + 48) = v24;
      *(_QWORD *)(a1 + 40) = v22;
      *(_QWORD *)(a1 + 56) = v23;
      v26 = *(_QWORD *)(a1 + 24);
      if (v22 <= v26)
        return 1;
      v27 = *(_DWORD *)(a1 + 16);
      *(_DWORD *)(a1 + 16) = v25;
      *(_DWORD *)(a1 + 32) = v27;
      *(_QWORD *)(a1 + 24) = v22;
      *(_QWORD *)(a1 + 40) = v26;
      v28 = *(_QWORD *)(a1 + 8);
      if (v22 <= v28)
        return 1;
      v29 = *(_DWORD *)a1;
      *(_DWORD *)a1 = v25;
      *(_DWORD *)(a1 + 16) = v29;
      *(_QWORD *)(a1 + 8) = v22;
      *(_QWORD *)(a1 + 24) = v28;
      return 1;
    default:
      v13 = *(_QWORD *)(a1 + 8);
      v14 = (unint64_t *)(a1 + 24);
      v15 = *(_QWORD *)(a1 + 24);
      v16 = *(_QWORD *)(a1 + 40);
      if (v15 > v13)
      {
        v17 = *(_DWORD *)a1;
        if (v16 <= v15)
        {
          *(_DWORD *)a1 = *(_DWORD *)(a1 + 16);
          *(_DWORD *)(a1 + 16) = v17;
          *(_QWORD *)(a1 + 8) = v15;
          *(_QWORD *)(a1 + 24) = v13;
          if (v16 <= v13)
            goto LABEL_30;
          *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 32);
          *(_DWORD *)(a1 + 32) = v17;
          v18 = (unint64_t *)(a1 + 24);
        }
        else
        {
          *(_DWORD *)a1 = *(_DWORD *)(a1 + 32);
          *(_DWORD *)(a1 + 32) = v17;
          v18 = (unint64_t *)(a1 + 8);
        }
        v14 = (unint64_t *)(a1 + 40);
        goto LABEL_29;
      }
      if (v16 > v15)
      {
        v34 = *(_DWORD *)(a1 + 16);
        v35 = *(_DWORD *)(a1 + 32);
        *(_DWORD *)(a1 + 16) = v35;
        *(_DWORD *)(a1 + 32) = v34;
        *(_QWORD *)(a1 + 24) = v16;
        *(_QWORD *)(a1 + 40) = v15;
        if (v16 > v13)
        {
          v36 = *(_DWORD *)a1;
          *(_DWORD *)a1 = v35;
          *(_DWORD *)(a1 + 16) = v36;
          v18 = (unint64_t *)(a1 + 8);
LABEL_29:
          *v18 = v16;
          *v14 = v13;
        }
      }
LABEL_30:
      v38 = (int *)(a1 + 48);
      if ((int *)(a1 + 48) == a2)
        return 1;
      v39 = 0;
      v40 = 0;
      v41 = (int *)(a1 + 32);
      while (1)
      {
        v42 = *((_QWORD *)v38 + 1);
        if (v42 > *((_QWORD *)v41 + 1))
          break;
LABEL_39:
        v41 = v38;
        v39 += 16;
        v38 += 4;
        if (v38 == a2)
          return 1;
      }
      v43 = *v38;
      v44 = v39;
      do
      {
        v45 = a1 + v44;
        *(_DWORD *)(v45 + 48) = *(_DWORD *)(a1 + v44 + 32);
        *(_QWORD *)(v45 + 56) = *(_QWORD *)(a1 + v44 + 40);
        if (v44 == -32)
        {
          *(_DWORD *)a1 = v43;
          *(_QWORD *)(a1 + 8) = v42;
          if (++v40 != 8)
            goto LABEL_39;
          return v38 + 4 == a2;
        }
        v44 -= 16;
      }
      while (v42 > *(_QWORD *)(v45 + 24));
      v46 = a1 + v44;
      *(_DWORD *)(v46 + 48) = v43;
      *(_QWORD *)(v46 + 56) = v42;
      if (++v40 != 8)
        goto LABEL_39;
      return v38 + 4 == a2;
  }
}

int *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,mlir::BytecodeReader::Impl::sortUseListOrder(mlir::Value)::$_2 &,std::pair<unsigned int,unsigned long long> *>(int *result, int *a2, int *a3, int *a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  int v19;

  v4 = *((_QWORD *)a2 + 1);
  v5 = *((_QWORD *)result + 1);
  v6 = *((_QWORD *)a3 + 1);
  if (v4 > v5)
  {
    v7 = *result;
    if (v6 <= v4)
    {
      *result = *a2;
      *a2 = v7;
      *((_QWORD *)result + 1) = v4;
      *((_QWORD *)a2 + 1) = v5;
      v4 = *((_QWORD *)a3 + 1);
      if (v4 <= v5)
        goto LABEL_11;
      *a2 = *a3;
      *a3 = v7;
      *((_QWORD *)a2 + 1) = v4;
    }
    else
    {
      *result = *a3;
      *a3 = v7;
      *((_QWORD *)result + 1) = v6;
    }
    *((_QWORD *)a3 + 1) = v5;
    v4 = v5;
LABEL_11:
    v12 = *((_QWORD *)a4 + 1);
    if (v12 <= v4)
      return result;
    goto LABEL_14;
  }
  if (v6 <= v4)
  {
    v4 = *((_QWORD *)a3 + 1);
    v12 = *((_QWORD *)a4 + 1);
    if (v12 <= v6)
      return result;
    goto LABEL_14;
  }
  v8 = *a2;
  *a2 = *a3;
  *a3 = v8;
  *((_QWORD *)a2 + 1) = v6;
  *((_QWORD *)a3 + 1) = v4;
  v9 = *((_QWORD *)a2 + 1);
  v10 = *((_QWORD *)result + 1);
  if (v9 <= v10)
    goto LABEL_11;
  v11 = *result;
  *result = *a2;
  *a2 = v11;
  *((_QWORD *)result + 1) = v9;
  *((_QWORD *)a2 + 1) = v10;
  v4 = *((_QWORD *)a3 + 1);
  v12 = *((_QWORD *)a4 + 1);
  if (v12 <= v4)
    return result;
LABEL_14:
  v13 = *a3;
  *a3 = *a4;
  *a4 = v13;
  *((_QWORD *)a3 + 1) = v12;
  *((_QWORD *)a4 + 1) = v4;
  v14 = *((_QWORD *)a3 + 1);
  v15 = *((_QWORD *)a2 + 1);
  if (v14 > v15)
  {
    v16 = *a2;
    *a2 = *a3;
    *a3 = v16;
    *((_QWORD *)a2 + 1) = v14;
    *((_QWORD *)a3 + 1) = v15;
    v17 = *((_QWORD *)a2 + 1);
    v18 = *((_QWORD *)result + 1);
    if (v17 > v18)
    {
      v19 = *result;
      *result = *a2;
      *a2 = v19;
      *((_QWORD *)result + 1) = v17;
      *((_QWORD *)a2 + 1) = v18;
    }
  }
  return result;
}

char *llvm::DenseMapBase<llvm::DenseMap<unsigned int,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseSetPair<unsigned int>>,unsigned int,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseSetPair<unsigned int>>::try_emplace<llvm::detail::DenseSetEmpty&>@<X0>(char *result@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  char *v4;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  _DWORD *v10;
  int v11;
  char v12;
  _DWORD *v13;
  int v14;
  BOOL v15;
  unsigned int v16;
  int v17;
  int v18;
  int v19;
  unsigned int v20;
  int v21;
  _DWORD *v22;
  int v23;
  BOOL v24;
  unsigned int v25;

  v4 = result;
  v6 = *(_QWORD *)result;
  v7 = *((_DWORD *)result + 4);
  if (!v7)
    goto LABEL_22;
  v8 = v7 - 1;
  v9 = (37 * *a2) & (v7 - 1);
  v10 = (_DWORD *)(v6 + 4 * v9);
  v11 = *v10;
  if (*a2 == *v10)
  {
LABEL_3:
    v12 = 0;
    goto LABEL_9;
  }
  v13 = 0;
  v14 = 1;
  while (v11 != -1)
  {
    if (v13)
      v15 = 0;
    else
      v15 = v11 == -2;
    if (v15)
      v13 = v10;
    v16 = v9 + v14++;
    v9 = v16 & v8;
    v10 = (_DWORD *)(v6 + 4 * (v16 & v8));
    v11 = *v10;
    if (*a2 == *v10)
      goto LABEL_3;
  }
  if (v13)
    v10 = v13;
  v17 = *((_DWORD *)result + 2);
  if (4 * v17 + 4 >= 3 * v7)
  {
LABEL_22:
    v7 *= 2;
LABEL_23:
    result = llvm::DenseMap<unsigned int,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseSetPair<unsigned int>>::grow((uint64_t)result, v7);
    v6 = *(_QWORD *)v4;
    v18 = *((_DWORD *)v4 + 4);
    if (v18)
    {
      v19 = v18 - 1;
      v20 = (37 * *a2) & (v18 - 1);
      v10 = (_DWORD *)(v6 + 4 * v20);
      v21 = *v10;
      if (*a2 != *v10)
      {
        v22 = 0;
        v23 = 1;
        while (v21 != -1)
        {
          if (v22)
            v24 = 0;
          else
            v24 = v21 == -2;
          if (v24)
            v22 = v10;
          v25 = v20 + v23++;
          v20 = v25 & v19;
          v10 = (_DWORD *)(v6 + 4 * (v25 & v19));
          v21 = *v10;
          if (*a2 == *v10)
            goto LABEL_6;
        }
        if (v22)
          v10 = v22;
      }
    }
    else
    {
      v10 = 0;
    }
    goto LABEL_6;
  }
  if (v7 + ~v17 - *((_DWORD *)result + 3) <= v7 >> 3)
    goto LABEL_23;
LABEL_6:
  ++*((_DWORD *)v4 + 2);
  if (*v10 != -1)
    --*((_DWORD *)v4 + 3);
  *v10 = *a2;
  v7 = *((_DWORD *)v4 + 4);
  v12 = 1;
LABEL_9:
  *(_QWORD *)a3 = v10;
  *(_QWORD *)(a3 + 8) = v6 + 4 * v7;
  *(_BYTE *)(a3 + 16) = v12;
  return result;
}

char *llvm::DenseMap<unsigned int,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<unsigned int,void>,llvm::detail::DenseSetPair<unsigned int>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  llvm *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  char *result;
  char *v10;
  uint64_t v11;
  int v12;
  llvm *v13;
  uint64_t v14;
  char *v15;
  int v16;
  int v17;
  unsigned int v18;
  int v19;
  char *v20;
  int v21;
  BOOL v22;
  unsigned int v23;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(llvm **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = (char *)llvm::allocate_buffer(4 * v8, (std::align_val_t)4uLL);
  v10 = result;
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v11 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v11)
      memset(result, 255, 4 * v11);
    if ((_DWORD)v3)
    {
      v12 = 0;
      v13 = v4;
      do
      {
        v16 = *(_DWORD *)v13;
        if (*(_DWORD *)v13 <= 0xFFFFFFFD)
        {
          v17 = *(_DWORD *)(a1 + 16) - 1;
          v18 = v17 & (37 * v16);
          v15 = &v10[4 * v18];
          v19 = *(_DWORD *)v15;
          if (v16 != *(_DWORD *)v15)
          {
            v20 = 0;
            v21 = 1;
            while (v19 != -1)
            {
              if (v20)
                v22 = 0;
              else
                v22 = v19 == -2;
              if (v22)
                v20 = v15;
              v23 = v18 + v21++;
              v18 = v23 & v17;
              v15 = &v10[4 * (v23 & v17)];
              v19 = *(_DWORD *)v15;
              if (v16 == *(_DWORD *)v15)
                goto LABEL_14;
            }
            if (v20)
              v15 = v20;
          }
LABEL_14:
          *(_DWORD *)v15 = v16;
          *(_DWORD *)(a1 + 8) = ++v12;
        }
        v13 = (llvm *)((char *)v13 + 4);
      }
      while (v13 != (llvm *)((char *)v4 + 4 * v3));
    }
    llvm::deallocate_buffer(v4, (void *)(4 * v3));
  }
  *(_QWORD *)(a1 + 8) = 0;
  v14 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v14)
    return (char *)memset(result, 255, 4 * v14);
  return result;
}

uint64_t *llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<mlir::BytecodeReader::Impl::processUseLists(mlir::Operation *)::$_0>(uint64_t *result, uint64_t a2)
{
  _DWORD *v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  int v13;
  BOOL v14;
  unsigned int v15;
  _QWORD *v16;
  int v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  _QWORD *v22;
  int v23;
  BOOL v24;
  unsigned int v25;

  v4 = *result;
  v3 = (_DWORD *)result[1];
  v5 = (*v3)++;
  v6 = *(_DWORD *)(v4 + 720);
  if (!v6)
    goto LABEL_22;
  v7 = *(_QWORD *)(v4 + 704);
  v8 = (v6 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  v9 = (_QWORD *)(v7 + 16 * v8);
  v10 = *v9;
  if (*v9 != a2)
  {
    v12 = 0;
    v13 = 1;
    while (v10 != -4096)
    {
      if (v12)
        v14 = 0;
      else
        v14 = v10 == -8192;
      if (v14)
        v12 = v9;
      v15 = v8 + v13++;
      v8 = v15 & (v6 - 1);
      v9 = (_QWORD *)(v7 + 16 * v8);
      v10 = *v9;
      if (*v9 == a2)
        return result;
    }
    if (v12)
      v16 = v12;
    else
      v16 = v9;
    v17 = *(_DWORD *)(v4 + 712);
    if (4 * v17 + 4 < 3 * v6)
    {
      if (v6 + ~v17 - *(_DWORD *)(v4 + 716) > v6 >> 3)
        goto LABEL_6;
      goto LABEL_23;
    }
LABEL_22:
    v6 *= 2;
LABEL_23:
    result = llvm::DenseMap<void const*,unsigned int,llvm::DenseMapInfo<void const*,void>,llvm::detail::DenseMapPair<void const*,unsigned int>>::grow(v4 + 704, v6);
    v18 = *(_QWORD *)(v4 + 704);
    v19 = *(_DWORD *)(v4 + 720) - 1;
    v20 = v19 & ((a2 >> 4) ^ (a2 >> 9));
    v16 = (_QWORD *)(v18 + 16 * v20);
    v21 = *v16;
    if (*v16 == a2)
    {
LABEL_24:
      ++*(_DWORD *)(v4 + 712);
      if (a2 == -4096)
        goto LABEL_8;
      goto LABEL_7;
    }
    v22 = 0;
    v23 = 1;
    while (v21 != -4096)
    {
      if (v22)
        v24 = 0;
      else
        v24 = v21 == -8192;
      if (v24)
        v22 = v16;
      v25 = v20 + v23++;
      v20 = v25 & v19;
      v16 = (_QWORD *)(v18 + 16 * (v25 & v19));
      v21 = *v16;
      if (*v16 == a2)
        goto LABEL_24;
    }
    if (v22)
      v16 = v22;
LABEL_6:
    v11 = *v16;
    ++*(_DWORD *)(v4 + 712);
    if (v11 == -4096)
    {
LABEL_8:
      *v16 = a2;
      *((_DWORD *)v16 + 2) = v5;
      return result;
    }
LABEL_7:
    --*(_DWORD *)(v4 + 716);
    goto LABEL_8;
  }
  return result;
}

uint64_t llvm::function_ref<mlir::WalkResult ()(mlir::Block *)>::callback_fn<mlir::BytecodeReader::Impl::processUseLists(mlir::Operation *)::$_1>(uint64_t *a1, uint64_t a2)
{
  _QWORD **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD ***)(a2 + 48);
  v3 = *(_QWORD *)(a2 + 56) - (_QWORD)v2;
  if (!v3)
    return 1;
  v4 = *a1;
  v5 = 8 * (v3 >> 3);
  while (mlir::BytecodeReader::Impl::sortUseListOrder(v4, *v2))
  {
    ++v2;
    v5 -= 8;
    if (!v5)
      return 1;
  }
  return 0;
}

uint64_t llvm::function_ref<mlir::WalkResult ()(mlir::Operation *)>::callback_fn<mlir::BytecodeReader::Impl::processUseLists(mlir::Operation *)::$_2>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *NextResultAtOffset;

  v2 = *(unsigned int *)(a2 + 36);
  if ((_DWORD)v2)
    v3 = a2 - 16;
  else
    v3 = 0;
  if (!(_DWORD)v2)
    return 1;
  v4 = 0;
  v5 = *a1;
  while (1)
  {
    NextResultAtOffset = (_QWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v3, v4);
    if (!mlir::BytecodeReader::Impl::sortUseListOrder(v5, NextResultAtOffset))
      break;
    if (v2 == ++v4)
      return 1;
  }
  return 0;
}

uint64_t llvm::raw_ostream::is_displayed(llvm::raw_ostream *this)
{
  return 0;
}

uint64_t llvm::raw_ostream::has_colors(llvm::raw_ostream *this)
{
  return (*(uint64_t (**)(llvm::raw_ostream *))(*(_QWORD *)this + 48))(this);
}

uint64_t llvm::raw_ostream::enable_colors(uint64_t this, char a2)
{
  *(_BYTE *)(this + 40) = a2;
  return this;
}

unint64_t llvm::hashing::detail::hash_combine_range_impl<char const>(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  unsigned __int8 v3;
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  _QWORD *v70;

  v2 = a2;
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v70 = a1;
    v4 = &unk_254519000;
    v67 = v66;
    v2 = a2;
    a1 = v70;
    if (v67)
    {
      v68 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v68 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v68;
      v4 = (_QWORD *)&unk_254519000;
      v2 = a2;
      a1 = v70;
    }
  }
  v5 = v4[373];
  v6 = v2 - (_QWORD)a1;
  if ((unint64_t)(v2 - (_QWORD)a1) <= 0x40)
    return llvm::hashing::detail::hash_short((llvm::hashing::detail *)a1, v6, v5);
  v8 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v5 ^ 0xB492B66FBE98F273)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ 0xB492B66FBE98F273)) >> 47) ^ 0xB492B66FBE98F273);
  v9 = __ROR8__(v5 ^ 0xB492B66FBE98F273, 49);
  v10 = v5 ^ (v5 >> 47);
  v11 = v5 ^ (((0x9DDFEA08EB382D69 * (v10 ^ (0xB492B66FBE98F273 * v5))) ^ v5) >> 47) ^ (0x9DDFEA08EB382D69
                                                                                          * (v10 ^ (0xB492B66FBE98F273
                                                                                                  * v5)));
  v12 = a1[1];
  v13 = a1[6];
  v14 = a1[7];
  v15 = v9 + v5 + v12;
  v16 = a1[5];
  v17 = v16 + v9 - 0x4B6D499041670D8DLL * __ROR8__(v13 + v5 - 0x4B6D499041670D8DLL * v5, 42);
  v18 = v10 - 0x622015F714C7D297 * (v8 ^ (v8 >> 47));
  v19 = *a1 - 0x6D8ED9027DD26057 * v5;
  v20 = a1[2];
  v21 = a1[3];
  v22 = v19 + v12 + v20;
  v23 = 0x9DDFEA08EB382D69 * ((0x9DDFEA08EB382D69 * v11) ^ ((0x9DDFEA08EB382D69 * v11) >> 47));
  v24 = __ROR8__(v18, 33);
  v25 = (0xB492B66FBE98F273 * __ROR8__(v15, 37)) ^ v23;
  v26 = __ROR8__(v22, 44) + v19 + __ROR8__(v25 + v10 + v19 + v21, 21);
  v27 = 0xB492B66FBE98F273 * v24;
  v28 = v22 + v21;
  v29 = v23 + a1[4] - 0x4B6D499041670D8DLL * v24;
  v30 = __ROR8__(v16 + v13 + v29, 44) + v29 + __ROR8__(v17 + v20 + v14 + v29, 21);
  v31 = v16 + v13 + v29 + v14;
  v32 = (v6 & 0xFFFFFFFFFFFFFFC0) - 64;
  if ((v6 & 0xFFFFFFFFFFFFFFC0) == 0x40)
  {
    v33 = v25;
  }
  else
  {
    v34 = a1 + 15;
    do
    {
      v35 = *(v34 - 6);
      v36 = __ROR8__(v17 + v28 + v27 + v35, 37);
      v38 = *(v34 - 2);
      v37 = *(v34 - 1);
      v17 = v38 + v28 - 0x4B6D499041670D8DLL * __ROR8__(v17 + v26 + v37, 42);
      v39 = v25 + v31;
      v40 = *(v34 - 7) - 0x4B6D499041670D8DLL * v26;
      v41 = *(v34 - 4);
      v42 = *(v34 - 5);
      v43 = v40 + v35 + v42;
      v33 = (0xB492B66FBE98F273 * v36) ^ v30;
      v27 = 0xB492B66FBE98F273 * __ROR8__(v39, 33);
      v26 = __ROR8__(v43, 44) + v40 + __ROR8__(v33 + v31 + v40 + v41, 21);
      v28 = v43 + v41;
      v44 = v27 + v30 + *(v34 - 3);
      v45 = *v34;
      v34 += 8;
      v46 = __ROR8__(v17 + v42 + v44 + v45, 21);
      v47 = v38 + v37 + v44;
      v30 = v46 + v44 + __ROR8__(v47, 44);
      v31 = v47 + v45;
      v25 = v33;
      v32 -= 64;
    }
    while (v32);
  }
  if ((v6 & 0x3F) != 0)
  {
    v48 = *(_QWORD *)(v2 - 56);
    v49 = *(_QWORD *)(v2 - 16);
    v50 = *(_QWORD *)(v2 - 8);
    v51 = v33 + v31;
    v52 = (0xB492B66FBE98F273 * __ROR8__(v17 + v28 + v27 + v48, 37)) ^ v30;
    v54 = *(_QWORD *)(v2 - 32);
    v53 = *(_QWORD *)(v2 - 24);
    v17 = v53 + v28 - 0x4B6D499041670D8DLL * __ROR8__(v17 + v26 + v49, 42);
    v55 = v52 + v31;
    v56 = *(_QWORD *)(v2 - 64) - 0x4B6D499041670D8DLL * v26;
    v59 = v2 - 48;
    v57 = *(_QWORD *)(v2 - 48);
    v58 = *(_QWORD *)(v59 + 8);
    v60 = v56 + v48 + v57;
    v27 = 0xB492B66FBE98F273 * __ROR8__(v51, 33);
    v26 = __ROR8__(v60, 44) + v56 + __ROR8__(v55 + v56 + v58, 21);
    v28 = v60 + v58;
    v61 = v27 + v30 + v54;
    v62 = v53 + v49 + v61;
    v30 = __ROR8__(v17 + v57 + v61 + v50, 21) + v61 + __ROR8__(v62, 44);
    v31 = v62 + v50;
    v33 = v52;
  }
  v63 = 0x9DDFEA08EB382D69
      * (v30 ^ ((0x9DDFEA08EB382D69 * (v26 ^ v30)) >> 47) ^ (0x9DDFEA08EB382D69 * (v26 ^ v30)));
  v64 = v27 - 0x4B6D499041670D8DLL * (v6 ^ (v6 >> 47)) - 0x622015F714C7D297 * (v63 ^ (v63 >> 47));
  v65 = 0x9DDFEA08EB382D69
      * ((v33
        - 0x4B6D499041670D8DLL * (v17 ^ (v17 >> 47))
        - 0x622015F714C7D297
        * ((0x9DDFEA08EB382D69
          * (v31 ^ ((0x9DDFEA08EB382D69 * (v28 ^ v31)) >> 47) ^ (0x9DDFEA08EB382D69 * (v28 ^ v31)))) ^ ((0x9DDFEA08EB382D69 * (v31 ^ ((0x9DDFEA08EB382D69 * (v28 ^ v31)) >> 47) ^ (0x9DDFEA08EB382D69 * (v28 ^ v31)))) >> 47))) ^ v64);
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v64 ^ (v65 >> 47) ^ v65)) ^ ((0x9DDFEA08EB382D69 * (v64 ^ (v65 >> 47) ^ v65)) >> 47));
}

unint64_t llvm::hashing::detail::hash_short(llvm::hashing::detail *this, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;

  if (a2 - 4 > 4)
  {
    if (a2 - 9 > 7)
    {
      if (a2 - 17 > 0xF)
      {
        if (a2 < 0x21)
        {
          if (a2)
          {
            v32 = (0x9AE16A3B2F90404FLL
                 * (*(unsigned __int8 *)this | ((unint64_t)*((unsigned __int8 *)this + (a2 >> 1)) << 8))) ^ (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)this + a2 - 1))) ^ a3;
            return 0x9AE16A3B2F90404FLL * (v32 ^ (v32 >> 47));
          }
          else
          {
            return a3 ^ 0x9AE16A3B2F90404FLL;
          }
        }
        else
        {
          v12 = (char *)this + a2;
          v13 = *(_QWORD *)((char *)this + a2 - 16);
          v14 = *(_QWORD *)((char *)this + a2 - 8);
          v15 = *(_QWORD *)this - 0x3C5A37A36834CED9 * (v13 + a2);
          v17 = *((_QWORD *)this + 2);
          v16 = *((_QWORD *)this + 3);
          v18 = __ROR8__(v15 + v16, 52);
          v19 = v15 + *((_QWORD *)this + 1);
          v20 = __ROR8__(v19, 7);
          v21 = v19 + v17;
          v22 = v20 + __ROR8__(*(_QWORD *)this - 0x3C5A37A36834CED9 * (v13 + a2), 37) + v18;
          v23 = *(_QWORD *)((char *)this + a2 - 32) + v17;
          v24 = __ROR8__(v23 + v14, 52);
          v25 = v22 + __ROR8__(v21, 31);
          v26 = __ROR8__(v23, 37);
          v27 = *((_QWORD *)v12 - 3) + v23;
          v28 = __ROR8__(v27, 7);
          v29 = v27 + v13;
          v30 = __ROR8__(v29, 31);
          v31 = ((0xC3A5C85C97CB3127
                * ((0xC3A5C85C97CB3127 * (v29 + v14 + v25) - 0x651E95C4D06FBFB1
                                                             * (v21 + v16 + v26 + v24 + v28 + v30)) ^ ((0xC3A5C85C97CB3127 * (v29 + v14 + v25) - 0x651E95C4D06FBFB1 * (v21 + v16 + v26 + v24 + v28 + v30)) >> 47))) ^ a3)
              + v25;
          return 0x9AE16A3B2F90404FLL * (v31 ^ (v31 >> 47));
        }
      }
      else
      {
        v8 = *((_QWORD *)this + 1);
        v9 = 0x9AE16A3B2F90404FLL * *(_QWORD *)((char *)this + a2 - 8);
        v10 = __ROR8__(0xB492B66FBE98F273 * *(_QWORD *)this - v8, 43)
            - 0x3C5A37A36834CED9 * *(_QWORD *)((char *)this + a2 - 16)
            + __ROR8__(v9 ^ a3, 30);
        v11 = a3 + a2 + __ROR8__(v8 ^ 0xC949D7C7509E6557, 20) - 0x4B6D499041670D8DLL * *(_QWORD *)this - v9;
        return 0x9DDFEA08EB382D69
             * ((0x9DDFEA08EB382D69
               * (v11 ^ ((0x9DDFEA08EB382D69 * (v10 ^ v11)) >> 47) ^ (0x9DDFEA08EB382D69 * (v10 ^ v11)))) ^ ((0x9DDFEA08EB382D69 * (v11 ^ ((0x9DDFEA08EB382D69 * (v10 ^ v11)) >> 47) ^ (0x9DDFEA08EB382D69 * (v10 ^ v11)))) >> 47));
      }
    }
    else
    {
      v6 = *(_QWORD *)((char *)this + a2 - 8);
      v7 = __ROR8__(v6 + a2, a2);
      return (0x9DDFEA08EB382D69
            * ((0x9DDFEA08EB382D69
              * (v7 ^ ((0x9DDFEA08EB382D69 * (*(_QWORD *)this ^ a3 ^ v7)) >> 47) ^ (0x9DDFEA08EB382D69
                                                                                    * (*(_QWORD *)this ^ a3 ^ v7)))) ^ ((0x9DDFEA08EB382D69 * (v7 ^ ((0x9DDFEA08EB382D69 * (*(_QWORD *)this ^ a3 ^ v7)) >> 47) ^ (0x9DDFEA08EB382D69 * (*(_QWORD *)this ^ a3 ^ v7)))) >> 47))) ^ v6;
    }
  }
  else
  {
    v3 = *(unsigned int *)((char *)this + a2 - 4) ^ a3;
    v4 = 0x9DDFEA08EB382D69 * (v3 ^ (a2 + 8 * *(unsigned int *)this));
    return 0x9DDFEA08EB382D69
         * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  }
}

uint64_t llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::~BumpPtrAllocatorImpl(uint64_t a1)
{
  uint64_t v2;
  void *v3;

  if (*(_DWORD *)(a1 + 24))
    llvm::deallocate_buffer(**(llvm ***)(a1 + 16), (void *)0x1000);
  v2 = *(_QWORD *)(a1 + 64);
  if (*(_DWORD *)(a1 + 72))
    llvm::deallocate_buffer(*(llvm **)v2, *(void **)(v2 + 8));
  if (v2 != a1 + 80)
    free(*(void **)(a1 + 64));
  v3 = *(void **)(a1 + 16);
  if (v3 != (void *)(a1 + 32))
    free(v3);
  return a1;
}

uint64_t llvm::SetVector<mlir::AsmDialectResourceHandle,llvm::SmallVector<mlir::AsmDialectResourceHandle,0u>,llvm::DenseSet<mlir::AsmDialectResourceHandle,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>>,0u>::insert(uint64_t a1, uint64_t *a2)
{
  uint64_t *v2;
  int v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  __int128 v15;
  _QWORD *v16;
  int v17;
  BOOL v18;
  unsigned int v19;
  unint64_t v20;
  unint64_t v21;
  char *v23;

  v2 = a2;
  v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    v5 = v4 - 1;
    v6 = ((*a2 >> 4) ^ (*a2 >> 9)) & v5;
    v7 = (_QWORD *)(*(_QWORD *)a1 + 24 * v6);
    v8 = *v7;
    if (*a2 == *v7)
      return 0;
    v16 = 0;
    v17 = 1;
    while (v8 != -4096)
    {
      if (v16)
        v18 = 0;
      else
        v18 = v8 == -8192;
      if (v18)
        v16 = v7;
      v19 = v6 + v17++;
      v6 = v19 & v5;
      v7 = (_QWORD *)(*(_QWORD *)a1 + 24 * v6);
      v8 = *v7;
      if (*a2 == *v7)
        return 0;
    }
    if (v16)
      v10 = v16;
    else
      v10 = v7;
  }
  else
  {
    v10 = 0;
  }
  llvm::DenseMapBase<llvm::DenseMap<mlir::AsmDialectResourceHandle,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseSetPair<mlir::AsmDialectResourceHandle>>,mlir::AsmDialectResourceHandle,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseSetPair<mlir::AsmDialectResourceHandle>>::InsertIntoBucket<mlir::AsmDialectResourceHandle const&,llvm::detail::DenseSetEmpty&>(a1, v10, v2);
  v11 = a1 + 24;
  v12 = *(_QWORD *)(a1 + 24);
  v13 = *(unsigned int *)(a1 + 32);
  if (v13 >= *(_DWORD *)(a1 + 36))
  {
    v20 = v13 + 1;
    v21 = v12 + 24 * v13;
    if (v12 <= (unint64_t)v2 && v21 > (unint64_t)v2)
    {
      v23 = (char *)v2 - v12;
      llvm::SmallVectorBase<unsigned int>::grow_pod(v11, (void *)(a1 + 40), v20, 24);
      v12 = *(_QWORD *)(a1 + 24);
      v2 = (uint64_t *)&v23[v12];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v11, (void *)(a1 + 40), v20, 24);
      v12 = *(_QWORD *)(a1 + 24);
    }
  }
  v14 = v12 + 24 * *(unsigned int *)(a1 + 32);
  v15 = *(_OWORD *)v2;
  *(_QWORD *)(v14 + 16) = v2[2];
  *(_OWORD *)v14 = v15;
  ++*(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t mlir::OperationName::hasTrait<mlir::OpTrait::IsIsolatedFromAbove>(_QWORD *a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  int v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = &unk_254519000;
  if ((v1 & 1) == 0)
  {
    v13 = a1;
    v2 = (_QWORD *)&unk_254519000;
    v5 = v4;
    a1 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsIsolatedFromAbove<Empty>]";
      v15 = 91;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v2 = (_QWORD *)&unk_254519000;
      a1 = v13;
    }
  }
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, v2[431]);
}

uint64_t mlir::AbstractAttribute::hasTrait<mlir::AttributeTrait::IsMutable>(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  int v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  const char *v17;
  unint64_t v18;

  v1 = a1;
  v3 = &unk_25451A000;
  if ((v2 & 1) == 0)
  {
    v3 = (_QWORD *)&unk_25451A000;
    v1 = a1;
    if (v8)
    {
      v17 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::detail::StorageUserTrait::IsMutable<Empty>]";
      v18 = 98;
      v9 = llvm::StringRef::find((uint64_t *)&v17, "DesiredTypeName = ", 0x12uLL, 0);
      if (v18 >= v9)
        v10 = v9;
      else
        v10 = v18;
      v11 = &v17[v10];
      v12 = v18 - v10;
      if (v18 - v10 >= 0x12)
        v13 = 18;
      else
        v13 = v18 - v10;
      v14 = v12 - v13;
      if (v14 >= v14 - 1)
        v15 = v14 - 1;
      else
        v15 = v14;
      mlir::detail::TypeIDResolver<mlir::detail::StorageUserTrait::IsMutable<mlir::TypeID mlir::TypeID::get<mlir::AttributeTrait::IsMutable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v11[v13], v15);
      v3 = (_QWORD *)&unk_25451A000;
      v1 = a1;
    }
  }
  v4 = (_QWORD *)(v1 + 72);
  v5 = v3[394];
  v6 = *(_QWORD *)(v1 + 96);
  if ((v6 & 2) == 0)
    v4 = (_QWORD *)*v4;
  return (*(uint64_t (**)(_QWORD *, uint64_t))(v6 & 0xFFFFFFFFFFFFFFF8))(v4, v5);
}

uint64_t mlir::AbstractType::hasTrait<mlir::TypeTrait::IsMutable>(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  int v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  const char *v17;
  unint64_t v18;

  v1 = a1;
  v3 = &unk_25451A000;
  if ((v2 & 1) == 0)
  {
    v3 = (_QWORD *)&unk_25451A000;
    v1 = a1;
    if (v8)
    {
      v17 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::detail::StorageUserTrait::IsMutable<Empty>]";
      v18 = 98;
      v9 = llvm::StringRef::find((uint64_t *)&v17, "DesiredTypeName = ", 0x12uLL, 0);
      if (v18 >= v9)
        v10 = v9;
      else
        v10 = v18;
      v11 = &v17[v10];
      v12 = v18 - v10;
      if (v18 - v10 >= 0x12)
        v13 = 18;
      else
        v13 = v18 - v10;
      v14 = v12 - v13;
      if (v14 >= v14 - 1)
        v15 = v14 - 1;
      else
        v15 = v14;
      mlir::detail::TypeIDResolver<mlir::detail::StorageUserTrait::IsMutable<mlir::TypeID mlir::TypeID::get<mlir::TypeTrait::IsMutable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v11[v13], v15);
      v3 = (_QWORD *)&unk_25451A000;
      v1 = a1;
    }
  }
  v4 = (_QWORD *)(v1 + 72);
  v5 = v3[392];
  v6 = *(_QWORD *)(v1 + 96);
  if ((v6 & 2) == 0)
    v4 = (_QWORD *)*v4;
  return (*(uint64_t (**)(_QWORD *, uint64_t))(v6 & 0xFFFFFFFFFFFFFFF8))(v4, v5);
}

_QWORD *llvm::DenseMapBase<llvm::DenseMap<mlir::AsmDialectResourceHandle,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseSetPair<mlir::AsmDialectResourceHandle>>,mlir::AsmDialectResourceHandle,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseSetPair<mlir::AsmDialectResourceHandle>>::InsertIntoBucket<mlir::AsmDialectResourceHandle const&,llvm::detail::DenseSetEmpty&>(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  int v6;
  unsigned int v7;
  uint64_t v8;
  __int128 v9;
  int v11;
  unsigned int v12;
  uint64_t v13;
  _QWORD *v14;
  int v15;
  BOOL v16;
  unsigned int v17;

  v6 = *(_DWORD *)(a1 + 8);
  v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
LABEL_3:
    v8 = *a2;
    goto LABEL_4;
  }
  llvm::DenseMap<mlir::AsmDialectResourceHandle,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseSetPair<mlir::AsmDialectResourceHandle>>::grow(a1, v7);
  v8 = *a3;
  v11 = *(_DWORD *)(a1 + 16) - 1;
  v12 = ((*a3 >> 4) ^ (*a3 >> 9)) & v11;
  a2 = (_QWORD *)(*(_QWORD *)a1 + 24 * v12);
  v13 = *a2;
  if (*a3 != *a2)
  {
    v14 = 0;
    v15 = 1;
    while (v13 != -4096)
    {
      if (v14)
        v16 = 0;
      else
        v16 = v13 == -8192;
      if (v16)
        v14 = a2;
      v17 = v12 + v15++;
      v12 = v17 & v11;
      a2 = (_QWORD *)(*(_QWORD *)a1 + 24 * (v17 & v11));
      v13 = *a2;
      if (v8 == *a2)
        goto LABEL_4;
    }
    if (v14)
      a2 = v14;
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -4096)
    --*(_DWORD *)(a1 + 12);
  v9 = *(_OWORD *)a3;
  a2[2] = a3[2];
  *(_OWORD *)a2 = v9;
  return a2;
}

int64x2_t *llvm::DenseMap<mlir::AsmDialectResourceHandle,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::AsmDialectResourceHandle,void>,llvm::detail::DenseSetPair<mlir::AsmDialectResourceHandle>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  llvm *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  int64x2_t *result;
  unsigned int v10;
  unint64_t v11;
  uint64_t *v12;
  unsigned int v13;
  unint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  int64x2_t v17;
  uint64_t v18;
  int64x2_t *v19;
  uint64_t *v20;
  llvm *v21;
  unint64_t v22;
  int64x2_t v23;
  uint64_t v24;
  int64x2_t *v25;
  uint64_t *v26;
  _QWORD *v27;
  __int128 v28;
  uint64_t v29;
  int v30;
  unsigned int v31;
  uint64_t v32;
  _QWORD *v33;
  int v34;
  BOOL v35;
  unsigned int v36;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(llvm **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  result = (int64x2_t *)llvm::allocate_buffer(24 * v8, (std::align_val_t)8uLL);
  *(_QWORD *)a1 = result;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v10 = *(_DWORD *)(a1 + 16);
    if (!v10)
      goto LABEL_16;
    v11 = 24 * v10 - 24;
    if (v11 >= 0x48)
    {
      v16 = v11 / 0x18 + 1;
      v12 = &result->i64[3 * (v16 & 0x1FFFFFFFFFFFFFFCLL)];
      v17 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
      v18 = v16 & 0x1FFFFFFFFFFFFFFCLL;
      v19 = result;
      do
      {
        *v19 = v17;
        v19[1] = (int64x2_t)xmmword_207AB7400;
        v19[4] = (int64x2_t)xmmword_207AB7400;
        v19[5] = (int64x2_t)xmmword_207AB73F0;
        v19[2] = (int64x2_t)xmmword_207AB73F0;
        v19[3] = v17;
        v19 += 6;
        v18 -= 4;
      }
      while (v18);
      if (v16 == (v16 & 0x1FFFFFFFFFFFFFFCLL))
      {
LABEL_16:
        if ((_DWORD)v3)
        {
          v21 = v4;
          do
          {
            v29 = *(_QWORD *)v21;
            if ((*(_QWORD *)v21 | 0x1000) != 0xFFFFFFFFFFFFF000)
            {
              v30 = *(_DWORD *)(a1 + 16) - 1;
              v31 = v30 & ((v29 >> 4) ^ (v29 >> 9));
              v27 = (_QWORD *)(*(_QWORD *)a1 + 24 * v31);
              v32 = *v27;
              if (v29 != *v27)
              {
                v33 = 0;
                v34 = 1;
                while (v32 != -4096)
                {
                  if (v33)
                    v35 = 0;
                  else
                    v35 = v32 == -8192;
                  if (v35)
                    v33 = v27;
                  v36 = v31 + v34++;
                  v31 = v36 & v30;
                  v27 = (_QWORD *)(*(_QWORD *)a1 + 24 * (v36 & v30));
                  v32 = *v27;
                  if (v29 == *v27)
                    goto LABEL_26;
                }
                if (v33)
                  v27 = v33;
              }
LABEL_26:
              v28 = *(_OWORD *)v21;
              v27[2] = *((_QWORD *)v21 + 2);
              *(_OWORD *)v27 = v28;
              ++*(_DWORD *)(a1 + 8);
            }
            v21 = (llvm *)((char *)v21 + 24);
          }
          while (v21 != (llvm *)((char *)v4 + 24 * v3));
        }
        llvm::deallocate_buffer(v4, (void *)(24 * v3));
      }
    }
    else
    {
      v12 = (uint64_t *)result;
    }
    v20 = &result->i64[3 * v10];
    do
    {
      *v12 = -4096;
      v12[1] = -4096;
      v12[2] = 0;
      v12 += 3;
    }
    while (v12 != v20);
    goto LABEL_16;
  }
  *(_QWORD *)(a1 + 8) = 0;
  v13 = *(_DWORD *)(a1 + 16);
  if (v13)
  {
    v14 = 24 * v13 - 24;
    if (v14 < 0x48)
    {
      v15 = (uint64_t *)result;
LABEL_21:
      v26 = &result->i64[3 * v13];
      do
      {
        *v15 = -4096;
        v15[1] = -4096;
        v15[2] = 0;
        v15 += 3;
      }
      while (v15 != v26);
      return result;
    }
    v22 = v14 / 0x18 + 1;
    v15 = &result->i64[3 * (v22 & 0x1FFFFFFFFFFFFFFCLL)];
    v23 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    v24 = v22 & 0x1FFFFFFFFFFFFFFCLL;
    v25 = result;
    do
    {
      *v25 = v23;
      v25[1] = (int64x2_t)xmmword_207AB7400;
      v25[4] = (int64x2_t)xmmword_207AB7400;
      v25[5] = (int64x2_t)xmmword_207AB73F0;
      v25[2] = (int64x2_t)xmmword_207AB73F0;
      v25[3] = v23;
      v25 += 6;
      v24 -= 4;
    }
    while (v24);
    if (v22 != (v22 & 0x1FFFFFFFFFFFFFFCLL))
      goto LABEL_21;
  }
  return result;
}

uint64_t mlir::OpInterface<mlir::CastOpInterface,mlir::detail::CastOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  BOOL v3;
  uint64_t v4;
  unint64_t v6;
  uint64_t result;
  unsigned __int8 v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  const char *v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  unint64_t v31;

  v1 = *(_QWORD *)(a1 + 48);
  v2 = *(void **)(v1 + 16);
  v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
    v4 = 0;
  else
    v4 = *(_QWORD *)(a1 + 48);
  if (v3)
  {
    v30 = *(const char **)(v1 + 8);
    result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v30);
    if (result)
    {
      if ((v8 & 1) == 0)
      {
        v12 = result;
        result = v12;
        if (v13)
        {
          v30 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CastOpInterface]";
          v31 = 71;
          v14 = llvm::StringRef::find((uint64_t *)&v30, "DesiredTypeName = ", 0x12uLL, 0);
          if (v31 >= v14)
            v15 = v14;
          else
            v15 = v31;
          v16 = &v30[v15];
          v17 = v31 - v15;
          if (v31 - v15 >= 0x12)
            v18 = 18;
          else
            v18 = v31 - v15;
          v19 = v17 - v18;
          if (v19 >= v19 - 1)
            v20 = v19 - 1;
          else
            v20 = v19;
          mlir::detail::TypeIDResolver<mlir::CastOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
          result = v12;
        }
      }
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)result + 104))(result, mlir::detail::TypeIDResolver<mlir::CastOpInterface,void>::resolveTypeID(void)::id, v1);
    }
  }
  else
  {
    v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    result = mlir::detail::InterfaceMap::lookup<mlir::CastOpInterface>(v6 + 32);
    if (!result)
    {
      v9 = *(_QWORD *)(v6 + 24);
      v10 = *(_QWORD *)(a1 + 48);
      if ((v11 & 1) == 0)
      {
        v29 = *(_QWORD *)(a1 + 48);
        v10 = v29;
        if (v21)
        {
          v30 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CastOpInterface]";
          v31 = 71;
          v22 = llvm::StringRef::find((uint64_t *)&v30, "DesiredTypeName = ", 0x12uLL, 0);
          if (v31 >= v22)
            v23 = v22;
          else
            v23 = v31;
          v24 = &v30[v23];
          v25 = v31 - v23;
          if (v31 - v23 >= 0x12)
            v26 = 18;
          else
            v26 = v31 - v23;
          v27 = v25 - v26;
          if (v27 >= v27 - 1)
            v28 = v27 - 1;
          else
            v28 = v27;
          mlir::detail::TypeIDResolver<mlir::CastOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v24[v26], v28);
          v10 = v29;
        }
      }
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 104))(v9, mlir::detail::TypeIDResolver<mlir::CastOpInterface,void>::resolveTypeID(void)::id, v10);
    }
  }
  return result;
}

uint64_t mlir::detail::InterfaceMap::lookup<mlir::CastOpInterface>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  _QWORD *v9;
  unint64_t v10;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  unint64_t v23;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v21 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v13 = v12;
    a1 = v21;
    if (v13)
    {
      v22 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CastOpInterface]";
      v23 = 71;
      v14 = llvm::StringRef::find((uint64_t *)&v22, "DesiredTypeName = ", 0x12uLL, 0);
      if (v23 >= v14)
        v15 = v14;
      else
        v15 = v23;
      v16 = &v22[v15];
      v17 = v23 - v15;
      if (v23 - v15 >= 0x12)
        v18 = 18;
      else
        v18 = v23 - v15;
      v19 = v17 - v18;
      if (v19 >= v19 - 1)
        v20 = v19 - 1;
      else
        v20 = v19;
      mlir::detail::TypeIDResolver<mlir::CastOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v21;
    }
  }
  v3 = *(unsigned int *)(a1 + 8);
  if (!(_DWORD)v3)
    return 0;
  v4 = v2[344];
  v5 = *(_QWORD **)a1;
  v6 = *(_QWORD *)a1 + 16 * v3;
  do
  {
    v7 = v3 >> 1;
    v8 = &v5[2 * (v3 >> 1)];
    v10 = *v8;
    v9 = v8 + 2;
    v3 += ~(v3 >> 1);
    if (v10 < v4)
      v5 = v9;
    else
      v3 = v7;
  }
  while (v3);
  if (v5 != (_QWORD *)v6 && *v5 == v4)
    return v5[1];
  else
    return 0;
}

void mlir::OperationState::addAttribute(mlir::Attribute *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::StringAttr *Context;
  uint64_t v9;
  _QWORD v10[4];
  __int16 v11;
  uint64_t v12[2];

  Context = (mlir::StringAttr *)mlir::Attribute::getContext(a1);
  v11 = 261;
  v10[0] = a2;
  v10[1] = a3;
  v9 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v10);
  ZinMirCacheTensors::ZinMirCacheTensors(v12, v9, a4);
  mlir::NamedAttrList::push_back((uint64_t)a1 + 112, v12[0], v12[1]);
}

uint64_t *mlir::SideEffects::Effect::Base<mlir::MemoryEffects::Write,mlir::MemoryEffects::Effect>::get()
{
  unsigned __int8 v0;
  unsigned __int8 v2;
  unint64_t v3;
  unint64_t v4;
  const char *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  const char *v10;
  unint64_t v11;

  if ((v0 & 1) != 0
  {
    return &mlir::SideEffects::Effect::get<mlir::MemoryEffects::Write>(void)::instance;
  }
  if ((v2 & 1) == 0
  {
    v10 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffects::Write]";
    v11 = 76;
    v3 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
    if (v11 >= v3)
      v4 = v3;
    else
      v4 = v11;
    v5 = &v10[v4];
    v6 = v11 - v4;
    if (v11 - v4 >= 0x12)
      v7 = 18;
    else
      v7 = v11 - v4;
    v8 = v6 - v7;
    if (v8 >= v8 - 1)
      v9 = v8 - 1;
    else
      v9 = v8;
    mlir::detail::TypeIDResolver<mlir::MemoryEffects::Write,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v5[v7], v9);
  }
  mlir::SideEffects::Effect::get<mlir::MemoryEffects::Write>(void)::instance = mlir::detail::TypeIDResolver<mlir::MemoryEffects::Write,void>::resolveTypeID(void)::id;
  return &mlir::SideEffects::Effect::get<mlir::MemoryEffects::Write>(void)::instance;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  const void ***v8;
  char *v9;
  char *v10;
  __int128 v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  const void ***v20;
  char *v21;
  char *v22;
  __int128 v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  _QWORD *v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD **))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  if (mlir::detail::DenseArrayAttrImpl<int>::classof(v39))
    v5 = v4;
  else
    v5 = 0;
  *a2 = v5;
  if (v5)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v8 = &v40;
    v9 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v9 = (char *)v46;
        v8 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v8 = &v40;
        v9 = (char *)v46;
      }
    }
    v10 = &v9[24 * v47];
    v11 = *(_OWORD *)v8;
    *((_QWORD *)v10 + 2) = v8[2];
    *(_OWORD *)v10 = v11;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::detail::DenseArrayAttrImpl<int32_t>]";
  v41 = 91;
  v12 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v12)
      v13 = v12;
    else
      v13 = v41;
    v14 = 18;
    if (v41 - v13 < 0x12)
      v14 = v41 - v13;
    v15 = v41 - v13 - v14;
    if (v15 >= v15 - 1)
      --v15;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v13 + v14);
    v41 = v15;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v16 = &v40;
      v17 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v17 = (char *)v46;
          v16 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v16 = &v40;
          v17 = (char *)v46;
        }
      }
      v18 = &v17[24 * v47];
      v19 = *(_OWORD *)v16;
      *((_QWORD *)v18 + 2) = v16[2];
      *(_OWORD *)v18 = v19;
      ++v47;
      if (v44)
      {
        v20 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, (uint64_t)v39);
        v21 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v21 = (char *)v46;
            v20 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v20 = &v40;
            v21 = (char *)v46;
          }
        }
        v22 = &v21[24 * v47];
        v23 = *(_OWORD *)v20;
        *((_QWORD *)v22 + 2) = v20[2];
        *(_OWORD *)v22 = v23;
        ++v47;
      }
    }
  }
  v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v24 = __p;
    if (__p)
    {
      v25 = v53;
      v26 = __p;
      if (v53 != __p)
      {
        do
          v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        v26 = __p;
      }
      v53 = v24;
      operator delete(v26);
    }
    v27 = v50;
    if (v50)
    {
      v28 = v51;
      v29 = v50;
      if (v51 != v50)
      {
        do
        {
          v31 = *--v28;
          v30 = v31;
          *v28 = 0;
          if (v31)
            MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
        }
        while (v28 != v27);
        v29 = v50;
      }
      v51 = v27;
      operator delete(v29);
    }
    if (v46 != v49)
      free(v46);
  }
  return v6;
}

uint64_t mlir::DialectBytecodeWriter::writeSparseArray<int>(uint64_t a1, int *a2, uint64_t a3)
{
  int *v4;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;

  v4 = a2;
  if ((_DWORD)a3)
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    do
    {
      if (a2[v8])
      {
        v7 = v8;
        ++v6;
      }
      ++v8;
    }
    while (a3 != v8);
    if (v7 > 0x100)
      goto LABEL_15;
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  if (v6 > a3 >> 1)
  {
LABEL_15:
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, 2 * a3);
    if (a3)
    {
      v14 = 4 * a3;
      do
      {
        v15 = *v4++;
        result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, v15);
        v14 -= 4;
      }
      while (v14);
    }
    return result;
  }
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, (2 * v6) | 1);
  if (v6)
  {
    v10 = v7 + 1;
    v11 = 32 - __clz(v7);
    result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, v11);
    v12 = 0;
    do
    {
      v13 = v4[v12];
      if (v13)
        result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 48))(a1, (v13 << v11) | v12);
      ++v12;
    }
    while (v10 != v12);
  }
  return result;
}

uint64_t *mlir::SideEffects::Effect::Base<mlir::MemoryEffects::Read,mlir::MemoryEffects::Effect>::get()
{
  unsigned __int8 v0;
  unsigned __int8 v2;
  unint64_t v3;
  unint64_t v4;
  const char *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  const char *v10;
  unint64_t v11;

  if ((v0 & 1) != 0
  {
    return &mlir::SideEffects::Effect::get<mlir::MemoryEffects::Read>(void)::instance;
  }
  if ((v2 & 1) == 0
  {
    v10 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffects::Read]";
    v11 = 75;
    v3 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
    if (v11 >= v3)
      v4 = v3;
    else
      v4 = v11;
    v5 = &v10[v4];
    v6 = v11 - v4;
    if (v11 - v4 >= 0x12)
      v7 = 18;
    else
      v7 = v11 - v4;
    v8 = v6 - v7;
    if (v8 >= v8 - 1)
      v9 = v8 - 1;
    else
      v9 = v8;
    mlir::detail::TypeIDResolver<mlir::MemoryEffects::Read,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v5[v7], v9);
  }
  mlir::SideEffects::Effect::get<mlir::MemoryEffects::Read>(void)::instance = mlir::detail::TypeIDResolver<mlir::MemoryEffects::Read,void>::resolveTypeID(void)::id;
  return &mlir::SideEffects::Effect::get<mlir::MemoryEffects::Read>(void)::instance;
}

uint64_t *mlir::SideEffects::Effect::Base<mlir::MemoryEffects::Allocate,mlir::MemoryEffects::Effect>::get()
{
  unsigned __int8 v0;
  unsigned __int8 v2;
  unint64_t v3;
  unint64_t v4;
  const char *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  const char *v10;
  unint64_t v11;

  if ((v0 & 1) != 0
  {
    return &mlir::SideEffects::Effect::get<mlir::MemoryEffects::Allocate>(void)::instance;
  }
  if ((v2 & 1) == 0
  {
    v10 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffects::Allocate]";
    v11 = 79;
    v3 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
    if (v11 >= v3)
      v4 = v3;
    else
      v4 = v11;
    v5 = &v10[v4];
    v6 = v11 - v4;
    if (v11 - v4 >= 0x12)
      v7 = 18;
    else
      v7 = v11 - v4;
    v8 = v6 - v7;
    if (v8 >= v8 - 1)
      v9 = v8 - 1;
    else
      v9 = v8;
    mlir::detail::TypeIDResolver<mlir::MemoryEffects::Allocate,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v5[v7], v9);
  }
  mlir::SideEffects::Effect::get<mlir::MemoryEffects::Allocate>(void)::instance = mlir::detail::TypeIDResolver<mlir::MemoryEffects::Allocate,void>::resolveTypeID(void)::id;
  return &mlir::SideEffects::Effect::get<mlir::MemoryEffects::Allocate>(void)::instance;
}

uint64_t mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const char *v6;
  const char *v7;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  char *v24;
  char *v25;
  __int128 v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v36;
  unint64_t v37;
  BOOL v38;
  unint64_t v39;
  BOOL v40;
  int64_t v41;
  int64_t v42;
  int64_t v43;
  char v44[32];
  __int16 v45;
  int v46;
  const char *v47;
  uint64_t v48;
  _QWORD v49[3];
  void *v50;
  unsigned int v51;
  unsigned int v52;
  _BYTE v53[96];
  void *v54;
  _QWORD *v55;
  void *__p;
  _QWORD *v57;
  char v58;
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  v6 = (const char *)*((unsigned int *)a2 + 2);
  v7 = (const char *)*(unsigned int *)(a3 + 8);
  if ((_DWORD)v6 == (_DWORD)v7)
  {
    if ((_DWORD)v6)
    {
      v9 = *a2;
      v10 = *(_QWORD **)a3;
      v11 = 32 * (_QWORD)v6;
      while ((*(unsigned __int8 (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 696))(a1, v9, *v10, a5))
      {
        v9 += 32;
        ++v10;
        v11 -= 32;
        if (!v11)
          return 1;
      }
      return 0;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    v45 = 257;
    (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)a1 + 24))(v49, a1, a4, v44);
    if (v49[0])
    {
      v46 = 5;
      v47 = v6;
      v13 = &v46;
      v14 = (char *)v50;
      if (v51 >= v52)
      {
        v36 = v51 + 1;
        if (v50 <= &v46 && (char *)v50 + 24 * v51 > (char *)&v46)
        {
          v41 = (char *)&v46 - (_BYTE *)v50;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v53, v36, 24);
          v14 = (char *)v50;
          v13 = (int *)((char *)v50 + v41);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v53, v36, 24);
          v13 = &v46;
          v14 = (char *)v50;
        }
      }
      v15 = &v14[24 * v51];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
      *(_OWORD *)v15 = v16;
      v17 = ++v51;
      if (v49[0])
      {
        v46 = 3;
        v47 = " operands present, but expected ";
        v48 = 32;
        v18 = &v46;
        v19 = (char *)v50;
        if (v17 >= v52)
        {
          v37 = v17 + 1;
          v38 = (char *)v50 + 24 * v17 > (char *)&v46;
          if (v50 <= &v46 && v38)
          {
            v42 = (char *)&v46 - (_BYTE *)v50;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v53, v37, 24);
            v19 = (char *)v50;
            v18 = (int *)((char *)v50 + v42);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v53, v37, 24);
            v18 = &v46;
            v19 = (char *)v50;
          }
        }
        v20 = &v19[24 * v51];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
        *(_OWORD *)v20 = v21;
        v22 = ++v51;
        if (v49[0])
        {
          v46 = 5;
          v47 = v7;
          v23 = &v46;
          v24 = (char *)v50;
          if (v22 >= v52)
          {
            v39 = v22 + 1;
            v40 = (char *)v50 + 24 * v22 > (char *)&v46;
            if (v50 <= &v46 && v40)
            {
              v43 = (char *)&v46 - (_BYTE *)v50;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v53, v39, 24);
              v24 = (char *)v50;
              v23 = (int *)((char *)v50 + v43);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v53, v39, 24);
              v23 = &v46;
              v24 = (char *)v50;
            }
          }
          v25 = &v24[24 * v51];
          v26 = *(_OWORD *)v23;
          *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
          *(_OWORD *)v25 = v26;
          ++v51;
        }
      }
    }
    v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v49);
    if (v49[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v49);
    if (v58)
    {
      v27 = __p;
      if (__p)
      {
        v28 = v57;
        v29 = __p;
        if (v57 != __p)
        {
          do
            v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
          while (v28 != v27);
          v29 = __p;
        }
        v57 = v27;
        operator delete(v29);
      }
      v30 = v54;
      if (v54)
      {
        v31 = v55;
        v32 = v54;
        if (v55 != v54)
        {
          do
          {
            v34 = *--v31;
            v33 = v34;
            *v31 = 0;
            if (v34)
              MEMORY[0x20BD002D4](v33, 0x1000C8077774924);
          }
          while (v31 != v30);
          v32 = v54;
        }
        v55 = v30;
        operator delete(v32);
      }
      if (v50 != v53)
        free(v50);
    }
  }
  return v12;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::UnitAttr]";
  v41 = 64;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::AsmParser::parseType<mlir::FunctionType>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  uint64_t v18;
  _QWORD v19[3];
  void *v20;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  void *__p;
  _QWORD *v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v18 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 504))(a1, &v18))
    return 0;
  v5 = v18;
  if (*(_UNKNOWN **)(*(_QWORD *)v18 + 136) != &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
    v5 = 0;
  *a2 = v5;
  if (v5)
    return 1;
  v16 = "invalid kind of type specified";
  v17 = 259;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v19, a1, v4, &v16);
  v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
  if (v19[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
  if (v26)
  {
    v8 = __p;
    if (__p)
    {
      v9 = v25;
      v10 = __p;
      if (v25 != __p)
      {
        do
          v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
        while (v9 != v8);
        v10 = __p;
      }
      v25 = v8;
      operator delete(v10);
    }
    v11 = v22;
    if (v22)
    {
      v12 = v23;
      v13 = v22;
      if (v23 != v22)
      {
        do
        {
          v15 = *--v12;
          v14 = v15;
          *v12 = 0;
          if (v15)
            MEMORY[0x20BD002D4](v14, 0x1000C8077774924);
        }
        while (v12 != v11);
        v13 = v22;
      }
      v23 = v11;
      operator delete(v13);
    }
    if (v20 != &v21)
      free(v20);
  }
  return v6;
}

uint64_t mlir::OpAsmParser::resolveOperands<llvm::detail::concat_range<mlir::OpAsmParser::UnresolvedOperand const,llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &>,llvm::ArrayRef<mlir::Type> &>(uint64_t a1, uint64_t **a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  BOOL v12;
  BOOL v13;
  const char *v14;
  const char *v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int *v29;
  char *v30;
  char *v31;
  __int128 v32;
  uint64_t v33;
  int *v34;
  char *v35;
  char *v36;
  __int128 v37;
  uint64_t v38;
  int *v39;
  char *v40;
  char *v41;
  __int128 v42;
  _QWORD *v43;
  _QWORD *v44;
  void *v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v52;
  unint64_t v53;
  BOOL v54;
  unint64_t v55;
  BOOL v56;
  int64_t v57;
  int64_t v58;
  int64_t v59;
  _QWORD v60[4];
  __int16 v61;
  int v62;
  const char *v63;
  uint64_t v64;
  _QWORD v65[3];
  void *v66;
  unsigned int v67;
  unsigned int v68;
  _BYTE v69[96];
  void *v70;
  _QWORD *v71;
  void *__p;
  _QWORD *v73;
  char v74;
  uint64_t v75;

  v75 = *MEMORY[0x24BDAC8D0];
  v6 = a2[1];
  v8 = **a2;
  v7 = (*a2)[1];
  v10 = *v6;
  v9 = v6[1];
  v65[0] = v8;
  v60[0] = v10;
  v11 = v7 == 0;
  v12 = v9 == 0;
  v13 = (v7 | v9) == 0;
  if (!(v7 | v9))
  {
    v14 = (const char *)a3[1];
    if (v14)
    {
      v15 = 0;
LABEL_31:
      v61 = 257;
      (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v65, a1, a4, v60);
      if (v65[0])
      {
        v62 = 5;
        v63 = v15;
        v29 = &v62;
        v30 = (char *)v66;
        if (v67 >= v68)
        {
          v52 = v67 + 1;
          if (v66 <= &v62 && (char *)v66 + 24 * v67 > (char *)&v62)
          {
            v57 = (char *)&v62 - (_BYTE *)v66;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v52, 24);
            v30 = (char *)v66;
            v29 = (int *)((char *)v66 + v57);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v52, 24);
            v29 = &v62;
            v30 = (char *)v66;
          }
        }
        v31 = &v30[24 * v67];
        v32 = *(_OWORD *)v29;
        *((_QWORD *)v31 + 2) = *((_QWORD *)v29 + 2);
        *(_OWORD *)v31 = v32;
        v33 = ++v67;
        if (v65[0])
        {
          v62 = 3;
          v63 = " operands present, but expected ";
          v64 = 32;
          v34 = &v62;
          v35 = (char *)v66;
          if (v33 >= v68)
          {
            v53 = v33 + 1;
            v54 = (char *)v66 + 24 * v33 > (char *)&v62;
            if (v66 <= &v62 && v54)
            {
              v58 = (char *)&v62 - (_BYTE *)v66;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v53, 24);
              v35 = (char *)v66;
              v34 = (int *)((char *)v66 + v58);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v53, 24);
              v34 = &v62;
              v35 = (char *)v66;
            }
          }
          v36 = &v35[24 * v67];
          v37 = *(_OWORD *)v34;
          *((_QWORD *)v36 + 2) = *((_QWORD *)v34 + 2);
          *(_OWORD *)v36 = v37;
          v38 = ++v67;
          if (v65[0])
          {
            v62 = 5;
            v63 = v14;
            v39 = &v62;
            v40 = (char *)v66;
            if (v38 >= v68)
            {
              v55 = v38 + 1;
              v56 = (char *)v66 + 24 * v38 > (char *)&v62;
              if (v66 <= &v62 && v56)
              {
                v59 = (char *)&v62 - (_BYTE *)v66;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v55, 24);
                v40 = (char *)v66;
                v39 = (int *)((char *)v66 + v59);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v66, v69, v55, 24);
                v39 = &v62;
                v40 = (char *)v66;
              }
            }
            v41 = &v40[24 * v67];
            v42 = *(_OWORD *)v39;
            *((_QWORD *)v41 + 2) = *((_QWORD *)v39 + 2);
            *(_OWORD *)v41 = v42;
            ++v67;
          }
        }
      }
      v28 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v65);
      if (v65[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v65);
      if (v74)
      {
        v43 = __p;
        if (__p)
        {
          v44 = v73;
          v45 = __p;
          if (v73 != __p)
          {
            do
              v44 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v44 - 1);
            while (v44 != v43);
            v45 = __p;
          }
          v73 = v43;
          operator delete(v45);
        }
        v46 = v70;
        if (v70)
        {
          v47 = v71;
          v48 = v70;
          if (v71 != v70)
          {
            do
            {
              v50 = *--v47;
              v49 = v50;
              *v47 = 0;
              if (v50)
                MEMORY[0x20BD002D4](v49, 0x1000C8077774924);
            }
            while (v47 != v46);
            v48 = v70;
          }
          v71 = v46;
          operator delete(v48);
        }
        if (v66 != v69)
          free(v66);
      }
      return v28;
    }
    return 1;
  }
  v15 = 0;
  v17 = v10;
  v18 = v8;
  v19 = v8 + 32 * v7;
  v20 = v10 + 32 * v9;
  while (1)
  {
    if (v18 != v19)
    {
      v21 = v65;
LABEL_9:
      *v21 = v18 + 32;
      v18 = v65[0];
      v22 = v60[0];
      goto LABEL_10;
    }
    v22 = v10 + 32 * v9;
    v18 = v19;
    if (v17 != v20)
    {
      v21 = v60;
      v18 = v17;
      goto LABEL_9;
    }
LABEL_10:
    ++v15;
    v17 = v22;
    if (v18 == v19)
    {
      v17 = v22;
      if (v22 == v20)
        break;
    }
  }
  v14 = (const char *)a3[1];
  if (v14 != v15)
    goto LABEL_31;
  if (v13)
    return 1;
  v23 = (_QWORD *)*a3;
  while (1)
  {
    v24 = v12 ? 0 : v10;
    v25 = (v8 == 0) | v11 ? v24 : v8;
    if (!(*(unsigned __int8 (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 696))(a1, v25, *v23, a5))break;
    if (v11)
      v26 = v10;
    else
      v26 = v8;
    v27 = v26 + 32;
    if (v11)
      v10 = v27;
    else
      v8 = v27;
    ++v23;
    v12 = v10 == v20;
    v11 = v8 == v19;
    if (v8 == v19 && v10 == v20)
      return 1;
  }
  return 0;
}

llvm::raw_ostream *mlir::AsmPrinter::printFunctionalType<mlir::ValueTypeRange<mlir::OperandRange>,mlir::ValueTypeRange<mlir::ResultRange>>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  llvm::raw_ostream *v6;
  llvm::raw_ostream *v7;
  _BYTE *v8;
  _BYTE *v9;
  _QWORD v11[2];

  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v7 = v6;
  v8 = (_BYTE *)*((_QWORD *)v6 + 4);
  if ((unint64_t)v8 >= *((_QWORD *)v6 + 3))
  {
    llvm::raw_ostream::write(v6, 40);
  }
  else
  {
    *((_QWORD *)v6 + 4) = v8 + 1;
    *v8 = 40;
  }
  v11[0] = ", ";
  v11[1] = 2;
  llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::OperandRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &,mlir::OpAsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>(*a2, a2[1], a2[2], a2[3], a1, a1, (uint64_t)v11);
  v9 = (_BYTE *)*((_QWORD *)v7 + 4);
  if ((unint64_t)v9 >= *((_QWORD *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 41);
  }
  else
  {
    *((_QWORD *)v7 + 4) = v9 + 1;
    *v9 = 41;
  }
  return mlir::AsmPrinter::printArrowTypeList<mlir::ValueTypeRange<mlir::ResultRange> &>(a1, a3);
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::bufferization::detail::ToMemrefOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::bufferization::detail::ToMemrefOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::bufferization::detail::ToMemrefOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::bufferization::detail::ToMemrefOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::bufferization::detail::ToMemrefOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::bufferization::detail::ToMemrefOpGenericAdaptorBase::Properties]";
        v15 = 119;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::bufferization::detail::ToMemrefOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[417];
    return a1[32];
  }
  return result;
}

void mlir::bufferization::ToMemrefOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  mlir::MLIRContext *v9;
  uint64_t UnitAttr;
  uint64_t v11;
  uint64_t v12;

  v12 = a4;
  mlir::OperationState::addOperands(a2, (uint64_t)&v12, 1);
  if (a5)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v9);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::bufferization::detail::ToMemrefOpGenericAdaptorBase::Properties>((_QWORD *)a2) = UnitAttr;
  }
  v11 = *(unsigned int *)(a2 + 72);
  if (v11 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v11) = a3;
  ++*(_DWORD *)(a2 + 72);
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::bufferization::detail::ToTensorOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::bufferization::detail::ToTensorOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::bufferization::detail::ToTensorOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::bufferization::detail::ToTensorOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::bufferization::detail::ToTensorOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::bufferization::detail::ToTensorOpGenericAdaptorBase::Properties]";
        v15 = 119;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::bufferization::detail::ToTensorOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[419];
    return a1[32];
  }
  return result;
}

void mlir::bufferization::ToTensorOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  mlir::MLIRContext *v9;
  uint64_t UnitAttr;
  uint64_t v11;
  mlir::MLIRContext *Context;
  unsigned int v13;
  uint64_t v14;
  uint64_t TensorTypeFromMemRefType;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  __int128 v22;
  void *__src;
  uint64_t v24;
  _BYTE v25[16];
  __int128 v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v20 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  if (a4)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v9);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::bufferization::detail::ToTensorOpGenericAdaptorBase::Properties>((_QWORD *)a2) = UnitAttr;
  }
  if (a5)
  {
    v11 = mlir::Builder::getUnitAttr(a1, v9);
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::bufferization::detail::ToTensorOpGenericAdaptorBase::Properties>((_QWORD *)a2)
              + 8) = v11;
  }
  __src = v25;
  v24 = 0x200000000;
  mlir::ValueRange::ValueRange((unint64_t *)&v22, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v21, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v26 = v22;
  if ((_DWORD)v24 != 1)
  {
    if (!(_DWORD)v24)
    {
      if (HIDWORD(v24))
      {
        v13 = 0;
LABEL_10:
        bzero((char *)__src + 8 * v13, 8 - 8 * v13);
        goto LABEL_11;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v25, 1uLL, 8);
      v13 = v24;
      if ((_DWORD)v24 != 1)
        goto LABEL_10;
    }
LABEL_11:
    LODWORD(v24) = 1;
  }
  v14 = mlir::ValueRange::dereference_iterator(&v26, 0);
  TensorTypeFromMemRefType = mlir::memref::getTensorTypeFromMemRefType(*(_QWORD *)(v14 + 8) & 0xFFFFFFFFFFFFFFF8);
  *(_QWORD *)__src = TensorTypeFromMemRefType;
  v16 = __src;
  v17 = v24;
  v18 = *(unsigned int *)(a2 + 72);
  v19 = v18 + v24;
  if (v19 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v19, 8);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v17)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v18), v16, 8 * v17);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v18 + v17;
  if (__src != v25)
    free(__src);
}

uint64_t mlir::DialectBytecodeReader::readSparseArray<int>(uint64_t a1, _DWORD *a2, const char *a3)
{
  unint64_t v6;
  unint64_t v7;
  int *v9;
  char *v10;
  char *v11;
  __int128 v12;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  int *v24;
  char *v25;
  char *v26;
  __int128 v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  int *v36;
  char *v37;
  char *v38;
  __int128 v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  int *v48;
  char *v49;
  char *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  char *v54;
  char *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  char *v59;
  char *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  char *v64;
  char *v65;
  __int128 v66;
  _QWORD *v67;
  _QWORD *v68;
  void *v69;
  _QWORD *v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  BOOL v75;
  unint64_t v76;
  unint64_t v77;
  BOOL v78;
  unint64_t v79;
  BOOL v80;
  unint64_t v81;
  unint64_t v82;
  BOOL v83;
  unint64_t v84;
  BOOL v85;
  unint64_t v86;
  BOOL v87;
  int64_t v88;
  int64_t v89;
  int64_t v90;
  int64_t v91;
  int64_t v92;
  int64_t v93;
  int64_t v94;
  int64_t v95;
  int64_t v96;
  unint64_t v97;
  unint64_t v98;
  _QWORD v99[4];
  __int16 v100;
  unint64_t v101;
  int v102;
  const char *v103;
  uint64_t v104;
  _QWORD v105[3];
  void *v106;
  unsigned int v107;
  unsigned int v108;
  _BYTE v109[96];
  void *v110;
  _QWORD *v111;
  void *__p;
  _QWORD *v113;
  char v114;
  uint64_t v115;

  v115 = *MEMORY[0x24BDAC8D0];
  v101 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, unint64_t *))(*(_QWORD *)a1 + 72))(a1, &v101))
    return 0;
  v6 = v101;
  v7 = v101 >> 1;
  v101 >>= 1;
  if (v6 < 2)
    return 1;
  if ((v6 & 1) != 0)
  {
    v98 = 0;
    if ((*(unsigned __int8 (**)(uint64_t, unint64_t *))(*(_QWORD *)a1 + 72))(a1, &v98))
    {
      if (v98 >= 9)
      {
        v99[0] = "reading sparse array with indexing above 8 bits: ";
        v100 = 259;
        (*(void (**)(_QWORD *__return_ptr, uint64_t, _QWORD *))(*(_QWORD *)a1 + 16))(v105, a1, v99);
        if (v105[0])
        {
          v102 = 5;
          v103 = (const char *)v98;
          v36 = &v102;
          v37 = (char *)v106;
          if (v107 >= v108)
          {
            v76 = v107 + 1;
            if (v106 <= &v102 && (char *)v106 + 24 * v107 > (char *)&v102)
            {
              v90 = (char *)&v102 - (_BYTE *)v106;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v76, 24);
              v37 = (char *)v106;
              v36 = (int *)((char *)v106 + v90);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v76, 24);
              v36 = &v102;
              v37 = (char *)v106;
            }
          }
          v38 = &v37[24 * v107];
          v39 = *(_OWORD *)v36;
          *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
          *(_OWORD *)v38 = v39;
          ++v107;
          if (v105[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v105);
        }
        if (!v114)
          return 0;
        v40 = __p;
        if (__p)
        {
          v41 = v113;
          v42 = __p;
          if (v113 != __p)
          {
            do
              v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
            while (v41 != v40);
            v42 = __p;
          }
          v113 = v40;
          operator delete(v42);
        }
        v31 = v110;
        if (!v110)
          goto LABEL_78;
        v43 = v111;
        v33 = v110;
        if (v111 == v110)
          goto LABEL_77;
        do
        {
          v45 = *--v43;
          v44 = v45;
          *v43 = 0;
          if (v45)
            MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
        }
        while (v43 != v31);
        goto LABEL_76;
      }
      v46 = v101;
      if (!(_DWORD)v101)
        return 1;
      while (1)
      {
        v97 = 0;
        if (!(*(unsigned __int8 (**)(uint64_t, unint64_t *))(*(_QWORD *)a1 + 72))(a1, &v97))
          break;
        v47 = v97 & ~(-1 << v98);
        if (v47 >= (unint64_t)a3)
        {
          v99[0] = "reading a sparse array found index ";
          v100 = 259;
          (*(void (**)(_QWORD *__return_ptr, uint64_t, _QWORD *))(*(_QWORD *)a1 + 16))(v105, a1, v99);
          if (v105[0])
          {
            v102 = 5;
            v103 = (const char *)v47;
            v48 = &v102;
            v49 = (char *)v106;
            if (v107 >= v108)
            {
              v81 = v107 + 1;
              if (v106 <= &v102 && (char *)v106 + 24 * v107 > (char *)&v102)
              {
                v93 = (char *)&v102 - (_BYTE *)v106;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v81, 24);
                v49 = (char *)v106;
                v48 = (int *)((char *)v106 + v93);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v81, 24);
                v48 = &v102;
                v49 = (char *)v106;
              }
            }
            v50 = &v49[24 * v107];
            v51 = *(_OWORD *)v48;
            *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
            *(_OWORD *)v50 = v51;
            v52 = ++v107;
            if (v105[0])
            {
              v102 = 3;
              v103 = " but only ";
              v104 = 10;
              v53 = &v102;
              v54 = (char *)v106;
              if (v52 >= v108)
              {
                v82 = v52 + 1;
                v83 = (char *)v106 + 24 * v52 > (char *)&v102;
                if (v106 <= &v102 && v83)
                {
                  v94 = (char *)&v102 - (_BYTE *)v106;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v82, 24);
                  v54 = (char *)v106;
                  v53 = (int *)((char *)v106 + v94);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v82, 24);
                  v53 = &v102;
                  v54 = (char *)v106;
                }
              }
              v55 = &v54[24 * v107];
              v56 = *(_OWORD *)v53;
              *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
              *(_OWORD *)v55 = v56;
              v57 = ++v107;
              if (v105[0])
              {
                v102 = 5;
                v103 = a3;
                v58 = &v102;
                v59 = (char *)v106;
                if (v57 >= v108)
                {
                  v84 = v57 + 1;
                  v85 = (char *)v106 + 24 * v57 > (char *)&v102;
                  if (v106 <= &v102 && v85)
                  {
                    v95 = (char *)&v102 - (_BYTE *)v106;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v84, 24);
                    v59 = (char *)v106;
                    v58 = (int *)((char *)v106 + v95);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v84, 24);
                    v58 = &v102;
                    v59 = (char *)v106;
                  }
                }
                v60 = &v59[24 * v107];
                v61 = *(_OWORD *)v58;
                *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                *(_OWORD *)v60 = v61;
                v62 = ++v107;
                if (v105[0])
                {
                  v102 = 3;
                  v103 = " storage available.";
                  v104 = 19;
                  v63 = &v102;
                  v64 = (char *)v106;
                  if (v62 >= v108)
                  {
                    v86 = v62 + 1;
                    v87 = (char *)v106 + 24 * v62 > (char *)&v102;
                    if (v106 <= &v102 && v87)
                    {
                      v96 = (char *)&v102 - (_BYTE *)v106;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v86, 24);
                      v64 = (char *)v106;
                      v63 = (int *)((char *)v106 + v96);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v86, 24);
                      v63 = &v102;
                      v64 = (char *)v106;
                    }
                  }
                  v65 = &v64[24 * v107];
                  v66 = *(_OWORD *)v63;
                  *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                  *(_OWORD *)v65 = v66;
                  ++v107;
                  if (v105[0])
                    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v105);
                }
              }
            }
          }
          if (!v114)
            return 0;
          v67 = __p;
          if (__p)
          {
            v68 = v113;
            v69 = __p;
            if (v113 != __p)
            {
              do
                v68 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v68 - 1);
              while (v68 != v67);
              v69 = __p;
            }
            v113 = v67;
            operator delete(v69);
          }
          v31 = v110;
          if (!v110)
            goto LABEL_78;
          v70 = v111;
          v33 = v110;
          if (v111 == v110)
            goto LABEL_77;
          do
          {
            v72 = *--v70;
            v71 = v72;
            *v70 = 0;
            if (v72)
              MEMORY[0x20BD002D4](v71, 0x1000C8077774924);
          }
          while (v70 != v31);
          goto LABEL_76;
        }
        a2[v47] = v97 >> v98;
        if (!--v46)
          return 1;
      }
    }
  }
  else
  {
    if (v7 <= (unint64_t)a3)
    {
      while (1)
      {
        v105[0] = 0;
        if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 72))(a1, v105))
          break;
        *a2++ = v105[0];
        if (!--v7)
          return 1;
      }
      return 0;
    }
    v99[0] = "trying to read an array of ";
    v100 = 259;
    (*(void (**)(_QWORD *__return_ptr, uint64_t, _QWORD *))(*(_QWORD *)a1 + 16))(v105, a1, v99);
    if (v105[0])
    {
      v102 = 5;
      v103 = (const char *)v101;
      v9 = &v102;
      v10 = (char *)v106;
      if (v107 >= v108)
      {
        v73 = v107 + 1;
        if (v106 <= &v102 && (char *)v106 + 24 * v107 > (char *)&v102)
        {
          v88 = (char *)&v102 - (_BYTE *)v106;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v73, 24);
          v10 = (char *)v106;
          v9 = (int *)((char *)v106 + v88);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v73, 24);
          v9 = &v102;
          v10 = (char *)v106;
        }
      }
      v11 = &v10[24 * v107];
      v12 = *(_OWORD *)v9;
      *((_QWORD *)v11 + 2) = *((_QWORD *)v9 + 2);
      *(_OWORD *)v11 = v12;
      v13 = ++v107;
      if (v105[0])
      {
        v102 = 3;
        v103 = " but only ";
        v104 = 10;
        v14 = &v102;
        v15 = (char *)v106;
        if (v13 >= v108)
        {
          v74 = v13 + 1;
          v75 = (char *)v106 + 24 * v13 > (char *)&v102;
          if (v106 <= &v102 && v75)
          {
            v89 = (char *)&v102 - (_BYTE *)v106;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v74, 24);
            v15 = (char *)v106;
            v14 = (int *)((char *)v106 + v89);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v74, 24);
            v14 = &v102;
            v15 = (char *)v106;
          }
        }
        v16 = &v15[24 * v107];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
        *(_OWORD *)v16 = v17;
        v18 = ++v107;
        if (v105[0])
        {
          v102 = 5;
          v103 = a3;
          v19 = &v102;
          v20 = (char *)v106;
          if (v18 >= v108)
          {
            v77 = v18 + 1;
            v78 = (char *)v106 + 24 * v18 > (char *)&v102;
            if (v106 <= &v102 && v78)
            {
              v91 = (char *)&v102 - (_BYTE *)v106;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v77, 24);
              v20 = (char *)v106;
              v19 = (int *)((char *)v106 + v91);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v77, 24);
              v19 = &v102;
              v20 = (char *)v106;
            }
          }
          v21 = &v20[24 * v107];
          v22 = *(_OWORD *)v19;
          *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
          *(_OWORD *)v21 = v22;
          v23 = ++v107;
          if (v105[0])
          {
            v102 = 3;
            v103 = " storage available.";
            v104 = 19;
            v24 = &v102;
            v25 = (char *)v106;
            if (v23 >= v108)
            {
              v79 = v23 + 1;
              v80 = (char *)v106 + 24 * v23 > (char *)&v102;
              if (v106 <= &v102 && v80)
              {
                v92 = (char *)&v102 - (_BYTE *)v106;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v79, 24);
                v25 = (char *)v106;
                v24 = (int *)((char *)v106 + v92);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v79, 24);
                v24 = &v102;
                v25 = (char *)v106;
              }
            }
            v26 = &v25[24 * v107];
            v27 = *(_OWORD *)v24;
            *((_QWORD *)v26 + 2) = *((_QWORD *)v24 + 2);
            *(_OWORD *)v26 = v27;
            ++v107;
            if (v105[0])
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v105);
          }
        }
      }
    }
    if (v114)
    {
      v28 = __p;
      if (__p)
      {
        v29 = v113;
        v30 = __p;
        if (v113 != __p)
        {
          do
            v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
          while (v29 != v28);
          v30 = __p;
        }
        v113 = v28;
        operator delete(v30);
      }
      v31 = v110;
      if (!v110)
        goto LABEL_78;
      v32 = v111;
      v33 = v110;
      if (v111 == v110)
      {
LABEL_77:
        v111 = v31;
        operator delete(v33);
LABEL_78:
        if (v106 != v109)
          free(v106);
        return 0;
      }
      do
      {
        v35 = *--v32;
        v34 = v35;
        *v32 = 0;
        if (v35)
          MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
      }
      while (v32 != v31);
LABEL_76:
      v33 = v110;
      goto LABEL_77;
    }
  }
  return 0;
}

void mlir::SideEffects::DefaultResource::~DefaultResource(mlir::SideEffects::DefaultResource *this)
{
  JUMPOUT(0x20BD002F8);
}

const char *mlir::SideEffects::DefaultResource::getName(mlir::SideEffects::DefaultResource *this)
{
  return "<Default>";
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::DimOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::DimOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::tensor::DimOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t mlir::AsmParser::parseType<mlir::TensorType>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v8;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  uint64_t v20;
  _QWORD v21[3];
  void *v22;
  uint64_t v23;
  void *v24;
  _QWORD *v25;
  void *__p;
  _QWORD *v27;
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v20 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 504))(a1, &v20))
    return 0;
  v5 = v20;
  v6 = *(void **)(*(_QWORD *)v20 + 136);
  if (v6 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    && v6 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v5 = 0;
  }
  *a2 = v5;
  if (v5)
    return 1;
  v18 = "invalid kind of type specified";
  v19 = 259;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v21, a1, v4, &v18);
  v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v21);
  if (v21[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v21);
  if (v28)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v27;
      v12 = __p;
      if (v27 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v27 = v10;
      operator delete(v12);
    }
    v13 = v24;
    if (v24)
    {
      v14 = v25;
      v15 = v24;
      if (v25 != v24)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v24;
      }
      v25 = v13;
      operator delete(v15);
    }
    if (v22 != &v23)
      free(v22);
  }
  return v8;
}

uint64_t mlir::OpInterface<mlir::MemoryEffectOpInterface,mlir::detail::MemoryEffectOpInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1;
  void *v2;
  BOOL v3;
  uint64_t v4;
  unint64_t v6;
  uint64_t result;
  unsigned __int8 v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  const char *v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  unint64_t v31;

  v1 = *(_QWORD *)(a1 + 48);
  v2 = *(void **)(v1 + 16);
  v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
    v4 = 0;
  else
    v4 = *(_QWORD *)(a1 + 48);
  if (v3)
  {
    v30 = *(const char **)(v1 + 8);
    result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v30);
    if (result)
    {
      if ((v8 & 1) == 0)
      {
        v12 = result;
        result = v12;
        if (v13)
        {
          v30 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
          v31 = 79;
          v14 = llvm::StringRef::find((uint64_t *)&v30, "DesiredTypeName = ", 0x12uLL, 0);
          if (v31 >= v14)
            v15 = v14;
          else
            v15 = v31;
          v16 = &v30[v15];
          v17 = v31 - v15;
          if (v31 - v15 >= 0x12)
            v18 = 18;
          else
            v18 = v31 - v15;
          v19 = v17 - v18;
          if (v19 >= v19 - 1)
            v20 = v19 - 1;
          else
            v20 = v19;
          mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
          result = v12;
        }
      }
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)result + 104))(result, mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id, v1);
    }
  }
  else
  {
    v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    result = mlir::detail::InterfaceMap::lookup<mlir::MemoryEffectOpInterface>(v6 + 32);
    if (!result)
    {
      v9 = *(_QWORD *)(v6 + 24);
      v10 = *(_QWORD *)(a1 + 48);
      if ((v11 & 1) == 0)
      {
        v29 = *(_QWORD *)(a1 + 48);
        v10 = v29;
        if (v21)
        {
          v30 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
          v31 = 79;
          v22 = llvm::StringRef::find((uint64_t *)&v30, "DesiredTypeName = ", 0x12uLL, 0);
          if (v31 >= v22)
            v23 = v22;
          else
            v23 = v31;
          v24 = &v30[v23];
          v25 = v31 - v23;
          if (v31 - v23 >= 0x12)
            v26 = 18;
          else
            v26 = v31 - v23;
          v27 = v25 - v26;
          if (v27 >= v27 - 1)
            v28 = v27 - 1;
          else
            v28 = v27;
          mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v24[v26], v28);
          v10 = v29;
        }
      }
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 104))(v9, mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id, v10);
    }
  }
  return result;
}

uint64_t mlir::detail::InterfaceMap::lookup<mlir::MemoryEffectOpInterface>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  unint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  _QWORD *v9;
  unint64_t v10;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  unint64_t v23;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v21 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v13 = v12;
    a1 = v21;
    if (v13)
    {
      v22 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v23 = 79;
      v14 = llvm::StringRef::find((uint64_t *)&v22, "DesiredTypeName = ", 0x12uLL, 0);
      if (v23 >= v14)
        v15 = v14;
      else
        v15 = v23;
      v16 = &v22[v15];
      v17 = v23 - v15;
      if (v23 - v15 >= 0x12)
        v18 = 18;
      else
        v18 = v23 - v15;
      v19 = v17 - v18;
      if (v19 >= v19 - 1)
        v20 = v19 - 1;
      else
        v20 = v19;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v21;
    }
  }
  v3 = *(unsigned int *)(a1 + 8);
  if (!(_DWORD)v3)
    return 0;
  v4 = v2[1];
  v5 = *(_QWORD **)a1;
  v6 = *(_QWORD *)a1 + 16 * v3;
  do
  {
    v7 = v3 >> 1;
    v8 = &v5[2 * (v3 >> 1)];
    v10 = *v8;
    v9 = v8 + 2;
    v3 += ~(v3 >> 1);
    if (v10 < v4)
      v5 = v9;
    else
      v3 = v7;
  }
  while (v3);
  if (v5 != (_QWORD *)v6 && *v5 == v4)
    return v5[1];
  else
    return 0;
}

void llvm::SmallVectorImpl<llvm::SmallVector<mlir::OpFoldResult,6u>>::append(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v16;

  v3 = a3;
  v6 = *(unsigned int *)(a1 + 8);
  v7 = v6 + a2;
  if (v7 > *(unsigned int *)(a1 + 12))
  {
    v14 = *(_QWORD *)a1 + (v6 << 6);
    if (*(_QWORD *)a1 <= a3 && v14 > a3)
    {
      v16 = a3 - *(_QWORD *)a1;
      llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::OpFoldResult,6u>,false>::grow(a1, v7);
      v3 = *(_QWORD *)a1 + v16;
    }
    else
    {
      llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::OpFoldResult,6u>,false>::grow(a1, v7);
    }
  }
  v8 = *(unsigned int *)(a1 + 8);
  if (a2)
  {
    v9 = (_QWORD *)(*(_QWORD *)a1 + (v8 << 6));
    v10 = a2;
    while (1)
    {
      v12 = v9 + 2;
      *v9 = v9 + 2;
      v9[1] = 0x600000000;
      if (v9 == (_QWORD *)v3)
        goto LABEL_7;
      v13 = *(unsigned int *)(v3 + 8);
      if (!*(_DWORD *)(v3 + 8))
        goto LABEL_7;
      if (v13 < 7)
      {
        v11 = *(unsigned int *)(v3 + 8);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v9, v9 + 2, *(unsigned int *)(v3 + 8), 8);
        v11 = *(unsigned int *)(v3 + 8);
        if (!(_DWORD)v11)
          goto LABEL_6;
        v12 = (void *)*v9;
      }
      memcpy(v12, *(const void **)v3, 8 * v11);
LABEL_6:
      *((_DWORD *)v9 + 2) = v13;
LABEL_7:
      v9 += 8;
      if (!--v10)
      {
        LODWORD(v8) = *(_DWORD *)(a1 + 8);
        break;
      }
    }
  }
  *(_DWORD *)(a1 + 8) = v8 + a2;
}

void llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::OpFoldResult,6u>,false>::grow(uint64_t a1, unint64_t a2)
{
  _DWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  int v13;
  unint64_t v14;

  v14 = 0;
  v3 = (_DWORD *)(a1 + 16);
  v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 64, &v14);
  v5 = v4;
  v6 = *(_DWORD **)a1;
  v7 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v7)
  {
    v8 = v7 << 6;
    v9 = v4;
    do
    {
      *v9 = v9 + 2;
      v9[1] = 0x600000000;
      if (v6[2])
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v9, (uint64_t)v6);
      v9 += 8;
      v6 += 16;
      v8 -= 64;
    }
    while (v8);
    v6 = *(_DWORD **)a1;
    v10 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v10)
    {
      v11 = v10 << 6;
      do
      {
        v12 = *(char **)((char *)v6 + v11 - 64);
        if ((char *)v6 + v11 - 48 != v12)
          free(v12);
        v11 -= 64;
      }
      while (v11);
      v6 = *(_DWORD **)a1;
    }
  }
  v13 = v14;
  if (v6 != v3)
    free(v6);
  *(_QWORD *)a1 = v5;
  *(_DWORD *)(a1 + 12) = v13;
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::memref::DimOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::memref::DimOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::memref::DimOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::DimOp,mlir::Value &,mlir::detail::TypedValue<mlir::IndexType>>(mlir::IndexType **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  ZinIrHalH13g *v11;
  ZinIrHalH13g *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x24BDAC8D0];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.dim", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"tensor.dim";
    v17[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::tensor::DimOp::build(a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::DimOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::tensor::ExtractOp,mlir::detail::TypedValue<mlir::TensorType>,mlir::OperandRange>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  ZinIrHalH13g *v12;
  ZinIrHalH13g *v13;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  uint64_t v18[4];
  __int16 v19;
  unint64_t v20[2];
  _QWORD v21[39];

  v21[38] = *MEMORY[0x24BDAC8D0];
  v15 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"tensor.extract", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    v19 = 1283;
    v18[2] = (uint64_t)"tensor.extract";
    v18[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v17 = 259;
    llvm::operator+(v18, (uint64_t *)&v16, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  v11 = *a3;
  mlir::ValueRange::ValueRange(v20, *(_QWORD *)a4, *(_QWORD *)(a4 + 8));
  mlir::tensor::ExtractOp::build((uint64_t)a1, (uint64_t)v21, v11, v20[0], v20[1]);
  v12 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v12 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::tensor::ExtractOp,void>::id)
    v13 = v12;
  else
    v13 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v13;
}

uint64_t **llvm::find_if<llvm::SmallVector<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,4u> &,std::optional<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>> mlir::MemoryEffectOpInterface::getEffectOnValue<mlir::MemoryEffects::Allocate>(mlir::Value)::{lambda(llvm::SmallVector<mlir::SideEffects::EffectInstance<mlir::MemoryEffects::Effect>,4u> & &)#1}>(uint64_t a1, _QWORD *a2)
{
  uint64_t **result;
  uint64_t v4;
  uint64_t **v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  unsigned __int8 v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  const char *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t **v24;
  _QWORD *v25;
  uint64_t **v26;
  const char *v27;
  unint64_t v28;

  result = *(uint64_t ***)a1;
  v4 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v4)
  {
    v5 = &result[5 * v4];
    v6 = 40 * v4;
    v7 = (_QWORD *)&unk_25451A000;
    while (1)
    {
      v8 = **result;
      if ((v9 & 1) == 0)
      {
        v26 = result;
        v24 = v5;
        v25 = a2;
        v22 = **result;
        v23 = v6;
        v8 = v22;
        v6 = v23;
        v7 = &unk_25451A000;
        v5 = v24;
        a2 = v25;
        v13 = v12;
        result = v26;
        if (v13)
        {
          v27 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffects::Allocate]";
          v28 = 79;
          v14 = llvm::StringRef::find((uint64_t *)&v27, "DesiredTypeName = ", 0x12uLL, 0);
          if (v28 >= v14)
            v15 = v14;
          else
            v15 = v28;
          v16 = &v27[v15];
          v17 = v28 - v15;
          v18 = 18;
          if (v17 < 0x12)
            v18 = v17;
          v19 = (uint64_t)&v16[v18];
          v20 = v17 - v18;
          if (v20 >= v20 - 1)
            v21 = v20 - 1;
          else
            v21 = v20;
          mlir::detail::TypeIDResolver<mlir::MemoryEffects::Allocate,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID(v19, v21);
          v8 = v22;
          v6 = v23;
          v7 = (_QWORD *)&unk_25451A000;
          v5 = v24;
          a2 = v25;
          result = v26;
        }
      }
      if (v8 == v7[413])
      {
        v10 = (unint64_t)result[2];
        v11 = v10 <= 7 ? 0 : v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8;
        if (*a2 == v11)
          break;
      }
      result += 5;
      v6 -= 40;
      if (!v6)
        return v5;
    }
  }
  return result;
}

unint64_t llvm::hashing::detail::hash_combine_recursive_helper::combine(llvm::hashing::detail::hash_combine_recursive_helper *this, uint64_t a2, char *__src, char *a4)
{
  uint64_t v7;
  uint64_t v8;
  char *v9;
  unint64_t v10;
  char *v11;
  llvm::hashing::detail::hash_combine_recursive_helper *v12;
  unint64_t v13;
  char v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  llvm::hashing::detail::hash_combine_recursive_helper *v20;
  char v21;
  char v22;
  llvm::hashing::detail::hash_combine_recursive_helper *v23;
  llvm::hashing::detail::hash_combine_recursive_helper *v24;
  llvm::hashing::detail::hash_combine_recursive_helper *v25;
  char *v26;
  BOOL v27;
  char v28;
  uint64_t v29;
  __int128 *v30;
  char *v31;
  unint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t *v36;
  char *v37;
  unint64_t v38;
  uint64_t v39;
  char *v40;
  char *v41;
  char v42;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;

  if (!a2)
    return llvm::hashing::detail::hash_short(this, __src - (char *)this, *((_QWORD *)this + 15));
  if (this != (llvm::hashing::detail::hash_combine_recursive_helper *)__src && __src != a4)
  {
    if ((char *)this + 1 != __src)
    {
      if (__src + 1 == a4)
      {
        v17 = *(a4 - 1);
        if (a4 - 1 != (char *)this)
          memmove((char *)this + 1, this, a4 - 1 - (char *)this);
        *(_BYTE *)this = v17;
        goto LABEL_42;
      }
      v7 = __src - (char *)this;
      v8 = a4 - __src;
      if (__src - (char *)this != a4 - __src)
      {
        v18 = __src - (char *)this;
        do
        {
          v19 = v18;
          v18 = v8;
          v8 = v19 % v8;
        }
        while (v8);
        if (v18)
        {
          v20 = (llvm::hashing::detail::hash_combine_recursive_helper *)((char *)this + v18);
          do
          {
            v22 = *((_BYTE *)v20 - 1);
            v20 = (llvm::hashing::detail::hash_combine_recursive_helper *)((char *)v20 - 1);
            v21 = v22;
            v23 = (llvm::hashing::detail::hash_combine_recursive_helper *)((char *)v20 + v7);
            v24 = v20;
            do
            {
              v25 = v24;
              v24 = v23;
              *(_BYTE *)v25 = *(_BYTE *)v23;
              v26 = (char *)(a4 - (char *)v23);
              v27 = __OFSUB__(v7, v26);
              v29 = v7 - (_QWORD)v26;
              v28 = (v29 < 0) ^ v27;
              v23 = (llvm::hashing::detail::hash_combine_recursive_helper *)((char *)this + v29);
              if (v28)
                v23 = (llvm::hashing::detail::hash_combine_recursive_helper *)((char *)v24 + v7);
            }
            while (v23 != v20);
            *(_BYTE *)v24 = v21;
          }
          while (v20 != this);
        }
        goto LABEL_42;
      }
      v9 = &a4[~(unint64_t)__src];
      if (v9 >= &__src[~(unint64_t)this])
        v9 = &__src[~(unint64_t)this];
      v10 = (unint64_t)(v9 + 1);
      v11 = __src;
      v12 = this;
      if (v10 < 8)
        goto LABEL_38;
      if (&__src[v10] > (char *)this)
      {
        v11 = __src;
        v12 = this;
        if ((char *)this + v10 > __src)
          goto LABEL_38;
      }
      if (v10 >= 0x20)
      {
        v13 = v10 & 0xFFFFFFFFFFFFFFE0;
        v30 = (__int128 *)((char *)this + 16);
        v31 = __src + 16;
        v32 = v10 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          v33 = *(v30 - 1);
          v34 = *v30;
          v35 = *(_OWORD *)v31;
          *(v30 - 1) = *((_OWORD *)v31 - 1);
          *v30 = v35;
          *((_OWORD *)v31 - 1) = v33;
          *(_OWORD *)v31 = v34;
          v30 += 2;
          v31 += 32;
          v32 -= 32;
        }
        while (v32);
        if (v10 == v13)
          goto LABEL_42;
        if ((v10 & 0x18) == 0)
        {
          v12 = (llvm::hashing::detail::hash_combine_recursive_helper *)((char *)this + v13);
          v11 = &__src[v13];
          goto LABEL_38;
        }
      }
      else
      {
        v13 = 0;
      }
      v11 = &__src[v10 & 0xFFFFFFFFFFFFFFF8];
      v12 = (llvm::hashing::detail::hash_combine_recursive_helper *)((char *)this + (v10 & 0xFFFFFFFFFFFFFFF8));
      v36 = (uint64_t *)((char *)this + v13);
      v37 = &__src[v13];
      v38 = v13 - (v10 & 0xFFFFFFFFFFFFFFF8);
      do
      {
        v39 = *v36;
        *v36++ = *(_QWORD *)v37;
        *(_QWORD *)v37 = v39;
        v37 += 8;
        v38 += 8;
      }
      while (v38);
      if (v10 == (v10 & 0xFFFFFFFFFFFFFFF8))
        goto LABEL_42;
LABEL_38:
      v40 = v11 + 1;
      v41 = (char *)v12 + 1;
      do
      {
        v42 = *(v41 - 1);
        *(v41 - 1) = *(v40 - 1);
        *(v40 - 1) = v42;
        if (v41 == __src)
          break;
        ++v41;
      }
      while (v40++ != a4);
      goto LABEL_42;
    }
    v15 = *(_BYTE *)this;
    v16 = a4 - __src;
    memmove(this, __src, a4 - __src);
    *((_BYTE *)this + v16) = v15;
  }
LABEL_42:
  v44 = *((_QWORD *)this + 9);
  v45 = *((_QWORD *)this + 11);
  v46 = *((_QWORD *)this + 1);
  v47 = *((_QWORD *)this + 12);
  v48 = *((_QWORD *)this + 13);
  v50 = *((_QWORD *)this + 6);
  v49 = *((_QWORD *)this + 7);
  v51 = *((_QWORD *)this + 14);
  v52 = v51 ^ (0xB492B66FBE98F273 * __ROR8__(v44 + *((_QWORD *)this + 8) + v45 + v46, 37));
  v53 = v45 - 0x4B6D499041670D8DLL * __ROR8__(v47 + v44 + v50, 42);
  v54 = v48 + *((_QWORD *)this + 10);
  v55 = *(_QWORD *)this - 0x4B6D499041670D8DLL * v47;
  v56 = v55 + v48;
  v58 = *((_QWORD *)this + 2);
  v57 = *((_QWORD *)this + 3);
  v59 = v55 + v46 + v58;
  v60 = *((_QWORD *)this + 5);
  v61 = v53 + v60;
  v62 = __ROR8__(v54, 33);
  v63 = __ROR8__(v56 + v57 + v52, 21) + v55 + __ROR8__(v59, 44);
  v64 = v59 + v57;
  v65 = v58 + v61;
  v66 = *((_QWORD *)this + 4) + v51 - 0x4B6D499041670D8DLL * v62;
  v67 = v60 + v50 + v66;
  v68 = __ROR8__(v66 + v49 + v65, 21) + v66 + __ROR8__(v67, 44);
  *((_QWORD *)this + 11) = v64;
  *((_QWORD *)this + 12) = v63;
  *((_QWORD *)this + 13) = v67 + v49;
  *((_QWORD *)this + 14) = v68;
  *((_QWORD *)this + 9) = v61;
  *((_QWORD *)this + 10) = v52;
  *((_QWORD *)this + 8) = 0xB492B66FBE98F273 * v62;
  v69 = v52
      - 0x4B6D499041670D8DLL * (v61 ^ (v61 >> 47))
      - 0x622015F714C7D297
      * ((0x9DDFEA08EB382D69
        * ((v67 + v49) ^ ((0x9DDFEA08EB382D69 * ((v67 + v49) ^ v64)) >> 47) ^ (0x9DDFEA08EB382D69
                                                                               * ((v67 + v49) ^ v64)))) ^ ((0x9DDFEA08EB382D69 * ((v67 + v49) ^ ((0x9DDFEA08EB382D69 * ((v67 + v49) ^ v64)) >> 47) ^ (0x9DDFEA08EB382D69 * ((v67 + v49) ^ v64)))) >> 47));
  v70 = 0x9DDFEA08EB382D69
      * (v68 ^ ((0x9DDFEA08EB382D69 * (v68 ^ v63)) >> 47) ^ (0x9DDFEA08EB382D69 * (v68 ^ v63)));
  v71 = 0xB492B66FBE98F273
      * (v62 + ((__src - (char *)this + a2) ^ ((unint64_t)(__src - (char *)this + a2) >> 47)))
      - 0x622015F714C7D297 * (v70 ^ (v70 >> 47));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69
         * (v71 ^ ((0x9DDFEA08EB382D69 * (v71 ^ v69)) >> 47) ^ (0x9DDFEA08EB382D69 * (v71 ^ v69)))) ^ ((0x9DDFEA08EB382D69 * (v71 ^ ((0x9DDFEA08EB382D69 * (v71 ^ v69)) >> 47) ^ (0x9DDFEA08EB382D69 * (v71 ^ v69)))) >> 47));
}

uint64_t mlir::AsmParser::parseType<mlir::BaseMemRefType>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v8;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  uint64_t v20;
  _QWORD v21[3];
  void *v22;
  uint64_t v23;
  void *v24;
  _QWORD *v25;
  void *__p;
  _QWORD *v27;
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v20 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 504))(a1, &v20))
    return 0;
  v5 = v20;
  v6 = *(void **)(*(_QWORD *)v20 + 136);
  if (v6 != &mlir::detail::TypeIDResolver<mlir::UnrankedMemRefType,void>::id
    && v6 != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
  {
    v5 = 0;
  }
  *a2 = v5;
  if (v5)
    return 1;
  v18 = "invalid kind of type specified";
  v19 = 259;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v21, a1, v4, &v18);
  v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v21);
  if (v21[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v21);
  if (v28)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v27;
      v12 = __p;
      if (v27 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v27 = v10;
      operator delete(v12);
    }
    v13 = v24;
    if (v24)
    {
      v14 = v25;
      v15 = v24;
      if (v25 != v24)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v24;
      }
      v25 = v13;
      operator delete(v15);
    }
    if (v22 != &v23)
      free(v22);
  }
  return v8;
}

uint64_t llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::OperandRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &,mlir::OpAsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13;
  uint64_t *i;
  uint64_t v15;
  llvm::raw_ostream *v16;
  const char *v17;
  unint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  llvm::raw_ostream *v23;
  const char *v24;
  unint64_t v25;
  void *v26;

  v13 = result;
  if (result != a3 || a2 != a4)
  {
    result = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)a5 + 32))(a5, *(_QWORD *)(*(_QWORD *)(result + 32 * a2 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (v13 != a3 || a2 + 1 != a4)
    {
      if (v13 != a3)
      {
        for (i = (uint64_t *)(v13 + 32 * a2 + 56); ; i += 4)
        {
          v16 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a6 + 16))(a6);
          v17 = *(const char **)a7;
          v18 = *(_QWORD *)(a7 + 8);
          v19 = (void *)*((_QWORD *)v16 + 4);
          if (v18 > *((_QWORD *)v16 + 3) - (_QWORD)v19)
          {
            llvm::raw_ostream::write(v16, v17, *(_QWORD *)(a7 + 8));
          }
          else if (v18)
          {
            memcpy(v19, v17, *(_QWORD *)(a7 + 8));
            *((_QWORD *)v16 + 4) += v18;
          }
          v15 = *i;
          (*(void (**)(uint64_t, unint64_t))(*(_QWORD *)a5 + 32))(a5, *(_QWORD *)(v15 + 8) & 0xFFFFFFFFFFFFFFF8);
        }
      }
      v20 = ~a2 + a4;
      v21 = (uint64_t *)(v13 + 32 * a2 + 56);
      do
      {
        v23 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a6 + 16))(a6);
        v24 = *(const char **)a7;
        v25 = *(_QWORD *)(a7 + 8);
        v26 = (void *)*((_QWORD *)v23 + 4);
        if (v25 > *((_QWORD *)v23 + 3) - (_QWORD)v26)
        {
          llvm::raw_ostream::write(v23, v24, *(_QWORD *)(a7 + 8));
        }
        else if (v25)
        {
          memcpy(v26, v24, *(_QWORD *)(a7 + 8));
          *((_QWORD *)v23 + 4) += v25;
        }
        v22 = *v21;
        v21 += 4;
        result = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)a5 + 32))(a5, *(_QWORD *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8);
        --v20;
      }
      while (v20);
    }
  }
  return result;
}

llvm::raw_ostream *mlir::AsmPrinter::printArrowTypeList<mlir::ValueTypeRange<mlir::ResultRange> &>(uint64_t a1, uint64_t *a2)
{
  llvm::raw_ostream *v4;
  llvm::raw_ostream *v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;
  const char *v14;
  uint64_t v15;

  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v5 = v4;
  v6 = (_DWORD *)*((_QWORD *)v4 + 4);
  if (*((_QWORD *)v4 + 3) - (_QWORD)v6 <= 3uLL)
  {
    v5 = llvm::raw_ostream::write(v4, " -> ", 4uLL);
    v7 = *a2;
    v8 = a2[1];
    v10 = a2[2];
    v9 = a2[3];
    if (*a2 != v10)
      goto LABEL_8;
LABEL_5:
    if (v8 == v9)
      goto LABEL_6;
    goto LABEL_8;
  }
  *v6 = 540945696;
  *((_QWORD *)v4 + 4) += 4;
  v7 = *a2;
  v8 = a2[1];
  v10 = a2[2];
  v9 = a2[3];
  if (*a2 == v10)
    goto LABEL_5;
LABEL_8:
  if (v7 == v10
    && v8 + 1 == v9
    && *(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v7, v8) + 8) & 0xFFFFFFFFFFFFFFF8)
                    + 136) != &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
  {
    v14 = ", ";
    v15 = 2;
    return (llvm::raw_ostream *)llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::ResultRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &,mlir::AsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>(*a2, a2[1], a2[2], a2[3], a1, a1, (uint64_t)&v14);
  }
LABEL_6:
  v11 = (_BYTE *)*((_QWORD *)v5 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)v5 + 3))
  {
    llvm::raw_ostream::write(v5, 40);
  }
  else
  {
    *((_QWORD *)v5 + 4) = v11 + 1;
    *v11 = 40;
  }
  v14 = ", ";
  v15 = 2;
  result = (llvm::raw_ostream *)llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::ResultRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &,mlir::AsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>(*a2, a2[1], a2[2], a2[3], a1, a1, (uint64_t)&v14);
  v13 = (_BYTE *)*((_QWORD *)v5 + 4);
  if ((unint64_t)v13 >= *((_QWORD *)v5 + 3))
    return llvm::raw_ostream::write(v5, 41);
  *((_QWORD *)v5 + 4) = v13 + 1;
  *v13 = 41;
  return result;
}

uint64_t llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::ResultRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &,mlir::AsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>(uint64_t this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13;
  uint64_t NextResultAtOffset;
  uint64_t v15;
  uint64_t v16;
  llvm::raw_ostream *v17;
  const char *v18;
  unint64_t v19;
  void *v20;
  uint64_t v21;
  llvm::raw_ostream *v22;
  const char *v23;
  unint64_t v24;
  void *v25;

  v13 = this;
  if (this != a3 || a2 != a4)
  {
    NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(this, a2);
    this = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)a5 + 32))(a5, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
    v15 = a2 + 1;
    if (v13 != a3 || v15 != a4)
    {
      if (v13 != a3)
      {
        while (1)
        {
          v17 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a6 + 16))(a6);
          v18 = *(const char **)a7;
          v19 = *(_QWORD *)(a7 + 8);
          v20 = (void *)*((_QWORD *)v17 + 4);
          if (v19 > *((_QWORD *)v17 + 3) - (_QWORD)v20)
          {
            llvm::raw_ostream::write(v17, v18, *(_QWORD *)(a7 + 8));
          }
          else if (v19)
          {
            memcpy(v20, v18, *(_QWORD *)(a7 + 8));
            *((_QWORD *)v17 + 4) += v19;
          }
          v16 = mlir::detail::OpResultImpl::getNextResultAtOffset(v13, v15);
          (*(void (**)(uint64_t, unint64_t))(*(_QWORD *)a5 + 32))(a5, *(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8);
          ++v15;
        }
      }
      do
      {
        v22 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a6 + 16))(a6);
        v23 = *(const char **)a7;
        v24 = *(_QWORD *)(a7 + 8);
        v25 = (void *)*((_QWORD *)v22 + 4);
        if (v24 > *((_QWORD *)v22 + 3) - (_QWORD)v25)
        {
          llvm::raw_ostream::write(v22, v23, *(_QWORD *)(a7 + 8));
        }
        else if (v24)
        {
          memcpy(v25, v23, *(_QWORD *)(a7 + 8));
          *((_QWORD *)v22 + 4) += v24;
        }
        v21 = mlir::detail::OpResultImpl::getNextResultAtOffset(v13, v15);
        this = (*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)a5 + 32))(a5, *(_QWORD *)(v21 + 8) & 0xFFFFFFFFFFFFFFF8);
        ++v15;
      }
      while (a4 != v15);
    }
  }
  return this;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::bufferization::detail::ToMemrefOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::bufferization::detail::ToMemrefOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::bufferization::detail::ToMemrefOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::bufferization::detail::ToMemrefOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::bufferization::detail::ToTensorOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::bufferization::detail::ToTensorOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::bufferization::detail::ToTensorOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::bufferization::detail::ToTensorOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

uint64_t mlir::InFlightDiagnostic::operator<<<unsigned long>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  uint64_t v8;
  __int128 v9;
  unint64_t v11;
  BOOL v12;
  char *v13;
  int v14;
  uint64_t v15;

  if (*(_QWORD *)a1)
  {
    v3 = a1 + 24;
    v4 = *(_QWORD *)(a1 + 24);
    v5 = *a2;
    v14 = 5;
    v15 = v5;
    v6 = *(unsigned int *)(a1 + 32);
    v7 = &v14;
    if (v6 >= *(_DWORD *)(a1 + 36))
    {
      v11 = v6 + 1;
      v12 = v4 + 24 * v6 > (unint64_t)&v14;
      if (v4 <= (unint64_t)&v14 && v12)
      {
        v13 = (char *)&v14 - v4;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v3, (void *)(a1 + 40), v11, 24);
        v4 = *(_QWORD *)(a1 + 24);
        v7 = (int *)&v13[v4];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v3, (void *)(a1 + 40), v11, 24);
        v4 = *(_QWORD *)(a1 + 24);
        v7 = &v14;
      }
    }
    v8 = v4 + 24 * *(unsigned int *)(a1 + 32);
    v9 = *(_OWORD *)v7;
    *(_QWORD *)(v8 + 16) = *((_QWORD *)v7 + 2);
    *(_OWORD *)v8 = v9;
    ++*(_DWORD *)(a1 + 32);
  }
  return a1;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::IntegerAttr]";
  v41 = 67;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::IntegerAttr]";
  v41 = 67;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

unint64_t llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code>(_QWORD *a1, uint64_t *a2, uint64_t *a3)
{
  unsigned __int8 v4;
  uint64_t v5;
  char *v6;
  char *v7;
  int v9;
  unint64_t v10;
  uint64_t *v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t v14;
  _OWORD v15[4];
  _OWORD v16[3];
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v17 = 0;
  memset(v16, 0, sizeof(v16));
  memset(v15, 0, sizeof(v15));
  if ((v4 & 1) == 0)
  {
    v11 = a2;
    v12 = a1;
    a2 = v11;
    a1 = v12;
    if (v9)
    {
      v10 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v10 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v10;
      a2 = v11;
      a1 = v12;
    }
  }
  v5 = *a1;
  v18 = llvm::hashing::detail::get_execution_seed(void)::seed;
  *(_QWORD *)&v15[0] = v5;
  v13 = 0;
  v6 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v15, (uint64_t *)&v13, (_QWORD *)v15 + 1, (unint64_t)v16, *a2);
  v14 = v13;
  v7 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v15, (uint64_t *)&v14, v6, (unint64_t)v16, *a3);
  return llvm::hashing::detail::hash_combine_recursive_helper::combine((llvm::hashing::detail::hash_combine_recursive_helper *)v15, v14, v7, (char *)v16);
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::AffineMapAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::AffineMapAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::AffineMapAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::AffineMapAttr]";
  v41 = 69;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::AsmParser::parseOptionalInteger<long long>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unsigned __int16 v5;
  unsigned __int8 v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  _QWORD *v13;
  unint64_t v14;
  BOOL v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  const char *v25;
  __int16 v26;
  _QWORD *v27;
  unsigned int v28;
  _QWORD *v29;
  unsigned int v30;
  void *v31;
  uint64_t v32;
  void *v33;
  _QWORD *v34;
  void *__p;
  _QWORD *v36;
  char v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v28 = 1;
  v27 = 0;
  v5 = (*(uint64_t (**)(uint64_t, _QWORD **))(*(_QWORD *)a1 + 352))(a1, &v27);
  if (v5 < 0x100u || v5 == 0)
  {
    v7 = v5;
    v8 = HIBYTE(v5);
    if (v28 < 0x41)
      return v7 | (v8 << 8);
    goto LABEL_46;
  }
  llvm::APInt::sextOrTrunc((char *)&v27, 0x40u, (uint64_t)&v29);
  v9 = v30;
  if (v30 >= 0x41)
  {
    v12 = v9 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v29);
    v13 = v29;
    if (v12 <= 0x40)
    {
      *a2 = *v29;
    }
    else
    {
      v10 = -1;
      *a2 = -1;
      if (!v13)
      {
        v11 = v28;
        v30 = v28;
        if (v28 > 0x40)
          goto LABEL_20;
        goto LABEL_14;
      }
    }
    MEMORY[0x20BD002D4]();
    v10 = *a2;
    v11 = v28;
    v30 = v28;
    if (v28 > 0x40)
      goto LABEL_20;
LABEL_14:
    if (v11)
      v14 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v11;
    else
      v14 = 0;
    v29 = (_QWORD *)(v14 & v10);
LABEL_21:
    if (v29 == v27)
      goto LABEL_22;
    goto LABEL_27;
  }
  v10 = (uint64_t)v29;
  *a2 = (uint64_t)v29;
  v11 = v28;
  v30 = v28;
  if (v28 <= 0x40)
    goto LABEL_14;
LABEL_20:
  llvm::APInt::initSlowCase((llvm::APInt *)&v29, v10, 0);
  if (v30 <= 0x40)
    goto LABEL_21;
  v15 = llvm::APInt::equalSlowCase((const void **)&v29, (const void **)&v27);
  if (v29)
    MEMORY[0x20BD002D4](v29, 0x1000C8000313F17);
  if (v15)
  {
LABEL_22:
    v7 = 1;
    v8 = 1;
    if (v28 < 0x41)
      return v7 | (v8 << 8);
    goto LABEL_46;
  }
LABEL_27:
  v25 = "integer value too large";
  v26 = 259;
  (*(void (**)(_QWORD **__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(&v29, a1, v4, &v25);
  if (v29)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v29);
  if (v37)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v36;
      v18 = __p;
      if (v36 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v36 = v16;
      operator delete(v18);
    }
    v19 = v33;
    if (v33)
    {
      v20 = v34;
      v21 = v33;
      if (v34 != v33)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v33;
      }
      v34 = v19;
      operator delete(v21);
    }
    if (v31 != &v32)
      free(v31);
  }
  v7 = 0;
  v8 = 1;
  if (v28 >= 0x41)
  {
LABEL_46:
    if (v27)
      MEMORY[0x20BD002D4](v27, 0x1000C8000313F17);
  }
  return v7 | (v8 << 8);
}

char *llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(_QWORD *a1, uint64_t *a2, _QWORD *__dst, unint64_t a4, uint64_t a5)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  size_t v30;
  char *v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  uint64_t __src;

  __src = a5;
  if ((unint64_t)(__dst + 1) <= a4)
  {
    *__dst = a5;
    return (char *)(__dst + 1);
  }
  else
  {
    v8 = a4 - (_QWORD)__dst;
    memcpy(__dst, &__src, a4 - (_QWORD)__dst);
    v9 = *a2;
    if (*a2)
    {
      v10 = a1[9];
      v11 = a1[11];
      v12 = a1[1];
      v13 = a1[12];
      v14 = a1[13];
      v16 = a1[6];
      v15 = a1[7];
      v17 = a1[14];
      v18 = v17 ^ (0xB492B66FBE98F273 * __ROR8__(v10 + a1[8] + v11 + v12, 37));
      v19 = v11 - 0x4B6D499041670D8DLL * __ROR8__(v13 + v10 + v16, 42);
      v20 = 0xB492B66FBE98F273 * __ROR8__(v14 + a1[10], 33);
      v21 = *a1 - 0x4B6D499041670D8DLL * v13;
      v22 = v21 + v14;
      v24 = a1[2];
      v23 = a1[3];
      v25 = a1[5];
      v26 = v19 + v25;
      v27 = a1[4] + v17 + v20;
      v28 = v21 + v12 + v24;
      v29 = v25 + v16 + v27;
      a1[12] = __ROR8__(v22 + v23 + v18, 21) + v21 + __ROR8__(v28, 44);
      a1[13] = v29 + v15;
      a1[14] = __ROR8__(v27 + v15 + v24 + v26, 21) + v27 + __ROR8__(v29, 44);
      a1[10] = v18;
      a1[11] = v28 + v23;
      a1[8] = v20;
      a1[9] = v26;
      *a2 = v9 + 64;
      v30 = 8 - v8;
      v31 = (char *)a1 + 8 - v8;
      if ((unint64_t)v31 > a4)
        return (char *)a1;
      goto LABEL_7;
    }
    v32 = a1[15];
    v33 = __ROR8__(v32 ^ 0xB492B66FBE98F273, 49);
    v34 = v32 ^ (v32 >> 47);
    v35 = a1[1];
    v36 = v35 + v32 + v33;
    v37 = a1[6];
    v38 = a1[7];
    v39 = a1[5];
    v40 = v39 + v33 - 0x4B6D499041670D8DLL * __ROR8__(v37 + v32 - 0x4B6D499041670D8DLL * v32, 42);
    v41 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v32 ^ 0xB492B66FBE98F273)) ^ ((0x9DDFEA08EB382D69 * (v32 ^ 0xB492B66FBE98F273)) >> 47) ^ 0xB492B66FBE98F273);
    v42 = 0x9DDFEA08EB382D69
        * (v32 ^ (((0x9DDFEA08EB382D69 * (v34 ^ (0xB492B66FBE98F273 * v32))) ^ v32) >> 47) ^ (0x9DDFEA08EB382D69
                                                                                                * (v34 ^ (0xB492B66FBE98F273 * v32))));
    v43 = 0x9DDFEA08EB382D69 * (v42 ^ (v42 >> 47));
    v44 = 0xB492B66FBE98F273 * __ROR8__(v34 - 0x622015F714C7D297 * (v41 ^ (v41 >> 47)), 33);
    v45 = *a1 - 0x6D8ED9027DD26057 * v32;
    v47 = a1[2];
    v46 = a1[3];
    v48 = v45 + v35 + v47;
    v49 = v43 ^ (0xB492B66FBE98F273 * __ROR8__(v36, 37));
    v50 = v44 + a1[4] + v43;
    a1[8] = v44;
    a1[9] = v40;
    a1[10] = v49;
    a1[11] = v48 + v46;
    a1[12] = __ROR8__(v48, 44) + v45 + __ROR8__(v45 + v34 + v46 + v49, 21);
    a1[13] = v39 + v37 + v50 + v38;
    a1[14] = __ROR8__(v39 + v37 + v50, 44) + v50 + __ROR8__(v40 + v47 + v38 + v50, 21);
    *a2 = 64;
    v30 = 8 - v8;
    v31 = (char *)a1 + 8 - v8;
    if ((unint64_t)v31 <= a4)
    {
LABEL_7:
      memcpy(a1, (char *)&__src + v8, v30);
      return v31;
    }
  }
  return (char *)a1;
}

char *llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned int>(_QWORD *a1, uint64_t *a2, _DWORD *__dst, unint64_t a4, int a5)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  size_t v30;
  char *v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int __src;

  __src = a5;
  if ((unint64_t)(__dst + 1) <= a4)
  {
    *__dst = a5;
    return (char *)(__dst + 1);
  }
  else
  {
    v8 = a4 - (_QWORD)__dst;
    memcpy(__dst, &__src, a4 - (_QWORD)__dst);
    v9 = *a2;
    if (*a2)
    {
      v10 = a1[9];
      v11 = a1[11];
      v12 = a1[1];
      v13 = a1[12];
      v14 = a1[13];
      v16 = a1[6];
      v15 = a1[7];
      v17 = a1[14];
      v18 = v17 ^ (0xB492B66FBE98F273 * __ROR8__(v10 + a1[8] + v11 + v12, 37));
      v19 = v11 - 0x4B6D499041670D8DLL * __ROR8__(v13 + v10 + v16, 42);
      v20 = 0xB492B66FBE98F273 * __ROR8__(v14 + a1[10], 33);
      v21 = *a1 - 0x4B6D499041670D8DLL * v13;
      v22 = v21 + v14;
      v24 = a1[2];
      v23 = a1[3];
      v25 = a1[5];
      v26 = v19 + v25;
      v27 = a1[4] + v17 + v20;
      v28 = v21 + v12 + v24;
      v29 = v25 + v16 + v27;
      a1[12] = __ROR8__(v22 + v23 + v18, 21) + v21 + __ROR8__(v28, 44);
      a1[13] = v29 + v15;
      a1[14] = __ROR8__(v27 + v15 + v24 + v26, 21) + v27 + __ROR8__(v29, 44);
      a1[10] = v18;
      a1[11] = v28 + v23;
      a1[8] = v20;
      a1[9] = v26;
      *a2 = v9 + 64;
      v30 = 4 - v8;
      v31 = (char *)a1 + 4 - v8;
      if ((unint64_t)v31 > a4)
        return (char *)a1;
      goto LABEL_7;
    }
    v32 = a1[15];
    v33 = __ROR8__(v32 ^ 0xB492B66FBE98F273, 49);
    v34 = v32 ^ (v32 >> 47);
    v35 = a1[1];
    v36 = v35 + v32 + v33;
    v37 = a1[6];
    v38 = a1[7];
    v39 = a1[5];
    v40 = v39 + v33 - 0x4B6D499041670D8DLL * __ROR8__(v37 + v32 - 0x4B6D499041670D8DLL * v32, 42);
    v41 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v32 ^ 0xB492B66FBE98F273)) ^ ((0x9DDFEA08EB382D69 * (v32 ^ 0xB492B66FBE98F273)) >> 47) ^ 0xB492B66FBE98F273);
    v42 = 0x9DDFEA08EB382D69
        * (v32 ^ (((0x9DDFEA08EB382D69 * (v34 ^ (0xB492B66FBE98F273 * v32))) ^ v32) >> 47) ^ (0x9DDFEA08EB382D69
                                                                                                * (v34 ^ (0xB492B66FBE98F273 * v32))));
    v43 = 0x9DDFEA08EB382D69 * (v42 ^ (v42 >> 47));
    v44 = 0xB492B66FBE98F273 * __ROR8__(v34 - 0x622015F714C7D297 * (v41 ^ (v41 >> 47)), 33);
    v45 = *a1 - 0x6D8ED9027DD26057 * v32;
    v47 = a1[2];
    v46 = a1[3];
    v48 = v45 + v35 + v47;
    v49 = v43 ^ (0xB492B66FBE98F273 * __ROR8__(v36, 37));
    v50 = v44 + a1[4] + v43;
    a1[8] = v44;
    a1[9] = v40;
    a1[10] = v49;
    a1[11] = v48 + v46;
    a1[12] = __ROR8__(v48, 44) + v45 + __ROR8__(v45 + v34 + v46 + v49, 21);
    a1[13] = v39 + v37 + v50 + v38;
    a1[14] = __ROR8__(v39 + v37 + v50, 44) + v50 + __ROR8__(v40 + v47 + v38 + v50, 21);
    *a2 = 64;
    v30 = 4 - v8;
    v31 = (char *)a1 + 4 - v8;
    if ((unint64_t)v31 <= a4)
    {
LABEL_7:
      memcpy(a1, (char *)&__src + v8, v30);
      return v31;
    }
  }
  return (char *)a1;
}

uint64_t llvm::BumpPtrAllocatorImpl<llvm::MallocAllocator,4096ul,4096ul,128ul>::Allocate(uint64_t *__sz, uint64_t a2, char a3)
{
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t result;
  unsigned int v17;
  uint64_t v18;
  char *buffer;
  uint64_t v20;

  v5 = __sz + 10;
  __sz[10] += a2;
  v6 = (1 << a3) - 1;
  v7 = *__sz;
  v8 = -(1 << a3);
  v9 = ((v6 + *__sz) & v8) - *__sz;
  if (*__sz)
    v10 = v9 + a2 > (unint64_t)(__sz[1] - *__sz);
  else
    v10 = 1;
  if (v10)
  {
    v11 = a2 + (1 << a3);
    v12 = v11 - 1;
    if ((unint64_t)(v11 - 1) <= 0x1000)
    {
      v17 = *((_DWORD *)__sz + 6) >> 7;
      if (v17 >= 0x1E)
        LOBYTE(v17) = 30;
      v18 = 4096 << v17;
      buffer = (char *)llvm::allocate_buffer(4096 << v17, (std::align_val_t)8uLL);
      v20 = *((unsigned int *)__sz + 6);
      if (v20 >= *((_DWORD *)__sz + 7))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(__sz + 2), __sz + 4, v20 + 1, 8);
        LODWORD(v20) = *((_DWORD *)__sz + 6);
      }
      *(_QWORD *)(__sz[2] + 8 * v20) = buffer;
      ++*((_DWORD *)__sz + 6);
      result = (unint64_t)&buffer[v6] & v8;
      *__sz = result + a2;
      __sz[1] = (uint64_t)&buffer[v18];
    }
    else
    {
      v13 = llvm::allocate_buffer(v11 - 1, (std::align_val_t)8uLL);
      v14 = *((unsigned int *)__sz + 18);
      if (v14 >= *((_DWORD *)__sz + 19))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(__sz + 8), v5, v14 + 1, 16);
        LODWORD(v14) = *((_DWORD *)__sz + 18);
      }
      v15 = (_QWORD *)(__sz[8] + 16 * v14);
      *v15 = v13;
      v15[1] = v12;
      ++*((_DWORD *)__sz + 18);
      return ((unint64_t)v13 + v6) & v8;
    }
  }
  else
  {
    result = v7 + v9;
    *__sz = v7 + v9 + a2;
  }
  return result;
}

uint64_t mlir::InFlightDiagnostic::append<char const*&>(uint64_t a1, const char **a2)
{
  const char *v3;
  size_t v4;
  uint64_t v5;
  unint64_t v6;
  int *v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v11;
  unint64_t v12;
  BOOL v13;
  char *v14;
  int v15;
  const char *v16;
  size_t v17;

  if (*(_QWORD *)a1)
  {
    v3 = *a2;
    if (*a2)
      v4 = strlen(*a2);
    else
      v4 = 0;
    v15 = 3;
    v16 = v3;
    v17 = v4;
    v5 = *(unsigned int *)(a1 + 32);
    v6 = *(_QWORD *)(a1 + 24);
    v7 = &v15;
    if (v5 >= *(_DWORD *)(a1 + 36))
    {
      v11 = a1 + 24;
      v12 = v5 + 1;
      v13 = v6 + 24 * v5 > (unint64_t)&v15;
      if (v6 <= (unint64_t)&v15 && v13)
      {
        v14 = (char *)&v15 - v6;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v11, (void *)(a1 + 40), v12, 24);
        v6 = *(_QWORD *)(a1 + 24);
        v7 = (int *)&v14[v6];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v11, (void *)(a1 + 40), v12, 24);
        v6 = *(_QWORD *)(a1 + 24);
        v7 = &v15;
      }
    }
    v8 = v6 + 24 * *(unsigned int *)(a1 + 32);
    v9 = *(_OWORD *)v7;
    *(_QWORD *)(v8 + 16) = *((_QWORD *)v7 + 2);
    *(_OWORD *)v8 = v9;
    ++*(_DWORD *)(a1 + 32);
  }
  return a1;
}

BOOL mlir::ValueTypeRange<mlir::OperandRange>::operator==<mlir::ValueTypeRange<mlir::ResultRange>>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  _BOOL8 result;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t NextResultAtOffset;

  v2 = a1[1];
  v3 = a1[3];
  v4 = a2[1];
  if (v3 - v2 != a2[3] - v4)
    return 0;
  v5 = *a1;
  v6 = *a2;
  v7 = *a1 == a1[2];
  if (v3 == v2 && *a1 == a1[2])
    return 1;
  v9 = *(_QWORD *)(*(_QWORD *)(v5 + 32 * v2 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v10 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(*a2, a2[1]) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (!v7)
  {
    if (v9 == v10)
    {
      v17 = v4 + 1;
      v18 = (uint64_t *)(v5 + 32 * v2 + 56);
      do
      {
        v19 = *v18;
        v18 += 4;
        v20 = *(_QWORD *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8;
        NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, v17++);
      }
      while (v20 == (*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
    }
    return 0;
  }
  if (v9 != v10)
    return 0;
  v11 = v4 + 1;
  v12 = (uint64_t *)(v5 + 32 * v2 + 56);
  v13 = ~v2 + v3;
  do
  {
    result = v13 == 0;
    if (!v13)
      break;
    v14 = *v12;
    v12 += 4;
    v15 = *(_QWORD *)(v14 + 8) & 0xFFFFFFFFFFFFFFF8;
    v16 = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, v11);
    result = 0;
    ++v11;
    --v13;
  }
  while (v15 == (*(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
  return result;
}

uint64_t mlir::OpAsmDialectInterface::getAlias()
{
  return 0;
}

{
  return 0;
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  const char *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  const char *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  const char *v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  const char *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  const char *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  const char *v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  const char *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  const char *v185;
  unint64_t v186;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v175 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v41 = v40;
    a1 = v175;
    if (v41)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v186 = 83;
      v42 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v42)
        v43 = v42;
      else
        v43 = v186;
      v44 = &v185[v43];
      v45 = v186 - v43;
      if (v186 - v43 >= 0x12)
        v46 = 18;
      else
        v46 = v186 - v43;
      v47 = v45 - v46;
      if (v47 >= v47 - 1)
        v48 = v47 - 1;
      else
        v48 = v47;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v44[v46], v48);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v175;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v166 = v3;
    v176 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v50 = v49;
    v3 = v166;
    a1 = v176;
    if (v50)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v186 = 81;
      v51 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v51)
        v52 = v51;
      else
        v52 = v186;
      v53 = &v185[v52];
      v54 = v186 - v52;
      if (v186 - v52 >= 0x12)
        v55 = 18;
      else
        v55 = v186 - v52;
      v56 = v54 - v55;
      if (v56 >= v56 - 1)
        v57 = v56 - 1;
      else
        v57 = v56;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v53[v55], v57);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v166;
      a1 = v176;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v167 = v3;
    v177 = a1;
    v158 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v158;
    v59 = v58;
    v3 = v167;
    a1 = v177;
    if (v59)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl<Empty>]";
      v186 = 109;
      v60 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v60)
        v61 = v60;
      else
        v61 = v186;
      v62 = &v185[v61];
      v63 = v186 - v61;
      if (v186 - v61 >= 0x12)
        v64 = 18;
      else
        v64 = v186 - v61;
      v65 = v63 - v64;
      if (v65 >= v65 - 1)
        v66 = v65 - 1;
      else
        v66 = v65;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::IndexType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v62[v64], v66);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v158;
      v3 = v167;
      a1 = v177;
    }
  }
  v9 = v8[435];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v168 = v3;
    v178 = a1;
    v151 = v9;
    v159 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v151;
    v6 = v159;
    v68 = v67;
    v3 = v168;
    a1 = v178;
    if (v68)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v186 = 86;
      v69 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v69)
        v70 = v69;
      else
        v70 = v186;
      v71 = &v185[v70];
      v72 = v186 - v70;
      if (v186 - v70 >= 0x12)
        v73 = 18;
      else
        v73 = v186 - v70;
      v74 = v72 - v73;
      if (v74 >= v74 - 1)
        v75 = v74 - 1;
      else
        v75 = v74;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v71[v73], v75);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v151;
      v6 = v159;
      v3 = v168;
      a1 = v178;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v169 = v3;
    v179 = a1;
    v152 = v9;
    v160 = v6;
    v145 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v145;
    v9 = v152;
    v6 = v160;
    v77 = v76;
    v3 = v169;
    a1 = v179;
    if (v77)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v186 = 82;
      v78 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v78)
        v79 = v78;
      else
        v79 = v186;
      v80 = &v185[v79];
      v81 = v186 - v79;
      if (v186 - v79 >= 0x12)
        v82 = 18;
      else
        v82 = v186 - v79;
      v83 = v81 - v82;
      if (v83 >= v83 - 1)
        v84 = v83 - 1;
      else
        v84 = v83;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v80[v82], v84);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v145;
      v9 = v152;
      v6 = v160;
      v3 = v169;
      a1 = v179;
    }
  }
  v15 = v14[19];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v170 = v3;
    v180 = a1;
    v153 = v9;
    v161 = v6;
    v140 = v15;
    v146 = v12;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v140;
    v12 = v146;
    v9 = v153;
    v6 = v161;
    v86 = v85;
    v3 = v170;
    a1 = v180;
    if (v86)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v186 = 84;
      v87 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v87)
        v88 = v87;
      else
        v88 = v186;
      v89 = &v185[v88];
      v90 = v186 - v88;
      if (v186 - v88 >= 0x12)
        v91 = 18;
      else
        v91 = v186 - v88;
      v92 = v90 - v91;
      if (v92 >= v92 - 1)
        v93 = v92 - 1;
      else
        v93 = v92;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v89[v91], v93);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v140;
      v12 = v146;
      v9 = v153;
      v6 = v161;
      v3 = v170;
      a1 = v180;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v171 = v3;
    v181 = a1;
    v154 = v9;
    v162 = v6;
    v141 = v15;
    v147 = v12;
    v136 = v18;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v136;
    v15 = v141;
    v12 = v147;
    v9 = v154;
    v6 = v162;
    v95 = v94;
    v3 = v171;
    a1 = v181;
    if (v95)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v186 = 95;
      v96 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v96)
        v97 = v96;
      else
        v97 = v186;
      v98 = &v185[v97];
      v99 = v186 - v97;
      if (v186 - v97 >= 0x12)
        v100 = 18;
      else
        v100 = v186 - v97;
      v101 = v99 - v100;
      if (v101 >= v101 - 1)
        v102 = v101 - 1;
      else
        v102 = v101;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v98[v100], v102);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v136;
      v15 = v141;
      v12 = v147;
      v9 = v154;
      v6 = v162;
      v3 = v171;
      a1 = v181;
    }
  }
  v21 = v20[312];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v172 = v3;
    v182 = a1;
    v155 = v9;
    v163 = v6;
    v142 = v15;
    v148 = v12;
    v133 = v21;
    v137 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v133;
    v18 = v137;
    v15 = v142;
    v12 = v148;
    v9 = v155;
    v6 = v163;
    v104 = v103;
    v3 = v172;
    a1 = v182;
    if (v104)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v186 = 99;
      v105 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v105)
        v106 = v105;
      else
        v106 = v186;
      v107 = &v185[v106];
      v108 = v186 - v106;
      if (v186 - v106 >= 0x12)
        v109 = 18;
      else
        v109 = v186 - v106;
      v110 = v108 - v109;
      if (v110 >= v110 - 1)
        v111 = v110 - 1;
      else
        v111 = v110;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v107[v109], v111);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v133;
      v18 = v137;
      v15 = v142;
      v12 = v148;
      v9 = v155;
      v6 = v163;
      v3 = v172;
      a1 = v182;
    }
  }
  v24 = v23[314];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v173 = v3;
    v183 = a1;
    v156 = v9;
    v164 = v6;
    v143 = v15;
    v149 = v12;
    v134 = v21;
    v138 = v18;
    v131 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v131;
    v21 = v134;
    v18 = v138;
    v15 = v143;
    v12 = v149;
    v9 = v156;
    v6 = v164;
    v113 = v112;
    v3 = v173;
    a1 = v183;
    if (v113)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v186 = 93;
      v114 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v114)
        v115 = v114;
      else
        v115 = v186;
      v116 = &v185[v115];
      v117 = v186 - v115;
      if (v186 - v115 >= 0x12)
        v118 = 18;
      else
        v118 = v186 - v115;
      v119 = v117 - v118;
      if (v119 >= v119 - 1)
        v120 = v119 - 1;
      else
        v120 = v119;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v116[v118], v120);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v131;
      v21 = v134;
      v18 = v138;
      v15 = v143;
      v12 = v149;
      v9 = v156;
      v6 = v164;
      v3 = v173;
      a1 = v183;
    }
  }
  v27 = v26[21];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v174 = v3;
    v184 = a1;
    v157 = v9;
    v165 = v6;
    v144 = v15;
    v150 = v12;
    v135 = v21;
    v139 = v18;
    v130 = v27;
    v132 = v24;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v130;
    v24 = v132;
    v21 = v135;
    v18 = v139;
    v15 = v144;
    v12 = v150;
    v9 = v157;
    v6 = v165;
    v122 = v121;
    v3 = v174;
    a1 = v184;
    if (v122)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v186 = 90;
      v123 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v123)
        v124 = v123;
      else
        v124 = v186;
      v125 = &v185[v124];
      v126 = v186 - v124;
      if (v186 - v124 >= 0x12)
        v127 = 18;
      else
        v127 = v186 - v124;
      v128 = v126 - v127;
      if (v128 >= v128 - 1)
        v129 = v128 - 1;
      else
        v129 = v128;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v125[v127], v129);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v130;
      v24 = v132;
      v21 = v135;
      v18 = v139;
      v15 = v144;
      v12 = v150;
      v9 = v157;
      v6 = v165;
      v3 = v174;
      a1 = v184;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v29[27] == a1;
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  int v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  const char *v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  const char *v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unint64_t v56;
  unint64_t v57;
  const char *v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  unint64_t v65;
  unint64_t v66;
  const char *v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  unint64_t v74;
  unint64_t v75;
  const char *v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  unint64_t v83;
  unint64_t v84;
  const char *v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  unint64_t v92;
  unint64_t v93;
  const char *v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  unint64_t v101;
  unint64_t v102;
  const char *v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  unint64_t v110;
  unint64_t v111;
  const char *v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  const char *v162;
  unint64_t v163;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v153 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v37 = v36;
    a1 = v153;
    if (v37)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v163 = 83;
      v38 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v38)
        v39 = v38;
      else
        v39 = v163;
      v40 = &v162[v39];
      v41 = v163 - v39;
      if (v163 - v39 >= 0x12)
        v42 = 18;
      else
        v42 = v163 - v39;
      v43 = v41 - v42;
      if (v43 >= v43 - 1)
        v44 = v43 - 1;
      else
        v44 = v43;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v153;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v145 = v3;
    v154 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v46 = v45;
    v3 = v145;
    a1 = v154;
    if (v46)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v163 = 81;
      v47 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v47)
        v48 = v47;
      else
        v48 = v163;
      v49 = &v162[v48];
      v50 = v163 - v48;
      if (v163 - v48 >= 0x12)
        v51 = 18;
      else
        v51 = v163 - v48;
      v52 = v50 - v51;
      if (v52 >= v52 - 1)
        v53 = v52 - 1;
      else
        v53 = v52;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v145;
      a1 = v154;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v146 = v3;
    v155 = a1;
    v138 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v138;
    v55 = v54;
    v3 = v146;
    a1 = v155;
    if (v55)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v163 = 104;
      v56 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v56)
        v57 = v56;
      else
        v57 = v163;
      v58 = &v162[v57];
      v59 = v163 - v57;
      if (v163 - v57 >= 0x12)
        v60 = 18;
      else
        v60 = v163 - v57;
      v61 = v59 - v60;
      if (v61 >= v61 - 1)
        v62 = v61 - 1;
      else
        v62 = v61;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v138;
      v3 = v146;
      a1 = v155;
    }
  }
  v9 = v8[308];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v147 = v3;
    v156 = a1;
    v132 = v9;
    v139 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v132;
    v6 = v139;
    v64 = v63;
    v3 = v147;
    a1 = v156;
    if (v64)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v163 = 86;
      v65 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v65)
        v66 = v65;
      else
        v66 = v163;
      v67 = &v162[v66];
      v68 = v163 - v66;
      if (v163 - v66 >= 0x12)
        v69 = 18;
      else
        v69 = v163 - v66;
      v70 = v68 - v69;
      if (v70 >= v70 - 1)
        v71 = v70 - 1;
      else
        v71 = v70;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v132;
      v6 = v139;
      v3 = v147;
      a1 = v156;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v148 = v3;
    v157 = a1;
    v133 = v9;
    v140 = v6;
    v127 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v127;
    v9 = v133;
    v6 = v140;
    v73 = v72;
    v3 = v148;
    a1 = v157;
    if (v73)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v163 = 82;
      v74 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v74)
        v75 = v74;
      else
        v75 = v163;
      v76 = &v162[v75];
      v77 = v163 - v75;
      if (v163 - v75 >= 0x12)
        v78 = 18;
      else
        v78 = v163 - v75;
      v79 = v77 - v78;
      if (v79 >= v79 - 1)
        v80 = v79 - 1;
      else
        v80 = v79;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v127;
      v9 = v133;
      v6 = v140;
      v3 = v148;
      a1 = v157;
    }
  }
  v15 = v14[19];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v149 = v3;
    v158 = a1;
    v134 = v9;
    v141 = v6;
    v123 = v15;
    v128 = v12;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v123;
    v12 = v128;
    v9 = v134;
    v6 = v141;
    v82 = v81;
    v3 = v149;
    a1 = v158;
    if (v82)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v163 = 84;
      v83 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v83)
        v84 = v83;
      else
        v84 = v163;
      v85 = &v162[v84];
      v86 = v163 - v84;
      if (v163 - v84 >= 0x12)
        v87 = 18;
      else
        v87 = v163 - v84;
      v88 = v86 - v87;
      if (v88 >= v88 - 1)
        v89 = v88 - 1;
      else
        v89 = v88;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v123;
      v12 = v128;
      v9 = v134;
      v6 = v141;
      v3 = v149;
      a1 = v158;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v150 = v3;
    v159 = a1;
    v135 = v9;
    v142 = v6;
    v124 = v15;
    v129 = v12;
    v120 = v18;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v120;
    v15 = v124;
    v12 = v129;
    v9 = v135;
    v6 = v142;
    v91 = v90;
    v3 = v150;
    a1 = v159;
    if (v91)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v163 = 95;
      v92 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v92)
        v93 = v92;
      else
        v93 = v163;
      v94 = &v162[v93];
      v95 = v163 - v93;
      if (v163 - v93 >= 0x12)
        v96 = 18;
      else
        v96 = v163 - v93;
      v97 = v95 - v96;
      if (v97 >= v97 - 1)
        v98 = v97 - 1;
      else
        v98 = v97;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v120;
      v15 = v124;
      v12 = v129;
      v9 = v135;
      v6 = v142;
      v3 = v150;
      a1 = v159;
    }
  }
  v21 = v20[312];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v151 = v3;
    v160 = a1;
    v136 = v9;
    v143 = v6;
    v125 = v15;
    v130 = v12;
    v118 = v21;
    v121 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v118;
    v18 = v121;
    v15 = v125;
    v12 = v130;
    v9 = v136;
    v6 = v143;
    v100 = v99;
    v3 = v151;
    a1 = v160;
    if (v100)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v163 = 99;
      v101 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v101)
        v102 = v101;
      else
        v102 = v163;
      v103 = &v162[v102];
      v104 = v163 - v102;
      if (v163 - v102 >= 0x12)
        v105 = 18;
      else
        v105 = v163 - v102;
      v106 = v104 - v105;
      if (v106 >= v106 - 1)
        v107 = v106 - 1;
      else
        v107 = v106;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v118;
      v18 = v121;
      v15 = v125;
      v12 = v130;
      v9 = v136;
      v6 = v143;
      v3 = v151;
      a1 = v160;
    }
  }
  v24 = v23[314];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v152 = v3;
    v161 = a1;
    v137 = v9;
    v144 = v6;
    v126 = v15;
    v131 = v12;
    v119 = v21;
    v122 = v18;
    v117 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v117;
    v21 = v119;
    v18 = v122;
    v15 = v126;
    v12 = v131;
    v9 = v137;
    v6 = v144;
    v109 = v108;
    v3 = v152;
    a1 = v161;
    if (v109)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v163 = 93;
      v110 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v110)
        v111 = v110;
      else
        v111 = v163;
      v112 = &v162[v111];
      v113 = v163 - v111;
      if (v163 - v111 >= 0x12)
        v114 = 18;
      else
        v114 = v163 - v111;
      v115 = v113 - v114;
      if (v115 >= v115 - 1)
        v116 = v115 - 1;
      else
        v116 = v115;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v117;
      v21 = v119;
      v18 = v122;
      v15 = v126;
      v12 = v131;
      v9 = v137;
      v6 = v144;
      v3 = v152;
      a1 = v161;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v26[21] == a1;
}

uint64_t mlir::AsmParser::parseType<mlir::MemRefType>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  uint64_t v18;
  _QWORD v19[3];
  void *v20;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  void *__p;
  _QWORD *v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v18 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 504))(a1, &v18))
    return 0;
  v5 = v18;
  if (*(_UNKNOWN **)(*(_QWORD *)v18 + 136) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
    v5 = 0;
  *a2 = v5;
  if (v5)
    return 1;
  v16 = "invalid kind of type specified";
  v17 = 259;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v19, a1, v4, &v16);
  v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
  if (v19[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
  if (v26)
  {
    v8 = __p;
    if (__p)
    {
      v9 = v25;
      v10 = __p;
      if (v25 != __p)
      {
        do
          v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
        while (v9 != v8);
        v10 = __p;
      }
      v25 = v8;
      operator delete(v10);
    }
    v11 = v22;
    if (v22)
    {
      v12 = v23;
      v13 = v22;
      if (v23 != v22)
      {
        do
        {
          v15 = *--v12;
          v14 = v15;
          *v12 = 0;
          if (v15)
            MEMORY[0x20BD002D4](v14, 0x1000C8077774924);
        }
        while (v12 != v11);
        v13 = v22;
      }
      v23 = v11;
      operator delete(v13);
    }
    if (v20 != &v21)
      free(v20);
  }
  return v6;
}

uint64_t mlir::AsmParser::parseType<mlir::RankedTensorType>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  uint64_t v18;
  _QWORD v19[3];
  void *v20;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  void *__p;
  _QWORD *v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v18 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 504))(a1, &v18))
    return 0;
  v5 = v18;
  if (*(_UNKNOWN **)(*(_QWORD *)v18 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    v5 = 0;
  *a2 = v5;
  if (v5)
    return 1;
  v16 = "invalid kind of type specified";
  v17 = 259;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v19, a1, v4, &v16);
  v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
  if (v19[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
  if (v26)
  {
    v8 = __p;
    if (__p)
    {
      v9 = v25;
      v10 = __p;
      if (v25 != __p)
      {
        do
          v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
        while (v9 != v8);
        v10 = __p;
      }
      v25 = v8;
      operator delete(v10);
    }
    v11 = v22;
    if (v22)
    {
      v12 = v23;
      v13 = v22;
      if (v23 != v22)
      {
        do
        {
          v15 = *--v12;
          v14 = v15;
          *v12 = 0;
          if (v15)
            MEMORY[0x20BD002D4](v14, 0x1000C8077774924);
        }
        while (v12 != v11);
        v13 = v22;
      }
      v23 = v11;
      operator delete(v13);
    }
    if (v20 != &v21)
      free(v20);
  }
  return v6;
}

uint64_t llvm::function_ref<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>::callback_fn<mlir::Operation * ()(mlir::OpBuilder &,mlir::Location)>(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  return a1(a2, a3);
}

uint64_t mlir::AsmParser::parseAttribute<mlir::IntegerAttr>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  uint64_t v20;
  _QWORD v21[3];
  void *v22;
  uint64_t v23;
  void *v24;
  _QWORD *v25;
  void *__p;
  _QWORD *v27;
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v20 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *, uint64_t))(*(_QWORD *)a1 + 408))(a1, &v20, a3))
    return 0;
  v7 = v20;
  if (*(_UNKNOWN **)(*(_QWORD *)v20 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    v7 = 0;
  *a2 = v7;
  if (v7)
    return 1;
  v18 = "invalid kind of attribute specified";
  v19 = 259;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v21, a1, v6, &v18);
  v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v21);
  if (v21[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v21);
  if (v28)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v27;
      v12 = __p;
      if (v27 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v27 = v10;
      operator delete(v12);
    }
    v13 = v24;
    if (v24)
    {
      v14 = v25;
      v15 = v24;
      if (v25 != v24)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v24;
      }
      v25 = v13;
      operator delete(v15);
    }
    if (v22 != &v23)
      free(v22);
  }
  return v8;
}

uint64_t mlir::CallOpInterface::resolveCallable(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  mlir::Operation *v5;
  unint64_t v7;

  v4 = (**(uint64_t (***)(void))(a1 + 8))();
  v5 = (mlir::Operation *)(v4 & 0xFFFFFFFFFFFFFFF8);
  v7 = v4 & 0xFFFFFFFFFFFFFFF8 & (v4 << 61 >> 63);
  if (v7)
    return mlir::Value::getDefiningOp((mlir::Value *)&v7);
  if (a2)
    return mlir::SymbolTableCollection::lookupNearestSymbolFrom(a2, *(mlir::SymbolTable **)a1, (uint64_t)v5);
  return mlir::SymbolTable::lookupNearestSymbolFrom(*(mlir::SymbolTable **)a1, v5);
}

uint64_t mlir::CallOpInterface::getArgOperands(mlir::CallOpInterface *this)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*((_QWORD *)this + 1) + 16))(*((_QWORD *)this + 1), *(_QWORD *)this);
}

unint64_t mlir::complex::ConstantOp::fold(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFFFBLL;
}

uint64_t mlir::complex::ConstantOp::getAsmResultNames(_QWORD *a1, uint64_t (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  return a2(a3, *a1 - 16, "cst", 3);
}

BOOL mlir::complex::ConstantOp::isBuildableWith(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t Value;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  if (*(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    v2 = a1;
  else
    v2 = 0;
  v21 = v2;
  if (!v2)
    return 0;
  v3 = *(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id ? a2 : 0;
  v20 = v3;
  if (!v3)
    return 0;
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v21);
  if (v4 != 2)
    return 0;
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v20);
  v6 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v21);
  v7 = *(_QWORD *)v6;
  v8 = *(void **)(**(_QWORD **)v6 + 136);
  if (v8 != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
    v7 = 0;
  v19 = v7;
  if (v8 != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    v9 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v21);
    v10 = *(_QWORD *)v9;
    v11 = *(void **)(**(_QWORD **)v9 + 136);
    if (v11 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      v10 = 0;
    v19 = v10;
    if (v11 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      v12 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v21) + 8);
      v13 = *(void **)(*(_QWORD *)v12 + 136);
      if (v13 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
        v12 = 0;
      v18 = v12;
      if (v13 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        v14 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v19);
        if (v14 == Value)
          return mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v18) == v14;
      }
    }
    return 0;
  }
  v16 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v21) + 8);
  v17 = *(void **)(*(_QWORD *)v16 + 136);
  if (v17 != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
    v16 = 0;
  v18 = v16;
  if (v17 != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id
    || mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v19) != Value)
  {
    return 0;
  }
  return mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v18) == Value;
}

uint64_t mlir::complex::ConstantOp::verify(uint64_t **this)
{
  uint64_t v2;
  uint64_t Value;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  char *v8;
  char *v9;
  __int128 v10;
  uint64_t v11;
  int *v12;
  char *v13;
  char *v14;
  __int128 v15;
  uint64_t v16;
  int *v17;
  char *v18;
  char *v19;
  __int128 v20;
  uint64_t v21;
  int *v22;
  char *v23;
  char *v24;
  __int128 v25;
  uint64_t v26;
  int *v27;
  char *v28;
  char *v29;
  __int128 v30;
  int *v31;
  char *v32;
  char *v33;
  __int128 v34;
  uint64_t v35;
  int *v36;
  char *v37;
  char *v38;
  __int128 v39;
  uint64_t v40;
  _QWORD *v41;
  _QWORD *v42;
  void *v43;
  _QWORD *v44;
  _QWORD *v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  _QWORD *v50;
  void *v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  BOOL v66;
  unint64_t v67;
  BOOL v68;
  unint64_t v69;
  unint64_t v70;
  BOOL v71;
  int64_t v72;
  int64_t v73;
  int64_t v74;
  int64_t v75;
  int64_t v76;
  int64_t v77;
  int64_t v78;
  uint64_t v79;
  uint64_t v80;
  const void **v81[4];
  __int16 v82;
  uint64_t v83;
  int v84;
  const char *v85;
  uint64_t v86;
  _QWORD v87[3];
  void *v88;
  unsigned int v89;
  unsigned int v90;
  _BYTE v91[96];
  void *v92;
  _QWORD *v93;
  void *__p;
  _QWORD *v95;
  char v96;
  uint64_t v97;

  v97 = *MEMORY[0x24BDAC8D0];
  v83 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v83);
  if (v2 == 2)
  {
    v87[0] = *(*this - 1) & 0xFFFFFFFFFFFFFFF8;
    Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v87);
    v4 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v83);
    v5 = *(_QWORD *)v4;
    if (*(_UNKNOWN **)(**(_QWORD **)v4 + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
      v5 = 0;
    v80 = v5;
    v6 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v83) + 8);
    if (*(_UNKNOWN **)(*(_QWORD *)v6 + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
      v6 = 0;
    v79 = v6;
    if (v80 && v6)
    {
      if (Value == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v80)
        && Value == mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v79))
      {
        return 1;
      }
      v82 = 257;
      mlir::OpState::emitOpError(this, v81, (uint64_t)v87);
      if (v87[0])
      {
        v84 = 3;
        v85 = "requires attribute's element types (";
        v86 = 36;
        v7 = &v84;
        v8 = (char *)v88;
        if (v89 >= v90)
        {
          v62 = v89 + 1;
          if (v88 <= &v84 && (char *)v88 + 24 * v89 > (char *)&v84)
          {
            v72 = (char *)&v84 - (_BYTE *)v88;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v62, 24);
            v8 = (char *)v88;
            v7 = (int *)((char *)v88 + v72);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v62, 24);
            v7 = &v84;
            v8 = (char *)v88;
          }
        }
        v9 = &v8[24 * v89];
        v10 = *(_OWORD *)v7;
        *((_QWORD *)v9 + 2) = *((_QWORD *)v7 + 2);
        *(_OWORD *)v9 = v10;
        ++v89;
      }
      v11 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v80);
      if (v87[0])
      {
        v12 = &v84;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v84, v11);
        v13 = (char *)v88;
        if (v89 >= v90)
        {
          v63 = v89 + 1;
          if (v88 <= &v84 && (char *)v88 + 24 * v89 > (char *)&v84)
          {
            v73 = (char *)&v84 - (_BYTE *)v88;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v63, 24);
            v13 = (char *)v88;
            v12 = (int *)((char *)v88 + v73);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v63, 24);
            v12 = &v84;
            v13 = (char *)v88;
          }
        }
        v14 = &v13[24 * v89];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = *((_QWORD *)v12 + 2);
        *(_OWORD *)v14 = v15;
        v16 = ++v89;
        if (v87[0])
        {
          v84 = 3;
          v85 = ", ";
          v86 = 2;
          v17 = &v84;
          v18 = (char *)v88;
          if (v16 >= v90)
          {
            v65 = v16 + 1;
            v66 = (char *)v88 + 24 * v16 > (char *)&v84;
            if (v88 <= &v84 && v66)
            {
              v75 = (char *)&v84 - (_BYTE *)v88;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v65, 24);
              v18 = (char *)v88;
              v17 = (int *)((char *)v88 + v75);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v65, 24);
              v17 = &v84;
              v18 = (char *)v88;
            }
          }
          v19 = &v18[24 * v89];
          v20 = *(_OWORD *)v17;
          *((_QWORD *)v19 + 2) = *((_QWORD *)v17 + 2);
          *(_OWORD *)v19 = v20;
          ++v89;
        }
      }
      v21 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v79);
      if (v87[0])
      {
        v22 = &v84;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v84, v21);
        v23 = (char *)v88;
        if (v89 >= v90)
        {
          v64 = v89 + 1;
          if (v88 <= &v84 && (char *)v88 + 24 * v89 > (char *)&v84)
          {
            v74 = (char *)&v84 - (_BYTE *)v88;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v64, 24);
            v23 = (char *)v88;
            v22 = (int *)((char *)v88 + v74);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v64, 24);
            v22 = &v84;
            v23 = (char *)v88;
          }
        }
        v24 = &v23[24 * v89];
        v25 = *(_OWORD *)v22;
        *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
        *(_OWORD *)v24 = v25;
        v26 = ++v89;
        if (v87[0])
        {
          v84 = 3;
          v85 = ") to match the element type of the op's return type (";
          v86 = 53;
          v27 = &v84;
          v28 = (char *)v88;
          if (v26 >= v90)
          {
            v67 = v26 + 1;
            v68 = (char *)v88 + 24 * v26 > (char *)&v84;
            if (v88 <= &v84 && v68)
            {
              v76 = (char *)&v84 - (_BYTE *)v88;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v67, 24);
              v28 = (char *)v88;
              v27 = (int *)((char *)v88 + v76);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v67, 24);
              v27 = &v84;
              v28 = (char *)v88;
            }
          }
          v29 = &v28[24 * v89];
          v30 = *(_OWORD *)v27;
          *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
          *(_OWORD *)v29 = v30;
          ++v89;
          if (v87[0])
          {
            v31 = &v84;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v84, Value);
            v32 = (char *)v88;
            if (v89 >= v90)
            {
              v69 = v89 + 1;
              if (v88 <= &v84 && (char *)v88 + 24 * v89 > (char *)&v84)
              {
                v77 = (char *)&v84 - (_BYTE *)v88;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v69, 24);
                v32 = (char *)v88;
                v31 = (int *)((char *)v88 + v77);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v69, 24);
                v31 = &v84;
                v32 = (char *)v88;
              }
            }
            v33 = &v32[24 * v89];
            v34 = *(_OWORD *)v31;
            *((_QWORD *)v33 + 2) = *((_QWORD *)v31 + 2);
            *(_OWORD *)v33 = v34;
            v35 = ++v89;
            if (v87[0])
            {
              v84 = 3;
              v85 = ")";
              v86 = 1;
              v36 = &v84;
              v37 = (char *)v88;
              if (v35 >= v90)
              {
                v70 = v35 + 1;
                v71 = (char *)v88 + 24 * v35 > (char *)&v84;
                if (v88 <= &v84 && v71)
                {
                  v78 = (char *)&v84 - (_BYTE *)v88;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v70, 24);
                  v37 = (char *)v88;
                  v36 = (int *)((char *)v88 + v78);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v70, 24);
                  v36 = &v84;
                  v37 = (char *)v88;
                }
              }
              v38 = &v37[24 * v89];
              v39 = *(_OWORD *)v36;
              *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
              *(_OWORD *)v38 = v39;
              ++v89;
            }
          }
        }
      }
      v40 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v87);
      if (v87[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v87);
      if (v96)
      {
        v41 = __p;
        if (__p)
        {
          v42 = v95;
          v43 = __p;
          if (v95 != __p)
          {
            do
              v42 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v42 - 1);
            while (v42 != v41);
            v43 = __p;
          }
          v95 = v41;
          operator delete(v43);
        }
        v44 = v92;
        if (!v92)
          goto LABEL_71;
        v45 = v93;
        v46 = v92;
        if (v93 == v92)
        {
LABEL_70:
          v93 = v44;
          operator delete(v46);
LABEL_71:
          if (v88 != v91)
            free(v88);
          return v40;
        }
        do
        {
          v48 = *--v45;
          v47 = v48;
          *v45 = 0;
          if (v48)
            MEMORY[0x20BD002D4](v47, 0x1000C8077774924);
        }
        while (v45 != v44);
LABEL_69:
        v46 = v92;
        goto LABEL_70;
      }
    }
    else
    {
      v81[0] = (const void **)"requires attribute's elements to be float attributes";
      v82 = 259;
      mlir::OpState::emitOpError(this, v81, (uint64_t)v87);
      v40 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v87);
      if (v87[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v87);
      if (v96)
      {
        v55 = __p;
        if (__p)
        {
          v56 = v95;
          v57 = __p;
          if (v95 != __p)
          {
            do
              v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            v57 = __p;
          }
          v95 = v55;
          operator delete(v57);
        }
        v44 = v92;
        if (!v92)
          goto LABEL_71;
        v58 = v93;
        v46 = v92;
        if (v93 == v92)
          goto LABEL_70;
        do
        {
          v60 = *--v58;
          v59 = v60;
          *v58 = 0;
          if (v60)
            MEMORY[0x20BD002D4](v59, 0x1000C8077774924);
        }
        while (v58 != v44);
        goto LABEL_69;
      }
    }
  }
  else
  {
    v81[0] = (const void **)"requires 'value' to be a complex constant, represented as array of two values";
    v82 = 259;
    mlir::OpState::emitOpError(this, v81, (uint64_t)v87);
    v40 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v87);
    if (v87[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v87);
    if (v96)
    {
      v49 = __p;
      if (__p)
      {
        v50 = v95;
        v51 = __p;
        if (v95 != __p)
        {
          do
            v50 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v50 - 1);
          while (v50 != v49);
          v51 = __p;
        }
        v95 = v49;
        operator delete(v51);
      }
      v44 = v92;
      if (!v92)
        goto LABEL_71;
      v52 = v93;
      v46 = v92;
      if (v93 == v92)
        goto LABEL_70;
      do
      {
        v54 = *--v52;
        v53 = v54;
        *v52 = 0;
        if (v54)
          MEMORY[0x20BD002D4](v53, 0x1000C8077774924);
      }
      while (v52 != v44);
      goto LABEL_69;
    }
  }
  return v40;
}

uint64_t mlir::complex::BitcastOp::fold(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24);
  v2 = *(_QWORD *)(v1 + 8) & 0xFFFFFFFFFFFFFFF8;
  v3 = v1 | 4;
  if (v2 == (*(_QWORD *)(*(_QWORD *)a1 - 8) & 0xFFFFFFFFFFFFFFF8))
    return v3;
  else
    return 0;
}

uint64_t mlir::complex::BitcastOp::verify(uint64_t **this)
{
  uint64_t *v1;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  BOOL isIntOrFloat;
  unint64_t v13;
  void *v14;
  const void **v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  const void **v23;
  int IntOrFloatBitWidth;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  const void **v38[4];
  __int16 v39;
  unint64_t v40;
  unint64_t v41;
  _QWORD v42[3];
  void *v43;
  uint64_t v44;
  void *v45;
  _QWORD *v46;
  void *__p;
  _QWORD *v48;
  char v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  v1 = *this;
  v41 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v40 = *(v1 - 1) & 0xFFFFFFFFFFFFFFF8;
  if (v41 == v40)
    return 1;
  if (!mlir::Type::isIntOrFloat((mlir::Type *)&v41)
    && *(_UNKNOWN **)(*(_QWORD *)v41 + 136) != &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
  {
    v38[0] = (const void **)"operand must be int/float/complex";
    v39 = 259;
    mlir::OpState::emitOpError(this, v38, (uint64_t)v42);
    v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v42);
    if (v42[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v42);
    if (v49)
    {
      v4 = __p;
      if (__p)
      {
        v5 = v48;
        v6 = __p;
        if (v48 != __p)
        {
          do
            v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
          while (v5 != v4);
          v6 = __p;
        }
        v48 = v4;
        operator delete(v6);
      }
      v7 = v45;
      if (!v45)
        goto LABEL_74;
      v8 = v46;
      v9 = v45;
      if (v46 == v45)
      {
LABEL_73:
        v46 = v7;
        operator delete(v9);
LABEL_74:
        if (v43 != &v44)
          free(v43);
        return v3;
      }
      do
      {
        v11 = *--v8;
        v10 = v11;
        *v8 = 0;
        if (v11)
          MEMORY[0x20BD002D4](v10, 0x1000C8077774924);
      }
      while (v8 != v7);
LABEL_72:
      v9 = v45;
      goto LABEL_73;
    }
    return v3;
  }
  isIntOrFloat = mlir::Type::isIntOrFloat((mlir::Type *)&v40);
  v13 = v40;
  v14 = *(void **)(*(_QWORD *)v40 + 136);
  if (isIntOrFloat)
  {
    v15 = (const void **)v41;
    v16 = *(void **)(*(_QWORD *)v41 + 136);
    if ((v16 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id) != (v14 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id))
    {
      if (v14 != &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
        goto LABEL_39;
      goto LABEL_38;
    }
LABEL_44:
    v38[0] = (const void **)"requires input or output is a complex type";
    v39 = 259;
    mlir::OpState::emitOpError(this, v38, (uint64_t)v42);
    v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v42);
    if (v42[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v42);
    if (v49)
    {
      v25 = __p;
      if (__p)
      {
        v26 = v48;
        v27 = __p;
        if (v48 != __p)
        {
          do
            v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
          while (v26 != v25);
          v27 = __p;
        }
        v48 = v25;
        operator delete(v27);
      }
      v7 = v45;
      if (!v45)
        goto LABEL_74;
      v28 = v46;
      v9 = v45;
      if (v46 == v45)
        goto LABEL_73;
      do
      {
        v30 = *--v28;
        v29 = v30;
        *v28 = 0;
        if (v30)
          MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
      }
      while (v28 != v7);
      goto LABEL_72;
    }
    return v3;
  }
  if (v14 != &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
  {
    v38[0] = (const void **)"result must be int/float/complex";
    v39 = 259;
    mlir::OpState::emitOpError(this, v38, (uint64_t)v42);
    v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v42);
    if (v42[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v42);
    if (v49)
    {
      v17 = __p;
      if (__p)
      {
        v18 = v48;
        v19 = __p;
        if (v48 != __p)
        {
          do
            v18 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v18 - 1);
          while (v18 != v17);
          v19 = __p;
        }
        v48 = v17;
        operator delete(v19);
      }
      v7 = v45;
      if (!v45)
        goto LABEL_74;
      v20 = v46;
      v9 = v45;
      if (v46 == v45)
        goto LABEL_73;
      do
      {
        v22 = *--v20;
        v21 = v22;
        *v20 = 0;
        if (v22)
          MEMORY[0x20BD002D4](v21, 0x1000C8077774924);
      }
      while (v20 != v7);
      goto LABEL_72;
    }
    return v3;
  }
  v15 = (const void **)v41;
  if (*(_UNKNOWN **)(*(_QWORD *)v41 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    goto LABEL_44;
LABEL_38:
  v40 = (unint64_t)v15;
  v41 = v13;
  v16 = *(void **)(*(_QWORD *)v13 + 136);
  v15 = (const void **)v13;
LABEL_39:
  if (v16 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    v23 = v15;
  else
    v23 = 0;
  v38[0] = v23;
  v42[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v38);
  IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)v42);
  if (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v40) == 2 * IntOrFloatBitWidth)
    return 1;
  v38[0] = (const void **)"casting bitwidths do not match";
  v39 = 259;
  mlir::OpState::emitOpError(this, v38, (uint64_t)v42);
  v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v42);
  if (v42[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v42);
  if (v49)
  {
    v31 = __p;
    if (__p)
    {
      v32 = v48;
      v33 = __p;
      if (v48 != __p)
      {
        do
          v32 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v32 - 1);
        while (v32 != v31);
        v33 = __p;
      }
      v48 = v31;
      operator delete(v33);
    }
    v7 = v45;
    if (!v45)
      goto LABEL_74;
    v34 = v46;
    v9 = v45;
    if (v46 == v45)
      goto LABEL_73;
    do
    {
      v36 = *--v34;
      v35 = v36;
      *v34 = 0;
      if (v36)
        MEMORY[0x20BD002D4](v35, 0x1000C8077774924);
    }
    while (v34 != v7);
    goto LABEL_72;
  }
  return v3;
}

void mlir::complex::BitcastOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  mlir::RewritePatternSet::addImpl<ArithBitcast,mlir::MLIRContext *&>(a1, 0, 0, &v3);
  mlir::RewritePatternSet::addImpl<MergeComplexBitcast,mlir::MLIRContext *&>(a1, 0, 0, &v3);
  mlir::RewritePatternSet::addImpl<MergeArithBitcast,mlir::MLIRContext *&>(a1, 0, 0, &v3);
}

uint64_t mlir::complex::CreateOp::fold(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v5);
  if (result)
  {
    v3 = result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::ReOp,void>::id)
    {
      v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 56);
      result = mlir::Value::getDefiningOp((mlir::Value *)&v5);
      if (result)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::ImOp,void>::id)
        {
          v4 = *(_QWORD *)(*(_QWORD *)(v3 + 72) + 24);
          if (v4 == *(_QWORD *)(*(_QWORD *)(result + 72) + 24))
            return v4 | 4;
          else
            return 0;
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

unint64_t mlir::complex::ImOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  unint64_t result;
  uint64_t v7;
  uint64_t v8;

  v3 = **(_QWORD **)(a2 + 48);
  if (v3)
  {
    v4 = *(void **)(*(_QWORD *)v3 + 136);
    if (v4 != &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
      v3 = 0;
    v8 = v3;
    if (v4 == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    {
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v8);
      if (v5 == 2)
        return *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v8) + 8) & 0xFFFFFFFFFFFFFFFBLL;
    }
  }
  else
  {
    v8 = 0;
  }
  v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v7);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::CreateOp,void>::id)
      return *(_QWORD *)(*(_QWORD *)(result + 72) + 56) | 4;
    else
      return 0;
  }
  return result;
}

void mlir::complex::ImOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  unint64_t v39;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v38, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"complex.im", 10, (__int16)v38, a2, 0, 0);
  *(_QWORD *)v4 = &off_24C0289B8;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v38 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldComponentNeg<mlir::complex::ImOp, 1>]";
  v39 = 113;
  v9 = llvm::StringRef::find((uint64_t *)&v38, "DesiredTypeName = ", 0x12uLL, 0);
  if (v39 >= v9)
    v10 = v9;
  else
    v10 = v39;
  v11 = &v38[v10];
  v12 = v39 - v10;
  if (v39 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v39 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    abort();
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_44;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_44:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
}

unint64_t mlir::complex::ReOp::fold(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;
  unint64_t result;
  uint64_t v7;
  uint64_t v8;

  v3 = **(_QWORD **)(a2 + 48);
  if (v3)
  {
    v4 = *(void **)(*(_QWORD *)v3 + 136);
    if (v4 != &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
      v3 = 0;
    v8 = v3;
    if (v4 == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    {
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v8);
      if (v5 == 2)
        return *(_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v8) & 0xFFFFFFFFFFFFFFFBLL;
    }
  }
  else
  {
    v8 = 0;
  }
  v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v7);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::CreateOp,void>::id)
      return *(_QWORD *)(*(_QWORD *)(result + 72) + 24) | 4;
    else
      return 0;
  }
  return result;
}

void mlir::complex::ReOp::getCanonicalizationPatterns(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  uint64_t *v22;
  char *v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  unint64_t v39;

  v4 = operator new();
  mlir::PatternBenefit::PatternBenefit(&v38, 1);
  mlir::Pattern::Pattern(v4 + 8, (uint64_t)"complex.re", 10, (__int16)v38, a2, 0, 0);
  *(_QWORD *)v4 = &off_24C028A10;
  if (*(_QWORD *)(v4 + 72))
  {
    v5 = *(unsigned int *)(v4 + 88);
    if (v5 <= *(_DWORD *)(v4 + 92))
      goto LABEL_3;
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4 + 80, (void *)(v4 + 96), v5, 16);
    *(_DWORD *)(v4 + 88) = *(_DWORD *)(v4 + 88);
    v7 = (char *)a1[2];
    v6 = a1[3];
    if ((unint64_t)v7 < v6)
      goto LABEL_4;
    goto LABEL_15;
  }
  v38 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::FoldComponentNeg<mlir::complex::ReOp, 0>]";
  v39 = 113;
  v9 = llvm::StringRef::find((uint64_t *)&v38, "DesiredTypeName = ", 0x12uLL, 0);
  if (v39 >= v9)
    v10 = v9;
  else
    v10 = v39;
  v11 = &v38[v10];
  v12 = v39 - v10;
  if (v39 - v10 >= 0x12)
    v13 = 18;
  else
    v13 = v39 - v10;
  v14 = &v11[v13];
  v15 = v12 - v13;
  if (v15 >= v15 - 1)
    --v15;
  *(_QWORD *)(v4 + 64) = v14;
  *(_QWORD *)(v4 + 72) = v15;
  v5 = *(unsigned int *)(v4 + 88);
  if (v5 > *(_DWORD *)(v4 + 92))
    goto LABEL_14;
LABEL_3:
  *(_DWORD *)(v4 + 88) = v5;
  v7 = (char *)a1[2];
  v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(_QWORD *)v7 = v4;
    v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  v16 = (char *)a1[1];
  v17 = (v7 - v16) >> 3;
  v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61)
    abort();
  v19 = v6 - (_QWORD)v16;
  if (v19 >> 2 > v18)
    v18 = v19 >> 2;
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8)
    v20 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v20 = v18;
  if (v20)
  {
    if (v20 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v21 = (char *)operator new(8 * v20);
    v22 = (uint64_t *)&v21[8 * v17];
    v23 = &v21[8 * v20];
    *v22 = v4;
    v8 = (uint64_t)(v22 + 1);
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
      goto LABEL_24;
  }
  else
  {
    v21 = 0;
    v22 = (uint64_t *)(8 * v17);
    v23 = 0;
    *(_QWORD *)(8 * v17) = v4;
    v8 = 8 * v17 + 8;
    v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v22
        && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_44;
      }
      v26 = (v25 >> 3) + 1;
      v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      v28 = &v7[-v27];
      v22 = (uint64_t *)((char *)v22 - v27);
      v29 = &v21[8 * v17 - 16];
      v30 = v7 - 16;
      v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *((_OWORD *)v30 - 1);
        v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_44:
        do
        {
          v34 = *((_QWORD *)v7 - 1);
          v7 -= 8;
          *(_QWORD *)v7 = 0;
          *--v22 = v34;
        }
        while (v7 != v16);
      }
      v7 = (char *)a1[1];
      v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        v37 = *((_QWORD *)v35 - 1);
        v35 -= 8;
        v36 = v37;
        *(_QWORD *)v35 = 0;
        if (v37)
          (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7)
    operator delete(v7);
LABEL_39:
  a1[2] = v8;
}

uint64_t mlir::complex::AddOp::fold(uint64_t *a1)
{
  uint64_t DefiningOp;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  llvm::APFloatBase *Value;
  void *v10;
  void *v11;
  uint64_t *v12;
  _BYTE *v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE v18[8];
  _QWORD v19[3];
  uint64_t v20;
  _QWORD v21[4];

  v21[3] = *MEMORY[0x24BDAC8D0];
  v20 = *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v20);
  if (!DefiningOp)
  {
    v20 = *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 56);
    v5 = mlir::Value::getDefiningOp((mlir::Value *)&v20);
    if (v5)
      goto LABEL_5;
LABEL_9:
    v6 = *a1;
    goto LABEL_10;
  }
  v3 = *a1;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::SubOp,void>::id)
  {
    v4 = *(_QWORD *)(DefiningOp + 72);
    if (*(_QWORD *)(*(_QWORD *)(v3 + 72) + 56) == *(_QWORD *)(v4 + 56))
      goto LABEL_7;
  }
  v20 = *(_QWORD *)(*(_QWORD *)(v3 + 72) + 56);
  v5 = mlir::Value::getDefiningOp((mlir::Value *)&v20);
  if (!v5)
    goto LABEL_9;
LABEL_5:
  v6 = *a1;
  if (*(_UNKNOWN **)(*(_QWORD *)(v5 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::complex::SubOp,void>::id
    || (v4 = *(_QWORD *)(v5 + 72), *(_QWORD *)(*(_QWORD *)(v6 + 72) + 24) != *(_QWORD *)(v4 + 56)))
  {
LABEL_10:
    v20 = *(_QWORD *)(*(_QWORD *)(v6 + 72) + 56);
    result = mlir::Value::getDefiningOp((mlir::Value *)&v20);
    if (!result)
      return result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::complex::ConstantOp,void>::id)
      return 0;
    v17 = *(_QWORD *)(result + 16 * (((unint64_t)*(unsigned int *)(result + 44) >> 23) & 1) + 64);
    v16 = *(_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v17);
    Value = (llvm::APFloatBase *)mlir::FloatAttr::getValue((mlir::FloatAttr *)&v16, (uint64_t)&v20);
    v10 = (void *)v21[0];
    v11 = llvm::APFloatBase::PPCDoubleDouble(Value);
    v12 = (uint64_t *)v21[1];
    if (v11 != v10)
      v12 = &v20;
    if ((*((_BYTE *)v12 + 28) & 7) == 3)
    {
      v15 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v17) + 8);
      mlir::FloatAttr::getValue((mlir::FloatAttr *)&v15, (uint64_t)v18);
      v13 = (_BYTE *)v19[1];
      if (v11 != (void *)v19[0])
        v13 = v18;
      v14 = (v13[28] & 7) == 3;
      if (v11 != (void *)v19[0])
      {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v19);
        if (v11 == (void *)v21[0])
          goto LABEL_20;
LABEL_23:
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v21);
        if (!v14)
          return 0;
        goto LABEL_24;
      }
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v19);
      if (v11 != (void *)v21[0])
        goto LABEL_23;
    }
    else
    {
      v14 = 0;
      if (v11 != v10)
        goto LABEL_23;
    }
LABEL_20:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v21);
    if (!v14)
      return 0;
LABEL_24:
    v7 = *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24);
    return v7 | 4;
  }
LABEL_7:
  v7 = *(_QWORD *)(v4 + 24);
  return v7 | 4;
}

uint64_t mlir::complex::SubOp::fold(uint64_t *a1)
{
  uint64_t DefiningOp;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  llvm::APFloatBase *Value;
  void *v8;
  void *v9;
  uint64_t *v10;
  _BYTE *v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE v16[8];
  _QWORD v17[3];
  uint64_t v18;
  _QWORD v19[4];

  v19[3] = *MEMORY[0x24BDAC8D0];
  v18 = *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v18);
  if (!DefiningOp)
  {
    v3 = *a1;
    goto LABEL_6;
  }
  v3 = *a1;
  if (*(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::complex::AddOp,void>::id
    || (v4 = *(_QWORD *)(DefiningOp + 72), *(_QWORD *)(*(_QWORD *)(v3 + 72) + 56) != *(_QWORD *)(v4 + 56)))
  {
LABEL_6:
    v18 = *(_QWORD *)(*(_QWORD *)(v3 + 72) + 56);
    result = mlir::Value::getDefiningOp((mlir::Value *)&v18);
    if (!result)
      return result;
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::complex::ConstantOp,void>::id)
      return 0;
    v15 = *(_QWORD *)(result + 16 * (((unint64_t)*(unsigned int *)(result + 44) >> 23) & 1) + 64);
    v14 = *(_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v15);
    Value = (llvm::APFloatBase *)mlir::FloatAttr::getValue((mlir::FloatAttr *)&v14, (uint64_t)&v18);
    v8 = (void *)v19[0];
    v9 = llvm::APFloatBase::PPCDoubleDouble(Value);
    v10 = (uint64_t *)v19[1];
    if (v9 != v8)
      v10 = &v18;
    if ((*((_BYTE *)v10 + 28) & 7) == 3)
    {
      v13 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v15) + 8);
      mlir::FloatAttr::getValue((mlir::FloatAttr *)&v13, (uint64_t)v16);
      v11 = (_BYTE *)v17[1];
      if (v9 != (void *)v17[0])
        v11 = v16;
      v12 = (v11[28] & 7) == 3;
      if (v9 != (void *)v17[0])
      {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v17);
        if (v9 == (void *)v19[0])
          goto LABEL_16;
LABEL_19:
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v19);
        if (!v12)
          return 0;
        goto LABEL_20;
      }
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v17);
      if (v9 != (void *)v19[0])
        goto LABEL_19;
    }
    else
    {
      v12 = 0;
      if (v9 != v8)
        goto LABEL_19;
    }
LABEL_16:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v19);
    if (!v12)
      return 0;
LABEL_20:
    v5 = *(_QWORD *)(*(_QWORD *)(*a1 + 72) + 24);
    return v5 | 4;
  }
  v5 = *(_QWORD *)(v4 + 24);
  return v5 | 4;
}

uint64_t mlir::complex::NegOp::fold(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v2);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::NegOp,void>::id)
      return *(_QWORD *)(*(_QWORD *)(result + 72) + 24) | 4;
    else
      return 0;
  }
  return result;
}

uint64_t mlir::complex::LogOp::fold(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v2);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::ExpOp,void>::id)
      return *(_QWORD *)(*(_QWORD *)(result + 72) + 24) | 4;
    else
      return 0;
  }
  return result;
}

uint64_t mlir::complex::ExpOp::fold(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v2);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::LogOp,void>::id)
      return *(_QWORD *)(*(_QWORD *)(result + 72) + 24) | 4;
    else
      return 0;
  }
  return result;
}

uint64_t mlir::complex::ConjOp::fold(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v2);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::ConjOp,void>::id)
      return *(_QWORD *)(*(_QWORD *)(result + 72) + 24) | 4;
    else
      return 0;
  }
  return result;
}

uint64_t mlir::complex::MulOp::fold(uint64_t a1)
{
  uint64_t DefiningOp;
  uint64_t v3;
  llvm::APFloatBase *Value;
  void *v6;
  void *v7;
  uint64_t *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[3];
  uint64_t v15;
  _QWORD v16[3];
  uint64_t v17;
  uint64_t v18[4];

  v18[3] = *MEMORY[0x24BDAC8D0];
  v17 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 56);
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v17);
  if (DefiningOp
    && *(_UNKNOWN **)(*(_QWORD *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::ConstantOp,void>::id)
  {
    v12 = *(_QWORD *)(DefiningOp + 16 * (((unint64_t)*(unsigned int *)(DefiningOp + 44) >> 23) & 1) + 64);
    v15 = *(_QWORD *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v12);
    mlir::FloatAttr::getValue((mlir::FloatAttr *)&v15, (uint64_t)&v17);
    v13 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v12) + 8);
    Value = (llvm::APFloatBase *)mlir::FloatAttr::getValue((mlir::FloatAttr *)&v13, (uint64_t)&v15);
    v6 = (void *)v16[0];
    v7 = llvm::APFloatBase::PPCDoubleDouble(Value);
    v8 = (uint64_t *)v16[1];
    if (v7 != v6)
      v8 = &v15;
    if ((*((_BYTE *)v8 + 28) & 7) != 3)
      goto LABEL_18;
    if (v7 == (void *)v18[0])
    {
      llvm::detail::DoubleAPFloat::DoubleAPFloat(v14, (uint64_t)v7, 1);
      if (v7 != (void *)v18[0])
      {
LABEL_10:
        llvm::detail::IEEEFloat::compare((llvm::detail::IEEEFloat *)v18, (const llvm::detail::IEEEFloat *)v14);
        v10 = v9;
        if (v7 != (void *)v14[0])
          goto LABEL_11;
        goto LABEL_17;
      }
    }
    else
    {
      llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v14, v18[0], (llvm::APInt *)1);
      if (v7 != (void *)v18[0])
        goto LABEL_10;
    }
    llvm::detail::DoubleAPFloat::compare((llvm::detail::DoubleAPFloat *)v18, (const llvm::detail::DoubleAPFloat *)v14);
    v10 = v11;
    if (v7 != (void *)v14[0])
    {
LABEL_11:
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v14);
      if (v10 == 1)
        goto LABEL_12;
      goto LABEL_18;
    }
LABEL_17:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v14);
    if (v10 == 1)
    {
LABEL_12:
      v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 72) + 24) | 4;
      if (v7 == (void *)v16[0])
        goto LABEL_13;
      goto LABEL_19;
    }
LABEL_18:
    v3 = 0;
    if (v7 == (void *)v16[0])
    {
LABEL_13:
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v16);
      if (v7 == (void *)v18[0])
      {
LABEL_14:
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v18);
        return v3;
      }
LABEL_20:
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v18);
      return v3;
    }
LABEL_19:
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v16);
    if (v7 == (void *)v18[0])
      goto LABEL_14;
    goto LABEL_20;
  }
  return 0;
}

BOOL mlir::complex::AbsOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::AbsOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[441];
    return a1[32];
  }
  return result;
}

uint64_t mlir::complex::AbsOp::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  unint64_t v14;
  _QWORD v15[3];

  v15[2] = *MEMORY[0x24BDAC8D0];
  v15[0] = a4;
  v15[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  v14 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v15, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  **(_QWORD **)a11 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v14);
  return 1;
}

uint64_t mlir::complex::AbsOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t Value;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  const void **v18;
  __int16 v19;
  _QWORD v20[3];
  void *v21;
  uint64_t v22;
  void *v23;
  _QWORD *v24;
  void *__p;
  _QWORD *v26;
  char v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v20[0] = v2;
  if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v3, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::__mlir_ods_local_attr_constraint_ComplexOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20)|| !mlir::complex::__mlir_ods_local_type_constraint_ComplexOps0(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))
  {
    return 0;
  }
  v4 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  if (!mlir::complex::__mlir_ods_local_type_constraint_ComplexOps1(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0))return 0;
  v20[0] = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v20);
  if (*((_DWORD *)*this + 9))
    v7 = (uint64_t)(*this - 2);
  else
    v7 = 0;
  if (Value == (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0) + 8) & 0xFFFFFFFFFFFFFFF8))
    return 1;
  v18 = (const void **)"failed to verify that complex element type matches result type";
  v19 = 259;
  mlir::OpState::emitOpError(this, &v18, (uint64_t)v20);
  v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
  if (v20[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
  if (v27)
  {
    v9 = __p;
    if (__p)
    {
      v10 = v26;
      v11 = __p;
      if (v26 != __p)
      {
        do
          v10 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v10 - 1);
        while (v10 != v9);
        v11 = __p;
      }
      v26 = v9;
      operator delete(v11);
    }
    v12 = v23;
    if (v23)
    {
      v13 = v24;
      v14 = v23;
      if (v24 != v23)
      {
        do
        {
          v16 = *--v13;
          v15 = v16;
          *v13 = 0;
          if (v16)
            MEMORY[0x20BD002D4](v15, 0x1000C8077774924);
        }
        while (v13 != v12);
        v14 = v23;
      }
      v24 = v12;
      operator delete(v14);
    }
    if (v21 != &v22)
      free(v21);
  }
  return v8;
}

uint64_t mlir::complex::__mlir_ods_local_type_constraint_ComplexOps0(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t v14;
  int *v15;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  int *v20;
  char *v21;
  char *v22;
  __int128 v23;
  int *v24;
  char *v25;
  char *v26;
  __int128 v27;
  uint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  BOOL v38;
  BOOL v39;
  BOOL v40;
  BOOL v41;
  BOOL v42;
  BOOL v43;
  BOOL v44;
  BOOL v45;
  unint64_t v49;
  unint64_t v50;
  BOOL v51;
  unint64_t v52;
  BOOL v53;
  unint64_t v54;
  int64_t v55;
  int64_t v56;
  int64_t v57;
  int64_t v58;
  const void **v59[4];
  __int16 v60;
  int v61;
  const char *v62;
  uint64_t v63;
  _QWORD v64[3];
  void *v65;
  unsigned int v66;
  unsigned int v67;
  _BYTE v68[96];
  void *v69;
  _QWORD *v70;
  void *__p;
  _QWORD *v72;
  char v73;
  uint64_t v74;

  v74 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) != &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    goto LABEL_2;
  v64[0] = a2;
  v37 = *(void **)(*(_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v64) + 136);
  v38 = v37 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
     || v37 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id;
  v39 = v38 || v37 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id;
  v40 = v39 || v37 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id;
  v41 = v40 || v37 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id;
  v42 = v41 || v37 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id;
  v43 = v42 || v37 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id;
  v44 = v43 || v37 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id;
  v45 = v44 || v37 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id;
  if (v45 || v37 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id)
    return 1;
  if (v37 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    || v37 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    return 1;
  }
LABEL_2:
  v60 = 261;
  v59[0] = a3;
  v59[1] = a4;
  mlir::Operation::emitOpError(a1, v59, (uint64_t)v64);
  if (v64[0])
  {
    v61 = 3;
    v62 = " #";
    v63 = 2;
    v10 = &v61;
    v11 = (char *)v65;
    if (v66 >= v67)
    {
      v49 = v66 + 1;
      if (v65 <= &v61 && (char *)v65 + 24 * v66 > (char *)&v61)
      {
        v55 = (char *)&v61 - (_BYTE *)v65;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v65, v68, v49, 24);
        v11 = (char *)v65;
        v10 = (int *)((char *)v65 + v55);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v65, v68, v49, 24);
        v10 = &v61;
        v11 = (char *)v65;
      }
    }
    v12 = &v11[24 * v66];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    v14 = ++v66;
    if (v64[0])
    {
      v61 = 5;
      v62 = (const char *)a5;
      v15 = &v61;
      v16 = (char *)v65;
      if (v14 >= v67)
      {
        v50 = v14 + 1;
        v51 = (char *)v65 + 24 * v14 > (char *)&v61;
        if (v65 <= &v61 && v51)
        {
          v56 = (char *)&v61 - (_BYTE *)v65;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v65, v68, v50, 24);
          v16 = (char *)v65;
          v15 = (int *)((char *)v65 + v56);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v65, v68, v50, 24);
          v15 = &v61;
          v16 = (char *)v65;
        }
      }
      v17 = &v16[24 * v66];
      v18 = *(_OWORD *)v15;
      *((_QWORD *)v17 + 2) = *((_QWORD *)v15 + 2);
      *(_OWORD *)v17 = v18;
      v19 = ++v66;
      if (v64[0])
      {
        v61 = 3;
        v62 = " must be complex type with floating-point elements, but got ";
        v63 = 60;
        v20 = &v61;
        v21 = (char *)v65;
        if (v19 >= v67)
        {
          v52 = v19 + 1;
          v53 = (char *)v65 + 24 * v19 > (char *)&v61;
          if (v65 <= &v61 && v53)
          {
            v57 = (char *)&v61 - (_BYTE *)v65;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v65, v68, v52, 24);
            v21 = (char *)v65;
            v20 = (int *)((char *)v65 + v57);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v65, v68, v52, 24);
            v20 = &v61;
            v21 = (char *)v65;
          }
        }
        v22 = &v21[24 * v66];
        v23 = *(_OWORD *)v20;
        *((_QWORD *)v22 + 2) = *((_QWORD *)v20 + 2);
        *(_OWORD *)v22 = v23;
        ++v66;
        if (v64[0])
        {
          v24 = &v61;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v61, a2);
          v25 = (char *)v65;
          if (v66 >= v67)
          {
            v54 = v66 + 1;
            if (v65 <= &v61 && (char *)v65 + 24 * v66 > (char *)&v61)
            {
              v58 = (char *)&v61 - (_BYTE *)v65;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v65, v68, v54, 24);
              v25 = (char *)v65;
              v24 = (int *)((char *)v65 + v58);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v65, v68, v54, 24);
              v24 = &v61;
              v25 = (char *)v65;
            }
          }
          v26 = &v25[24 * v66];
          v27 = *(_OWORD *)v24;
          *((_QWORD *)v26 + 2) = *((_QWORD *)v24 + 2);
          *(_OWORD *)v26 = v27;
          ++v66;
        }
      }
    }
  }
  v28 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v64);
  if (v64[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v64);
  if (v73)
  {
    v29 = __p;
    if (__p)
    {
      v30 = v72;
      v31 = __p;
      if (v72 != __p)
      {
        do
          v30 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v30 - 1);
        while (v30 != v29);
        v31 = __p;
      }
      v72 = v29;
      operator delete(v31);
    }
    v32 = v69;
    if (v69)
    {
      v33 = v70;
      v34 = v69;
      if (v70 != v69)
      {
        do
        {
          v36 = *--v33;
          v35 = v36;
          *v33 = 0;
          if (v36)
            MEMORY[0x20BD002D4](v35, 0x1000C8077774924);
        }
        while (v33 != v32);
        v34 = v69;
      }
      v70 = v32;
      operator delete(v34);
    }
    if (v65 != v68)
      free(v65);
  }
  return v28;
}

uint64_t mlir::complex::__mlir_ods_local_type_constraint_ComplexOps1(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  void *v5;
  uint64_t v10;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  int *v24;
  char *v25;
  char *v26;
  __int128 v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  BOOL v42;
  unint64_t v43;
  BOOL v44;
  unint64_t v45;
  int64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  const void **v50[4];
  __int16 v51;
  int v52;
  const char *v53;
  uint64_t v54;
  _QWORD v55[3];
  void *v56;
  unsigned int v57;
  unsigned int v58;
  _BYTE v59[96];
  void *v60;
  _QWORD *v61;
  void *__p;
  _QWORD *v63;
  char v64;
  uint64_t v65;

  v65 = *MEMORY[0x24BDAC8D0];
  v5 = *(void **)(*(_QWORD *)a2 + 136);
  if (v5 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
    || v5 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id)
  {
    return 1;
  }
  if (v5 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
    || v5 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id)
  {
    return 1;
  }
  if (v5 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
    || v5 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id)
  {
    return 1;
  }
  if (v5 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
    || v5 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id)
  {
    return 1;
  }
  v10 = 1;
  if (v5 != &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
    && v5 != &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
    && v5 != &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
    && v5 != &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
  {
    v51 = 261;
    v50[0] = a3;
    v50[1] = a4;
    mlir::Operation::emitOpError(a1, v50, (uint64_t)v55);
    if (v55[0])
    {
      v52 = 3;
      v53 = " #";
      v54 = 2;
      v14 = &v52;
      v15 = (char *)v56;
      if (v57 >= v58)
      {
        v40 = v57 + 1;
        if (v56 <= &v52 && (char *)v56 + 24 * v57 > (char *)&v52)
        {
          v46 = (char *)&v52 - (_BYTE *)v56;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v40, 24);
          v15 = (char *)v56;
          v14 = (int *)((char *)v56 + v46);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v40, 24);
          v14 = &v52;
          v15 = (char *)v56;
        }
      }
      v16 = &v15[24 * v57];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      v18 = ++v57;
      if (v55[0])
      {
        v52 = 5;
        v53 = (const char *)a5;
        v19 = &v52;
        v20 = (char *)v56;
        if (v18 >= v58)
        {
          v41 = v18 + 1;
          v42 = (char *)v56 + 24 * v18 > (char *)&v52;
          if (v56 <= &v52 && v42)
          {
            v47 = (char *)&v52 - (_BYTE *)v56;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v41, 24);
            v20 = (char *)v56;
            v19 = (int *)((char *)v56 + v47);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v41, 24);
            v19 = &v52;
            v20 = (char *)v56;
          }
        }
        v21 = &v20[24 * v57];
        v22 = *(_OWORD *)v19;
        *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
        *(_OWORD *)v21 = v22;
        v23 = ++v57;
        if (v55[0])
        {
          v52 = 3;
          v53 = " must be floating-point, but got ";
          v54 = 33;
          v24 = &v52;
          v25 = (char *)v56;
          if (v23 >= v58)
          {
            v43 = v23 + 1;
            v44 = (char *)v56 + 24 * v23 > (char *)&v52;
            if (v56 <= &v52 && v44)
            {
              v48 = (char *)&v52 - (_BYTE *)v56;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v43, 24);
              v25 = (char *)v56;
              v24 = (int *)((char *)v56 + v48);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v43, 24);
              v24 = &v52;
              v25 = (char *)v56;
            }
          }
          v26 = &v25[24 * v57];
          v27 = *(_OWORD *)v24;
          *((_QWORD *)v26 + 2) = *((_QWORD *)v24 + 2);
          *(_OWORD *)v26 = v27;
          ++v57;
          if (v55[0])
          {
            v28 = &v52;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v52, a2);
            v29 = (char *)v56;
            if (v57 >= v58)
            {
              v45 = v57 + 1;
              if (v56 <= &v52 && (char *)v56 + 24 * v57 > (char *)&v52)
              {
                v49 = (char *)&v52 - (_BYTE *)v56;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v45, 24);
                v29 = (char *)v56;
                v28 = (int *)((char *)v56 + v49);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v45, 24);
                v28 = &v52;
                v29 = (char *)v56;
              }
            }
            v30 = &v29[24 * v57];
            v31 = *(_OWORD *)v28;
            *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
            *(_OWORD *)v30 = v31;
            ++v57;
          }
        }
      }
    }
    v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v55);
    if (v55[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v55);
    if (v64)
    {
      v32 = __p;
      if (__p)
      {
        v33 = v63;
        v34 = __p;
        if (v63 != __p)
        {
          do
            v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
          while (v33 != v32);
          v34 = __p;
        }
        v63 = v32;
        operator delete(v34);
      }
      v35 = v60;
      if (v60)
      {
        v36 = v61;
        v37 = v60;
        if (v61 != v60)
        {
          do
          {
            v39 = *--v36;
            v38 = v39;
            *v36 = 0;
            if (v39)
              MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
          }
          while (v36 != v35);
          v37 = v60;
        }
        v61 = v35;
        operator delete(v37);
      }
      if (v56 != v59)
        free(v56);
    }
  }
  return v10;
}

BOOL mlir::complex::AbsOp::parse(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v13;
  _QWORD v14[4];
  __int16 v15;
  uint64_t v16;
  _QWORD v17[2];
  uint64_t v18;
  uint64_t v19[2];
  _QWORD __src[24];
  uint64_t v21;
  _QWORD v22[5];

  v22[4] = *MEMORY[0x24BDAC8D0];
  memset(v22, 0, 24);
  v19[0] = (uint64_t)v22;
  v19[1] = 1;
  v17[1] = 1;
  v18 = 0;
  v21 = 0;
  v17[0] = &v21;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v22, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v18, 0))return 0;
  if (v18)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties>(a2);
    *v5 = v18;
  }
LABEL_6:
  v14[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
    return 0;
  v6 = a2[1];
  __src[0] = a1;
  __src[1] = v14;
  __src[2] = a2;
  v7 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::AbsOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  __src[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, __src))
    return 0;
  v21 = __src[0];
  v16 = __src[0];
  if (*(_UNKNOWN **)(*(_QWORD *)__src[0] + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id
    && ((v13 = *(void **)(*(_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)__src) + 136),
         v13 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id)
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id))
  {
    v14[0] = v21;
    __src[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v14);
    mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
    return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v19, v17, v4, (uint64_t)(a2 + 2)) != 0;
  }
  else
  {
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v15 = 257;
    (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(__src, a1, v8, v14);
    v9 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)__src, "'complex' must be complex type with floating-point elements, but got ");
    v10 = mlir::InFlightDiagnostic::append<mlir::Type &>(v9, &v16);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v10);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)__src);
  }
  return v11;
}

void mlir::complex::AbsOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  uint64_t v6;
  mlir::MLIRContext *Context;
  llvm::raw_ostream *v8;
  _BYTE *v9;
  llvm::raw_ostream *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  mlir::MLIRContext *v14;
  uint64_t v15;
  mlir::Operation *v16;
  mlir::ArrayAttr *p_AttrDictionary;
  unsigned int v18;
  _QWORD *v19;
  uint64_t Value;
  uint64_t v21;
  llvm::raw_ostream *v22;
  _BYTE *v23;
  llvm::raw_ostream *v24;
  _BYTE *v25;
  llvm::raw_ostream *v26;
  _BYTE *v27;
  unint64_t AttrDictionary;
  void *v29;
  uint64_t v30;
  _QWORD v31[5];

  v31[4] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 24));
  v6 = *((_QWORD *)*this + 2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8);
  if (v6)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Operation *)((char *)*this + 24));
    if (v6 != mlir::arith::FastMathFlagsAttr::get(Context, 0))
    {
      v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
      v9 = (_BYTE *)*((_QWORD *)v8 + 4);
      if ((unint64_t)v9 >= *((_QWORD *)v8 + 3))
      {
        llvm::raw_ostream::write(v8, 32);
      }
      else
      {
        *((_QWORD *)v8 + 4) = v9 + 1;
        *v9 = 32;
      }
      v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
      v11 = (_QWORD *)*((_QWORD *)v10 + 4);
      if (*((_QWORD *)v10 + 3) - (_QWORD)v11 > 7uLL)
      {
        *v11 = 0x6874616D74736166;
        *((_QWORD *)v10 + 4) += 8;
      }
      else
      {
        llvm::raw_ostream::write(v10, "fastmath", 8uLL);
      }
      v29 = (void *)*((_QWORD *)*this + 2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8);
      if (!(*(unsigned __int8 (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 104))(a2))
      {
        v12 = (_QWORD *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
        v13 = (*(uint64_t (**)(_QWORD *))(*v12 + 80))(v12) + v12[4] - v12[2];
        mlir::arith::FastMathFlagsAttr::print((mlir::arith::FastMathFlagsAttr *)&v29, a2);
        if (v13 == (*(uint64_t (**)(_QWORD *))(*v12 + 80))(v12) + v12[4] - v12[2])
          (*(void (**)(mlir::OpAsmPrinter *, void *))(*(_QWORD *)a2 + 40))(a2, v29);
      }
    }
  }
  v29 = v31;
  v31[0] = "fastmath";
  v31[1] = 8;
  v30 = 0x200000001;
  v14 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Operation *)((char *)*this + 24));
  v15 = *((_QWORD *)*this + 2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8);
  if (v15 && v15 == mlir::arith::FastMathFlagsAttr::get(v14, 0))
  {
    v18 = v30;
    if (v30 >= HIDWORD(v30))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v29, v31, v30 + 1, 16);
      v18 = v30;
    }
    v19 = (char *)v29 + 16 * v18;
    *v19 = "fastmath";
    v19[1] = 8;
    LODWORD(v30) = v30 + 1;
    v16 = *this;
    if (!*((_BYTE *)*this + 47))
      goto LABEL_18;
  }
  else
  {
    v16 = *this;
    if (!*((_BYTE *)*this + 47))
    {
LABEL_18:
      p_AttrDictionary = (mlir::Operation *)((char *)v16 + 56);
      goto LABEL_23;
    }
  }
  AttrDictionary = mlir::Operation::getAttrDictionary(v16);
  p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
LABEL_23:
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v21, v29, v30);
  v22 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v23 = (_BYTE *)*((_QWORD *)v22 + 4);
  if ((unint64_t)v23 >= *((_QWORD *)v22 + 3))
  {
    llvm::raw_ostream::write(v22, 32);
  }
  else
  {
    *((_QWORD *)v22 + 4) = v23 + 1;
    *v23 = 32;
  }
  v24 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v25 = (_BYTE *)*((_QWORD *)v24 + 4);
  if (*((_BYTE **)v24 + 3) == v25)
  {
    llvm::raw_ostream::write(v24, ":", 1uLL);
  }
  else
  {
    *v25 = 58;
    ++*((_QWORD *)v24 + 4);
  }
  v26 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v27 = (_BYTE *)*((_QWORD *)v26 + 4);
  if ((unint64_t)v27 >= *((_QWORD *)v26 + 3))
  {
    llvm::raw_ostream::write(v26, 32);
  }
  else
  {
    *((_QWORD *)v26 + 4) = v27 + 1;
    *v27 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(*((_QWORD *)*this + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v29 != v31)
    free(v29);
}

uint64_t mlir::complex::detail::AddOpGenericAdaptorBase::AddOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "complex.add", 11, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::AddOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::AddOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::AddOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AddOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AddOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AddOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AddOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::AddOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::AddOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[443];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::AddOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t *v7;

  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v7 = v2;
  if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v3, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::__mlir_ods_local_attr_constraint_ComplexOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::complex::__mlir_ods_local_type_constraint_ComplexOps0(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::complex::__mlir_ods_local_type_constraint_ComplexOps0(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v4 = (uint64_t)(*this - 2);
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::complex::__mlir_ods_local_type_constraint_ComplexOps0(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

BOOL mlir::complex::AddOp::parse(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v9;
  uint64_t v10;
  _QWORD __src[3];
  _QWORD v12[4];
  _QWORD v13[5];

  v13[4] = *MEMORY[0x24BDAC8D0];
  memset(v13, 0, 24);
  memset(v12, 0, 24);
  v10 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v13, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v12, 1))
    return 0;
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
  {
    if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v10, 0))return 0;
    if (v10)
    {
      v4 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::AddOpGenericAdaptorBase::Properties>(a2);
      *v4 = v10;
    }
  }
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
  {
    v5 = a2[1];
    __src[0] = a1;
    __src[1] = &v9;
    __src[2] = a2;
    v6 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v5 + 96));
    if (!v6
      || mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v6, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::AddOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))
    {
      if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
      {
        v9 = 0;
        if (mlir::AsmParser::parseType<mlir::ComplexType>(a1, &v9))
        {
          __src[0] = v9;
          mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
          v7 = a2 + 2;
          if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v13, __src[0], v7))
          {
            return (*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v12, __src[0], v7) != 0;
          }
        }
      }
    }
  }
  return 0;
}

BOOL mlir::complex::AngleOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::AngleOpGenericAdaptorBase::Properties]";
        v15 = 110;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[445];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::AngleOp::parse(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v13;
  _QWORD v14[4];
  __int16 v15;
  uint64_t v16;
  _QWORD v17[2];
  uint64_t v18;
  uint64_t v19[2];
  _QWORD __src[24];
  uint64_t v21;
  _QWORD v22[5];

  v22[4] = *MEMORY[0x24BDAC8D0];
  memset(v22, 0, 24);
  v19[0] = (uint64_t)v22;
  v19[1] = 1;
  v17[1] = 1;
  v18 = 0;
  v21 = 0;
  v17[0] = &v21;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v22, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v18, 0))return 0;
  if (v18)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties>(a2);
    *v5 = v18;
  }
LABEL_6:
  v14[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
    return 0;
  v6 = a2[1];
  __src[0] = a1;
  __src[1] = v14;
  __src[2] = a2;
  v7 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::AngleOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  __src[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, __src))
    return 0;
  v21 = __src[0];
  v16 = __src[0];
  if (*(_UNKNOWN **)(*(_QWORD *)__src[0] + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id
    && ((v13 = *(void **)(*(_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)__src) + 136),
         v13 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id)
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id))
  {
    v14[0] = v21;
    __src[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v14);
    mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
    return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v19, v17, v4, (uint64_t)(a2 + 2)) != 0;
  }
  else
  {
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v15 = 257;
    (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(__src, a1, v8, v14);
    v9 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)__src, "'complex' must be complex type with floating-point elements, but got ");
    v10 = mlir::InFlightDiagnostic::append<mlir::Type &>(v9, &v16);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v10);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)__src);
  }
  return v11;
}

BOOL mlir::complex::Atan2Op::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties]";
        v15 = 110;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[447];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::Atan2Op::parse(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v9;
  uint64_t v10;
  _QWORD __src[3];
  _QWORD v12[4];
  _QWORD v13[5];

  v13[4] = *MEMORY[0x24BDAC8D0];
  memset(v13, 0, 24);
  memset(v12, 0, 24);
  v10 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v13, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v12, 1))
    return 0;
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
  {
    if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v10, 0))return 0;
    if (v10)
    {
      v4 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties>(a2);
      *v4 = v10;
    }
  }
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
  {
    v5 = a2[1];
    __src[0] = a1;
    __src[1] = &v9;
    __src[2] = a2;
    v6 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v5 + 96));
    if (!v6
      || mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v6, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::Atan2Op::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))
    {
      if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
      {
        v9 = 0;
        if (mlir::AsmParser::parseType<mlir::ComplexType>(a1, &v9))
        {
          __src[0] = v9;
          mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
          v7 = a2 + 2;
          if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v13, __src[0], v7))
          {
            return (*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v12, __src[0], v7) != 0;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t mlir::complex::detail::BitcastOpGenericAdaptorBase::BitcastOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  v5 = a2[11];
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "complex.bitcast", 15, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::complex::BitcastOp::verifyInvariantsImpl(mlir::complex::BitcastOp *this)
{
  uint64_t v1;

  if (*(_DWORD *)(*(_QWORD *)this + 36))
    v1 = *(_QWORD *)this - 16;
  else
    v1 = 0;
  mlir::detail::OpResultImpl::getNextResultAtOffset(v1, 0);
  return 1;
}

BOOL mlir::complex::BitcastOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v7[2];
  uint64_t v8[2];
  uint64_t v9;
  _QWORD v10[4];
  _QWORD __src[4];
  __int16 v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  memset(v10, 0, 24);
  v8[0] = (uint64_t)v10;
  v8[1] = 1;
  v9 = 0;
  v7[0] = &v9;
  v7[1] = 1;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v10, 1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  __src[0] = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 504))(a1, __src))
    return 0;
  v9 = __src[0];
  v12 = 257;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 368))(a1, "to", 2, __src))return 0;
  v6 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 504))(a1, &v6))
    return 0;
  __src[0] = v6;
  mlir::OperationState::addTypes(a2, __src, 1);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v8, v7, v4, a2 + 16) != 0;
}

uint64_t mlir::complex::detail::ConjOpGenericAdaptorBase::ConjOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "complex.conj", 12, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::ConjOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::ConjOpGenericAdaptorBase::Properties]";
        v15 = 109;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[449];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::ConjOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t *v7;

  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v7 = v2;
  if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v3, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::__mlir_ods_local_attr_constraint_ComplexOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::complex::__mlir_ods_local_type_constraint_ComplexOps0(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v4 = (uint64_t)(*this - 2);
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::complex::__mlir_ods_local_type_constraint_ComplexOps0(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

BOOL mlir::complex::ConjOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15[2];
  uint64_t v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v16 = 0;
  v13[0] = &v16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0;
  if (v14)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v5 = v14;
  }
LABEL_6:
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  v6 = *(_QWORD *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  v7 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ConjOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11))
    return 0;
  v8 = v11[0];
  v16 = v11[0];
  v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    v8 = v16;
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

uint64_t mlir::complex::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "complex.constant", 16, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::complex::ConstantOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  int *v36;
  char *v37;
  char *v38;
  __int128 v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  uint64_t v55;
  int v56;
  const char *v57;
  uint64_t v58;
  _QWORD v59[3];
  void *v60;
  unsigned int v61;
  unsigned int v62;
  _BYTE v63[96];
  void *v64;
  _QWORD *v65;
  void *__p;
  _QWORD *v67;
  char v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v55 = v6;
  if (!v6)
  {
    a3(v59, a4);
    if (v59[0])
    {
      v56 = 3;
      v57 = "expected DictionaryAttr to set properties";
      v58 = 41;
      v26 = &v56;
      v27 = (char *)v60;
      if (v61 >= v62)
      {
        v47 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v51 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          v27 = (char *)v60;
          v26 = (int *)((char *)v60 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          v26 = &v56;
          v27 = (char *)v60;
        }
      }
      v28 = &v27[24 * v61];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v68)
      return 0;
    v30 = __p;
    if (__p)
    {
      v31 = v67;
      v32 = __p;
      if (v67 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v67 = v30;
      operator delete(v32);
    }
    v21 = v64;
    if (!v64)
      goto LABEL_59;
    v33 = v65;
    v23 = v64;
    if (v65 == v64)
      goto LABEL_58;
    do
    {
      v35 = *--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
    }
    while (v33 != v21);
    goto LABEL_57;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v55, "value", 5uLL);
  if (!v8)
  {
    a3(v59, a4);
    if (v59[0])
    {
      v56 = 3;
      v57 = "expected key entry for value in DictionaryAttr to set Properties.";
      v58 = 65;
      v36 = &v56;
      v37 = (char *)v60;
      if (v61 >= v62)
      {
        v49 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v53 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          v37 = (char *)v60;
          v36 = (int *)((char *)v60 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          v36 = &v56;
          v37 = (char *)v60;
        }
      }
      v38 = &v37[24 * v61];
      v39 = *(_OWORD *)v36;
      *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
      *(_OWORD *)v38 = v39;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v68)
      return 0;
    v40 = __p;
    if (__p)
    {
      v41 = v67;
      v42 = __p;
      if (v67 != __p)
      {
        do
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        v42 = __p;
      }
      v67 = v40;
      operator delete(v42);
    }
    v21 = v64;
    if (!v64)
      goto LABEL_59;
    v43 = v65;
    v23 = v64;
    if (v65 == v64)
      goto LABEL_58;
    do
    {
      v45 = *--v43;
      v44 = v45;
      *v43 = 0;
      if (v45)
        MEMORY[0x20BD002D4](v44, 0x1000C8077774924);
    }
    while (v43 != v21);
    goto LABEL_57;
  }
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v59, a4);
  if (v59[0])
  {
    v56 = 3;
    v58 = 50;
    v10 = &v56;
    v11 = (char *)v60;
    if (v61 >= v62)
    {
      v48 = v61 + 1;
      if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
      {
        v52 = (char *)&v56 - (_BYTE *)v60;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        v11 = (char *)v60;
        v10 = (int *)((char *)v60 + v52);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        v10 = &v56;
        v11 = (char *)v60;
      }
    }
    v12 = &v11[24 * v61];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v61;
    if (v59[0])
    {
      v14 = &v56;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v56, v9);
      v15 = (char *)v60;
      if (v61 >= v62)
      {
        v50 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v54 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          v15 = (char *)v60;
          v14 = (int *)((char *)v60 + v54);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          v14 = &v56;
          v15 = (char *)v60;
        }
      }
      v16 = &v15[24 * v61];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
  }
  if (v68)
  {
    v18 = __p;
    if (__p)
    {
      v19 = v67;
      v20 = __p;
      if (v67 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v67 = v18;
      operator delete(v20);
    }
    v21 = v64;
    if (!v64)
      goto LABEL_59;
    v22 = v65;
    v23 = v64;
    if (v65 == v64)
    {
LABEL_58:
      v65 = v21;
      operator delete(v23);
LABEL_59:
      if (v60 != v63)
        free(v60);
      return 0;
    }
    do
    {
      v25 = *--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
    }
    while (v22 != v21);
LABEL_57:
    v23 = v64;
    goto LABEL_58;
  }
  return 0;
}

_QWORD *mlir::complex::ConstantOp::setInherentAttr(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;

  if (a3 == 5 && *(_DWORD *)a2 == 1970037110 && *(_BYTE *)(a2 + 4) == 101)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
        v5 = a4;
      else
        v5 = 0;
      *result = v5;
    }
    else
    {
      *result = 0;
    }
  }
  return result;
}

BOOL mlir::complex::ConstantOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;

  v6 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  return !v6
      || mlir::complex::__mlir_ods_local_attr_constraint_ComplexOps1(v6, (const void **)"value", (const char *)5, a3, a4);
}

uint64_t mlir::complex::__mlir_ods_local_attr_constraint_ComplexOps1(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!a1 || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    return 1;
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: array attribute";
        v31 = 47;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

BOOL mlir::complex::ConstantOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::ArrayAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties]";
        v15 = 113;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[451];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::ArrayAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::ArrayAttr]";
  v41 = 65;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

void mlir::complex::ConstantOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;

  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a4;
  v6 = *(unsigned int *)(a2 + 72);
  if (v6 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v6 + 1, 8);
    LODWORD(v6) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v6) = a3;
  ++*(_DWORD *)(a2 + 72);
}

BOOL mlir::complex::ConstantOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  const void **v16;
  __int16 v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD *v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v18[0] = v2;
    if (mlir::complex::__mlir_ods_local_attr_constraint_ComplexOps1(v3, (const void **)"value", (const char *)5, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::__mlir_ods_local_attr_constraint_ComplexOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v18))
    {
      if (*((_DWORD *)*this + 9))
        v4 = (uint64_t)(*this - 2);
      else
        v4 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
      return mlir::complex::__mlir_ods_local_type_constraint_ComplexOps0(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v16 = (const void **)"requires attribute 'value'";
    v17 = 259;
    mlir::OpState::emitOpError(this, &v16, (uint64_t)v18);
    v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
    if (v18[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
    if (v25)
    {
      v7 = __p;
      if (__p)
      {
        v8 = v24;
        v9 = __p;
        if (v24 != __p)
        {
          do
            v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
          while (v8 != v7);
          v9 = __p;
        }
        v24 = v7;
        operator delete(v9);
      }
      v10 = v21;
      if (v21)
      {
        v11 = v22;
        v12 = v21;
        if (v22 != v21)
        {
          do
          {
            v14 = *--v11;
            v13 = v14;
            *v11 = 0;
            if (v14)
              MEMORY[0x20BD002D4](v13, 0x1000C8077774924);
          }
          while (v11 != v10);
          v12 = v21;
        }
        v22 = v10;
        operator delete(v12);
      }
      if (v19 != &v20)
        free(v19);
    }
  }
  return v6;
}

uint64_t mlir::complex::ConstantOp::parse(uint64_t a1, uint64_t a2)
{
  mlir::NoneType **v4;
  mlir::MLIRContext *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v13[3];
  uint64_t v14;
  uint64_t v15;

  v15 = 0;
  v4 = (mlir::NoneType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  v6 = mlir::NoneType::get(*v4, v5);
  if (!mlir::AsmParser::parseAttribute<mlir::ArrayAttr>(a1, &v15, v6))
    return 0;
  if (v15)
  {
    v7 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v7 = v15;
  }
  v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  v8 = *(_QWORD *)(a2 + 8);
  v13[0] = a1;
  v13[1] = &v14;
  v13[2] = a2;
  v9 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v8 + 96));
  if (v9)
  {
    if (!mlir::complex::__mlir_ods_local_attr_constraint_ComplexOps1(v9, (const void **)"value", (const char *)5, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ConstantOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v13))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v13[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v13))
    return 0;
  v10 = v13[0];
  v11 = *(unsigned int *)(a2 + 72);
  if (v11 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v11) = v10;
  ++*(_DWORD *)(a2 + 72);
  return 1;
}

void mlir::complex::ConstantOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  mlir::Operation *v6;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v9;
  llvm::raw_ostream *v10;
  _BYTE *v11;
  llvm::raw_ostream *v12;
  _BYTE *v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t NextResultAtOffset;
  unint64_t AttrDictionary;
  void *v19;
  uint64_t v20;
  _QWORD v21[5];

  v21[4] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 48))(a2, *((_QWORD *)*this + 2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8));
  v19 = v21;
  v21[0] = "value";
  v21[1] = 5;
  v20 = 0x200000001;
  v6 = *this;
  if (*((_BYTE *)*this + 47))
  {
    AttrDictionary = mlir::Operation::getAttrDictionary(v6);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::Operation *)((char *)v6 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v9, v19, v20);
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (_BYTE *)*((_QWORD *)v10 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((_QWORD *)v10 + 4) = v11 + 1;
    *v11 = 32;
  }
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)v12 + 4);
  if (*((_BYTE **)v12 + 3) == v13)
  {
    llvm::raw_ostream::write(v12, ":", 1uLL);
  }
  else
  {
    *v13 = 58;
    ++*((_QWORD *)v12 + 4);
  }
  v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)v14 + 4);
  if ((unint64_t)v15 >= *((_QWORD *)v14 + 3))
  {
    llvm::raw_ostream::write(v14, 32);
  }
  else
  {
    *((_QWORD *)v14 + 4) = v15 + 1;
    *v15 = 32;
  }
  if (*((_DWORD *)*this + 9))
    v16 = (uint64_t)*this - 16;
  else
    v16 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 0);
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v19 != v21)
    free(v19);
}

BOOL mlir::complex::CosOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::CosOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::CosOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::CosOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::CosOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::CosOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::CosOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::CosOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::CosOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[453];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::CosOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15[2];
  uint64_t v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v16 = 0;
  v13[0] = &v16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0;
  if (v14)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::CosOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v5 = v14;
  }
LABEL_6:
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  v6 = *(_QWORD *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  v7 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::CosOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11))
    return 0;
  v8 = v11[0];
  v16 = v11[0];
  v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    v8 = v16;
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

uint64_t mlir::complex::detail::CreateOpGenericAdaptorBase::CreateOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  v5 = a2[11];
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "complex.create", 14, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::complex::CreateOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;
  uint64_t *v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t Value;
  uint64_t *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t *v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  const void **v35[4];
  __int16 v36;
  _QWORD v37[3];
  void *v38;
  uint64_t v39;
  void *v40;
  _QWORD *v41;
  void *__p;
  _QWORD *v43;
  char v44;
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  if (!mlir::complex::__mlir_ods_local_type_constraint_ComplexOps1(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::complex::__mlir_ods_local_type_constraint_ComplexOps1(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  v2 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  if (!mlir::complex::__mlir_ods_local_type_constraint_ComplexOps0(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0))return 0;
  v4 = *this;
  if ((*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8) == (*(_QWORD *)(*(_QWORD *)((*this)[9] + 56)
                                                                                              + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    v14 = *((_DWORD *)v4 + 9);
    v15 = v4 - 2;
    if (v14)
      v16 = (uint64_t)v15;
    else
      v16 = 0;
    v37[0] = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v37);
    v18 = *this;
    if (Value == (*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      v25 = *((_DWORD *)v18 + 9);
      v26 = v18 - 2;
      if (v25)
        v27 = (uint64_t)v26;
      else
        v27 = 0;
      v37[0] = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      if (mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v37) == (*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8))
        return 1;
      v35[0] = (const void **)"failed to verify that complex element type matches imaginary operand type";
      v36 = 259;
      mlir::OpState::emitOpError(this, v35, (uint64_t)v37);
      v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v37);
      if (v37[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v37);
      if (v44)
      {
        v28 = __p;
        if (__p)
        {
          v29 = v43;
          v30 = __p;
          if (v43 != __p)
          {
            do
              v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
            while (v29 != v28);
            v30 = __p;
          }
          v43 = v28;
          operator delete(v30);
        }
        v9 = v40;
        if (!v40)
          goto LABEL_61;
        v31 = v41;
        v11 = v40;
        if (v41 == v40)
          goto LABEL_60;
        do
        {
          v33 = *--v31;
          v32 = v33;
          *v31 = 0;
          if (v33)
            MEMORY[0x20BD002D4](v32, 0x1000C8077774924);
        }
        while (v31 != v9);
        goto LABEL_59;
      }
    }
    else
    {
      v35[0] = (const void **)"failed to verify that complex element type matches real operand type";
      v36 = 259;
      mlir::OpState::emitOpError(this, v35, (uint64_t)v37);
      v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v37);
      if (v37[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v37);
      if (v44)
      {
        v19 = __p;
        if (__p)
        {
          v20 = v43;
          v21 = __p;
          if (v43 != __p)
          {
            do
              v20 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v20 - 1);
            while (v20 != v19);
            v21 = __p;
          }
          v43 = v19;
          operator delete(v21);
        }
        v9 = v40;
        if (!v40)
          goto LABEL_61;
        v22 = v41;
        v11 = v40;
        if (v41 == v40)
          goto LABEL_60;
        do
        {
          v24 = *--v22;
          v23 = v24;
          *v22 = 0;
          if (v24)
            MEMORY[0x20BD002D4](v23, 0x1000C8077774924);
        }
        while (v22 != v9);
        goto LABEL_59;
      }
    }
  }
  else
  {
    v35[0] = (const void **)"failed to verify that all of {real, imaginary} have same type";
    v36 = 259;
    mlir::OpState::emitOpError(this, v35, (uint64_t)v37);
    v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v37);
    if (v37[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v37);
    if (v44)
    {
      v6 = __p;
      if (__p)
      {
        v7 = v43;
        v8 = __p;
        if (v43 != __p)
        {
          do
            v7 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v7 - 1);
          while (v7 != v6);
          v8 = __p;
        }
        v43 = v6;
        operator delete(v8);
      }
      v9 = v40;
      if (!v40)
        goto LABEL_61;
      v10 = v41;
      v11 = v40;
      if (v41 == v40)
      {
LABEL_60:
        v41 = v9;
        operator delete(v11);
LABEL_61:
        if (v38 != &v39)
          free(v38);
        return v5;
      }
      do
      {
        v13 = *--v10;
        v12 = v13;
        *v10 = 0;
        if (v13)
          MEMORY[0x20BD002D4](v12, 0x1000C8077774924);
      }
      while (v10 != v9);
LABEL_59:
      v11 = v40;
      goto LABEL_60;
    }
  }
  return v5;
}

BOOL mlir::complex::CreateOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t Value;
  uint64_t v10;
  uint64_t v11;
  _WORD v13[20];
  uint64_t v14;
  _QWORD v15[24];
  uint64_t __src;
  _QWORD v17[4];
  _QWORD v18[5];

  v18[4] = *MEMORY[0x24BDAC8D0];
  memset(v18, 0, 24);
  memset(v17, 0, 24);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v18, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v15[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v15))
    return 0;
  __src = v15[0];
  v14 = v15[0];
  if (*(_UNKNOWN **)(*(_QWORD *)v15[0] + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
  {
    v8 = *(void **)(*(_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v15) + 136);
    if (v8 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
    {
      mlir::OperationState::addTypes(a2, &__src, 1);
      v15[0] = __src;
      Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v15);
      v10 = a2 + 16;
      if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v18, Value, v10))
      {
        v15[0] = __src;
        v11 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v15);
        return (*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)a1 + 696))(a1, v17, v11, v10) != 0;
      }
      return 0;
    }
  }
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v13[16] = 257;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, _WORD *))(*(_QWORD *)a1 + 24))(v15, a1, v4, v13);
  v5 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v15, "'complex' must be complex type with floating-point elements, but got ");
  v6 = mlir::InFlightDiagnostic::append<mlir::Type &>(v5, &v14);
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v6);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v15);
  return v7;
}

BOOL mlir::complex::DivOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::DivOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::DivOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::DivOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::DivOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::DivOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::DivOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::DivOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::DivOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[455];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::DivOp::parse(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v9;
  uint64_t v10;
  _QWORD __src[3];
  _QWORD v12[4];
  _QWORD v13[5];

  v13[4] = *MEMORY[0x24BDAC8D0];
  memset(v13, 0, 24);
  memset(v12, 0, 24);
  v10 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v13, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v12, 1))
    return 0;
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
  {
    if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v10, 0))return 0;
    if (v10)
    {
      v4 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::DivOpGenericAdaptorBase::Properties>(a2);
      *v4 = v10;
    }
  }
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
  {
    v5 = a2[1];
    __src[0] = a1;
    __src[1] = &v9;
    __src[2] = a2;
    v6 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v5 + 96));
    if (!v6
      || mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v6, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::DivOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))
    {
      if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
      {
        v9 = 0;
        if (mlir::AsmParser::parseType<mlir::ComplexType>(a1, &v9))
        {
          __src[0] = v9;
          mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
          v7 = a2 + 2;
          if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v13, __src[0], v7))
          {
            return (*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v12, __src[0], v7) != 0;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t mlir::complex::EqualOp::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v12;
  unsigned int v13;
  uint64_t v15;

  v12 = *(_DWORD *)(a11 + 8);
  if (v12 != 1)
  {
    if (!v12)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v13 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v13), 8 - 8 * v13);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v13 = *(_DWORD *)(a11 + 8);
      if (v13 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  v15 = a1;
  **(_QWORD **)a11 = mlir::Builder::getIntegerType((mlir::Builder *)&v15, 1u);
  return 1;
}

uint64_t mlir::complex::EqualOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  const void **v14;
  __int16 v15;
  _QWORD v16[3];
  void *v17;
  uint64_t v18;
  void *v19;
  _QWORD *v20;
  void *__p;
  _QWORD *v22;
  char v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  if (!mlir::complex::__mlir_ods_local_type_constraint_ComplexOps0(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::complex::__mlir_ods_local_type_constraint_ComplexOps0(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  v2 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  if (!mlir::complex::__mlir_ods_local_type_constraint_ComplexOps3(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0))return 0;
  if ((*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8) == (*(_QWORD *)(*(_QWORD *)((*this)[9] + 56)
                                                                                              + 8) & 0xFFFFFFFFFFFFFFF8))
    return 1;
  v14 = (const void **)"failed to verify that all of {lhs, rhs} have same type";
  v15 = 259;
  mlir::OpState::emitOpError(this, &v14, (uint64_t)v16);
  v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v16);
  if (v16[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v16);
  if (v23)
  {
    v5 = __p;
    if (__p)
    {
      v6 = v22;
      v7 = __p;
      if (v22 != __p)
      {
        do
          v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
        while (v6 != v5);
        v7 = __p;
      }
      v22 = v5;
      operator delete(v7);
    }
    v8 = v19;
    if (v19)
    {
      v9 = v20;
      v10 = v19;
      if (v20 != v19)
      {
        do
        {
          v12 = *--v9;
          v11 = v12;
          *v9 = 0;
          if (v12)
            MEMORY[0x20BD002D4](v11, 0x1000C8077774924);
        }
        while (v9 != v8);
        v10 = v19;
      }
      v20 = v8;
      operator delete(v10);
    }
    if (v17 != &v18)
      free(v17);
  }
  return v4;
}

uint64_t mlir::complex::__mlir_ods_local_type_constraint_ComplexOps3(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t v14;
  int *v15;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  int *v20;
  char *v21;
  char *v22;
  __int128 v23;
  int *v24;
  char *v25;
  char *v26;
  __int128 v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v37;
  unint64_t v38;
  BOOL v39;
  unint64_t v40;
  BOOL v41;
  unint64_t v42;
  int64_t v43;
  int64_t v44;
  int64_t v45;
  int64_t v46;
  const void **v47[4];
  __int16 v48;
  uint64_t v49;
  int v50;
  const char *v51;
  uint64_t v52;
  _QWORD v53[3];
  void *v54;
  unsigned int v55;
  unsigned int v56;
  _BYTE v57[96];
  void *v58;
  _QWORD *v59;
  void *__p;
  _QWORD *v61;
  char v62;
  uint64_t v63;

  v63 = *MEMORY[0x24BDAC8D0];
  v49 = a2;
  v9 = 1;
  if (!mlir::Type::isSignlessInteger((mlir::Type *)&v49, 1))
  {
    v48 = 261;
    v47[0] = a3;
    v47[1] = a4;
    mlir::Operation::emitOpError(a1, v47, (uint64_t)v53);
    if (v53[0])
    {
      v50 = 3;
      v51 = " #";
      v52 = 2;
      v10 = &v50;
      v11 = (char *)v54;
      if (v55 >= v56)
      {
        v37 = v55 + 1;
        if (v54 <= &v50 && (char *)v54 + 24 * v55 > (char *)&v50)
        {
          v43 = (char *)&v50 - (_BYTE *)v54;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v37, 24);
          v11 = (char *)v54;
          v10 = (int *)((char *)v54 + v43);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v37, 24);
          v10 = &v50;
          v11 = (char *)v54;
        }
      }
      v12 = &v11[24 * v55];
      v13 = *(_OWORD *)v10;
      *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
      *(_OWORD *)v12 = v13;
      v14 = ++v55;
      if (v53[0])
      {
        v50 = 5;
        v51 = (const char *)a5;
        v15 = &v50;
        v16 = (char *)v54;
        if (v14 >= v56)
        {
          v38 = v14 + 1;
          v39 = (char *)v54 + 24 * v14 > (char *)&v50;
          if (v54 <= &v50 && v39)
          {
            v44 = (char *)&v50 - (_BYTE *)v54;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v38, 24);
            v16 = (char *)v54;
            v15 = (int *)((char *)v54 + v44);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v38, 24);
            v15 = &v50;
            v16 = (char *)v54;
          }
        }
        v17 = &v16[24 * v55];
        v18 = *(_OWORD *)v15;
        *((_QWORD *)v17 + 2) = *((_QWORD *)v15 + 2);
        *(_OWORD *)v17 = v18;
        v19 = ++v55;
        if (v53[0])
        {
          v50 = 3;
          v51 = " must be 1-bit signless integer, but got ";
          v52 = 41;
          v20 = &v50;
          v21 = (char *)v54;
          if (v19 >= v56)
          {
            v40 = v19 + 1;
            v41 = (char *)v54 + 24 * v19 > (char *)&v50;
            if (v54 <= &v50 && v41)
            {
              v45 = (char *)&v50 - (_BYTE *)v54;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v40, 24);
              v21 = (char *)v54;
              v20 = (int *)((char *)v54 + v45);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v40, 24);
              v20 = &v50;
              v21 = (char *)v54;
            }
          }
          v22 = &v21[24 * v55];
          v23 = *(_OWORD *)v20;
          *((_QWORD *)v22 + 2) = *((_QWORD *)v20 + 2);
          *(_OWORD *)v22 = v23;
          ++v55;
          if (v53[0])
          {
            v24 = &v50;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v50, v49);
            v25 = (char *)v54;
            if (v55 >= v56)
            {
              v42 = v55 + 1;
              if (v54 <= &v50 && (char *)v54 + 24 * v55 > (char *)&v50)
              {
                v46 = (char *)&v50 - (_BYTE *)v54;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v42, 24);
                v25 = (char *)v54;
                v24 = (int *)((char *)v54 + v46);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v42, 24);
                v24 = &v50;
                v25 = (char *)v54;
              }
            }
            v26 = &v25[24 * v55];
            v27 = *(_OWORD *)v24;
            *((_QWORD *)v26 + 2) = *((_QWORD *)v24 + 2);
            *(_OWORD *)v26 = v27;
            ++v55;
          }
        }
      }
    }
    v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v53);
    if (v53[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v53);
    if (v62)
    {
      v28 = __p;
      if (__p)
      {
        v29 = v61;
        v30 = __p;
        if (v61 != __p)
        {
          do
            v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
          while (v29 != v28);
          v30 = __p;
        }
        v61 = v28;
        operator delete(v30);
      }
      v31 = v58;
      if (v58)
      {
        v32 = v59;
        v33 = v58;
        if (v59 != v58)
        {
          do
          {
            v35 = *--v32;
            v34 = v35;
            *v32 = 0;
            if (v35)
              MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
          }
          while (v32 != v31);
          v33 = v58;
        }
        v59 = v31;
        operator delete(v33);
      }
      if (v54 != v57)
        free(v54);
    }
  }
  return v9;
}

BOOL mlir::complex::EqualOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  mlir::Builder *v5;
  uint64_t v6;
  uint64_t __src;
  _QWORD v9[2];
  uint64_t v10[2];
  uint64_t v11;
  _QWORD v12[4];
  _QWORD v13[5];

  v13[4] = *MEMORY[0x24BDAC8D0];
  memset(v13, 0, 24);
  v10[0] = (uint64_t)v13;
  v10[1] = 1;
  memset(v12, 0, 24);
  v11 = 0;
  v9[0] = &v11;
  v9[1] = 1;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v13, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v12, 1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112)
    && (*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1)
    && (__src = 0, mlir::AsmParser::parseType<mlir::ComplexType>(a1, &__src))
    && (v11 = __src,
        v5 = (mlir::Builder *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1),
        __src = mlir::Builder::getIntegerType(v5, 1u),
        mlir::OperationState::addTypes(a2, &__src, 1),
        v6 = a2 + 16,
        mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v10, v9, v4, v6)))
  {
    return (*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, uint64_t))(*(_QWORD *)a1 + 696))(a1, v12, *(_QWORD *)v9[0], v6) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::complex::detail::ExpOpGenericAdaptorBase::ExpOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "complex.exp", 11, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::ExpOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::ExpOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[457];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::ExpOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15[2];
  uint64_t v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v16 = 0;
  v13[0] = &v16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0;
  if (v14)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v5 = v14;
  }
LABEL_6:
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  v6 = *(_QWORD *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  v7 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ExpOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11))
    return 0;
  v8 = v11[0];
  v16 = v11[0];
  v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    v8 = v16;
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

BOOL mlir::complex::Expm1Op::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties]";
        v15 = 110;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[459];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::Expm1Op::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15[2];
  uint64_t v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v16 = 0;
  v13[0] = &v16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0;
  if (v14)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v5 = v14;
  }
LABEL_6:
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  v6 = *(_QWORD *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  v7 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::Expm1Op::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11))
    return 0;
  v8 = v11[0];
  v16 = v11[0];
  v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    v8 = v16;
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

uint64_t mlir::complex::detail::ImOpGenericAdaptorBase::ImOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "complex.im", 10, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::ImOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ImOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::ImOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ImOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ImOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ImOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ImOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::ImOpGenericAdaptorBase::Properties]";
        v15 = 107;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::ImOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[461];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::ImOp::parse(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v13;
  _QWORD v14[4];
  __int16 v15;
  uint64_t v16;
  _QWORD v17[2];
  uint64_t v18;
  uint64_t v19[2];
  _QWORD __src[24];
  uint64_t v21;
  _QWORD v22[5];

  v22[4] = *MEMORY[0x24BDAC8D0];
  memset(v22, 0, 24);
  v19[0] = (uint64_t)v22;
  v19[1] = 1;
  v17[1] = 1;
  v18 = 0;
  v21 = 0;
  v17[0] = &v21;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v22, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v18, 0))return 0;
  if (v18)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ImOpGenericAdaptorBase::Properties>(a2);
    *v5 = v18;
  }
LABEL_6:
  v14[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
    return 0;
  v6 = a2[1];
  __src[0] = a1;
  __src[1] = v14;
  __src[2] = a2;
  v7 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ImOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  __src[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, __src))
    return 0;
  v21 = __src[0];
  v16 = __src[0];
  if (*(_UNKNOWN **)(*(_QWORD *)__src[0] + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id
    && ((v13 = *(void **)(*(_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)__src) + 136),
         v13 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id)
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id))
  {
    v14[0] = v21;
    __src[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v14);
    mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
    return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v19, v17, v4, (uint64_t)(a2 + 2)) != 0;
  }
  else
  {
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v15 = 257;
    (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(__src, a1, v8, v14);
    v9 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)__src, "'complex' must be complex type with floating-point elements, but got ");
    v10 = mlir::InFlightDiagnostic::append<mlir::Type &>(v9, &v16);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v10);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)__src);
  }
  return v11;
}

BOOL mlir::complex::Log1pOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties]";
        v15 = 110;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[463];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::Log1pOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15[2];
  uint64_t v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v16 = 0;
  v13[0] = &v16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0;
  if (v14)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v5 = v14;
  }
LABEL_6:
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  v6 = *(_QWORD *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  v7 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::Log1pOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11))
    return 0;
  v8 = v11[0];
  v16 = v11[0];
  v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    v8 = v16;
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

uint64_t mlir::complex::detail::LogOpGenericAdaptorBase::LogOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "complex.log", 11, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::LogOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::LogOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::LogOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::LogOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::LogOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::LogOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::LogOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::LogOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::LogOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[465];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::LogOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15[2];
  uint64_t v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v16 = 0;
  v13[0] = &v16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0;
  if (v14)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::LogOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v5 = v14;
  }
LABEL_6:
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  v6 = *(_QWORD *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  v7 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::LogOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11))
    return 0;
  v8 = v11[0];
  v16 = v11[0];
  v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    v8 = v16;
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

uint64_t mlir::complex::detail::MulOpGenericAdaptorBase::MulOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "complex.mul", 11, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::MulOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::MulOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::MulOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::MulOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::MulOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::MulOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::MulOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::MulOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::MulOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[467];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::MulOp::parse(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v9;
  uint64_t v10;
  _QWORD __src[3];
  _QWORD v12[4];
  _QWORD v13[5];

  v13[4] = *MEMORY[0x24BDAC8D0];
  memset(v13, 0, 24);
  memset(v12, 0, 24);
  v10 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v13, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v12, 1))
    return 0;
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
  {
    if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v10, 0))return 0;
    if (v10)
    {
      v4 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::MulOpGenericAdaptorBase::Properties>(a2);
      *v4 = v10;
    }
  }
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
  {
    v5 = a2[1];
    __src[0] = a1;
    __src[1] = &v9;
    __src[2] = a2;
    v6 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v5 + 96));
    if (!v6
      || mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v6, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::MulOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))
    {
      if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
      {
        v9 = 0;
        if (mlir::AsmParser::parseType<mlir::ComplexType>(a1, &v9))
        {
          __src[0] = v9;
          mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
          v7 = a2 + 2;
          if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v13, __src[0], v7))
          {
            return (*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v12, __src[0], v7) != 0;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t mlir::complex::detail::NegOpGenericAdaptorBase::NegOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "complex.neg", 11, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::NegOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::NegOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::NegOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::NegOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::NegOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[469];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::NegOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15[2];
  uint64_t v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v16 = 0;
  v13[0] = &v16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0;
  if (v14)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v5 = v14;
  }
LABEL_6:
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  v6 = *(_QWORD *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  v7 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::NegOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11))
    return 0;
  v8 = v11[0];
  v16 = v11[0];
  v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    v8 = v16;
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

BOOL mlir::complex::NotEqualOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  mlir::Builder *v5;
  uint64_t v6;
  uint64_t __src;
  _QWORD v9[2];
  uint64_t v10[2];
  uint64_t v11;
  _QWORD v12[4];
  _QWORD v13[5];

  v13[4] = *MEMORY[0x24BDAC8D0];
  memset(v13, 0, 24);
  v10[0] = (uint64_t)v13;
  v10[1] = 1;
  memset(v12, 0, 24);
  v11 = 0;
  v9[0] = &v11;
  v9[1] = 1;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v13, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v12, 1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112)
    && (*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1)
    && (__src = 0, mlir::AsmParser::parseType<mlir::ComplexType>(a1, &__src))
    && (v11 = __src,
        v5 = (mlir::Builder *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1),
        __src = mlir::Builder::getIntegerType(v5, 1u),
        mlir::OperationState::addTypes(a2, &__src, 1),
        v6 = a2 + 16,
        mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v10, v9, v4, v6)))
  {
    return (*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, uint64_t))(*(_QWORD *)a1 + 696))(a1, v12, *(_QWORD *)v9[0], v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::complex::PowOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::PowOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::PowOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::PowOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::PowOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[471];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::PowOp::parse(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v9;
  uint64_t v10;
  _QWORD __src[3];
  _QWORD v12[4];
  _QWORD v13[5];

  v13[4] = *MEMORY[0x24BDAC8D0];
  memset(v13, 0, 24);
  memset(v12, 0, 24);
  v10 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v13, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v12, 1))
    return 0;
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
  {
    if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v10, 0))return 0;
    if (v10)
    {
      v4 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(a2);
      *v4 = v10;
    }
  }
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
  {
    v5 = a2[1];
    __src[0] = a1;
    __src[1] = &v9;
    __src[2] = a2;
    v6 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v5 + 96));
    if (!v6
      || mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v6, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::PowOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))
    {
      if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
      {
        v9 = 0;
        if (mlir::AsmParser::parseType<mlir::ComplexType>(a1, &v9))
        {
          __src[0] = v9;
          mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
          v7 = a2 + 2;
          if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v13, __src[0], v7))
          {
            return (*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v12, __src[0], v7) != 0;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t mlir::complex::detail::ReOpGenericAdaptorBase::ReOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "complex.re", 10, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::ReOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ReOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ReOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::ReOpGenericAdaptorBase::Properties]";
        v15 = 107;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::ReOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[473];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::ReOp::parse(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v13;
  _QWORD v14[4];
  __int16 v15;
  uint64_t v16;
  _QWORD v17[2];
  uint64_t v18;
  uint64_t v19[2];
  _QWORD __src[24];
  uint64_t v21;
  _QWORD v22[5];

  v22[4] = *MEMORY[0x24BDAC8D0];
  memset(v22, 0, 24);
  v19[0] = (uint64_t)v22;
  v19[1] = 1;
  v17[1] = 1;
  v18 = 0;
  v21 = 0;
  v17[0] = &v21;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v22, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v18, 0))return 0;
  if (v18)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(a2);
    *v5 = v18;
  }
LABEL_6:
  v14[0] = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
    return 0;
  v6 = a2[1];
  __src[0] = a1;
  __src[1] = v14;
  __src[2] = a2;
  v7 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ReOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  __src[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, __src))
    return 0;
  v21 = __src[0];
  v16 = __src[0];
  if (*(_UNKNOWN **)(*(_QWORD *)__src[0] + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id
    && ((v13 = *(void **)(*(_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)__src) + 136),
         v13 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id)
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id))
  {
    v14[0] = v21;
    __src[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v14);
    mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
    return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v19, v17, v4, (uint64_t)(a2 + 2)) != 0;
  }
  else
  {
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v15 = 257;
    (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(__src, a1, v8, v14);
    v9 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)__src, "'complex' must be complex type with floating-point elements, but got ");
    v10 = mlir::InFlightDiagnostic::append<mlir::Type &>(v9, &v16);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v10);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)__src);
  }
  return v11;
}

BOOL mlir::complex::RsqrtOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties]";
        v15 = 110;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[475];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::RsqrtOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15[2];
  uint64_t v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v16 = 0;
  v13[0] = &v16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0;
  if (v14)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v5 = v14;
  }
LABEL_6:
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  v6 = *(_QWORD *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  v7 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::RsqrtOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11))
    return 0;
  v8 = v11[0];
  v16 = v11[0];
  v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    v8 = v16;
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

BOOL mlir::complex::SignOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SignOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SignOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::SignOpGenericAdaptorBase::Properties]";
        v15 = 109;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::SignOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[477];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::SignOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15[2];
  uint64_t v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v16 = 0;
  v13[0] = &v16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0;
  if (v14)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v5 = v14;
  }
LABEL_6:
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  v6 = *(_QWORD *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  v7 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SignOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11))
    return 0;
  v8 = v11[0];
  v16 = v11[0];
  v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    v8 = v16;
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

BOOL mlir::complex::SinOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SinOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SinOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::SinOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::SinOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[479];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::SinOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15[2];
  uint64_t v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v16 = 0;
  v13[0] = &v16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0;
  if (v14)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v5 = v14;
  }
LABEL_6:
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  v6 = *(_QWORD *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  v7 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SinOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11))
    return 0;
  v8 = v11[0];
  v16 = v11[0];
  v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    v8 = v16;
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

BOOL mlir::complex::SqrtOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties]";
        v15 = 109;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[481];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::SqrtOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15[2];
  uint64_t v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v16 = 0;
  v13[0] = &v16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0;
  if (v14)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v5 = v14;
  }
LABEL_6:
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  v6 = *(_QWORD *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  v7 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SqrtOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11))
    return 0;
  v8 = v11[0];
  v16 = v11[0];
  v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    v8 = v16;
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

uint64_t mlir::complex::detail::SubOpGenericAdaptorBase::SubOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "complex.sub", 11, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::SubOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SubOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SubOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::SubOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::SubOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[483];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::SubOp::parse(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v9;
  uint64_t v10;
  _QWORD __src[3];
  _QWORD v12[4];
  _QWORD v13[5];

  v13[4] = *MEMORY[0x24BDAC8D0];
  memset(v13, 0, 24);
  memset(v12, 0, 24);
  v10 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v13, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1))
    return 0;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v12, 1))
    return 0;
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
  {
    if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v10, 0))return 0;
    if (v10)
    {
      v4 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(a2);
      *v4 = v10;
    }
  }
  v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
  {
    v5 = a2[1];
    __src[0] = a1;
    __src[1] = &v9;
    __src[2] = a2;
    v6 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v5 + 96));
    if (!v6
      || mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v6, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SubOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))
    {
      if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
      {
        v9 = 0;
        if (mlir::AsmParser::parseType<mlir::ComplexType>(a1, &v9))
        {
          __src[0] = v9;
          mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
          v7 = a2 + 2;
          if ((*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v13, __src[0], v7))
          {
            return (*(unsigned __int8 (**)(uint64_t, _QWORD *, _QWORD, _QWORD *))(*(_QWORD *)a1 + 696))(a1, v12, __src[0], v7) != 0;
          }
        }
      }
    }
  }
  return 0;
}

BOOL mlir::complex::TanOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::TanOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::TanOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[485];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::TanOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15[2];
  uint64_t v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v16 = 0;
  v13[0] = &v16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0;
  if (v14)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v5 = v14;
  }
LABEL_6:
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  v6 = *(_QWORD *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  v7 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::TanOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11))
    return 0;
  v8 = v11[0];
  v16 = v11[0];
  v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    v8 = v16;
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

BOOL mlir::complex::TanhOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451A000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451A000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::TanhOpGenericAdaptorBase::Properties]";
        v15 = 109;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451A000;
      }
    }
    a1[33] = v5[487];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::TanhOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[3];
  uint64_t v12;
  _QWORD v13[2];
  uint64_t v14;
  uint64_t v15[2];
  uint64_t v16;
  _QWORD v17[5];

  v17[4] = *MEMORY[0x24BDAC8D0];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  v14 = 0;
  v16 = 0;
  v13[0] = &v16;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v17, 1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 376))(a1, "fastmath", 8))
    goto LABEL_6;
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0;
  if (v14)
  {
    v5 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v5 = v14;
  }
LABEL_6:
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    return 0;
  v6 = *(_QWORD *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  v7 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::TanhOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11))
    return 0;
  v8 = v11[0];
  v16 = v11[0];
  v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    v8 = v16;
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::__mlir_ods_local_attr_constraint_ComplexOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::__mlir_ods_local_attr_constraint_ComplexOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void mlir::RewritePatternSet::addImpl<ArithBitcast,mlir::MLIRContext *&>(_QWORD *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  unint64_t v18;
  unint64_t v19;
  const char *v20;
  unint64_t v21;
  uint64_t v22;
  const char *v23;
  unint64_t v24;
  uint64_t v25;
  const char *v26;
  unint64_t v27;

  v8 = operator new();
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v26, 1);
  mlir::Pattern::Pattern(v8 + 8, (uint64_t)"complex.bitcast", 15, (__int16)v26, v9, 0, 0);
  *(_QWORD *)v8 = &unk_24C016210;
  v25 = v8;
  if (*(_QWORD *)(v8 + 72))
  {
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
      goto LABEL_3;
  }
  else
  {
    v26 = "StringRef llvm::getTypeName() [DesiredTypeName = ArithBitcast]";
    v27 = 62;
    v18 = llvm::StringRef::find((uint64_t *)&v26, "DesiredTypeName = ", 0x12uLL, 0);
    if (v27 >= v18)
      v19 = v18;
    else
      v19 = v27;
    v20 = &v26[v19];
    v21 = v27 - v19;
    if (v27 - v19 >= 0x12)
      v22 = 18;
    else
      v22 = v27 - v19;
    v23 = &v20[v22];
    v24 = v21 - v22;
    if (v24 >= v24 - 1)
      --v24;
    *(_QWORD *)(v8 + 64) = v23;
    *(_QWORD *)(v8 + 72) = v24;
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
    {
LABEL_3:
      if (!a3)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(v8 + 80, (void *)(v8 + 96), v12, 16);
  LODWORD(v11) = *(_DWORD *)(v8 + 88);
  if (a3)
  {
LABEL_4:
    memcpy((void *)(*(_QWORD *)(v8 + 80) + 16 * v11), a2, v10);
    LODWORD(v11) = *(_DWORD *)(v8 + 88);
  }
LABEL_5:
  *(_DWORD *)(v8 + 88) = v11 + (v10 >> 4);
  v13 = (uint64_t *)a1[2];
  if ((unint64_t)v13 >= a1[3])
  {
    v14 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, &v25);
    v15 = v25;
    a1[2] = v14;
    v25 = 0;
    if (v15)
    {
      v16 = *(void **)(v15 + 80);
      if (v16 != (void *)(v15 + 96))
        free(v16);
      v17 = *(void **)(v15 + 32);
      if (v17 != (void *)(v15 + 48))
        free(v17);
      MEMORY[0x20BD002F8](v15, 0x10D1C403AF06869);
    }
  }
  else
  {
    *v13 = v8;
    a1[2] = v13 + 1;
  }
}

void mlir::RewritePatternSet::addImpl<MergeComplexBitcast,mlir::MLIRContext *&>(_QWORD *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  unint64_t v18;
  unint64_t v19;
  const char *v20;
  unint64_t v21;
  uint64_t v22;
  const char *v23;
  unint64_t v24;
  uint64_t v25;
  const char *v26;
  unint64_t v27;

  v8 = operator new();
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v26, 1);
  mlir::Pattern::Pattern(v8 + 8, (uint64_t)"complex.bitcast", 15, (__int16)v26, v9, 0, 0);
  *(_QWORD *)v8 = &unk_24C01E8F0;
  v25 = v8;
  if (*(_QWORD *)(v8 + 72))
  {
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
      goto LABEL_3;
  }
  else
  {
    v26 = "StringRef llvm::getTypeName() [DesiredTypeName = MergeComplexBitcast]";
    v27 = 69;
    v18 = llvm::StringRef::find((uint64_t *)&v26, "DesiredTypeName = ", 0x12uLL, 0);
    if (v27 >= v18)
      v19 = v18;
    else
      v19 = v27;
    v20 = &v26[v19];
    v21 = v27 - v19;
    if (v27 - v19 >= 0x12)
      v22 = 18;
    else
      v22 = v27 - v19;
    v23 = &v20[v22];
    v24 = v21 - v22;
    if (v24 >= v24 - 1)
      --v24;
    *(_QWORD *)(v8 + 64) = v23;
    *(_QWORD *)(v8 + 72) = v24;
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
    {
LABEL_3:
      if (!a3)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(v8 + 80, (void *)(v8 + 96), v12, 16);
  LODWORD(v11) = *(_DWORD *)(v8 + 88);
  if (a3)
  {
LABEL_4:
    memcpy((void *)(*(_QWORD *)(v8 + 80) + 16 * v11), a2, v10);
    LODWORD(v11) = *(_DWORD *)(v8 + 88);
  }
LABEL_5:
  *(_DWORD *)(v8 + 88) = v11 + (v10 >> 4);
  v13 = (uint64_t *)a1[2];
  if ((unint64_t)v13 >= a1[3])
  {
    v14 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, &v25);
    v15 = v25;
    a1[2] = v14;
    v25 = 0;
    if (v15)
    {
      v16 = *(void **)(v15 + 80);
      if (v16 != (void *)(v15 + 96))
        free(v16);
      v17 = *(void **)(v15 + 32);
      if (v17 != (void *)(v15 + 48))
        free(v17);
      MEMORY[0x20BD002F8](v15, 0x10D1C403AF06869);
    }
  }
  else
  {
    *v13 = v8;
    a1[2] = v13 + 1;
  }
}

void mlir::RewritePatternSet::addImpl<MergeArithBitcast,mlir::MLIRContext *&>(_QWORD *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  unint64_t v18;
  unint64_t v19;
  const char *v20;
  unint64_t v21;
  uint64_t v22;
  const char *v23;
  unint64_t v24;
  uint64_t v25;
  const char *v26;
  unint64_t v27;

  v8 = operator new();
  v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v26, 1);
  mlir::Pattern::Pattern(v8 + 8, (uint64_t)"arith.bitcast", 13, (__int16)v26, v9, 0, 0);
  *(_QWORD *)v8 = &unk_24C01C7E8;
  v25 = v8;
  if (*(_QWORD *)(v8 + 72))
  {
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
      goto LABEL_3;
  }
  else
  {
    v26 = "StringRef llvm::getTypeName() [DesiredTypeName = MergeArithBitcast]";
    v27 = 67;
    v18 = llvm::StringRef::find((uint64_t *)&v26, "DesiredTypeName = ", 0x12uLL, 0);
    if (v27 >= v18)
      v19 = v18;
    else
      v19 = v27;
    v20 = &v26[v19];
    v21 = v27 - v19;
    if (v27 - v19 >= 0x12)
      v22 = 18;
    else
      v22 = v27 - v19;
    v23 = &v20[v22];
    v24 = v21 - v22;
    if (v24 >= v24 - 1)
      --v24;
    *(_QWORD *)(v8 + 64) = v23;
    *(_QWORD *)(v8 + 72) = v24;
    v10 = 16 * a3;
    v11 = *(unsigned int *)(v8 + 88);
    v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *(unsigned int *)(v8 + 92))
    {
LABEL_3:
      if (!a3)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(v8 + 80, (void *)(v8 + 96), v12, 16);
  LODWORD(v11) = *(_DWORD *)(v8 + 88);
  if (a3)
  {
LABEL_4:
    memcpy((void *)(*(_QWORD *)(v8 + 80) + 16 * v11), a2, v10);
    LODWORD(v11) = *(_DWORD *)(v8 + 88);
  }
LABEL_5:
  *(_DWORD *)(v8 + 88) = v11 + (v10 >> 4);
  v13 = (uint64_t *)a1[2];
  if ((unint64_t)v13 >= a1[3])
  {
    v14 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, &v25);
    v15 = v25;
    a1[2] = v14;
    v25 = 0;
    if (v15)
    {
      v16 = *(void **)(v15 + 80);
      if (v16 != (void *)(v15 + 96))
        free(v16);
      v17 = *(void **)(v15 + 32);
      if (v17 != (void *)(v15 + 48))
        free(v17);
      MEMORY[0x20BD002F8](v15, 0x10D1C403AF06869);
    }
  }
  else
  {
    *v13 = v8;
    a1[2] = v13 + 1;
  }
}

void ArithBitcast::~ArithBitcast(ArithBitcast *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::BitcastOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::BitcastOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::BitcastOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t ArithBitcast::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  ZinIrHalH13g *v6;
  uint64_t v8;
  unint64_t v9;

  v3 = *(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(_QWORD *)v3 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id
    || *(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8)
                    + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
  {
    return 0;
  }
  v8 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  v9 = v3;
  v6 = mlir::OpBuilder::create<mlir::arith::BitcastOp,mlir::Type,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v9, &v8);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v6);
  return 1;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::arith::BitcastOp,mlir::Type,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  ZinIrHalH13g *v11;
  ZinIrHalH13g *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x24BDAC8D0];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"arith.bitcast", (const unsigned __int8 *)0xD, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"arith.bitcast";
    v17[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::BitcastOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void MergeComplexBitcast::~MergeComplexBitcast(MergeComplexBitcast *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t MergeComplexBitcast::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unint64_t v6;
  ZinIrHalH13g *v7;
  uint64_t v8;
  unint64_t v9;

  v9 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v9);
  if (result
    && *(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::BitcastOp,void>::id)
  {
    goto LABEL_7;
  }
  v9 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v9);
  if (!result)
    return result;
  if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::BitcastOp,void>::id)
  {
LABEL_7:
    v6 = *(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
    v8 = *(_QWORD *)(*(_QWORD *)(result + 72) + 24);
    v9 = v6;
    v7 = mlir::OpBuilder::create<mlir::complex::BitcastOp,mlir::Type,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v9, &v8);
    (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v7);
    return 1;
  }
  return 0;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::complex::BitcastOp,mlir::Type,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  unsigned int v12;
  ZinIrHalH13g *v13;
  ZinIrHalH13g *v14;
  uint64_t v16;
  const char *v17;
  __int16 v18;
  uint64_t v19[4];
  __int16 v20;
  _QWORD v21[8];
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  _QWORD v25[29];

  v25[28] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"complex.bitcast", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    v20 = 1283;
    v19[2] = (uint64_t)"complex.bitcast";
    v19[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  v11 = *a3;
  v19[0] = *a4;
  mlir::OperationState::addOperands((uint64_t)v21, (uint64_t)v19, 1);
  v12 = v23;
  if (v23 >= v24)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v22, v25, v23 + 1, 8);
    v12 = v23;
  }
  *(_QWORD *)(v22 + 8 * v12) = v11;
  ++v23;
  v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((_QWORD *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::BitcastOp,void>::id)
    v14 = v13;
  else
    v14 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void MergeArithBitcast::~MergeArithBitcast(MergeArithBitcast *this)
{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
}

{
  char *v2;
  char *v3;

  v2 = (char *)*((_QWORD *)this + 10);
  if (v2 != (char *)this + 96)
    free(v2);
  v3 = (char *)*((_QWORD *)this + 4);
  if (v3 != (char *)this + 48)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::arith::BitcastOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::arith::BitcastOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::arith::BitcastOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t MergeArithBitcast::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  unint64_t v6;
  ZinIrHalH13g *v7;
  uint64_t v8;
  unint64_t v9;

  v9 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v9);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::BitcastOp,void>::id)
    {
      v6 = *(_QWORD *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
      v8 = *(_QWORD *)(*(_QWORD *)(result + 72) + 24);
      v9 = v6;
      v7 = mlir::OpBuilder::create<mlir::complex::BitcastOp,mlir::Type,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(_QWORD *)(a2 + 24), (uint64_t *)&v9, &v8);
      (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a3 + 32))(a3, a2, v7);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

_QWORD *`anonymous namespace'::FoldComponentNeg<mlir::complex::ImOp,1>::~FoldComponentNeg(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void `anonymous namespace'::FoldComponentNeg<mlir::complex::ImOp,1>::~FoldComponentNeg(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::ImOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::ImOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::ImOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t `anonymous namespace'::FoldComponentNeg<mlir::complex::ImOp,1>::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t Value;
  ZinIrHalH13g *v8;
  unint64_t v9;
  uint64_t v10;

  v10 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v10);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::NegOp,void>::id)
    {
      v10 = *(_QWORD *)(*(_QWORD *)(result + 72) + 24);
      result = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (result)
      {
        v6 = result;
        if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::CreateOp,void>::id)
        {
          v9 = *(_QWORD *)(result - 8) & 0xFFFFFFFFFFFFFFF8;
          Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v9);
          v9 = *(_QWORD *)(*(_QWORD *)(v6 + 72) + 56);
          v10 = Value;
          v8 = mlir::OpBuilder::create<mlir::arith::NegFOp,mlir::Type &,mlir::Value>(a3 + 1, *(_QWORD *)(a2 + 24), &v10, (uint64_t *)&v9);
          (*((void (**)(mlir::MLIRContext **, uint64_t, ZinIrHalH13g *))*a3 + 4))(a3, a2, v8);
          return 1;
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::arith::NegFOp,mlir::Type &,mlir::Value>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  ZinIrHalH13g *v11;
  ZinIrHalH13g *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x24BDAC8D0];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"arith.negf", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"arith.negf";
    v17[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::arith::NegFOp::build(a1, (uint64_t)v19, *a3, *a4, 0);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::NegFOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

_QWORD *`anonymous namespace'::FoldComponentNeg<mlir::complex::ReOp,0>::~FoldComponentNeg(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  return a1;
}

void `anonymous namespace'::FoldComponentNeg<mlir::complex::ReOp,0>::~FoldComponentNeg(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[10];
  if (v2 != a1 + 12)
    free(v2);
  v3 = (_QWORD *)a1[4];
  if (v3 != a1 + 6)
    free(v3);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::ReOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 48))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::ReOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::ReOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

uint64_t `anonymous namespace'::FoldComponentNeg<mlir::complex::ReOp,0>::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t Value;
  ZinIrHalH13g *v8;
  unint64_t v9;
  uint64_t v10;

  v10 = *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24);
  result = mlir::Value::getDefiningOp((mlir::Value *)&v10);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::NegOp,void>::id)
    {
      v10 = *(_QWORD *)(*(_QWORD *)(result + 72) + 24);
      result = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (result)
      {
        v6 = result;
        if (*(_UNKNOWN **)(*(_QWORD *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::CreateOp,void>::id)
        {
          v9 = *(_QWORD *)(result - 8) & 0xFFFFFFFFFFFFFFF8;
          Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v9);
          v9 = *(_QWORD *)(*(_QWORD *)(v6 + 72) + 24);
          v10 = Value;
          v8 = mlir::OpBuilder::create<mlir::arith::NegFOp,mlir::Type &,mlir::Value>(a3 + 1, *(_QWORD *)(a2 + 24), &v10, (uint64_t *)&v9);
          (*((void (**)(mlir::MLIRContext **, uint64_t, ZinIrHalH13g *))*a3 + 4))(a3, a2, v8);
          return 1;
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::AbsOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

uint64_t mlir::AsmParser::parseType<mlir::ComplexType>(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  uint64_t v18;
  _QWORD v19[3];
  void *v20;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  void *__p;
  _QWORD *v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v18 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 504))(a1, &v18))
    return 0;
  v5 = v18;
  if (*(_UNKNOWN **)(*(_QWORD *)v18 + 136) != &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    v5 = 0;
  *a2 = v5;
  if (v5)
    return 1;
  v16 = "invalid kind of type specified";
  v17 = 259;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v19, a1, v4, &v16);
  v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
  if (v19[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
  if (v26)
  {
    v8 = __p;
    if (__p)
    {
      v9 = v25;
      v10 = __p;
      if (v25 != __p)
      {
        do
          v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
        while (v9 != v8);
        v10 = __p;
      }
      v25 = v8;
      operator delete(v10);
    }
    v11 = v22;
    if (v22)
    {
      v12 = v23;
      v13 = v22;
      if (v23 != v22)
      {
        do
        {
          v15 = *--v12;
          v14 = v15;
          *v12 = 0;
          if (v15)
            MEMORY[0x20BD002D4](v14, 0x1000C8077774924);
        }
        while (v12 != v11);
        v13 = v22;
      }
      v23 = v11;
      operator delete(v13);
    }
    if (v20 != &v21)
      free(v20);
  }
  return v6;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AddOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AddOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AddOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AddOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::AddOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::AngleOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::Atan2Op::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ConjOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

uint64_t mlir::AsmParser::parseAttribute<mlir::ArrayAttr>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  uint64_t v20;
  _QWORD v21[3];
  void *v22;
  uint64_t v23;
  void *v24;
  _QWORD *v25;
  void *__p;
  _QWORD *v27;
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v20 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *, uint64_t))(*(_QWORD *)a1 + 408))(a1, &v20, a3))
    return 0;
  v7 = v20;
  if (*(_UNKNOWN **)(*(_QWORD *)v20 + 136) != &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    v7 = 0;
  *a2 = v7;
  if (v7)
    return 1;
  v18 = "invalid kind of attribute specified";
  v19 = 259;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v21, a1, v6, &v18);
  v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v21);
  if (v21[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v21);
  if (v28)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v27;
      v12 = __p;
      if (v27 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v27 = v10;
      operator delete(v12);
    }
    v13 = v24;
    if (v24)
    {
      v14 = v25;
      v15 = v24;
      if (v25 != v24)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v24;
      }
      v25 = v13;
      operator delete(v15);
    }
    if (v22 != &v23)
      free(v22);
  }
  return v8;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ConstantOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::CosOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::CosOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::CosOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::CosOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::CosOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::DivOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::DivOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::DivOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::DivOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::DivOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ExpOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::Expm1Op::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ImOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ImOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ImOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ImOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ImOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::Log1pOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::LogOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::LogOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::LogOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::LogOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::LogOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::MulOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::MulOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::MulOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::MulOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::MulOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::NegOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::NegOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::NegOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::PowOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::PowOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::PowOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ReOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ReOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ReOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::RsqrtOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SignOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SignOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SignOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SinOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SinOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SinOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SqrtOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SubOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SubOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SubOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::TanOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2)
{
  if (a2)
    JUMPOUT(0x20BD002F8);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::TanhOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  const void **AttrData;
  const char *v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  char v35[32];
  __int16 v36;
  const void **v37;
  const char *v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void *v44;
  unsigned int v45;
  unsigned int v46;
  _BYTE v47[96];
  void *v48[2];
  uint64_t v49;
  void *__p[2];
  uint64_t v51;
  unsigned __int8 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  v5 = *(_QWORD *)a1[1];
  v36 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)v4 + 24))(&v41, v4, v5, v35);
  if (v41)
  {
    LODWORD(v37) = 3;
    v38 = "'";
    v39 = 1;
    v6 = &v37;
    v7 = (char *)v44;
    if (v45 >= v46)
    {
      v31 = v45 + 1;
      if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
      {
        v33 = (char *)&v37 - (_BYTE *)v44;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v7 = (char *)v44;
        v6 = (const void ***)((char *)v44 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v31, 24);
        v6 = &v37;
        v7 = (char *)v44;
      }
    }
    v8 = &v7[24 * v45];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v45;
  }
  v37 = *(const void ***)(*(_QWORD *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v37);
  v12 = v41;
  if (v41)
  {
    v40 = 261;
    v37 = AttrData;
    v38 = v11;
    mlir::Diagnostic::operator<<((uint64_t)&v42, &v37);
    v12 = v41;
    if (v41)
    {
      LODWORD(v37) = 3;
      v38 = "' op ";
      v39 = 5;
      v13 = &v37;
      v14 = (char *)v44;
      if (v45 >= v46)
      {
        v32 = v45 + 1;
        if (v44 <= &v37 && (char *)v44 + 24 * v45 > (char *)&v37)
        {
          v34 = (char *)&v37 - (_BYTE *)v44;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v14 = (char *)v44;
          v13 = (const void ***)((char *)v44 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v44, v47, v32, 24);
          v13 = &v37;
          v14 = (char *)v44;
        }
      }
      v15 = &v14[24 * v45];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      ++v45;
      v12 = v41;
    }
  }
  *(_QWORD *)a2 = v12;
  *(_BYTE *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 184) = 0;
  if (v52)
  {
    *(_QWORD *)(a2 + 8) = v42;
    v17 = v45;
    *(_DWORD *)(a2 + 16) = v43;
    v18 = (void *)(a2 + 40);
    *(_QWORD *)(a2 + 24) = a2 + 40;
    *(_QWORD *)(a2 + 32) = 0x400000000;
    if (!(_DWORD)v17 || &v41 == (uint64_t *)a2)
    {
      v21 = 1;
      goto LABEL_21;
    }
    v19 = v47;
    if (v44 != v47)
    {
      *(_QWORD *)(a2 + 24) = v44;
      v20 = v46;
      *(_DWORD *)(a2 + 32) = v17;
      *(_DWORD *)(a2 + 36) = v20;
      v44 = v47;
      v46 = 0;
      v21 = 1;
LABEL_20:
      v45 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v48;
      *(_QWORD *)(a2 + 152) = v49;
      v48[0] = 0;
      v48[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(_QWORD *)(a2 + 176) = v51;
      v49 = 0;
      __p[0] = 0;
      __p[1] = 0;
      v51 = 0;
      *(_BYTE *)(a2 + 184) = 1;
      if (v21)
      {
        if (v44 != v47)
          free(v44);
        v52 = 0;
      }
      goto LABEL_25;
    }
    if (v17 < 5)
    {
      v22 = v17;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v17, 24);
      v22 = v45;
      if (!v45)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v17;
        v21 = v52;
        goto LABEL_20;
      }
      v19 = v44;
      v18 = *(void **)(a2 + 24);
    }
    memcpy(v18, v19, 24 * v22);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v41);
  if (v41)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  if (v52)
  {
    v23 = __p[0];
    if (__p[0])
    {
      v24 = __p[1];
      v25 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p[0];
      }
      __p[1] = v23;
      operator delete(v25);
    }
    v26 = v48[0];
    if (v48[0])
    {
      v27 = v48[1];
      v28 = v48[0];
      if (v48[1] != v48[0])
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v48[0];
      }
      v48[1] = v26;
      operator delete(v28);
    }
    if (v44 != v47)
      free(v44);
  }
}

mlir::complex::ComplexDialect *mlir::complex::ComplexDialect::ComplexDialect(mlir::complex::ComplexDialect *this, mlir::MLIRContext *a2)
{
  _QWORD *v3;
  uint64_t *v4;
  uint64_t *v6;

  v3 = (_QWORD *)mlir::Dialect::Dialect((uint64_t)this, (uint64_t)"complex", 7, (uint64_t)a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ComplexDialect,void>::id);
  *v3 = off_24C0529C0;
  v4 = (uint64_t *)v3[4];
  if (!mlir::MLIRContext::isDialectLoading(v4, (uint64_t)"arith", 5))
  {
    v6 = v4;
    mlir::MLIRContext::getOrLoadDialect(v4, (uint64_t)"arith", 5, (uint64_t)&mlir::detail::TypeIDResolver<mlir::arith::ArithDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::arith::ArithDialect * mlir::MLIRContext::getOrLoadDialect<mlir::arith::ArithDialect>(void)::{lambda(void)#1}>, (uint64_t)&v6);
  }
  mlir::Dialect::addOperations<mlir::complex::AbsOp,mlir::complex::AddOp,mlir::complex::AngleOp,mlir::complex::Atan2Op,mlir::complex::BitcastOp,mlir::complex::ConjOp,mlir::complex::ConstantOp,mlir::complex::CosOp,mlir::complex::CreateOp,mlir::complex::DivOp,mlir::complex::EqualOp,mlir::complex::ExpOp,mlir::complex::Expm1Op,mlir::complex::ImOp,mlir::complex::Log1pOp,mlir::complex::LogOp,mlir::complex::MulOp,mlir::complex::NegOp,mlir::complex::NotEqualOp,mlir::complex::PowOp,mlir::complex::ReOp,mlir::complex::RsqrtOp,mlir::complex::SignOp,mlir::complex::SinOp,mlir::complex::SqrtOp,mlir::complex::SubOp,mlir::complex::TanOp,mlir::complex::TanhOp>((uint64_t)this);
  mlir::Dialect::addAttribute<mlir::complex::NumberAttr>((uint64_t)this);
  return this;
}

void mlir::complex::ComplexDialect::~ComplexDialect(llvm **this)
{
  mlir::Dialect::~Dialect(this);
}

void sub_20725A7C4()
{
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::Dialect::addOperations<mlir::complex::AbsOp,mlir::complex::AddOp,mlir::complex::AngleOp,mlir::complex::Atan2Op,mlir::complex::BitcastOp,mlir::complex::ConjOp,mlir::complex::ConstantOp,mlir::complex::CosOp,mlir::complex::CreateOp,mlir::complex::DivOp,mlir::complex::EqualOp,mlir::complex::ExpOp,mlir::complex::Expm1Op,mlir::complex::ImOp,mlir::complex::Log1pOp,mlir::complex::LogOp,mlir::complex::MulOp,mlir::complex::NegOp,mlir::complex::NotEqualOp,mlir::complex::PowOp,mlir::complex::ReOp,mlir::complex::RsqrtOp,mlir::complex::SignOp,mlir::complex::SinOp,mlir::complex::SqrtOp,mlir::complex::SubOp,mlir::complex::TanOp,mlir::complex::TanhOp>(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t result;
  _QWORD *v54;

  v2 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::Model(v2, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::AbsOp::getAttributeNames(void)::attrNames, 1);
  v3 = (uint64_t)v54;
  v54 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::Model(v4, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::AddOp::getAttributeNames(void)::attrNames, 1);
  v5 = (uint64_t)v54;
  v54 = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::Model(v6, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::AngleOp::getAttributeNames(void)::attrNames, 1);
  v7 = (uint64_t)v54;
  v54 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  v8 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::Model(v8, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::Atan2Op::getAttributeNames(void)::attrNames, 1);
  v9 = (uint64_t)v54;
  v54 = 0;
  if (v9)
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
  mlir::RegisteredOperationName::insert<mlir::complex::BitcastOp>(a1);
  v10 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::Model(v10, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::ConjOp::getAttributeNames(void)::attrNames, 1);
  v11 = (uint64_t)v54;
  v54 = 0;
  if (v11)
    (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
  v12 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::Model(v12, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::ConstantOp::getAttributeNames(void)::attrNames, 1);
  v13 = (uint64_t)v54;
  v54 = 0;
  if (v13)
    (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
  v14 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::Model(v14, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::CosOp::getAttributeNames(void)::attrNames, 1);
  v15 = (uint64_t)v54;
  v54 = 0;
  if (v15)
    (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
  mlir::RegisteredOperationName::insert<mlir::complex::CreateOp>(a1);
  v16 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::Model(v16, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::DivOp::getAttributeNames(void)::attrNames, 1);
  v17 = (uint64_t)v54;
  v54 = 0;
  if (v17)
    (*(void (**)(uint64_t))(*(_QWORD *)v17 + 8))(v17);
  v18 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::Model(v18, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, 0, 0);
  v19 = (uint64_t)v54;
  v54 = 0;
  if (v19)
    (*(void (**)(uint64_t))(*(_QWORD *)v19 + 8))(v19);
  v20 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::Model(v20, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::ExpOp::getAttributeNames(void)::attrNames, 1);
  v21 = (uint64_t)v54;
  v54 = 0;
  if (v21)
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 8))(v21);
  v22 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::Model(v22, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::Expm1Op::getAttributeNames(void)::attrNames, 1);
  v23 = (uint64_t)v54;
  v54 = 0;
  if (v23)
    (*(void (**)(uint64_t))(*(_QWORD *)v23 + 8))(v23);
  v24 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::Model(v24, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::ImOp::getAttributeNames(void)::attrNames, 1);
  v25 = (uint64_t)v54;
  v54 = 0;
  if (v25)
    (*(void (**)(uint64_t))(*(_QWORD *)v25 + 8))(v25);
  v26 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::Model(v26, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::Log1pOp::getAttributeNames(void)::attrNames, 1);
  v27 = (uint64_t)v54;
  v54 = 0;
  if (v27)
    (*(void (**)(uint64_t))(*(_QWORD *)v27 + 8))(v27);
  v28 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::Model(v28, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::LogOp::getAttributeNames(void)::attrNames, 1);
  v29 = (uint64_t)v54;
  v54 = 0;
  if (v29)
    (*(void (**)(uint64_t))(*(_QWORD *)v29 + 8))(v29);
  v30 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::Model(v30, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::MulOp::getAttributeNames(void)::attrNames, 1);
  v31 = (uint64_t)v54;
  v54 = 0;
  if (v31)
    (*(void (**)(uint64_t))(*(_QWORD *)v31 + 8))(v31);
  v32 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::Model(v32, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::NegOp::getAttributeNames(void)::attrNames, 1);
  v33 = (uint64_t)v54;
  v54 = 0;
  if (v33)
    (*(void (**)(uint64_t))(*(_QWORD *)v33 + 8))(v33);
  v34 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::Model(v34, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, 0, 0);
  v35 = (uint64_t)v54;
  v54 = 0;
  if (v35)
    (*(void (**)(uint64_t))(*(_QWORD *)v35 + 8))(v35);
  v36 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::Model(v36, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::PowOp::getAttributeNames(void)::attrNames, 1);
  v37 = (uint64_t)v54;
  v54 = 0;
  if (v37)
    (*(void (**)(uint64_t))(*(_QWORD *)v37 + 8))(v37);
  v38 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::Model(v38, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::ReOp::getAttributeNames(void)::attrNames, 1);
  v39 = (uint64_t)v54;
  v54 = 0;
  if (v39)
    (*(void (**)(uint64_t))(*(_QWORD *)v39 + 8))(v39);
  v40 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::Model(v40, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::RsqrtOp::getAttributeNames(void)::attrNames, 1);
  v41 = (uint64_t)v54;
  v54 = 0;
  if (v41)
    (*(void (**)(uint64_t))(*(_QWORD *)v41 + 8))(v41);
  v42 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::Model(v42, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::SignOp::getAttributeNames(void)::attrNames, 1);
  v43 = (uint64_t)v54;
  v54 = 0;
  if (v43)
    (*(void (**)(uint64_t))(*(_QWORD *)v43 + 8))(v43);
  v44 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::Model(v44, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::SinOp::getAttributeNames(void)::attrNames, 1);
  v45 = (uint64_t)v54;
  v54 = 0;
  if (v45)
    (*(void (**)(uint64_t))(*(_QWORD *)v45 + 8))(v45);
  v46 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::Model(v46, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::SqrtOp::getAttributeNames(void)::attrNames, 1);
  v47 = (uint64_t)v54;
  v54 = 0;
  if (v47)
    (*(void (**)(uint64_t))(*(_QWORD *)v47 + 8))(v47);
  v48 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::Model(v48, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::SubOp::getAttributeNames(void)::attrNames, 1);
  v49 = (uint64_t)v54;
  v54 = 0;
  if (v49)
    (*(void (**)(uint64_t))(*(_QWORD *)v49 + 8))(v49);
  v50 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::Model(v50, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::TanOp::getAttributeNames(void)::attrNames, 1);
  v51 = (uint64_t)v54;
  v54 = 0;
  if (v51)
    (*(void (**)(uint64_t))(*(_QWORD *)v51 + 8))(v51);
  v52 = (_QWORD *)operator new();
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::Model(v52, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::TanhOp::getAttributeNames(void)::attrNames, 1);
  result = (uint64_t)v54;
  v54 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

ZinIrHalH13g *mlir::complex::ComplexDialect::materializeConstant(uint64_t a1, mlir::OpBuilder *a2, _QWORD *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v10;
  uint64_t v11;

  v11 = a4;
  if (!mlir::complex::ConstantOp::isBuildableWith((uint64_t)a3, a4))
    return mlir::arith::ConstantOp::materialize(a2, a3, a4, a5);
  v10 = a3;
  return mlir::OpBuilder::create<mlir::complex::ConstantOp,mlir::Type &,mlir::ArrayAttr>(a2, a5, &v11, (uint64_t *)&v10);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::complex::ConstantOp,mlir::Type &,mlir::ArrayAttr>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  ZinIrHalH13g *v11;
  ZinIrHalH13g *v12;
  uint64_t v14;
  const char *v15;
  __int16 v16;
  uint64_t v17[4];
  __int16 v18;
  _QWORD v19[39];

  v19[38] = *MEMORY[0x24BDAC8D0];
  v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"complex.constant", (const unsigned __int8 *)0x10, Context);
  if (!v10)
  {
    v18 = 1283;
    v17[2] = (uint64_t)"complex.constant";
    v17[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::complex::ConstantOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((_QWORD *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::ConstantOp,void>::id)
    v12 = v11;
  else
    v12 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

llvm::APFloatBase *mlir::complex::NumberAttr::get(uint64_t a1, double a2, double a3)
{
  llvm::APFloatBase *v5;
  void *v6;
  void *FloatSemantics;
  void *v8;
  mlir::MLIRContext *Context;
  llvm::APFloatBase *AttributeUniquer;
  llvm::APFloatBase *v11;
  void *v12;
  void *v13;
  char v15;
  uint64_t Value;
  uint64_t v17;
  _QWORD v18[3];
  _BYTE v19[8];
  _QWORD v20[3];
  _BYTE v21[8];
  _QWORD v22[4];

  v22[3] = *MEMORY[0x24BDAC8D0];
  v17 = a1;
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v17);
  v5 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v19, a2);
  v6 = llvm::APFloatBase::IEEEdouble(v5);
  llvm::APFloat::Storage::Storage(v22, v19, v6);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v19);
  v15 = 0;
  FloatSemantics = mlir::FloatType::getFloatSemantics((llvm::APFloatBase *)&Value);
  llvm::APFloat::convert((uint64_t)v21, FloatSemantics, 1, &v15);
  llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v18, a3);
  llvm::APFloat::Storage::Storage(v20, v18, v6);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v18);
  v8 = mlir::FloatType::getFloatSemantics((llvm::APFloatBase *)&Value);
  llvm::APFloat::convert((uint64_t)v19, v8, 1, &v15);
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
  AttributeUniquer = (llvm::APFloatBase *)mlir::MLIRContext::getAttributeUniquer(Context);
  v18[0] = &mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id;
  v18[1] = Context;
  v11 = (llvm::APFloatBase *)mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir7complex6detail17NumberAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_10NumberAttrEJRNS_7APFloatESE_RNS1_11ComplexTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESJ_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSL_E_EEvlS5_, (uint64_t)v18, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id, (uint64_t)v21, (uint64_t)v19, &v17);
  v12 = (void *)v20[0];
  v13 = llvm::APFloatBase::PPCDoubleDouble(v11);
  if (v13 == v12)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v20);
    if (v13 != (void *)v22[0])
      goto LABEL_3;
LABEL_6:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22);
    return v11;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v20);
  if (v13 == (void *)v22[0])
    goto LABEL_6;
LABEL_3:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v22);
  return v11;
}

llvm::APFloatBase *mlir::complex::ComplexDialect::parseAttribute(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  llvm::APFloatBase *v8;
  const void **v9;
  const void ***v10;
  char *v11;
  char *v12;
  __int128 v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void **v18;
  const char *v19;
  const void ***v20;
  char *v21;
  char *v22;
  __int128 v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  int64_t v36;
  int64_t v37;
  int64_t v38;
  char v39[32];
  __int16 v40;
  const void **v41;
  const char *v42;
  uint64_t v43;
  __int16 v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD *v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  v45 = a2;
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2);
  BYTE2(v49) = 0;
  v47 = 0;
  v48 = 0;
  v46 = v5;
  LOBYTE(v49) = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a2 + 608))(a2, &v47))
  {
    LOWORD(v49) = 256;
    if (!BYTE2(v49))
      BYTE2(v49) = 1;
    goto LABEL_15;
  }
  v41 = (const void **)"number";
  v42 = (const char *)6;
  if (BYTE2(v49))
    goto LABEL_15;
  v6 = (const char *)v48;
  if (!v48)
  {
    (*(void (**)(uint64_t, const void ***, uint64_t))(*(_QWORD *)v45 + 616))(v45, &v41, 1);
    if (!BYTE2(v49))
    {
      v6 = (const char *)v48;
      goto LABEL_45;
    }
LABEL_15:
    v6 = 0;
    v9 = 0;
    v8 = 0;
    if ((unsigned __int16)mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::operator mlir::OptionalParseResult(&v45) > 0xFFu)
      return v8;
    goto LABEL_16;
  }
  if (v48 == (void *)6 && *(_DWORD *)v47 == 1651340654 && *(_WORD *)(v47 + 4) == 29285)
  {
    v8 = mlir::complex::NumberAttr::parse(a2);
    v6 = 0;
    v9 = 0;
    LOBYTE(v49) = v8 != 0;
    *(_WORD *)((char *)&v49 + 1) = 257;
    if ((unsigned __int16)mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::operator mlir::OptionalParseResult(&v45) > 0xFFu)
      return v8;
    goto LABEL_16;
  }
LABEL_45:
  v8 = 0;
  v9 = (const void **)v47;
  LOWORD(v49) = 0;
  BYTE2(v49) = 1;
  if ((unsigned __int16)mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::operator mlir::OptionalParseResult(&v45) > 0xFFu)
    return v8;
LABEL_16:
  v40 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(_QWORD *)a2 + 24))(&v45, a2, v4, v39);
  if (v45)
  {
    LODWORD(v41) = 3;
    v43 = 19;
    v10 = &v41;
    v11 = (char *)v48;
    if (v49 >= v50)
    {
      v33 = v49 + 1;
      if (v48 <= &v41 && (char *)v48 + 24 * v49 > (char *)&v41)
      {
        v36 = (char *)&v41 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v33, 24);
        v11 = (char *)v48;
        v10 = (const void ***)((char *)v48 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v33, 24);
        v10 = &v41;
        v11 = (char *)v48;
      }
    }
    v12 = &v11[24 * v49];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = v10[2];
    *(_OWORD *)v12 = v13;
    ++v49;
    if (v45)
    {
      v44 = 261;
      v41 = v9;
      v42 = v6;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        v43 = 14;
        v14 = &v41;
        v15 = (char *)v48;
        if (v49 >= v50)
        {
          v34 = v49 + 1;
          if (v48 <= &v41 && (char *)v48 + 24 * v49 > (char *)&v41)
          {
            v37 = (char *)&v41 - (_BYTE *)v48;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v34, 24);
            v15 = (char *)v48;
            v14 = (const void ***)((char *)v48 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v34, 24);
            v14 = &v41;
            v15 = (char *)v48;
          }
        }
        v16 = &v15[24 * v49];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v49;
        if (v45)
        {
          v18 = *(const void ***)(a1 + 8);
          v19 = *(const char **)(a1 + 16);
          v44 = 261;
          v41 = v18;
          v42 = v19;
          mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
          if (v45)
          {
            LODWORD(v41) = 3;
            v43 = 1;
            v20 = &v41;
            v21 = (char *)v48;
            if (v49 >= v50)
            {
              v35 = v49 + 1;
              if (v48 <= &v41 && (char *)v48 + 24 * v49 > (char *)&v41)
              {
                v38 = (char *)&v41 - (_BYTE *)v48;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
                v21 = (char *)v48;
                v20 = (const void ***)((char *)v48 + v38);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
                v20 = &v41;
                v21 = (char *)v48;
              }
            }
            v22 = &v21[24 * v49];
            v23 = *(_OWORD *)v20;
            *((_QWORD *)v22 + 2) = v20[2];
            *(_OWORD *)v22 = v23;
            ++v49;
            if (v45)
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
          }
        }
      }
    }
  }
  if (v56)
  {
    v24 = __p;
    if (__p)
    {
      v25 = v55;
      v26 = __p;
      if (v55 != __p)
      {
        do
          v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        v26 = __p;
      }
      v55 = v24;
      operator delete(v26);
    }
    v27 = v52;
    if (v52)
    {
      v28 = v53;
      v29 = v52;
      if (v53 != v52)
      {
        do
        {
          v31 = *--v28;
          v30 = v31;
          *v28 = 0;
          if (v31)
            MEMORY[0x20BD002D4](v30, 0x1000C8077774924);
        }
        while (v28 != v27);
        v29 = v52;
      }
      v53 = v27;
      operator delete(v29);
    }
    if (v48 != v51)
      free(v48);
  }
  return 0;
}

void mlir::complex::ComplexDialect::printAttribute(uint64_t a1, uint64_t a2, mlir::AsmPrinter *a3)
{
  llvm::raw_ostream *v4;
  uint64_t v5;
  uint64_t v6;

  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id)
  {
    v6 = a2;
    v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v5 = *((_QWORD *)v4 + 4);
    if ((unint64_t)(*((_QWORD *)v4 + 3) - v5) > 5)
    {
      *(_WORD *)(v5 + 4) = 29285;
      *(_DWORD *)v5 = 1651340654;
      *((_QWORD *)v4 + 4) += 6;
    }
    else
    {
      llvm::raw_ostream::write(v4, "number", 6uLL);
    }
    mlir::complex::NumberAttr::print((mlir::complex::NumberAttr *)&v6, a3);
  }
}

void mlir::complex::NumberAttr::print(mlir::complex::NumberAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _WORD *v5;
  uint64_t Value;
  llvm::raw_ostream *v7;
  _BYTE *v8;
  const llvm::detail::DoubleAPFloat *v9;
  void *v10;
  void *v11;
  llvm::raw_ostream *v12;
  _WORD *v13;
  const llvm::detail::DoubleAPFloat *v14;
  llvm::raw_ostream *v15;
  _BYTE *v16;
  uint64_t v17;
  _BYTE v18[8];
  _QWORD v19[3];
  _BYTE v20[8];
  _QWORD v21[4];

  v21[3] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_WORD *)*((_QWORD *)v4 + 4);
  if (*((_QWORD *)v4 + 3) - (_QWORD)v5 > 1uLL)
  {
    *v5 = 14908;
    *((_QWORD *)v4 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v4, "<:", 2uLL);
  }
  v17 = *(_QWORD *)(*(_QWORD *)this + 72);
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v17);
  (*(void (**)(mlir::AsmPrinter *, uint64_t))(*(_QWORD *)a2 + 32))(a2, Value);
  v7 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v8 = (_BYTE *)*((_QWORD *)v7 + 4);
  if (*((_BYTE **)v7 + 3) == v8)
  {
    v7 = llvm::raw_ostream::write(v7, " ", 1uLL);
  }
  else
  {
    *v8 = 32;
    ++*((_QWORD *)v7 + 4);
  }
  v9 = (const llvm::detail::DoubleAPFloat *)(*(_QWORD *)this + 16);
  v10 = *(void **)v9;
  v11 = llvm::APFloatBase::PPCDoubleDouble(v7);
  if (v11 == v10)
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v21, v9);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v21, v9);
  (*(void (**)(mlir::AsmPrinter *, _BYTE *))(*(_QWORD *)a2 + 24))(a2, v20);
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_WORD *)*((_QWORD *)v12 + 4);
  if (*((_QWORD *)v12 + 3) - (_QWORD)v13 > 1uLL)
  {
    *v13 = 8236;
    *((_QWORD *)v12 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v12, ", ", 2uLL);
  }
  v14 = (const llvm::detail::DoubleAPFloat *)(*(_QWORD *)this + 48);
  if (v11 == *(void **)v14)
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v19, v14);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v19, v14);
  (*(void (**)(mlir::AsmPrinter *, _BYTE *))(*(_QWORD *)a2 + 24))(a2, v18);
  v15 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v16 = (_BYTE *)*((_QWORD *)v15 + 4);
  if (*((_BYTE **)v15 + 3) != v16)
  {
    *v16 = 62;
    ++*((_QWORD *)v15 + 4);
    if (v11 != (void *)v19[0])
      goto LABEL_18;
LABEL_22:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v19);
    if (v11 != (void *)v21[0])
      goto LABEL_19;
LABEL_23:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v21);
    return;
  }
  llvm::raw_ostream::write(v15, ">", 1uLL);
  if (v11 == (void *)v19[0])
    goto LABEL_22;
LABEL_18:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v19);
  if (v11 == (void *)v21[0])
    goto LABEL_23;
LABEL_19:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v21);
}

llvm::APFloatBase *mlir::complex::NumberAttr::parse(uint64_t a1)
{
  uint64_t v2;
  double v4;
  double v5;
  uint64_t v6;

  v6 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    return 0;
  v4 = 0.0;
  v5 = 0.0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 504))(a1, &v6)
    || !(*(unsigned __int8 (**)(uint64_t, double *))(*(_QWORD *)a1 + 344))(a1, &v5)
    || !(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 120))(a1)
    || !(*(unsigned __int8 (**)(uint64_t, double *))(*(_QWORD *)a1 + 344))(a1, &v4)
    || !(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 168))(a1))
  {
    return 0;
  }
  v2 = mlir::ComplexType::get(v6);
  return mlir::complex::NumberAttr::get(v2, v5, v4);
}

mlir::arith::ArithDialect *llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::arith::ArithDialect * mlir::MLIRContext::getOrLoadDialect<mlir::arith::ArithDialect>(void)::{lambda(void)#1}>@<X0>(mlir::MLIRContext **a1@<X0>, mlir::arith::ArithDialect **a2@<X8>)
{
  mlir::MLIRContext *v3;
  mlir::arith::ArithDialect *v4;
  mlir::arith::ArithDialect *result;

  v3 = *a1;
  v4 = (mlir::arith::ArithDialect *)operator new();
  result = mlir::arith::ArithDialect::ArithDialect(v4, v3);
  *a2 = result;
  return result;
}

uint64_t mlir::RegisteredOperationName::insert<mlir::complex::BitcastOp>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t result;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v2 = (_QWORD *)operator new();
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::BitcastOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::BitcastOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"complex.bitcast", 15, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::BitcastOp,void>::id, (uint64_t)&v9);
  v3 = v9;
  if ((_DWORD)v10)
  {
    v4 = 16 * v10;
    v5 = (void **)((char *)v9 + 8);
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v3 = v9;
  }
  if (v3 != v11)
    free(v3);
  *v2 = &unk_24C04F0B8;
  v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t mlir::RegisteredOperationName::insert<mlir::complex::CreateOp>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t result;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v2 = (_QWORD *)operator new();
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CreateOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CreateOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"complex.create", 14, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::CreateOp,void>::id, (uint64_t)&v9);
  v3 = v9;
  if ((_DWORD)v10)
  {
    v4 = 16 * v10;
    v5 = (void **)((char *)v9 + 8);
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v3 = v9;
  }
  if (v3 != v11)
    free(v3);
  *v2 = &unk_24C04EFF0;
  v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AbsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.abs", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::AbsOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04DEC0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::AbsOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AbsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AbsOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AbsOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AbsOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AbsOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.abs";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  uint64_t v36;
  unsigned __int8 v37;
  _QWORD *v38;
  int v52;
  int v53;
  unint64_t v54;
  unint64_t v55;
  const char *v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  unint64_t v63;
  unint64_t v64;
  const char *v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  int v70;
  int v71;
  unint64_t v72;
  unint64_t v73;
  const char *v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  unint64_t v81;
  unint64_t v82;
  const char *v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  int v88;
  int v89;
  unint64_t v90;
  unint64_t v91;
  const char *v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  unint64_t v99;
  unint64_t v100;
  const char *v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  int v106;
  int v107;
  unint64_t v108;
  unint64_t v109;
  const char *v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  int v115;
  int v116;
  unint64_t v117;
  unint64_t v118;
  const char *v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  int v124;
  int v125;
  unint64_t v126;
  unint64_t v127;
  const char *v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  int v133;
  int v134;
  unint64_t v135;
  unint64_t v136;
  const char *v137;
  unint64_t v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  int v142;
  int v143;
  unint64_t v144;
  unint64_t v145;
  const char *v146;
  unint64_t v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  int v151;
  int v152;
  unint64_t v153;
  unint64_t v154;
  const char *v155;
  unint64_t v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t v159;
  int v160;
  int v161;
  unint64_t v162;
  unint64_t v163;
  const char *v164;
  unint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  const char *v260;
  unint64_t v261;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v247 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v53 = v52;
    a1 = v247;
    if (v53)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v261 = 83;
      v54 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v54)
        v55 = v54;
      else
        v55 = v261;
      v56 = &v260[v55];
      v57 = v261 - v55;
      if (v261 - v55 >= 0x12)
        v58 = 18;
      else
        v58 = v261 - v55;
      v59 = v57 - v58;
      if (v59 >= v59 - 1)
        v60 = v59 - 1;
      else
        v60 = v59;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v56[v58], v60);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v247;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v235 = v3;
    v248 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v62 = v61;
    v3 = v235;
    a1 = v248;
    if (v62)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v261 = 81;
      v63 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v63)
        v64 = v63;
      else
        v64 = v261;
      v65 = &v260[v64];
      v66 = v261 - v64;
      if (v261 - v64 >= 0x12)
        v67 = 18;
      else
        v67 = v261 - v64;
      v68 = v66 - v67;
      if (v68 >= v68 - 1)
        v69 = v68 - 1;
      else
        v69 = v68;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v65[v67], v69);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v235;
      a1 = v248;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v236 = v3;
    v249 = a1;
    v224 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v224;
    v3 = v236;
    v71 = v70;
    a1 = v249;
    if (v71)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl<Empty>]";
      v261 = 109;
      v72 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v72)
        v73 = v72;
      else
        v73 = v261;
      v74 = &v260[v73];
      v75 = v261 - v73;
      if (v261 - v73 >= 0x12)
        v76 = 18;
      else
        v76 = v261 - v73;
      v77 = v75 - v76;
      if (v77 >= v77 - 1)
        v78 = v77 - 1;
      else
        v78 = v77;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v74[v76], v78);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v224;
      v3 = v236;
      a1 = v249;
    }
  }
  v9 = v8[489];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v237 = v3;
    v250 = a1;
    v214 = v9;
    v225 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v214;
    v6 = v225;
    v80 = v79;
    v3 = v237;
    a1 = v250;
    if (v80)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v261 = 86;
      v81 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v81)
        v82 = v81;
      else
        v82 = v261;
      v83 = &v260[v82];
      v84 = v261 - v82;
      if (v261 - v82 >= 0x12)
        v85 = 18;
      else
        v85 = v261 - v82;
      v86 = v84 - v85;
      if (v86 >= v86 - 1)
        v87 = v86 - 1;
      else
        v87 = v86;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v83[v85], v87);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v214;
      v6 = v225;
      v3 = v237;
      a1 = v250;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v238 = v3;
    v251 = a1;
    v215 = v9;
    v226 = v6;
    v205 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v205;
    v9 = v215;
    v6 = v226;
    v89 = v88;
    v3 = v238;
    a1 = v251;
    if (v89)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v261 = 82;
      v90 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v90)
        v91 = v90;
      else
        v91 = v261;
      v92 = &v260[v91];
      v93 = v261 - v91;
      if (v261 - v91 >= 0x12)
        v94 = 18;
      else
        v94 = v261 - v91;
      v95 = v93 - v94;
      if (v95 >= v95 - 1)
        v96 = v95 - 1;
      else
        v96 = v95;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v92[v94], v96);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v205;
      v9 = v215;
      v6 = v226;
      v3 = v238;
      a1 = v251;
    }
  }
  v15 = v14[19];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v239 = v3;
    v252 = a1;
    v216 = v9;
    v227 = v6;
    v197 = v15;
    v206 = v12;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v197;
    v12 = v206;
    v9 = v216;
    v6 = v227;
    v98 = v97;
    v3 = v239;
    a1 = v252;
    if (v98)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v261 = 84;
      v99 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v99)
        v100 = v99;
      else
        v100 = v261;
      v101 = &v260[v100];
      v102 = v261 - v100;
      if (v261 - v100 >= 0x12)
        v103 = 18;
      else
        v103 = v261 - v100;
      v104 = v102 - v103;
      if (v104 >= v104 - 1)
        v105 = v104 - 1;
      else
        v105 = v104;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v101[v103], v105);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v197;
      v12 = v206;
      v9 = v216;
      v6 = v227;
      v3 = v239;
      a1 = v252;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v240 = v3;
    v253 = a1;
    v217 = v9;
    v228 = v6;
    v198 = v15;
    v207 = v12;
    v190 = v18;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v190;
    v15 = v198;
    v12 = v207;
    v9 = v217;
    v6 = v228;
    v107 = v106;
    v3 = v240;
    a1 = v253;
    if (v107)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v261 = 89;
      v108 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v108)
        v109 = v108;
      else
        v109 = v261;
      v110 = &v260[v109];
      v111 = v261 - v109;
      if (v261 - v109 >= 0x12)
        v112 = 18;
      else
        v112 = v261 - v109;
      v113 = v111 - v112;
      if (v113 >= v113 - 1)
        v114 = v113 - 1;
      else
        v114 = v113;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v110[v112], v114);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v190;
      v15 = v198;
      v12 = v207;
      v9 = v217;
      v6 = v228;
      v3 = v240;
      a1 = v253;
    }
  }
  v21 = v20[310];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v241 = v3;
    v254 = a1;
    v218 = v9;
    v229 = v6;
    v199 = v15;
    v208 = v12;
    v184 = v21;
    v191 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v184;
    v18 = v191;
    v15 = v199;
    v12 = v208;
    v9 = v218;
    v6 = v229;
    v116 = v115;
    v3 = v241;
    a1 = v254;
    if (v116)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v261 = 95;
      v117 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v117)
        v118 = v117;
      else
        v118 = v261;
      v119 = &v260[v118];
      v120 = v261 - v118;
      if (v261 - v118 >= 0x12)
        v121 = 18;
      else
        v121 = v261 - v118;
      v122 = v120 - v121;
      if (v122 >= v122 - 1)
        v123 = v122 - 1;
      else
        v123 = v122;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v119[v121], v123);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v184;
      v18 = v191;
      v15 = v199;
      v12 = v208;
      v9 = v218;
      v6 = v229;
      v3 = v241;
      a1 = v254;
    }
  }
  v24 = v23[312];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v242 = v3;
    v255 = a1;
    v219 = v9;
    v230 = v6;
    v200 = v15;
    v209 = v12;
    v185 = v21;
    v192 = v18;
    v179 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v179;
    v21 = v185;
    v18 = v192;
    v15 = v200;
    v12 = v209;
    v9 = v219;
    v6 = v230;
    v125 = v124;
    v3 = v242;
    a1 = v255;
    if (v125)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v261 = 99;
      v126 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v126)
        v127 = v126;
      else
        v127 = v261;
      v128 = &v260[v127];
      v129 = v261 - v127;
      if (v261 - v127 >= 0x12)
        v130 = 18;
      else
        v130 = v261 - v127;
      v131 = v129 - v130;
      if (v131 >= v131 - 1)
        v132 = v131 - 1;
      else
        v132 = v131;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v128[v130], v132);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v179;
      v21 = v185;
      v18 = v192;
      v15 = v200;
      v12 = v209;
      v9 = v219;
      v6 = v230;
      v3 = v242;
      a1 = v255;
    }
  }
  v27 = v26[314];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v243 = v3;
    v256 = a1;
    v220 = v9;
    v231 = v6;
    v201 = v15;
    v210 = v12;
    v186 = v21;
    v193 = v18;
    v175 = v27;
    v180 = v24;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v175;
    v24 = v180;
    v21 = v186;
    v18 = v193;
    v15 = v201;
    v12 = v210;
    v9 = v220;
    v6 = v231;
    v134 = v133;
    v3 = v243;
    a1 = v256;
    if (v134)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v261 = 93;
      v135 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v135)
        v136 = v135;
      else
        v136 = v261;
      v137 = &v260[v136];
      v138 = v261 - v136;
      if (v261 - v136 >= 0x12)
        v139 = 18;
      else
        v139 = v261 - v136;
      v140 = v138 - v139;
      if (v140 >= v140 - 1)
        v141 = v140 - 1;
      else
        v141 = v140;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v137[v139], v141);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v175;
      v24 = v180;
      v21 = v186;
      v18 = v193;
      v15 = v201;
      v12 = v210;
      v9 = v220;
      v6 = v231;
      v3 = v243;
      a1 = v256;
    }
  }
  v30 = v29[21];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v244 = v3;
    v257 = a1;
    v221 = v9;
    v232 = v6;
    v202 = v15;
    v211 = v12;
    v187 = v21;
    v194 = v18;
    v176 = v27;
    v181 = v24;
    v172 = v30;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v172;
    v27 = v176;
    v24 = v181;
    v21 = v187;
    v18 = v194;
    v15 = v202;
    v12 = v211;
    v9 = v221;
    v6 = v232;
    v143 = v142;
    v3 = v244;
    a1 = v257;
    if (v143)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Elementwise<Empty>]";
      v261 = 83;
      v144 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v144)
        v145 = v144;
      else
        v145 = v261;
      v146 = &v260[v145];
      v147 = v261 - v145;
      if (v261 - v145 >= 0x12)
        v148 = 18;
      else
        v148 = v261 - v145;
      v149 = v147 - v148;
      if (v149 >= v149 - 1)
        v150 = v149 - 1;
      else
        v150 = v149;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v146[v148], v150);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v172;
      v27 = v176;
      v24 = v181;
      v21 = v187;
      v18 = v194;
      v15 = v202;
      v12 = v211;
      v9 = v221;
      v6 = v232;
      v3 = v244;
      a1 = v257;
    }
  }
  v33 = v32[322];
  v35 = &unk_25451A000;
  if ((v34 & 1) == 0)
  {
    v245 = v3;
    v258 = a1;
    v222 = v9;
    v233 = v6;
    v203 = v15;
    v212 = v12;
    v188 = v21;
    v195 = v18;
    v177 = v27;
    v182 = v24;
    v170 = v33;
    v173 = v30;
    v35 = (_QWORD *)&unk_25451A000;
    v33 = v170;
    v30 = v173;
    v27 = v177;
    v24 = v182;
    v21 = v188;
    v18 = v195;
    v15 = v203;
    v12 = v212;
    v9 = v222;
    v6 = v233;
    v152 = v151;
    v3 = v245;
    a1 = v258;
    if (v152)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface::Trait<Empty>]";
      v261 = 99;
      v153 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v153)
        v154 = v153;
      else
        v154 = v261;
      v155 = &v260[v154];
      v156 = v261 - v154;
      if (v261 - v154 >= 0x12)
        v157 = 18;
      else
        v157 = v261 - v154;
      v158 = v156 - v157;
      if (v158 >= v158 - 1)
        v159 = v158 - 1;
      else
        v159 = v158;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithFastMathInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v155[v157], v159);
      v35 = (_QWORD *)&unk_25451A000;
      v33 = v170;
      v30 = v173;
      v27 = v177;
      v24 = v182;
      v21 = v188;
      v18 = v195;
      v15 = v203;
      v12 = v212;
      v9 = v222;
      v6 = v233;
      v3 = v245;
      a1 = v258;
    }
  }
  v36 = v35[316];
  v38 = &unk_25451A000;
  if ((v37 & 1) == 0)
  {
    v246 = v3;
    v259 = a1;
    v223 = v9;
    v234 = v6;
    v204 = v15;
    v213 = v12;
    v189 = v21;
    v196 = v18;
    v178 = v27;
    v183 = v24;
    v171 = v33;
    v174 = v30;
    v169 = v36;
    v38 = (_QWORD *)&unk_25451A000;
    v36 = v169;
    v33 = v171;
    v30 = v174;
    v27 = v178;
    v24 = v183;
    v21 = v189;
    v18 = v196;
    v15 = v204;
    v12 = v213;
    v9 = v223;
    v6 = v234;
    v161 = v160;
    v3 = v246;
    a1 = v259;
    if (v161)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v261 = 90;
      v162 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v162)
        v163 = v162;
      else
        v163 = v261;
      v164 = &v260[v163];
      v165 = v261 - v163;
      if (v261 - v163 >= 0x12)
        v166 = 18;
      else
        v166 = v261 - v163;
      v167 = v165 - v166;
      if (v167 >= v167 - 1)
        v168 = v167 - 1;
      else
        v168 = v167;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v164[v166], v168);
      v38 = (_QWORD *)&unk_25451A000;
      v36 = v169;
      v33 = v171;
      v30 = v174;
      v27 = v178;
      v24 = v183;
      v21 = v189;
      v18 = v196;
      v15 = v204;
      v12 = v213;
      v9 = v223;
      v6 = v234;
      v3 = v246;
      a1 = v259;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v36 == a1
      || v38[27] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v8 = a1, mlir::complex::AbsOp::verifyInvariantsImpl((uint64_t **)&v8)))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AddOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.add", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::AddOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04DF88;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::AddOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AddOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AddOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AddOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AddOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AddOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.add";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::complex::detail::AddOpGenericAdaptorBase::AddOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::AddOp::fold(&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  uint64_t v36;
  unsigned __int8 v37;
  _QWORD *v38;
  uint64_t v39;
  unsigned __int8 v40;
  _QWORD *v41;
  int v56;
  int v57;
  unint64_t v58;
  unint64_t v59;
  const char *v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  int v65;
  int v66;
  unint64_t v67;
  unint64_t v68;
  const char *v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  int v74;
  int v75;
  unint64_t v76;
  unint64_t v77;
  const char *v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  int v83;
  int v84;
  unint64_t v85;
  unint64_t v86;
  const char *v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  int v92;
  int v93;
  unint64_t v94;
  unint64_t v95;
  const char *v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  int v101;
  int v102;
  unint64_t v103;
  unint64_t v104;
  const char *v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  int v110;
  int v111;
  unint64_t v112;
  unint64_t v113;
  const char *v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  int v119;
  int v120;
  unint64_t v121;
  unint64_t v122;
  const char *v123;
  unint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  int v128;
  int v129;
  unint64_t v130;
  unint64_t v131;
  const char *v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t v135;
  uint64_t v136;
  int v137;
  int v138;
  unint64_t v139;
  unint64_t v140;
  const char *v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  int v146;
  int v147;
  unint64_t v148;
  unint64_t v149;
  const char *v150;
  unint64_t v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  int v155;
  int v156;
  unint64_t v157;
  unint64_t v158;
  const char *v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  int v164;
  int v165;
  unint64_t v166;
  unint64_t v167;
  const char *v168;
  unint64_t v169;
  uint64_t v170;
  unint64_t v171;
  uint64_t v172;
  int v173;
  int v174;
  unint64_t v175;
  unint64_t v176;
  const char *v177;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  const char *v287;
  unint64_t v288;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v273 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v57 = v56;
    a1 = v273;
    if (v57)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v288 = 83;
      v58 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v58)
        v59 = v58;
      else
        v59 = v288;
      v60 = &v287[v59];
      v61 = v288 - v59;
      if (v288 - v59 >= 0x12)
        v62 = 18;
      else
        v62 = v288 - v59;
      v63 = v61 - v62;
      if (v63 >= v63 - 1)
        v64 = v63 - 1;
      else
        v64 = v63;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v60[v62], v64);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v273;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v260 = v3;
    v274 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v66 = v65;
    v3 = v260;
    a1 = v274;
    if (v66)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v288 = 81;
      v67 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v67)
        v68 = v67;
      else
        v68 = v288;
      v69 = &v287[v68];
      v70 = v288 - v68;
      if (v288 - v68 >= 0x12)
        v71 = 18;
      else
        v71 = v288 - v68;
      v72 = v70 - v71;
      if (v72 >= v72 - 1)
        v73 = v72 - 1;
      else
        v73 = v72;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v69[v71], v73);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v260;
      a1 = v274;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v261 = v3;
    v275 = a1;
    v248 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v248;
    v3 = v261;
    v75 = v74;
    a1 = v275;
    if (v75)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<Empty>]";
      v288 = 111;
      v76 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v76)
        v77 = v76;
      else
        v77 = v288;
      v78 = &v287[v77];
      v79 = v288 - v77;
      if (v288 - v77 >= 0x12)
        v80 = 18;
      else
        v80 = v288 - v77;
      v81 = v79 - v80;
      if (v81 >= v81 - 1)
        v82 = v81 - 1;
      else
        v82 = v81;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v78[v80], v82);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v248;
      v3 = v261;
      a1 = v275;
    }
  }
  v9 = v8[493];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v262 = v3;
    v276 = a1;
    v237 = v9;
    v249 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v237;
    v6 = v249;
    v84 = v83;
    v3 = v262;
    a1 = v276;
    if (v84)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v288 = 86;
      v85 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v85)
        v86 = v85;
      else
        v86 = v288;
      v87 = &v287[v86];
      v88 = v288 - v86;
      if (v288 - v86 >= 0x12)
        v89 = 18;
      else
        v89 = v288 - v86;
      v90 = v88 - v89;
      if (v90 >= v90 - 1)
        v91 = v90 - 1;
      else
        v91 = v90;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v87[v89], v91);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v237;
      v6 = v249;
      v3 = v262;
      a1 = v276;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v263 = v3;
    v277 = a1;
    v238 = v9;
    v250 = v6;
    v227 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v227;
    v9 = v238;
    v6 = v250;
    v93 = v92;
    v3 = v263;
    a1 = v277;
    if (v93)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v288 = 90;
      v94 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v94)
        v95 = v94;
      else
        v95 = v288;
      v96 = &v287[v95];
      v97 = v288 - v95;
      if (v288 - v95 >= 0x12)
        v98 = 18;
      else
        v98 = v288 - v95;
      v99 = v97 - v98;
      if (v99 >= v99 - 1)
        v100 = v99 - 1;
      else
        v100 = v99;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v96[v98], v100);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v227;
      v9 = v238;
      v6 = v250;
      v3 = v263;
      a1 = v277;
    }
  }
  v15 = v14[79];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v264 = v3;
    v278 = a1;
    v239 = v9;
    v251 = v6;
    v218 = v15;
    v228 = v12;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v218;
    v12 = v228;
    v9 = v239;
    v6 = v251;
    v102 = v101;
    v3 = v264;
    a1 = v278;
    if (v102)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v288 = 84;
      v103 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v103)
        v104 = v103;
      else
        v104 = v288;
      v105 = &v287[v104];
      v106 = v288 - v104;
      if (v288 - v104 >= 0x12)
        v107 = 18;
      else
        v107 = v288 - v104;
      v108 = v106 - v107;
      if (v108 >= v108 - 1)
        v109 = v108 - 1;
      else
        v109 = v108;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v105[v107], v109);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v218;
      v12 = v228;
      v9 = v239;
      v6 = v251;
      v3 = v264;
      a1 = v278;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v265 = v3;
    v279 = a1;
    v240 = v9;
    v252 = v6;
    v219 = v15;
    v229 = v12;
    v210 = v18;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v210;
    v15 = v219;
    v12 = v229;
    v9 = v240;
    v6 = v252;
    v111 = v110;
    v3 = v265;
    a1 = v279;
    if (v111)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v288 = 89;
      v112 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v112)
        v113 = v112;
      else
        v113 = v288;
      v114 = &v287[v113];
      v115 = v288 - v113;
      if (v288 - v113 >= 0x12)
        v116 = 18;
      else
        v116 = v288 - v113;
      v117 = v115 - v116;
      if (v117 >= v117 - 1)
        v118 = v117 - 1;
      else
        v118 = v117;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v114[v116], v118);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v210;
      v15 = v219;
      v12 = v229;
      v9 = v240;
      v6 = v252;
      v3 = v265;
      a1 = v279;
    }
  }
  v21 = v20[310];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v266 = v3;
    v280 = a1;
    v241 = v9;
    v253 = v6;
    v220 = v15;
    v230 = v12;
    v203 = v21;
    v211 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v203;
    v18 = v211;
    v15 = v220;
    v12 = v230;
    v9 = v241;
    v6 = v253;
    v120 = v119;
    v3 = v266;
    a1 = v280;
    if (v120)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v288 = 95;
      v121 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v121)
        v122 = v121;
      else
        v122 = v288;
      v123 = &v287[v122];
      v124 = v288 - v122;
      if (v288 - v122 >= 0x12)
        v125 = 18;
      else
        v125 = v288 - v122;
      v126 = v124 - v125;
      if (v126 >= v126 - 1)
        v127 = v126 - 1;
      else
        v127 = v126;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v123[v125], v127);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v203;
      v18 = v211;
      v15 = v220;
      v12 = v230;
      v9 = v241;
      v6 = v253;
      v3 = v266;
      a1 = v280;
    }
  }
  v24 = v23[312];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v267 = v3;
    v281 = a1;
    v242 = v9;
    v254 = v6;
    v221 = v15;
    v231 = v12;
    v204 = v21;
    v212 = v18;
    v197 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v197;
    v21 = v204;
    v18 = v212;
    v15 = v221;
    v12 = v231;
    v9 = v242;
    v6 = v254;
    v129 = v128;
    v3 = v267;
    a1 = v281;
    if (v129)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v288 = 99;
      v130 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v130)
        v131 = v130;
      else
        v131 = v288;
      v132 = &v287[v131];
      v133 = v288 - v131;
      if (v288 - v131 >= 0x12)
        v134 = 18;
      else
        v134 = v288 - v131;
      v135 = v133 - v134;
      if (v135 >= v135 - 1)
        v136 = v135 - 1;
      else
        v136 = v135;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v132[v134], v136);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v197;
      v21 = v204;
      v18 = v212;
      v15 = v221;
      v12 = v231;
      v9 = v242;
      v6 = v254;
      v3 = v267;
      a1 = v281;
    }
  }
  v27 = v26[314];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v268 = v3;
    v282 = a1;
    v243 = v9;
    v255 = v6;
    v222 = v15;
    v232 = v12;
    v205 = v21;
    v213 = v18;
    v192 = v27;
    v198 = v24;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v192;
    v24 = v198;
    v21 = v205;
    v18 = v213;
    v15 = v222;
    v12 = v232;
    v9 = v243;
    v6 = v255;
    v138 = v137;
    v3 = v268;
    a1 = v282;
    if (v138)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v288 = 93;
      v139 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v139)
        v140 = v139;
      else
        v140 = v288;
      v141 = &v287[v140];
      v142 = v288 - v140;
      if (v288 - v140 >= 0x12)
        v143 = 18;
      else
        v143 = v288 - v140;
      v144 = v142 - v143;
      if (v144 >= v144 - 1)
        v145 = v144 - 1;
      else
        v145 = v144;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v141[v143], v145);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v192;
      v24 = v198;
      v21 = v205;
      v18 = v213;
      v15 = v222;
      v12 = v232;
      v9 = v243;
      v6 = v255;
      v3 = v268;
      a1 = v282;
    }
  }
  v30 = v29[21];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v269 = v3;
    v283 = a1;
    v244 = v9;
    v256 = v6;
    v223 = v15;
    v233 = v12;
    v206 = v21;
    v214 = v18;
    v193 = v27;
    v199 = v24;
    v188 = v30;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v188;
    v27 = v193;
    v24 = v199;
    v21 = v206;
    v18 = v214;
    v15 = v223;
    v12 = v233;
    v9 = v244;
    v6 = v256;
    v147 = v146;
    v3 = v269;
    a1 = v283;
    if (v147)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      v288 = 97;
      v148 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v148)
        v149 = v148;
      else
        v149 = v288;
      v150 = &v287[v149];
      v151 = v288 - v149;
      if (v288 - v149 >= 0x12)
        v152 = 18;
      else
        v152 = v288 - v149;
      v153 = v151 - v152;
      if (v153 >= v153 - 1)
        v154 = v153 - 1;
      else
        v154 = v153;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v150[v152], v154);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v188;
      v27 = v193;
      v24 = v199;
      v21 = v206;
      v18 = v214;
      v15 = v223;
      v12 = v233;
      v9 = v244;
      v6 = v256;
      v3 = v269;
      a1 = v283;
    }
  }
  v33 = v32[318];
  v35 = &unk_25451A000;
  if ((v34 & 1) == 0)
  {
    v270 = v3;
    v284 = a1;
    v245 = v9;
    v257 = v6;
    v224 = v15;
    v234 = v12;
    v207 = v21;
    v215 = v18;
    v194 = v27;
    v200 = v24;
    v185 = v33;
    v189 = v30;
    v35 = (_QWORD *)&unk_25451A000;
    v33 = v185;
    v30 = v189;
    v27 = v194;
    v24 = v200;
    v21 = v207;
    v18 = v215;
    v15 = v224;
    v12 = v234;
    v9 = v245;
    v6 = v257;
    v156 = v155;
    v3 = v270;
    a1 = v284;
    if (v156)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Elementwise<Empty>]";
      v288 = 83;
      v157 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v157)
        v158 = v157;
      else
        v158 = v288;
      v159 = &v287[v158];
      v160 = v288 - v158;
      if (v288 - v158 >= 0x12)
        v161 = 18;
      else
        v161 = v288 - v158;
      v162 = v160 - v161;
      if (v162 >= v162 - 1)
        v163 = v162 - 1;
      else
        v163 = v162;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v159[v161], v163);
      v35 = (_QWORD *)&unk_25451A000;
      v33 = v185;
      v30 = v189;
      v27 = v194;
      v24 = v200;
      v21 = v207;
      v18 = v215;
      v15 = v224;
      v12 = v234;
      v9 = v245;
      v6 = v257;
      v3 = v270;
      a1 = v284;
    }
  }
  v36 = v35[322];
  v38 = &unk_25451A000;
  if ((v37 & 1) == 0)
  {
    v271 = v3;
    v285 = a1;
    v246 = v9;
    v258 = v6;
    v225 = v15;
    v235 = v12;
    v208 = v21;
    v216 = v18;
    v195 = v27;
    v201 = v24;
    v186 = v33;
    v190 = v30;
    v183 = v36;
    v38 = (_QWORD *)&unk_25451A000;
    v36 = v183;
    v33 = v186;
    v30 = v190;
    v27 = v195;
    v24 = v201;
    v21 = v208;
    v18 = v216;
    v15 = v225;
    v12 = v235;
    v9 = v246;
    v6 = v258;
    v165 = v164;
    v3 = v271;
    a1 = v285;
    if (v165)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface::Trait<Empty>]";
      v288 = 99;
      v166 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v166)
        v167 = v166;
      else
        v167 = v288;
      v168 = &v287[v167];
      v169 = v288 - v167;
      if (v288 - v167 >= 0x12)
        v170 = 18;
      else
        v170 = v288 - v167;
      v171 = v169 - v170;
      if (v171 >= v171 - 1)
        v172 = v171 - 1;
      else
        v172 = v171;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithFastMathInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v168[v170], v172);
      v38 = (_QWORD *)&unk_25451A000;
      v36 = v183;
      v33 = v186;
      v30 = v190;
      v27 = v195;
      v24 = v201;
      v21 = v208;
      v18 = v216;
      v15 = v225;
      v12 = v235;
      v9 = v246;
      v6 = v258;
      v3 = v271;
      a1 = v285;
    }
  }
  v39 = v38[316];
  v41 = &unk_25451A000;
  if ((v40 & 1) == 0)
  {
    v272 = v3;
    v286 = a1;
    v247 = v9;
    v259 = v6;
    v226 = v15;
    v236 = v12;
    v209 = v21;
    v217 = v18;
    v196 = v27;
    v202 = v24;
    v187 = v33;
    v191 = v30;
    v182 = v39;
    v184 = v36;
    v41 = (_QWORD *)&unk_25451A000;
    v39 = v182;
    v36 = v184;
    v33 = v187;
    v30 = v191;
    v27 = v196;
    v24 = v202;
    v21 = v209;
    v18 = v217;
    v15 = v226;
    v12 = v236;
    v9 = v247;
    v6 = v259;
    v174 = v173;
    v3 = v272;
    a1 = v286;
    if (v174)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v288 = 90;
      v175 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v175)
        v176 = v175;
      else
        v176 = v288;
      v177 = &v287[v176];
      v178 = v288 - v176;
      if (v288 - v176 >= 0x12)
        v179 = 18;
      else
        v179 = v288 - v176;
      v180 = v178 - v179;
      if (v180 >= v180 - 1)
        v181 = v180 - 1;
      else
        v181 = v180;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v177[v179], v181);
      v41 = (_QWORD *)&unk_25451A000;
      v39 = v182;
      v36 = v184;
      v33 = v187;
      v30 = v191;
      v27 = v196;
      v24 = v202;
      v21 = v209;
      v18 = v217;
      v15 = v226;
      v12 = v236;
      v9 = v247;
      v6 = v259;
      v3 = v272;
      a1 = v286;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v36 == a1
      || v39 == a1
      || v41[27] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (v8 = a1, mlir::complex::AddOp::verifyInvariantsImpl((uint64_t **)&v8))
    && mlir::OpTrait::impl::verifySameOperandsAndResultType(a1, v5))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AngleOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.angle", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::AngleOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04EB40;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::AngleOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AngleOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AngleOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AngleOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AngleOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AngleOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.angle";
  v16[1] = 13;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v8 = a1, mlir::complex::AbsOp::verifyInvariantsImpl((uint64_t **)&v8)))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Atan2Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.atan2", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::Atan2Op,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04EC08;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::Atan2Op::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Atan2Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Atan2Op>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Atan2Op>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Atan2Op>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Atan2Op>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.atan2";
  v16[1] = 13;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

void mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::complex::BitcastOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::BitcastOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::BitcastOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::BitcastOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::BitcastOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::BitcastOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::BitcastOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::BitcastOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int *v13;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::complex::detail::BitcastOpGenericAdaptorBase::BitcastOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::BitcastOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 4 == (unsigned int *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::BitcastOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneOperand(a1, v5))
    return 0;
  v7 = a1;
  if (!mlir::complex::BitcastOp::verifyInvariantsImpl((mlir::complex::BitcastOp *)&v7))
    return 0;
  v7 = a1;
  return mlir::complex::BitcastOp::verify((uint64_t **)&v7) != 0;
}

uint64_t mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConjOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.conj", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ConjOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04E820;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::ConjOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConjOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConjOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConjOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ConjOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ConjOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.conj";
  v16[1] = 12;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::complex::detail::ConjOpGenericAdaptorBase::ConjOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::ConjOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  uint64_t v36;
  unsigned __int8 v37;
  _QWORD *v38;
  uint64_t v39;
  unsigned __int8 v40;
  _QWORD *v41;
  int v56;
  int v57;
  unint64_t v58;
  unint64_t v59;
  const char *v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  int v65;
  int v66;
  unint64_t v67;
  unint64_t v68;
  const char *v69;
  unint64_t v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  int v74;
  int v75;
  unint64_t v76;
  unint64_t v77;
  const char *v78;
  unint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  int v83;
  int v84;
  unint64_t v85;
  unint64_t v86;
  const char *v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  int v92;
  int v93;
  unint64_t v94;
  unint64_t v95;
  const char *v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  int v101;
  int v102;
  unint64_t v103;
  unint64_t v104;
  const char *v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  int v110;
  int v111;
  unint64_t v112;
  unint64_t v113;
  const char *v114;
  unint64_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  int v119;
  int v120;
  unint64_t v121;
  unint64_t v122;
  const char *v123;
  unint64_t v124;
  uint64_t v125;
  unint64_t v126;
  uint64_t v127;
  int v128;
  int v129;
  unint64_t v130;
  unint64_t v131;
  const char *v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t v135;
  uint64_t v136;
  int v137;
  int v138;
  unint64_t v139;
  unint64_t v140;
  const char *v141;
  unint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  int v146;
  int v147;
  unint64_t v148;
  unint64_t v149;
  const char *v150;
  unint64_t v151;
  uint64_t v152;
  unint64_t v153;
  uint64_t v154;
  int v155;
  int v156;
  unint64_t v157;
  unint64_t v158;
  const char *v159;
  unint64_t v160;
  uint64_t v161;
  unint64_t v162;
  uint64_t v163;
  int v164;
  int v165;
  unint64_t v166;
  unint64_t v167;
  const char *v168;
  unint64_t v169;
  uint64_t v170;
  unint64_t v171;
  uint64_t v172;
  int v173;
  int v174;
  unint64_t v175;
  unint64_t v176;
  const char *v177;
  unint64_t v178;
  uint64_t v179;
  unint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  const char *v287;
  unint64_t v288;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v273 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v57 = v56;
    a1 = v273;
    if (v57)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v288 = 83;
      v58 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v58)
        v59 = v58;
      else
        v59 = v288;
      v60 = &v287[v59];
      v61 = v288 - v59;
      if (v288 - v59 >= 0x12)
        v62 = 18;
      else
        v62 = v288 - v59;
      v63 = v61 - v62;
      if (v63 >= v63 - 1)
        v64 = v63 - 1;
      else
        v64 = v63;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v60[v62], v64);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v273;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v260 = v3;
    v274 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v66 = v65;
    v3 = v260;
    a1 = v274;
    if (v66)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v288 = 81;
      v67 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v67)
        v68 = v67;
      else
        v68 = v288;
      v69 = &v287[v68];
      v70 = v288 - v68;
      if (v288 - v68 >= 0x12)
        v71 = 18;
      else
        v71 = v288 - v68;
      v72 = v70 - v71;
      if (v72 >= v72 - 1)
        v73 = v72 - 1;
      else
        v73 = v72;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v69[v71], v73);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v260;
      a1 = v274;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v261 = v3;
    v275 = a1;
    v248 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v248;
    v3 = v261;
    v75 = v74;
    a1 = v275;
    if (v75)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<Empty>]";
      v288 = 111;
      v76 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v76)
        v77 = v76;
      else
        v77 = v288;
      v78 = &v287[v77];
      v79 = v288 - v77;
      if (v288 - v77 >= 0x12)
        v80 = 18;
      else
        v80 = v288 - v77;
      v81 = v79 - v80;
      if (v81 >= v81 - 1)
        v82 = v81 - 1;
      else
        v82 = v81;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v78[v80], v82);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v248;
      v3 = v261;
      a1 = v275;
    }
  }
  v9 = v8[493];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v262 = v3;
    v276 = a1;
    v237 = v9;
    v249 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v237;
    v6 = v249;
    v84 = v83;
    v3 = v262;
    a1 = v276;
    if (v84)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v288 = 86;
      v85 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v85)
        v86 = v85;
      else
        v86 = v288;
      v87 = &v287[v86];
      v88 = v288 - v86;
      if (v288 - v86 >= 0x12)
        v89 = 18;
      else
        v89 = v288 - v86;
      v90 = v88 - v89;
      if (v90 >= v90 - 1)
        v91 = v90 - 1;
      else
        v91 = v90;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v87[v89], v91);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v237;
      v6 = v249;
      v3 = v262;
      a1 = v276;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v263 = v3;
    v277 = a1;
    v238 = v9;
    v250 = v6;
    v227 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v227;
    v9 = v238;
    v6 = v250;
    v93 = v92;
    v3 = v263;
    a1 = v277;
    if (v93)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v288 = 82;
      v94 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v94)
        v95 = v94;
      else
        v95 = v288;
      v96 = &v287[v95];
      v97 = v288 - v95;
      if (v288 - v95 >= 0x12)
        v98 = 18;
      else
        v98 = v288 - v95;
      v99 = v97 - v98;
      if (v99 >= v99 - 1)
        v100 = v99 - 1;
      else
        v100 = v99;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v96[v98], v100);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v227;
      v9 = v238;
      v6 = v250;
      v3 = v263;
      a1 = v277;
    }
  }
  v15 = v14[19];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v264 = v3;
    v278 = a1;
    v239 = v9;
    v251 = v6;
    v218 = v15;
    v228 = v12;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v218;
    v12 = v228;
    v9 = v239;
    v6 = v251;
    v102 = v101;
    v3 = v264;
    a1 = v278;
    if (v102)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v288 = 84;
      v103 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v103)
        v104 = v103;
      else
        v104 = v288;
      v105 = &v287[v104];
      v106 = v288 - v104;
      if (v288 - v104 >= 0x12)
        v107 = 18;
      else
        v107 = v288 - v104;
      v108 = v106 - v107;
      if (v108 >= v108 - 1)
        v109 = v108 - 1;
      else
        v109 = v108;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v105[v107], v109);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v218;
      v12 = v228;
      v9 = v239;
      v6 = v251;
      v3 = v264;
      a1 = v278;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v265 = v3;
    v279 = a1;
    v240 = v9;
    v252 = v6;
    v219 = v15;
    v229 = v12;
    v210 = v18;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v210;
    v15 = v219;
    v12 = v229;
    v9 = v240;
    v6 = v252;
    v111 = v110;
    v3 = v265;
    a1 = v279;
    if (v111)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v288 = 89;
      v112 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v112)
        v113 = v112;
      else
        v113 = v288;
      v114 = &v287[v113];
      v115 = v288 - v113;
      if (v288 - v113 >= 0x12)
        v116 = 18;
      else
        v116 = v288 - v113;
      v117 = v115 - v116;
      if (v117 >= v117 - 1)
        v118 = v117 - 1;
      else
        v118 = v117;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v114[v116], v118);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v210;
      v15 = v219;
      v12 = v229;
      v9 = v240;
      v6 = v252;
      v3 = v265;
      a1 = v279;
    }
  }
  v21 = v20[310];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v266 = v3;
    v280 = a1;
    v241 = v9;
    v253 = v6;
    v220 = v15;
    v230 = v12;
    v203 = v21;
    v211 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v203;
    v18 = v211;
    v15 = v220;
    v12 = v230;
    v9 = v241;
    v6 = v253;
    v120 = v119;
    v3 = v266;
    a1 = v280;
    if (v120)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      v288 = 97;
      v121 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v121)
        v122 = v121;
      else
        v122 = v288;
      v123 = &v287[v122];
      v124 = v288 - v122;
      if (v288 - v122 >= 0x12)
        v125 = 18;
      else
        v125 = v288 - v122;
      v126 = v124 - v125;
      if (v126 >= v126 - 1)
        v127 = v126 - 1;
      else
        v127 = v126;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v123[v125], v127);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v203;
      v18 = v211;
      v15 = v220;
      v12 = v230;
      v9 = v241;
      v6 = v253;
      v3 = v266;
      a1 = v280;
    }
  }
  v24 = v23[318];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v267 = v3;
    v281 = a1;
    v242 = v9;
    v254 = v6;
    v221 = v15;
    v231 = v12;
    v204 = v21;
    v212 = v18;
    v197 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v197;
    v21 = v204;
    v18 = v212;
    v15 = v221;
    v12 = v231;
    v9 = v242;
    v6 = v254;
    v129 = v128;
    v3 = v267;
    a1 = v281;
    if (v129)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v288 = 95;
      v130 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v130)
        v131 = v130;
      else
        v131 = v288;
      v132 = &v287[v131];
      v133 = v288 - v131;
      if (v288 - v131 >= 0x12)
        v134 = 18;
      else
        v134 = v288 - v131;
      v135 = v133 - v134;
      if (v135 >= v135 - 1)
        v136 = v135 - 1;
      else
        v136 = v135;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v132[v134], v136);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v197;
      v21 = v204;
      v18 = v212;
      v15 = v221;
      v12 = v231;
      v9 = v242;
      v6 = v254;
      v3 = v267;
      a1 = v281;
    }
  }
  v27 = v26[312];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v268 = v3;
    v282 = a1;
    v243 = v9;
    v255 = v6;
    v222 = v15;
    v232 = v12;
    v205 = v21;
    v213 = v18;
    v192 = v27;
    v198 = v24;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v192;
    v24 = v198;
    v21 = v205;
    v18 = v213;
    v15 = v222;
    v12 = v232;
    v9 = v243;
    v6 = v255;
    v138 = v137;
    v3 = v268;
    a1 = v282;
    if (v138)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v288 = 99;
      v139 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v139)
        v140 = v139;
      else
        v140 = v288;
      v141 = &v287[v140];
      v142 = v288 - v140;
      if (v288 - v140 >= 0x12)
        v143 = 18;
      else
        v143 = v288 - v140;
      v144 = v142 - v143;
      if (v144 >= v144 - 1)
        v145 = v144 - 1;
      else
        v145 = v144;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v141[v143], v145);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v192;
      v24 = v198;
      v21 = v205;
      v18 = v213;
      v15 = v222;
      v12 = v232;
      v9 = v243;
      v6 = v255;
      v3 = v268;
      a1 = v282;
    }
  }
  v30 = v29[314];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v269 = v3;
    v283 = a1;
    v244 = v9;
    v256 = v6;
    v223 = v15;
    v233 = v12;
    v206 = v21;
    v214 = v18;
    v193 = v27;
    v199 = v24;
    v188 = v30;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v188;
    v27 = v193;
    v24 = v199;
    v21 = v206;
    v18 = v214;
    v15 = v223;
    v12 = v233;
    v9 = v244;
    v6 = v256;
    v147 = v146;
    v3 = v269;
    a1 = v283;
    if (v147)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v288 = 93;
      v148 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v148)
        v149 = v148;
      else
        v149 = v288;
      v150 = &v287[v149];
      v151 = v288 - v149;
      if (v288 - v149 >= 0x12)
        v152 = 18;
      else
        v152 = v288 - v149;
      v153 = v151 - v152;
      if (v153 >= v153 - 1)
        v154 = v153 - 1;
      else
        v154 = v153;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v150[v152], v154);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v188;
      v27 = v193;
      v24 = v199;
      v21 = v206;
      v18 = v214;
      v15 = v223;
      v12 = v233;
      v9 = v244;
      v6 = v256;
      v3 = v269;
      a1 = v283;
    }
  }
  v33 = v32[21];
  v35 = &unk_25451A000;
  if ((v34 & 1) == 0)
  {
    v270 = v3;
    v284 = a1;
    v245 = v9;
    v257 = v6;
    v224 = v15;
    v234 = v12;
    v207 = v21;
    v215 = v18;
    v194 = v27;
    v200 = v24;
    v185 = v33;
    v189 = v30;
    v35 = (_QWORD *)&unk_25451A000;
    v33 = v185;
    v30 = v189;
    v27 = v194;
    v24 = v200;
    v21 = v207;
    v18 = v215;
    v15 = v224;
    v12 = v234;
    v9 = v245;
    v6 = v257;
    v156 = v155;
    v3 = v270;
    a1 = v284;
    if (v156)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Elementwise<Empty>]";
      v288 = 83;
      v157 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v157)
        v158 = v157;
      else
        v158 = v288;
      v159 = &v287[v158];
      v160 = v288 - v158;
      if (v288 - v158 >= 0x12)
        v161 = 18;
      else
        v161 = v288 - v158;
      v162 = v160 - v161;
      if (v162 >= v162 - 1)
        v163 = v162 - 1;
      else
        v163 = v162;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v159[v161], v163);
      v35 = (_QWORD *)&unk_25451A000;
      v33 = v185;
      v30 = v189;
      v27 = v194;
      v24 = v200;
      v21 = v207;
      v18 = v215;
      v15 = v224;
      v12 = v234;
      v9 = v245;
      v6 = v257;
      v3 = v270;
      a1 = v284;
    }
  }
  v36 = v35[322];
  v38 = &unk_25451A000;
  if ((v37 & 1) == 0)
  {
    v271 = v3;
    v285 = a1;
    v246 = v9;
    v258 = v6;
    v225 = v15;
    v235 = v12;
    v208 = v21;
    v216 = v18;
    v195 = v27;
    v201 = v24;
    v186 = v33;
    v190 = v30;
    v183 = v36;
    v38 = (_QWORD *)&unk_25451A000;
    v36 = v183;
    v33 = v186;
    v30 = v190;
    v27 = v195;
    v24 = v201;
    v21 = v208;
    v18 = v216;
    v15 = v225;
    v12 = v235;
    v9 = v246;
    v6 = v258;
    v165 = v164;
    v3 = v271;
    a1 = v285;
    if (v165)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface::Trait<Empty>]";
      v288 = 99;
      v166 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v166)
        v167 = v166;
      else
        v167 = v288;
      v168 = &v287[v167];
      v169 = v288 - v167;
      if (v288 - v167 >= 0x12)
        v170 = 18;
      else
        v170 = v288 - v167;
      v171 = v169 - v170;
      if (v171 >= v171 - 1)
        v172 = v171 - 1;
      else
        v172 = v171;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithFastMathInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v168[v170], v172);
      v38 = (_QWORD *)&unk_25451A000;
      v36 = v183;
      v33 = v186;
      v30 = v190;
      v27 = v195;
      v24 = v201;
      v21 = v208;
      v18 = v216;
      v15 = v225;
      v12 = v235;
      v9 = v246;
      v6 = v258;
      v3 = v271;
      a1 = v285;
    }
  }
  v39 = v38[316];
  v41 = &unk_25451A000;
  if ((v40 & 1) == 0)
  {
    v272 = v3;
    v286 = a1;
    v247 = v9;
    v259 = v6;
    v226 = v15;
    v236 = v12;
    v209 = v21;
    v217 = v18;
    v196 = v27;
    v202 = v24;
    v187 = v33;
    v191 = v30;
    v182 = v39;
    v184 = v36;
    v41 = (_QWORD *)&unk_25451A000;
    v39 = v182;
    v36 = v184;
    v33 = v187;
    v30 = v191;
    v27 = v196;
    v24 = v202;
    v21 = v209;
    v18 = v217;
    v15 = v226;
    v12 = v236;
    v9 = v247;
    v6 = v259;
    v174 = v173;
    v3 = v272;
    a1 = v286;
    if (v174)
    {
      v287 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v288 = 90;
      v175 = llvm::StringRef::find((uint64_t *)&v287, "DesiredTypeName = ", 0x12uLL, 0);
      if (v288 >= v175)
        v176 = v175;
      else
        v176 = v288;
      v177 = &v287[v176];
      v178 = v288 - v176;
      if (v288 - v176 >= 0x12)
        v179 = 18;
      else
        v179 = v288 - v176;
      v180 = v178 - v179;
      if (v180 >= v180 - 1)
        v181 = v180 - 1;
      else
        v181 = v180;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v177[v179], v181);
      v41 = (_QWORD *)&unk_25451A000;
      v39 = v182;
      v36 = v184;
      v33 = v187;
      v30 = v191;
      v27 = v196;
      v24 = v202;
      v21 = v209;
      v18 = v217;
      v15 = v226;
      v12 = v236;
      v9 = v247;
      v6 = v259;
      v3 = v272;
      a1 = v286;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v36 == a1
      || v39 == a1
      || v41[27] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::Operation *v7;
  mlir::OpTrait::impl *v9;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v9 = a1, mlir::complex::ConjOp::verifyInvariantsImpl((uint64_t **)&v9))
    && mlir::OpTrait::impl::verifySameOperandsAndResultType(a1, v6))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v7) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.constant", 16, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ConstantOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04DBA0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::ConstantOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::ConstantOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::complex::ConstantOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::ConstantOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::complex::ConstantOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::complex::ConstantOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::ConstantOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::CmpFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConstantOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConstantOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::complex::ConstantOp::getAsmResultNames(&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::complex::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::ConstantOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  const char *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  const char *v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  unint64_t v86;
  unint64_t v87;
  const char *v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  const char *v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  const char *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unint64_t v113;
  unint64_t v114;
  const char *v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  unint64_t v122;
  unint64_t v123;
  const char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  int v129;
  int v130;
  unint64_t v131;
  unint64_t v132;
  const char *v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  const char *v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  const char *v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  const char *v234;
  unint64_t v235;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v222 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v49 = v48;
    a1 = v222;
    if (v49)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v235 = 83;
      v50 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v50)
        v51 = v50;
      else
        v51 = v235;
      v52 = &v234[v51];
      v53 = v235 - v51;
      if (v235 - v51 >= 0x12)
        v54 = 18;
      else
        v54 = v235 - v51;
      v55 = v53 - v54;
      if (v55 >= v55 - 1)
        v56 = v55 - 1;
      else
        v56 = v55;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v222;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v211 = v3;
    v223 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v58 = v57;
    v3 = v211;
    a1 = v223;
    if (v58)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v235 = 81;
      v59 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v59)
        v60 = v59;
      else
        v60 = v235;
      v61 = &v234[v60];
      v62 = v235 - v60;
      if (v235 - v60 >= 0x12)
        v63 = 18;
      else
        v63 = v235 - v60;
      v64 = v62 - v63;
      if (v64 >= v64 - 1)
        v65 = v64 - 1;
      else
        v65 = v64;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v211;
      a1 = v223;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v212 = v3;
    v224 = a1;
    v201 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v201;
    v3 = v212;
    v67 = v66;
    a1 = v224;
    if (v67)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<Empty>]";
      v235 = 111;
      v68 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v68)
        v69 = v68;
      else
        v69 = v235;
      v70 = &v234[v69];
      v71 = v235 - v69;
      if (v235 - v69 >= 0x12)
        v72 = 18;
      else
        v72 = v235 - v69;
      v73 = v71 - v72;
      if (v73 >= v73 - 1)
        v74 = v73 - 1;
      else
        v74 = v73;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v201;
      v3 = v212;
      a1 = v224;
    }
  }
  v9 = v8[493];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v213 = v3;
    v225 = a1;
    v202 = v6;
    v192 = v9;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v192;
    v6 = v202;
    v3 = v213;
    v76 = v75;
    a1 = v225;
    if (v76)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v235 = 86;
      v77 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v77)
        v78 = v77;
      else
        v78 = v235;
      v79 = &v234[v78];
      v80 = v235 - v78;
      if (v235 - v78 >= 0x12)
        v81 = 18;
      else
        v81 = v235 - v78;
      v82 = v80 - v81;
      if (v82 >= v82 - 1)
        v83 = v82 - 1;
      else
        v83 = v82;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v192;
      v6 = v202;
      v3 = v213;
      a1 = v225;
    }
  }
  v12 = v11[419];
  v14 = &unk_254519000;
  if ((v13 & 1) == 0)
  {
    v214 = v3;
    v226 = a1;
    v203 = v6;
    v184 = v12;
    v193 = v9;
    v14 = (_QWORD *)&unk_254519000;
    v12 = v184;
    v9 = v193;
    v6 = v203;
    v3 = v214;
    v85 = v84;
    a1 = v226;
    if (v85)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroOperands<Empty>]";
      v235 = 84;
      v86 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v86)
        v87 = v86;
      else
        v87 = v235;
      v88 = &v234[v87];
      v89 = v235 - v87;
      if (v235 - v87 >= 0x12)
        v90 = 18;
      else
        v90 = v235 - v87;
      v91 = v89 - v90;
      if (v91 >= v91 - 1)
        v92 = v91 - 1;
      else
        v92 = v91;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      v14 = (_QWORD *)&unk_254519000;
      v12 = v184;
      v9 = v193;
      v6 = v203;
      v3 = v214;
      a1 = v226;
    }
  }
  v15 = v14[421];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v215 = v3;
    v227 = a1;
    v204 = v6;
    v185 = v12;
    v194 = v9;
    v177 = v15;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v177;
    v12 = v185;
    v9 = v194;
    v6 = v204;
    v3 = v215;
    v94 = v93;
    a1 = v227;
    if (v94)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v235 = 84;
      v95 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v95)
        v96 = v95;
      else
        v96 = v235;
      v97 = &v234[v96];
      v98 = v235 - v96;
      if (v235 - v96 >= 0x12)
        v99 = 18;
      else
        v99 = v235 - v96;
      v100 = v98 - v99;
      if (v100 >= v100 - 1)
        v101 = v100 - 1;
      else
        v101 = v100;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v177;
      v12 = v185;
      v9 = v194;
      v6 = v204;
      v3 = v215;
      a1 = v227;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v216 = v3;
    v228 = a1;
    v205 = v6;
    v186 = v12;
    v195 = v9;
    v171 = v18;
    v178 = v15;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v171;
    v15 = v178;
    v12 = v186;
    v9 = v195;
    v6 = v205;
    v3 = v216;
    v103 = v102;
    a1 = v228;
    if (v103)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v235 = 89;
      v104 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v104)
        v105 = v104;
      else
        v105 = v235;
      v106 = &v234[v105];
      v107 = v235 - v105;
      if (v235 - v105 >= 0x12)
        v108 = 18;
      else
        v108 = v235 - v105;
      v109 = v107 - v108;
      if (v109 >= v109 - 1)
        v110 = v109 - 1;
      else
        v110 = v109;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v171;
      v15 = v178;
      v12 = v186;
      v9 = v195;
      v6 = v205;
      v3 = v216;
      a1 = v228;
    }
  }
  v21 = v20[310];
  v23 = &unk_254519000;
  if ((v22 & 1) == 0)
  {
    v217 = v3;
    v229 = a1;
    v206 = v6;
    v187 = v12;
    v196 = v9;
    v172 = v18;
    v179 = v15;
    v166 = v21;
    v23 = (_QWORD *)&unk_254519000;
    v21 = v166;
    v18 = v172;
    v15 = v179;
    v12 = v187;
    v9 = v196;
    v6 = v206;
    v3 = v217;
    v112 = v111;
    a1 = v229;
    if (v112)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
      v235 = 84;
      v113 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v113)
        v114 = v113;
      else
        v114 = v235;
      v115 = &v234[v114];
      v116 = v235 - v114;
      if (v235 - v114 >= 0x12)
        v117 = 18;
      else
        v117 = v235 - v114;
      v118 = v116 - v117;
      if (v118 >= v118 - 1)
        v119 = v118 - 1;
      else
        v119 = v118;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      v23 = (_QWORD *)&unk_254519000;
      v21 = v166;
      v18 = v172;
      v15 = v179;
      v12 = v187;
      v9 = v196;
      v6 = v206;
      v3 = v217;
      a1 = v229;
    }
  }
  v24 = v23[375];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v218 = v3;
    v230 = a1;
    v207 = v6;
    v188 = v12;
    v197 = v9;
    v173 = v18;
    v180 = v15;
    v162 = v24;
    v167 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v162;
    v21 = v167;
    v18 = v173;
    v15 = v180;
    v12 = v188;
    v9 = v197;
    v6 = v207;
    v3 = v218;
    v121 = v120;
    a1 = v230;
    if (v121)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v235 = 95;
      v122 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v122)
        v123 = v122;
      else
        v123 = v235;
      v124 = &v234[v123];
      v125 = v235 - v123;
      if (v235 - v123 >= 0x12)
        v126 = 18;
      else
        v126 = v235 - v123;
      v127 = v125 - v126;
      if (v127 >= v127 - 1)
        v128 = v127 - 1;
      else
        v128 = v127;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v162;
      v21 = v167;
      v18 = v173;
      v15 = v180;
      v12 = v188;
      v9 = v197;
      v6 = v207;
      v3 = v218;
      a1 = v230;
    }
  }
  v27 = v26[312];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v219 = v3;
    v231 = a1;
    v208 = v6;
    v189 = v12;
    v198 = v9;
    v174 = v18;
    v181 = v15;
    v163 = v24;
    v168 = v21;
    v159 = v27;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v159;
    v24 = v163;
    v21 = v168;
    v18 = v174;
    v15 = v181;
    v12 = v189;
    v9 = v198;
    v6 = v208;
    v3 = v219;
    v130 = v129;
    a1 = v231;
    if (v130)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v235 = 99;
      v131 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v131)
        v132 = v131;
      else
        v132 = v235;
      v133 = &v234[v132];
      v134 = v235 - v132;
      if (v235 - v132 >= 0x12)
        v135 = 18;
      else
        v135 = v235 - v132;
      v136 = v134 - v135;
      if (v136 >= v136 - 1)
        v137 = v136 - 1;
      else
        v137 = v136;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v159;
      v24 = v163;
      v21 = v168;
      v18 = v174;
      v15 = v181;
      v12 = v189;
      v9 = v198;
      v6 = v208;
      v3 = v219;
      a1 = v231;
    }
  }
  v30 = v29[314];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v220 = v3;
    v232 = a1;
    v209 = v6;
    v190 = v12;
    v199 = v9;
    v175 = v18;
    v182 = v15;
    v164 = v24;
    v169 = v21;
    v157 = v30;
    v160 = v27;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v157;
    v27 = v160;
    v24 = v164;
    v21 = v169;
    v18 = v175;
    v15 = v182;
    v12 = v190;
    v9 = v199;
    v6 = v209;
    v3 = v220;
    v139 = v138;
    a1 = v232;
    if (v139)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v235 = 93;
      v140 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v140)
        v141 = v140;
      else
        v141 = v235;
      v142 = &v234[v141];
      v143 = v235 - v141;
      if (v235 - v141 >= 0x12)
        v144 = 18;
      else
        v144 = v235 - v141;
      v145 = v143 - v144;
      if (v145 >= v145 - 1)
        v146 = v145 - 1;
      else
        v146 = v145;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v157;
      v27 = v160;
      v24 = v164;
      v21 = v169;
      v18 = v175;
      v15 = v182;
      v12 = v190;
      v9 = v199;
      v6 = v209;
      v3 = v220;
      a1 = v232;
    }
  }
  v33 = v32[21];
  v35 = &unk_25451A000;
  if ((v34 & 1) == 0)
  {
    v221 = v3;
    v233 = a1;
    v210 = v6;
    v191 = v12;
    v200 = v9;
    v176 = v18;
    v183 = v15;
    v165 = v24;
    v170 = v21;
    v158 = v30;
    v161 = v27;
    v156 = v33;
    v35 = (_QWORD *)&unk_25451A000;
    v33 = v156;
    v30 = v158;
    v27 = v161;
    v24 = v165;
    v21 = v170;
    v18 = v176;
    v15 = v183;
    v12 = v191;
    v9 = v200;
    v6 = v210;
    v3 = v221;
    v148 = v147;
    a1 = v233;
    if (v148)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v235 = 86;
      v149 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v149)
        v150 = v149;
      else
        v150 = v235;
      v151 = &v234[v150];
      v152 = v235 - v150;
      if (v235 - v150 >= 0x12)
        v153 = 18;
      else
        v153 = v235 - v150;
      v154 = v152 - v153;
      if (v154 >= v154 - 1)
        v155 = v154 - 1;
      else
        v155 = v154;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      v35 = (_QWORD *)&unk_25451A000;
      v33 = v156;
      v30 = v158;
      v27 = v161;
      v24 = v165;
      v21 = v170;
      v18 = v176;
      v15 = v183;
      v12 = v191;
      v9 = v200;
      v6 = v210;
      v3 = v221;
      a1 = v233;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v35[340] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::ConstantOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroOperands(a1, v5))
    return 0;
  v7 = a1;
  if (!mlir::complex::ConstantOp::verifyInvariantsImpl((uint64_t **)&v7))
    return 0;
  v7 = a1;
  return mlir::complex::ConstantOp::verify((uint64_t **)&v7) != 0;
}

uint64_t mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CosOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.cos", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::CosOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04E050;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::foldHook()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::CosOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CosOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CosOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CosOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::CosOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::CosOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.cos";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::CreateOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  unsigned int *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, unsigned int *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                              + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CreateOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CreateOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CreateOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CreateOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CreateOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CreateOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unsigned int *v13;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::complex::detail::CreateOpGenericAdaptorBase::CreateOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::CreateOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 4 == (unsigned int *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  int v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  const char *v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  const char *v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unint64_t v56;
  unint64_t v57;
  const char *v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  unint64_t v65;
  unint64_t v66;
  const char *v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  unint64_t v74;
  unint64_t v75;
  const char *v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  unint64_t v83;
  unint64_t v84;
  const char *v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  unint64_t v92;
  unint64_t v93;
  const char *v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  unint64_t v101;
  unint64_t v102;
  const char *v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  unint64_t v110;
  unint64_t v111;
  const char *v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  const char *v162;
  unint64_t v163;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v153 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v37 = v36;
    a1 = v153;
    if (v37)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v163 = 83;
      v38 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v38)
        v39 = v38;
      else
        v39 = v163;
      v40 = &v162[v39];
      v41 = v163 - v39;
      if (v163 - v39 >= 0x12)
        v42 = 18;
      else
        v42 = v163 - v39;
      v43 = v41 - v42;
      if (v43 >= v43 - 1)
        v44 = v43 - 1;
      else
        v44 = v43;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v153;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v145 = v3;
    v154 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v46 = v45;
    v3 = v145;
    a1 = v154;
    if (v46)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v163 = 81;
      v47 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v47)
        v48 = v47;
      else
        v48 = v163;
      v49 = &v162[v48];
      v50 = v163 - v48;
      if (v163 - v48 >= 0x12)
        v51 = 18;
      else
        v51 = v163 - v48;
      v52 = v50 - v51;
      if (v52 >= v52 - 1)
        v53 = v52 - 1;
      else
        v53 = v52;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v145;
      a1 = v154;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v146 = v3;
    v155 = a1;
    v138 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v138;
    v55 = v54;
    v3 = v146;
    a1 = v155;
    if (v55)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<Empty>]";
      v163 = 111;
      v56 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v56)
        v57 = v56;
      else
        v57 = v163;
      v58 = &v162[v57];
      v59 = v163 - v57;
      if (v163 - v57 >= 0x12)
        v60 = 18;
      else
        v60 = v163 - v57;
      v61 = v59 - v60;
      if (v61 >= v61 - 1)
        v62 = v61 - 1;
      else
        v62 = v61;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v138;
      v3 = v146;
      a1 = v155;
    }
  }
  v9 = v8[493];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v147 = v3;
    v156 = a1;
    v132 = v9;
    v139 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v132;
    v6 = v139;
    v64 = v63;
    v3 = v147;
    a1 = v156;
    if (v64)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v163 = 86;
      v65 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v65)
        v66 = v65;
      else
        v66 = v163;
      v67 = &v162[v66];
      v68 = v163 - v66;
      if (v163 - v66 >= 0x12)
        v69 = 18;
      else
        v69 = v163 - v66;
      v70 = v68 - v69;
      if (v70 >= v70 - 1)
        v71 = v70 - 1;
      else
        v71 = v70;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v132;
      v6 = v139;
      v3 = v147;
      a1 = v156;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v148 = v3;
    v157 = a1;
    v133 = v9;
    v140 = v6;
    v127 = v12;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v127;
    v9 = v133;
    v6 = v140;
    v73 = v72;
    v3 = v148;
    a1 = v157;
    if (v73)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v163 = 90;
      v74 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v74)
        v75 = v74;
      else
        v75 = v163;
      v76 = &v162[v75];
      v77 = v163 - v75;
      if (v163 - v75 >= 0x12)
        v78 = 18;
      else
        v78 = v163 - v75;
      v79 = v77 - v78;
      if (v79 >= v79 - 1)
        v80 = v79 - 1;
      else
        v80 = v79;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v127;
      v9 = v133;
      v6 = v140;
      v3 = v148;
      a1 = v157;
    }
  }
  v15 = v14[79];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v149 = v3;
    v158 = a1;
    v134 = v9;
    v141 = v6;
    v123 = v15;
    v128 = v12;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v123;
    v12 = v128;
    v9 = v134;
    v6 = v141;
    v82 = v81;
    v3 = v149;
    a1 = v158;
    if (v82)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v163 = 84;
      v83 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v83)
        v84 = v83;
      else
        v84 = v163;
      v85 = &v162[v84];
      v86 = v163 - v84;
      if (v163 - v84 >= 0x12)
        v87 = 18;
      else
        v87 = v163 - v84;
      v88 = v86 - v87;
      if (v88 >= v88 - 1)
        v89 = v88 - 1;
      else
        v89 = v88;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v123;
      v12 = v128;
      v9 = v134;
      v6 = v141;
      v3 = v149;
      a1 = v158;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v150 = v3;
    v159 = a1;
    v135 = v9;
    v142 = v6;
    v124 = v15;
    v129 = v12;
    v120 = v18;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v120;
    v15 = v124;
    v12 = v129;
    v9 = v135;
    v6 = v142;
    v91 = v90;
    v3 = v150;
    a1 = v159;
    if (v91)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v163 = 95;
      v92 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v92)
        v93 = v92;
      else
        v93 = v163;
      v94 = &v162[v93];
      v95 = v163 - v93;
      if (v163 - v93 >= 0x12)
        v96 = 18;
      else
        v96 = v163 - v93;
      v97 = v95 - v96;
      if (v97 >= v97 - 1)
        v98 = v97 - 1;
      else
        v98 = v97;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v120;
      v15 = v124;
      v12 = v129;
      v9 = v135;
      v6 = v142;
      v3 = v150;
      a1 = v159;
    }
  }
  v21 = v20[312];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v151 = v3;
    v160 = a1;
    v136 = v9;
    v143 = v6;
    v125 = v15;
    v130 = v12;
    v118 = v21;
    v121 = v18;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v118;
    v18 = v121;
    v15 = v125;
    v12 = v130;
    v9 = v136;
    v6 = v143;
    v100 = v99;
    v3 = v151;
    a1 = v160;
    if (v100)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v163 = 99;
      v101 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v101)
        v102 = v101;
      else
        v102 = v163;
      v103 = &v162[v102];
      v104 = v163 - v102;
      if (v163 - v102 >= 0x12)
        v105 = 18;
      else
        v105 = v163 - v102;
      v106 = v104 - v105;
      if (v106 >= v106 - 1)
        v107 = v106 - 1;
      else
        v107 = v106;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v118;
      v18 = v121;
      v15 = v125;
      v12 = v130;
      v9 = v136;
      v6 = v143;
      v3 = v151;
      a1 = v160;
    }
  }
  v24 = v23[314];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v152 = v3;
    v161 = a1;
    v137 = v9;
    v144 = v6;
    v126 = v15;
    v131 = v12;
    v119 = v21;
    v122 = v18;
    v117 = v24;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v117;
    v21 = v119;
    v18 = v122;
    v15 = v126;
    v12 = v131;
    v9 = v137;
    v6 = v144;
    v109 = v108;
    v3 = v152;
    a1 = v161;
    if (v109)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v163 = 93;
      v110 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v110)
        v111 = v110;
      else
        v111 = v163;
      v112 = &v162[v111];
      v113 = v163 - v111;
      if (v163 - v111 >= 0x12)
        v114 = 18;
      else
        v114 = v163 - v111;
      v115 = v113 - v114;
      if (v115 >= v115 - 1)
        v116 = v115 - 1;
      else
        v116 = v115;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v117;
      v21 = v119;
      v18 = v122;
      v15 = v126;
      v12 = v131;
      v9 = v137;
      v6 = v144;
      v3 = v152;
      a1 = v161;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v26[21] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::AddIOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
  {
    return 0;
  }
  v6 = a1;
  return mlir::complex::CreateOp::verifyInvariantsImpl((uint64_t **)&v6) != 0;
}

uint64_t mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::DivOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.div", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::DivOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04E118;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::foldHook()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::DivOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::DivOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::DivOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::DivOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::DivOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::DivOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.div";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::EqualOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.eq", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::EqualOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04ECD0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::EqualOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::EqualOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::EqualOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::EqualOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::EqualOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::EqualOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::EqualOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::complex::EqualOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.eq";
  v16[1] = 10;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  const char *v209;
  unint64_t v210;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v198;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<Empty>]";
      v210 = 111;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = v8[509];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[419];
  v14 = &unk_25451A000;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = (_QWORD *)&unk_25451A000;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v210 = 90;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = (_QWORD *)&unk_25451A000;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[79];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v210 = 95;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[312];
  v23 = &unk_25451A000;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = (_QWORD *)&unk_25451A000;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v210 = 99;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = (_QWORD *)&unk_25451A000;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[314];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[21];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Elementwise<Empty>]";
      v210 = 83;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[322];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v32[27] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::MulSIExtendedOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::EqualOp>,mlir::OpTrait::OneResult<mlir::complex::EqualOp>,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::EqualOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::OpInvariants<mlir::complex::EqualOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::EqualOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::EqualOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::EqualOp>,mlir::OpTrait::Elementwise<mlir::complex::EqualOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::EqualOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::EqualOp>,mlir::OpTrait::OneResult<mlir::complex::EqualOp>,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::EqualOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::OpInvariants<mlir::complex::EqualOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::EqualOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::EqualOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::EqualOp>,mlir::OpTrait::Elementwise<mlir::complex::EqualOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::EqualOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (v7 = a1, mlir::complex::EqualOp::verifyInvariantsImpl((uint64_t **)&v7)))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v5) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ExpOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.exp", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ExpOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04E1E0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::ExpOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ExpOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ExpOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ExpOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ExpOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ExpOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.exp";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::complex::detail::ExpOpGenericAdaptorBase::ExpOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::ExpOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Expm1Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.expm1", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::Expm1Op,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04ED98;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::Expm1Op::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Expm1Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Expm1Op>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Expm1Op>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Expm1Op>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Expm1Op>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.expm1";
  v16[1] = 13;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ImOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.im", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ImOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04DD30;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::complex::ImOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::ImOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ImOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ImOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ImOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ImOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ImOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.im";
  v16[1] = 10;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::complex::detail::ImOpGenericAdaptorBase::ImOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::ImOp::fold((uint64_t)&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v8 = a1, mlir::complex::AbsOp::verifyInvariantsImpl((uint64_t **)&v8)))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Log1pOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.log1p", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::Log1pOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04EE60;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::foldHook()
{
  unsigned int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::Log1pOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Log1pOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Log1pOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Log1pOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Log1pOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Log1pOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.log1p";
  v16[1] = 13;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::LogOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.log", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::LogOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04E2A8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::LogOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::LogOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::LogOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::LogOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::LogOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::LogOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.log";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::complex::detail::LogOpGenericAdaptorBase::LogOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::LogOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::MulOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.mul", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::MulOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04E370;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::MulOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::MulOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::MulOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::MulOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::MulOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::MulOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.mul";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::complex::detail::MulOpGenericAdaptorBase::MulOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::MulOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NegOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.neg", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NegOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04E438;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _BOOL8 v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::NegOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NegOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NegOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NegOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::NegOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::NegOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.neg";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::complex::detail::NegOpGenericAdaptorBase::NegOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::NegOp::fold((uint64_t)&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NotEqualOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.neq", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NotEqualOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04DC68;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::foldHook()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::NotEqualOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NotEqualOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NotEqualOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NotEqualOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::EqualOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::NotEqualOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::NotEqualOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::complex::EqualOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.neq";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::MulSIExtendedOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::EqualOp>,mlir::OpTrait::OneResult<mlir::complex::EqualOp>,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::EqualOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::OpInvariants<mlir::complex::EqualOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::EqualOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::EqualOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::EqualOp>,mlir::OpTrait::Elementwise<mlir::complex::EqualOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::EqualOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::PowOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.pow", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::PowOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04E500;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::foldHook()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::PowOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::PowOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::PowOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::PowOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::PowOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::PowOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.pow";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ReOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.re", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ReOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04DDF8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::getCanonicalizationPatterns(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  mlir::complex::ReOp::getCanonicalizationPatterns(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::ReOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ReOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ReOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ReOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ReOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ReOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.re";
  v16[1] = 10;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::complex::detail::ReOpGenericAdaptorBase::ReOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::ReOp::fold((uint64_t)&v13, (uint64_t)v14);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (v8 = a1, mlir::complex::AbsOp::verifyInvariantsImpl((uint64_t **)&v8)))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::RsqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.rsqrt", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::RsqrtOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04EF28;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::foldHook()
{
  unsigned int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::RsqrtOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::RsqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::RsqrtOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::RsqrtOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::RsqrtOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::RsqrtOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.rsqrt";
  v16[1] = 13;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.sign", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::SignOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04E8E8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::SignOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SignOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SignOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SignOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SignOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SignOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.sign";
  v16[1] = 12;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.sin", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::SinOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04E5C8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::SinOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SinOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SinOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SinOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SinOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SinOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.sin";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.sqrt", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::SqrtOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04E9B0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::SqrtOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SqrtOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SqrtOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SqrtOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SqrtOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.sqrt";
  v16[1] = 12;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SubOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.sub", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::SubOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04E690;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::complex::SubOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SubOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SubOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SubOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SubOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SubOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.sub";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v13;
  _BYTE v14[48];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v13 = a2;
  mlir::complex::detail::SubOpGenericAdaptorBase::SubOpGenericAdaptorBase((uint64_t)v14, a2);
  v15 = a3;
  v16 = a4;
  v9 = mlir::complex::SubOp::fold(&v13);
  v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    return v9 > 7;
  v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.tan", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::TanOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04E758;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::TanOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::TanOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::TanOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.tan";
  v16[1] = 11;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanhOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.tanh", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::TanhOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C04EA78;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::TanhOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanhOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanhOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanhOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  ZinIrHalH13g::~ZinIrHalH13g((ZinIrHalH13g *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getFastMathAttrName;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      v15 = 85;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[272], v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::isCompatibleReturnTypes;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[7], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::TanhOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::TanhOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  uint64_t v13;
  void *v14;
  _QWORD v16[2];
  unint64_t v17[2];
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[5];

  v11 = a3;
  v22[4] = *MEMORY[0x24BDAC8D0];
  v20 = v22;
  v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    v13 = 0;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    v13 = 1;
    v14 = v20;
    if (v20 == v22)
      return v13;
    goto LABEL_7;
  }
  v16[0] = "complex.tanh";
  v16[1] = 12;
  v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  v14 = v20;
  if (v20 != v22)
LABEL_7:
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t *mlir::Dialect::addAttribute<mlir::complex::NumberAttr>(uint64_t a1)
{
  char v2;
  llvm **v3;
  uint64_t *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  uint64_t *AttributeUniquer;
  _BYTE v10[8];
  void *v11;
  unsigned int v12;
  uint64_t v13;
  llvm *v14[2];
  unint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  mlir::AbstractAttribute::get<mlir::complex::NumberAttr>(a1, (uint64_t)v10);
  mlir::Dialect::addAttribute(a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id, (uint64_t)v10);
  v2 = v15;
  if (v15 >= 8)
  {
    if ((v15 & 4) != 0)
    {
      if ((v15 & 2) != 0)
        v3 = v14;
      else
        v3 = (llvm **)v14[0];
      (*(void (**)(llvm **))((v15 & 0xFFFFFFFFFFFFFFF8) + 16))(v3);
    }
    if ((v2 & 2) == 0)
      llvm::deallocate_buffer(v14[0], v14[1]);
  }
  v4 = (uint64_t *)v11;
  if (v12)
  {
    v5 = 16 * v12;
    v6 = (void **)((char *)v11 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = (uint64_t *)v11;
  }
  if (v4 != &v13)
    free(v4);
  AttributeUniquer = (uint64_t *)mlir::MLIRContext::getAttributeUniquer(*(mlir::MLIRContext **)(a1 + 32));
  return mlir::StorageUniquer::registerParametricStorageTypeImpl(AttributeUniquer, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id, (uint64_t)llvm::function_ref<void ()(mlir::StorageUniquer::BaseStorage *)>::callback_fn<void mlir::StorageUniquer::registerParametricStorageType<mlir::complex::detail::NumberAttrStorage>(mlir::TypeID)::{lambda(mlir::StorageUniquer::BaseStorage *)#1}>, (uint64_t)v10);
}

void mlir::AbstractAttribute::get<mlir::complex::NumberAttr>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  char v8;
  char v9;
  __int128 v10;
  void *v11;
  uint64_t v12;
  _QWORD v13[7];

  v13[6] = *MEMORY[0x24BDAC8D0];
  v11 = v13;
  v12 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::TypedAttrInterfaceTraits::Model<mlir::complex::NumberAttr>>((uint64_t)&v11);
  *(_QWORD *)a2 = a1;
  *(_QWORD *)(a2 + 8) = a2 + 24;
  *(_QWORD *)(a2 + 16) = 0x300000000;
  if ((_DWORD)v12)
    llvm::SmallVectorImpl<std::pair<mlir::TypeID,void *>>::operator=(a2 + 8, (uint64_t)&v11);
  *(_QWORD *)(a2 + 96) = (char *)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks
                       + 2;
  if ((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks
     + 2 >= 8)
  {
    *(_QWORD *)(a2 + 72) = mlir::detail::StorageUserBase<mlir::complex::NumberAttr,mlir::Attribute,mlir::complex::detail::NumberAttrStorage,mlir::detail::AttributeUniquer,mlir::TypedAttr::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke;
    *(_OWORD *)(a2 + 80) = v10;
  }
  *(_QWORD *)(a2 + 104) = _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_7complex10NumberAttrES2_NSD_6detail17NumberAttrStorageENSB_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_;
  *(_QWORD *)(a2 + 112) = &v9;
  *(_QWORD *)(a2 + 120) = _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_7complex10NumberAttrES2_NSC_6detail17NumberAttrStorageENSA_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_;
  *(_QWORD *)(a2 + 128) = &v8;
  *(_QWORD *)(a2 + 136) = &mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id;
  v4 = v11;
  if ((_DWORD)v12)
  {
    v5 = 16 * v12;
    v6 = (void **)((char *)v11 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v11;
  }
  if (v4 != v13)
    free(v4);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::TypedAttrInterfaceTraits::Model<mlir::complex::NumberAttr>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::TypedAttrInterfaceTraits::Model<mlir::complex::NumberAttr>::getType;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::TypedAttr]";
      v15 = 65;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::TypedAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[268], v2);
}

uint64_t mlir::detail::TypedAttrInterfaceTraits::Model<mlir::complex::NumberAttr>::getType(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 72);
}

BOOL mlir::detail::StorageUserBase<mlir::complex::NumberAttr,mlir::Attribute,mlir::complex::detail::NumberAttrStorage,mlir::detail::AttributeUniquer,mlir::TypedAttr::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  int v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  v2 = &unk_25451B000;
  if ((v1 & 1) == 0)
  {
    v13 = a1;
    v2 = (_QWORD *)&unk_25451B000;
    v5 = v4;
    a1 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::TypedAttr::Trait<Empty>]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::TypedAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::TypedAttr::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v2 = (_QWORD *)&unk_25451B000;
      a1 = v13;
    }
  }
  return v2[31] == a1;
}

void _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_7complex10NumberAttrES2_NSD_6detail17NumberAttrStorageENSB_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  mlir::detail::walkImmediateSubElementsImpl<mlir::complex::NumberAttr>(a2, a3, a4, a5, a6);
}

void mlir::detail::walkImmediateSubElementsImpl<mlir::complex::NumberAttr>(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const llvm::detail::DoubleAPFloat *v10;
  void *v11;
  void *v12;
  const llvm::detail::DoubleAPFloat *v13;
  _QWORD v14[4];
  _QWORD v15[4];
  _QWORD v16[3];
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v10 = (const llvm::detail::DoubleAPFloat *)(a1 + 2);
  v11 = (void *)a1[2];
  v12 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
  if (v12 == v11)
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v15, v10);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v15, v10);
  v13 = (const llvm::detail::DoubleAPFloat *)(a1 + 6);
  if (v12 == (void *)a1[6])
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v16, v13);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v16, v13);
  v17 = a1[9];
  v14[0] = a2;
  v14[1] = a3;
  v14[2] = a4;
  v14[3] = a5;
  mlir::AttrTypeImmediateSubElementWalker::walk((uint64_t)v14, v17);
  if (v12 == (void *)v16[0])
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v16);
    if (v12 != (void *)v15[0])
      goto LABEL_9;
LABEL_12:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v15);
    return;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v16);
  if (v12 == (void *)v15[0])
    goto LABEL_12;
LABEL_9:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v15);
}

uint64_t _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_7complex10NumberAttrES2_NSC_6detail17NumberAttrStorageENSA_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  uint64_t *v7[2];
  _QWORD v8[2];

  v8[0] = a3;
  v8[1] = a4;
  v7[0] = a5;
  v7[1] = a6;
  return mlir::detail::replaceImmediateSubElementsImpl<mlir::complex::NumberAttr>(a2, (uint64_t)v8, v7);
}

uint64_t mlir::detail::replaceImmediateSubElementsImpl<mlir::complex::NumberAttr>(_QWORD *a1, uint64_t a2, uint64_t **a3)
{
  const llvm::detail::DoubleAPFloat *v5;
  void *v6;
  void *v7;
  const llvm::detail::DoubleAPFloat *v8;
  uint64_t v9;
  mlir::MLIRContext *Context;
  llvm::APFloatBase *AttributeUniquer;
  uint64_t v12;
  uint64_t v14;
  _QWORD *v15;
  _QWORD v16[2];
  _BYTE v17[8];
  _QWORD v18[3];
  uint64_t v19;
  _QWORD v20[3];
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v15 = a1;
  v5 = (const llvm::detail::DoubleAPFloat *)(a1 + 2);
  v6 = (void *)a1[2];
  v7 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
  if (v7 == v6)
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v18, v5);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v18, v5);
  v8 = (const llvm::detail::DoubleAPFloat *)(a1 + 6);
  if (v7 == (void *)a1[6])
  {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v20, v8);
    v21 = a1[9];
    if (v21)
      goto LABEL_6;
  }
  else
  {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v20, v8);
    v21 = a1[9];
    if (v21)
    {
LABEL_6:
      v9 = **a3;
      goto LABEL_9;
    }
  }
  v9 = 0;
LABEL_9:
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
  v14 = v9;
  AttributeUniquer = (llvm::APFloatBase *)mlir::MLIRContext::getAttributeUniquer(Context);
  v16[0] = &mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id;
  v16[1] = Context;
  v12 = mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir7complex6detail17NumberAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_10NumberAttrEJRKNS_7APFloatESF_RNS1_4TypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESK_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSM_E_EEvlS5_, (uint64_t)v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id, (uint64_t)v17, (uint64_t)&v19, &v14);
  if (v7 == (void *)v20[0])
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v20);
    if (v7 != (void *)v18[0])
      goto LABEL_11;
LABEL_14:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v18);
    return v12;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v20);
  if (v7 == (void *)v18[0])
    goto LABEL_14;
LABEL_11:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v18);
  return v12;
}

uint64_t mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  const llvm::detail::DoubleAPFloat *v11;
  void *v12;
  void *v13;
  const llvm::detail::DoubleAPFloat *v14;
  unsigned int v15;
  uint64_t ParametricStorageTypeImpl;
  _QWORD v18[2];
  _BYTE *v19;
  _QWORD v20[2];
  _BYTE v21[8];
  _QWORD v22[3];
  uint64_t v23;
  _QWORD v24[3];
  _QWORD v25[2];

  v25[1] = *MEMORY[0x24BDAC8D0];
  v20[0] = a2;
  v20[1] = a3;
  v11 = (const llvm::detail::DoubleAPFloat *)(a5 + 8);
  v12 = *(void **)(a5 + 8);
  v13 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v13 == v12)
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v22, v11);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v22, v11);
  v14 = (const llvm::detail::DoubleAPFloat *)(a6 + 8);
  if (v13 == *(void **)(a6 + 8))
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v24, v14);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v24, v14);
  v25[0] = *a7;
  v15 = llvm::hash_combine<llvm::APFloat,llvm::APFloat,mlir::Type>((llvm *)v21, (const llvm::APFloat *)&v23, v25);
  v18[0] = v21;
  v18[1] = v20;
  v19 = v21;
  ParametricStorageTypeImpl = mlir::StorageUniquer::getParametricStorageTypeImpl((unsigned __int8 **)a1, a4, v15, (uint64_t (*)(uint64_t))llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, (uint64_t)&v19, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, (uint64_t)v18);
  if (v13 == (void *)v24[0])
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v24);
    if (v13 != (void *)v22[0])
      goto LABEL_9;
LABEL_12:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22);
    return ParametricStorageTypeImpl;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v24);
  if (v13 == (void *)v22[0])
    goto LABEL_12;
LABEL_9:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v22);
  return ParametricStorageTypeImpl;
}

unint64_t llvm::hash_combine<llvm::APFloat,llvm::APFloat,mlir::Type>(llvm *a1, const llvm::APFloat *a2, _DWORD *a3)
{
  unsigned __int8 v5;
  const llvm::APFloat *v6;
  unint64_t v7;
  char *v8;
  char *v9;
  llvm *v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _OWORD v16[4];
  _OWORD v17[3];
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v18 = 0;
  memset(v17, 0, sizeof(v17));
  memset(v16, 0, sizeof(v16));
  if ((v5 & 1) == 0)
  {
    v11 = a1;
    a1 = v11;
    if (v12)
    {
      v13 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v13 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v13;
      a1 = v11;
    }
  }
  v19 = llvm::hashing::detail::get_execution_seed(void)::seed;
  *(_QWORD *)&v16[0] = llvm::hash_value(a1, a2);
  v14 = 0;
  v7 = llvm::hash_value(a2, v6);
  v8 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v16, (uint64_t *)&v14, (_QWORD *)v16 + 1, (unint64_t)v17, v7);
  v15 = v14;
  v9 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v16, (uint64_t *)&v15, v8, (unint64_t)v17, (*a3 >> 4) ^ (*a3 >> 9));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine((llvm::hashing::detail::hash_combine_recursive_helper *)v16, v15, v9, (char *)v17);
}

uint64_t llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(llvm::APFloatBase *a1, _QWORD *a2)
{
  uint64_t v2;
  llvm::detail::DoubleAPFloat *v3;
  void *v4;
  const llvm::detail::DoubleAPFloat *v5;
  uint64_t result;
  void *v8;
  llvm::detail::IEEEFloat *v9;
  void *v10;
  const llvm::detail::IEEEFloat *v11;

  v2 = *(_QWORD *)a1;
  v3 = (llvm::detail::DoubleAPFloat *)(a2 + 2);
  v4 = (void *)a2[2];
  v5 = (const llvm::detail::DoubleAPFloat *)(*(_QWORD *)a1 + 8);
  if (v4 != *(void **)v5)
    return 0;
  v8 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v8 == v4)
  {
    result = llvm::detail::DoubleAPFloat::bitwiseIsEqual(v3, v5);
    if (!(_DWORD)result)
      return result;
  }
  else if (!llvm::detail::IEEEFloat::bitwiseIsEqual(v3, v5))
  {
    return 0;
  }
  v9 = (llvm::detail::IEEEFloat *)(a2 + 6);
  v10 = (void *)a2[6];
  v11 = (const llvm::detail::IEEEFloat *)(v2 + 40);
  if (v10 != *(void **)(v2 + 40))
    return 0;
  if (v8 != v10)
  {
    if (!llvm::detail::IEEEFloat::bitwiseIsEqual(v9, v11))
      return 0;
    return a2[9] == *(_QWORD *)(v2 + 64);
  }
  result = llvm::detail::DoubleAPFloat::bitwiseIsEqual(v9, v11);
  if ((_DWORD)result)
    return a2[9] == *(_QWORD *)(v2 + 64);
  return result;
}

_QWORD *llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t a1, uint64_t *a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = mlir::complex::detail::NumberAttrStorage::construct(a2, *(_QWORD **)a1);
  v4 = *(_QWORD *)(a1 + 8);
  if (*(_QWORD *)v4)
    (*(void (**)(_QWORD, _QWORD *))v4)(*(_QWORD *)(v4 + 8), v3);
  return v3;
}

_QWORD *mlir::complex::detail::NumberAttrStorage::construct(uint64_t *a1, _QWORD *a2)
{
  _QWORD *v4;
  void *v5;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unsigned int v11;
  uint64_t v12;
  char *buffer;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD v18[3];
  _QWORD v19[3];
  _QWORD v20[3];
  _QWORD v21[4];

  v21[3] = *MEMORY[0x24BDAC8D0];
  v4 = a2 + 1;
  v5 = (void *)a2[1];
  v6 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
  if (v6 == v5)
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v21, v4);
  else
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v21, (uint64_t)v4);
  v7 = a2 + 5;
  if (v6 == (void *)a2[5])
  {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v20, v7);
    v8 = a2[8];
    a1[10] += 80;
    v9 = *a1;
    if (!*a1)
      goto LABEL_10;
  }
  else
  {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v20, (uint64_t)v7);
    v8 = a2[8];
    a1[10] += 80;
    v9 = *a1;
    if (!*a1)
      goto LABEL_10;
  }
  if (((v9 + 7) & 0xFFFFFFFFFFFFFFF8) - v9 + 80 <= a1[1] - v9)
  {
    v10 = (_QWORD *)((v9 + 7) & 0xFFFFFFFFFFFFFFF8);
    goto LABEL_15;
  }
LABEL_10:
  v11 = *((_DWORD *)a1 + 6) >> 7;
  if (v11 >= 0x1E)
    LOBYTE(v11) = 30;
  v12 = 4096 << v11;
  buffer = (char *)llvm::allocate_buffer(4096 << v11, (std::align_val_t)8uLL);
  v14 = *((unsigned int *)a1 + 6);
  if (v14 >= *((_DWORD *)a1 + 7))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(a1 + 2), a1 + 4, v14 + 1, 8);
    LODWORD(v14) = *((_DWORD *)a1 + 6);
  }
  *(_QWORD *)(a1[2] + 8 * v14) = buffer;
  ++*((_DWORD *)a1 + 6);
  a1[1] = (uint64_t)&buffer[v12];
  v10 = (_QWORD *)((unint64_t)(buffer + 7) & 0xFFFFFFFFFFFFFFF8);
LABEL_15:
  *a1 = (uint64_t)(v10 + 10);
  if (v6 == (void *)v21[0])
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v19, v21);
  else
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v19, (uint64_t)v21);
  if (v6 == (void *)v20[0])
  {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v18, v20);
    *v10 = 0;
    v15 = v10 + 2;
    if (v6 != (void *)v19[0])
    {
LABEL_20:
      llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v15, (uint64_t)v19);
      v16 = v10 + 6;
      if (v6 != (void *)v18[0])
        goto LABEL_21;
      goto LABEL_29;
    }
  }
  else
  {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v18, (uint64_t)v20);
    *v10 = 0;
    v15 = v10 + 2;
    if (v6 != (void *)v19[0])
      goto LABEL_20;
  }
  llvm::detail::DoubleAPFloat::DoubleAPFloat(v15, v19);
  v16 = v10 + 6;
  if (v6 != (void *)v18[0])
  {
LABEL_21:
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v16, (uint64_t)v18);
    v10[9] = v8;
    if (v6 != (void *)v18[0])
      goto LABEL_22;
    goto LABEL_30;
  }
LABEL_29:
  llvm::detail::DoubleAPFloat::DoubleAPFloat(v16, v18);
  v10[9] = v8;
  if (v6 != (void *)v18[0])
  {
LABEL_22:
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v18);
    if (v6 != (void *)v19[0])
      goto LABEL_23;
    goto LABEL_31;
  }
LABEL_30:
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v18);
  if (v6 != (void *)v19[0])
  {
LABEL_23:
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v19);
    if (v6 != (void *)v20[0])
      goto LABEL_24;
LABEL_32:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v20);
    if (v6 != (void *)v21[0])
      goto LABEL_25;
LABEL_33:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v21);
    return v10;
  }
LABEL_31:
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v19);
  if (v6 == (void *)v20[0])
    goto LABEL_32;
LABEL_24:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v20);
  if (v6 == (void *)v21[0])
    goto LABEL_33;
LABEL_25:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v21);
  return v10;
}

_QWORD *_ZN4llvm12function_refIFvPN4mlir7complex6detail17NumberAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_10NumberAttrEJRKNS_7APFloatESF_RNS1_4TypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESK_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSM_E_EEvlS5_(uint64_t *a1, _QWORD *a2)
{
  return mlir::detail::AttributeUniquer::initializeAttributeStorage(a2, a1[1], *a1);
}

void llvm::function_ref<void ()(mlir::StorageUniquer::BaseStorage *)>::callback_fn<void mlir::StorageUniquer::registerParametricStorageType<mlir::complex::detail::NumberAttrStorage>(mlir::TypeID)::{lambda(mlir::StorageUniquer::BaseStorage *)#1}>(llvm::APFloatBase *a1, uint64_t a2)
{
  llvm::detail::DoubleAPFloat *v3;
  void *v4;
  void *v5;
  llvm::detail::IEEEFloat *v6;

  v3 = (llvm::detail::DoubleAPFloat *)(a2 + 48);
  v4 = *(void **)(a2 + 48);
  v5 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v5 == v4)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat(v3);
    v6 = (llvm::detail::IEEEFloat *)(a2 + 16);
    if (v5 != *(void **)(a2 + 16))
      goto LABEL_3;
  }
  else
  {
    llvm::detail::IEEEFloat::~IEEEFloat(v3);
    v6 = (llvm::detail::IEEEFloat *)(a2 + 16);
    if (v5 != *(void **)(a2 + 16))
    {
LABEL_3:
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      return;
    }
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
}

uint64_t mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7)
{
  const llvm::detail::DoubleAPFloat *v11;
  void *v12;
  void *v13;
  const llvm::detail::DoubleAPFloat *v14;
  unsigned int v15;
  uint64_t ParametricStorageTypeImpl;
  _QWORD v18[2];
  _BYTE *v19;
  _QWORD v20[2];
  _BYTE v21[8];
  _QWORD v22[3];
  uint64_t v23;
  _QWORD v24[3];
  _QWORD v25[2];

  v25[1] = *MEMORY[0x24BDAC8D0];
  v20[0] = a2;
  v20[1] = a3;
  v11 = (const llvm::detail::DoubleAPFloat *)(a5 + 8);
  v12 = *(void **)(a5 + 8);
  v13 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v13 == v12)
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v22, v11);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v22, v11);
  v14 = (const llvm::detail::DoubleAPFloat *)(a6 + 8);
  if (v13 == *(void **)(a6 + 8))
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v24, v14);
  else
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v24, v14);
  v25[0] = *a7;
  v15 = llvm::hash_combine<llvm::APFloat,llvm::APFloat,mlir::Type>((llvm *)v21, (const llvm::APFloat *)&v23, v25);
  v18[0] = v21;
  v18[1] = v20;
  v19 = v21;
  ParametricStorageTypeImpl = mlir::StorageUniquer::getParametricStorageTypeImpl((unsigned __int8 **)a1, a4, v15, (uint64_t (*)(uint64_t))llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, (uint64_t)&v19, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, (uint64_t)v18);
  if (v13 == (void *)v24[0])
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v24);
    if (v13 != (void *)v22[0])
      goto LABEL_9;
LABEL_12:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22);
    return ParametricStorageTypeImpl;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v24);
  if (v13 == (void *)v22[0])
    goto LABEL_12;
LABEL_9:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v22);
  return ParametricStorageTypeImpl;
}

uint64_t llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(llvm::APFloatBase *a1, _QWORD *a2)
{
  uint64_t v2;
  llvm::detail::DoubleAPFloat *v3;
  void *v4;
  const llvm::detail::DoubleAPFloat *v5;
  uint64_t result;
  void *v8;
  llvm::detail::IEEEFloat *v9;
  void *v10;
  const llvm::detail::IEEEFloat *v11;

  v2 = *(_QWORD *)a1;
  v3 = (llvm::detail::DoubleAPFloat *)(a2 + 2);
  v4 = (void *)a2[2];
  v5 = (const llvm::detail::DoubleAPFloat *)(*(_QWORD *)a1 + 8);
  if (v4 != *(void **)v5)
    return 0;
  v8 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v8 == v4)
  {
    result = llvm::detail::DoubleAPFloat::bitwiseIsEqual(v3, v5);
    if (!(_DWORD)result)
      return result;
  }
  else if (!llvm::detail::IEEEFloat::bitwiseIsEqual(v3, v5))
  {
    return 0;
  }
  v9 = (llvm::detail::IEEEFloat *)(a2 + 6);
  v10 = (void *)a2[6];
  v11 = (const llvm::detail::IEEEFloat *)(v2 + 40);
  if (v10 != *(void **)(v2 + 40))
    return 0;
  if (v8 != v10)
  {
    if (!llvm::detail::IEEEFloat::bitwiseIsEqual(v9, v11))
      return 0;
    return a2[9] == *(_QWORD *)(v2 + 64);
  }
  result = llvm::detail::DoubleAPFloat::bitwiseIsEqual(v9, v11);
  if ((_DWORD)result)
    return a2[9] == *(_QWORD *)(v2 + 64);
  return result;
}

_QWORD *llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t a1, uint64_t *a2)
{
  _QWORD *v3;
  uint64_t v4;

  v3 = mlir::complex::detail::NumberAttrStorage::construct(a2, *(_QWORD **)a1);
  v4 = *(_QWORD *)(a1 + 8);
  if (*(_QWORD *)v4)
    (*(void (**)(_QWORD, _QWORD *))v4)(*(_QWORD *)(v4 + 8), v3);
  return v3;
}

_QWORD *_ZN4llvm12function_refIFvPN4mlir7complex6detail17NumberAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_10NumberAttrEJRNS_7APFloatESE_RNS1_11ComplexTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESJ_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSL_E_EEvlS5_(uint64_t *a1, _QWORD *a2)
{
  return mlir::detail::AttributeUniquer::initializeAttributeStorage(a2, a1[1], *a1);
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::StringAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::StringAttr]";
  v41 = 66;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

void mlir::cf::BranchOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;

  v9 = *(unsigned int *)(a2 + 208);
  if (v9 >= *(_DWORD *)(a2 + 212))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 200, (void *)(a2 + 216), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 208);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 200) + 8 * v9) = a3;
  ++*(_DWORD *)(a2 + 208);
  mlir::OperationState::addOperands(a2, a4, a5);
}

void mlir::OperationState::addSuccessors(mlir::OperationState *this, mlir::Block *a2)
{
  uint64_t v4;

  v4 = *((unsigned int *)this + 52);
  if (v4 >= *((_DWORD *)this + 53))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)this + 200, (char *)this + 216, v4 + 1, 8);
    LODWORD(v4) = *((_DWORD *)this + 52);
  }
  *(_QWORD *)(*((_QWORD *)this + 25) + 8 * v4) = a2;
  ++*((_DWORD *)this + 52);
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  const void ***v9;
  char *v10;
  char *v11;
  __int128 v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  const void ***v17;
  char *v18;
  char *v19;
  __int128 v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  int64_t v36;
  int64_t v37;
  int64_t v38;
  _WORD v39[20];
  uint64_t v40;
  const void **v41;
  unint64_t v42;
  uint64_t v43;
  __int16 v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  unsigned int v48;
  unsigned int v49;
  _BYTE v50[96];
  void *v51;
  _QWORD *v52;
  void *__p;
  _QWORD *v54;
  char v55;
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  v40 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v40))
    return 0;
  v4 = v40;
  if (!v40)
    return 1;
  v5 = mlir::DenseIntElementsAttr::classof(v40);
  v6 = v5 ? v4 : 0;
  *a2 = v6;
  if ((v5 & 1) != 0)
    return 1;
  v39[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v45, a1, v39);
  if (v45)
  {
    LODWORD(v41) = 3;
    v42 = (unint64_t)"expected ";
    v43 = 9;
    v9 = &v41;
    v10 = (char *)v47;
    if (v48 >= v49)
    {
      v33 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        v36 = (char *)&v41 - (_BYTE *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v33, 24);
        v10 = (char *)v47;
        v9 = (const void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v33, 24);
        v9 = &v41;
        v10 = (char *)v47;
      }
    }
    v11 = &v10[24 * v48];
    v12 = *(_OWORD *)v9;
    *((_QWORD *)v11 + 2) = v9[2];
    *(_OWORD *)v11 = v12;
    ++v48;
  }
  v41 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::DenseIntElementsAttr]";
  v42 = 76;
  v13 = llvm::StringRef::find((uint64_t *)&v41, "DesiredTypeName = ", 0x12uLL, 0);
  if (v45)
  {
    if (v42 >= v13)
      v14 = v13;
    else
      v14 = v42;
    v15 = 18;
    if (v42 - v14 < 0x12)
      v15 = v42 - v14;
    v16 = v42 - v14 - v15;
    if (v16 >= v16 - 1)
      --v16;
    v44 = 261;
    v41 = (const void **)((char *)v41 + v14 + v15);
    v42 = v16;
    mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
    if (v45)
    {
      LODWORD(v41) = 3;
      v42 = (unint64_t)", but got: ";
      v43 = 11;
      v17 = &v41;
      v18 = (char *)v47;
      if (v48 >= v49)
      {
        v34 = v48 + 1;
        if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
        {
          v37 = (char *)&v41 - (_BYTE *)v47;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
          v18 = (char *)v47;
          v17 = (const void ***)((char *)v47 + v37);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
          v17 = &v41;
          v18 = (char *)v47;
        }
      }
      v19 = &v18[24 * v48];
      v20 = *(_OWORD *)v17;
      *((_QWORD *)v19 + 2) = v17[2];
      *(_OWORD *)v19 = v20;
      ++v48;
      if (v45)
      {
        v21 = &v41;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v41, v40);
        v22 = (char *)v47;
        if (v48 >= v49)
        {
          v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            v38 = (char *)&v41 - (_BYTE *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v22 = (char *)v47;
            v21 = (const void ***)((char *)v47 + v38);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v21 = &v41;
            v22 = (char *)v47;
          }
        }
        v23 = &v22[24 * v48];
        v24 = *(_OWORD *)v21;
        *((_QWORD *)v23 + 2) = v21[2];
        *(_OWORD *)v23 = v24;
        ++v48;
      }
    }
  }
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  if (v55)
  {
    v25 = __p;
    if (__p)
    {
      v26 = v54;
      v27 = __p;
      if (v54 != __p)
      {
        do
          v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        v27 = __p;
      }
      v54 = v25;
      operator delete(v27);
    }
    v28 = v51;
    if (v51)
    {
      v29 = v52;
      v30 = v51;
      if (v52 != v51)
      {
        do
        {
          v32 = *--v29;
          v31 = v32;
          *v29 = 0;
          if (v32)
            MEMORY[0x20BD002D4](v31, 0x1000C8077774924);
        }
        while (v29 != v28);
        v30 = v51;
      }
      v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50)
      free(v47);
  }
  return v7;
}

uint64_t mlir::Dialect::materializeConstant()
{
  return 0;
}

uint64_t mlir::AsmParser::parseInteger<long long>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  const char *v15;
  __int16 v16;
  _QWORD v17[3];
  void *v18;
  uint64_t v19;
  void *v20;
  _QWORD *v21;
  void *__p;
  _QWORD *v23;
  char v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v5 = mlir::AsmParser::parseOptionalInteger<long long>(a1, a2);
  if ((unsigned __int16)v5 <= 0xFFu)
  {
    v15 = "expected integer value";
    v16 = 259;
    (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v17, a1, v4, &v15);
    v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v17);
    if (v17[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v17);
    if (v24)
    {
      v6 = __p;
      if (__p)
      {
        v7 = v23;
        v8 = __p;
        if (v23 != __p)
        {
          do
            v7 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v7 - 1);
          while (v7 != v6);
          v8 = __p;
        }
        v23 = v6;
        operator delete(v8);
      }
      v9 = v20;
      if (v20)
      {
        v10 = v21;
        v11 = v20;
        if (v21 != v20)
        {
          do
          {
            v13 = *--v10;
            v12 = v13;
            *v10 = 0;
            if (v13)
              MEMORY[0x20BD002D4](v12, 0x1000C8077774924);
          }
          while (v10 != v9);
          v11 = v20;
        }
        v21 = v9;
        operator delete(v11);
      }
      if (v18 != &v19)
        free(v18);
    }
  }
  return v5;
}

uint64_t llvm::SmallVectorImpl<mlir::OpAsmParser::UnresolvedOperand>::operator=(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  void *v6;
  _DWORD *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a1 != a2)
  {
    v5 = (const void *)(a2 + 16);
    v4 = *(const void **)a2;
    if (v4 != v5)
    {
      v6 = *(void **)a1;
      if (*(_QWORD *)a1 != a1 + 16)
      {
        free(v6);
        v4 = *(const void **)a2;
      }
      *(_QWORD *)a1 = v4;
      v7 = (_DWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
      goto LABEL_16;
    }
    v7 = (_DWORD *)(a2 + 8);
    v8 = *(unsigned int *)(a2 + 8);
    v9 = *(unsigned int *)(a1 + 8);
    if (v9 >= v8)
    {
      if ((_DWORD)v8)
        memmove(*(void **)a1, v4, 32 * v8 - 4);
      goto LABEL_15;
    }
    if (*(_DWORD *)(a1 + 12) >= v8)
    {
      if ((_DWORD)v9)
      {
        memmove(*(void **)a1, v4, 32 * v9 - 4);
        v10 = *v7;
        if (v9 == v10)
        {
LABEL_15:
          *(_DWORD *)(a1 + 8) = v8;
LABEL_16:
          *v7 = 0;
          return a1;
        }
      }
      else
      {
        v9 = 0;
        v10 = *v7;
        if (!*v7)
          goto LABEL_15;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v8, 32);
      v9 = 0;
      v10 = *v7;
      if (!*v7)
        goto LABEL_15;
    }
    memcpy((void *)(*(_QWORD *)a1 + 32 * v9), (const void *)(*(_QWORD *)a2 + 32 * v9), *(_QWORD *)a2 + 32 * v10 - (*(_QWORD *)a2 + 32 * v9));
    goto LABEL_15;
  }
  return a1;
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  int v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  const char *v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  unint64_t v35;
  unint64_t v36;
  const char *v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  unint64_t v44;
  unint64_t v45;
  const char *v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  unint64_t v53;
  unint64_t v54;
  const char *v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  unint64_t v62;
  unint64_t v63;
  const char *v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  unint64_t v71;
  unint64_t v72;
  const char *v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  const char *v99;
  unint64_t v100;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v93 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v25 = v24;
    a1 = v93;
    if (v25)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v100 = 83;
      v26 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v26)
        v27 = v26;
      else
        v27 = v100;
      v28 = &v99[v27];
      v29 = v100 - v27;
      if (v100 - v27 >= 0x12)
        v30 = 18;
      else
        v30 = v100 - v27;
      v31 = v29 - v30;
      if (v31 >= v31 - 1)
        v32 = v31 - 1;
      else
        v32 = v31;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v28[v30], v32);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v93;
    }
  }
  v3 = v2[13];
  v5 = &unk_254519000;
  if ((v4 & 1) == 0)
  {
    v88 = v3;
    v94 = a1;
    v5 = (_QWORD *)&unk_254519000;
    v34 = v33;
    v3 = v88;
    a1 = v94;
    if (v34)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      v100 = 83;
      v35 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v35)
        v36 = v35;
      else
        v36 = v100;
      v37 = &v99[v36];
      v38 = v100 - v36;
      if (v100 - v36 >= 0x12)
        v39 = 18;
      else
        v39 = v100 - v36;
      v40 = v38 - v39;
      if (v40 >= v40 - 1)
        v41 = v40 - 1;
      else
        v41 = v40;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v37[v39], v41);
      v5 = (_QWORD *)&unk_254519000;
      v3 = v88;
      a1 = v94;
    }
  }
  v6 = v5[417];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v89 = v3;
    v95 = a1;
    v84 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v84;
    v3 = v89;
    v43 = v42;
    a1 = v95;
    if (v43)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v100 = 86;
      v44 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v44)
        v45 = v44;
      else
        v45 = v100;
      v46 = &v99[v45];
      v47 = v100 - v45;
      if (v100 - v45 >= 0x12)
        v48 = 18;
      else
        v48 = v100 - v45;
      v49 = v47 - v48;
      if (v49 >= v49 - 1)
        v50 = v49 - 1;
      else
        v50 = v49;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v84;
      v3 = v89;
      a1 = v95;
    }
  }
  v9 = v8[419];
  v11 = &unk_25451A000;
  if ((v10 & 1) == 0)
  {
    v90 = v3;
    v96 = a1;
    v81 = v9;
    v85 = v6;
    v11 = (_QWORD *)&unk_25451A000;
    v9 = v81;
    v6 = v85;
    v52 = v51;
    v3 = v90;
    a1 = v96;
    if (v52)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v100 = 82;
      v53 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v53)
        v54 = v53;
      else
        v54 = v100;
      v55 = &v99[v54];
      v56 = v100 - v54;
      if (v100 - v54 >= 0x12)
        v57 = 18;
      else
        v57 = v100 - v54;
      v58 = v56 - v57;
      if (v58 >= v58 - 1)
        v59 = v58 - 1;
      else
        v59 = v58;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      v11 = (_QWORD *)&unk_25451A000;
      v9 = v81;
      v6 = v85;
      v3 = v90;
      a1 = v96;
    }
  }
  v12 = v11[19];
  v14 = &unk_254519000;
  if ((v13 & 1) == 0)
  {
    v91 = v3;
    v97 = a1;
    v82 = v9;
    v86 = v6;
    v79 = v12;
    v14 = (_QWORD *)&unk_254519000;
    v12 = v79;
    v9 = v82;
    v6 = v86;
    v3 = v91;
    v61 = v60;
    a1 = v97;
    if (v61)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v100 = 84;
      v62 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v62)
        v63 = v62;
      else
        v63 = v100;
      v64 = &v99[v63];
      v65 = v100 - v63;
      if (v100 - v63 >= 0x12)
        v66 = 18;
      else
        v66 = v100 - v63;
      v67 = v65 - v66;
      if (v67 >= v67 - 1)
        v68 = v67 - 1;
      else
        v68 = v67;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      v14 = (_QWORD *)&unk_254519000;
      v12 = v79;
      v9 = v82;
      v6 = v86;
      v3 = v91;
      a1 = v97;
    }
  }
  v15 = v14[423];
  v17 = &unk_25451A000;
  if ((v16 & 1) == 0)
  {
    v92 = v3;
    v98 = a1;
    v83 = v9;
    v87 = v6;
    v78 = v15;
    v80 = v12;
    v17 = (_QWORD *)&unk_25451A000;
    v15 = v78;
    v12 = v80;
    v9 = v83;
    v6 = v87;
    v70 = v69;
    v3 = v92;
    a1 = v98;
    if (v70)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v100 = 89;
      v71 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v71)
        v72 = v71;
      else
        v72 = v100;
      v73 = &v99[v72];
      v74 = v100 - v72;
      if (v100 - v72 >= 0x12)
        v75 = 18;
      else
        v75 = v100 - v72;
      v76 = v74 - v75;
      if (v76 >= v76 - 1)
        v77 = v76 - 1;
      else
        v77 = v76;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      v17 = (_QWORD *)&unk_25451A000;
      v15 = v78;
      v12 = v80;
      v9 = v83;
      v6 = v87;
      v3 = v92;
      a1 = v98;
    }
  }
  return v3 == a1 || v6 == a1 || v9 == a1 || v12 == a1 || v15 == a1 || v17[310] == a1;
}

uint64_t mlir::AsmParser::parseAttribute<mlir::StringAttr>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  uint64_t v20;
  _QWORD v21[3];
  void *v22;
  uint64_t v23;
  void *v24;
  _QWORD *v25;
  void *__p;
  _QWORD *v27;
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v20 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *, uint64_t))(*(_QWORD *)a1 + 408))(a1, &v20, a3))
    return 0;
  v7 = v20;
  if (*(_UNKNOWN **)(*(_QWORD *)v20 + 136) != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    v7 = 0;
  *a2 = v7;
  if (v7)
    return 1;
  v18 = "invalid kind of attribute specified";
  v19 = 259;
  (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, const char **))(*(_QWORD *)a1 + 24))(v21, a1, v6, &v18);
  v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v21);
  if (v21[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v21);
  if (v28)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v27;
      v12 = __p;
      if (v27 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v27 = v10;
      operator delete(v12);
    }
    v13 = v24;
    if (v24)
    {
      v14 = v25;
      v15 = v24;
      if (v25 != v24)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v24;
      }
      v25 = v13;
      operator delete(v15);
    }
    if (v22 != &v23)
      free(v22);
  }
  return v8;
}

uint64_t mlir::BranchOpInterface::getSuccessorOperands(mlir::BranchOpInterface *this, uint64_t a2)
{
  return (**((uint64_t (***)(_QWORD, _QWORD, uint64_t))this + 1))(*((_QWORD *)this + 1), *(_QWORD *)this, a2);
}

uint64_t mlir::BranchOpInterface::getSuccessorBlockArgument(mlir::BranchOpInterface *this, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*((_QWORD *)this + 1) + 8))(*((_QWORD *)this + 1), *(_QWORD *)this, a2);
}

uint64_t mlir::BranchOpInterface::getSuccessorForOperands(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t))(a1[1] + 16))(a1[1], *a1, a2, a3);
}

uint64_t mlir::RegionBranchOpInterface::getEntrySuccessorOperands(uint64_t a1, uint64_t a2)
{
  return (**(uint64_t (***)(_QWORD, _QWORD, uint64_t))(a1 + 8))(*(_QWORD *)(a1 + 8), *(_QWORD *)a1, a2);
}

uint64_t mlir::RegionBranchOpInterface::getEntrySuccessorRegions(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(a1[1] + 8))(a1[1], *a1, a2, a3, a4);
}

uint64_t mlir::detail::verifyTypesAlongControlFlowEdges(mlir::detail *this, mlir::Operation *a2)
{
  mlir::detail *v2;
  unint64_t v3;
  mlir::Region *v4;
  mlir::Region *v5;
  mlir::Region *v6;
  uint64_t v7;
  uint64_t *v8;
  ZinIrHalH13g **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t InterfaceFor;
  int v13;
  void *v14;
  _QWORD v16[4];
  _QWORD *v17;
  _QWORD *v18;
  _QWORD v19[2];
  uint64_t *v20;
  void *v21;
  uint64_t v22;
  _QWORD v23[8];

  v2 = this;
  v23[6] = *MEMORY[0x24BDAC8D0];
  v20 = (uint64_t *)this;
  if (this)
    this = (mlir::detail *)mlir::OpInterface<mlir::RegionBranchOpInterface,mlir::detail::RegionBranchOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v19[0] = v2;
  v19[1] = this;
  v18 = v19;
  if (!verifyTypesAlongAllEdges((uint64_t *)v2, 0, (void (*)(_QWORD *__return_ptr, _QWORD, _QWORD))llvm::function_ref<mlir::FailureOr<mlir::TypeRange> ()(mlir::RegionBranchPoint)>::callback_fn<mlir::detail::verifyTypesAlongControlFlowEdges(mlir::Operation *)::$_0>, (uint64_t)&v18))return 0;
  v17 = v19;
  v3 = *((unsigned int *)v2 + 11);
  if ((v3 & 0x7FFFFF) != 0)
  {
    v4 = (mlir::Region *)((((unint64_t)v2 + 16 * ((v3 >> 23) & 1) + ((v3 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                        + 32 * *((unsigned int *)v2 + 10));
    v5 = (mlir::Region *)((char *)v4 + 24 * (v3 & 0x7FFFFF));
    while (1)
    {
      v21 = v23;
      v22 = 0x300000000;
      v6 = (mlir::Region *)*((_QWORD *)v4 + 1);
      if (v6 != v4)
      {
        do
        {
          if (v6)
            v9 = (ZinIrHalH13g **)((char *)v6 - 8);
          else
            v9 = 0;
          mlir::Block::getTerminator(v9);
          v11 = v10;
          if (mlir::OpInterface<mlir::RegionBranchTerminatorOpInterface,mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits>::getInterfaceFor(v10)
            && v11)
          {
            InterfaceFor = mlir::OpInterface<mlir::RegionBranchTerminatorOpInterface,mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits>::getInterfaceFor(v11);
            v7 = v22;
            if (v22 >= (unint64_t)HIDWORD(v22))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v21, v23, v22 + 1, 16);
              v7 = v22;
            }
            v8 = (uint64_t *)((char *)v21 + 16 * v7);
            *v8 = v11;
            v8[1] = InterfaceFor;
            LODWORD(v22) = v22 + 1;
          }
          v6 = (mlir::Region *)*((_QWORD *)v6 + 1);
        }
        while (v6 != v4);
        if ((_DWORD)v22)
          break;
      }
      v13 = 3;
      v14 = v21;
      if (v21 != v23)
        goto LABEL_24;
LABEL_25:
      if (v13 != 3 && v13)
        return 0;
      v4 = (mlir::Region *)((char *)v4 + 24);
      if (v4 == v5)
        return 1;
    }
    v16[0] = &v21;
    v16[1] = &v17;
    v16[2] = &v20;
    v16[3] = v4;
    v13 = verifyTypesAlongAllEdges(v20, v4, (void (*)(_QWORD *__return_ptr, _QWORD, _QWORD))llvm::function_ref<mlir::FailureOr<mlir::TypeRange> ()(mlir::RegionBranchPoint)>::callback_fn<mlir::detail::verifyTypesAlongControlFlowEdges(mlir::Operation *)::$_2>, (uint64_t)v16) == 0;
    v14 = v21;
    if (v21 == v23)
      goto LABEL_25;
LABEL_24:
    free(v14);
    goto LABEL_25;
  }
  return 1;
}

uint64_t verifyTypesAlongAllEdges(uint64_t *a1, mlir::Region *a2, void (*a3)(_QWORD *__return_ptr, _QWORD, _QWORD), uint64_t a4)
{
  uint64_t InterfaceFor;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  __n128 *v18;
  char *v19;
  char *v20;
  __n128 v21;
  uint64_t v22;
  __n128 *v23;
  char *v24;
  char *v25;
  __n128 v26;
  uint64_t v27;
  __n128 *v28;
  char *v29;
  char *v30;
  __n128 v31;
  __n128 *v32;
  char *v33;
  char *v34;
  __n128 v35;
  uint64_t v36;
  __n128 *v37;
  char *v38;
  char *v39;
  __n128 v40;
  uint64_t v41;
  __n128 *v42;
  char *v43;
  char *v44;
  __n128 v45;
  uint64_t v46;
  __n128 *v47;
  char *v48;
  char *v49;
  __n128 v50;
  __n128 *v51;
  char *v52;
  char *v53;
  __n128 v54;
  uint64_t v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  uint64_t v62;
  uint64_t v63;
  void *v64;
  __n128 *v65;
  char *v66;
  char *v67;
  __n128 v68;
  uint64_t v69;
  __n128 *v70;
  char *v71;
  char *v72;
  __n128 v73;
  uint64_t v74;
  __n128 *v75;
  char *v76;
  char *v77;
  __n128 v78;
  uint64_t v79;
  __n128 *v80;
  char *v81;
  char *v82;
  __n128 v83;
  _QWORD *v84;
  _QWORD *v85;
  void *v86;
  _QWORD *v87;
  _QWORD *v88;
  void *v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v93;
  unint64_t v94;
  BOOL v95;
  unint64_t v96;
  BOOL v97;
  unint64_t v98;
  unint64_t v99;
  BOOL v100;
  unint64_t v101;
  unint64_t v102;
  BOOL v103;
  unint64_t v104;
  BOOL v105;
  unint64_t v106;
  BOOL v107;
  unint64_t v108;
  BOOL v109;
  unint64_t v110;
  unint64_t v111;
  BOOL v112;
  int64_t v113;
  int64_t v114;
  int64_t v115;
  int64_t v116;
  int64_t v117;
  int64_t v118;
  int64_t v119;
  int64_t v120;
  int64_t v121;
  int64_t v122;
  int64_t v123;
  int64_t v124;
  unint64_t *v125;
  void (*v126)(_QWORD *__return_ptr, _QWORD, _QWORD);
  __n128 v128;
  uint64_t v129;
  __int16 v130;
  __n128 v131;
  void *v132;
  unsigned int v133;
  unsigned int v134;
  _BYTE v135[96];
  void *v136;
  _QWORD *v137;
  void *__p;
  _QWORD *v139;
  char v140;
  __n128 v141;
  uint64_t v142;
  uint64_t v143;
  unint64_t v144;
  uint64_t v145;
  unint64_t v146;
  char v147;
  unint64_t *v148;
  uint64_t v149;
  _QWORD v150[8];

  v150[6] = *MEMORY[0x24BDAC8D0];
  if (a1)
    InterfaceFor = mlir::OpInterface<mlir::RegionBranchOpInterface,mlir::detail::RegionBranchOpInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a1);
  else
    InterfaceFor = 0;
  v148 = v150;
  v149 = 0x200000000;
  (*(void (**)(uint64_t, uint64_t *, mlir::Region *, unint64_t **))(InterfaceFor + 16))(InterfaceFor, a1, a2, &v148);
  if (!(_DWORD)v149)
  {
    v55 = 1;
    goto LABEL_77;
  }
  v8 = v148;
  v125 = &v148[3 * v149];
  v126 = a3;
  while (1)
  {
    a3(&v145, a4, *v8);
    if (!v147)
    {
      v55 = 0;
      goto LABEL_77;
    }
    v128 = *(__n128 *)(v8 + 1);
    mlir::ValueRange::getTypes(&v128, &v141);
    v10 = v141.n128_u64[1];
    v9 = v141.n128_u64[0];
    v11 = v142;
    v131 = v141;
    if (v141.n128_u64[1])
    {
      v9 = mlir::ValueRange::offset_base(&v131, v141.n128_i64[1]);
      v10 = v131.n128_u64[1];
    }
    mlir::TypeRange::TypeRange((unint64_t *)&v143, v9, v11 - v10);
    v12 = v146;
    if (v146 != v144)
      break;
    if (v146)
    {
      v13 = 0;
      v14 = v145;
      v15 = v143;
      while (1)
      {
        v16 = mlir::TypeRange::dereference_iterator(v14, v13);
        v17 = mlir::TypeRange::dereference_iterator(v15, v13);
        if (((*(uint64_t (**)(uint64_t, uint64_t *, unint64_t, unint64_t))(InterfaceFor + 32))(InterfaceFor, a1, v16, v17) & 1) == 0)break;
        if (v12 == ++v13)
          goto LABEL_6;
      }
      v128.n128_u64[0] = (unint64_t)" along control flow edge ";
      v130 = 259;
      mlir::Operation::emitOpError(a1, (const void ***)&v128, (uint64_t)&v131);
      printRegionEdgeName((uint64_t *)&v131, a2, *v8);
      if (v131.n128_u64[0])
      {
        v128.n128_u32[0] = 3;
        v128.n128_u64[1] = (unint64_t)": source type #";
        v129 = 15;
        v18 = &v128;
        v19 = (char *)v132;
        if (v133 >= v134)
        {
          v93 = v133 + 1;
          if (v132 <= &v128 && (char *)v132 + 24 * v133 > (char *)&v128)
          {
            v113 = (char *)&v128 - (_BYTE *)v132;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v93, 24);
            v19 = (char *)v132;
            v18 = (__n128 *)((char *)v132 + v113);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v93, 24);
            v18 = &v128;
            v19 = (char *)v132;
          }
        }
        v20 = &v19[24 * v133];
        v21 = *v18;
        *((_QWORD *)v20 + 2) = v18[1].n128_u64[0];
        *(__n128 *)v20 = v21;
        v22 = ++v133;
        if (v131.n128_u64[0])
        {
          v128.n128_u32[0] = 5;
          v128.n128_u64[1] = v13;
          v23 = &v128;
          v24 = (char *)v132;
          if (v22 >= v134)
          {
            v94 = v22 + 1;
            v95 = (char *)v132 + 24 * v22 > (char *)&v128;
            if (v132 <= &v128 && v95)
            {
              v114 = (char *)&v128 - (_BYTE *)v132;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v94, 24);
              v24 = (char *)v132;
              v23 = (__n128 *)((char *)v132 + v114);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v94, 24);
              v23 = &v128;
              v24 = (char *)v132;
            }
          }
          v25 = &v24[24 * v133];
          v26 = *v23;
          *((_QWORD *)v25 + 2) = v23[1].n128_u64[0];
          *(__n128 *)v25 = v26;
          v27 = ++v133;
          if (v131.n128_u64[0])
          {
            v128.n128_u32[0] = 3;
            v128.n128_u64[1] = (unint64_t)" ";
            v129 = 1;
            v28 = &v128;
            v29 = (char *)v132;
            if (v27 >= v134)
            {
              v96 = v27 + 1;
              v97 = (char *)v132 + 24 * v27 > (char *)&v128;
              if (v132 <= &v128 && v97)
              {
                v115 = (char *)&v128 - (_BYTE *)v132;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v96, 24);
                v29 = (char *)v132;
                v28 = (__n128 *)((char *)v132 + v115);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v96, 24);
                v28 = &v128;
                v29 = (char *)v132;
              }
            }
            v30 = &v29[24 * v133];
            v31 = *v28;
            *((_QWORD *)v30 + 2) = v28[1].n128_u64[0];
            *(__n128 *)v30 = v31;
            ++v133;
            if (v131.n128_u64[0])
            {
              v32 = &v128;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v128, v16);
              v33 = (char *)v132;
              if (v133 >= v134)
              {
                v98 = v133 + 1;
                if (v132 <= &v128 && (char *)v132 + 24 * v133 > (char *)&v128)
                {
                  v116 = (char *)&v128 - (_BYTE *)v132;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v98, 24);
                  v33 = (char *)v132;
                  v32 = (__n128 *)((char *)v132 + v116);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v98, 24);
                  v32 = &v128;
                  v33 = (char *)v132;
                }
              }
              v34 = &v33[24 * v133];
              v35 = *v32;
              *((_QWORD *)v34 + 2) = v32[1].n128_u64[0];
              *(__n128 *)v34 = v35;
              v36 = ++v133;
              if (v131.n128_u64[0])
              {
                v128.n128_u32[0] = 3;
                v128.n128_u64[1] = (unint64_t)" should match input type #";
                v129 = 26;
                v37 = &v128;
                v38 = (char *)v132;
                if (v36 >= v134)
                {
                  v99 = v36 + 1;
                  v100 = (char *)v132 + 24 * v36 > (char *)&v128;
                  if (v132 <= &v128 && v100)
                  {
                    v117 = (char *)&v128 - (_BYTE *)v132;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v99, 24);
                    v38 = (char *)v132;
                    v37 = (__n128 *)((char *)v132 + v117);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v99, 24);
                    v37 = &v128;
                    v38 = (char *)v132;
                  }
                }
                v39 = &v38[24 * v133];
                v40 = *v37;
                *((_QWORD *)v39 + 2) = v37[1].n128_u64[0];
                *(__n128 *)v39 = v40;
                v41 = ++v133;
                if (v131.n128_u64[0])
                {
                  v128.n128_u32[0] = 5;
                  v128.n128_u64[1] = v13;
                  v42 = &v128;
                  v43 = (char *)v132;
                  if (v41 >= v134)
                  {
                    v102 = v41 + 1;
                    v103 = (char *)v132 + 24 * v41 > (char *)&v128;
                    if (v132 <= &v128 && v103)
                    {
                      v119 = (char *)&v128 - (_BYTE *)v132;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v102, 24);
                      v43 = (char *)v132;
                      v42 = (__n128 *)((char *)v132 + v119);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v102, 24);
                      v42 = &v128;
                      v43 = (char *)v132;
                    }
                  }
                  v44 = &v43[24 * v133];
                  v45 = *v42;
                  *((_QWORD *)v44 + 2) = v42[1].n128_u64[0];
                  *(__n128 *)v44 = v45;
                  v46 = ++v133;
                  if (v131.n128_u64[0])
                  {
                    v128.n128_u32[0] = 3;
                    v128.n128_u64[1] = (unint64_t)" ";
                    v129 = 1;
                    v47 = &v128;
                    v48 = (char *)v132;
                    if (v46 >= v134)
                    {
                      v106 = v46 + 1;
                      v107 = (char *)v132 + 24 * v46 > (char *)&v128;
                      if (v132 <= &v128 && v107)
                      {
                        v121 = (char *)&v128 - (_BYTE *)v132;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v106, 24);
                        v48 = (char *)v132;
                        v47 = (__n128 *)((char *)v132 + v121);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v106, 24);
                        v47 = &v128;
                        v48 = (char *)v132;
                      }
                    }
                    v49 = &v48[24 * v133];
                    v50 = *v47;
                    *((_QWORD *)v49 + 2) = v47[1].n128_u64[0];
                    *(__n128 *)v49 = v50;
                    ++v133;
                    if (v131.n128_u64[0])
                    {
                      v51 = &v128;
                      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v128, v17);
                      v52 = (char *)v132;
                      if (v133 >= v134)
                      {
                        v110 = v133 + 1;
                        if (v132 <= &v128 && (char *)v132 + 24 * v133 > (char *)&v128)
                        {
                          v123 = (char *)&v128 - (_BYTE *)v132;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v110, 24);
                          v52 = (char *)v132;
                          v51 = (__n128 *)((char *)v132 + v123);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v110, 24);
                          v51 = &v128;
                          v52 = (char *)v132;
                        }
                      }
                      v53 = &v52[24 * v133];
                      v54 = *v51;
                      *((_QWORD *)v53 + 2) = v51[1].n128_u64[0];
                      *(__n128 *)v53 = v54;
                      ++v133;
                    }
                  }
                }
              }
            }
          }
        }
      }
      v55 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v131);
      if (v131.n128_u64[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v131);
      if (v140)
      {
        v56 = __p;
        if (__p)
        {
          v57 = v139;
          v58 = __p;
          if (v139 != __p)
          {
            do
              v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
            while (v57 != v56);
            v58 = __p;
          }
          v139 = v56;
          operator delete(v58);
        }
        v59 = v136;
        if (v136)
        {
          v60 = v137;
          v61 = v136;
          if (v137 != v136)
          {
            do
            {
              v63 = *--v60;
              v62 = v63;
              *v60 = 0;
              if (v63)
                MEMORY[0x20BD002D4](v62, 0x1000C8077774924);
            }
            while (v60 != v59);
            v61 = v136;
          }
          v137 = v59;
          operator delete(v61);
        }
        v64 = v132;
        if (v132 != v135)
          goto LABEL_51;
      }
      goto LABEL_77;
    }
LABEL_6:
    v8 += 3;
    a3 = v126;
    if (v8 == v125)
    {
      v55 = 1;
      goto LABEL_77;
    }
  }
  v128.n128_u64[0] = (unint64_t)" region control flow edge ";
  v130 = 259;
  mlir::Operation::emitOpError(a1, (const void ***)&v128, (uint64_t)&v131);
  printRegionEdgeName((uint64_t *)&v131, a2, *v8);
  if (v131.n128_u64[0])
  {
    v128.n128_u32[0] = 3;
    v128.n128_u64[1] = (unint64_t)": source has ";
    v129 = 13;
    v65 = &v128;
    v66 = (char *)v132;
    if (v133 >= v134)
    {
      v101 = v133 + 1;
      if (v132 <= &v128 && (char *)v132 + 24 * v133 > (char *)&v128)
      {
        v118 = (char *)&v128 - (_BYTE *)v132;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v101, 24);
        v66 = (char *)v132;
        v65 = (__n128 *)((char *)v132 + v118);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v101, 24);
        v65 = &v128;
        v66 = (char *)v132;
      }
    }
    v67 = &v66[24 * v133];
    v68 = *v65;
    *((_QWORD *)v67 + 2) = v65[1].n128_u64[0];
    *(__n128 *)v67 = v68;
    v69 = ++v133;
    if (v131.n128_u64[0])
    {
      v128.n128_u32[0] = 5;
      v128.n128_u64[1] = v146;
      v70 = &v128;
      v71 = (char *)v132;
      if (v69 >= v134)
      {
        v104 = v69 + 1;
        v105 = (char *)v132 + 24 * v69 > (char *)&v128;
        if (v132 <= &v128 && v105)
        {
          v120 = (char *)&v128 - (_BYTE *)v132;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v104, 24);
          v71 = (char *)v132;
          v70 = (__n128 *)((char *)v132 + v120);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v104, 24);
          v70 = &v128;
          v71 = (char *)v132;
        }
      }
      v72 = &v71[24 * v133];
      v73 = *v70;
      *((_QWORD *)v72 + 2) = v70[1].n128_u64[0];
      *(__n128 *)v72 = v73;
      v74 = ++v133;
      if (v131.n128_u64[0])
      {
        v128.n128_u32[0] = 3;
        v128.n128_u64[1] = (unint64_t)" operands, but target successor needs ";
        v129 = 38;
        v75 = &v128;
        v76 = (char *)v132;
        if (v74 >= v134)
        {
          v108 = v74 + 1;
          v109 = (char *)v132 + 24 * v74 > (char *)&v128;
          if (v132 <= &v128 && v109)
          {
            v122 = (char *)&v128 - (_BYTE *)v132;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v108, 24);
            v76 = (char *)v132;
            v75 = (__n128 *)((char *)v132 + v122);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v108, 24);
            v75 = &v128;
            v76 = (char *)v132;
          }
        }
        v77 = &v76[24 * v133];
        v78 = *v75;
        *((_QWORD *)v77 + 2) = v75[1].n128_u64[0];
        *(__n128 *)v77 = v78;
        v79 = ++v133;
        if (v131.n128_u64[0])
        {
          v128.n128_u32[0] = 5;
          v128.n128_u64[1] = v144;
          v80 = &v128;
          v81 = (char *)v132;
          if (v79 >= v134)
          {
            v111 = v79 + 1;
            v112 = (char *)v132 + 24 * v79 > (char *)&v128;
            if (v132 <= &v128 && v112)
            {
              v124 = (char *)&v128 - (_BYTE *)v132;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v111, 24);
              v81 = (char *)v132;
              v80 = (__n128 *)((char *)v132 + v124);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v111, 24);
              v80 = &v128;
              v81 = (char *)v132;
            }
          }
          v82 = &v81[24 * v133];
          v83 = *v80;
          *((_QWORD *)v82 + 2) = v80[1].n128_u64[0];
          *(__n128 *)v82 = v83;
          ++v133;
        }
      }
    }
  }
  v55 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v131);
  if (v131.n128_u64[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v131);
  if (v140)
  {
    v84 = __p;
    if (__p)
    {
      v85 = v139;
      v86 = __p;
      if (v139 != __p)
      {
        do
          v85 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v85 - 1);
        while (v85 != v84);
        v86 = __p;
      }
      v139 = v84;
      operator delete(v86);
    }
    v87 = v136;
    if (v136)
    {
      v88 = v137;
      v89 = v136;
      if (v137 != v136)
      {
        do
        {
          v91 = *--v88;
          v90 = v91;
          *v88 = 0;
          if (v91)
            MEMORY[0x20BD002D4](v90, 0x1000C8077774924);
        }
        while (v88 != v87);
        v89 = v136;
      }
      v137 = v87;
      operator delete(v89);
    }
    v64 = v132;
    if (v132 != v135)
LABEL_51:
      free(v64);
  }
LABEL_77:
  if (v148 != v150)
    free(v148);
  return v55;
}

uint64_t llvm::SmallVectorImpl<std::pair<unsigned int,mlir::NamedAttribute>>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t *v5;
  char *v6;
  _DWORD *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;

  if ((uint64_t *)a1 != a2)
  {
    v5 = a2 + 2;
    v4 = *a2;
    if ((uint64_t *)*a2 != a2 + 2)
    {
      v6 = *(char **)a1;
      if (*(_QWORD *)a1 != a1 + 16)
      {
        free(v6);
        v4 = *a2;
      }
      *(_QWORD *)a1 = v4;
      v7 = a2 + 1;
      *(_QWORD *)(a1 + 8) = a2[1];
      *a2 = (uint64_t)v5;
      *((_DWORD *)a2 + 3) = 0;
      goto LABEL_20;
    }
    v7 = a2 + 1;
    v8 = *((unsigned int *)a2 + 2);
    v9 = *(unsigned int *)(a1 + 8);
    if (v9 >= v8)
    {
      if ((_DWORD)v8)
      {
        v11 = *(char **)a1;
        v12 = v4 + 24 * v8;
        do
        {
          *(_DWORD *)v11 = *(_DWORD *)v4;
          *(_OWORD *)(v11 + 8) = *(_OWORD *)(v4 + 8);
          v4 += 24;
          v11 += 24;
        }
        while (v4 != v12);
      }
      goto LABEL_19;
    }
    if (*(_DWORD *)(a1 + 12) >= v8)
    {
      if ((_DWORD)v9)
      {
        v13 = v4 + 24 * v9;
        v14 = *(char **)a1;
        do
        {
          *(_DWORD *)v14 = *(_DWORD *)v4;
          *(_OWORD *)(v14 + 8) = *(_OWORD *)(v4 + 8);
          v4 += 24;
          v14 += 24;
        }
        while (v4 != v13);
        v10 = *v7;
        if (v9 == v10)
          goto LABEL_19;
      }
      else
      {
        v9 = 0;
        LODWORD(v10) = *v7;
        if (!*v7)
          goto LABEL_19;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v8, 24);
      v9 = 0;
      LODWORD(v10) = *v7;
      if (!*v7)
        goto LABEL_19;
    }
    memcpy((void *)(*(_QWORD *)a1 + 24 * v9), (const void *)(*a2 + 24 * v9), *a2 + 24 * v10 - (*a2 + 24 * v9));
LABEL_19:
    *(_DWORD *)(a1 + 8) = v8;
LABEL_20:
    *v7 = 0;
  }
  return a1;
}

uint64_t *printRegionEdgeName(uint64_t *a1, mlir::Region *this, unint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int *v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  __int128 v18;
  unsigned int RegionNumber;
  unsigned int v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  __int128 v26;
  unsigned int v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  int *v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  unint64_t v35;
  int *v36;
  uint64_t v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  int *v43;
  uint64_t v44;
  __int128 v45;
  unsigned int v46;
  unsigned int v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  int *v51;
  uint64_t v52;
  __int128 v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int *v57;
  uint64_t v58;
  __int128 v59;
  unint64_t v61;
  BOOL v62;
  unint64_t v63;
  BOOL v64;
  unint64_t v65;
  BOOL v66;
  unint64_t v67;
  BOOL v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  BOOL v72;
  unint64_t v73;
  BOOL v74;
  unint64_t v75;
  BOOL v76;
  char *v77;
  char *v78;
  char *v79;
  char *v80;
  char *v81;
  char *v82;
  char *v83;
  char *v84;
  int v85;
  const char *v86;
  uint64_t v87;

  if (*a1)
  {
    v6 = (uint64_t)(a1 + 3);
    v7 = a1[3];
    v85 = 3;
    v86 = "from ";
    v87 = 5;
    v8 = *((unsigned int *)a1 + 8);
    v9 = &v85;
    if (v8 >= *((_DWORD *)a1 + 9))
    {
      v61 = v8 + 1;
      v62 = v7 + 24 * v8 > (unint64_t)&v85;
      if (v7 <= (unint64_t)&v85 && v62)
      {
        v77 = (char *)&v85 - v7;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v6, a1 + 5, v61, 24);
        v7 = a1[3];
        v9 = (int *)&v77[v7];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v6, a1 + 5, v61, 24);
        v7 = a1[3];
        v9 = &v85;
      }
    }
    v10 = v7 + 24 * *((unsigned int *)a1 + 8);
    v11 = *(_OWORD *)v9;
    *(_QWORD *)(v10 + 16) = *((_QWORD *)v9 + 2);
    *(_OWORD *)v10 = v11;
    ++*((_DWORD *)a1 + 8);
  }
  v12 = *a1;
  if (this)
  {
    if (v12)
    {
      v13 = (uint64_t)(a1 + 3);
      v14 = a1[3];
      v85 = 3;
      v86 = "Region #";
      v87 = 8;
      v15 = *((unsigned int *)a1 + 8);
      v16 = &v85;
      if (v15 >= *((_DWORD *)a1 + 9))
      {
        v63 = v15 + 1;
        v64 = v14 + 24 * v15 > (unint64_t)&v85;
        if (v14 <= (unint64_t)&v85 && v64)
        {
          v78 = (char *)&v85 - v14;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v13, a1 + 5, v63, 24);
          v14 = a1[3];
          v16 = (int *)&v78[v14];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v13, a1 + 5, v63, 24);
          v14 = a1[3];
          v16 = &v85;
        }
      }
      v17 = v14 + 24 * *((unsigned int *)a1 + 8);
      v18 = *(_OWORD *)v16;
      *(_QWORD *)(v17 + 16) = *((_QWORD *)v16 + 2);
      *(_OWORD *)v17 = v18;
      ++*((_DWORD *)a1 + 8);
    }
    RegionNumber = mlir::Region::getRegionNumber((unint64_t)this);
    if (!*a1)
      goto LABEL_17;
    v20 = RegionNumber;
    v21 = (uint64_t)(a1 + 3);
    v22 = a1[3];
    v85 = 5;
    v86 = (const char *)v20;
    v23 = *((unsigned int *)a1 + 8);
    v24 = &v85;
    if (v23 >= *((_DWORD *)a1 + 9))
    {
      v65 = v23 + 1;
      v66 = v22 + 24 * v23 > (unint64_t)&v85;
      if (v22 <= (unint64_t)&v85 && v66)
      {
        v79 = (char *)&v85 - v22;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v21, a1 + 5, v65, 24);
        v22 = a1[3];
        v24 = (int *)&v79[v22];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v21, a1 + 5, v65, 24);
        v22 = a1[3];
        v24 = &v85;
      }
    }
    v25 = v22 + 24 * *((unsigned int *)a1 + 8);
    v26 = *(_OWORD *)v24;
    *(_QWORD *)(v25 + 16) = *((_QWORD *)v24 + 2);
    *(_OWORD *)v25 = v26;
    v27 = *((_DWORD *)a1 + 8) + 1;
    *((_DWORD *)a1 + 8) = v27;
    if (!*a1)
      goto LABEL_17;
LABEL_15:
    v34 = (uint64_t)(a1 + 3);
    v35 = a1[3];
    v85 = 3;
    v86 = " to ";
    v87 = 4;
    v36 = &v85;
    if (v27 >= *((_DWORD *)a1 + 9))
    {
      v67 = v27 + 1;
      v68 = v35 + 24 * v27 > (unint64_t)&v85;
      if (v35 <= (unint64_t)&v85 && v68)
      {
        v80 = (char *)&v85 - v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v34, a1 + 5, v67, 24);
        v35 = a1[3];
        v36 = (int *)&v80[v35];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v34, a1 + 5, v67, 24);
        v35 = a1[3];
        v36 = &v85;
      }
    }
    v37 = v35 + 24 * *((unsigned int *)a1 + 8);
    v38 = *(_OWORD *)v36;
    *(_QWORD *)(v37 + 16) = *((_QWORD *)v36 + 2);
    *(_OWORD *)v37 = v38;
    ++*((_DWORD *)a1 + 8);
    goto LABEL_17;
  }
  if (v12)
  {
    v28 = (uint64_t)(a1 + 3);
    v29 = a1[3];
    v85 = 3;
    v86 = "parent operands";
    v87 = 15;
    v30 = *((unsigned int *)a1 + 8);
    v31 = &v85;
    if (v30 >= *((_DWORD *)a1 + 9))
    {
      v73 = v30 + 1;
      v74 = v29 + 24 * v30 > (unint64_t)&v85;
      if (v29 <= (unint64_t)&v85 && v74)
      {
        v83 = (char *)&v85 - v29;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v28, a1 + 5, v73, 24);
        v29 = a1[3];
        v31 = (int *)&v83[v29];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v28, a1 + 5, v73, 24);
        v29 = a1[3];
        v31 = &v85;
      }
    }
    v32 = v29 + 24 * *((unsigned int *)a1 + 8);
    v33 = *(_OWORD *)v31;
    *(_QWORD *)(v32 + 16) = *((_QWORD *)v31 + 2);
    *(_OWORD *)v32 = v33;
    v27 = *((_DWORD *)a1 + 8) + 1;
    *((_DWORD *)a1 + 8) = v27;
    if (*a1)
      goto LABEL_15;
  }
LABEL_17:
  v39 = *a1;
  if (a3)
  {
    if (v39)
    {
      v40 = (uint64_t)(a1 + 3);
      v41 = a1[3];
      v85 = 3;
      v86 = "Region #";
      v87 = 8;
      v42 = *((unsigned int *)a1 + 8);
      v43 = &v85;
      if (v42 >= *((_DWORD *)a1 + 9))
      {
        v69 = v42 + 1;
        v70 = v41 + 24 * v42 > (unint64_t)&v85;
        if (v41 <= (unint64_t)&v85 && v70)
        {
          v81 = (char *)&v85 - v41;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v40, a1 + 5, v69, 24);
          v41 = a1[3];
          v43 = (int *)&v81[v41];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v40, a1 + 5, v69, 24);
          v41 = a1[3];
          v43 = &v85;
        }
      }
      v44 = v41 + 24 * *((unsigned int *)a1 + 8);
      v45 = *(_OWORD *)v43;
      *(_QWORD *)(v44 + 16) = *((_QWORD *)v43 + 2);
      *(_OWORD *)v44 = v45;
      ++*((_DWORD *)a1 + 8);
    }
    v46 = mlir::Region::getRegionNumber(a3);
    if (*a1)
    {
      v47 = v46;
      v48 = (uint64_t)(a1 + 3);
      v49 = a1[3];
      v85 = 5;
      v86 = (const char *)v47;
      v50 = *((unsigned int *)a1 + 8);
      v51 = &v85;
      if (v50 >= *((_DWORD *)a1 + 9))
      {
        v71 = v50 + 1;
        v72 = v49 + 24 * v50 > (unint64_t)&v85;
        if (v49 <= (unint64_t)&v85 && v72)
        {
          v82 = (char *)&v85 - v49;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v48, a1 + 5, v71, 24);
          v49 = a1[3];
          v51 = (int *)&v82[v49];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v48, a1 + 5, v71, 24);
          v49 = a1[3];
          v51 = &v85;
        }
      }
      v52 = v49 + 24 * *((unsigned int *)a1 + 8);
      v53 = *(_OWORD *)v51;
      *(_QWORD *)(v52 + 16) = *((_QWORD *)v51 + 2);
      *(_OWORD *)v52 = v53;
LABEL_27:
      ++*((_DWORD *)a1 + 8);
    }
  }
  else if (v39)
  {
    v54 = (uint64_t)(a1 + 3);
    v55 = a1[3];
    v85 = 3;
    v86 = "parent results";
    v87 = 14;
    v56 = *((unsigned int *)a1 + 8);
    v57 = &v85;
    if (v56 >= *((_DWORD *)a1 + 9))
    {
      v75 = v56 + 1;
      v76 = v55 + 24 * v56 > (unint64_t)&v85;
      if (v55 <= (unint64_t)&v85 && v76)
      {
        v84 = (char *)&v85 - v55;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v54, a1 + 5, v75, 24);
        v55 = a1[3];
        v57 = (int *)&v84[v55];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v54, a1 + 5, v75, 24);
        v55 = a1[3];
        v57 = &v85;
      }
    }
    v58 = v55 + 24 * *((unsigned int *)a1 + 8);
    v59 = *(_OWORD *)v57;
    *(_QWORD *)(v58 + 16) = *((_QWORD *)v57 + 2);
    *(_OWORD *)v58 = v59;
    goto LABEL_27;
  }
  return a1;
}

double llvm::function_ref<mlir::FailureOr<mlir::TypeRange> ()(mlir::RegionBranchPoint)>::callback_fn<mlir::detail::verifyTypesAlongControlFlowEdges(mlir::Operation *)::$_0>@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  double result;
  uint64_t v5[2];
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9[3];
  unint64_t v10[3];

  v10[2] = *MEMORY[0x24BDAC8D0];
  v5[0] = (**(uint64_t (***)(void))(*(_QWORD *)a1 + 8))();
  v5[1] = v3;
  mlir::OperandRange::getTypes(v5, &v6);
  mlir::ValueRange::ValueRange(v10, v6 + 32 * v7, v8 - v7);
  mlir::TypeRange::TypeRange(v9, v10[0], v10[1]);
  result = *(double *)v9;
  *(_OWORD *)a2 = *(_OWORD *)v9;
  *(_BYTE *)(a2 + 16) = 1;
  return result;
}

void llvm::function_ref<mlir::FailureOr<mlir::TypeRange> ()(mlir::RegionBranchPoint)>::callback_fn<mlir::detail::verifyTypesAlongControlFlowEdges(mlir::Operation *)::$_2>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  const void ***v17;
  char *v18;
  char *v19;
  __int128 v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  int64_t v31;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  __int128 v41;
  char v42;
  const void **v43;
  const char *v44;
  uint64_t v45;
  __int16 v46;
  uint64_t v47;
  unint64_t v48;
  void *v49;
  void *v50;
  _DWORD v51[2];
  _BYTE v52[96];
  void *v53;
  _QWORD *v54;
  void *__p;
  _QWORD *v56;
  char v57;
  unint64_t v58[2];
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  LOBYTE(v41) = 0;
  v42 = 0;
  v3 = *(uint64_t **)a1;
  v4 = *(unsigned int *)(*(_QWORD *)a1 + 8);
  if (!(_DWORD)v4)
  {
LABEL_20:
    mlir::OperandRange::getTypes((uint64_t *)&v41, &v47);
    mlir::ValueRange::ValueRange((unint64_t *)&v43, v47 + 32 * v48, (unint64_t)v50 - v48);
    *((_BYTE *)mlir::TypeRange::TypeRange((unint64_t *)a3, (uint64_t)v43, (unint64_t)v44) + 16) = 1;
    return;
  }
  v7 = *v3;
  v33 = *v3 + 16 * v4;
  while (1)
  {
    (**(void (***)(uint64_t *__return_ptr))(v7 + 8))(&v47);
    v8 = mlir::MutableOperandRange::operator mlir::OperandRange((unsigned int *)&v47);
    v10 = v9;
    if (v49 != v51)
      free(v49);
    *(_QWORD *)&v40 = v8;
    *((_QWORD *)&v40 + 1) = v10;
    if (!v42)
    {
      v41 = v40;
      v42 = 1;
      goto LABEL_4;
    }
    v11 = *(_QWORD *)(a1 + 8);
    mlir::OperandRange::getTypes((uint64_t *)&v41, &v37);
    mlir::ValueRange::ValueRange((unint64_t *)&v47, v37 + 32 * v38, v39 - v38);
    mlir::TypeRange::TypeRange((unint64_t *)&v59, v47, v48);
    mlir::OperandRange::getTypes((uint64_t *)&v40, &v34);
    mlir::ValueRange::ValueRange((unint64_t *)&v47, v34 + 32 * v35, v36 - v35);
    mlir::TypeRange::TypeRange(v58, v47, v48);
    v12 = v60;
    if (v60 != v58[1])
      goto LABEL_14;
    if (v60)
      break;
LABEL_4:
    v7 += 16;
    if (v7 == v33)
      goto LABEL_20;
  }
  v13 = 0;
  v14 = v59;
  v15 = v58[0];
  while (1)
  {
    mlir::TypeRange::dereference_iterator(v14, v13);
    mlir::TypeRange::dereference_iterator(v15, v13);
    if (!(*(unsigned int (**)(void))(*(_QWORD *)(*(_QWORD *)v11 + 8) + 32))())
      break;
    if (v12 == ++v13)
      goto LABEL_4;
  }
LABEL_14:
  v16 = **(uint64_t ***)(a1 + 16);
  v43 = (const void **)" along control flow edge";
  v46 = 259;
  mlir::Operation::emitOpError(v16, &v43, (uint64_t)&v47);
  printRegionEdgeName(&v47, *(mlir::Region **)(a1 + 24), a2);
  if (!v47)
  {
    *(_BYTE *)a3 = 0;
    *(_BYTE *)(a3 + 16) = 0;
    if (!v57)
      return;
    goto LABEL_22;
  }
  LODWORD(v43) = 3;
  v44 = " operands mismatch between return-like terminators";
  v45 = 50;
  v17 = &v43;
  v18 = (char *)v50;
  if (v51[0] >= v51[1])
  {
    v30 = v51[0] + 1;
    if (v50 <= &v43 && (char *)v50 + 24 * v51[0] > (char *)&v43)
    {
      v31 = (char *)&v43 - (_BYTE *)v50;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v52, v30, 24);
      v18 = (char *)v50;
      v17 = (const void ***)((char *)v50 + v31);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v52, v30, 24);
      v17 = &v43;
      v18 = (char *)v50;
    }
  }
  v19 = &v18[24 * v51[0]];
  v20 = *(_OWORD *)v17;
  *((_QWORD *)v19 + 2) = v17[2];
  *(_OWORD *)v19 = v20;
  ++v51[0];
  v21 = v47;
  *(_BYTE *)a3 = 0;
  *(_BYTE *)(a3 + 16) = 0;
  if (v21)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v47);
  if (v57)
  {
LABEL_22:
    v22 = __p;
    if (__p)
    {
      v23 = v56;
      v24 = __p;
      if (v56 != __p)
      {
        do
          v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        v24 = __p;
      }
      v56 = v22;
      operator delete(v24);
    }
    v25 = v53;
    if (v53)
    {
      v26 = v54;
      v27 = v53;
      if (v54 != v53)
      {
        do
        {
          v29 = *--v26;
          v28 = v29;
          *v26 = 0;
          if (v29)
            MEMORY[0x20BD002D4](v28, 0x1000C8077774924);
        }
        while (v26 != v25);
        v27 = v53;
      }
      v54 = v25;
      operator delete(v27);
    }
    if (v50 != v52)
      free(v50);
  }
}

uint64_t mlir::OpTrait::util::staticallyKnownBroadcastable(const void *a1, uint64_t a2, char *a3, uint64_t a4)
{
  unint64_t v4;
  size_t v9;
  int v10;
  uint64_t v11;
  _QWORD *v12;
  int64_t v13;
  unsigned int v14;
  unsigned int *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int8x16_t v22;
  unsigned int *v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  int8x16_t v27;
  unint64_t v28;
  uint64_t v29;
  unsigned int *v30;
  unint64_t v31;
  unsigned int v32;
  unint64_t v33;
  char v34;
  uint64_t v35;
  unint64_t v36;
  unsigned int *v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  BOOL v41;
  char *v42;
  char *v44;
  const void *v45;
  void *v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  _QWORD v50[15];

  v50[14] = *MEMORY[0x24BDAC8D0];
  v46 = &v48;
  v47 = 0x200000000;
  v9 = 8 * a2;
  v48 = v50;
  v49 = 0x600000000;
  if ((unint64_t)(8 * a2) < 0x31)
  {
    v10 = 0;
    if (!a2)
      goto LABEL_6;
    goto LABEL_5;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v50, (8 * a2) >> 3, 8);
  v10 = v49;
  if (a2)
  {
LABEL_5:
    memcpy(&v48[v10], a1, v9);
    v10 = v49;
  }
LABEL_6:
  v11 = (v47 + 1);
  LODWORD(v49) = v10 + (v9 >> 3);
  LODWORD(v47) = v11;
  v44 = &a3[8 * a4];
  v45 = a3;
  if (v11 < HIDWORD(v47))
  {
    v12 = (char *)v46 + 64 * v11;
    *v12 = v12 + 2;
    v12[1] = 0x600000000;
    v13 = 8 * a4;
    if ((unint64_t)(8 * a4) < 0x31)
    {
      v14 = 0;
      if (!a4)
        goto LABEL_12;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v12, v12 + 2, v13 >> 3, 8);
      v14 = *((_DWORD *)v12 + 2);
      if (!a4)
      {
LABEL_12:
        *((_DWORD *)v12 + 2) = v14 + a4;
        LODWORD(v47) = v47 + 1;
        v15 = (unsigned int *)v46;
        v16 = v47;
        v17 = *((unsigned int *)v46 + 2);
        v18 = (unint64_t)v47 << 6;
        if ((_DWORD)v47 == 1)
          goto LABEL_13;
LABEL_16:
        v20 = v16 - 1;
        if ((unint64_t)(v16 - 1) >= 4)
        {
          v21 = v20 & 0xFFFFFFFFFFFFFFFCLL | 1;
          v22 = (int8x16_t)vdupq_n_s64(v17);
          v23 = v15 + 66;
          v4 = v20 & 0xFFFFFFFFFFFFFFFCLL;
          v24 = v22;
          do
          {
            v25.i64[0] = *(v23 - 48);
            v25.i64[1] = *(v23 - 32);
            v26 = v25;
            v25.i64[0] = *(v23 - 16);
            v25.i64[1] = *v23;
            v22 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v22, (uint64x2_t)v26), v22, v26);
            v24 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v24, (uint64x2_t)v25), v24, v25);
            v23 += 64;
            v4 -= 4;
          }
          while (v4);
          v27 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v22, (uint64x2_t)v24), v22, v24);
          v28 = vextq_s8(v27, v27, 8uLL).u64[0];
          v17 = (unint64_t)vbsl_s8((int8x8_t)vcgtd_u64(v27.u64[0], v28), *(int8x8_t *)v27.i8, (int8x8_t)v28);
          if (v20 == (v20 & 0xFFFFFFFFFFFFFFFCLL))
            goto LABEL_25;
        }
        else
        {
          v21 = 1;
        }
        v29 = v16 - v21;
        v30 = &v15[16 * v21 + 2];
        do
        {
          v32 = *v30;
          v30 += 16;
          v31 = v32;
          if (v17 <= v32)
            v17 = v31;
          --v29;
        }
        while (v29);
LABEL_25:
        if (!v17)
        {
LABEL_43:
          v19 = 1;
          if ((_DWORD)v16)
            goto LABEL_46;
          goto LABEL_49;
        }
        if (!(_DWORD)v16)
        {
          v19 = 1;
          if (v15 != (unsigned int *)&v48)
            goto LABEL_50;
          return v19;
        }
        goto LABEL_27;
      }
    }
    memcpy((void *)(*v12 + 8 * v14), a3, v13);
    v14 = *((_DWORD *)v12 + 2);
    goto LABEL_12;
  }
  llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,6u>,false>::growAndEmplaceBack<long long const*,long long const*>((uint64_t)&v46, &v45, (const void **)&v44);
  v15 = (unsigned int *)v46;
  v16 = v47;
  v17 = *((unsigned int *)v46 + 2);
  v18 = (unint64_t)v47 << 6;
  if ((_DWORD)v47 != 1)
    goto LABEL_16;
LABEL_13:
  if (!(_DWORD)v17)
  {
    v19 = 1;
    goto LABEL_46;
  }
LABEL_27:
  v33 = 0;
LABEL_29:
  v34 = 0;
  v35 = 0;
  v4 &= 0xFFFFFFFFFFFFFF00;
  v36 = v18;
  v37 = v15 + 2;
  while (1)
  {
    v39 = *v37;
    if (v33 >= v39 || (v40 = *(_QWORD *)(*((_QWORD *)v37 - 1) + 8 * (v39 + ~v33)), v40 == 1))
    {
      v38 = v35;
      goto LABEL_31;
    }
    if (v40 == 0x8000000000000000)
    {
      if (v34 & 1 | ((_DWORD)v35 != 0))
        break;
      v38 = 1;
      v4 = 0x8000000000000000;
      v34 = 1;
      goto LABEL_31;
    }
    v38 = 1;
    if (!(_DWORD)v35)
    {
      v4 = v40;
      goto LABEL_31;
    }
    v41 = v40 == v4;
    v4 = v40;
    if (!v41)
      break;
LABEL_31:
    v37 += 16;
    v35 = v38;
    v36 -= 64;
    if (!v36)
    {
      if (++v33 == v17)
        goto LABEL_43;
      goto LABEL_29;
    }
  }
  v19 = 0;
  if (!(_DWORD)v16)
    goto LABEL_49;
  do
  {
LABEL_46:
    v42 = *(char **)((char *)v15 + v18 - 64);
    if ((char *)v15 + v18 - 48 != v42)
      free(v42);
    v18 -= 64;
  }
  while (v18);
  v15 = (unsigned int *)v46;
LABEL_49:
  if (v15 != (unsigned int *)&v48)
LABEL_50:
    free(v15);
  return v19;
}

uint64_t mlir::OpTrait::util::getBroadcastedShape(uint64_t *a1, unint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  unsigned int v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;
  unint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  BOOL v24;
  uint64_t v25;

  *(_DWORD *)(a5 + 8) = 0;
  if (a2 <= a4)
  {
    if (!a4)
      return 1;
    v10 = 0;
    v14 = 8 * a4;
    v15 = a3;
    do
    {
      v16 = *v15;
      if (v10 >= *(_DWORD *)(a5 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v10 + 1, 8);
        v10 = *(_DWORD *)(a5 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a5 + 8 * v10) = v16;
      v10 = *(_DWORD *)(a5 + 8) + 1;
      *(_DWORD *)(a5 + 8) = v10;
      ++v15;
      v14 -= 8;
    }
    while (v14);
  }
  else
  {
    v10 = 0;
    v11 = 8 * a2;
    v12 = a1;
    do
    {
      v13 = *v12;
      if (v10 >= *(_DWORD *)(a5 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v10 + 1, 8);
        v10 = *(_DWORD *)(a5 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a5 + 8 * v10) = v13;
      v10 = *(_DWORD *)(a5 + 8) + 1;
      *(_DWORD *)(a5 + 8) = v10;
      ++v12;
      v11 -= 8;
    }
    while (v11);
  }
  result = 1;
  if (a2 && a4)
  {
    v18 = 8 * a2 - 8;
    v19 = (unint64_t *)(*(_QWORD *)a5 + 8 * v10 - 8);
    v20 = 8 * a4 - 8;
    while (1)
    {
      v21 = *(uint64_t *)((char *)a1 + v18);
      v22 = *(uint64_t *)((char *)a3 + v20);
      if (v21 == 0x8000000000000000)
        break;
      if (v22 == 0x8000000000000000)
      {
        v23 = *(uint64_t *)((char *)a1 + v18);
        if (v21 > 1)
          goto LABEL_27;
        goto LABEL_21;
      }
      v24 = v21 == v22 || v22 == 1;
      v23 = *(uint64_t *)((char *)a1 + v18);
      if (!v24)
      {
        v23 = *(uint64_t *)((char *)a3 + v20);
        if (v21 != 1)
        {
          result = 0;
          *(_DWORD *)(a5 + 8) = 0;
          return result;
        }
      }
LABEL_27:
      *v19-- = v23;
      if (v18)
      {
        v18 -= 8;
        v25 = v20;
        v20 -= 8;
        if (v25)
          continue;
      }
      return result;
    }
    v23 = *(uint64_t *)((char *)a3 + v20);
    if (v22 > 1)
      goto LABEL_27;
    v23 = *(uint64_t *)((char *)a1 + v18);
    if (v22 == 1)
      goto LABEL_27;
LABEL_21:
    v23 = 0x8000000000000000;
    goto LABEL_27;
  }
  return result;
}

uint64_t mlir::OpTrait::util::getBroadcastedType(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t ElementTypeOrSelf;
  unint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;
  _BOOL4 v10;
  uint64_t v12;
  uint64_t v14;
  uint64_t *Shape;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  unint64_t v20;
  void *v21;
  _QWORD *v23;
  uint64_t v24;
  void *v25;
  size_t v26;
  _QWORD v27[5];

  ElementTypeOrSelf = a3;
  v5 = (unint64_t)a1;
  v27[4] = *MEMORY[0x24BDAC8D0];
  if (!a3)
  {
    ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
    if (ElementTypeOrSelf != mlir::getElementTypeOrSelf(a2))
      return 0;
  }
  v6 = *(_QWORD *)v5;
  v7 = *(void **)(*(_QWORD *)v5 + 136);
  v8 = *(void **)(*a2 + 136);
  if (v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    if (v8 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
      return 0;
    return mlir::UnrankedTensorType::get(ElementTypeOrSelf);
  }
  if (v8 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    if (v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
      return 0;
    return mlir::UnrankedTensorType::get(ElementTypeOrSelf);
  }
  v10 = v8 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id
     || v8 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id;
  if (v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id
    || v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v12 = 0;
    if (!v10)
      v8 = 0;
    if (v7 != v8 && v10)
      return v12;
    v10 = 1;
  }
  else if (v10)
  {
    v7 = *(void **)(*a2 + 136);
  }
  else
  {
    v7 = 0;
  }
  v25 = v27;
  v26 = 0x400000000;
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v6 + 8))
  {
    v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v5 + 8);
    v23 = (_QWORD *)v5;
    v24 = v14;
    if (v5)
    {
      Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v23);
      v5 = v16;
      v17 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a2 + 8);
      if (v17)
        goto LABEL_34;
LABEL_42:
      v23 = 0;
      v24 = v17;
      goto LABEL_43;
    }
  }
  else
  {
    v5 = 0;
    v23 = 0;
    v24 = 0;
  }
  Shape = 0;
  v17 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a2 + 8);
  if (!v17)
    goto LABEL_42;
LABEL_34:
  v18 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a2 + 8);
  v23 = a2;
  v24 = v18;
  if (a2)
  {
    v19 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v23);
    if (mlir::OpTrait::util::getBroadcastedShape(Shape, v5, v19, v20, (uint64_t)&v25))
      goto LABEL_36;
LABEL_44:
    v12 = 0;
    v21 = v25;
    if (v25 == v27)
      return v12;
    goto LABEL_51;
  }
LABEL_43:
  if (!mlir::OpTrait::util::getBroadcastedShape(Shape, v5, 0, 0, (uint64_t)&v25))
    goto LABEL_44;
LABEL_36:
  if (v10 && v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
  {
    v12 = mlir::VectorType::get((uint64_t)v25, v26, ElementTypeOrSelf, 0, 0);
    v21 = v25;
    if (v25 == v27)
      return v12;
    goto LABEL_51;
  }
  if (v10 && v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v12 = mlir::RankedTensorType::get((uint64_t)v25, v26, ElementTypeOrSelf, 0);
    v21 = v25;
    if (v25 == v27)
      return v12;
    goto LABEL_51;
  }
  v12 = ElementTypeOrSelf;
  v21 = v25;
  if (v25 != v27)
LABEL_51:
    free(v21);
  return v12;
}

uint64_t mlir::OpTrait::impl::verifyCompatibleOperandBroadcast(mlir::OpTrait::impl *this, mlir::Operation *a2)
{
  uint64_t v3;
  uint64_t v4;
  _BOOL4 v5;
  _BOOL4 v6;
  void *v7;
  BOOL v9;
  uint64_t *v10;
  uint64_t v11;
  void *v12;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  BOOL v30;
  void *v31;
  BOOL v33;
  uint64_t v34;
  void *v35;
  uint64_t v37;
  void *v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  _BOOL4 v44;
  void *v45;
  uint64_t v46;
  uint64_t NextResultAtOffset;
  uint64_t v48;
  uint64_t v49;
  BOOL v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  BOOL v65;
  _QWORD *v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t v71;
  uint64_t *Shape;
  unint64_t v73;
  char *v74;
  char *v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t *v81;
  _QWORD *v82;
  uint64_t v83;
  _QWORD *v84;
  uint64_t v85;
  uint64_t *v86;
  unint64_t v87;
  char BroadcastedShape;
  _QWORD *v89;
  _QWORD *v90;
  void *v91;
  _QWORD *v92;
  _QWORD *v93;
  void *v94;
  uint64_t v95;
  uint64_t v96;
  const char *v97;
  char *v98;
  uint64_t v99;
  char *v100;
  char *v101;
  BOOL v102;
  uint64_t v103;
  _QWORD *v104;
  char *v105;
  BOOL v106;
  BOOL v107;
  char *v108;
  _QWORD *v109;
  uint64_t v110;
  _QWORD *v111;
  unint64_t v112;
  uint64_t v113;
  _QWORD *v114;
  uint64_t v115;
  uint64_t v116;
  void *v118;
  void **p_dst;
  char *v121;
  char *v122;
  __int128 v123;
  uint64_t v124;
  unint64_t *v125;
  uint64_t v126;
  uint64_t v127;
  void **v128;
  char *v129;
  char *v130;
  __int128 v131;
  unsigned int v132;
  _QWORD *v133;
  _QWORD *v134;
  void *v135;
  _QWORD *v136;
  _QWORD *v137;
  void *v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  unint64_t v142;
  int64_t v143;
  int64_t v144;
  unsigned int v145;
  std::string v146;
  std::string v147;
  const void **v148[4];
  __int16 v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  void *__dst;
  uint64_t v159;
  _QWORD v160[2];
  __int16 v161;
  void *__src;
  uint64_t v163;
  _WORD v164[16];
  _QWORD *v165;
  uint64_t v166;
  _QWORD *v167;
  void *v168;
  unsigned int v169;
  unsigned int v170;
  _BYTE v171[96];
  void *v172;
  _QWORD *v173;
  void *__p;
  _QWORD *v175;
  char v176;
  uint64_t v177;

  v177 = *MEMORY[0x24BDAC8D0];
  if ((*((_BYTE *)this + 46) & 0x80) != 0)
  {
    v3 = *((_QWORD *)this + 9);
    v4 = *((unsigned int *)this + 17);
  }
  else
  {
    v3 = 0;
    v4 = 0;
  }
  v165 = (_QWORD *)v3;
  v166 = v4;
  mlir::OperandRange::getTypes((uint64_t *)&v165, &v154);
  if (v154 == v156 && v157 == v155)
  {
    v5 = 0;
    v6 = 1;
    goto LABEL_42;
  }
  v7 = *(void **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v154 + 32 * v155 + 24) + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
  v9 = v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
  if (v154 == v156)
  {
    if (v9)
    {
      v5 = 1;
      goto LABEL_37;
    }
    v14 = (uint64_t *)(v154 + 32 * v155 + 56);
    v15 = v157 - v155;
    while (1)
    {
      v5 = --v15 != 0;
      if (!v15)
        break;
      v16 = *v14;
      v14 += 4;
      v17 = *(void **)(*(_QWORD *)(*(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
      if (v17 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
        || v17 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
      {
        goto LABEL_31;
      }
    }
  }
  else
  {
    if (v9)
    {
      v5 = 1;
      goto LABEL_33;
    }
    v10 = (uint64_t *)(v154 + 32 * v155 + 56);
    do
    {
      v11 = *v10;
      v10 += 4;
      v12 = *(void **)(*(_QWORD *)(*(_QWORD *)(v11 + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
    }
    while (v12 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
         && v12 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id);
LABEL_31:
    v5 = 1;
  }
  if (v154 != v156)
  {
LABEL_33:
    if (v7 != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
    {
      v19 = (uint64_t *)(v154 + 32 * v155 + 56);
      do
      {
        v20 = *v19;
        v19 += 4;
      }
      while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id);
    }
    goto LABEL_41;
  }
LABEL_37:
  if (v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
  {
LABEL_41:
    v6 = 0;
    goto LABEL_42;
  }
  v21 = (uint64_t *)(v154 + 32 * v155 + 56);
  v22 = v157 - v155;
  while (1)
  {
    v6 = --v22 == 0;
    if (!v22)
      break;
    v23 = *v21;
    v21 += 4;
    if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v23 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
      goto LABEL_41;
  }
LABEL_42:
  v24 = *((unsigned int *)this + 9);
  v25 = (char *)this - 16;
  if (!(_DWORD)v24)
    v25 = 0;
  v165 = v25;
  v166 = v24;
  mlir::OperandRange::getTypes((uint64_t *)&v165, &v150);
  v26 = v150;
  v27 = v151;
  v28 = v153;
  v29 = v150 != v152;
  if (v150 == v152 && v151 == v153)
  {
    v30 = 1;
    goto LABEL_71;
  }
  v31 = *(void **)(*(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v150, v151) + 8) & 0xFFFFFFFFFFFFFFF8)
                 + 136);
  v33 = v31 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
     || v31 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
  if (v29)
  {
    if (!v33)
    {
      v34 = v27 + 1;
      do
        v35 = *(void **)(*(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v26, v34++) + 8) & 0xFFFFFFFFFFFFFFF8)
                       + 136);
      while (v35 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
           && v35 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id);
    }
    goto LABEL_70;
  }
  if (v33)
  {
LABEL_70:
    v30 = 0;
    goto LABEL_71;
  }
  v37 = v27 + 1;
  while (1)
  {
    v30 = v28 == v37;
    if (v28 == v37)
      break;
    v38 = *(void **)(*(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v26, v37++) + 8) & 0xFFFFFFFFFFFFFFF8)
                   + 136);
    if (v38 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      || v38 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_70;
    }
  }
LABEL_71:
  v40 = v150;
  v41 = v151;
  v42 = v153;
  v43 = v150 != v152;
  if (v150 == v152 && v151 == v153)
  {
    v44 = 1;
    goto LABEL_84;
  }
  v45 = *(void **)(*(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v150, v151) + 8) & 0xFFFFFFFFFFFFFFF8)
                 + 136);
  if (v43)
  {
    if (v45 != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
    {
      v46 = v41 + 1;
      do
        NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v40, v46++);
      while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id);
    }
    goto LABEL_83;
  }
  if (v45 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
  {
LABEL_83:
    v44 = 0;
    goto LABEL_84;
  }
  v48 = v41 + 1;
  while (1)
  {
    v44 = v42 == v48;
    if (v42 == v48)
      break;
    v49 = mlir::detail::OpResultImpl::getNextResultAtOffset(v40, v48++);
    if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v49 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
      goto LABEL_83;
  }
LABEL_84:
  v50 = !v5 && v30;
  if (v50 || v6 && v44)
  {
    if ((*((_BYTE *)this + 46) & 0x80) != 0)
    {
      v60 = (void *)*((_QWORD *)this + 9);
      v61 = *((unsigned int *)this + 17);
    }
    else
    {
      v60 = 0;
      v61 = 0;
    }
    __src = v60;
    v163 = v61;
    mlir::OperandRange::getTypes((uint64_t *)&__src, (uint64_t *)&v165);
    v63 = (uint64_t)v165;
    v62 = v166;
    v64 = (char *)v168;
    v65 = v165 != v167;
    if (v165 != v167 || (void *)v166 != v168)
    {
      if (v165 == v167)
      {
        v69 = (uint64_t)&v165[4 * v166 + 3];
        while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v69 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
        {
          ++v62;
          v69 += 32;
          if (v168 == (void *)v62)
          {
            v62 = (uint64_t)v168;
            break;
          }
        }
      }
      else
      {
        v66 = &v165[4 * v166];
        if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v66[3] + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
        {
          v67 = v66 + 7;
          do
          {
            v68 = *v67;
            v67 += 4;
            ++v62;
          }
          while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v68 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id);
        }
      }
    }
    if (v165 == v167 && (void *)v62 == v168)
      return 1;
    __src = v164;
    v163 = 0x400000000;
    v70 = (_QWORD *)(*(_QWORD *)(v165[4 * v62 + 3] + 8) & 0xFFFFFFFFFFFFFFF8);
    if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v70 + 8))
    {
      v71 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v70 + 8);
      v165 = v70;
      v166 = v71;
      if (v70)
      {
        Shape = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v165);
LABEL_128:
        mlir::OpTrait::util::getBroadcastedShape(Shape, v73, 0, 0, (uint64_t)&__src);
        while (1)
        {
          if (!v65 && v62 == (_QWORD)v64)
          {
            v97 = (const char *)*((unsigned int *)this + 9);
            v98 = (char *)this - 16;
            if (!(_DWORD)v97)
              v98 = 0;
            __dst = v98;
            v159 = (uint64_t)v97;
            mlir::OperandRange::getTypes((uint64_t *)&__dst, (uint64_t *)&v165);
            v99 = (uint64_t)v165;
            v100 = (char *)v166;
            v101 = (char *)v168;
            v102 = v165 != v167;
            if (v165 != v167 || (void *)v166 != v168)
            {
              if (v165 == v167)
              {
                do
                {
                  if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v99, (uint64_t)v100)+ 8) & 0xFFFFFFFFFFFFFFF8)+ 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)goto LABEL_184;
                  ++v100;
                }
                while (v101 != v100);
                v100 = v101;
              }
              else
              {
                do
                  v103 = mlir::detail::OpResultImpl::getNextResultAtOffset(v99, (uint64_t)v100++);
                while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v103 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id);
                --v100;
              }
            }
LABEL_184:
            v104 = v167;
            v105 = (char *)v168;
            v106 = (_QWORD *)v99 == v167 && v100 == v168;
            if (v106 || ((_QWORD *)v99 == v167 ? (v107 = v100 == v168) : (v107 = 0), v107))
            {
              v145 = 1;
LABEL_220:
              v118 = __src;
              if (__src == v164)
                return v145;
              goto LABEL_221;
            }
            while (2)
            {
              v108 = v100;
              v109 = (_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v99, (uint64_t)v100) + 8) & 0xFFFFFFFFFFFFFFF8);
              if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v109 + 8))
              {
                v110 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v109 + 8);
                v165 = v109;
                v166 = v110;
                if (v109)
                {
                  v111 = (_QWORD *)mlir::ShapedType::getShape((mlir::ShapedType *)&v165);
                  v113 = v163;
                  if (v112 > v163)
                  {
                    v111 += v112 - v163;
LABEL_199:
                    if (v113)
                    {
                      v114 = __src;
                      v115 = 8 * v113 - 8;
                      while (1)
                      {
                        v116 = v115;
                        if (*v111 != 0x8000000000000000 && *v114 != 0x8000000000000000 && *v114 != *v111)
                          break;
                        ++v114;
                        ++v111;
                        v115 -= 8;
                        if (!v116)
                          goto LABEL_208;
                      }
LABEL_224:
                      v149 = 257;
                      mlir::Operation::emitOpError((uint64_t *)this, v148, (uint64_t)&v165);
                      if (v165)
                      {
                        LODWORD(__dst) = 3;
                        v159 = (uint64_t)"result type ";
                        v160[0] = 12;
                        p_dst = &__dst;
                        v121 = (char *)v168;
                        if (v169 >= v170)
                        {
                          v141 = v169 + 1;
                          if (v168 <= &__dst && (char *)v168 + 24 * v169 > (char *)&__dst)
                          {
                            v143 = (char *)&__dst - (_BYTE *)v168;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v168, v171, v141, 24);
                            v121 = (char *)v168;
                            p_dst = (void **)((char *)v168 + v143);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v168, v171, v141, 24);
                            p_dst = &__dst;
                            v121 = (char *)v168;
                          }
                        }
                        v122 = &v121[24 * v169];
                        v123 = *(_OWORD *)p_dst;
                        *((_QWORD *)v122 + 2) = p_dst[2];
                        *(_OWORD *)v122 = v123;
                        ++v169;
                      }
                      v124 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v109 + 8);
                      if (v124)
                        v124 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v109 + 8);
                      else
                        v109 = 0;
                      __dst = v109;
                      v159 = v124;
                      if (v109)
                      {
                        v125 = (unint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&__dst);
                        v127 = v126;
                      }
                      else
                      {
                        v127 = 0;
                        v125 = 0;
                      }
                      getShapeString(&v147, v125, v127);
                      if (v165)
                      {
                        v161 = 260;
                        __dst = &v147;
                        mlir::Diagnostic::operator<<((uint64_t)&v166, (const void ***)&__dst);
                        if (v165)
                        {
                          LODWORD(__dst) = 3;
                          v159 = (uint64_t)" not broadcast compatible with broadcasted operands's shapes ";
                          v160[0] = 61;
                          v128 = &__dst;
                          v129 = (char *)v168;
                          if (v169 >= v170)
                          {
                            v142 = v169 + 1;
                            if (v168 <= &__dst && (char *)v168 + 24 * v169 > (char *)&__dst)
                            {
                              v144 = (char *)&__dst - (_BYTE *)v168;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v168, v171, v142, 24);
                              v129 = (char *)v168;
                              v128 = (void **)((char *)v168 + v144);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v168, v171, v142, 24);
                              v128 = &__dst;
                              v129 = (char *)v168;
                            }
                          }
                          v130 = &v129[24 * v169];
                          v131 = *(_OWORD *)v128;
                          *((_QWORD *)v130 + 2) = v128[2];
                          *(_OWORD *)v130 = v131;
                          ++v169;
                        }
                      }
                      getShapeString(&v146, (unint64_t *)__src, v163);
                      if (v165)
                      {
                        v161 = 260;
                        __dst = &v146;
                        mlir::Diagnostic::operator<<((uint64_t)&v166, (const void ***)&__dst);
                      }
                      v132 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v165);
                      if ((SHIBYTE(v146.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                      {
                        if ((SHIBYTE(v147.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                          goto LABEL_241;
LABEL_256:
                        operator delete(v147.__r_.__value_.__l.__data_);
                        if (!v165)
                          goto LABEL_243;
LABEL_242:
                        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v165);
                        goto LABEL_243;
                      }
                      operator delete(v146.__r_.__value_.__l.__data_);
                      if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0)
                        goto LABEL_256;
LABEL_241:
                      if (v165)
                        goto LABEL_242;
LABEL_243:
                      if (v176)
                      {
                        v133 = __p;
                        if (__p)
                        {
                          v134 = v175;
                          v135 = __p;
                          if (v175 != __p)
                          {
                            do
                              v134 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v134 - 1);
                            while (v134 != v133);
                            v135 = __p;
                          }
                          v175 = v133;
                          operator delete(v135);
                        }
                        v136 = v172;
                        if (v172)
                        {
                          v137 = v173;
                          v138 = v172;
                          if (v173 != v172)
                          {
                            do
                            {
                              v140 = *--v137;
                              v139 = v140;
                              *v137 = 0;
                              if (v140)
                                MEMORY[0x20BD002D4](v139, 0x1000C8077774924);
                            }
                            while (v137 != v136);
                            v138 = v172;
                          }
                          v173 = v136;
                          operator delete(v138);
                        }
                        if (v168 != v171)
                          free(v168);
                      }
                      v145 = v132;
                      v118 = __src;
                      if (__src == v164)
                        return v145;
LABEL_221:
                      free(v118);
                      return v145;
                    }
LABEL_208:
                    v100 = v101;
                    if (v102 || v108 + 1 != v101)
                    {
                      v100 = v108 + 1;
                      if (v102)
                      {
                        v100 = v108;
                        do
                          ++v100;
                        while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v99, (uint64_t)v100)+ 8) & 0xFFFFFFFFFFFFFFF8)+ 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id);
                      }
                      else
                      {
                        while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v99, (uint64_t)v100)+ 8) & 0xFFFFFFFFFFFFFFF8)+ 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
                        {
                          if (v101 == ++v100)
                          {
                            v100 = v101;
                            break;
                          }
                        }
                      }
                    }
                    if ((_QWORD *)v99 == v104)
                    {
                      v145 = 1;
                      if (v100 == v105)
                        goto LABEL_220;
                    }
                    continue;
                  }
LABEL_198:
                  if (v113 != v112)
                    goto LABEL_224;
                  goto LABEL_199;
                }
              }
              else
              {
                v165 = 0;
                v166 = 0;
              }
              break;
            }
            v111 = 0;
            v112 = 0;
            v113 = v163;
            goto LABEL_198;
          }
          v74 = (char *)(v62 + 1);
          v75 = v64;
          if (v65 || v62 + 1 != (_QWORD)v64)
          {
            if (!v65)
            {
              v78 = v63 + 56 + 32 * v62;
              while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)v78 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
              {
                ++v74;
                v78 += 32;
                if (v64 == v74)
                {
                  v75 = v64;
                  goto LABEL_142;
                }
              }
LABEL_141:
              v75 = v74;
              goto LABEL_142;
            }
            if (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v63 + 32 * (_QWORD)v74 + 24) + 8) & 0xFFFFFFFFFFFFFFF8)
                              + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
              goto LABEL_141;
            v76 = (uint64_t *)(v63 + 88 + 32 * v62);
            v75 = (char *)(v62 + 1);
            do
            {
              v77 = *v76;
              v76 += 4;
              ++v75;
            }
            while (*(_UNKNOWN **)(*(_QWORD *)(*(_QWORD *)(v77 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id);
          }
LABEL_142:
          v79 = *(_QWORD *)(*(_QWORD *)(v63 + 32 * v62 + 24) + 8);
          __dst = v160;
          v159 = 0x400000000;
          v80 = v163;
          v81 = v160;
          if (!(_DWORD)v163)
            goto LABEL_148;
          v82 = v160;
          v83 = v163;
          if (v163 < 5uLL)
            goto LABEL_146;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v160, v163, 8);
          v83 = v163;
          if ((_DWORD)v163)
          {
            v82 = __dst;
LABEL_146:
            memcpy(v82, __src, 8 * v83);
          }
          LODWORD(v159) = v80;
          v81 = (uint64_t *)__dst;
LABEL_148:
          v84 = (_QWORD *)(v79 & 0xFFFFFFFFFFFFFFF8);
          if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v84 + 8))
          {
            v85 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v84 + 8);
            v165 = v84;
            v166 = v85;
            if (v84)
            {
              v86 = (uint64_t *)mlir::ShapedType::getShape((mlir::ShapedType *)&v165);
              BroadcastedShape = mlir::OpTrait::util::getBroadcastedShape(v81, v80, v86, v87, (uint64_t)&__src);
              if ((BroadcastedShape & 1) == 0)
                goto LABEL_154;
              goto LABEL_172;
            }
          }
          else
          {
            v165 = 0;
            v166 = 0;
          }
          BroadcastedShape = mlir::OpTrait::util::getBroadcastedShape(v81, v80, 0, 0, (uint64_t)&__src);
          if ((BroadcastedShape & 1) == 0)
          {
LABEL_154:
            v148[0] = (const void **)"operands don't have broadcast-compatible shapes";
            v149 = 259;
            mlir::Operation::emitOpError((uint64_t *)this, v148, (uint64_t)&v165);
            v145 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v165);
            if (v165)
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v165);
            if (v176)
            {
              v89 = __p;
              if (__p)
              {
                v90 = v175;
                v91 = __p;
                if (v175 != __p)
                {
                  do
                    v90 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v90 - 1);
                  while (v90 != v89);
                  v91 = __p;
                }
                v175 = v89;
                operator delete(v91);
              }
              v92 = v172;
              if (v172)
              {
                v93 = v173;
                v94 = v172;
                if (v173 != v172)
                {
                  do
                  {
                    v96 = *--v93;
                    v95 = v96;
                    *v93 = 0;
                    if (v96)
                      MEMORY[0x20BD002D4](v95, 0x1000C8077774924);
                  }
                  while (v93 != v92);
                  v94 = v172;
                }
                v173 = v92;
                operator delete(v94);
              }
              if (v168 != v171)
                free(v168);
            }
          }
LABEL_172:
          if (__dst != v160)
            free(__dst);
          v62 = (uint64_t)v75;
          if ((BroadcastedShape & 1) == 0)
            goto LABEL_220;
        }
      }
    }
    else
    {
      v165 = 0;
      v166 = 0;
    }
    v73 = 0;
    Shape = 0;
    goto LABEL_128;
  }
  __src = "cannot broadcast vector with tensor";
  v164[8] = 259;
  mlir::Operation::emitError((uint64_t *)this, (uint64_t)&__src, (uint64_t)&v165);
  v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v165);
  if (v165)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v165);
  if (v176)
  {
    v52 = __p;
    if (__p)
    {
      v53 = v175;
      v54 = __p;
      if (v175 != __p)
      {
        do
          v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
        while (v53 != v52);
        v54 = __p;
      }
      v175 = v52;
      operator delete(v54);
    }
    v55 = v172;
    if (v172)
    {
      v56 = v173;
      v57 = v172;
      if (v173 != v172)
      {
        do
        {
          v59 = *--v56;
          v58 = v59;
          *v56 = 0;
          if (v59)
            MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
        }
        while (v56 != v55);
        v57 = v172;
      }
      v173 = v55;
      operator delete(v57);
    }
    if (v168 != v171)
      free(v168);
  }
  return v51;
}

void getShapeString(std::string *a1, unint64_t *a2, uint64_t a3)
{
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  void **v9;
  __int128 v10;
  unint64_t *v11;
  uint64_t i;
  unint64_t v13;
  _BYTE *v14;
  void *v15;
  int v16;
  uint64_t v17;
  _BYTE *v18;
  _BYTE *v19;
  char v20;
  uint64_t v21;
  int v22;
  void **v23;
  void *__p[2];
  uint64_t v25;

  __p[0] = 0;
  __p[1] = 0;
  v25 = 0;
  v16 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 1;
  v18 = 0;
  v19 = 0;
  v17 = 0;
  v15 = &unk_24C02DC40;
  v23 = __p;
  llvm::raw_ostream::SetBufferAndMode((uint64_t)&v15, 0, 0, 0);
  v6 = v19;
  if (v19 >= v18)
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v15, 39);
    if (!a3)
      goto LABEL_12;
    goto LABEL_5;
  }
  ++v19;
  *v6 = 39;
  if (a3)
  {
LABEL_5:
    if (*a2 == 0x8000000000000000)
    {
      v7 = v19;
      if (v19 >= v18)
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v15, 63);
        if (a3 == 1)
          goto LABEL_12;
      }
      else
      {
        ++v19;
        *v7 = 63;
        if (a3 == 1)
          goto LABEL_12;
      }
    }
    else
    {
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v15, *a2);
      if (a3 == 1)
        goto LABEL_12;
    }
    v11 = a2 + 1;
    for (i = 8 * a3 - 8; i; i -= 8)
    {
      if (v18 == v19)
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v15, "x", 1uLL);
        v13 = *v11;
        if (*v11 == 0x8000000000000000)
        {
LABEL_27:
          v14 = v19;
          if (v19 >= v18)
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v15, 63);
          }
          else
          {
            ++v19;
            *v14 = 63;
          }
          goto LABEL_22;
        }
      }
      else
      {
        *v19++ = 120;
        v13 = *v11;
        if (*v11 == 0x8000000000000000)
          goto LABEL_27;
      }
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v15, v13);
LABEL_22:
      ++v11;
    }
  }
LABEL_12:
  v8 = v19;
  if (v19 >= v18)
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v15, 39);
    v9 = v23;
    if ((*((char *)v23 + 23) & 0x80000000) == 0)
    {
LABEL_14:
      v10 = *(_OWORD *)v9;
      a1->__r_.__value_.__r.__words[2] = (std::string::size_type)v9[2];
      *(_OWORD *)&a1->__r_.__value_.__l.__data_ = v10;
      llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v15);
      if ((SHIBYTE(v25) & 0x80000000) == 0)
        return;
      goto LABEL_15;
    }
  }
  else
  {
    ++v19;
    *v8 = 39;
    v9 = v23;
    if ((*((char *)v23 + 23) & 0x80000000) == 0)
      goto LABEL_14;
  }
  std::string::__init_copy_ctor_external(a1, (const std::string::value_type *)*v9, (std::string::size_type)v9[1]);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v15);
  if (SHIBYTE(v25) < 0)
LABEL_15:
    operator delete(__p[0]);
}

uint64_t llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,6u>,false>::growAndEmplaceBack<long long const*,long long const*>(uint64_t a1, const void **a2, const void **a3)
{
  _DWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _BYTE *v9;
  _BYTE *v10;
  uint64_t v11;
  unsigned int v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int v20;
  uint64_t v21;
  unint64_t v23;

  v23 = 0;
  v6 = (_DWORD *)(a1 + 16);
  v7 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 64, &v23);
  v8 = &v7[8 * (unint64_t)*(unsigned int *)(a1 + 8)];
  v9 = *a2;
  v10 = *a3;
  *v8 = v8 + 2;
  v8[1] = 0x600000000;
  v11 = v10 - v9;
  if ((unint64_t)(v10 - v9) < 0x31)
  {
    v12 = 0;
    if (v9 == v10)
      goto LABEL_6;
    goto LABEL_5;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v8, v8 + 2, v11 >> 3, 8);
  v12 = *((_DWORD *)v8 + 2);
  if (v9 != v10)
  {
LABEL_5:
    memcpy((void *)(*v8 + 8 * v12), v9, v10 - v9);
    v12 = *((_DWORD *)v8 + 2);
  }
LABEL_6:
  *((_DWORD *)v8 + 2) = v12 + ((unint64_t)v11 >> 3);
  v13 = *(_DWORD **)a1;
  v14 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v14)
  {
    v15 = v14 << 6;
    v16 = v7;
    do
    {
      *v16 = v16 + 2;
      v16[1] = 0x600000000;
      if (v13[2])
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v16, (uint64_t)v13);
      v16 += 8;
      v13 += 16;
      v15 -= 64;
    }
    while (v15);
    v13 = *(_DWORD **)a1;
    v17 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v17)
    {
      v18 = v17 << 6;
      do
      {
        v19 = *(char **)((char *)v13 + v18 - 64);
        if ((char *)v13 + v18 - 48 != v19)
          free(v19);
        v18 -= 64;
      }
      while (v18);
      v13 = *(_DWORD **)a1;
    }
  }
  v20 = v23;
  if (v13 != v6)
    free(v13);
  *(_QWORD *)a1 = v7;
  v21 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v21;
  *(_DWORD *)(a1 + 12) = v20;
  return (uint64_t)&v7[8 * v21 - 8];
}

void mlir::applyPermutationToVector<long long,6u>(uint64_t a1, uint64_t *a2)
{
  _QWORD *v4;
  unint64_t v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  _QWORD v17[7];

  v17[6] = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD **)a1;
  v5 = *(unsigned int *)(a1 + 8);
  v15 = v17;
  v16 = 0x600000000;
  if (v5 < 7)
  {
    v6 = 0;
    v7 = v17;
    if (!(_DWORD)v5)
      goto LABEL_6;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v15, v17, v5, 8);
    v6 = v16;
    v7 = v15;
  }
  v8 = v6;
  v9 = v5;
  do
  {
    v10 = *a2++;
    v7[v8++] = v4[v10];
    --v9;
  }
  while (v9);
LABEL_6:
  v11 = v6 + v5;
  LODWORD(v16) = v11;
  if (&v15 == (void **)a1)
    goto LABEL_22;
  if (v7 != v17)
  {
    if (*(_QWORD *)a1 != a1 + 16)
    {
      free(*(void **)a1);
      v7 = v15;
      LODWORD(v11) = v16;
    }
    *(_QWORD *)a1 = v7;
    v12 = HIDWORD(v16);
    *(_DWORD *)(a1 + 8) = v11;
    *(_DWORD *)(a1 + 12) = v12;
    v15 = v17;
    HIDWORD(v16) = 0;
    goto LABEL_21;
  }
  v13 = *(unsigned int *)(a1 + 8);
  if (v13 >= v11)
  {
    if ((_DWORD)v11)
      memmove(*(void **)a1, v17, 8 * v11);
    goto LABEL_20;
  }
  if (*(_DWORD *)(a1 + 12) < v11)
  {
    *(_DWORD *)(a1 + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v11, 8);
    v13 = 0;
    v14 = v16;
    if (!(_DWORD)v16)
      goto LABEL_20;
    goto LABEL_19;
  }
  if (!(_DWORD)v13)
  {
    v13 = 0;
    v14 = v16;
    if (!(_DWORD)v16)
      goto LABEL_20;
    goto LABEL_19;
  }
  memmove(*(void **)a1, v17, 8 * v13);
  v14 = v16;
  if (v13 != v16)
LABEL_19:
    memcpy((void *)(*(_QWORD *)a1 + 8 * v13), (char *)v15 + 8 * v13, 8 * v14 - 8 * v13);
LABEL_20:
  *(_DWORD *)(a1 + 8) = v11;
LABEL_21:
  LODWORD(v16) = 0;
  v7 = v15;
LABEL_22:
  if (v7 != v17)
    free(v7);
}

_QWORD *llvm::DenseMapBase<llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::InsertIntoBucket<long long const&,llvm::detail::DenseSetEmpty&>(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  uint64_t v11;
  int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  BOOL v18;
  unsigned int v19;

  v6 = *(_DWORD *)a1;
  v7 = *(_DWORD *)a1 >> 1;
  if ((*(_DWORD *)a1 & 1) != 0)
    v8 = 4;
  else
    v8 = *(_DWORD *)(a1 + 16);
  if (4 * v7 + 4 >= 3 * v8)
  {
    v8 *= 2;
  }
  else if (v8 + ~v7 - *(_DWORD *)(a1 + 4) > v8 >> 3)
  {
    v9 = *(_DWORD *)a1 & 1;
    goto LABEL_7;
  }
  llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::grow(a1, v8);
  v11 = a1 + 8;
  v6 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 & 1) != 0)
  {
    v12 = 4;
  }
  else
  {
    v12 = *(_DWORD *)(a1 + 16);
    if (!v12)
    {
      v9 = 0;
      a2 = 0;
      goto LABEL_7;
    }
    v11 = *(_QWORD *)(a1 + 8);
  }
  v9 = *(_DWORD *)a1 & 1;
  v13 = v12 - 1;
  v14 = (37 * *a3) & (v12 - 1);
  a2 = (_QWORD *)(v11 + 8 * v14);
  v15 = *a2;
  if (*a3 != *a2)
  {
    v16 = 0;
    v17 = 1;
    while (v15 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if (v16)
        v18 = 0;
      else
        v18 = v15 == 0x8000000000000000;
      if (v18)
        v16 = a2;
      v19 = v14 + v17++;
      v14 = v19 & v13;
      a2 = (_QWORD *)(v11 + 8 * (v19 & v13));
      v15 = *a2;
      if (*a3 == *a2)
        goto LABEL_7;
    }
    if (v16)
      a2 = v16;
  }
LABEL_7:
  *(_DWORD *)a1 = (v6 & 0xFFFFFFFE | v9) + 2;
  if (*a2 != 0x7FFFFFFFFFFFFFFFLL)
    --*(_DWORD *)(a1 + 4);
  *a2 = *a3;
  return a2;
}

void llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::grow(uint64_t a1, unsigned int a2)
{
  unint64_t v3;
  unint64_t v4;
  int v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  _QWORD v16[4];

  v16[3] = *MEMORY[0x24BDAC8D0];
  if (a2 >= 5)
  {
    v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40)
      a2 = v5 + 1;
    else
      a2 = 64;
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    v6 = *(uint64_t **)(a1 + 8);
    v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      v13 = a2;
      *(_QWORD *)(a1 + 8) = llvm::allocate_buffer(8 * a2, (std::align_val_t)8uLL);
      *(_QWORD *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    v14 = (char *)(8 * v7);
    llvm::DenseMapBase<llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::moveFromOldBuckets((_DWORD *)a1, v6, (uint64_t *)&v14[(_QWORD)v6]);
    llvm::deallocate_buffer((llvm *)v6, v14);
  }
  v8 = &v15;
  if ((unint64_t)(*(_QWORD *)(a1 + 8) - 0x7FFFFFFFFFFFFFFFLL) >= 2)
  {
    v15 = *(_QWORD *)(a1 + 8);
    v8 = v16;
    v9 = *(_QWORD *)(a1 + 16);
    if ((unint64_t)(v9 - 0x7FFFFFFFFFFFFFFFLL) < 2)
    {
LABEL_10:
      v10 = *(_QWORD *)(a1 + 24);
      if ((unint64_t)(v10 - 0x7FFFFFFFFFFFFFFFLL) < 2)
        goto LABEL_11;
      goto LABEL_19;
    }
  }
  else
  {
    v9 = *(_QWORD *)(a1 + 16);
    if ((unint64_t)(v9 - 0x7FFFFFFFFFFFFFFFLL) < 2)
      goto LABEL_10;
  }
  *v8++ = v9;
  v10 = *(_QWORD *)(a1 + 24);
  if ((unint64_t)(v10 - 0x7FFFFFFFFFFFFFFFLL) < 2)
  {
LABEL_11:
    v11 = *(_QWORD *)(a1 + 32);
    if ((unint64_t)(v11 - 0x7FFFFFFFFFFFFFFFLL) < 2)
      goto LABEL_12;
LABEL_20:
    *v8++ = v11;
    if (a2 < 5)
      goto LABEL_14;
    goto LABEL_13;
  }
LABEL_19:
  *v8++ = v10;
  v11 = *(_QWORD *)(a1 + 32);
  if ((unint64_t)(v11 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
    goto LABEL_20;
LABEL_12:
  if (a2 >= 5)
  {
LABEL_13:
    *(_DWORD *)a1 &= ~1u;
    v12 = a2;
    *(_QWORD *)(a1 + 8) = llvm::allocate_buffer(8 * a2, (std::align_val_t)8uLL);
    *(_QWORD *)(a1 + 16) = v12;
  }
LABEL_14:
  llvm::DenseMapBase<llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::moveFromOldBuckets((_DWORD *)a1, &v15, v8);
}

void llvm::DenseMapBase<llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::moveFromOldBuckets(_DWORD *a1, uint64_t *a2, uint64_t *a3)
{
  int v6;
  _DWORD *v7;
  uint64_t v8;
  void *v9;
  _DWORD *v10;
  int v11;
  int v12;
  unsigned int v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  int v18;
  BOOL v19;
  unsigned int v20;

  v6 = *a1;
  *(_QWORD *)a1 = *a1 & 1;
  v7 = a1 + 2;
  if ((v6 & 1) != 0)
  {
    v8 = 4;
    v9 = a1 + 2;
  }
  else
  {
    v8 = a1[4];
    if (!(_DWORD)v8)
      goto LABEL_6;
    v9 = (void *)*((_QWORD *)a1 + 1);
  }
  memset_pattern16(v9, &unk_207AB7E40, 8 * v8);
LABEL_6:
  while (a2 != a3)
  {
    v16 = *a2;
    if ((unint64_t)(*a2 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
    {
      if ((*(_BYTE *)a1 & 1) != 0)
      {
        v11 = 4;
        v10 = v7;
      }
      else
      {
        v10 = (_DWORD *)*((_QWORD *)a1 + 1);
        v11 = a1[4];
      }
      v12 = v11 - 1;
      v13 = (v11 - 1) & (37 * v16);
      v14 = &v10[2 * v13];
      v15 = *v14;
      if (v16 != *v14)
      {
        v17 = 0;
        v18 = 1;
        while (v15 != 0x7FFFFFFFFFFFFFFFLL)
        {
          if (v17)
            v19 = 0;
          else
            v19 = v15 == 0x8000000000000000;
          if (v19)
            v17 = v14;
          v20 = v13 + v18++;
          v13 = v20 & v12;
          v14 = &v10[2 * (v20 & v12)];
          v15 = *v14;
          if (v16 == *v14)
            goto LABEL_10;
        }
        if (v17)
          v14 = v17;
      }
LABEL_10:
      *v14 = v16;
      *a1 += 2;
    }
    ++a2;
  }
}

void llvm::DenseMapBase<llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::try_emplace<llvm::detail::DenseSetEmpty&>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t *v14;
  int v15;
  BOOL v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t *v22;
  int v23;
  BOOL v24;
  unsigned int v25;

  v6 = *(_QWORD *)a1;
  v7 = *(_DWORD *)(a1 + 16);
  if (!v7)
    goto LABEL_23;
  v8 = v7 - 1;
  v9 = (37 * *a2) & (v7 - 1);
  v10 = (uint64_t *)(v6 + 8 * v9);
  v11 = *v10;
  if (*a2 == *v10)
  {
LABEL_3:
    v12 = 0;
    goto LABEL_10;
  }
  v14 = 0;
  v15 = 1;
  while (v11 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (v14)
      v16 = 0;
    else
      v16 = v11 == 0x8000000000000000;
    if (v16)
      v14 = v10;
    v17 = v9 + v15++;
    v9 = v17 & v8;
    v10 = (uint64_t *)(v6 + 8 * (v17 & v8));
    v11 = *v10;
    if (*a2 == *v10)
      goto LABEL_3;
  }
  if (v14)
    v10 = v14;
  v18 = *(_DWORD *)(a1 + 8);
  if (4 * v18 + 4 < 3 * v7)
  {
    if (v7 + ~v18 - *(_DWORD *)(a1 + 12) > v7 >> 3)
      goto LABEL_6;
  }
  else
  {
LABEL_23:
    v7 *= 2;
  }
  llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::grow(a1, v7);
  v6 = *(_QWORD *)a1;
  v7 = *(_DWORD *)(a1 + 16);
  v13 = *a2;
  v19 = v7 - 1;
  v20 = (37 * *a2) & (v7 - 1);
  v10 = (uint64_t *)(*(_QWORD *)a1 + 8 * v20);
  v21 = *v10;
  if (*a2 == *v10)
    goto LABEL_7;
  v22 = 0;
  v23 = 1;
  while (v21 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (v22)
      v24 = 0;
    else
      v24 = v21 == 0x8000000000000000;
    if (v24)
      v22 = v10;
    v25 = v20 + v23++;
    v20 = v25 & v19;
    v10 = (uint64_t *)(v6 + 8 * (v25 & v19));
    v21 = *v10;
    if (v13 == *v10)
      goto LABEL_7;
  }
  if (v22)
    v10 = v22;
LABEL_6:
  v13 = *v10;
LABEL_7:
  ++*(_DWORD *)(a1 + 8);
  if (v13 != 0x7FFFFFFFFFFFFFFFLL)
    --*(_DWORD *)(a1 + 12);
  *v10 = *a2;
  v12 = 1;
LABEL_10:
  *(_QWORD *)a3 = v10;
  *(_QWORD *)(a3 + 8) = v6 + 8 * v7;
  *(_BYTE *)(a3 + 16) = v12;
}

void llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::grow(uint64_t a1, int a2)
{
  uint64_t v3;
  llvm *v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unsigned int v8;
  char *buffer;
  char *v10;
  uint64_t v11;
  int v12;
  int v13;
  llvm *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  char *v20;
  int v21;
  BOOL v22;
  unsigned int v23;

  v3 = *(unsigned int *)(a1 + 16);
  v4 = *(llvm **)a1;
  v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40)
    v8 = v7 + 1;
  else
    v8 = 64;
  *(_DWORD *)(a1 + 16) = v8;
  buffer = (char *)llvm::allocate_buffer(8 * v8, (std::align_val_t)8uLL);
  v10 = buffer;
  *(_QWORD *)a1 = buffer;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = 0;
    v11 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v11)
      memset_pattern16(buffer, &unk_207AB7E40, 8 * v11);
    if ((_DWORD)v3)
    {
      v12 = 0;
      v13 = v11 - 1;
      v14 = v4;
      do
      {
        v17 = *(_QWORD *)v14;
        if ((unint64_t)(*(_QWORD *)v14 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
        {
          v18 = (37 * v17) & v13;
          v16 = &v10[8 * v18];
          v19 = *(_QWORD *)v16;
          if (v17 != *(_QWORD *)v16)
          {
            v20 = 0;
            v21 = 1;
            while (v19 != 0x7FFFFFFFFFFFFFFFLL)
            {
              if (v20)
                v22 = 0;
              else
                v22 = v19 == 0x8000000000000000;
              if (v22)
                v20 = v16;
              v23 = v18 + v21++;
              v18 = v23 & v13;
              v16 = &v10[8 * (v23 & v13)];
              v19 = *(_QWORD *)v16;
              if (v17 == *(_QWORD *)v16)
                goto LABEL_14;
            }
            if (v20)
              v16 = v20;
          }
LABEL_14:
          *(_QWORD *)v16 = v17;
          *(_DWORD *)(a1 + 8) = ++v12;
        }
        v14 = (llvm *)((char *)v14 + 8);
      }
      while (v14 != (llvm *)((char *)v4 + 8 * v3));
    }
    llvm::deallocate_buffer(v4, (void *)(8 * v3));
  }
  *(_QWORD *)(a1 + 8) = 0;
  v15 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v15)
    memset_pattern16(buffer, &unk_207AB7E40, 8 * v15);
}

void mlir::getReassociationIndicesForCollapse(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void **v20;
  int v21;
  uint64_t v22;
  void *v23;
  unint64_t v24;
  unsigned int v25;
  uint64_t v26;
  char *v28;
  unint64_t v29;
  void *v30;
  char *v31;
  uint64_t v32;
  char *v33;
  void *__src;
  uint64_t v36;
  _BYTE v37[16];
  void *v38;
  uint64_t v39;
  _BYTE v40[16];
  void *v41;
  uint64_t v42;
  _QWORD v43[6];

  v43[4] = *MEMORY[0x24BDAC8D0];
  if (a2 <= a4)
  {
    *(_BYTE *)a5 = 0;
    *(_BYTE *)(a5 + 48) = 0;
    return;
  }
  v41 = v43;
  v42 = 0x100000000;
  if (a4 >= 2)
    llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow((uint64_t)&v41, a4);
  LODWORD(v9) = 0;
  v38 = v40;
  v39 = 0x200000000;
  while (1)
  {
    v10 = v42;
    if (a4 == v42)
      break;
    v11 = *(_QWORD *)(a3 + 8 * v42);
    v12 = v9;
    if (a2 <= v9)
    {
      v15 = 1;
LABEL_19:
      v18 = *(_QWORD *)(a1 + 8 * v12);
      if (v18 != 0x8000000000000000)
      {
LABEL_24:
        if (v11 == 0x8000000000000000)
          goto LABEL_57;
        goto LABEL_25;
      }
    }
    else
    {
      v13 = 1;
      while (1)
      {
        v14 = *(_QWORD *)(a1 + 8 * v12);
        v15 = v14 * v13;
        if (v14 == 0x8000000000000000 || v15 >= v11)
          break;
        v17 = v39;
        if (v39 >= (unint64_t)HIDWORD(v39))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v40, v39 + 1, 8);
          v17 = v39;
        }
        v9 = (v9 + 1);
        *((_QWORD *)v38 + v17) = v12;
        LODWORD(v39) = v39 + 1;
        v12 = v9;
        v13 = v15;
        if (a2 <= v9)
          goto LABEL_19;
      }
      v15 = v13;
      v18 = *(_QWORD *)(a1 + 8 * v12);
      if (v18 != 0x8000000000000000)
        goto LABEL_24;
    }
    if (v11 != 0x8000000000000000 || v15 != 1)
      goto LABEL_57;
LABEL_25:
    if (v18 * v15 != v11)
      goto LABEL_57;
    v19 = v39;
    if (v39 >= (unint64_t)HIDWORD(v39))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v40, v39 + 1, 8);
      v19 = v39;
    }
    *((_QWORD *)v38 + v19) = v12;
    LODWORD(v39) = v39 + 1;
    __src = v37;
    v36 = 0x200000000;
    if (v42 >= HIDWORD(v42))
    {
      llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::growAndEmplaceBack<llvm::SmallVector<long long,2u>>((uint64_t)&v41, (uint64_t)&__src);
      v23 = __src;
      if (__src == v37)
        goto LABEL_5;
    }
    else
    {
      v20 = (void **)((char *)v41 + 32 * v42);
      *v20 = v20 + 2;
      v20[1] = (void *)0x200000000;
      if (v20 != &__src)
      {
        v21 = v36;
        if ((_DWORD)v36)
        {
          if (__src == v37)
          {
            v22 = v36;
            if (v36 < 3uLL
              || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v20, v20 + 2, v36, 8),
                  v22 = v36,
                  (_DWORD)v36))
            {
              memcpy(*v20, __src, 8 * v22);
            }
            *((_DWORD *)v20 + 2) = v21;
          }
          else
          {
            *v20 = __src;
            *((_DWORD *)v20 + 2) = v21;
            *((_DWORD *)v20 + 3) = HIDWORD(v36);
            __src = v37;
            HIDWORD(v36) = 0;
          }
          LODWORD(v36) = 0;
        }
      }
      LODWORD(v42) = v42 + 1;
      v23 = __src;
      if (__src == v37)
        goto LABEL_5;
    }
    free(v23);
LABEL_5:
    LODWORD(v9) = v9 + 1;
    llvm::SmallVectorImpl<long long>::swap((uint64_t)v41 + 32 * v42 - 32, (uint64_t)&v38);
    if (a2 <= v9)
    {
      v10 = v42;
      break;
    }
  }
  if (a4 != v10)
  {
LABEL_57:
    *(_BYTE *)a5 = 0;
    *(_BYTE *)(a5 + 48) = 0;
    v30 = v38;
    if (v38 == v40)
      goto LABEL_59;
    goto LABEL_58;
  }
  v24 = v9;
  if (a2 > v9)
  {
    v25 = v9 + 1;
    while (1)
    {
      v26 = *(_QWORD *)(a1 + 8 * v24);
      if (v26 != 0x8000000000000000 && v26 != 1)
        goto LABEL_57;
      if ((_DWORD)v42)
      {
        v28 = (char *)v41 + 32 * v42;
        v29 = *((unsigned int *)v28 - 6);
        if (v29 >= *((unsigned int *)v28 - 5))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v28 - 32), v28 - 16, v29 + 1, 8);
          v29 = *((unsigned int *)v28 - 6);
        }
        *(_QWORD *)(*((_QWORD *)v28 - 4) + 8 * v29) = v24;
        ++*((_DWORD *)v28 - 6);
      }
      v24 = v25++;
      if (a2 <= v24)
      {
        LODWORD(v10) = v42;
        break;
      }
    }
  }
  *(_QWORD *)a5 = a5 + 16;
  *(_QWORD *)(a5 + 8) = 0x100000000;
  if ((_DWORD)v10)
    llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=(a5, (uint64_t)&v41);
  *(_BYTE *)(a5 + 48) = 1;
  v30 = v38;
  if (v38 != v40)
LABEL_58:
    free(v30);
LABEL_59:
  v31 = (char *)v41;
  if ((_DWORD)v42)
  {
    v32 = 32 * v42;
    do
    {
      v33 = *(char **)&v31[v32 - 32];
      if (&v31[v32 - 16] != v33)
        free(v33);
      v32 -= 32;
    }
    while (v32);
    v31 = (char *)v41;
  }
  if (v31 != (char *)v43)
    free(v31);
}

void mlir::composeReassociationIndices(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned __int32 v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  int32x2_t v16;
  int32x2_t *v17;
  int32x2_t v18;
  int32x2_t v19;
  int32x2_t v20;
  int32x2_t v21;
  int32x2_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  const void *v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  void **v33;
  char *v34;
  unint64_t v35;
  int64_t v36;
  int v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  char *v41;
  void *v42;
  uint64_t v43;
  _BYTE v44[16];
  void *v45;
  uint64_t v46;
  _QWORD v47[5];

  v47[4] = *MEMORY[0x24BDAC8D0];
  v45 = v47;
  v46 = 0x100000000;
  if (a2 == a4)
    goto LABEL_45;
  if (a2 < a4)
    v6 = a2;
  else
    v6 = a4;
  if (a2 < a4)
    v7 = a1;
  else
    v7 = a3;
  if (a2 < a4)
    v8 = a3;
  else
    v8 = a1;
  if (a2 < a4)
    v9 = a4;
  else
    v9 = a2;
  if (!v6)
  {
    *(_QWORD *)a5 = a5 + 16;
    *(_QWORD *)(a5 + 8) = 0x100000000;
    *(_BYTE *)(a5 + 48) = 1;
    return;
  }
  v10 = (v6 - 1) & 0x7FFFFFFFFFFFFFFLL;
  if (v10 >= 4)
  {
    v13 = v10 + 1;
    v14 = v13 & 3;
    if ((v13 & 3) == 0)
      v14 = 4;
    v15 = v13 - v14;
    v12 = v7 + 32 * v15;
    v16 = 0;
    v17 = (int32x2_t *)(v7 + 72);
    v18 = 0;
    do
    {
      v19 = vzip1_s32(v17[-8], v17[-4]);
      v20 = v17[4];
      v21 = *v17;
      v17 += 16;
      v16 = vadd_s32(v19, v16);
      v18 = vadd_s32(vzip1_s32(v21, v20), v18);
      v15 -= 4;
    }
    while (v15);
    v22 = vadd_s32(v18, v16);
    v11 = vpadd_s32(v22, v22).u32[0];
  }
  else
  {
    v11 = 0;
    v12 = v7;
  }
  v23 = v7 + 32 * v6;
  do
  {
    v11 += *(_DWORD *)(v12 + 8);
    v12 += 32;
  }
  while (v12 != v23);
  if (v9 != v11)
  {
LABEL_45:
    *(_BYTE *)a5 = 0;
    *(_BYTE *)(a5 + 48) = 0;
    return;
  }
  do
  {
    v24 = *(_QWORD **)v7;
    v25 = *(unsigned int *)(v7 + 8);
    v42 = v44;
    v43 = 0x200000000;
    if ((_DWORD)v25)
    {
      v26 = 0;
      v27 = 8 * v25;
      do
      {
        v28 = v8 + 32 * *v24;
        v29 = *(const void **)v28;
        v30 = *(unsigned int *)(v28 + 8);
        v31 = v30 + v26;
        if (v31 > HIDWORD(v43))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v42, v44, v31, 8);
          v26 = v43;
        }
        if ((_DWORD)v30)
        {
          memcpy((char *)v42 + 8 * v26, v29, 8 * v30);
          v26 = v43;
        }
        v26 += v30;
        LODWORD(v43) = v26;
        ++v24;
        v27 -= 8;
      }
      while (v27);
    }
    v32 = (char *)v45;
    if (v46 >= HIDWORD(v46))
    {
      v35 = v46 + 1;
      if (v45 <= &v42 && (char *)v45 + 32 * v46 > (char *)&v42)
      {
        v36 = (char *)&v42 - (_BYTE *)v45;
        llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow((uint64_t)&v45, v35);
        v32 = (char *)v45;
        v33 = (void **)((char *)v45 + v36);
      }
      else
      {
        llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow((uint64_t)&v45, v35);
        v33 = &v42;
        v32 = (char *)v45;
      }
    }
    else
    {
      v33 = &v42;
    }
    v34 = &v32[32 * v46];
    *(_QWORD *)v34 = v34 + 16;
    *((_QWORD *)v34 + 1) = 0x200000000;
    if (*((_DWORD *)v33 + 2))
      llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v34, (uint64_t)v33);
    LODWORD(v46) = v46 + 1;
    if (v42 != v44)
      free(v42);
    v7 += 32;
  }
  while (v7 != v23);
  v37 = v46;
  *(_QWORD *)a5 = a5 + 16;
  *(_QWORD *)(a5 + 8) = 0x100000000;
  if (v37)
  {
    llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=(a5, (uint64_t)&v45);
    v38 = v46;
    *(_BYTE *)(a5 + 48) = 1;
    v39 = (char *)v45;
    if (!(_DWORD)v38)
      goto LABEL_55;
    v40 = 32 * v38;
    do
    {
      v41 = *(char **)&v39[v40 - 32];
      if (&v39[v40 - 16] != v41)
        free(v41);
      v40 -= 32;
    }
    while (v40);
  }
  else
  {
    *(_BYTE *)(a5 + 48) = 1;
  }
  v39 = (char *)v45;
LABEL_55:
  if (v39 != (char *)v47)
    free(v39);
}

void mlir::convertReassociationIndicesToExprs(mlir::MLIRContext *a1@<X0>, unsigned int **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unsigned int **v5;
  unsigned int **v7;
  unint64_t v8;
  unsigned int *v9;
  uint64_t v10;
  uint64_t AffineDimExpr;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  void **v15;
  _QWORD *v16;
  unint64_t v17;
  BOOL v18;
  char *v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[3];

  v22[2] = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a4 = a4 + 16;
  *(_QWORD *)(a4 + 8) = 0x200000000;
  if (a3)
  {
    v5 = a2;
    v7 = &a2[4 * a3];
    do
    {
      v20 = v22;
      v21 = 0x200000000;
      v8 = *((unsigned int *)v5 + 2);
      if (v8 >= 3)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v20, v22, v8, 8);
        v8 = *((unsigned int *)v5 + 2);
      }
      if (v8)
      {
        v9 = *v5;
        v10 = 8 * v8;
        do
        {
          AffineDimExpr = mlir::getAffineDimExpr((mlir *)*v9, a1, (mlir::MLIRContext *)v8);
          v12 = v21;
          if (v21 >= (unint64_t)HIDWORD(v21))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v20, v22, v21 + 1, 8);
            v12 = v21;
          }
          *((_QWORD *)v20 + v12) = AffineDimExpr;
          LODWORD(v21) = v21 + 1;
          v9 += 2;
          v10 -= 8;
        }
        while (v10);
      }
      v13 = *(unsigned int *)(a4 + 8);
      v14 = *(_QWORD *)a4;
      if (v13 >= *(_DWORD *)(a4 + 12))
      {
        v17 = v13 + 1;
        v18 = v14 + 32 * v13 > (unint64_t)&v20;
        if (v14 <= (unint64_t)&v20 && v18)
        {
          v19 = (char *)&v20 - v14;
          llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(a4, v17);
          v14 = *(_QWORD *)a4;
          v15 = (void **)&v19[*(_QWORD *)a4];
          goto LABEL_13;
        }
        llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(a4, v17);
        v14 = *(_QWORD *)a4;
      }
      v15 = &v20;
LABEL_13:
      v16 = (_QWORD *)(v14 + 32 * *(unsigned int *)(a4 + 8));
      *v16 = v16 + 2;
      v16[1] = 0x200000000;
      if (*((_DWORD *)v15 + 2))
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v16, (uint64_t)v15);
      ++*(_DWORD *)(a4 + 8);
      if (v20 != v22)
        free(v20);
      v5 += 4;
    }
    while (v5 != v7);
  }
}

uint64_t mlir::getReassociationIndicesAttribute(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  int v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t ArrayAttr;
  void *v14;
  uint64_t v15;
  _QWORD v16[5];

  v16[4] = *MEMORY[0x24BDAC8D0];
  v6 = 32 * a3;
  v14 = v16;
  v15 = 0x400000000;
  if ((unint64_t)(32 * a3) < 0x81)
  {
    v7 = 0;
    v9 = 0;
    v8 = v16;
    if (!a3)
      goto LABEL_8;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v14, v16, (32 * a3) >> 5, 8);
    v7 = v15;
    v8 = v14;
    v9 = v15;
    if (!a3)
      goto LABEL_8;
  }
  v10 = a2 + v6;
  v11 = &v8[v7];
  do
  {
    *v11++ = mlir::Builder::getI64ArrayAttr(a1, *(uint64_t **)a2, *(unsigned int *)(a2 + 8));
    a2 += 32;
  }
  while (a2 != v10);
  v9 = v15;
  v8 = v14;
LABEL_8:
  LODWORD(v15) = v9 + (v6 >> 5);
  ArrayAttr = mlir::Builder::getArrayAttr((mlir::MLIRContext **)a1, (uint64_t)v8, v15);
  if (v14 != v16)
    free(v14);
  return ArrayAttr;
}

void llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::push_back(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  void *v7;
  unsigned int v8;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v14;

  v4 = *(unsigned int *)(a1 + 8);
  v5 = *(_QWORD *)a1;
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    v11 = v4 + 1;
    v12 = v5 + 32 * v4;
    if (v5 <= a2 && v12 > a2)
    {
      v14 = a2 - v5;
      llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(a1, v11);
      v5 = *(_QWORD *)a1;
      a2 = *(_QWORD *)a1 + v14;
    }
    else
    {
      llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(a1, v11);
      v5 = *(_QWORD *)a1;
    }
  }
  v6 = (_QWORD *)(v5 + 32 * *(unsigned int *)(a1 + 8));
  v7 = v6 + 2;
  *v6 = v6 + 2;
  v6[1] = 0x200000000;
  v8 = *(_DWORD *)(a2 + 8);
  if (v6 != (_QWORD *)a2 && v8 != 0)
  {
    if (v8 < 3)
    {
      v10 = *(_DWORD *)(a2 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v6, v6 + 2, *(unsigned int *)(a2 + 8), 8);
      v10 = *(_DWORD *)(a2 + 8);
      if (!v10)
      {
LABEL_11:
        *((_DWORD *)v6 + 2) = v8;
        goto LABEL_12;
      }
      v7 = (void *)*v6;
    }
    memcpy(v7, *(const void **)a2, 8 * v10);
    goto LABEL_11;
  }
LABEL_12:
  ++*(_DWORD *)(a1 + 8);
}

void mlir::getSymbolLessAffineMaps(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t i;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  mlir::AffineExpr *v14;
  uint64_t v15;
  _QWORD *Context;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  _QWORD v21[3];
  _QWORD *v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v20 = 0;
  if (!a2)
  {
    *(_QWORD *)a3 = a3 + 16;
    *(_QWORD *)(a3 + 8) = 0x400000000;
    return;
  }
  v5 = a1;
  v6 = a1 + 32 * a2;
  v7 = a1;
  do
  {
    v8 = *(unsigned int *)(v7 + 8);
    if ((_DWORD)v8)
    {
      v9 = *(uint64_t **)v7;
      for (i = 8 * v8; i; i -= 8)
      {
        v19 = *v9;
        v21[0] = &unk_24C053F10;
        v21[1] = &v20;
        v22 = v21;
        mlir::AffineExpr::walk(&v19, v21);
        v11 = v22;
        if (v22 == v21)
        {
          v11 = v21;
          v12 = 4;
        }
        else
        {
          if (!v22)
            goto LABEL_8;
          v12 = 5;
        }
        (*(void (**)(void))(*v11 + 8 * v12))();
LABEL_8:
        ++v9;
      }
    }
    v7 += 32;
  }
  while (v7 != v6);
  v13 = v20 + 1;
  *(_QWORD *)a3 = a3 + 16;
  *(_QWORD *)(a3 + 8) = 0x400000000;
  if (a2 >= 5)
    llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), a2, 8);
  do
  {
    v14 = *(mlir::AffineExpr **)v5;
    v15 = *(unsigned int *)(v5 + 8);
    Context = (_QWORD *)mlir::AffineExpr::getContext(*(mlir::AffineExpr **)v5);
    v17 = mlir::AffineMap::get(v13, 0, (uint64_t)v14, v15, Context);
    v18 = *(unsigned int *)(a3 + 8);
    if (v18 >= *(unsigned int *)(a3 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v18 + 1, 8);
      v18 = *(unsigned int *)(a3 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a3 + 8 * v18) = v17;
    ++*(_DWORD *)(a3 + 8);
    v5 += 32;
  }
  while (v5 != v6);
}

uint64_t mlir::isReassociationValid(mlir::AffineMap *a1, uint64_t a2, _DWORD *a3)
{
  mlir::AffineMap *v5;
  int NumDims;
  int v7;
  int v8;
  mlir::AffineMap *v9;
  uint64_t Results;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  if (!a2)
    return 1;
  v5 = a1;
  NumDims = mlir::AffineMap::getNumDims(a1);
  v7 = 0;
  v8 = 0;
  v9 = (mlir::AffineMap *)((char *)v5 + 8 * a2);
  do
  {
    v17 = *(_QWORD *)v5;
    if (mlir::AffineMap::getNumDims((mlir::AffineMap *)&v17) != NumDims
      || mlir::AffineMap::getNumSymbols((mlir::AffineMap *)&v17))
    {
      goto LABEL_15;
    }
    Results = mlir::AffineMap::getResults((mlir::AffineMap *)&v17);
    if (v11)
    {
      v12 = (uint64_t *)Results;
      v13 = 8 * v11;
      while (1)
      {
        v14 = *v12;
        v18 = *v12;
        if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v18) == 6)
        {
          ZinMirValidateMirInfo::ZinMirValidateMirInfo(&v18, v14);
          v16 = v18;
          if (!v18)
            break;
        }
        else
        {
          ZinMirValidateMirInfo::ZinMirValidateMirInfo(&v18, 0);
          v16 = v18;
          if (!v18)
            break;
        }
        if (v7 != mlir::AffineDimExpr::getPosition((mlir::AffineDimExpr *)&v16))
          break;
        ++v7;
        ++v12;
        v13 -= 8;
        if (!v13)
          goto LABEL_3;
      }
LABEL_15:
      if (a3)
        *a3 = v8;
      return 0;
    }
LABEL_3:
    ++v8;
    v5 = (mlir::AffineMap *)((char *)v5 + 8);
  }
  while (v5 != v9);
  if (v7 == NumDims)
    return 1;
  result = 0;
  if (a3)
    *a3 = a2 - 1;
  return result;
}

uint64_t mlir::reshapeLikeShapesAreCompatible(uint64_t (*a1)(uint64_t, _QWORD **), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  uint64_t v12;
  unsigned int v13;
  uint64_t i;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  _QWORD *v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[4];
  __int16 v35;
  _QWORD v36[4];
  __int16 v37;
  _QWORD v38[4];
  __int16 v39;
  _QWORD v40[2];
  const char *v41;
  __int16 v42;
  _QWORD v43[2];
  const char *v44;
  __int16 v45;
  _QWORD *v46;
  const char *v47;
  __int16 v48;
  uint64_t v49;

  if (!a8)
    return 1;
  v12 = a7 + 32 * a8;
  if ((a9 & 1) != 0)
  {
    v13 = 0;
    for (i = 0; ; ++i)
    {
      v9 &= 0xFFFFFFFFFFFFFF00;
      v49 = 1;
      v15 = v13;
      v16 = *(unsigned int *)(a7 + 8);
      if ((_DWORD)v16)
      {
        v17 = 0;
        v18 = 0;
        v19 = 8 * v16;
        v20 = 1;
        v21 = a5 + 8 * v13;
        do
        {
          while (1)
          {
            v22 = *(_QWORD *)(v21 + 8 * v18);
            if (v22 == 0x8000000000000000)
              break;
            v20 *= v22;
            v49 = v20;
            ++v18;
            v19 -= 8;
            if (!v19)
              goto LABEL_10;
          }
          if (v17)
          {
            v33 = i;
            v34[0] = "invalid to have a single dimension (";
            v34[2] = &v33;
            v35 = 2819;
            v36[0] = v34;
            v36[2] = ") expanded into multiple dynamic dims (";
            v30 = 770;
            v37 = 770;
            v32 = v9 + v15;
            v38[0] = v36;
            v38[2] = &v32;
            v39 = 3586;
            v40[0] = v38;
            v41 = ",";
            v42 = 770;
            v31 = v15 + v18;
            v43[0] = v40;
            v44 = (const char *)&v31;
            v45 = 2818;
            v46 = v43;
            v47 = ")";
            goto LABEL_31;
          }
          v17 = 1;
          v9 = v18++;
          v19 -= 8;
        }
        while (v19);
LABEL_10:
        if (!v17)
          goto LABEL_14;
        if (*(_QWORD *)(a3 + 8 * i) != 0x8000000000000000)
          goto LABEL_28;
      }
      else
      {
        v20 = 1;
LABEL_14:
        if (*(_QWORD *)(a3 + 8 * i) != v20)
          goto LABEL_30;
      }
      v13 = v16 + v15;
      a7 += 32;
      if (a7 == v12)
        return 1;
    }
  }
  v24 = 0;
  for (i = 0; ; ++i)
  {
    v49 = 1;
    v25 = *(unsigned int *)(a7 + 8);
    v26 = 1;
    if (!(_DWORD)v25)
      break;
    v27 = 0;
    v28 = 8 * v25;
    v26 = 1;
    v29 = (_QWORD *)(a5 + 8 * v24);
    do
    {
      while (*v29 != 0x8000000000000000)
      {
        v26 *= *v29;
        v49 = v26;
        ++v29;
        v28 -= 8;
        if (!v28)
          goto LABEL_26;
      }
      v27 = 1;
      ++v29;
      v28 -= 8;
    }
    while (v28);
LABEL_26:
    if (!v27)
      break;
    if (*(_QWORD *)(a3 + 8 * i) != 0x8000000000000000)
    {
LABEL_28:
      v40[0] = i;
      v43[0] = "expected dimension ";
      v44 = (const char *)v40;
      v45 = 2819;
      v46 = v43;
      v47 = " of collapsed type to be dynamic since one or more of the corresponding dimensions in the expanded type is dynamic";
      v30 = 770;
      goto LABEL_31;
    }
LABEL_20:
    v24 += v25;
    a7 += 32;
    if (a7 == v12)
      return 1;
  }
  if (*(_QWORD *)(a3 + 8 * i) == v26)
    goto LABEL_20;
LABEL_30:
  v38[0] = i;
  v40[0] = "expected dimension ";
  v41 = (const char *)v38;
  v42 = 2819;
  v43[0] = v40;
  v44 = " of collapsed type to be static value of ";
  v45 = 770;
  v46 = v43;
  v47 = (const char *)&v49;
  v30 = 3586;
LABEL_31:
  v48 = v30;
  return a1(a2, &v46);
}

uint64_t mlir::hasNonIdentityLayout(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD v4[2];
  uint64_t v5;

  if (*(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
    v1 = a1;
  else
    v1 = 0;
  v5 = v1;
  if (!v1)
    return 0;
  v4[0] = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&v5);
  v4[1] = v2;
  return mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v4) ^ 1;
}

uint64_t llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  _DWORD *v10;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  char *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;

  if (a1 != a2)
  {
    v5 = a2 + 16;
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)a2 != a2 + 16)
    {
      v6 = *(char **)a1;
      v7 = *(unsigned int *)(a1 + 8);
      if ((_DWORD)v7)
      {
        v8 = 32 * v7;
        do
        {
          v9 = *(char **)&v6[v8 - 32];
          if (&v6[v8 - 16] != v9)
            free(v9);
          v8 -= 32;
        }
        while (v8);
        v6 = *(char **)a1;
      }
      if (v6 != (char *)(a1 + 16))
        free(v6);
      *(_QWORD *)a1 = *(_QWORD *)a2;
      v10 = (_DWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
LABEL_12:
      *v10 = 0;
      return a1;
    }
    v10 = (_DWORD *)(a2 + 8);
    v12 = *(unsigned int *)(a2 + 8);
    v13 = *(unsigned int *)(a1 + 8);
    if (v13 < v12)
    {
      if (*(_DWORD *)(a1 + 12) >= v12)
      {
        if (!(_DWORD)v13)
        {
          v13 = 0;
          v23 = *(_QWORD *)a2;
          v24 = *(unsigned int *)(a2 + 8);
          if (*(_DWORD *)(a2 + 8))
          {
LABEL_32:
            v25 = *(char **)a1;
            v26 = 32 * v13;
            v27 = 32 * v24;
            do
            {
              v28 = &v25[v26];
              *(_QWORD *)v28 = &v25[v26 + 16];
              *((_QWORD *)v28 + 1) = 0x200000000;
              if (*(_DWORD *)(v23 + v26 + 8))
                llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v28, v23 + v26);
              v25 += 32;
              v27 -= 32;
              v23 += 32;
            }
            while (v26 != v27);
            v23 = *(_QWORD *)a2;
          }
LABEL_37:
          *(_DWORD *)(a1 + 8) = v12;
          v29 = *v10;
          if ((_DWORD)v29)
          {
            v30 = 32 * v29;
            do
            {
              v31 = *(void **)(v23 + v30 - 32);
              if ((void *)(v23 + v30 - 16) != v31)
                free(v31);
              v30 -= 32;
            }
            while (v30);
          }
          goto LABEL_12;
        }
        v21 = *(_QWORD *)a1;
        v22 = 32 * v13;
        do
        {
          llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v21, v4);
          v4 += 32;
          v21 += 32;
          v22 -= 32;
        }
        while (v22);
      }
      else
      {
        if ((_DWORD)v13)
        {
          v14 = *(_QWORD *)a1;
          v15 = 32 * v13;
          do
          {
            v16 = *(void **)(v14 + v15 - 32);
            if ((void *)(v14 + v15 - 16) != v16)
              free(v16);
            v15 -= 32;
          }
          while (v15);
        }
        *(_DWORD *)(a1 + 8) = 0;
        llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(a1, v12);
        v13 = 0;
      }
      v23 = *(_QWORD *)a2;
      v24 = *(unsigned int *)(a2 + 8);
      if (v13 != v24)
        goto LABEL_32;
      goto LABEL_37;
    }
    v17 = *(_QWORD *)a1;
    if ((_DWORD)v12)
    {
      v18 = 0;
      do
      {
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v17 + v18, v4 + v18);
        v18 += 32;
      }
      while (32 * v12 != v18);
      v19 = v17 + v18;
      v20 = *(_QWORD *)a1 + 32 * *(unsigned int *)(a1 + 8);
      if (v20 == v17 + v18)
      {
LABEL_47:
        *(_DWORD *)(a1 + 8) = v12;
        v35 = *(unsigned int *)(a2 + 8);
        if ((_DWORD)v35)
        {
          v36 = *(_QWORD *)a2;
          v37 = 32 * v35;
          do
          {
            v38 = *(void **)(v36 + v37 - 32);
            if ((void *)(v36 + v37 - 16) != v38)
              free(v38);
            v37 -= 32;
          }
          while (v37);
        }
        goto LABEL_12;
      }
    }
    else
    {
      v19 = *(_QWORD *)a1;
      v20 = v17 + 32 * v13;
      if (v20 == v17)
        goto LABEL_47;
    }
    v32 = (char *)(v20 - 16);
    do
    {
      v34 = (char *)*((_QWORD *)v32 - 2);
      if (v32 != v34)
        free(v34);
      v33 = v32 - 16;
      v32 -= 32;
    }
    while (v33 != (char *)v19);
    goto LABEL_47;
  }
  return a1;
}

void llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(uint64_t a1, unint64_t a2)
{
  _DWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  int v13;
  unint64_t v14;

  v14 = 0;
  v3 = (_DWORD *)(a1 + 16);
  v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 32, &v14);
  v5 = v4;
  v6 = *(_DWORD **)a1;
  v7 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v7)
  {
    v8 = 32 * v7;
    v9 = v4;
    do
    {
      *v9 = v9 + 2;
      v9[1] = 0x200000000;
      if (v6[2])
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v9, (uint64_t)v6);
      v9 += 4;
      v6 += 8;
      v8 -= 32;
    }
    while (v8);
    v6 = *(_DWORD **)a1;
    v10 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v10)
    {
      v11 = 8 * v10;
      do
      {
        v12 = *(_DWORD **)&v6[v11 - 8];
        if (&v6[v11 - 4] != v12)
          free(v12);
        v11 -= 8;
      }
      while (v11 * 4);
      v6 = *(_DWORD **)a1;
    }
  }
  v13 = v14;
  if (v6 != v3)
    free(v6);
  *(_QWORD *)a1 = v5;
  *(_DWORD *)(a1 + 12) = v13;
}

uint64_t llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::growAndEmplaceBack<llvm::SmallVector<long long,2u>>(uint64_t a1, uint64_t a2)
{
  _DWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _DWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  int v14;
  uint64_t v15;
  unint64_t v17;

  v17 = 0;
  v4 = (_DWORD *)(a1 + 16);
  v5 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 32, &v17);
  v6 = &v5[4 * *(unsigned int *)(a1 + 8)];
  *v6 = v6 + 2;
  v6[1] = 0x200000000;
  if (*(_DWORD *)(a2 + 8))
    llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v6, a2);
  v7 = *(_DWORD **)a1;
  v8 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v8)
  {
    v9 = 32 * v8;
    v10 = v5;
    do
    {
      *v10 = v10 + 2;
      v10[1] = 0x200000000;
      if (v7[2])
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v10, (uint64_t)v7);
      v10 += 4;
      v7 += 8;
      v9 -= 32;
    }
    while (v9);
    v7 = *(_DWORD **)a1;
    v11 = *(unsigned int *)(a1 + 8);
    if ((_DWORD)v11)
    {
      v12 = 8 * v11;
      do
      {
        v13 = *(_DWORD **)&v7[v12 - 8];
        if (&v7[v12 - 4] != v13)
          free(v13);
        v12 -= 8;
      }
      while (v12 * 4);
      v7 = *(_DWORD **)a1;
    }
  }
  v14 = v17;
  if (v7 != v4)
    free(v7);
  *(_QWORD *)a1 = v5;
  v15 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v15;
  *(_DWORD *)(a1 + 12) = v14;
  return (uint64_t)&v5[4 * v15 - 4];
}

void llvm::SmallVectorImpl<long long>::swap(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  int v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  uint64_t v16;
  __int128 *v17;
  __int128 *v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  int v28;
  int v29;

  if (a1 != a2)
  {
    v4 = *(_QWORD *)a1;
    if (*(_QWORD *)a1 != a1 + 16 && *(_QWORD *)a2 != a2 + 16)
    {
      *(_QWORD *)a1 = *(_QWORD *)a2;
      *(_QWORD *)a2 = v4;
      v5 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 8) = v5;
      v6 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 12) = v6;
      return;
    }
    v7 = *(unsigned int *)(a2 + 8);
    if (*(_DWORD *)(a1 + 12) >= v7)
    {
      v8 = *(unsigned int *)(a1 + 8);
      if (*(_DWORD *)(a2 + 12) >= v8)
      {
LABEL_7:
        v9 = v8;
        v10 = *(unsigned int *)(a2 + 8);
        if (v8 >= v10)
          v11 = v10;
        else
          v11 = v8;
        if (!(_DWORD)v11)
          goto LABEL_30;
LABEL_17:
        v13 = *(_QWORD *)a1;
        v14 = *(_QWORD *)a2;
        if (v11 >= 4 && (v13 < v14 + 8 * v11 ? (v15 = v14 >= v13 + 8 * v11) : (v15 = 1), v15))
        {
          v16 = v11 & 0xFFFFFFFC;
          v17 = (__int128 *)(v13 + 16);
          v18 = (__int128 *)(v14 + 16);
          v19 = v16;
          do
          {
            v20 = *(v17 - 1);
            v21 = *v17;
            v22 = *v18;
            *(v17 - 1) = *(v18 - 1);
            *v17 = v22;
            *(v18 - 1) = v20;
            *v18 = v21;
            v17 += 2;
            v18 += 2;
            v19 -= 4;
          }
          while (v19);
          if (v16 == v11)
            goto LABEL_30;
        }
        else
        {
          v16 = 0;
        }
        v23 = v11 - v16;
        v24 = 8 * v16;
        v25 = (uint64_t *)(v13 + v24);
        v26 = (uint64_t *)(v14 + v24);
        do
        {
          v27 = *v25;
          *v25++ = *v26;
          *v26++ = v27;
          --v23;
        }
        while (v23);
LABEL_30:
        if (v10 >= v9)
        {
          if (v10 > v9)
          {
            v29 = v10 - v9;
            memcpy((void *)(*(_QWORD *)a1 + 8 * v9), (const void *)(*(_QWORD *)a2 + 8 * v11), *(_QWORD *)a2 + 8 * v10 - (*(_QWORD *)a2 + 8 * v11));
            *(_DWORD *)(a1 + 8) += v29;
            *(_DWORD *)(a2 + 8) = v11;
          }
        }
        else
        {
          v28 = v9 - v10;
          memcpy((void *)(*(_QWORD *)a2 + 8 * v10), (const void *)(*(_QWORD *)a1 + 8 * v11), *(_QWORD *)a1 + 8 * v9 - (*(_QWORD *)a1 + 8 * v11));
          *(_DWORD *)(a2 + 8) += v28;
          *(_DWORD *)(a1 + 8) = v11;
        }
        return;
      }
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v7, 8);
      v8 = *(unsigned int *)(a1 + 8);
      if (*(_DWORD *)(a2 + 12) >= v8)
        goto LABEL_7;
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v8, 8);
    v12 = *(_DWORD *)(a1 + 8);
    v9 = v12;
    v10 = *(unsigned int *)(a2 + 8);
    if (v12 >= v10)
      v11 = v10;
    else
      v11 = v12;
    if (!(_DWORD)v11)
      goto LABEL_30;
    goto LABEL_17;
  }
}

void std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::~__func()
{
  JUMPOUT(0x20BD002F8);
}

_QWORD *std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &unk_24C053F10;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &unk_24C053F10;
  a2[1] = v2;
  return result;
}

_QWORD *std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  _QWORD *result;
  int *v5;
  int v6;
  uint64_t v7;

  v3 = *a2;
  v7 = *a2;
  if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v7) == 6)
  {
    result = ZinMirValidateMirInfo::ZinMirValidateMirInfo(&v7, v3);
    if (!v7)
      return result;
  }
  else
  {
    result = ZinMirValidateMirInfo::ZinMirValidateMirInfo(&v7, 0);
    if (!v7)
      return result;
  }
  v5 = *(int **)(a1 + 8);
  result = (_QWORD *)mlir::AffineDimExpr::getPosition((mlir::AffineDimExpr *)&v7);
  v6 = *v5;
  if (*v5 <= result)
    v6 = (int)result;
  **(_DWORD **)(a1 + 8) = v6;
  return result;
}

uint64_t std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::target(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 8);
  if (v3 == 0x8000000207AB7EF5)
    return a1 + 8;
  if (((v3 & 0x8000000207AB7EF5 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x8000000207AB7EF5))
    return 0;
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x8000000207AB7EF5 & 0x7FFFFFFFFFFFFFFFLL)))
    return a1 + 8;
  return 0;
}

void *std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::target_type()
{
}

void mlir::clone(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t v13;
  mlir::ArrayAttr *v14;
  uint64_t Value;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  mlir::Region *v20;
  uint64_t v21;
  mlir::Region *v22;
  _QWORD v23[2];
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  llvm *v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31[2];
  _QWORD v32[40];

  v32[38] = *MEMORY[0x24BDAC8D0];
  v23[0] = 0;
  v23[1] = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v12 = *(_QWORD *)(a2 + 24);
  v13 = *(_QWORD *)(a2 + 48);
  if (*(_BYTE *)(a2 + 47))
  {
    v32[0] = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
    v14 = (mlir::ArrayAttr *)v32;
  }
  else
  {
    v14 = (mlir::ArrayAttr *)(a2 + 56);
  }
  Value = mlir::ArrayAttr::getValue(v14);
  v17 = v16;
  mlir::BlockRange::BlockRange(v31, 0, 0);
  mlir::OperationState::OperationState(v32, v12, v13, a5, a6, a3, a4, v18, Value, v17, v31[0], v31[1], 0, 0);
  v19 = *(unsigned int *)(a2 + 44);
  if ((v19 & 0x7FFFFF) != 0)
  {
    v20 = (mlir::Region *)(((a2 + 16 * ((v19 >> 23) & 1) + ((v19 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                         + 32 * *(unsigned int *)(a2 + 40));
    v21 = 24 * (v19 & 0x7FFFFF);
    do
    {
      v22 = (mlir::Region *)mlir::OperationState::addRegion((mlir::OperationState *)v32);
      mlir::Region::cloneInto(v20, v22, (mlir::IRMapping *)v23);
      v20 = (mlir::Region *)((char *)v20 + 24);
      v21 -= 24;
    }
    while (v21);
  }
  mlir::OpBuilder::create(a1, (const mlir::OperationState *)v32);
  mlir::OperationState::~OperationState((mlir::OperationState *)v32);
  llvm::deallocate_buffer(v28, (void *)(16 * v30));
}

void sub_207283DB8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, llvm *a19, uint64_t a20,unsigned int a21)
{
  llvm::deallocate_buffer(a19, (void *)(16 * a21));
}

void sub_207283DCC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, llvm *a16, uint64_t a17, unsigned int a18)
{
  llvm::deallocate_buffer(a16, (void *)(16 * a18));
}

uint64_t sub_207283DE0()
{
  uint64_t v0;

  return v0;
}

void mlir::getPrunedAttributeList(_BYTE *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  int8x16_t *v8;
  const unsigned __int8 *v9;
  uint64_t v10;
  __int128 *Value;
  uint64_t v12;
  __int128 v13;
  unint64_t v14;
  int8x16_t *AttrData;
  const unsigned __int8 *v16;
  int Key;
  uint64_t v18;
  llvm *v19;
  __int128 v21;
  uint64_t NumNeededNEs;
  __int128 v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;

  v24 = 0;
  v25 = 0;
  v26 = 0x800000000;
  if (a3)
  {
    v6 = a2;
    v7 = a2 + 16 * a3;
    do
    {
      v8 = *(int8x16_t **)v6;
      v9 = *(const unsigned __int8 **)(v6 + 8);
      v6 += 16;
      llvm::StringMap<std::nullopt_t,llvm::MallocAllocator>::try_emplace<>((uint64_t)&v24, v8, v9);
    }
    while (v6 != v7);
  }
  *(_QWORD *)a4 = a4 + 16;
  *(_QWORD *)(a4 + 8) = 0x300000000;
  if (a1[47])
  {
    *(_QWORD *)&v23 = mlir::Operation::getAttrDictionary((mlir::Operation *)a1);
    Value = (__int128 *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v23);
    if (!v10)
      goto LABEL_16;
  }
  else
  {
    Value = (__int128 *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)(a1 + 56));
    if (!v10)
      goto LABEL_16;
  }
  v12 = 16 * v10;
  do
  {
    v23 = *Value;
    NumNeededNEs = MirInfoChannelAssignment::GetNumNeededNEs((MirInfoChannelAssignment *)&v23);
    AttrData = (int8x16_t *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&NumNeededNEs);
    Key = llvm::StringMapImpl::FindKey((uint64_t *)&v24, AttrData, v16);
    if (Key == -1 || Key == (unint64_t)v25)
    {
      v13 = v23;
      v14 = *(unsigned int *)(a4 + 8);
      if (v14 >= *(unsigned int *)(a4 + 12))
      {
        v21 = v23;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v14 + 1, 16);
        v13 = v21;
        v14 = *(unsigned int *)(a4 + 8);
      }
      *(_OWORD *)(*(_QWORD *)a4 + 16 * v14) = v13;
      ++*(_DWORD *)(a4 + 8);
    }
    ++Value;
    v12 -= 16;
  }
  while (v12);
LABEL_16:
  if (HIDWORD(v25) && (_DWORD)v25)
  {
    v18 = 0;
    do
    {
      v19 = *(llvm **)((char *)v24 + v18);
      if (v19 != (llvm *)-8 && v19 != 0)
        llvm::deallocate_buffer(v19, (void *)(*(_QWORD *)v19 + 9));
      v18 += 8;
    }
    while (8 * v25 != v18);
  }
  free(v24);
}

void mlir::dispatchIndexOpFoldResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  unsigned int v12;

  v4 = a1 & 0xFFFFFFFFFFFFFFF8;
  if ((a1 & 4) != 0 && v4)
  {
    v6 = *(unsigned int *)(a2 + 8);
    if (v6 >= *(_DWORD *)(a2 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v6 + 1, 8);
      LODWORD(v6) = *(_DWORD *)(a2 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a2 + 8 * v6) = v4;
    ++*(_DWORD *)(a2 + 8);
    v7 = *(unsigned int *)(a3 + 8);
    if (v7 >= *(_DWORD *)(a3 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v7 + 1, 8);
      LODWORD(v7) = *(_DWORD *)(a3 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a3 + 8 * v7) = 0x8000000000000000;
    ++*(_DWORD *)(a3 + 8);
  }
  else
  {
    v10 = a1 & 0xFFFFFFFFFFFFFFF8;
    mlir::IntegerAttr::getValue(&v10, (llvm::APInt *)&v11);
    if (v12 > 0x40)
      v8 = *v11;
    else
      v8 = (uint64_t)((_QWORD)v11 << -(uint64_t)v12) >> -(uint64_t)v12;
    v9 = *(unsigned int *)(a3 + 8);
    if (v9 >= *(_DWORD *)(a3 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v9 + 1, 8);
      LODWORD(v9) = *(_DWORD *)(a3 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a3 + 8 * v9) = v8;
    ++*(_DWORD *)(a3 + 8);
    if (v12 >= 0x41 && v11)
      MEMORY[0x20BD002D4](v11, 0x1000C8000313F17);
  }
}

void mlir::dispatchIndexOpFoldResults(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;

  if (a2)
  {
    v7 = 8 * a2;
    do
    {
      v8 = *a1++;
      mlir::dispatchIndexOpFoldResult(v8, a3, a4);
      v7 -= 8;
    }
    while (v7);
  }
}

uint64_t mlir::getAsOpFoldResult(uint64_t a1)
{
  uint64_t DefiningOp;
  uint64_t v3;
  unint64_t v4;
  uint64_t v6;
  void *v7[2];
  _QWORD v8[2];

  v8[1] = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 0;
  v6 = a1;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v6);
  if (!DefiningOp)
    return a1 | 4;
  v3 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
    return a1 | 4;
  v7[0] = v8;
  v7[1] = (void *)0x100000000;
  mlir::Operation::fold(v3, 0, 0, (uint64_t)v7);
  v4 = *(_QWORD *)v7[0] & 0xFFFFFFFFFFFFFFF8;
  if (v7[0] != v8)
    free(v7[0]);
  if (!v4)
    return a1 | 4;
  return v4;
}

void mlir::getAsOpFoldResult(uint64_t a1@<X0>, unint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t DefiningOp;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  void *v20[2];
  _QWORD v21[2];

  v21[1] = *MEMORY[0x24BDAC8D0];
  *a3 = a3 + 2;
  a3[1] = 0x600000000;
  if (a2 < 7)
  {
    v18 = a1;
    v19 = xmmword_207AB7F70;
    if (!a2)
    {
      v16 = 0;
      goto LABEL_20;
    }
    v6 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a3, a3 + 2, a2, 8);
    v6 = *((unsigned int *)a3 + 2);
    v18 = a1;
    v19 = xmmword_207AB7F70;
  }
  v7 = 0;
  v8 = (unint64_t *)(*a3 + 8 * v6);
  do
  {
    v11 = mlir::ValueRange::dereference_iterator(&v18, v7);
    if (v11)
    {
      v12 = v11;
      v17 = v11;
      DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v17);
      if (!DefiningOp)
        goto LABEL_6;
      v14 = DefiningOp;
      if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
        goto LABEL_6;
      v20[0] = v21;
      v20[1] = (void *)0x100000000;
      mlir::Operation::fold(v14, 0, 0, (uint64_t)v20);
      v15 = *(_QWORD *)v20[0];
      if (v20[0] != v21)
        free(v20[0]);
      v9 = v15 & 0xFFFFFFFFFFFFFFF8;
      if ((v15 & 0xFFFFFFFFFFFFFFF8) == 0)
LABEL_6:
        v9 = v12 | 4;
    }
    else
    {
      v9 = 0;
    }
    *v8++ = v9;
    v7 = v19 + 1;
    *(_QWORD *)&v19 = v19 + 1;
  }
  while (v18 != a1 || v7 != a2);
  v16 = *((_DWORD *)a3 + 2);
LABEL_20:
  *((_DWORD *)a3 + 2) = v16 + a2;
}

unint64_t mlir::getConstantIntValue(uint64_t a1)
{
  unint64_t v1;
  uint64_t DefiningOp;
  uint64_t v3;
  unint64_t v4;
  void *v5;
  BOOL v6;
  BOOL v7;
  BOOL v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  void *v12;
  unint64_t v13;
  unint64_t *v15;
  unint64_t v16;
  unsigned int v17;
  char v18;
  unint64_t v19;
  void *v20;
  uint64_t v21;
  _QWORD v22[2];

  v22[1] = *MEMORY[0x24BDAC8D0];
  v1 = a1 & 0xFFFFFFFFFFFFFFF8;
  if ((a1 & 4) != 0 && v1)
  {
    v17 = 1;
    v18 = 0;
    v15 = &v16;
    v16 = 0;
    v19 = a1 & 0xFFFFFFFFFFFFFFF8;
    DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v19);
    if (!DefiningOp)
      goto LABEL_28;
    v3 = DefiningOp;
    if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
      goto LABEL_28;
    v20 = v22;
    v21 = 0x100000000;
    mlir::Operation::fold(v3, 0, 0, (uint64_t)&v20);
    v4 = *(_QWORD *)v20 & 0xFFFFFFFFFFFFFFF8;
    if (v20 != v22)
      free(v20);
    if (v4
      && ((v5 = *(void **)(*(_QWORD *)(*(_QWORD *)(v3 - 8) & 0xFFFFFFFFFFFFFFF8) + 136),
           v5 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
        ? (v6 = v5 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        : (v6 = 1),
          !v6 ? (v7 = v5 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) : (v7 = 1),
          !v7 ? (v8 = v5 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) : (v8 = 1),
          v8))
    {
      v9 = mlir::detail::constant_int_value_binder::match((uint64_t *)&v15, v4);
      v10 = v17;
      if (v9)
      {
        if (v17 > 0x40)
          v11 = *(_QWORD *)v16;
        else
          v11 = (uint64_t)(v16 << -(char)v17) >> -(char)v17;
        v13 = v11 & 0xFFFFFFFFFFFFFF00;
      }
      else
      {
        LOBYTE(v11) = 0;
        v13 = 0;
      }
    }
    else
    {
LABEL_28:
      LOBYTE(v11) = 0;
      v13 = 0;
      v10 = v17;
    }
    if (v10 >= 0x41 && v16)
      MEMORY[0x20BD002D4](v16, 0x1000C8000313F17);
  }
  else
  {
    if (!v1 || (a1 & 4) != 0)
      goto LABEL_27;
    v12 = *(void **)(*(_QWORD *)v1 + 136);
    if (v12 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      v1 = 0;
    v16 = v1;
    if (v12 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      mlir::IntegerAttr::getValue(&v16, (llvm::APInt *)&v20);
      if (v21 > 0x40)
      {
        v11 = *(_QWORD *)v20;
        MEMORY[0x20BD002D4]();
      }
      else
      {
        v11 = (uint64_t)((_QWORD)v20 << -(uint64_t)v21) >> -(uint64_t)v21;
      }
      v13 = v11 & 0xFFFFFFFFFFFFFF00;
    }
    else
    {
LABEL_27:
      LOBYTE(v11) = 0;
      v13 = 0;
    }
  }
  return v13 & 0xFFFFFFFFFFFFFF00 | v11;
}

BOOL mlir::isConstantIntValue(uint64_t a1, uint64_t a2)
{
  unint64_t ConstantIntValue;
  char v4;

  ConstantIntValue = mlir::getConstantIntValue(a1);
  return v4 && ConstantIntValue == a2;
}

uint64_t mlir::isEqualConstantIntOrValue(uint64_t a1, uint64_t a2)
{
  unint64_t ConstantIntValue;
  char v5;
  char v6;
  unint64_t v7;
  char v8;
  _BOOL4 v10;

  ConstantIntValue = mlir::getConstantIntValue(a1);
  v6 = v5;
  v7 = mlir::getConstantIntValue(a2);
  if (v6 && v8 && ConstantIntValue == v7)
    return 1;
  v10 = (a1 & 0xFFFFFFFFFFFFFFF8) != 0
     && (a1 & 0xFFFFFFFFFFFFFFF8) == (a2 & (a2 << 61 >> 63) & 0xFFFFFFFFFFFFFFF8);
  return (a1 & 4) != 0 && v10;
}

void mlir::getMixedValues(uint64_t *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, mlir::Builder *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v7;
  void *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  _QWORD v16[3];

  LODWORD(v7) = a2;
  v16[2] = *MEMORY[0x24BDAC8D0];
  v16[0] = a3;
  v16[1] = a4;
  v10 = (void *)(a6 + 16);
  *(_QWORD *)a6 = a6 + 16;
  *(_QWORD *)(a6 + 8) = 0x600000000;
  if (a2 >= 7)
    llvm::SmallVectorBase<unsigned int>::grow_pod(a6, v10, a2, 8);
  v7 = v7;
  if ((_DWORD)v7)
  {
    v11 = 0;
    do
    {
      v13 = *a1++;
      v12 = v13;
      if (v13 == 0x8000000000000000)
        v14 = mlir::ValueRange::dereference_iterator(v16, v11++) | 4;
      else
        v14 = mlir::Builder::getI64IntegerAttr(a5, v12) & 0xFFFFFFFFFFFFFFFBLL;
      v15 = *(unsigned int *)(a6 + 8);
      if (v15 >= *(unsigned int *)(a6 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a6, v10, v15 + 1, 8);
        v15 = *(unsigned int *)(a6 + 8);
      }
      *(_QWORD *)(*(_QWORD *)a6 + 8 * v15) = v14;
      ++*(_DWORD *)(a6 + 8);
      --v7;
    }
    while (v7);
  }
}

uint64_t mlir::constantTripCount(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t ConstantIntValue;
  char v6;
  unint64_t v7;
  unint64_t v8;
  char v9;
  unint64_t v10;
  int64_t v11;
  char v12;
  int64_t v13;
  int64_t v14;

  if (a1 == a2)
    return 0;
  ConstantIntValue = mlir::getConstantIntValue(a1);
  if (!v6)
    return 0;
  v7 = ConstantIntValue;
  v8 = mlir::getConstantIntValue(a2);
  if (!v9)
    return 0;
  v10 = v8;
  v11 = mlir::getConstantIntValue(a3);
  if (!v12)
    return 0;
  v13 = v10 - v7;
  if (v10 == v7 || (uint64_t)(v10 - v7) < 1 == v11 > 0)
    return v13 / v11;
  if (v11 <= 0)
    v14 = v13 + 1;
  else
    v14 = v13 - 1;
  return v14 / v11 + 1;
}

uint64_t mlir::foldDynamicIndexList(uint64_t a1, char a2)
{
  uint64_t v2;
  unint64_t *v3;
  char v4;
  uint64_t v5;
  uint64_t DefiningOp;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v14;
  void *v15;
  uint64_t v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x24BDAC8D0];
  v2 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v2)
  {
    v3 = *(unint64_t **)a1;
    v4 = 0;
    v5 = 8 * v2;
    if ((a2 & 1) != 0)
    {
      do
      {
        if ((*v3 & 4) != 0)
        {
          v14 = *v3 & 0xFFFFFFFFFFFFFFF8;
          DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v14);
          if (DefiningOp)
          {
            v7 = DefiningOp;
            if ((mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)) & 1) != 0)
            {
              v15 = v17;
              v16 = 0x100000000;
              mlir::Operation::fold(v7, 0, 0, (uint64_t)&v15);
              v8 = *(_QWORD *)v15;
              if (v15 != v17)
                free(v15);
              v9 = v8 & 0xFFFFFFFFFFFFFFF8;
              if (v9 && (mlir::getConstantIntValue(v9) & 0x8000000000000000) == 0)
              {
                *v3 = v9;
                v4 = 1;
              }
            }
          }
        }
        ++v3;
        v5 -= 8;
      }
      while (v5);
    }
    else
    {
      do
      {
        if ((*v3 & 4) != 0)
        {
          v14 = *v3 & 0xFFFFFFFFFFFFFFF8;
          v10 = mlir::Value::getDefiningOp((mlir::Value *)&v14);
          if (v10)
          {
            v11 = v10;
            if (mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(v10 + 48)))
            {
              v15 = v17;
              v16 = 0x100000000;
              mlir::Operation::fold(v11, 0, 0, (uint64_t)&v15);
              v12 = *(_QWORD *)v15;
              if (v15 != v17)
                free(v15);
              if ((v12 & 0xFFFFFFFFFFFFFFF8) != 0)
              {
                *v3 = v12 & 0xFFFFFFFFFFFFFFF8;
                v4 = 1;
              }
            }
          }
        }
        ++v3;
        v5 -= 8;
      }
      while (v5);
    }
  }
  else
  {
    v4 = 0;
  }
  return v4 & 1;
}

mlir::func::FuncDialect *mlir::func::FuncDialect::FuncDialect(mlir::func::FuncDialect *this, mlir::MLIRContext *a2)
{
  _QWORD *v3;

  v3 = (_QWORD *)mlir::Dialect::Dialect((uint64_t)this, (uint64_t)"func", 4, (uint64_t)a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::FuncDialect,void>::id);
  *v3 = off_24C051890;
  mlir::Dialect::addOperations<mlir::func::CallIndirectOp,mlir::func::CallOp,mlir::func::ConstantOp,mlir::func::FuncOp,mlir::func::ReturnOp>((uint64_t)v3);
  mlir::Dialect::declarePromisedInterface<mlir::func::FuncDialect,mlir::DialectInlinerInterface>((uint64_t)this);
  return this;
}

void mlir::func::FuncDialect::~FuncDialect(llvm **this)
{
  mlir::Dialect::~Dialect(this);
}

void sub_207284B48()
{
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::Dialect::addOperations<mlir::func::CallIndirectOp,mlir::func::CallOp,mlir::func::ConstantOp,mlir::func::FuncOp,mlir::func::ReturnOp>(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t result;
  _QWORD *v10;

  mlir::RegisteredOperationName::insert<mlir::func::CallIndirectOp>(a1);
  v2 = (_QWORD *)operator new();
  v10 = mlir::RegisteredOperationName::Model<mlir::func::CallOp>::Model(v2, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v10, (uint64_t)&mlir::func::CallOp::getAttributeNames(void)::attrNames, 1);
  v3 = (uint64_t)v10;
  v10 = 0;
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v4 = (_QWORD *)operator new();
  v10 = mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::Model(v4, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v10, (uint64_t)&mlir::func::ConstantOp::getAttributeNames(void)::attrNames, 1);
  v5 = (uint64_t)v10;
  v10 = 0;
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  v6 = (_QWORD *)operator new();
  v10 = mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::Model(v6, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v10, (uint64_t)&mlir::func::FuncOp::getAttributeNames(void)::attrNames, 5);
  v7 = (uint64_t)v10;
  v10 = 0;
  if (v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
  v8 = (_QWORD *)operator new();
  v10 = mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::Model(v8, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v10, 0, 0);
  result = (uint64_t)v10;
  v10 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t mlir::Dialect::declarePromisedInterface<mlir::func::FuncDialect,mlir::DialectInlinerInterface>(uint64_t a1)
{
  uint64_t *v1;
  unsigned __int8 v2;
  _QWORD *v3;
  unint64_t v4;
  uint64_t result;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;
  _QWORD *v16;

  v1 = (uint64_t *)(a1 + 72);
  v3 = &unk_25451A000;
  if ((v2 & 1) == 0)
  {
    v3 = (_QWORD *)&unk_25451A000;
    if (v6)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DialectInlinerInterface]";
      v15 = 79;
      v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v7)
        v8 = v7;
      else
        v8 = v15;
      v9 = &v14[v8];
      v10 = v15 - v8;
      if (v15 - v8 >= 0x12)
        v11 = 18;
      else
        v11 = v15 - v8;
      v12 = v10 - v11;
      if (v12 >= v12 - 1)
        v13 = v12 - 1;
      else
        v13 = v12;
      mlir::detail::TypeIDResolver<mlir::DialectInlinerInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      v3 = (_QWORD *)&unk_25451A000;
    }
  }
  v4 = v3[374];
  v14 = (const char *)&mlir::detail::TypeIDResolver<mlir::func::FuncDialect,void>::id;
  v15 = v4;
  v16 = 0;
  result = llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>,std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::LookupBucketFor<std::pair<mlir::TypeID,mlir::TypeID>>(v1, (uint64_t *)&v14, &v16);
  if ((result & 1) == 0)
  {
    result = (uint64_t)llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>,std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::InsertIntoBucketImpl<std::pair<mlir::TypeID,mlir::TypeID>>((uint64_t)v1, (uint64_t)&v14, (uint64_t *)&v14, v16);
    *(_QWORD *)result = v14;
    *(_QWORD *)(result + 8) = v15;
  }
  return result;
}

ZinIrHalH13g *mlir::func::FuncDialect::materializeConstant(uint64_t a1, mlir::OpBuilder *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;

  v12 = a4;
  if (*(_UNKNOWN **)(*(_QWORD *)a3 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
    v5 = a3;
  else
    v5 = 0;
  v13 = v5;
  if (!v5)
    return 0;
  mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v13);
  if (v10 || *(_UNKNOWN **)(*(_QWORD *)a4 + 136) != &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
    return 0;
  v13 = a3;
  return mlir::OpBuilder::create<mlir::func::ConstantOp,mlir::Type &,mlir::FlatSymbolRefAttr>(a2, a5, &v12, &v13);
}

ZinIrHalH13g *mlir::OpBuilder::create<mlir::func::ConstantOp,mlir::Type &,mlir::FlatSymbolRefAttr>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *Context;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  ZinIrHalH13g *v14;
  ZinIrHalH13g *v15;
  uint64_t v17;
  const char *v18;
  __int16 v19;
  uint64_t v20[4];
  __int16 v21;
  _QWORD v22[8];
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  _QWORD v26[29];

  v26[28] = *MEMORY[0x24BDAC8D0];
  v17 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
  v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"func.constant", (const unsigned __int8 *)0xD, Context);
  if (!v10)
  {
    v21 = 1283;
    v20[2] = (uint64_t)"func.constant";
    v20[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v19 = 259;
    llvm::operator+(v20, (uint64_t *)&v18, (uint64_t)v22);
    llvm::report_fatal_error((llvm::Twine *)v22, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v9);
  v11 = *a3;
  v12 = *a4;
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(v22) = v12;
  v13 = v24;
  if (v24 >= v25)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v23, v26, v24 + 1, 8);
    v13 = v24;
  }
  *(_QWORD *)(v23 + 8 * v13) = v11;
  ++v24;
  v14 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (*(_UNKNOWN **)(*((_QWORD *)v14 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::func::ConstantOp,void>::id)
    v15 = v14;
  else
    v15 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v15;
}

uint64_t mlir::func::CallOp::verifySymbolUses(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t InherentAttr;
  char v6;
  uint64_t v7;
  void *v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const void ***v23;
  const void ***v24;
  const void ***v25;
  __int128 v26;
  const void **AttrData;
  const char *v28;
  const void ***v29;
  const void ***v30;
  const void ***v31;
  __int128 v32;
  _QWORD *v33;
  _QWORD *v34;
  void *v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  int Kind;
  int v41;
  const char *v42;
  int v43;
  uint64_t v44;
  unint64_t v45;
  int NumResults;
  int v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  const char *v52;
  const void **v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t *Results;
  uint64_t v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  _QWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t Inputs;
  const void ***v65;
  const void ***v66;
  const void ***v67;
  __int128 v68;
  uint64_t v69;
  const void ***v70;
  const void ***v71;
  const void ***v72;
  __int128 v73;
  unint64_t v74;
  const void ***v75;
  const void ***v76;
  const void ***v77;
  __int128 v78;
  uint64_t v79;
  const void ***v80;
  const void ***v81;
  const void ***v82;
  __int128 v83;
  uint64_t v84;
  const void ***v85;
  const void ***v86;
  const void ***v87;
  __int128 v88;
  _QWORD *v89;
  _QWORD *v90;
  void *v91;
  _QWORD *v92;
  uint64_t v93;
  uint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unsigned int v100;
  unsigned int v101;
  uint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  _QWORD *v106;
  _QWORD *v107;
  void *v108;
  _QWORD *v109;
  uint64_t v110;
  uint64_t v111;
  unint64_t v113;
  unint64_t v114;
  BOOL v115;
  unint64_t v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  BOOL v120;
  int64_t v121;
  int64_t v122;
  int64_t v123;
  int64_t v124;
  int64_t v125;
  int64_t v126;
  int64_t v127;
  unsigned int v128;
  uint64_t Value;
  const void **v130;
  const char *v131;
  uint64_t v132;
  __int16 v133;
  uint64_t v134;
  const void **v135;
  const char *v136;
  uint64_t v137;
  __int16 v138;
  uint64_t v139;
  uint64_t v140[2];
  const void ***v141;
  unsigned int v142;
  unsigned int v143;
  _BYTE v144[96];
  _QWORD *v145;
  _QWORD *v146;
  _QWORD *v147;
  _QWORD *v148;
  char v149;
  uint64_t v150;

  v150 = *MEMORY[0x24BDAC8D0];
  v4 = *a1;
  if (*(_BYTE *)(*a1 + 47) && (InherentAttr = mlir::Operation::getInherentAttr(*a1, (uint64_t)"callee", 6), v6))
  {
    v7 = InherentAttr;
    if (!InherentAttr)
      goto LABEL_10;
  }
  else
  {
    v7 = mlir::DictionaryAttr::get(v4 + 56, "callee", 6uLL);
    if (!v7)
    {
LABEL_10:
      v134 = 0;
      goto LABEL_11;
    }
  }
  v8 = *(void **)(*(_QWORD *)v7 + 136);
  v9 = v8 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id;
  if (v8 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
    v10 = v7;
  else
    v10 = 0;
  v139 = v10;
  if (!v9)
    goto LABEL_10;
  mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v139);
  if (v20)
    v21 = 0;
  else
    v21 = v7;
  v134 = v21;
  if (!v21)
  {
LABEL_11:
    v135 = (const void **)"requires a 'callee' symbol reference attribute";
    v138 = 259;
    mlir::OpState::emitOpError((uint64_t **)a1, &v135, (uint64_t)&v139);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
    if (v139)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
    if (v149)
    {
      v12 = v147;
      if (v147)
      {
        v13 = v148;
        v14 = v147;
        if (v148 != v147)
        {
          do
            v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          v14 = v147;
        }
        v148 = v12;
        operator delete(v14);
      }
      v15 = v145;
      if (!v145)
        goto LABEL_147;
      v16 = v146;
      v17 = v145;
      if (v146 == v145)
      {
LABEL_146:
        v146 = v15;
        operator delete(v17);
LABEL_147:
        if (v141 != (const void ***)v144)
          free(v141);
        return v11;
      }
      do
      {
        v19 = *--v16;
        v18 = v19;
        *v16 = 0;
        if (v19)
          MEMORY[0x20BD002D4](v18, 0x1000C8077774924);
      }
      while (v16 != v15);
LABEL_145:
      v17 = v145;
      goto LABEL_146;
    }
    return v11;
  }
  v22 = mlir::SymbolTableCollection::lookupNearestSymbolFrom(a2, (mlir::SymbolTable *)*a1, v21);
  if (v22 && *(_UNKNOWN **)(*(_QWORD *)(v22 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id)
  {
    if (HIBYTE(*(_DWORD *)(v22 + 44)))
      v39 = v22 + 16 * (((unint64_t)*(unsigned int *)(v22 + 44) >> 23) & 1) + 64;
    else
      v39 = 0;
    v139 = *(_QWORD *)(v39 + 8);
    Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v139);
    Kind = mlir::AffineExpr::getKind((mlir::AffineExpr *)&Value);
    if ((*(_BYTE *)(*a1 + 46) & 0x80) != 0)
    {
      if (Kind == *(_DWORD *)(*a1 + 68))
        goto LABEL_57;
    }
    else if (!Kind)
    {
LABEL_57:
      v41 = mlir::AffineExpr::getKind((mlir::AffineExpr *)&Value);
      if (v41)
      {
        v42 = 0;
        v43 = v41;
        v44 = 24;
        while (1)
        {
          v45 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a1 + 72) + v44) + 8) & 0xFFFFFFFFFFFFFFF8;
          if (*(_QWORD *)(mlir::FunctionType::getInputs((mlir::FunctionType *)&Value) + 8 * (_QWORD)v42) != v45)
            break;
          ++v42;
          v44 += 32;
          if (v43 == (_DWORD)v42)
            goto LABEL_61;
        }
        v135 = (const void **)"operand type mismatch: expected operand type ";
        v138 = 259;
        mlir::OpState::emitOpError((uint64_t **)a1, &v135, (uint64_t)&v139);
        Inputs = mlir::FunctionType::getInputs((mlir::FunctionType *)&Value);
        if (v139)
        {
          v65 = &v130;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v130, *(_QWORD *)(Inputs + 8 * (_QWORD)v42));
          v66 = v141;
          if (v142 >= v143)
          {
            v113 = v142 + 1;
            if (v141 <= &v130 && &v141[3 * v142] > &v130)
            {
              v123 = (char *)&v130 - (char *)v141;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v113, 24);
              v66 = v141;
              v65 = (const void ***)((char *)v141 + v123);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v113, 24);
              v65 = &v130;
              v66 = v141;
            }
          }
          v67 = &v66[3 * v142];
          v68 = *(_OWORD *)v65;
          v67[2] = v65[2];
          *(_OWORD *)v67 = v68;
          v69 = ++v142;
          if (v139)
          {
            LODWORD(v130) = 3;
            v131 = ", but provided ";
            v132 = 15;
            v70 = &v130;
            v71 = v141;
            if (v69 >= v143)
            {
              v114 = v69 + 1;
              v115 = &v141[3 * v69] > &v130;
              if (v141 <= &v130 && v115)
              {
                v124 = (char *)&v130 - (char *)v141;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v114, 24);
                v71 = v141;
                v70 = (const void ***)((char *)v141 + v124);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v114, 24);
                v70 = &v130;
                v71 = v141;
              }
            }
            v72 = &v71[3 * v142];
            v73 = *(_OWORD *)v70;
            v72[2] = v70[2];
            *(_OWORD *)v72 = v73;
            ++v142;
            if (v139)
            {
              v74 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a1 + 72) + v44) + 8) & 0xFFFFFFFFFFFFFFF8;
              v75 = &v130;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v130, v74);
              v76 = v141;
              if (v142 >= v143)
              {
                v116 = v142 + 1;
                if (v141 <= &v130 && &v141[3 * v142] > &v130)
                {
                  v125 = (char *)&v130 - (char *)v141;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v116, 24);
                  v76 = v141;
                  v75 = (const void ***)((char *)v141 + v125);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v116, 24);
                  v75 = &v130;
                  v76 = v141;
                }
              }
              v77 = &v76[3 * v142];
              v78 = *(_OWORD *)v75;
              v77[2] = v75[2];
              *(_OWORD *)v77 = v78;
              v79 = ++v142;
              if (v139)
              {
                LODWORD(v130) = 3;
                v131 = " for operand number ";
                v132 = 20;
                v80 = &v130;
                v81 = v141;
                if (v79 >= v143)
                {
                  v117 = v79 + 1;
                  v118 = &v141[3 * v79] > &v130;
                  if (v141 <= &v130 && v118)
                  {
                    v126 = (char *)&v130 - (char *)v141;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v117, 24);
                    v81 = v141;
                    v80 = (const void ***)((char *)v141 + v126);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v117, 24);
                    v80 = &v130;
                    v81 = v141;
                  }
                }
                v82 = &v81[3 * v142];
                v83 = *(_OWORD *)v80;
                v82[2] = v80[2];
                *(_OWORD *)v82 = v83;
                v84 = ++v142;
                if (v139)
                {
                  LODWORD(v130) = 5;
                  v131 = v42;
                  v85 = &v130;
                  v86 = v141;
                  if (v84 >= v143)
                  {
                    v119 = v84 + 1;
                    v120 = &v141[3 * v84] > &v130;
                    if (v141 <= &v130 && v120)
                    {
                      v127 = (char *)&v130 - (char *)v141;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v119, 24);
                      v86 = v141;
                      v85 = (const void ***)((char *)v141 + v127);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v119, 24);
                      v85 = &v130;
                      v86 = v141;
                    }
                  }
                  v87 = &v86[3 * v142];
                  v88 = *(_OWORD *)v85;
                  v87[2] = v85[2];
                  *(_OWORD *)v87 = v88;
                  ++v142;
                }
              }
            }
          }
        }
        v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
        if (v139)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
        if (v149)
        {
          v89 = v147;
          if (v147)
          {
            v90 = v148;
            v91 = v147;
            if (v148 != v147)
            {
              do
                v90 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v90 - 1);
              while (v90 != v89);
              v91 = v147;
            }
            v148 = v89;
            operator delete(v91);
          }
          v15 = v145;
          if (!v145)
            goto LABEL_147;
          v92 = v146;
          v17 = v145;
          if (v146 == v145)
            goto LABEL_146;
          do
          {
            v94 = *--v92;
            v93 = v94;
            *v92 = 0;
            if (v94)
              MEMORY[0x20BD002D4](v93, 0x1000C8077774924);
          }
          while (v92 != v15);
          goto LABEL_145;
        }
        return v11;
      }
LABEL_61:
      if (mlir::FunctionType::getNumResults((mlir::FunctionType *)&Value) != *(_DWORD *)(*a1 + 36))
      {
        v135 = (const void **)"incorrect number of results for callee";
        v138 = 259;
        mlir::OpState::emitOpError((uint64_t **)a1, &v135, (uint64_t)&v139);
        v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
        if (v139)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
        if (v149)
        {
          v58 = v147;
          if (v147)
          {
            v59 = v148;
            v60 = v147;
            if (v148 != v147)
            {
              do
                v59 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v59 - 1);
              while (v59 != v58);
              v60 = v147;
            }
            v148 = v58;
            operator delete(v60);
          }
          v15 = v145;
          if (!v145)
            goto LABEL_147;
          v61 = v146;
          v17 = v145;
          if (v146 == v145)
            goto LABEL_146;
          do
          {
            v63 = *--v61;
            v62 = v63;
            *v61 = 0;
            if (v63)
              MEMORY[0x20BD002D4](v62, 0x1000C8077774924);
          }
          while (v61 != v15);
          goto LABEL_145;
        }
        return v11;
      }
      v128 = 0;
      NumResults = mlir::FunctionType::getNumResults((mlir::FunctionType *)&Value);
      if (NumResults)
      {
        v47 = NumResults;
        v48 = *(_QWORD *)(*a1 - 8) & 0xFFFFFFFFFFFFFFF8;
        if (*(_QWORD *)mlir::FunctionType::getResults((mlir::FunctionType *)&Value) != v48)
        {
LABEL_64:
          v130 = (const void **)"result type mismatch at index ";
          v133 = 259;
          mlir::OpState::emitOpError((uint64_t **)a1, &v130, (uint64_t)&v135);
          v49 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)&v135, &v128);
          mlir::InFlightDiagnostic::InFlightDiagnostic((uint64_t)&v139, v49);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v135);
          v50 = mlir::Diagnostic::attachNote(v140, 0, 0);
          v51 = mlir::Diagnostic::operator<<(v50, "      op result types: ");
          v52 = (const char *)*(unsigned int *)(*a1 + 36);
          v53 = (const void **)(*a1 - 16);
          if (!(_DWORD)v52)
            v53 = 0;
          v130 = v53;
          v131 = v52;
          mlir::OperandRange::getTypes((uint64_t *)&v130, (uint64_t *)&v135);
          mlir::Diagnostic::operator<<<mlir::ValueTypeRange<mlir::ResultRange>,mlir::Type>(v51, (uint64_t)&v135);
          v54 = mlir::Diagnostic::attachNote(v140, 0, 0);
          v55 = mlir::Diagnostic::operator<<(v54, "function result types: ");
          Results = (uint64_t *)mlir::FunctionType::getResults((mlir::FunctionType *)&Value);
          v135 = (const void **)", ";
          llvm::interleave<mlir::Type const*,mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<mlir::Type>>(llvm::ArrayRef<mlir::Type> const&,char const*)::{lambda(llvm::ArrayRef<mlir::Type> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<mlir::Type>>(llvm::ArrayRef<mlir::Type> const&,char const*)::{lambda(void)#1},void>(Results, &Results[v57], v55, v55, (const char **)&v135);
          v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v139);
          return v11;
        }
        v128 = 1;
        if (v47 != 1)
        {
          v95 = *(_QWORD *)(*a1 - 24) & 0xFFFFFFFFFFFFFFF8;
          if (*(_QWORD *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 8) != v95)
            goto LABEL_64;
          v128 = 2;
          if (v47 != 2)
          {
            v96 = *(_QWORD *)(*a1 - 40) & 0xFFFFFFFFFFFFFFF8;
            if (*(_QWORD *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 16) != v96)
              goto LABEL_64;
            v128 = 3;
            if (v47 != 3)
            {
              v97 = *(_QWORD *)(*a1 - 56) & 0xFFFFFFFFFFFFFFF8;
              if (*(_QWORD *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 24) != v97)
                goto LABEL_64;
              v128 = 4;
              if (v47 != 4)
              {
                v98 = *(_QWORD *)(*a1 - 72) & 0xFFFFFFFFFFFFFFF8;
                if (*(_QWORD *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 32) != v98)
                  goto LABEL_64;
                v128 = 5;
                if (v47 != 5)
                {
                  v99 = *(_QWORD *)(*a1 - 88) & 0xFFFFFFFFFFFFFFF8;
                  if (*(_QWORD *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 40) != v99)
                    goto LABEL_64;
                  v128 = 6;
                  if (v47 != 6)
                  {
                    v100 = 6;
                    while (1)
                    {
                      v101 = v100 + 1;
                      v102 = *a1 - 16 * (v100 + 1);
                      if (v100 > 5)
                        v102 = *a1 - 24 * (v100 - 5) - 96;
                      v103 = *(_QWORD *)(v102 + 8) & 0xFFFFFFFFFFFFFFF8;
                      if (*(_QWORD *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 8 * v100) != v103)
                        break;
                      v128 = ++v100;
                      if (v47 == v101)
                        return 1;
                    }
                    goto LABEL_64;
                  }
                }
              }
            }
          }
        }
      }
      return 1;
    }
    v135 = (const void **)"incorrect number of operands for callee";
    v138 = 259;
    mlir::OpState::emitOpError((uint64_t **)a1, &v135, (uint64_t)&v139);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
    if (v139)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
    if (v149)
    {
      v106 = v147;
      if (v147)
      {
        v107 = v148;
        v108 = v147;
        if (v148 != v147)
        {
          do
            v107 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v107 - 1);
          while (v107 != v106);
          v108 = v147;
        }
        v148 = v106;
        operator delete(v108);
      }
      v15 = v145;
      if (!v145)
        goto LABEL_147;
      v109 = v146;
      v17 = v145;
      if (v146 == v145)
        goto LABEL_146;
      do
      {
        v111 = *--v109;
        v110 = v111;
        *v109 = 0;
        if (v111)
          MEMORY[0x20BD002D4](v110, 0x1000C8077774924);
      }
      while (v109 != v15);
      goto LABEL_145;
    }
    return v11;
  }
  v133 = 257;
  mlir::OpState::emitOpError((uint64_t **)a1, &v130, (uint64_t)&v139);
  if (v139)
  {
    LODWORD(v135) = 3;
    v136 = "'";
    v137 = 1;
    v23 = &v135;
    v24 = v141;
    if (v142 >= v143)
    {
      v104 = v142 + 1;
      if (v141 <= &v135 && &v141[3 * v142] > &v135)
      {
        v121 = (char *)&v135 - (char *)v141;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v104, 24);
        v24 = v141;
        v23 = (const void ***)((char *)v141 + v121);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v104, 24);
        v23 = &v135;
        v24 = v141;
      }
    }
    v25 = &v24[3 * v142];
    v26 = *(_OWORD *)v23;
    v25[2] = v23[2];
    *(_OWORD *)v25 = v26;
    ++v142;
  }
  v135 = (const void **)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v134);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v135);
  if (v139)
  {
    v138 = 261;
    v135 = AttrData;
    v136 = v28;
    mlir::Diagnostic::operator<<((uint64_t)v140, &v135);
    if (v139)
    {
      LODWORD(v135) = 3;
      v136 = "' does not reference a valid function";
      v137 = 37;
      v29 = &v135;
      v30 = v141;
      if (v142 >= v143)
      {
        v105 = v142 + 1;
        if (v141 <= &v135 && &v141[3 * v142] > &v135)
        {
          v122 = (char *)&v135 - (char *)v141;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v105, 24);
          v30 = v141;
          v29 = (const void ***)((char *)v141 + v122);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v105, 24);
          v29 = &v135;
          v30 = v141;
        }
      }
      v31 = &v30[3 * v142];
      v32 = *(_OWORD *)v29;
      v31[2] = v29[2];
      *(_OWORD *)v31 = v32;
      ++v142;
    }
  }
  v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
  if (v139)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
  if (v149)
  {
    v33 = v147;
    if (v147)
    {
      v34 = v148;
      v35 = v147;
      if (v148 != v147)
      {
        do
          v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
        while (v34 != v33);
        v35 = v147;
      }
      v148 = v33;
      operator delete(v35);
    }
    v15 = v145;
    if (!v145)
      goto LABEL_147;
    v36 = v146;
    v17 = v145;
    if (v146 == v145)
      goto LABEL_146;
    do
    {
      v38 = *--v36;
      v37 = v38;
      *v36 = 0;
      if (v38)
        MEMORY[0x20BD002D4](v37, 0x1000C8077774924);
    }
    while (v36 != v15);
    goto LABEL_145;
  }
  return v11;
}

uint64_t mlir::func::FuncOp::getFunctionType(mlir::func::FuncOp *this)
{
  unint64_t v1;
  uint64_t v3;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  v3 = *(_QWORD *)(v1 + 8);
  return mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v3);
}

uint64_t mlir::InFlightDiagnostic::InFlightDiagnostic(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_BYTE *)(a1 + 8) = 0;
  v4 = (uint64_t *)(a2 + 8);
  *(_BYTE *)(a1 + 184) = 0;
  if (*(_BYTE *)(a2 + 184))
  {
    v5 = *v4;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    *(_QWORD *)(a1 + 8) = v5;
    *(_QWORD *)(a1 + 24) = a1 + 40;
    v6 = a1 + 24;
    *(_QWORD *)(a1 + 32) = 0x400000000;
    if (*(_DWORD *)(a2 + 32))
      llvm::SmallVectorImpl<mlir::DiagnosticArgument>::operator=(v6, a2 + 24);
    *(_QWORD *)(a1 + 136) = 0;
    *(_QWORD *)(a1 + 144) = 0;
    *(_QWORD *)(a1 + 152) = 0;
    *(_OWORD *)(a1 + 136) = *(_OWORD *)(a2 + 136);
    *(_QWORD *)(a1 + 152) = *(_QWORD *)(a2 + 152);
    *(_QWORD *)(a2 + 136) = 0;
    *(_QWORD *)(a2 + 144) = 0;
    *(_QWORD *)(a2 + 152) = 0;
    *(_QWORD *)(a1 + 160) = 0;
    *(_QWORD *)(a1 + 168) = 0;
    *(_QWORD *)(a1 + 176) = 0;
    *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
    *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 176);
    *(_QWORD *)(a2 + 160) = 0;
    *(_QWORD *)(a2 + 168) = 0;
    *(_QWORD *)(a2 + 176) = 0;
    *(_BYTE *)(a1 + 184) = 1;
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::reset[abi:nn180100]((uint64_t)v4);
  mlir::InFlightDiagnostic::abandon((_QWORD *)a2);
  return a1;
}

uint64_t mlir::Diagnostic::operator<<<mlir::ValueTypeRange<mlir::ResultRange>,mlir::Type>(uint64_t a1, uint64_t a2)
{
  const char *v4;

  v4 = ", ";
  llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,mlir::Diagnostic& mlir::Diagnostic::appendRange<mlir::ValueTypeRange<mlir::ResultRange>>(mlir::ValueTypeRange<mlir::ResultRange> const&,char const*)::{lambda(mlir::ValueTypeRange<mlir::ResultRange> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<mlir::ValueTypeRange<mlir::ResultRange>>(mlir::ValueTypeRange<mlir::ResultRange> const&,char const*)::{lambda(void)#1},void>(*(mlir::detail::OpResultImpl **)a2, *(_QWORD *)(a2 + 8), *(mlir::detail::OpResultImpl **)(a2 + 16), *(_QWORD *)(a2 + 24), a1, a1, &v4);
  return a1;
}

uint64_t mlir::func::CallIndirectOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t DefiningOp;
  uint64_t v6;
  BOOL v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  ZinIrHalH13g *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17[2];
  _QWORD v18[3];

  v18[2] = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 24);
  v14 = 0;
  v15 = v4;
  DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (!DefiningOp)
    return 0;
  v6 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((_QWORD *)(DefiningOp + 48)))
    return 0;
  v17[0] = v18;
  v17[1] = (void *)0x100000000;
  mlir::Operation::fold(v6, 0, 0, (uint64_t)v17);
  v7 = (*(_QWORD *)v17[0] & 0xFFFFFFFFFFFFFFF8) == 0
    || *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v17[0] & 0xFFFFFFFFFFFFFFF8) + 136) != (_QWORD)&mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id;
  if (!v7)
    v14 = *(_QWORD *)v17[0] & 0xFFFFFFFFFFFFFFF8;
  if (v17[0] != v18)
    free(v17[0]);
  if (v7)
    return 0;
  v9 = *(unsigned int *)(a1 + 36);
  v10 = a1 - 16;
  if (!(_DWORD)v9)
    v10 = 0;
  v15 = v10;
  v16 = v9;
  mlir::OperandRange::getTypes(&v15, (uint64_t *)v17);
  if ((*(_BYTE *)(a1 + 46) & 0x80) != 0)
  {
    v11 = *(_QWORD *)(a1 + 72);
    v12 = *(unsigned int *)(a1 + 68) - 1;
  }
  else
  {
    v11 = 0;
    v12 = -1;
  }
  v15 = v11 + 32;
  v16 = v12;
  v13 = mlir::OpBuilder::create<mlir::func::CallOp,mlir::SymbolRefAttr &,mlir::ValueTypeRange<mlir::ResultRange>,mlir::OperandRange>((mlir::OpBuilder *)(a2 + 8), *(_QWORD *)(a1 + 24), (uint64_t *)&v14, (uint64_t *)v17, (uint64_t)&v15);
  (*(void (**)(uint64_t, uint64_t, ZinIrHalH13g *))(*(_QWORD *)a2 + 32))(a2, a1, v13);
  return 1;
}

uint64_t mlir::func::ConstantOp::verify(uint64_t **this)
{
  const void **AttrData;
  const char *v3;
  const char *v4;
  uint64_t v5;
  unint64_t v6;
  mlir::Block *v7;
  uint64_t ParentOp;
  mlir::StringAttr *Context;
  uint64_t v10;
  uint64_t v11;
  const void ***v12;
  char *v13;
  char *v14;
  __int128 v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v37;
  unint64_t v38;
  int64_t v39;
  int64_t v40;
  const void **v41;
  __int16 v42;
  const void **v43;
  const char *v44;
  uint64_t v45;
  __int16 v46;
  uint64_t Value;
  const char *v48;
  void *v49;
  unsigned int v50;
  unsigned int v51;
  _BYTE v52[96];
  void *v53;
  _QWORD *v54;
  void *__p;
  _QWORD *v56;
  char v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v43 = (const void **)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v43);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&Value);
  v4 = v3;
  v5 = (uint64_t)*this;
  v6 = *(*this - 1) & 0xFFFFFFFFFFFFFFF8;
  while (1)
  {
    v7 = *(mlir::Block **)(v5 + 16);
    if (!v7)
      break;
    ParentOp = mlir::Block::getParentOp(v7);
    v5 = ParentOp;
    if (!ParentOp
      || *(_UNKNOWN **)(*(_QWORD *)(ParentOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ModuleOp,void>::id)
    {
      goto LABEL_7;
    }
  }
  v5 = 0;
LABEL_7:
  Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v5 + 24));
  LOWORD(v50) = 261;
  Value = (uint64_t)AttrData;
  v48 = v4;
  v10 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&Value);
  v11 = mlir::SymbolTable::lookupSymbolIn((unsigned int *)v5, v10);
  if (v11 && *(_UNKNOWN **)(*(_QWORD *)(v11 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id)
  {
    if (HIBYTE(*(_DWORD *)(v11 + 44)))
      v29 = v11 + 16 * (((unint64_t)*(unsigned int *)(v11 + 44) >> 23) & 1) + 64;
    else
      v29 = 0;
    Value = *(_QWORD *)(v29 + 8);
    if (mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value) == v6)
      return 1;
    v43 = (const void **)"reference to function with mismatched type";
    v46 = 259;
    mlir::OpState::emitOpError(this, &v43, (uint64_t)&Value);
    v20 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (v57)
    {
      v30 = __p;
      if (__p)
      {
        v31 = v56;
        v32 = __p;
        if (v56 != __p)
        {
          do
            v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
          while (v31 != v30);
          v32 = __p;
        }
        v56 = v30;
        operator delete(v32);
      }
      v24 = v53;
      if (!v53)
        goto LABEL_49;
      v33 = v54;
      v26 = v53;
      if (v54 == v53)
        goto LABEL_48;
      do
      {
        v35 = *--v33;
        v34 = v35;
        *v33 = 0;
        if (v35)
          MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
      }
      while (v33 != v24);
      goto LABEL_47;
    }
  }
  else
  {
    v42 = 257;
    mlir::OpState::emitOpError(this, &v41, (uint64_t)&Value);
    if (Value)
    {
      LODWORD(v43) = 3;
      v44 = "reference to undefined function '";
      v45 = 33;
      v12 = &v43;
      v13 = (char *)v49;
      if (v50 >= v51)
      {
        v37 = v50 + 1;
        if (v49 <= &v43 && (char *)v49 + 24 * v50 > (char *)&v43)
        {
          v39 = (char *)&v43 - (_BYTE *)v49;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v37, 24);
          v13 = (char *)v49;
          v12 = (const void ***)((char *)v49 + v39);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v37, 24);
          v12 = &v43;
          v13 = (char *)v49;
        }
      }
      v14 = &v13[24 * v50];
      v15 = *(_OWORD *)v12;
      *((_QWORD *)v14 + 2) = v12[2];
      *(_OWORD *)v14 = v15;
      ++v50;
      if (Value)
      {
        v46 = 261;
        v43 = AttrData;
        v44 = v4;
        mlir::Diagnostic::operator<<((uint64_t)&v48, &v43);
        if (Value)
        {
          LODWORD(v43) = 3;
          v44 = "'";
          v45 = 1;
          v16 = &v43;
          v17 = (char *)v49;
          if (v50 >= v51)
          {
            v38 = v50 + 1;
            if (v49 <= &v43 && (char *)v49 + 24 * v50 > (char *)&v43)
            {
              v40 = (char *)&v43 - (_BYTE *)v49;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v38, 24);
              v17 = (char *)v49;
              v16 = (const void ***)((char *)v49 + v40);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v38, 24);
              v16 = &v43;
              v17 = (char *)v49;
            }
          }
          v18 = &v17[24 * v50];
          v19 = *(_OWORD *)v16;
          *((_QWORD *)v18 + 2) = v16[2];
          *(_OWORD *)v18 = v19;
          ++v50;
        }
      }
    }
    v20 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (v57)
    {
      v21 = __p;
      if (__p)
      {
        v22 = v56;
        v23 = __p;
        if (v56 != __p)
        {
          do
            v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
          while (v22 != v21);
          v23 = __p;
        }
        v56 = v21;
        operator delete(v23);
      }
      v24 = v53;
      if (!v53)
        goto LABEL_49;
      v25 = v54;
      v26 = v53;
      if (v54 == v53)
      {
LABEL_48:
        v54 = v24;
        operator delete(v26);
LABEL_49:
        if (v49 != v52)
          free(v49);
        return v20;
      }
      do
      {
        v28 = *--v25;
        v27 = v28;
        *v25 = 0;
        if (v28)
          MEMORY[0x20BD002D4](v27, 0x1000C8077774924);
      }
      while (v25 != v24);
LABEL_47:
      v26 = v53;
      goto LABEL_48;
    }
  }
  return v20;
}

void mlir::func::FuncOp::build(mlir::StringAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7, uint64_t a8, uint64_t *a9, uint64_t a10)
{
  uint64_t StringAttr;
  mlir::StringAttr *Context;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  _QWORD v22[4];
  __int16 v23;
  const char *v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27[2];

  v23 = 261;
  v22[0] = a3;
  v22[1] = a4;
  StringAttr = mlir::Builder::getStringAttr(a1, (mlir::MLIRContext *)v22);
  Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  v26 = 261;
  v24 = "sym_name";
  v25 = 8;
  v17 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&v24);
  ZinMirCacheTensors::ZinMirCacheTensors(v27, v17, StringAttr);
  mlir::NamedAttrList::push_back(a2 + 112, v27[0], v27[1]);
  v18 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 96) + 8);
  v19 = mlir::TypeAttr::get(a5);
  ZinMirCacheTensors::ZinMirCacheTensors(&v24, v18, v19);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)v24, v25);
  *(_QWORD *)(a2 + 192) = 0;
  v20 = *(unsigned int *)(a2 + 120);
  v21 = v20 + ((16 * a7) >> 4);
  if (v21 > *(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), v21, 16);
    LODWORD(v20) = *(_DWORD *)(a2 + 120);
  }
  if (a7)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 112) + 16 * v20), a6, 16 * a7);
    LODWORD(v20) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v20 + a7;
  mlir::OperationState::addRegion((mlir::OperationState *)a2);
  if (a10)
    mlir::function_interface_impl::addArgAndResultAttrs(a1, a2, a9, a10, 0, 0, **(_QWORD **)(*(_QWORD *)(a2 + 8) + 96), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 96) + 16));
}

uint64_t mlir::func::FuncOp::parse(mlir::AsmParser *a1, uint64_t a2)
{
  char v3;

  return mlir::function_interface_impl::parseFunctionOp(a1, a2, 0, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 96) + 8), (uint64_t (*)(uint64_t, mlir::DictionaryAttr **, void *, _QWORD, void *, _QWORD, _QWORD, void **))llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::func::FuncOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v3, **(_QWORD **)(*(_QWORD *)(a2 + 8) + 96), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 96) + 16));
}

unint64_t mlir::func::FuncOp::getBody(mlir::func::FuncOp *this)
{
  unint64_t v1;

  v1 = *(unsigned int *)(*(_QWORD *)this + 44);
  if ((v1 & 0x7FFFFF) != 0)
    return ((*(_QWORD *)this + 16 * ((v1 >> 23) & 1) + ((v1 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
         + 32 * *(unsigned int *)(*(_QWORD *)this + 40);
  else
    return 0;
}

uint64_t mlir::func::ReturnOp::verify(uint64_t **this)
{
  mlir::Block *v2;
  unsigned int *ParentOp;
  unint64_t v4;
  uint64_t Results;
  const char *v6;
  uint64_t v7;
  const char *v8;
  uint64_t *v9;
  const char *v10;
  uint64_t v11;
  uint64_t i;
  uint64_t v13;
  mlir::Operation *v14;
  const void ***v15;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  const void ***v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t v24;
  const void ***v25;
  char *v26;
  char *v27;
  __int128 v28;
  unint64_t v29;
  const void ***v30;
  char *v31;
  char *v32;
  __int128 v33;
  uint64_t v34;
  const void ***v35;
  char *v36;
  char *v37;
  __int128 v38;
  uint64_t v39;
  const void ***v40;
  char *v41;
  char *v42;
  __int128 v43;
  uint64_t v44;
  const void ***v45;
  char *v46;
  char *v47;
  __int128 v48;
  uint64_t v49;
  const void ***v50;
  char *v51;
  char *v52;
  __int128 v53;
  const void **AttrData;
  const char *v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  uint64_t v62;
  uint64_t v63;
  mlir::Operation *v64;
  unsigned int v65;
  const void ***p_SymbolName;
  char *v67;
  char *v68;
  __int128 v69;
  uint64_t v70;
  const void ***v71;
  char *v72;
  char *v73;
  __int128 v74;
  const void **v75;
  const char *v76;
  const void ***v77;
  char *v78;
  char *v79;
  __int128 v80;
  uint64_t v81;
  const void ***v82;
  char *v83;
  char *v84;
  __int128 v85;
  _QWORD *v86;
  _QWORD *v87;
  void *v88;
  _QWORD *v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v93;
  unint64_t v94;
  BOOL v95;
  unint64_t v96;
  unint64_t v97;
  BOOL v98;
  unint64_t v99;
  unint64_t v100;
  BOOL v101;
  unint64_t v102;
  BOOL v103;
  unint64_t v104;
  unint64_t v105;
  BOOL v106;
  unint64_t v107;
  unint64_t v108;
  BOOL v109;
  unint64_t v110;
  BOOL v111;
  int64_t v112;
  int64_t v113;
  int64_t v114;
  int64_t v115;
  int64_t v116;
  int64_t v117;
  int64_t v118;
  int64_t v119;
  int64_t v120;
  int64_t v121;
  int64_t v122;
  int64_t v123;
  const void **v124[4];
  __int16 v125;
  const void **SymbolName;
  const char *v127;
  uint64_t v128;
  __int16 v129;
  uint64_t Value;
  _BYTE v131[16];
  void *v132;
  unsigned int v133;
  unsigned int v134;
  _BYTE v135[96];
  void *v136;
  _QWORD *v137;
  void *__p;
  _QWORD *v139;
  char v140;
  uint64_t v141;

  v141 = *MEMORY[0x24BDAC8D0];
  v2 = (mlir::Block *)(*this)[2];
  if (v2)
    ParentOp = (unsigned int *)mlir::Block::getParentOp(v2);
  else
    ParentOp = 0;
  if (HIBYTE(ParentOp[11]))
    v4 = (unint64_t)&ParentOp[4 * (((unint64_t)ParentOp[11] >> 23) & 1) + 16];
  else
    v4 = 0;
  Value = *(_QWORD *)(v4 + 8);
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value);
  Results = mlir::FunctionType::getResults((mlir::FunctionType *)&Value);
  v7 = Results;
  v8 = v6;
  v9 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    if (v6 == (const char *)*((unsigned int *)v9 + 17))
      goto LABEL_9;
  }
  else if (!v6)
  {
LABEL_9:
    if (!(_DWORD)v6)
      return 1;
    v10 = 0;
    v11 = v9[9];
    for (i = 24;
          *(_QWORD *)(Results + 8 * (_QWORD)v10) == (*(_QWORD *)(*(_QWORD *)(v11 + i) + 8) & 0xFFFFFFFFFFFFFFF8);
          i += 32)
    {
      if ((_DWORD)v6 == (_DWORD)++v10)
        return 1;
    }
    v125 = 257;
    mlir::OpState::emitError(this, (uint64_t)v124, (uint64_t)&Value);
    if (Value)
    {
      LODWORD(SymbolName) = 3;
      v127 = "type of return operand ";
      v128 = 23;
      v15 = &SymbolName;
      v16 = (char *)v132;
      if (v133 >= v134)
      {
        v99 = v133 + 1;
        if (v132 <= &SymbolName && (char *)v132 + 24 * v133 > (char *)&SymbolName)
        {
          v116 = (char *)&SymbolName - (_BYTE *)v132;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v99, 24);
          v16 = (char *)v132;
          v15 = (const void ***)((char *)v132 + v116);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v99, 24);
          v15 = &SymbolName;
          v16 = (char *)v132;
        }
      }
      v17 = &v16[24 * v133];
      v18 = *(_OWORD *)v15;
      *((_QWORD *)v17 + 2) = v15[2];
      *(_OWORD *)v17 = v18;
      v19 = ++v133;
      if (Value)
      {
        LODWORD(SymbolName) = 5;
        v127 = v10;
        v20 = &SymbolName;
        v21 = (char *)v132;
        if (v19 >= v134)
        {
          v100 = v19 + 1;
          v101 = (char *)v132 + 24 * v19 > (char *)&SymbolName;
          if (v132 <= &SymbolName && v101)
          {
            v117 = (char *)&SymbolName - (_BYTE *)v132;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v100, 24);
            v21 = (char *)v132;
            v20 = (const void ***)((char *)v132 + v117);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v100, 24);
            v20 = &SymbolName;
            v21 = (char *)v132;
          }
        }
        v22 = &v21[24 * v133];
        v23 = *(_OWORD *)v20;
        *((_QWORD *)v22 + 2) = v20[2];
        *(_OWORD *)v22 = v23;
        v24 = ++v133;
        if (Value)
        {
          LODWORD(SymbolName) = 3;
          v127 = " (";
          v128 = 2;
          v25 = &SymbolName;
          v26 = (char *)v132;
          if (v24 >= v134)
          {
            v102 = v24 + 1;
            v103 = (char *)v132 + 24 * v24 > (char *)&SymbolName;
            if (v132 <= &SymbolName && v103)
            {
              v118 = (char *)&SymbolName - (_BYTE *)v132;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v102, 24);
              v26 = (char *)v132;
              v25 = (const void ***)((char *)v132 + v118);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v102, 24);
              v25 = &SymbolName;
              v26 = (char *)v132;
            }
          }
          v27 = &v26[24 * v133];
          v28 = *(_OWORD *)v25;
          *((_QWORD *)v27 + 2) = v25[2];
          *(_OWORD *)v27 = v28;
          ++v133;
          if (Value)
          {
            v29 = *(_QWORD *)(*(_QWORD *)((*this)[9] + i) + 8) & 0xFFFFFFFFFFFFFFF8;
            v30 = &SymbolName;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&SymbolName, v29);
            v31 = (char *)v132;
            if (v133 >= v134)
            {
              v104 = v133 + 1;
              if (v132 <= &SymbolName && (char *)v132 + 24 * v133 > (char *)&SymbolName)
              {
                v119 = (char *)&SymbolName - (_BYTE *)v132;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v104, 24);
                v31 = (char *)v132;
                v30 = (const void ***)((char *)v132 + v119);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v104, 24);
                v30 = &SymbolName;
                v31 = (char *)v132;
              }
            }
            v32 = &v31[24 * v133];
            v33 = *(_OWORD *)v30;
            *((_QWORD *)v32 + 2) = v30[2];
            *(_OWORD *)v32 = v33;
            v34 = ++v133;
            if (Value)
            {
              LODWORD(SymbolName) = 3;
              v127 = ") doesn't match function result type (";
              v128 = 38;
              v35 = &SymbolName;
              v36 = (char *)v132;
              if (v34 >= v134)
              {
                v105 = v34 + 1;
                v106 = (char *)v132 + 24 * v34 > (char *)&SymbolName;
                if (v132 <= &SymbolName && v106)
                {
                  v120 = (char *)&SymbolName - (_BYTE *)v132;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v105, 24);
                  v36 = (char *)v132;
                  v35 = (const void ***)((char *)v132 + v120);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v105, 24);
                  v35 = &SymbolName;
                  v36 = (char *)v132;
                }
              }
              v37 = &v36[24 * v133];
              v38 = *(_OWORD *)v35;
              *((_QWORD *)v37 + 2) = v35[2];
              *(_OWORD *)v37 = v38;
              ++v133;
              if (Value)
              {
                v39 = *(_QWORD *)(v7 + 8 * (_QWORD)v10);
                v40 = &SymbolName;
                mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&SymbolName, v39);
                v41 = (char *)v132;
                if (v133 >= v134)
                {
                  v107 = v133 + 1;
                  if (v132 <= &SymbolName && (char *)v132 + 24 * v133 > (char *)&SymbolName)
                  {
                    v121 = (char *)&SymbolName - (_BYTE *)v132;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v107, 24);
                    v41 = (char *)v132;
                    v40 = (const void ***)((char *)v132 + v121);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v107, 24);
                    v40 = &SymbolName;
                    v41 = (char *)v132;
                  }
                }
                v42 = &v41[24 * v133];
                v43 = *(_OWORD *)v40;
                *((_QWORD *)v42 + 2) = v40[2];
                *(_OWORD *)v42 = v43;
                v44 = ++v133;
                if (Value)
                {
                  LODWORD(SymbolName) = 3;
                  v127 = ")";
                  v128 = 1;
                  v45 = &SymbolName;
                  v46 = (char *)v132;
                  if (v44 >= v134)
                  {
                    v108 = v44 + 1;
                    v109 = (char *)v132 + 24 * v44 > (char *)&SymbolName;
                    if (v132 <= &SymbolName && v109)
                    {
                      v122 = (char *)&SymbolName - (_BYTE *)v132;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v108, 24);
                      v46 = (char *)v132;
                      v45 = (const void ***)((char *)v132 + v122);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v108, 24);
                      v45 = &SymbolName;
                      v46 = (char *)v132;
                    }
                  }
                  v47 = &v46[24 * v133];
                  v48 = *(_OWORD *)v45;
                  *((_QWORD *)v47 + 2) = v45[2];
                  *(_OWORD *)v47 = v48;
                  v49 = ++v133;
                  if (Value)
                  {
                    LODWORD(SymbolName) = 3;
                    v127 = " in function @";
                    v128 = 14;
                    v50 = &SymbolName;
                    v51 = (char *)v132;
                    if (v49 >= v134)
                    {
                      v110 = v49 + 1;
                      v111 = (char *)v132 + 24 * v49 > (char *)&SymbolName;
                      if (v132 <= &SymbolName && v111)
                      {
                        v123 = (char *)&SymbolName - (_BYTE *)v132;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v110, 24);
                        v51 = (char *)v132;
                        v50 = (const void ***)((char *)v132 + v123);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v110, 24);
                        v50 = &SymbolName;
                        v51 = (char *)v132;
                      }
                    }
                    v52 = &v51[24 * v133];
                    v53 = *(_OWORD *)v50;
                    *((_QWORD *)v52 + 2) = v50[2];
                    *(_OWORD *)v52 = v53;
                    ++v133;
                  }
                }
              }
            }
          }
        }
      }
    }
    SymbolName = (const void **)mlir::SymbolTable::getSymbolName((mlir::SymbolTable *)ParentOp, v14);
    AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&SymbolName);
    if (Value)
    {
      v129 = 261;
      SymbolName = AttrData;
      v127 = v55;
      mlir::Diagnostic::operator<<((uint64_t)v131, &SymbolName);
    }
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (v140)
    {
      v56 = __p;
      if (__p)
      {
        v57 = v139;
        v58 = __p;
        if (v139 != __p)
        {
          do
            v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
          while (v57 != v56);
          v58 = __p;
        }
        v139 = v56;
        operator delete(v58);
      }
      v59 = v136;
      if (!v136)
        goto LABEL_76;
      v60 = v137;
      v61 = v136;
      if (v137 == v136)
      {
LABEL_75:
        v137 = v59;
        operator delete(v61);
LABEL_76:
        if (v132 != v135)
          free(v132);
        return v13;
      }
      do
      {
        v63 = *--v60;
        v62 = v63;
        *v60 = 0;
        if (v63)
          MEMORY[0x20BD002D4](v62, 0x1000C8077774924);
      }
      while (v60 != v59);
LABEL_74:
      v61 = v136;
      goto LABEL_75;
    }
    return v13;
  }
  v124[0] = (const void **)"has ";
  v125 = 259;
  mlir::OpState::emitOpError(this, v124, (uint64_t)&Value);
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v65 = *((_DWORD *)*this + 17);
    if (!Value)
      goto LABEL_54;
  }
  else
  {
    v65 = 0;
    if (!Value)
      goto LABEL_54;
  }
  LODWORD(SymbolName) = 5;
  v127 = (const char *)v65;
  p_SymbolName = &SymbolName;
  v67 = (char *)v132;
  if (v133 >= v134)
  {
    v93 = v133 + 1;
    if (v132 <= &SymbolName && (char *)v132 + 24 * v133 > (char *)&SymbolName)
    {
      v112 = (char *)&SymbolName - (_BYTE *)v132;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v93, 24);
      v67 = (char *)v132;
      p_SymbolName = (const void ***)((char *)v132 + v112);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v93, 24);
      p_SymbolName = &SymbolName;
      v67 = (char *)v132;
    }
  }
  v68 = &v67[24 * v133];
  v69 = *(_OWORD *)p_SymbolName;
  *((_QWORD *)v68 + 2) = p_SymbolName[2];
  *(_OWORD *)v68 = v69;
  v70 = ++v133;
  if (Value)
  {
    LODWORD(SymbolName) = 3;
    v127 = " operands, but enclosing function (@";
    v128 = 36;
    v71 = &SymbolName;
    v72 = (char *)v132;
    if (v70 >= v134)
    {
      v94 = v70 + 1;
      v95 = (char *)v132 + 24 * v70 > (char *)&SymbolName;
      if (v132 <= &SymbolName && v95)
      {
        v113 = (char *)&SymbolName - (_BYTE *)v132;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v94, 24);
        v72 = (char *)v132;
        v71 = (const void ***)((char *)v132 + v113);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v94, 24);
        v71 = &SymbolName;
        v72 = (char *)v132;
      }
    }
    v73 = &v72[24 * v133];
    v74 = *(_OWORD *)v71;
    *((_QWORD *)v73 + 2) = v71[2];
    *(_OWORD *)v73 = v74;
    ++v133;
  }
LABEL_54:
  SymbolName = (const void **)mlir::SymbolTable::getSymbolName((mlir::SymbolTable *)ParentOp, v64);
  v75 = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&SymbolName);
  if (Value)
  {
    v129 = 261;
    SymbolName = v75;
    v127 = v76;
    mlir::Diagnostic::operator<<((uint64_t)v131, &SymbolName);
    if (Value)
    {
      LODWORD(SymbolName) = 3;
      v127 = ") returns ";
      v128 = 10;
      v77 = &SymbolName;
      v78 = (char *)v132;
      if (v133 >= v134)
      {
        v96 = v133 + 1;
        if (v132 <= &SymbolName && (char *)v132 + 24 * v133 > (char *)&SymbolName)
        {
          v114 = (char *)&SymbolName - (_BYTE *)v132;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v96, 24);
          v78 = (char *)v132;
          v77 = (const void ***)((char *)v132 + v114);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v96, 24);
          v77 = &SymbolName;
          v78 = (char *)v132;
        }
      }
      v79 = &v78[24 * v133];
      v80 = *(_OWORD *)v77;
      *((_QWORD *)v79 + 2) = v77[2];
      *(_OWORD *)v79 = v80;
      v81 = ++v133;
      if (Value)
      {
        LODWORD(SymbolName) = 5;
        v127 = v8;
        v82 = &SymbolName;
        v83 = (char *)v132;
        if (v81 >= v134)
        {
          v97 = v81 + 1;
          v98 = (char *)v132 + 24 * v81 > (char *)&SymbolName;
          if (v132 <= &SymbolName && v98)
          {
            v115 = (char *)&SymbolName - (_BYTE *)v132;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v97, 24);
            v83 = (char *)v132;
            v82 = (const void ***)((char *)v132 + v115);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v97, 24);
            v82 = &SymbolName;
            v83 = (char *)v132;
          }
        }
        v84 = &v83[24 * v133];
        v85 = *(_OWORD *)v82;
        *((_QWORD *)v84 + 2) = v82[2];
        *(_OWORD *)v84 = v85;
        ++v133;
      }
    }
  }
  v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  if (v140)
  {
    v86 = __p;
    if (__p)
    {
      v87 = v139;
      v88 = __p;
      if (v139 != __p)
      {
        do
          v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
        while (v87 != v86);
        v88 = __p;
      }
      v139 = v86;
      operator delete(v88);
    }
    v59 = v136;
    if (!v136)
      goto LABEL_76;
    v89 = v137;
    v61 = v136;
    if (v137 == v136)
      goto LABEL_75;
    do
    {
      v91 = *--v89;
      v90 = v91;
      *v89 = 0;
      if (v91)
        MEMORY[0x20BD002D4](v90, 0x1000C8077774924);
    }
    while (v89 != v59);
    goto LABEL_74;
  }
  return v13;
}

uint64_t mlir::func::CallIndirectOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  unint64_t *v4;
  char *v5;
  char *v6;
  __int128 v7;
  uint64_t v8;
  unint64_t *v9;
  char *v10;
  char *v11;
  __int128 v12;
  uint64_t v13;
  unint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  unint64_t *v18;
  char *v19;
  char *v20;
  __int128 v21;
  char v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t i;
  _QWORD *Inputs;
  _BYTE *v36;
  _BYTE *v37;
  uint64_t *v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  _QWORD *Results;
  _BYTE *v44;
  _BYTE *v45;
  uint64_t v46;
  const void **v47;
  uint64_t v48;
  mlir::detail::OpResultImpl *v49;
  uint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  void *v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  void *v62;
  _QWORD *v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v67;
  unint64_t v68;
  BOOL v69;
  unint64_t v70;
  BOOL v71;
  unint64_t v72;
  int64_t v73;
  int64_t v74;
  int64_t v75;
  int64_t v76;
  const void **v77;
  uint64_t v78;
  __int16 v79;
  unint64_t v80;
  const char *v81;
  uint64_t v82;
  mlir::detail::OpResultImpl *v83;
  uint64_t v84;
  void *v85;
  unsigned int v86;
  unsigned int v87;
  _BYTE v88[96];
  void *v89;
  _QWORD *v90;
  void *__p;
  _QWORD *v92;
  char v93;
  uint64_t v94;

  v94 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v3 = *(_QWORD *)(*(_QWORD *)(v2[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(_QWORD *)v3 + 136) != &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
  {
    v79 = 261;
    v77 = (const void **)"operand";
    v78 = 7;
    mlir::Operation::emitOpError(v2, &v77, (uint64_t)&v83);
    if (v83)
    {
      LODWORD(v80) = 3;
      v81 = " #";
      v82 = 2;
      v4 = &v80;
      v5 = (char *)v85;
      if (v86 >= v87)
      {
        v67 = v86 + 1;
        if (v85 <= &v80 && (char *)v85 + 24 * v86 > (char *)&v80)
        {
          v73 = (char *)&v80 - (_BYTE *)v85;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v67, 24);
          v5 = (char *)v85;
          v4 = (unint64_t *)((char *)v85 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v67, 24);
          v4 = &v80;
          v5 = (char *)v85;
        }
      }
      v6 = &v5[24 * v86];
      v7 = *(_OWORD *)v4;
      *((_QWORD *)v6 + 2) = v4[2];
      *(_OWORD *)v6 = v7;
      v8 = ++v86;
      if (v83)
      {
        LODWORD(v80) = 5;
        v81 = 0;
        v9 = &v80;
        v10 = (char *)v85;
        if (v8 >= v87)
        {
          v68 = v8 + 1;
          v69 = (char *)v85 + 24 * v8 > (char *)&v80;
          if (v85 <= &v80 && v69)
          {
            v74 = (char *)&v80 - (_BYTE *)v85;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v68, 24);
            v10 = (char *)v85;
            v9 = (unint64_t *)((char *)v85 + v74);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v68, 24);
            v9 = &v80;
            v10 = (char *)v85;
          }
        }
        v11 = &v10[24 * v86];
        v12 = *(_OWORD *)v9;
        *((_QWORD *)v11 + 2) = v9[2];
        *(_OWORD *)v11 = v12;
        v13 = ++v86;
        if (v83)
        {
          LODWORD(v80) = 3;
          v81 = " must be function type, but got ";
          v82 = 32;
          v14 = &v80;
          v15 = (char *)v85;
          if (v13 >= v87)
          {
            v70 = v13 + 1;
            v71 = (char *)v85 + 24 * v13 > (char *)&v80;
            if (v85 <= &v80 && v71)
            {
              v75 = (char *)&v80 - (_BYTE *)v85;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v70, 24);
              v15 = (char *)v85;
              v14 = (unint64_t *)((char *)v85 + v75);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v70, 24);
              v14 = &v80;
              v15 = (char *)v85;
            }
          }
          v16 = &v15[24 * v86];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = v14[2];
          *(_OWORD *)v16 = v17;
          ++v86;
          if (v83)
          {
            v18 = &v80;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v80, v3);
            v19 = (char *)v85;
            if (v86 >= v87)
            {
              v72 = v86 + 1;
              if (v85 <= &v80 && (char *)v85 + 24 * v86 > (char *)&v80)
              {
                v76 = (char *)&v80 - (_BYTE *)v85;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v72, 24);
                v19 = (char *)v85;
                v18 = (unint64_t *)((char *)v85 + v76);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v72, 24);
                v18 = &v80;
                v19 = (char *)v85;
              }
            }
            v20 = &v19[24 * v86];
            v21 = *(_OWORD *)v18;
            *((_QWORD *)v20 + 2) = v18[2];
            *(_OWORD *)v20 = v21;
            ++v86;
          }
        }
      }
    }
    v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v83);
    if (v83)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v83);
    if (v93)
    {
      v23 = __p;
      if (__p)
      {
        v24 = v92;
        v25 = __p;
        if (v92 != __p)
        {
          do
            v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
          while (v24 != v23);
          v25 = __p;
        }
        v92 = v23;
        operator delete(v25);
      }
      v26 = v89;
      if (v89)
      {
        v27 = v90;
        v28 = v89;
        if (v90 != v89)
        {
          do
          {
            v30 = *--v27;
            v29 = v30;
            *v27 = 0;
            if (v30)
              MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
          }
          while (v27 != v26);
          v28 = v89;
        }
        v90 = v26;
        operator delete(v28);
      }
      if (v85 != v88)
        free(v85);
    }
    if (!v22)
      return 0;
  }
  v31 = *this;
  v32 = *((unsigned int *)*this + 9);
  if (*((_DWORD *)*this + 9))
    v33 = (uint64_t)(*this - 2);
  else
    v33 = 0;
  if ((_DWORD)v32)
  {
    for (i = 0; i != v32; ++i)
      mlir::detail::OpResultImpl::getNextResultAtOffset(v33, i);
    v31 = *this;
  }
  v80 = *(_QWORD *)(*(_QWORD *)(v31[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  Inputs = (_QWORD *)mlir::FunctionType::getInputs((mlir::FunctionType *)&v80);
  v37 = v36;
  v38 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v39 = *((_DWORD *)v38 + 17);
    v40 = v38[9];
  }
  else
  {
    v39 = 0;
    v40 = 0;
  }
  v77 = (const void **)(v40 + 32);
  v78 = v39 - 1;
  mlir::OperandRange::getTypes((uint64_t *)&v77, (uint64_t *)&v83);
  if (v37 != (char *)v85 - v84)
  {
LABEL_52:
    v77 = (const void **)"failed to verify that callee input types match argument types";
    v79 = 259;
    mlir::OpState::emitOpError(this, &v77, (uint64_t)&v83);
    v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v83);
    if (v83)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v83);
    if (v93)
    {
      v52 = __p;
      if (__p)
      {
        v53 = v92;
        v54 = __p;
        if (v92 != __p)
        {
          do
            v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
          while (v53 != v52);
          v54 = __p;
        }
        v92 = v52;
        operator delete(v54);
      }
      v55 = v89;
      if (!v89)
        goto LABEL_83;
      v56 = v90;
      v57 = v89;
      if (v90 == v89)
        goto LABEL_82;
      do
      {
        v59 = *--v56;
        v58 = v59;
        *v56 = 0;
        if (v59)
          MEMORY[0x20BD002D4](v58, 0x1000C8077774924);
      }
      while (v56 != v55);
      goto LABEL_81;
    }
    return v51;
  }
  if (v37)
  {
    v41 = 8 * (_QWORD)v37;
    v42 = (char *)v83 + 32 * v84 + 24;
    while (*Inputs == (*(_QWORD *)(*(_QWORD *)v42 + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      ++Inputs;
      v42 += 32;
      v41 -= 8;
      if (!v41)
        goto LABEL_44;
    }
    goto LABEL_52;
  }
LABEL_44:
  v80 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  Results = (_QWORD *)mlir::FunctionType::getResults((mlir::FunctionType *)&v80);
  v45 = v44;
  v46 = *((unsigned int *)*this + 9);
  v47 = (const void **)(*this - 2);
  if (!(_DWORD)v46)
    v47 = 0;
  v77 = v47;
  v78 = v46;
  mlir::OperandRange::getTypes((uint64_t *)&v77, (uint64_t *)&v83);
  v48 = v84;
  if (v45 == (char *)v85 - v84)
  {
    if (!v45)
      return 1;
    v49 = v83;
    v50 = 8 * (_QWORD)v45;
    while (*Results == (*(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v49, v48) + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      ++Results;
      ++v48;
      v50 -= 8;
      if (!v50)
        return 1;
    }
  }
  v77 = (const void **)"failed to verify that callee result types match result types";
  v79 = 259;
  mlir::OpState::emitOpError(this, &v77, (uint64_t)&v83);
  v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v83);
  if (v83)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v83);
  if (v93)
  {
    v60 = __p;
    if (__p)
    {
      v61 = v92;
      v62 = __p;
      if (v92 != __p)
      {
        do
          v61 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v61 - 1);
        while (v61 != v60);
        v62 = __p;
      }
      v92 = v60;
      operator delete(v62);
    }
    v55 = v89;
    if (!v89)
      goto LABEL_83;
    v63 = v90;
    v57 = v89;
    if (v90 == v89)
    {
LABEL_82:
      v90 = v55;
      operator delete(v57);
LABEL_83:
      if (v85 != v88)
        free(v85);
      return v51;
    }
    do
    {
      v65 = *--v63;
      v64 = v65;
      *v63 = 0;
      if (v65)
        MEMORY[0x20BD002D4](v64, 0x1000C8077774924);
    }
    while (v63 != v55);
LABEL_81:
    v57 = v89;
    goto LABEL_82;
  }
  return v51;
}

uint64_t mlir::func::CallIndirectOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *Results;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v15[4];
  __int16 v16;
  uint64_t v17;
  _QWORD v18[2];
  uint64_t v19[2];
  _QWORD v20[24];
  uint64_t v21;
  void *v22[2];
  _BYTE v23[128];
  _QWORD v24[5];

  v24[4] = *MEMORY[0x24BDAC8D0];
  memset(v24, 0, 24);
  v19[0] = (uint64_t)v24;
  v19[1] = 1;
  v21 = 0;
  v22[0] = v23;
  v22[1] = (void *)0x400000000;
  v18[0] = &v21;
  v18[1] = 1;
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *, uint64_t))(*(_QWORD *)a1 + 672))(a1, v24, 1))
    goto LABEL_12;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 264))(a1))
    goto LABEL_12;
  v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void **, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, v22, 0, 1, 0xFFFFFFFFLL))goto LABEL_12;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 280))(a1))
    goto LABEL_12;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    goto LABEL_12;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1))
    goto LABEL_12;
  v20[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::FunctionType>(a1, v20))
    goto LABEL_12;
  v21 = v20[0];
  v17 = v20[0];
  if (*(_UNKNOWN **)(*(_QWORD *)v20[0] + 136) != &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
  {
    v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v16 = 257;
    (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v20, a1, v6, v15);
    v7 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v20, "'callee' must be function type, but got ");
    v8 = mlir::InFlightDiagnostic::append<mlir::Type &>(v7, &v17);
    v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v8);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v20);
    goto LABEL_13;
  }
  Results = (void *)mlir::FunctionType::getResults((mlir::FunctionType *)v20);
  mlir::OperationState::addTypes(a2, Results, v11);
  v12 = a2 + 16;
  if (mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v19, v18, v4, v12))
  {
    v15[0] = *(_QWORD *)v18[0];
    v20[0] = mlir::FunctionType::getInputs((mlir::FunctionType *)v15);
    v20[1] = v13;
    v9 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,3u> &,llvm::ArrayRef<mlir::Type>>(a1, (uint64_t *)v22, v20, v5, v12) != 0;
  }
  else
  {
LABEL_12:
    v9 = 0;
  }
LABEL_13:
  if (v22[0] != v23)
    free(v22[0]);
  return v9;
}

void mlir::func::CallIndirectOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _BYTE *v7;
  mlir::Operation *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  llvm::raw_ostream *v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  mlir::Operation *v16;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v19;
  llvm::raw_ostream *v20;
  _BYTE *v21;
  llvm::raw_ostream *v22;
  _BYTE *v23;
  llvm::raw_ostream *v24;
  _BYTE *v25;
  unint64_t AttrDictionary;
  void *v27;
  uint64_t v28;
  _QWORD v29[5];

  v29[4] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 160))(a2, *(_QWORD *)(*((_QWORD *)*this + 9) + 24));
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v7 = (_BYTE *)*((_QWORD *)v6 + 4);
  if (*((_BYTE **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, "(", 1uLL);
    v8 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
      goto LABEL_6;
  }
  else
  {
    *v7 = 40;
    ++*((_QWORD *)v6 + 4);
    v8 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
    {
LABEL_6:
      v9 = *((unsigned int *)v8 + 17);
      v10 = *((_QWORD *)v8 + 9);
      v11 = v9 - 1;
      goto LABEL_7;
    }
  }
  v10 = 0;
  v11 = -1;
LABEL_7:
  v12 = v10 + 32;
  v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v27 = ", ";
  v28 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v12, 0, v12, v11, (uint64_t)a2, v13, (uint64_t)&v27);
  v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)v14 + 4);
  if (*((_BYTE **)v14 + 3) == v15)
  {
    llvm::raw_ostream::write(v14, ")", 1uLL);
  }
  else
  {
    *v15 = 41;
    ++*((_QWORD *)v14 + 4);
  }
  v27 = v29;
  v28 = 0x200000000;
  v16 = *this;
  if (*((_BYTE *)*this + 47))
  {
    AttrDictionary = mlir::Operation::getAttrDictionary(v16);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::Operation *)((char *)v16 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v19, v27, v28);
  v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v21 = (_BYTE *)*((_QWORD *)v20 + 4);
  if ((unint64_t)v21 >= *((_QWORD *)v20 + 3))
  {
    llvm::raw_ostream::write(v20, 32);
  }
  else
  {
    *((_QWORD *)v20 + 4) = v21 + 1;
    *v21 = 32;
  }
  v22 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v23 = (_BYTE *)*((_QWORD *)v22 + 4);
  if (*((_BYTE **)v22 + 3) == v23)
  {
    llvm::raw_ostream::write(v22, ":", 1uLL);
  }
  else
  {
    *v23 = 58;
    ++*((_QWORD *)v22 + 4);
  }
  v24 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v25 = (_BYTE *)*((_QWORD *)v24 + 4);
  if ((unint64_t)v25 >= *((_QWORD *)v24 + 3))
  {
    llvm::raw_ostream::write(v24, 32);
  }
  else
  {
    *((_QWORD *)v24 + 4) = v25 + 1;
    *v25 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(*(_QWORD *)(*((_QWORD *)*this + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v27 != v29)
    free(v27);
}

uint64_t mlir::func::CallOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  int *v40;
  char *v41;
  char *v42;
  __int128 v43;
  _QWORD *v44;
  _QWORD *v45;
  void *v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  int64_t v55;
  int64_t v56;
  int64_t v57;
  int64_t v58;
  uint64_t v59;
  int v60;
  const char *v61;
  uint64_t v62;
  _QWORD v63[3];
  void *v64;
  unsigned int v65;
  unsigned int v66;
  _BYTE v67[96];
  void *v68;
  _QWORD *v69;
  void *__p;
  _QWORD *v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v59 = v6;
  if (!v6)
  {
    a3(v63, a4);
    if (v63[0])
    {
      v60 = 3;
      v61 = "expected DictionaryAttr to set properties";
      v62 = 41;
      v30 = &v60;
      v31 = (char *)v64;
      if (v65 >= v66)
      {
        v51 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          v55 = (char *)&v60 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
          v31 = (char *)v64;
          v30 = (int *)((char *)v64 + v55);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
          v30 = &v60;
          v31 = (char *)v64;
        }
      }
      v32 = &v31[24 * v65];
      v33 = *(_OWORD *)v30;
      *((_QWORD *)v32 + 2) = *((_QWORD *)v30 + 2);
      *(_OWORD *)v32 = v33;
      ++v65;
      if (v63[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
    }
    if (!v72)
      return 0;
    v34 = __p;
    if (__p)
    {
      v35 = v71;
      v36 = __p;
      if (v71 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v71 = v34;
      operator delete(v36);
    }
    v25 = v68;
    if (!v68)
      goto LABEL_64;
    v37 = v69;
    v27 = v68;
    if (v69 == v68)
      goto LABEL_63;
    do
    {
      v39 = *--v37;
      v38 = v39;
      *v37 = 0;
      if (v39)
        MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
    }
    while (v37 != v25);
    goto LABEL_62;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v59, "callee", 6uLL);
  if (!v8)
  {
    a3(v63, a4);
    if (v63[0])
    {
      v60 = 3;
      v61 = "expected key entry for callee in DictionaryAttr to set Properties.";
      v62 = 66;
      v40 = &v60;
      v41 = (char *)v64;
      if (v65 >= v66)
      {
        v53 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          v57 = (char *)&v60 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v53, 24);
          v41 = (char *)v64;
          v40 = (int *)((char *)v64 + v57);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v53, 24);
          v40 = &v60;
          v41 = (char *)v64;
        }
      }
      v42 = &v41[24 * v65];
      v43 = *(_OWORD *)v40;
      *((_QWORD *)v42 + 2) = *((_QWORD *)v40 + 2);
      *(_OWORD *)v42 = v43;
      ++v65;
      if (v63[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
    }
    if (!v72)
      return 0;
    v44 = __p;
    if (__p)
    {
      v45 = v71;
      v46 = __p;
      if (v71 != __p)
      {
        do
          v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
        while (v45 != v44);
        v46 = __p;
      }
      v71 = v44;
      operator delete(v46);
    }
    v25 = v68;
    if (!v68)
      goto LABEL_64;
    v47 = v69;
    v27 = v68;
    if (v69 == v68)
      goto LABEL_63;
    do
    {
      v49 = *--v47;
      v48 = v49;
      *v47 = 0;
      if (v49)
        MEMORY[0x20BD002D4](v48, 0x1000C8077774924);
    }
    while (v47 != v25);
    goto LABEL_62;
  }
  v9 = v8;
  v10 = *(void **)(*(_QWORD *)v8 + 136);
  v11 = v10 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id;
  if (v10 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
    v12 = v8;
  else
    v12 = 0;
  v63[0] = v12;
  if (v11)
  {
    mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v63);
    if (!v13)
    {
      *a1 = v9;
      return 1;
    }
  }
  a3(v63, a4);
  if (v63[0])
  {
    v60 = 3;
    v62 = 51;
    v14 = &v60;
    v15 = (char *)v64;
    if (v65 >= v66)
    {
      v52 = v65 + 1;
      if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
      {
        v56 = (char *)&v60 - (_BYTE *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v52, 24);
        v15 = (char *)v64;
        v14 = (int *)((char *)v64 + v56);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v52, 24);
        v14 = &v60;
        v15 = (char *)v64;
      }
    }
    v16 = &v15[24 * v65];
    v17 = *(_OWORD *)v14;
    *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
    *(_OWORD *)v16 = v17;
    ++v65;
    if (v63[0])
    {
      v18 = &v60;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v60, v9);
      v19 = (char *)v64;
      if (v65 >= v66)
      {
        v54 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          v58 = (char *)&v60 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v54, 24);
          v19 = (char *)v64;
          v18 = (int *)((char *)v64 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v54, 24);
          v18 = &v60;
          v19 = (char *)v64;
        }
      }
      v20 = &v19[24 * v65];
      v21 = *(_OWORD *)v18;
      *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
      *(_OWORD *)v20 = v21;
      ++v65;
      if (v63[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
    }
  }
  if (v72)
  {
    v22 = __p;
    if (__p)
    {
      v23 = v71;
      v24 = __p;
      if (v71 != __p)
      {
        do
          v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        v24 = __p;
      }
      v71 = v22;
      operator delete(v24);
    }
    v25 = v68;
    if (!v68)
      goto LABEL_64;
    v26 = v69;
    v27 = v68;
    if (v69 == v68)
    {
LABEL_63:
      v69 = v25;
      operator delete(v27);
LABEL_64:
      if (v64 != v67)
        free(v64);
      return 0;
    }
    do
    {
      v29 = *--v26;
      v28 = v29;
      *v26 = 0;
      if (v29)
        MEMORY[0x20BD002D4](v28, 0x1000C8077774924);
    }
    while (v26 != v25);
LABEL_62:
    v27 = v68;
    goto LABEL_63;
  }
  return 0;
}

uint64_t mlir::func::CallOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x24BDAC8D0];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"callee", 6, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  void *v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  const void ***v17;
  char *v18;
  char *v19;
  __int128 v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  const void **v35;
  const char *v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  unsigned int v42;
  unsigned int v43;
  _BYTE v44[96];
  void *v45;
  _QWORD *v46;
  void *__p;
  _QWORD *v48;
  char v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  v9 = *(void **)(*(_QWORD *)a1 + 136);
  v10 = v9 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id;
  v11 = v9 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id ? a1 : 0;
  v39 = v11;
  if (v10)
  {
    mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v39);
    if (!v12)
      return 1;
  }
  a4(&v39, a5);
  if (v39)
  {
    LODWORD(v35) = 3;
    v36 = "attribute '";
    v37 = 11;
    v13 = &v35;
    v14 = (char *)v41;
    if (v42 >= v43)
    {
      v31 = v42 + 1;
      if (v41 <= &v35 && (char *)v41 + 24 * v42 > (char *)&v35)
      {
        v33 = (char *)&v35 - (_BYTE *)v41;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        v14 = (char *)v41;
        v13 = (const void ***)((char *)v41 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        v13 = &v35;
        v14 = (char *)v41;
      }
    }
    v15 = &v14[24 * v42];
    v16 = *(_OWORD *)v13;
    *((_QWORD *)v15 + 2) = v13[2];
    *(_OWORD *)v15 = v16;
    ++v42;
    if (v39)
    {
      v38 = 261;
      v35 = a2;
      v36 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v40, &v35);
      if (v39)
      {
        LODWORD(v35) = 3;
        v36 = "' failed to satisfy constraint: flat symbol reference attribute";
        v37 = 63;
        v17 = &v35;
        v18 = (char *)v41;
        if (v42 >= v43)
        {
          v32 = v42 + 1;
          if (v41 <= &v35 && (char *)v41 + 24 * v42 > (char *)&v35)
          {
            v34 = (char *)&v35 - (_BYTE *)v41;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
            v18 = (char *)v41;
            v17 = (const void ***)((char *)v41 + v34);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
            v17 = &v35;
            v18 = (char *)v41;
          }
        }
        v19 = &v18[24 * v42];
        v20 = *(_OWORD *)v17;
        *((_QWORD *)v19 + 2) = v17[2];
        *(_OWORD *)v19 = v20;
        ++v42;
      }
    }
  }
  v21 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v39);
  if (v39)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v39);
  if (v49)
  {
    v22 = __p;
    if (__p)
    {
      v23 = v48;
      v24 = __p;
      if (v48 != __p)
      {
        do
          v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        v24 = __p;
      }
      v48 = v22;
      operator delete(v24);
    }
    v25 = v45;
    if (v45)
    {
      v26 = v46;
      v27 = v45;
      if (v46 != v45)
      {
        do
        {
          v29 = *--v26;
          v28 = v29;
          *v26 = 0;
          if (v29)
            MEMORY[0x20BD002D4](v28, 0x1000C8077774924);
        }
        while (v26 != v25);
        v27 = v45;
      }
      v46 = v25;
      operator delete(v27);
    }
    if (v41 != v44)
      free(v41);
  }
  return v21;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451B000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451B000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::func::detail::CallOpGenericAdaptorBase::Properties]";
        v15 = 106;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::func::detail::CallOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451B000;
      }
    }
    a1[33] = v5[71];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::FlatSymbolRefAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void ***v9;
  char *v10;
  char *v11;
  __int128 v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  const void ***v17;
  char *v18;
  char *v19;
  __int128 v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  int64_t v37;
  int64_t v38;
  int64_t v39;
  _WORD v40[20];
  uint64_t v41;
  const void **v42;
  unint64_t v43;
  uint64_t v44;
  __int16 v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD *v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  v41 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v41))
    return 0;
  v4 = v41;
  if (*(_UNKNOWN **)(*(_QWORD *)v41 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
    v5 = v41;
  else
    v5 = 0;
  v46 = v5;
  if (v5)
  {
    mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v46);
    if (v6)
      v7 = 0;
    else
      v7 = v4;
    *a2 = v7;
    if (!v6)
      return 1;
  }
  else
  {
    *a2 = 0;
  }
  v40[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v46, a1, v40);
  if (v46)
  {
    LODWORD(v42) = 3;
    v43 = (unint64_t)"expected ";
    v44 = 9;
    v9 = &v42;
    v10 = (char *)v48;
    if (v49 >= v50)
    {
      v34 = v49 + 1;
      if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
      {
        v37 = (char *)&v42 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v34, 24);
        v10 = (char *)v48;
        v9 = (const void ***)((char *)v48 + v37);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v34, 24);
        v9 = &v42;
        v10 = (char *)v48;
      }
    }
    v11 = &v10[24 * v49];
    v12 = *(_OWORD *)v9;
    *((_QWORD *)v11 + 2) = v9[2];
    *(_OWORD *)v11 = v12;
    ++v49;
  }
  v42 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::FlatSymbolRefAttr]";
  v43 = 73;
  v13 = llvm::StringRef::find((uint64_t *)&v42, "DesiredTypeName = ", 0x12uLL, 0);
  if (v46)
  {
    if (v43 >= v13)
      v14 = v13;
    else
      v14 = v43;
    v15 = 18;
    if (v43 - v14 < 0x12)
      v15 = v43 - v14;
    v16 = v43 - v14 - v15;
    if (v16 >= v16 - 1)
      --v16;
    v45 = 261;
    v42 = (const void **)((char *)v42 + v14 + v15);
    v43 = v16;
    mlir::Diagnostic::operator<<((uint64_t)&v47, &v42);
    if (v46)
    {
      LODWORD(v42) = 3;
      v43 = (unint64_t)", but got: ";
      v44 = 11;
      v17 = &v42;
      v18 = (char *)v48;
      if (v49 >= v50)
      {
        v35 = v49 + 1;
        if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
        {
          v38 = (char *)&v42 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
          v18 = (char *)v48;
          v17 = (const void ***)((char *)v48 + v38);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
          v17 = &v42;
          v18 = (char *)v48;
        }
      }
      v19 = &v18[24 * v49];
      v20 = *(_OWORD *)v17;
      *((_QWORD *)v19 + 2) = v17[2];
      *(_OWORD *)v19 = v20;
      ++v49;
      if (v46)
      {
        v21 = &v42;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v42, v41);
        v22 = (char *)v48;
        if (v49 >= v50)
        {
          v36 = v49 + 1;
          if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
          {
            v39 = (char *)&v42 - (_BYTE *)v48;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            v22 = (char *)v48;
            v21 = (const void ***)((char *)v48 + v39);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            v21 = &v42;
            v22 = (char *)v48;
          }
        }
        v23 = &v22[24 * v49];
        v24 = *(_OWORD *)v21;
        *((_QWORD *)v23 + 2) = v21[2];
        *(_OWORD *)v23 = v24;
        ++v49;
      }
    }
  }
  v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  if (v56)
  {
    v25 = __p;
    if (__p)
    {
      v26 = v55;
      v27 = __p;
      if (v55 != __p)
      {
        do
          v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        v27 = __p;
      }
      v55 = v25;
      operator delete(v27);
    }
    v28 = v52;
    if (v52)
    {
      v29 = v53;
      v30 = v52;
      if (v53 != v52)
      {
        do
        {
          v32 = *--v29;
          v31 = v32;
          *v29 = 0;
          if (v32)
            MEMORY[0x20BD002D4](v31, 0x1000C8077774924);
        }
        while (v29 != v28);
        v30 = v52;
      }
      v53 = v28;
      operator delete(v30);
    }
    if (v48 != v51)
      free(v48);
  }
  return v8;
}

void mlir::func::CallOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  mlir::StringAttr *Context;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v16[4];
  __int16 v17;
  uint64_t v18[2];

  mlir::OperationState::addOperands(a2, a6, a7);
  Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  v17 = 261;
  v16[0] = "callee";
  v16[1] = 6;
  v12 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v16);
  ZinMirCacheTensors::ZinMirCacheTensors(v18, v12, a3);
  mlir::NamedAttrList::push_back(a2 + 112, v18[0], v18[1]);
  v13 = *(unsigned int *)(a2 + 72);
  if (a5 + v13 > (unint64_t)*(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), a5 + v13, 8);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  if (a5)
  {
    v14 = 0;
    v15 = *(_QWORD *)(a2 + 64) + 8 * v13;
    do
    {
      *(_QWORD *)(v15 + 8 * v14) = mlir::TypeRange::dereference_iterator(a4, v14);
      ++v14;
    }
    while (a5 != v14);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + a5;
}

uint64_t mlir::func::CallOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  const void **v17;
  __int16 v18;
  _QWORD v19[3];
  void *v20;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  void *__p;
  _QWORD *v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v19[0] = v2;
    if (mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v3, (const void **)"callee", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v19))
    {
      v4 = *((unsigned int *)*this + 9);
      if (*((_DWORD *)*this + 9))
        v5 = (uint64_t)(*this - 2);
      else
        v5 = 0;
      if ((_DWORD)v4)
      {
        for (i = 0; i != v4; ++i)
          mlir::detail::OpResultImpl::getNextResultAtOffset(v5, i);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v17 = (const void **)"requires attribute 'callee'";
    v18 = 259;
    mlir::OpState::emitOpError(this, &v17, (uint64_t)v19);
    v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
    if (v19[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
    if (v26)
    {
      v8 = __p;
      if (__p)
      {
        v9 = v25;
        v10 = __p;
        if (v25 != __p)
        {
          do
            v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
          while (v9 != v8);
          v10 = __p;
        }
        v25 = v8;
        operator delete(v10);
      }
      v11 = v22;
      if (v22)
      {
        v12 = v23;
        v13 = v22;
        if (v23 != v22)
        {
          do
          {
            v15 = *--v12;
            v14 = v15;
            *v12 = 0;
            if (v15)
              MEMORY[0x20BD002D4](v14, 0x1000C8077774924);
          }
          while (v12 != v11);
          v13 = v22;
        }
        v23 = v11;
        operator delete(v13);
      }
      if (v20 != &v21)
        free(v20);
    }
  }
  return v7;
}

BOOL mlir::func::CallOp::parse(uint64_t a1, _QWORD *a2)
{
  mlir::NoneType **v4;
  mlir::MLIRContext *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *Results;
  uint64_t v13;
  _BOOL8 v14;
  _QWORD v16[3];
  uint64_t v17;
  uint64_t Inputs;
  uint64_t v19;
  uint64_t v20;
  void *v21[2];
  _QWORD v22[17];

  v22[16] = *MEMORY[0x24BDAC8D0];
  v20 = 0;
  v21[0] = v22;
  v21[1] = (void *)0x400000000;
  Inputs = 0;
  v19 = 0;
  v4 = (mlir::NoneType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  v6 = mlir::NoneType::get(*v4, v5);
  if (!mlir::AsmParser::parseAttribute<mlir::FlatSymbolRefAttr>(a1, &v20, v6))
    goto LABEL_13;
  if (v20)
  {
    v7 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(a2);
    *v7 = v20;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 264))(a1))
    goto LABEL_13;
  v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void **, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, v21, 0, 1, 0xFFFFFFFFLL))goto LABEL_13;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 280))(a1))
    goto LABEL_13;
  v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 456))(a1, a2 + 14))
    goto LABEL_13;
  v9 = a2[1];
  v16[0] = a1;
  v16[1] = &v17;
  v16[2] = a2;
  v10 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(_QWORD **)(v9 + 96));
  if (v10)
  {
    if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v10, (const void **)"callee", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::CallOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v16))goto LABEL_13;
  }
  if ((*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1)
    && (v16[0] = 0, mlir::AsmParser::parseType<mlir::FunctionType>(a1, v16)))
  {
    Inputs = mlir::FunctionType::getInputs((mlir::FunctionType *)v16);
    v19 = v11;
    Results = (void *)mlir::FunctionType::getResults((mlir::FunctionType *)v16);
    mlir::OperationState::addTypes((uint64_t)a2, Results, v13);
    v14 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,3u> &,llvm::ArrayRef<mlir::Type>>(a1, (uint64_t *)v21, &Inputs, v8, (uint64_t)(a2 + 2)) != 0;
  }
  else
  {
LABEL_13:
    v14 = 0;
  }
  if (v21[0] != v22)
    free(v21[0]);
  return v14;
}

void mlir::func::CallOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  llvm::raw_ostream *v6;
  _BYTE *v7;
  mlir::Operation *v8;
  uint64_t v9;
  uint64_t v10;
  llvm::raw_ostream *v11;
  llvm::raw_ostream *v12;
  _BYTE *v13;
  mlir::Operation *v14;
  mlir::ArrayAttr *v15;
  uint64_t Value;
  uint64_t v17;
  llvm::raw_ostream *v18;
  _BYTE *v19;
  llvm::raw_ostream *v20;
  _BYTE *v21;
  llvm::raw_ostream *v22;
  _BYTE *v23;
  mlir::Operation *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29[4];
  uint64_t v30[2];
  uint64_t v31[4];
  uint64_t v32[2];
  char *v33;
  uint64_t v34;
  _QWORD v35[5];

  v35[4] = *MEMORY[0x24BDAC8D0];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if ((unint64_t)v5 >= *((_QWORD *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((_QWORD *)v4 + 4) = v5 + 1;
    *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 48))(a2, *((_QWORD *)*this + 2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8));
  v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v7 = (_BYTE *)*((_QWORD *)v6 + 4);
  if (*((_BYTE **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, "(", 1uLL);
    v8 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
      goto LABEL_6;
  }
  else
  {
    *v7 = 40;
    ++*((_QWORD *)v6 + 4);
    v8 = *this;
    if ((*((_BYTE *)*this + 46) & 0x80) != 0)
    {
LABEL_6:
      v9 = *((unsigned int *)v8 + 17);
      v10 = *((_QWORD *)v8 + 9);
      goto LABEL_7;
    }
  }
  v10 = 0;
  v9 = 0;
LABEL_7:
  v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v33 = ", ";
  v34 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v10, 0, v10, v9, (uint64_t)a2, v11, (uint64_t)&v33);
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)v12 + 4);
  if (*((_BYTE **)v12 + 3) == v13)
  {
    llvm::raw_ostream::write(v12, ")", 1uLL);
  }
  else
  {
    *v13 = 41;
    ++*((_QWORD *)v12 + 4);
  }
  v33 = (char *)v35;
  v35[0] = "callee";
  v35[1] = 6;
  v34 = 0x200000001;
  v14 = *this;
  if (*((_BYTE *)*this + 47))
  {
    v31[0] = mlir::Operation::getAttrDictionary(v14);
    v15 = (mlir::ArrayAttr *)v31;
  }
  else
  {
    v15 = (mlir::Operation *)((char *)v14 + 56);
  }
  Value = mlir::ArrayAttr::getValue(v15);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, char *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v17, v33, v34);
  v18 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v19 = (_BYTE *)*((_QWORD *)v18 + 4);
  if ((unint64_t)v19 >= *((_QWORD *)v18 + 3))
  {
    llvm::raw_ostream::write(v18, 32);
  }
  else
  {
    *((_QWORD *)v18 + 4) = v19 + 1;
    *v19 = 32;
  }
  v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v21 = (_BYTE *)*((_QWORD *)v20 + 4);
  if (*((_BYTE **)v20 + 3) == v21)
  {
    llvm::raw_ostream::write(v20, ":", 1uLL);
  }
  else
  {
    *v21 = 58;
    ++*((_QWORD *)v20 + 4);
  }
  v22 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v23 = (_BYTE *)*((_QWORD *)v22 + 4);
  if ((unint64_t)v23 >= *((_QWORD *)v22 + 3))
  {
    llvm::raw_ostream::write(v22, 32);
  }
  else
  {
    *((_QWORD *)v22 + 4) = v23 + 1;
    *v23 = 32;
  }
  v24 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v25 = *((unsigned int *)v24 + 17);
    v26 = *((_QWORD *)v24 + 9);
  }
  else
  {
    v26 = 0;
    v25 = 0;
  }
  v30[0] = v26;
  v30[1] = v25;
  mlir::OperandRange::getTypes(v30, v31);
  v27 = *((unsigned int *)*this + 9);
  v28 = (uint64_t)*this - 16;
  if (!(_DWORD)v27)
    v28 = 0;
  v32[0] = v28;
  v32[1] = v27;
  mlir::OperandRange::getTypes(v32, v29);
  mlir::AsmPrinter::printFunctionalType<mlir::ValueTypeRange<mlir::OperandRange>,mlir::ValueTypeRange<mlir::ResultRange>>((uint64_t)a2, v31, v29);
  if (v33 != (char *)v35)
    free(v33);
}

uint64_t mlir::func::ConstantOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD *v34;
  _QWORD *v35;
  void *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  int *v40;
  char *v41;
  char *v42;
  __int128 v43;
  _QWORD *v44;
  _QWORD *v45;
  void *v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  int64_t v55;
  int64_t v56;
  int64_t v57;
  int64_t v58;
  uint64_t v59;
  int v60;
  const char *v61;
  uint64_t v62;
  _QWORD v63[3];
  void *v64;
  unsigned int v65;
  unsigned int v66;
  _BYTE v67[96];
  void *v68;
  _QWORD *v69;
  void *__p;
  _QWORD *v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v59 = v6;
  if (!v6)
  {
    a3(v63, a4);
    if (v63[0])
    {
      v60 = 3;
      v61 = "expected DictionaryAttr to set properties";
      v62 = 41;
      v30 = &v60;
      v31 = (char *)v64;
      if (v65 >= v66)
      {
        v51 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          v55 = (char *)&v60 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
          v31 = (char *)v64;
          v30 = (int *)((char *)v64 + v55);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
          v30 = &v60;
          v31 = (char *)v64;
        }
      }
      v32 = &v31[24 * v65];
      v33 = *(_OWORD *)v30;
      *((_QWORD *)v32 + 2) = *((_QWORD *)v30 + 2);
      *(_OWORD *)v32 = v33;
      ++v65;
      if (v63[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
    }
    if (!v72)
      return 0;
    v34 = __p;
    if (__p)
    {
      v35 = v71;
      v36 = __p;
      if (v71 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v71 = v34;
      operator delete(v36);
    }
    v25 = v68;
    if (!v68)
      goto LABEL_64;
    v37 = v69;
    v27 = v68;
    if (v69 == v68)
      goto LABEL_63;
    do
    {
      v39 = *--v37;
      v38 = v39;
      *v37 = 0;
      if (v39)
        MEMORY[0x20BD002D4](v38, 0x1000C8077774924);
    }
    while (v37 != v25);
    goto LABEL_62;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v59, "value", 5uLL);
  if (!v8)
  {
    a3(v63, a4);
    if (v63[0])
    {
      v60 = 3;
      v61 = "expected key entry for value in DictionaryAttr to set Properties.";
      v62 = 65;
      v40 = &v60;
      v41 = (char *)v64;
      if (v65 >= v66)
      {
        v53 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          v57 = (char *)&v60 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v53, 24);
          v41 = (char *)v64;
          v40 = (int *)((char *)v64 + v57);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v53, 24);
          v40 = &v60;
          v41 = (char *)v64;
        }
      }
      v42 = &v41[24 * v65];
      v43 = *(_OWORD *)v40;
      *((_QWORD *)v42 + 2) = *((_QWORD *)v40 + 2);
      *(_OWORD *)v42 = v43;
      ++v65;
      if (v63[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
    }
    if (!v72)
      return 0;
    v44 = __p;
    if (__p)
    {
      v45 = v71;
      v46 = __p;
      if (v71 != __p)
      {
        do
          v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
        while (v45 != v44);
        v46 = __p;
      }
      v71 = v44;
      operator delete(v46);
    }
    v25 = v68;
    if (!v68)
      goto LABEL_64;
    v47 = v69;
    v27 = v68;
    if (v69 == v68)
      goto LABEL_63;
    do
    {
      v49 = *--v47;
      v48 = v49;
      *v47 = 0;
      if (v49)
        MEMORY[0x20BD002D4](v48, 0x1000C8077774924);
    }
    while (v47 != v25);
    goto LABEL_62;
  }
  v9 = v8;
  v10 = *(void **)(*(_QWORD *)v8 + 136);
  v11 = v10 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id;
  if (v10 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
    v12 = v8;
  else
    v12 = 0;
  v63[0] = v12;
  if (v11)
  {
    mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v63);
    if (!v13)
    {
      *a1 = v9;
      return 1;
    }
  }
  a3(v63, a4);
  if (v63[0])
  {
    v60 = 3;
    v62 = 50;
    v14 = &v60;
    v15 = (char *)v64;
    if (v65 >= v66)
    {
      v52 = v65 + 1;
      if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
      {
        v56 = (char *)&v60 - (_BYTE *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v52, 24);
        v15 = (char *)v64;
        v14 = (int *)((char *)v64 + v56);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v52, 24);
        v14 = &v60;
        v15 = (char *)v64;
      }
    }
    v16 = &v15[24 * v65];
    v17 = *(_OWORD *)v14;
    *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
    *(_OWORD *)v16 = v17;
    ++v65;
    if (v63[0])
    {
      v18 = &v60;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v60, v9);
      v19 = (char *)v64;
      if (v65 >= v66)
      {
        v54 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          v58 = (char *)&v60 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v54, 24);
          v19 = (char *)v64;
          v18 = (int *)((char *)v64 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v54, 24);
          v18 = &v60;
          v19 = (char *)v64;
        }
      }
      v20 = &v19[24 * v65];
      v21 = *(_OWORD *)v18;
      *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
      *(_OWORD *)v20 = v21;
      ++v65;
      if (v63[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
    }
  }
  if (v72)
  {
    v22 = __p;
    if (__p)
    {
      v23 = v71;
      v24 = __p;
      if (v71 != __p)
      {
        do
          v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        v24 = __p;
      }
      v71 = v22;
      operator delete(v24);
    }
    v25 = v68;
    if (!v68)
      goto LABEL_64;
    v26 = v69;
    v27 = v68;
    if (v69 == v68)
    {
LABEL_63:
      v69 = v25;
      operator delete(v27);
LABEL_64:
      if (v64 != v67)
        free(v64);
      return 0;
    }
    do
    {
      v29 = *--v26;
      v28 = v29;
      *v26 = 0;
      if (v29)
        MEMORY[0x20BD002D4](v28, 0x1000C8077774924);
    }
    while (v26 != v25);
LABEL_62:
    v27 = v68;
    goto LABEL_63;
  }
  return 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  _QWORD *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &unk_25451B000;
    if ((v4 & 1) == 0)
    {
      v5 = (_QWORD *)&unk_25451B000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::func::detail::ConstantOpGenericAdaptorBase::Properties]";
        v15 = 110;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = (_QWORD *)&unk_25451B000;
      }
    }
    a1[33] = v5[73];
    return a1[32];
  }
  return result;
}

uint64_t mlir::func::ConstantOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  const void **v15;
  __int16 v16;
  _QWORD v17[3];
  void *v18;
  uint64_t v19;
  void *v20;
  _QWORD *v21;
  void *__p;
  _QWORD *v23;
  char v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v17[0] = v2;
    if (mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v3, (const void **)"value", (const char *)5, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v17))
    {
      if (*((_DWORD *)*this + 9))
        v4 = (uint64_t)(*this - 2);
      else
        v4 = 0;
      mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v15 = (const void **)"requires attribute 'value'";
    v16 = 259;
    mlir::OpState::emitOpError(this, &v15, (uint64_t)v17);
    v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v17);
    if (v17[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v17);
    if (v24)
    {
      v6 = __p;
      if (__p)
      {
        v7 = v23;
        v8 = __p;
        if (v23 != __p)
        {
          do
            v7 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v7 - 1);
          while (v7 != v6);
          v8 = __p;
        }
        v23 = v6;
        operator delete(v8);
      }
      v9 = v20;
      if (v20)
      {
        v10 = v21;
        v11 = v20;
        if (v21 != v20)
        {
          do
          {
            v13 = *--v10;
            v12 = v13;
            *v10 = 0;
            if (v13)
              MEMORY[0x20BD002D4](v12, 0x1000C8077774924);
          }
          while (v10 != v9);
          v11 = v20;
        }
        v21 = v9;
        operator delete(v11);
      }
      if (v18 != &v19)
        free(v18);
    }
  }
  return v5;
}

uint64_t mlir::func::ConstantOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  mlir::NoneType **v6;
  mlir::MLIRContext *v7;
  uint64_t v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  void *v15;
  _QWORD v17[3];
  uint64_t v18;
  uint64_t v19;
  void *__src;
  uint64_t v21;
  _QWORD v22[2];

  v22[1] = *MEMORY[0x24BDAC8D0];
  v19 = 0;
  __src = v22;
  v21 = 0x100000000;
  v18 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112))
    goto LABEL_15;
  v4 = *(_QWORD *)(a2 + 8);
  v17[0] = a1;
  v17[1] = &v18;
  v17[2] = a2;
  v5 = mlir::NamedAttrList::get(a2 + 112, **(_QWORD **)(v4 + 96));
  if (v5)
  {
    if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v5, (const void **)"value", (const char *)5, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::ConstantOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v17))goto LABEL_15;
  }
  v6 = (mlir::NoneType **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  v8 = mlir::NoneType::get(*v6, v7);
  if (!mlir::AsmParser::parseAttribute<mlir::FlatSymbolRefAttr>(a1, &v19, v8))
    goto LABEL_15;
  if (v19)
  {
    v9 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>((_QWORD *)a2);
    *v9 = v19;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1)
    || !mlir::AsmParser::parseTypeList(a1, (uint64_t)&__src))
  {
LABEL_15:
    v14 = 0;
    v15 = __src;
    if (__src == v22)
      return v14;
LABEL_16:
    free(v15);
    return v14;
  }
  v10 = __src;
  v11 = v21;
  v12 = *(unsigned int *)(a2 + 72);
  v13 = v12 + v21;
  if (v13 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v13, 8);
    LODWORD(v12) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v11)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v12), v10, 8 * v11);
    LODWORD(v12) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v12 + v11;
  v14 = 1;
  v15 = __src;
  if (__src != v22)
    goto LABEL_16;
  return v14;
}

void mlir::func::ConstantOp::print(mlir::func::ConstantOp *this, mlir::OpAsmPrinter *a2)
{
  _BYTE *v4;
  mlir::ArrayAttr *v5;
  uint64_t Value;
  uint64_t v7;
  llvm::raw_ostream *v8;
  _BYTE *v9;
  llvm::raw_ostream *v10;
  _BYTE *v11;
  llvm::raw_ostream *v12;
  _BYTE *v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18[4];
  const char *v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  _QWORD v23[5];

  v23[4] = *MEMORY[0x24BDAC8D0];
  v21 = v23;
  v23[0] = "value";
  v23[1] = 5;
  v22 = 0x200000001;
  v4 = *(_BYTE **)this;
  if (v4[47])
  {
    v18[0] = mlir::Operation::getAttrDictionary((mlir::Operation *)v4);
    v5 = (mlir::ArrayAttr *)v18;
  }
  else
  {
    v5 = (mlir::ArrayAttr *)(v4 + 56);
  }
  Value = mlir::ArrayAttr::getValue(v5);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v7, v21, v22);
  v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v9 = (_BYTE *)*((_QWORD *)v8 + 4);
  if ((unint64_t)v9 >= *((_QWORD *)v8 + 3))
  {
    llvm::raw_ostream::write(v8, 32);
  }
  else
  {
    *((_QWORD *)v8 + 4) = v9 + 1;
    *v9 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, _QWORD))(*(_QWORD *)a2 + 48))(a2, *(_QWORD *)(*(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64));
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (_BYTE *)*((_QWORD *)v10 + 4);
  if ((unint64_t)v11 >= *((_QWORD *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((_QWORD *)v10 + 4) = v11 + 1;
    *v11 = 32;
  }
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)v12 + 4);
  if (*((_BYTE **)v12 + 3) == v13)
  {
    llvm::raw_ostream::write(v12, ":", 1uLL);
  }
  else
  {
    *v13 = 58;
    ++*((_QWORD *)v12 + 4);
  }
  v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)v14 + 4);
  if ((unint64_t)v15 >= *((_QWORD *)v14 + 3))
  {
    llvm::raw_ostream::write(v14, 32);
  }
  else
  {
    *((_QWORD *)v14 + 4) = v15 + 1;
    *v15 = 32;
  }
  v16 = *(unsigned int *)(*(_QWORD *)this + 36);
  v17 = (const char *)(*(_QWORD *)this - 16);
  if (!(_DWORD)v16)
    v17 = 0;
  v19 = v17;
  v20 = v16;
  mlir::OperandRange::getTypes((uint64_t *)&v19, v18);
  v19 = ", ";
  v20 = 2;
  llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::ResultRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &,mlir::AsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>(v18[0], v18[1], v18[2], v18[3], (uint64_t)a2, (uint64_t)a2, (uint64_t)&v19);
  if (v21 != v23)
    free(v21);
}

uint64_t mlir::func::FuncOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  char *v39;
  char *v40;
  __int128 v41;
  uint64_t *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  _QWORD *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t *v66;
  char *v67;
  char *v68;
  __int128 v69;
  _QWORD *v70;
  _QWORD *v71;
  void *v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  int64_t v85;
  int64_t v86;
  int64_t v87;
  int64_t v88;
  int64_t v89;
  int64_t v90;
  int64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  const char *v95;
  uint64_t v96;
  _QWORD v97[3];
  void *v98;
  unsigned int v99;
  unsigned int v100;
  _BYTE v101[96];
  void *v102;
  _QWORD *v103;
  void *__p;
  _QWORD *v105;
  char v106;
  uint64_t v107;

  v107 = *MEMORY[0x24BDAC8D0];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v93 = v6;
  if (!v6)
  {
    a3(v97, a4);
    if (v97[0])
    {
      LODWORD(v94) = 3;
      v95 = "expected DictionaryAttr to set properties";
      v96 = 41;
      v26 = &v94;
      v27 = (char *)v98;
      if (v99 >= v100)
      {
        v78 = v99 + 1;
        if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
        {
          v85 = (char *)&v94 - (_BYTE *)v98;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v78, 24);
          v27 = (char *)v98;
          v26 = (uint64_t *)((char *)v98 + v85);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v78, 24);
          v26 = &v94;
          v27 = (char *)v98;
        }
      }
      v28 = &v27[24 * v99];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      ++v99;
      if (v97[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v97);
    }
    if (!v106)
      return 0;
    v30 = __p;
    if (__p)
    {
      v31 = v105;
      v32 = __p;
      if (v105 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v105 = v30;
      operator delete(v32);
    }
    v21 = v102;
    if (!v102)
      goto LABEL_104;
    v33 = v103;
    v23 = v102;
    if (v103 == v102)
    {
LABEL_103:
      v103 = v21;
      operator delete(v23);
LABEL_104:
      if (v98 != v101)
        free(v98);
      return 0;
    }
    do
    {
      v35 = *--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        MEMORY[0x20BD002D4](v34, 0x1000C8077774924);
    }
    while (v33 != v21);
    goto LABEL_102;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v93, "arg_attrs", 9uLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    {
      a3(v97, a4);
      if (v97[0])
      {
        LODWORD(v94) = 3;
        v96 = 54;
        v10 = &v94;
        v11 = (char *)v98;
        if (v99 >= v100)
        {
          v79 = v99 + 1;
          if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
          {
            v86 = (char *)&v94 - (_BYTE *)v98;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v79, 24);
            v11 = (char *)v98;
            v10 = (uint64_t *)((char *)v98 + v86);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v79, 24);
            v10 = &v94;
            v11 = (char *)v98;
          }
        }
        v12 = &v11[24 * v99];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = v10[2];
        *(_OWORD *)v12 = v13;
        ++v99;
        if (v97[0])
        {
          v14 = &v94;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v94, v9);
          v15 = (char *)v98;
          if (v99 >= v100)
          {
            v80 = v99 + 1;
            if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
            {
              v87 = (char *)&v94 - (_BYTE *)v98;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v80, 24);
              v15 = (char *)v98;
              v14 = (uint64_t *)((char *)v98 + v87);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v80, 24);
              v14 = &v94;
              v15 = (char *)v98;
            }
          }
          v16 = &v15[24 * v99];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = v14[2];
          *(_OWORD *)v16 = v17;
          ++v99;
          if (v97[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v97);
        }
      }
      if (!v106)
        return 0;
      v18 = __p;
      if (__p)
      {
        v19 = v105;
        v20 = __p;
        if (v105 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v105 = v18;
        operator delete(v20);
      }
      v21 = v102;
      if (!v102)
        goto LABEL_104;
      v22 = v103;
      v23 = v102;
      if (v103 == v102)
        goto LABEL_103;
      do
      {
        v25 = *--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
      }
      while (v22 != v21);
      goto LABEL_102;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v93, "function_type", 0xDuLL);
  if (!v36)
  {
    a3(v97, a4);
    if (v97[0])
    {
      LODWORD(v94) = 3;
      v95 = "expected key entry for function_type in DictionaryAttr to set Properties.";
      v96 = 73;
      v52 = &v94;
      v53 = (char *)v98;
      if (v99 >= v100)
      {
        v82 = v99 + 1;
        if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
        {
          v89 = (char *)&v94 - (_BYTE *)v98;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v82, 24);
          v53 = (char *)v98;
          v52 = (uint64_t *)((char *)v98 + v89);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v82, 24);
          v52 = &v94;
          v53 = (char *)v98;
        }
      }
      v54 = &v53[24 * v99];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = v52[2];
      *(_OWORD *)v54 = v55;
      ++v99;
      if (v97[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v97);
    }
    if (!v106)
      return 0;
    v56 = __p;
    if (__p)
    {
      v57 = v105;
      v58 = __p;
      if (v105 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v105 = v56;
      operator delete(v58);
    }
    v21 = v102;
    if (!v102)
      goto LABEL_104;
    v59 = v103;
    v23 = v102;
    if (v103 == v102)
      goto LABEL_103;
    do
    {
      v61 = *--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        MEMORY[0x20BD002D4](v60, 0x1000C8077774924);
    }
    while (v59 != v21);
    goto LABEL_102;
  }
  v37 = v36;
  if (*(_UNKNOWN **)(*(_QWORD *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    a3(v97, a4);
    if (v97[0])
    {
      LODWORD(v94) = 3;
      v96 = 58;
      v38 = &v94;
      v39 = (char *)v98;
      if (v99 >= v100)
      {
        v81 = v99 + 1;
        if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
        {
          v88 = (char *)&v94 - (_BYTE *)v98;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v81, 24);
          v39 = (char *)v98;
          v38 = (uint64_t *)((char *)v98 + v88);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v81, 24);
          v38 = &v94;
          v39 = (char *)v98;
        }
      }
      v40 = &v39[24 * v99];
      v41 = *(_OWORD *)v38;
      *((_QWORD *)v40 + 2) = v38[2];
      *(_OWORD *)v40 = v41;
      ++v99;
      if (v97[0])
      {
        v42 = &v94;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v94, v37);
        v43 = (char *)v98;
        if (v99 >= v100)
        {
          v83 = v99 + 1;
          if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
          {
            v90 = (char *)&v94 - (_BYTE *)v98;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v83, 24);
            v43 = (char *)v98;
            v42 = (uint64_t *)((char *)v98 + v90);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v83, 24);
            v42 = &v94;
            v43 = (char *)v98;
          }
        }
        v44 = &v43[24 * v99];
        v45 = *(_OWORD *)v42;
        *((_QWORD *)v44 + 2) = v42[2];
        *(_OWORD *)v44 = v45;
        ++v99;
        if (v97[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v97);
      }
    }
    if (!v106)
      return 0;
    v46 = __p;
    if (__p)
    {
      v47 = v105;
      v48 = __p;
      if (v105 != __p)
      {
        do
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        v48 = __p;
      }
      v105 = v46;
      operator delete(v48);
    }
    v21 = v102;
    if (!v102)
      goto LABEL_104;
    v49 = v103;
    v23 = v102;
    if (v103 == v102)
      goto LABEL_103;
    do
    {
      v51 = *--v49;
      v50 = v51;
      *v49 = 0;
      if (v51)
        MEMORY[0x20BD002D4](v50, 0x1000C8077774924);
    }
    while (v49 != v21);
    goto LABEL_102;
  }
  a1[1] = v36;
  v62 = mlir::DictionaryAttr::get((uint64_t)&v93, "res_attrs", 9uLL);
  v94 = v62;
  if (!v62)
  {
LABEL_83:
    v64 = mlir::DictionaryAttr::get((uint64_t)&v93, "sym_name", 8uLL);
    v92 = v64;
    if (v64)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v64 + 136) != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
      {
        a3(v97, a4);
        mlir::InFlightDiagnostic::append<mlir::Attribute>(v65, &v92);
        mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v97);
        return 0;
      }
      a1[3] = v64;
      v77 = mlir::DictionaryAttr::get((uint64_t)&v93, "sym_visibility", 0xEuLL);
      v94 = v77;
      if (v77)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)v77 + 136) != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
        {
          a3(v97, a4);
          goto LABEL_81;
        }
        a1[4] = v77;
      }
      return 1;
    }
    a3(v97, a4);
    if (v97[0])
    {
      LODWORD(v94) = 3;
      v95 = "expected key entry for sym_name in DictionaryAttr to set Properties.";
      v96 = 68;
      v66 = &v94;
      v67 = (char *)v98;
      if (v99 >= v100)
      {
        v84 = v99 + 1;
        if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
        {
          v91 = (char *)&v94 - (_BYTE *)v98;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v84, 24);
          v67 = (char *)v98;
          v66 = (uint64_t *)((char *)v98 + v91);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v84, 24);
          v66 = &v94;
          v67 = (char *)v98;
        }
      }
      v68 = &v67[24 * v99];
      v69 = *(_OWORD *)v66;
      *((_QWORD *)v68 + 2) = v66[2];
      *(_OWORD *)v68 = v69;
      ++v99;
      if (v97[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v97);
    }
    if (!v106)
      return 0;
    v70 = __p;
    if (__p)
    {
      v71 = v105;
      v72 = __p;
      if (v105 != __p)
      {
        do
          v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        v72 = __p;
      }
      v105 = v70;
      operator delete(v72);
    }
    v21 = v102;
    if (!v102)
      goto LABEL_104;
    v73 = v103;
    v23 = v102;
    if (v103 == v102)
      goto LABEL_103;
    do
    {
      v75 = *--v73;
      v74 = v75;
      *v73 = 0;
      if (v75)
        MEMORY[0x20BD002D4](v74, 0x1000C8077774924);
    }
    while (v73 != v21);
LABEL_102:
    v23 = v102;
    goto LABEL_103;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v62 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
  {
    a1[2] = v62;
    goto LABEL_83;
  }
  a3(v97, a4);
LABEL_81:
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v63, &v94);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v97);
  return 0;
}

uint64_t mlir::func::FuncOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  void *v33;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v36;
  void *v37;
  uint64_t v38;
  _QWORD v39[7];

  v39[6] = *MEMORY[0x24BDAC8D0];
  v36 = a1;
  v37 = v39;
  v38 = 0x300000000;
  if (!*a2)
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_10;
    goto LABEL_7;
  }
  NamedAttr = mlir::Builder::getNamedAttr(&v36, (uint64_t)"arg_attrs", 9, *a2);
  v5 = v4;
  v6 = v38;
  if (v38 >= HIDWORD(v38))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
    v6 = v38;
  }
  v7 = (uint64_t *)((char *)v37 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = v38 + 1;
  LODWORD(v38) = v38 + 1;
  v9 = a2[1];
  if (v9)
  {
LABEL_7:
    v10 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"function_type", 13, v9);
    v12 = v11;
    v13 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v13 = v38;
    }
    v14 = (uint64_t *)((char *)v37 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
LABEL_10:
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"res_attrs", 9, v15);
    v18 = v17;
    v19 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v19 = v38;
    }
    v20 = (uint64_t *)((char *)v37 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"sym_name", 8, v21);
    v24 = v23;
    v25 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v25 = v38;
    }
    v26 = (uint64_t *)((char *)v37 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"sym_visibility", 14, v27);
    v30 = v29;
    v31 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v31 = v38;
    }
    v32 = (uint64_t *)((char *)v37 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  v33 = v37;
  if (!v8)
  {
    DictionaryAttr = 0;
    if (v37 == v39)
      return DictionaryAttr;
    goto LABEL_24;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v36, (mlir::MLIRContext *)v37, v8);
  v33 = v37;
  if (v37 != v39)
LABEL_24:
    free(v33);
  return DictionaryAttr;
}

unint64_t mlir::func::FuncOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1;
  unsigned __int8 v2;
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unsigned __int8 v16;
  unint64_t v17;
  unint64_t v18;
  int v20;
  int v21;
  unint64_t v22;
  int v23;
  int v24;
  unint64_t v25;
  int v26;
  int v27;
  unint64_t v28;
  int v29;
  int v30;
  unint64_t v31;
  int v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t *v39;
  unint64_t *v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;

  v1 = *a1;
  v3 = &unk_254519000;
  if ((v2 & 1) == 0)
  {
    v34 = *a1;
    v38 = a1;
    v3 = &unk_254519000;
    v21 = v20;
    v1 = v34;
    a1 = v38;
    if (v21)
    {
      v22 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v22 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v22;
      v1 = v34;
      a1 = v38;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v4 = HIDWORD(v1);
  v5 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v1) ^ HIDWORD(v1));
  v47 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) ^ ((0x9DDFEA08EB382D69 * (v4 ^ (v5 >> 47) ^ v5)) >> 47));
  v6 = a1[1];
  if ((v4 & 1) == 0)
  {
    v35 = a1[1];
    v39 = a1;
    v3 = &unk_254519000;
    v24 = v23;
    v6 = v35;
    a1 = v39;
    if (v24)
    {
      v25 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v25 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v25;
      v6 = v35;
      a1 = v39;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v7 = HIDWORD(v6);
  v8 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v6) ^ HIDWORD(v6));
  v46 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
  v9 = a1[2];
  if ((v7 & 1) == 0)
  {
    v36 = a1[2];
    v40 = a1;
    v3 = &unk_254519000;
    v27 = v26;
    v9 = v36;
    a1 = v40;
    if (v27)
    {
      v28 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v28 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v28;
      v9 = v36;
      a1 = v40;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v10 = HIDWORD(v9);
  v11 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v9) ^ HIDWORD(v9));
  v45 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) >> 47));
  v12 = a1[3];
  if ((v10 & 1) == 0)
  {
    v37 = a1[3];
    v41 = a1;
    v3 = &unk_254519000;
    v30 = v29;
    v12 = v37;
    a1 = v41;
    if (v30)
    {
      v31 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v31 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v31;
      v12 = v37;
      a1 = v41;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v13 = HIDWORD(v12);
  v14 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v12) ^ HIDWORD(v12));
  v44 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) ^ ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) >> 47));
  v15 = a1[4];
  if ((v16 & 1) == 0)
  {
    v42 = a1[4];
    v15 = v42;
    v3 = &unk_254519000;
    if (v32)
    {
      v33 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v33 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v33;
      v15 = v42;
      v3 = (_QWORD *)&unk_254519000;
    }
  }
  v17 = HIDWORD(v15);
  v18 = 0x9DDFEA08EB382D69 * ((v3[373] + 8 * v15) ^ HIDWORD(v15));
  v43 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) ^ ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) >> 47));
  return llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>(&v47, (uint64_t *)&v46, (uint64_t *)&v45, (uint64_t *)&v44, (uint64_t *)&v43);
}

unint64_t llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>(_QWORD *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  unsigned __int8 v8;
  uint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  int v15;
  unint64_t v16;
  uint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _OWORD v23[4];
  _OWORD v24[3];
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v25 = 0;
  memset(v24, 0, sizeof(v24));
  memset(v23, 0, sizeof(v23));
  if ((v8 & 1) == 0)
  {
    v17 = a2;
    v18 = a1;
    a2 = v17;
    a1 = v18;
    if (v15)
    {
      v16 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v16 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v16;
      a2 = v17;
      a1 = v18;
    }
  }
  v9 = *a1;
  v26 = llvm::hashing::detail::get_execution_seed(void)::seed;
  *(_QWORD *)&v23[0] = v9;
  v19 = 0;
  v10 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v23, (uint64_t *)&v19, (_QWORD *)v23 + 1, (unint64_t)v24, *a2);
  v20 = v19;
  v11 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v23, (uint64_t *)&v20, v10, (unint64_t)v24, *a3);
  v21 = v20;
  v12 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v23, (uint64_t *)&v21, v11, (unint64_t)v24, *a4);
  v22 = v21;
  v13 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v23, (uint64_t *)&v22, v12, (unint64_t)v24, *a5);
  return llvm::hashing::detail::hash_combine_recursive_helper::combine((llvm::hashing::detail::hash_combine_recursive_helper *)v23, v22, v13, (char *)v24);
}

uint64_t mlir::func::FuncOp::getInherentAttr(int a1, _QWORD *a2, _QWORD *__s1, size_t __n)
{
  switch(__n)
  {
    case 8uLL:
      if (memcmp(__s1, "sym_name", __n))
        return 0;
      return a2[3];
    case 9uLL:
      if (*__s1 == 0x727474615F677261 && *((_BYTE *)__s1 + 8) == 115)
        return *a2;
      if (memcmp(__s1, "res_attrs", __n))
        return 0;
      return a2[2];
    case 0xAuLL:
    case 0xBuLL:
    case 0xCuLL:
      return 0;
    case 0xDuLL:
      if (memcmp(__s1, "function_type", __n))
        return 0;
      return a2[1];
    case 0xEuLL:
      if (memcmp(__s1, "sym_visibility", __n))
        return 0;
      return a2[4];
    default:
      return 0;
  }
}

uint64_t mlir::func::FuncOp::setInherentAttr(uint64_t result, _QWORD *__s1, size_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (_QWORD *)result;
  switch(a3)
  {
    case 8uLL:
      result = memcmp(__s1, "sym_name", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          v5[3] = v10;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 9uLL:
      if (*__s1 == 0x727474615F677261 && *((_BYTE *)__s1 + 8) == 115)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          *(_QWORD *)result = v11;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      else
      {
        result = memcmp(__s1, "res_attrs", a3);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
              v7 = a4;
            else
              v7 = 0;
            v5[2] = v7;
          }
          else
          {
            v5[2] = 0;
          }
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "function_type", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
            v8 = a4;
          else
            v8 = 0;
          v5[1] = v8;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "sym_visibility", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
            v9 = a4;
          else
            v9 = 0;
          v5[4] = v9;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::func::FuncOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"arg_attrs", 9, *a2);
  v5 = a2[1];
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"function_type", 13, v5);
  v6 = a2[2];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"res_attrs", 9, v6);
  v7 = a2[3];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"sym_name", 8, v7);
  v8 = a2[4];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"sym_visibility", 14, v8);
}

BOOL mlir::func::FuncOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8;
  const void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BOOL8 result;

  v8 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(v8, (const void **)"arg_attrs", (const char *)9, a3, a4))
  {
    v9 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::func::__mlir_ods_local_attr_constraint_FuncOps2(v9, (const void **)"function_type", (const char *)0xD, (void (*)(const void ***__return_ptr, uint64_t))a3, a4))
    {
      v10 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(v10, (const void **)"res_attrs", (const char *)9, a3, a4))
      {
        v11 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(v11, (const void **)"sym_name", (const char *)8, a3, a4))
        {
          v12 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(v12, (const void **)"sym_visibility", (const char *)0xE, a3, a4))
          {
            return 1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v9;
  char *v10;
  char *v11;
  __int128 v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t Value;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v31;
  unint64_t v32;
  int64_t v33;
  int64_t v34;
  const void **v35;
  const char *v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  unsigned int v42;
  unsigned int v43;
  _BYTE v44[96];
  void *v45;
  _QWORD *v46;
  void *__p;
  _QWORD *v48;
  char v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  if (*(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
  {
    v39 = a1;
    Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    v27 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    v29 = v27 + 8 * v28;
    if (v29 != Value)
    {
      while (*(_QWORD *)Value
           && *(_UNKNOWN **)(**(_QWORD **)Value + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
      {
        Value += 8;
        if (Value == v29)
          return 1;
      }
      goto LABEL_3;
    }
    return 1;
  }
LABEL_3:
  a4(&v39, a5);
  if (v39)
  {
    LODWORD(v35) = 3;
    v36 = "attribute '";
    v37 = 11;
    v9 = &v35;
    v10 = (char *)v41;
    if (v42 >= v43)
    {
      v31 = v42 + 1;
      if (v41 <= &v35 && (char *)v41 + 24 * v42 > (char *)&v35)
      {
        v33 = (char *)&v35 - (_BYTE *)v41;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        v10 = (char *)v41;
        v9 = (const void ***)((char *)v41 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        v9 = &v35;
        v10 = (char *)v41;
      }
    }
    v11 = &v10[24 * v42];
    v12 = *(_OWORD *)v9;
    *((_QWORD *)v11 + 2) = v9[2];
    *(_OWORD *)v11 = v12;
    ++v42;
    if (v39)
    {
      v38 = 261;
      v35 = a2;
      v36 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v40, &v35);
      if (v39)
      {
        LODWORD(v35) = 3;
        v36 = "' failed to satisfy constraint: Array of dictionary attributes";
        v37 = 62;
        v13 = &v35;
        v14 = (char *)v41;
        if (v42 >= v43)
        {
          v32 = v42 + 1;
          if (v41 <= &v35 && (char *)v41 + 24 * v42 > (char *)&v35)
          {
            v34 = (char *)&v35 - (_BYTE *)v41;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
            v14 = (char *)v41;
            v13 = (const void ***)((char *)v41 + v34);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
            v13 = &v35;
            v14 = (char *)v41;
          }
        }
        v15 = &v14[24 * v42];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = v13[2];
        *(_OWORD *)v15 = v16;
        ++v42;
      }
    }
  }
  v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v39);
  if (v39)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v39);
  if (v49)
  {
    v18 = __p;
    if (__p)
    {
      v19 = v48;
      v20 = __p;
      if (v48 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v48 = v18;
      operator delete(v20);
    }
    v21 = v45;
    if (v45)
    {
      v22 = v46;
      v23 = v45;
      if (v46 != v45)
      {
        do
        {
          v25 = *--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
            MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
        }
        while (v22 != v21);
        v23 = v45;
      }
      v46 = v21;
      operator delete(v23);
    }
    if (v41 != v44)
      free(v41);
  }
  return v17;
}

uint64_t mlir::func::__mlir_ods_local_attr_constraint_FuncOps2(const void **a1, const void **a2, const char *a3, void (*a4)(const void ***__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v10;
  char *v11;
  char *v12;
  __int128 v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v28;
  unint64_t v29;
  int64_t v30;
  int64_t v31;
  const void **v32;
  const char *v33;
  uint64_t v34;
  __int16 v35;
  const void **v36;
  uint64_t v37;
  void *v38;
  unsigned int v39;
  unsigned int v40;
  _BYTE v41[96];
  void *v42;
  _QWORD *v43;
  void *__p;
  _QWORD *v45;
  char v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  if (!a1)
    return 1;
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    v36 = a1;
    if (*(_UNKNOWN **)(*(_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v36) + 136) == &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
    {
      v32 = a1;
      if (*(_UNKNOWN **)(*(_QWORD *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v32) + 136) == &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
        return 1;
    }
  }
  a4(&v36, a5);
  if (v36)
  {
    LODWORD(v32) = 3;
    v33 = "attribute '";
    v34 = 11;
    v10 = &v32;
    v11 = (char *)v38;
    if (v39 >= v40)
    {
      v28 = v39 + 1;
      if (v38 <= &v32 && (char *)v38 + 24 * v39 > (char *)&v32)
      {
        v30 = (char *)&v32 - (_BYTE *)v38;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v41, v28, 24);
        v11 = (char *)v38;
        v10 = (const void ***)((char *)v38 + v30);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v41, v28, 24);
        v10 = &v32;
        v11 = (char *)v38;
      }
    }
    v12 = &v11[24 * v39];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = v10[2];
    *(_OWORD *)v12 = v13;
    ++v39;
    if (v36)
    {
      v35 = 261;
      v32 = a2;
      v33 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v37, &v32);
      if (v36)
      {
        LODWORD(v32) = 3;
        v33 = "' failed to satisfy constraint: type attribute of function type";
        v34 = 63;
        v14 = &v32;
        v15 = (char *)v38;
        if (v39 >= v40)
        {
          v29 = v39 + 1;
          if (v38 <= &v32 && (char *)v38 + 24 * v39 > (char *)&v32)
          {
            v31 = (char *)&v32 - (_BYTE *)v38;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v41, v29, 24);
            v15 = (char *)v38;
            v14 = (const void ***)((char *)v38 + v31);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v41, v29, 24);
            v14 = &v32;
            v15 = (char *)v38;
          }
        }
        v16 = &v15[24 * v39];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v39;
      }
    }
  }
  v18 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v36);
  if (v36)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v36);
  if (v46)
  {
    v19 = __p;
    if (__p)
    {
      v20 = v45;
      v21 = __p;
      if (v45 != __p)
      {
        do
          v20 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v20 - 1);
        while (v20 != v19);
        v21 = __p;
      }
      v45 = v19;
      operator delete(v21);
    }
    v22 = v42;
    if (v42)
    {
      v23 = v43;
      v24 = v42;
      if (v43 != v42)
      {
        do
        {
          v26 = *--v23;
          v25 = v26;
          *v23 = 0;
          if (v26)
            MEMORY[0x20BD002D4](v25, 0x1000C8077774924);
        }
        while (v23 != v22);
        v24 = v42;
      }
      v43 = v22;
      operator delete(v24);
    }
    if (v38 != v41)
      free(v38);
  }
  return v18;
}

uint64_t mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD *v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (!a1 || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    return 1;
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: string attribute";
        v31 = 48;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = __p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = *--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            MEMORY[0x20BD002D4](v22, 0x1000C8077774924);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  _QWORD *v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new();
    *(_OWORD *)v3 = 0u;
    *(_OWORD *)(v3 + 16) = 0u;
    *(_QWORD *)(v3 + 32) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::FuncOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::FuncOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &unk_25451B000;
    if ((v5 & 1) == 0)
    {
      v4 = (_QWORD *)&unk_25451B000;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::func::detail::FuncOpGenericAdaptorBase::Properties]";
        v15 = 106;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::func::detail::FuncOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = (_QWORD *)&unk_25451B000;
      }
    }
    a1[33] = v4[75];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::ArrayAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::ArrayAttr]";
  v41 = 65;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::TypeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::TypeAttr]";
  v41 = 64;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::StringAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD *v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::StringAttr]";
  v41 = 66;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = __p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = *--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            MEMORY[0x20BD002D4](v29, 0x1000C8077774924);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

BOOL mlir::func::FuncOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  const void **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  const void **v28[4];
  __int16 v29;
  _QWORD v30[3];
  void *v31;
  _BYTE v32[96];
  void *v33;
  _QWORD *v34;
  void *__p;
  _QWORD *v36;
  char v37;
  uint64_t v38;

  v38 = *MEMORY[0x24BDAC8D0];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = (const void **)v3[1];
  if (v4)
  {
    v5 = v3[3];
    if (v5)
    {
      v6 = *v3;
      v7 = v3[2];
      v8 = v3[4];
      v30[0] = v2;
      if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(v5, (const void **)"sym_name", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0;
      v30[0] = *this;
      if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps2(v4, (const void **)"function_type", (const char *)0xD, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0;
      v30[0] = *this;
      if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(v8, (const void **)"sym_visibility", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0;
      v30[0] = *this;
      if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(v6, (const void **)"arg_attrs", (const char *)9, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0;
      v30[0] = *this;
      return mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(v7, (const void **)"res_attrs", (const char *)9, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30) != 0;
    }
    v28[0] = (const void **)"requires attribute 'sym_name'";
    v29 = 259;
    mlir::OpState::emitOpError(this, v28, (uint64_t)v30);
    v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v30);
    if (v30[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v30);
    if (v37)
    {
      v18 = __p;
      if (__p)
      {
        v19 = v36;
        v20 = __p;
        if (v36 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v36 = v18;
        operator delete(v20);
      }
      v21 = v33;
      if (v33)
      {
        v22 = v34;
        v23 = v33;
        if (v34 != v33)
        {
          do
          {
            v25 = *--v22;
            v24 = v25;
            *v22 = 0;
            if (v25)
              MEMORY[0x20BD002D4](v24, 0x1000C8077774924);
          }
          while (v22 != v21);
          v23 = v33;
        }
        v34 = v21;
        operator delete(v23);
      }
      v26 = v31;
      if (v31 != v32)
LABEL_47:
        free(v26);
    }
  }
  else
  {
    v28[0] = (const void **)"requires attribute 'function_type'";
    v29 = 259;
    mlir::OpState::emitOpError(this, v28, (uint64_t)v30);
    v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v30);
    if (v30[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v30);
    if (v37)
    {
      v10 = __p;
      if (__p)
      {
        v11 = v36;
        v12 = __p;
        if (v36 != __p)
        {
          do
            v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
          while (v11 != v10);
          v12 = __p;
        }
        v36 = v10;
        operator delete(v12);
      }
      v13 = v33;
      if (v33)
      {
        v14 = v34;
        v15 = v33;
        if (v34 != v33)
        {
          do
          {
            v17 = *--v14;
            v16 = v17;
            *v14 = 0;
            if (v17)
              MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
          }
          while (v14 != v13);
          v15 = v33;
        }
        v34 = v13;
        operator delete(v15);
      }
      v26 = v31;
      if (v31 != v32)
        goto LABEL_47;
    }
  }
  return v9;
}

BOOL mlir::func::ReturnOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 v5;
  void *v6;
  void *v8[2];
  uint64_t v9;
  void *v10;
  uint64_t v11;
  _QWORD v12[17];

  v12[16] = *MEMORY[0x24BDAC8D0];
  v10 = v12;
  v11 = 0x400000000;
  v8[0] = &v9;
  v8[1] = (void *)0x100000000;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 456))(a1, a2 + 112)
    || (v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1),
        !(*(unsigned __int8 (**)(uint64_t, void **, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 688))(a1, &v10, 0, 1, 0xFFFFFFFFLL))|| (_DWORD)v11&& (!(*(unsigned __int8 (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1)|| !mlir::AsmParser::parseTypeList(a1, (uint64_t)v8)))
  {
    v5 = 0;
    v6 = v8[0];
    if (v8[0] == &v9)
      goto LABEL_10;
    goto LABEL_9;
  }
  v5 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>(a1, (uint64_t *)&v10, (uint64_t)v8, v4, a2 + 16) != 0;
  v6 = v8[0];
  if (v8[0] != &v9)
LABEL_9:
    free(v6);
LABEL_10:
  if (v10 != v12)
    free(v10);
  return v5;
}

void mlir::func::ReturnOp::print(mlir::func::ReturnOp *this, mlir::OpAsmPrinter *a2)
{
  _BYTE *v4;
  mlir::ArrayAttr *p_AttrDictionary;
  uint64_t Value;
  uint64_t v7;
  llvm::raw_ostream *v8;
  _BYTE *v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  llvm::raw_ostream *v13;
  llvm::raw_ostream *v14;
  _BYTE *v15;
  llvm::raw_ostream *v16;
  _BYTE *v17;
  llvm::raw_ostream *v18;
  _BYTE *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23[2];
  const char *AttrDictionary;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[2];
  void *v29;
  uint64_t v30;
  _QWORD v31[5];

  v31[4] = *MEMORY[0x24BDAC8D0];
  v29 = v31;
  v30 = 0x200000000;
  v4 = *(_BYTE **)this;
  if (v4[47])
  {
    AttrDictionary = (const char *)mlir::Operation::getAttrDictionary((mlir::Operation *)v4);
    p_AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_AttrDictionary = (mlir::ArrayAttr *)(v4 + 56);
  }
  Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, _QWORD))(*(_QWORD *)a2 + 192))(a2, Value, v7, v29, v30);
  if ((*(_BYTE *)(*(_QWORD *)this + 46) & 0x80) != 0 && *(_DWORD *)(*(_QWORD *)this + 68))
  {
    v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v9 = (_BYTE *)*((_QWORD *)v8 + 4);
    if ((unint64_t)v9 >= *((_QWORD *)v8 + 3))
    {
      llvm::raw_ostream::write(v8, 32);
    }
    else
    {
      *((_QWORD *)v8 + 4) = v9 + 1;
      *v9 = 32;
    }
    v10 = *(_BYTE **)this;
    if ((*(_BYTE *)(*(_QWORD *)this + 46) & 0x80) != 0)
    {
      v11 = *((unsigned int *)v10 + 17);
      v12 = *((_QWORD *)v10 + 9);
    }
    else
    {
      v12 = 0;
      v11 = 0;
    }
    v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    AttrDictionary = ", ";
    v25 = 2;
    llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v12, 0, v12, v11, (uint64_t)a2, v13, (uint64_t)&AttrDictionary);
    v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v15 = (_BYTE *)*((_QWORD *)v14 + 4);
    if ((unint64_t)v15 >= *((_QWORD *)v14 + 3))
    {
      llvm::raw_ostream::write(v14, 32);
    }
    else
    {
      *((_QWORD *)v14 + 4) = v15 + 1;
      *v15 = 32;
    }
    v16 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v17 = (_BYTE *)*((_QWORD *)v16 + 4);
    if (*((_BYTE **)v16 + 3) == v17)
    {
      llvm::raw_ostream::write(v16, ":", 1uLL);
    }
    else
    {
      *v17 = 58;
      ++*((_QWORD *)v16 + 4);
    }
    v18 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
    v19 = (_BYTE *)*((_QWORD *)v18 + 4);
    if ((unint64_t)v19 >= *((_QWORD *)v18 + 3))
    {
      llvm::raw_ostream::write(v18, 32);
    }
    else
    {
      *((_QWORD *)v18 + 4) = v19 + 1;
      *v19 = 32;
    }
    v20 = *(_QWORD *)this;
    if ((*(_BYTE *)(*(_QWORD *)this + 46) & 0x80) != 0)
    {
      v21 = *(unsigned int *)(v20 + 68);
      v22 = *(_QWORD *)(v20 + 72);
    }
    else
    {
      v22 = 0;
      v21 = 0;
    }
    v23[0] = v22;
    v23[1] = v21;
    mlir::OperandRange::getTypes(v23, (uint64_t *)&AttrDictionary);
    v28[0] = ", ";
    v28[1] = 2;
    llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::OperandRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &,mlir::OpAsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>((uint64_t)AttrDictionary, v25, v26, v27, (uint64_t)a2, (uint64_t)a2, (uint64_t)v28);
  }
  if (v29 != v31)
    free(v29);
}

void std::__optional_destruct_base<mlir::Diagnostic,false>::reset[abi:nn180100](uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;

  if (*(_BYTE *)(a1 + 176))
  {
    v2 = *(_QWORD **)(a1 + 152);
    if (v2)
    {
      v3 = *(_QWORD **)(a1 + 160);
      v4 = v2;
      if (v3 != v2)
      {
        do
          v3 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v3 - 1);
        while (v3 != v2);
        v4 = *(void **)(a1 + 152);
      }
      *(_QWORD *)(a1 + 160) = v2;
      operator delete(v4);
    }
    v5 = *(_QWORD **)(a1 + 128);
    if (v5)
    {
      v6 = *(_QWORD **)(a1 + 136);
      v7 = *(void **)(a1 + 128);
      if (v6 != v5)
      {
        do
        {
          v9 = *--v6;
          v8 = v9;
          *v6 = 0;
          if (v9)
            MEMORY[0x20BD002D4](v8, 0x1000C8077774924);
        }
        while (v6 != v5);
        v7 = *(void **)(a1 + 128);
      }
      *(_QWORD *)(a1 + 136) = v5;
      operator delete(v7);
    }
    v10 = *(void **)(a1 + 16);
    if (v10 != (void *)(a1 + 32))
      free(v10);
    *(_BYTE *)(a1 + 176) = 0;
  }
}

uint64_t llvm::SmallVectorImpl<mlir::DiagnosticArgument>::operator=(uint64_t a1, uint64_t a2)
{
  const void *v4;
  const void *v5;
  void *v6;
  _DWORD *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (a1 != a2)
  {
    v5 = (const void *)(a2 + 16);
    v4 = *(const void **)a2;
    if (v4 != v5)
    {
      v6 = *(void **)a1;
      if (*(_QWORD *)a1 != a1 + 16)
      {
        free(v6);
        v4 = *(const void **)a2;
      }
      *(_QWORD *)a1 = v4;
      v7 = (_DWORD *)(a2 + 8);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
      *(_QWORD *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
      goto LABEL_16;
    }
    v7 = (_DWORD *)(a2 + 8);
    v8 = *(unsigned int *)(a2 + 8);
    v9 = *(unsigned int *)(a1 + 8);
    if (v9 >= v8)
    {
      if ((_DWORD)v8)
        memmove(*(void **)a1, v4, 24 * v8);
      goto LABEL_15;
    }
    if (*(_DWORD *)(a1 + 12) >= v8)
    {
      if ((_DWORD)v9)
      {
        memmove(*(void **)a1, v4, 24 * v9);
        v10 = *v7;
        if (v9 == v10)
        {
LABEL_15:
          *(_DWORD *)(a1 + 8) = v8;
LABEL_16:
          *v7 = 0;
          return a1;
        }
      }
      else
      {
        v9 = 0;
        LODWORD(v10) = *v7;
        if (!*v7)
          goto LABEL_15;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v8, 24);
      v9 = 0;
      LODWORD(v10) = *v7;
      if (!*v7)
        goto LABEL_15;
    }
    memcpy((void *)(*(_QWORD *)a1 + 24 * v9), (const void *)(*(_QWORD *)a2 + 24 * v9), *(_QWORD *)a2 + 24 * v10 - (*(_QWORD *)a2 + 24 * v9));
    goto LABEL_15;
  }
  return a1;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t *v2;
  const void **v3;
  __int16 v4;

  v2 = *a1;
  v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

uint64_t mlir::RegisteredOperationName::insert<mlir::func::CallIndirectOp>(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  void **v5;
  void *v6;
  uint64_t result;
  _QWORD *v8;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v2 = (_QWORD *)operator new();
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"func.call_indirect", 18, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::CallIndirectOp,void>::id, (uint64_t)&v9);
  v3 = v9;
  if ((_DWORD)v10)
  {
    v4 = 16 * v10;
    v5 = (void **)((char *)v9 + 8);
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v3 = v9;
  }
  if (v3 != v11)
    free(v3);
  *v2 = &unk_24C047098;
  v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  result = (uint64_t)v8;
  v8 = 0;
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = (_QWORD *)operator new();
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"func.call_indirect", 18, v3, v4, 0, 0);
  *v5 = &off_24C05E1D0;
  v5[12] = mlir::func::CallIndirectOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::func::CallIndirectOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getCallableForCallee;
  v2[1] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::setCalleeFromCallable;
  v2[2] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getArgOperands;
  v2[3] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getArgOperandsMutable;
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_254519000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallOpInterface]";
      v15 = 71;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CallOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_254519000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[389], v2);
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getCallableForCallee(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(*(_QWORD *)(a2 + 72) + 24) | 4;
}

void mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::setCalleeFromCallable(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t *v5;
  uint64_t v6;

  v3 = (uint64_t *)(a3 & 0xFFFFFFFFFFFFFFF8);
  v4 = *(uint64_t **)(a2 + 72);
  v5 = (uint64_t *)v4[1];
  if (v5)
  {
    *v5 = *v4;
    if (*v4)
      *(_QWORD *)(*v4 + 8) = v4[1];
  }
  v4[3] = (uint64_t)v3;
  v6 = *v3;
  *v4 = *v3;
  v4[1] = (uint64_t)v3;
  if (v6)
    *(_QWORD *)(v6 + 8) = v4;
  *v3 = (uint64_t)v4;
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getArgOperands(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    return *(_QWORD *)(a2 + 72) + 32;
  else
    return 32;
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getArgOperandsMutable@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  int v2;

  if ((*(_BYTE *)(a1 + 46) & 0x80) != 0)
    v2 = *(_DWORD *)(a1 + 68) - 1;
  else
    v2 = -1;
  return mlir::MutableOperandRange::MutableOperandRange(a2, a1, 1, v2, 0, 0);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  int v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  const char *v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  unint64_t v35;
  unint64_t v36;
  const char *v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  unint64_t v44;
  unint64_t v45;
  const char *v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  unint64_t v53;
  unint64_t v54;
  const char *v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  unint64_t v62;
  unint64_t v63;
  const char *v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  unint64_t v71;
  unint64_t v72;
  const char *v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  const char *v99;
  unint64_t v100;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v93 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v25 = v24;
    a1 = v93;
    if (v25)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v100 = 83;
      v26 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v26)
        v27 = v26;
      else
        v27 = v100;
      v28 = &v99[v27];
      v29 = v100 - v27;
      if (v100 - v27 >= 0x12)
        v30 = 18;
      else
        v30 = v100 - v27;
      v31 = v29 - v30;
      if (v31 >= v31 - 1)
        v32 = v31 - 1;
      else
        v32 = v31;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v28[v30], v32);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v93;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v88 = v3;
    v94 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v34 = v33;
    v3 = v88;
    a1 = v94;
    if (v34)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicResults<Empty>]";
      v100 = 87;
      v35 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v35)
        v36 = v35;
      else
        v36 = v100;
      v37 = &v99[v36];
      v38 = v100 - v36;
      if (v100 - v36 >= 0x12)
        v39 = 18;
      else
        v39 = v100 - v36;
      v40 = v38 - v39;
      if (v40 >= v40 - 1)
        v41 = v40 - 1;
      else
        v41 = v40;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v37[v39], v41);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v88;
      a1 = v94;
    }
  }
  v6 = v5[427];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v89 = v3;
    v95 = a1;
    v84 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v84;
    v3 = v89;
    v43 = v42;
    a1 = v95;
    if (v43)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v100 = 86;
      v44 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v44)
        v45 = v44;
      else
        v45 = v100;
      v46 = &v99[v45];
      v47 = v100 - v45;
      if (v100 - v45 >= 0x12)
        v48 = 18;
      else
        v48 = v100 - v45;
      v49 = v47 - v48;
      if (v49 >= v49 - 1)
        v50 = v49 - 1;
      else
        v50 = v49;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v84;
      v3 = v89;
      a1 = v95;
    }
  }
  v9 = v8[419];
  v11 = &unk_25451A000;
  if ((v10 & 1) == 0)
  {
    v90 = v3;
    v96 = a1;
    v81 = v9;
    v85 = v6;
    v11 = (_QWORD *)&unk_25451A000;
    v9 = v81;
    v6 = v85;
    v52 = v51;
    v3 = v90;
    a1 = v96;
    if (v52)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>]";
      v100 = 97;
      v53 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v53)
        v54 = v53;
      else
        v54 = v100;
      v55 = &v99[v54];
      v56 = v100 - v54;
      if (v100 - v54 >= 0x12)
        v57 = 18;
      else
        v57 = v100 - v54;
      v58 = v56 - v57;
      if (v58 >= v58 - 1)
        v59 = v58 - 1;
      else
        v59 = v58;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      v11 = (_QWORD *)&unk_25451A000;
      v9 = v81;
      v6 = v85;
      v3 = v90;
      a1 = v96;
    }
  }
  v12 = v11[423];
  v14 = &unk_254519000;
  if ((v13 & 1) == 0)
  {
    v91 = v3;
    v97 = a1;
    v82 = v9;
    v86 = v6;
    v79 = v12;
    v14 = (_QWORD *)&unk_254519000;
    v12 = v79;
    v9 = v82;
    v6 = v86;
    v3 = v91;
    v61 = v60;
    a1 = v97;
    if (v61)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v100 = 84;
      v62 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v62)
        v63 = v62;
      else
        v63 = v100;
      v64 = &v99[v63];
      v65 = v100 - v63;
      if (v100 - v63 >= 0x12)
        v66 = 18;
      else
        v66 = v100 - v63;
      v67 = v65 - v66;
      if (v67 >= v67 - 1)
        v68 = v67 - 1;
      else
        v68 = v67;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      v14 = (_QWORD *)&unk_254519000;
      v12 = v79;
      v9 = v82;
      v6 = v86;
      v3 = v91;
      a1 = v97;
    }
  }
  v15 = v14[423];
  v17 = &unk_25451B000;
  if ((v16 & 1) == 0)
  {
    v92 = v3;
    v98 = a1;
    v83 = v9;
    v87 = v6;
    v78 = v15;
    v80 = v12;
    v17 = (_QWORD *)&unk_25451B000;
    v15 = v78;
    v12 = v80;
    v9 = v83;
    v6 = v87;
    v70 = v69;
    v3 = v92;
    a1 = v98;
    if (v70)
    {
      v99 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallOpInterface::Trait<Empty>]";
      v100 = 85;
      v71 = llvm::StringRef::find((uint64_t *)&v99, "DesiredTypeName = ", 0x12uLL, 0);
      if (v100 >= v71)
        v72 = v71;
      else
        v72 = v100;
      v73 = &v99[v72];
      v74 = v100 - v72;
      if (v100 - v72 >= 0x12)
        v75 = 18;
      else
        v75 = v100 - v72;
      v76 = v74 - v75;
      if (v76 >= v76 - 1)
        v77 = v76 - 1;
      else
        v77 = v76;
      mlir::detail::TypeIDResolver<mlir::CallOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      v17 = (_QWORD *)&unk_25451B000;
      v15 = v78;
      v12 = v80;
      v9 = v83;
      v6 = v87;
      v3 = v92;
      a1 = v98;
    }
  }
  return v3 == a1 || v6 == a1 || v9 == a1 || v12 == a1 || v15 == a1 || v17[41] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::func::CallIndirectOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::OpTrait::impl *v5;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3)
    || !mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)1))
  {
    return 0;
  }
  v5 = a1;
  return mlir::func::CallIndirectOp::verifyInvariantsImpl((uint64_t **)&v5) != 0;
}

uint64_t mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::func::CallOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolUserOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"func.call", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::CallOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C047160;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::CallOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::getParseAssemblyFn(_QWORD *a1@<X8>)
{
  *a1 = mlir::func::CallOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 6 && (*(_DWORD *)a3 == 1819042147 ? (v7 = *(unsigned __int16 *)(a3 + 4) == 25957) : (v7 = 0), v7))
    return *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v11 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v11);
  if (v7 == 6 && *(_DWORD *)result == 1819042147 && *(_WORD *)(result + 4) == 25957)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
        v9 = a4;
      else
        v9 = 0;
      v12 = v9;
      if (v9)
      {
        result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
        if (v10)
          v9 = 0;
        else
          v9 = a4;
      }
      *v5 = v9;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v5 = *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"callee", 6, v5);
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::CallOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;

  v7 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  return !v7
      || mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v7, (const void **)"callee", (const char *)6, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::func::CallOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::func::CallOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::CallOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::FlatSymbolRefAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getCallableForCallee;
  v2[1] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::setCalleeFromCallable;
  v2[2] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getArgOperands;
  v2[3] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getArgOperandsMutable;
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_254519000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallOpInterface]";
      v15 = 71;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CallOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_254519000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[389], v2);
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getCallableForCallee(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  char v4;

  if (!*(_BYTE *)(a2 + 47) || (result = mlir::Operation::getInherentAttr(a2, (uint64_t)"callee", 6), !v4))
    result = mlir::DictionaryAttr::get(a2 + 56, "callee", 6uLL);
  if (result)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)result + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
      return result & 0xFFFFFFFFFFFFFFFBLL;
    else
      return 0;
  }
  return result;
}

void mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::setCalleeFromCallable(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  mlir::StringAttr *Context;
  uint64_t v6;
  _QWORD v7[4];
  __int16 v8;

  v4 = a3 & 0xFFFFFFFFFFFFFFF8;
  Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v8 = 261;
  v7[0] = "callee";
  v7[1] = 6;
  v6 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v7);
  mlir::Operation::setAttr(a2, v6, v4);
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getArgOperands(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
    return *(_QWORD *)(a2 + 72);
  else
    return 0;
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getArgOperandsMutable@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  int v2;

  if ((*(_BYTE *)(a1 + 46) & 0x80) != 0)
    v2 = *(_DWORD *)(a1 + 68);
  else
    v2 = 0;
  return mlir::MutableOperandRange::MutableOperandRange(a2, a1, 0, v2, 0, 0);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolUserOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::SymbolUserOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::verifySymbolUses;
  v4 = &unk_25451B000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451B000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SymbolUserOpInterface]";
      v15 = 77;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::SymbolUserOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451B000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[43], v2);
}

uint64_t mlir::detail::SymbolUserOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::verifySymbolUses(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::func::CallOp::verifySymbolUses(&v4, a3);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  int v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  const char *v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  const char *v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unint64_t v56;
  unint64_t v57;
  const char *v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  unint64_t v65;
  unint64_t v66;
  const char *v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  unint64_t v74;
  unint64_t v75;
  const char *v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  unint64_t v83;
  unint64_t v84;
  const char *v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  unint64_t v92;
  unint64_t v93;
  const char *v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  unint64_t v101;
  unint64_t v102;
  const char *v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  unint64_t v110;
  unint64_t v111;
  const char *v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  const char *v162;
  unint64_t v163;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v153 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v37 = v36;
    a1 = v153;
    if (v37)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v163 = 83;
      v38 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v38)
        v39 = v38;
      else
        v39 = v163;
      v40 = &v162[v39];
      v41 = v163 - v39;
      if (v163 - v39 >= 0x12)
        v42 = 18;
      else
        v42 = v163 - v39;
      v43 = v41 - v42;
      if (v43 >= v43 - 1)
        v44 = v43 - 1;
      else
        v44 = v43;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v153;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v145 = v3;
    v154 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v46 = v45;
    v3 = v145;
    a1 = v154;
    if (v46)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicResults<Empty>]";
      v163 = 87;
      v47 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v47)
        v48 = v47;
      else
        v48 = v163;
      v49 = &v162[v48];
      v50 = v163 - v48;
      if (v163 - v48 >= 0x12)
        v51 = 18;
      else
        v51 = v163 - v48;
      v52 = v50 - v51;
      if (v52 >= v52 - 1)
        v53 = v52 - 1;
      else
        v53 = v52;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v145;
      a1 = v154;
    }
  }
  v6 = v5[427];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v146 = v3;
    v155 = a1;
    v138 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v138;
    v55 = v54;
    v3 = v146;
    a1 = v155;
    if (v55)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v163 = 86;
      v56 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v56)
        v57 = v56;
      else
        v57 = v163;
      v58 = &v162[v57];
      v59 = v163 - v57;
      if (v163 - v57 >= 0x12)
        v60 = 18;
      else
        v60 = v163 - v57;
      v61 = v59 - v60;
      if (v61 >= v61 - 1)
        v62 = v61 - 1;
      else
        v62 = v61;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v138;
      v3 = v146;
      a1 = v155;
    }
  }
  v9 = v8[419];
  v11 = &unk_25451A000;
  if ((v10 & 1) == 0)
  {
    v147 = v3;
    v156 = a1;
    v132 = v9;
    v139 = v6;
    v11 = (_QWORD *)&unk_25451A000;
    v9 = v132;
    v6 = v139;
    v64 = v63;
    v3 = v147;
    a1 = v156;
    if (v64)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicOperands<Empty>]";
      v163 = 88;
      v65 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v65)
        v66 = v65;
      else
        v66 = v163;
      v67 = &v162[v66];
      v68 = v163 - v66;
      if (v163 - v66 >= 0x12)
        v69 = 18;
      else
        v69 = v163 - v66;
      v70 = v68 - v69;
      if (v70 >= v70 - 1)
        v71 = v70 - 1;
      else
        v71 = v70;
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      v11 = (_QWORD *)&unk_25451A000;
      v9 = v132;
      v6 = v139;
      v3 = v147;
      a1 = v156;
    }
  }
  v12 = v11[73];
  v14 = &unk_254519000;
  if ((v13 & 1) == 0)
  {
    v148 = v3;
    v157 = a1;
    v133 = v9;
    v140 = v6;
    v127 = v12;
    v14 = (_QWORD *)&unk_254519000;
    v12 = v127;
    v9 = v133;
    v6 = v140;
    v73 = v72;
    v3 = v148;
    a1 = v157;
    if (v73)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v163 = 84;
      v74 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v74)
        v75 = v74;
      else
        v75 = v163;
      v76 = &v162[v75];
      v77 = v163 - v75;
      if (v163 - v75 >= 0x12)
        v78 = 18;
      else
        v78 = v163 - v75;
      v79 = v77 - v78;
      if (v79 >= v79 - 1)
        v80 = v79 - 1;
      else
        v80 = v79;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      v14 = (_QWORD *)&unk_254519000;
      v12 = v127;
      v9 = v133;
      v6 = v140;
      v3 = v148;
      a1 = v157;
    }
  }
  v15 = v14[423];
  v17 = &unk_25451A000;
  if ((v16 & 1) == 0)
  {
    v149 = v3;
    v158 = a1;
    v134 = v9;
    v141 = v6;
    v123 = v15;
    v128 = v12;
    v17 = (_QWORD *)&unk_25451A000;
    v15 = v123;
    v12 = v128;
    v9 = v134;
    v6 = v141;
    v82 = v81;
    v3 = v149;
    a1 = v158;
    if (v82)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v163 = 89;
      v83 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v83)
        v84 = v83;
      else
        v84 = v163;
      v85 = &v162[v84];
      v86 = v163 - v84;
      if (v163 - v84 >= 0x12)
        v87 = 18;
      else
        v87 = v163 - v84;
      v88 = v86 - v87;
      if (v88 >= v88 - 1)
        v89 = v88 - 1;
      else
        v89 = v88;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      v17 = (_QWORD *)&unk_25451A000;
      v15 = v123;
      v12 = v128;
      v9 = v134;
      v6 = v141;
      v3 = v149;
      a1 = v158;
    }
  }
  v18 = v17[310];
  v20 = &unk_25451B000;
  if ((v19 & 1) == 0)
  {
    v150 = v3;
    v159 = a1;
    v135 = v9;
    v142 = v6;
    v124 = v15;
    v129 = v12;
    v120 = v18;
    v20 = (_QWORD *)&unk_25451B000;
    v18 = v120;
    v15 = v124;
    v12 = v129;
    v9 = v135;
    v6 = v142;
    v91 = v90;
    v3 = v150;
    a1 = v159;
    if (v91)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallOpInterface::Trait<Empty>]";
      v163 = 85;
      v92 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v92)
        v93 = v92;
      else
        v93 = v163;
      v94 = &v162[v93];
      v95 = v163 - v93;
      if (v163 - v93 >= 0x12)
        v96 = 18;
      else
        v96 = v163 - v93;
      v97 = v95 - v96;
      if (v97 >= v97 - 1)
        v98 = v97 - 1;
      else
        v98 = v97;
      mlir::detail::TypeIDResolver<mlir::CallOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      v20 = (_QWORD *)&unk_25451B000;
      v18 = v120;
      v15 = v124;
      v12 = v129;
      v9 = v135;
      v6 = v142;
      v3 = v150;
      a1 = v159;
    }
  }
  v21 = v20[41];
  v23 = &unk_25451B000;
  if ((v22 & 1) == 0)
  {
    v151 = v3;
    v160 = a1;
    v136 = v9;
    v143 = v6;
    v125 = v15;
    v130 = v12;
    v118 = v21;
    v121 = v18;
    v23 = (_QWORD *)&unk_25451B000;
    v21 = v118;
    v18 = v121;
    v15 = v125;
    v12 = v130;
    v9 = v136;
    v6 = v143;
    v100 = v99;
    v3 = v151;
    a1 = v160;
    if (v100)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::MemRefsNormalizable<Empty>]";
      v163 = 91;
      v101 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v101)
        v102 = v101;
      else
        v102 = v163;
      v103 = &v162[v102];
      v104 = v163 - v102;
      if (v163 - v102 >= 0x12)
        v105 = 18;
      else
        v105 = v163 - v102;
      v106 = v104 - v105;
      if (v106 >= v106 - 1)
        v107 = v106 - 1;
      else
        v107 = v106;
      mlir::detail::TypeIDResolver<mlir::OpTrait::MemRefsNormalizable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::MemRefsNormalizable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      v23 = (_QWORD *)&unk_25451B000;
      v21 = v118;
      v18 = v121;
      v15 = v125;
      v12 = v130;
      v9 = v136;
      v6 = v143;
      v3 = v151;
      a1 = v160;
    }
  }
  v24 = v23[45];
  v26 = &unk_25451B000;
  if ((v25 & 1) == 0)
  {
    v152 = v3;
    v161 = a1;
    v137 = v9;
    v144 = v6;
    v126 = v15;
    v131 = v12;
    v119 = v21;
    v122 = v18;
    v117 = v24;
    v26 = (_QWORD *)&unk_25451B000;
    v24 = v117;
    v21 = v119;
    v18 = v122;
    v15 = v126;
    v12 = v131;
    v9 = v137;
    v6 = v144;
    v109 = v108;
    v3 = v152;
    a1 = v161;
    if (v109)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SymbolUserOpInterface::Trait<Empty>]";
      v163 = 91;
      v110 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v110)
        v111 = v110;
      else
        v111 = v163;
      v112 = &v162[v111];
      v113 = v163 - v111;
      if (v163 - v111 >= 0x12)
        v114 = 18;
      else
        v114 = v163 - v111;
      v115 = v113 - v114;
      if (v115 >= v115 - 1)
        v116 = v115 - 1;
      else
        v116 = v115;
      mlir::detail::TypeIDResolver<mlir::SymbolUserOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolUserOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      v26 = (_QWORD *)&unk_25451B000;
      v24 = v117;
      v21 = v119;
      v18 = v122;
      v15 = v126;
      v12 = v131;
      v9 = v137;
      v6 = v144;
      v3 = v152;
      a1 = v161;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v26[47] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v7;

  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::func::CallOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::OpTrait::impl *v5;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3))
  {
    return 0;
  }
  v5 = a1;
  return mlir::func::CallOp::verifyInvariantsImpl((uint64_t **)&v5) != 0;
}

uint64_t mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"func.constant", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::ConstantOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C046FD0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  char v6;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::func::ConstantOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  mlir::OpAsmPrinter *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                    + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 5 && (*(_DWORD *)a3 == 1970037110 ? (v7 = *(_BYTE *)(a3 + 4) == 101) : (v7 = 0), v7))
    return *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v11 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v11);
  if (v7 == 5 && *(_DWORD *)result == 1970037110 && *(_BYTE *)(result + 4) == 101)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id)
        v9 = a4;
      else
        v9 = 0;
      v12 = v9;
      if (v9)
      {
        result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
        if (v10)
          v9 = 0;
        else
          v9 = a4;
      }
      *v5 = v9;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v5 = *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"value", 5, v5);
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;

  v7 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  return !v7
      || mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v7, (const void **)"value", (const char *)5, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::func::ConstantOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::arith::ConstantOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::FlatSymbolRefAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ConstantOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ConstantOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getEffects;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[1], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  return a3(a4, a2 - 16, "f", 1);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getDefaultDialect()
{
  return &byte_207AF6795;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldSingleResultHook<mlir::func::ConstantOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldSingleResultHook<mlir::func::ConstantOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t Context;
  unint64_t v15;
  uint64_t v16;
  uint64_t v18;
  _BYTE v19[8];
  char v20;
  uint64_t v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25[3];
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  v10 = a1 + 64;
  v11 = (uint64_t *)(a1 + 64 + 16 * ((v9 >> 23) & 1));
  v12 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v13 = (((unint64_t)v11 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v13 = 0;
    v12 = 0;
  }
  mlir::ValueRange::ValueRange(v25, v13, v12);
  v18 = v8;
  v19[0] = 0;
  v20 = 0;
  v21 = *v11;
  v22 = *(_OWORD *)v25;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v18);
    if (v20)
      v20 = 0;
    mlir::OperationName::OperationName(v19, "func.constant", 13, Context);
    v20 = 1;
  }
  v23 = a2;
  v24 = a3;
  v15 = *(_QWORD *)(v10 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1)) & 0xFFFFFFFFFFFFFFFBLL;
  if (v15 < 8)
    return 0;
  v16 = *(unsigned int *)(a4 + 8);
  if (v16 >= *(_DWORD *)(a4 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v16 + 1, 8);
    LODWORD(v16) = *(_DWORD *)(a4 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a4 + 8 * v16) = v15;
  ++*(_DWORD *)(a4 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  const char *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  const char *v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  unint64_t v86;
  unint64_t v87;
  const char *v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  const char *v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  const char *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unint64_t v113;
  unint64_t v114;
  const char *v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  unint64_t v122;
  unint64_t v123;
  const char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  int v129;
  int v130;
  unint64_t v131;
  unint64_t v132;
  const char *v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  const char *v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  const char *v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  const char *v234;
  unint64_t v235;

  v2 = &unk_25451A000;
  if ((v1 & 1) == 0)
  {
    v222 = a1;
    v2 = (_QWORD *)&unk_25451A000;
    v49 = v48;
    a1 = v222;
    if (v49)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v235 = 83;
      v50 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v50)
        v51 = v50;
      else
        v51 = v235;
      v52 = &v234[v51];
      v53 = v235 - v51;
      if (v235 - v51 >= 0x12)
        v54 = 18;
      else
        v54 = v235 - v51;
      v55 = v53 - v54;
      if (v55 >= v55 - 1)
        v56 = v55 - 1;
      else
        v56 = v55;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      v2 = (_QWORD *)&unk_25451A000;
      a1 = v222;
    }
  }
  v3 = v2[13];
  v5 = &unk_25451A000;
  if ((v4 & 1) == 0)
  {
    v211 = v3;
    v223 = a1;
    v5 = (_QWORD *)&unk_25451A000;
    v58 = v57;
    v3 = v211;
    a1 = v223;
    if (v58)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v235 = 81;
      v59 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v59)
        v60 = v59;
      else
        v60 = v235;
      v61 = &v234[v60];
      v62 = v235 - v60;
      if (v235 - v60 >= 0x12)
        v63 = 18;
      else
        v63 = v235 - v60;
      v64 = v62 - v63;
      if (v64 >= v64 - 1)
        v65 = v64 - 1;
      else
        v65 = v64;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      v5 = (_QWORD *)&unk_25451A000;
      v3 = v211;
      a1 = v223;
    }
  }
  v6 = v5[15];
  v8 = &unk_25451A000;
  if ((v7 & 1) == 0)
  {
    v212 = v3;
    v224 = a1;
    v201 = v6;
    v8 = (_QWORD *)&unk_25451A000;
    v6 = v201;
    v3 = v212;
    v67 = v66;
    a1 = v224;
    if (v67)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v235 = 104;
      v68 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v68)
        v69 = v68;
      else
        v69 = v235;
      v70 = &v234[v69];
      v71 = v235 - v69;
      if (v235 - v69 >= 0x12)
        v72 = 18;
      else
        v72 = v235 - v69;
      v73 = v71 - v72;
      if (v73 >= v73 - 1)
        v74 = v73 - 1;
      else
        v74 = v73;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      v8 = (_QWORD *)&unk_25451A000;
      v6 = v201;
      v3 = v212;
      a1 = v224;
    }
  }
  v9 = v8[308];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v213 = v3;
    v225 = a1;
    v202 = v6;
    v192 = v9;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v192;
    v6 = v202;
    v3 = v213;
    v76 = v75;
    a1 = v225;
    if (v76)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v235 = 86;
      v77 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v77)
        v78 = v77;
      else
        v78 = v235;
      v79 = &v234[v78];
      v80 = v235 - v78;
      if (v235 - v78 >= 0x12)
        v81 = 18;
      else
        v81 = v235 - v78;
      v82 = v80 - v81;
      if (v82 >= v82 - 1)
        v83 = v82 - 1;
      else
        v83 = v82;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v192;
      v6 = v202;
      v3 = v213;
      a1 = v225;
    }
  }
  v12 = v11[419];
  v14 = &unk_254519000;
  if ((v13 & 1) == 0)
  {
    v214 = v3;
    v226 = a1;
    v203 = v6;
    v184 = v12;
    v193 = v9;
    v14 = (_QWORD *)&unk_254519000;
    v12 = v184;
    v9 = v193;
    v6 = v203;
    v3 = v214;
    v85 = v84;
    a1 = v226;
    if (v85)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroOperands<Empty>]";
      v235 = 84;
      v86 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v86)
        v87 = v86;
      else
        v87 = v235;
      v88 = &v234[v87];
      v89 = v235 - v87;
      if (v235 - v87 >= 0x12)
        v90 = 18;
      else
        v90 = v235 - v87;
      v91 = v89 - v90;
      if (v91 >= v91 - 1)
        v92 = v91 - 1;
      else
        v92 = v91;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      v14 = (_QWORD *)&unk_254519000;
      v12 = v184;
      v9 = v193;
      v6 = v203;
      v3 = v214;
      a1 = v226;
    }
  }
  v15 = v14[421];
  v17 = &unk_254519000;
  if ((v16 & 1) == 0)
  {
    v215 = v3;
    v227 = a1;
    v204 = v6;
    v185 = v12;
    v194 = v9;
    v177 = v15;
    v17 = (_QWORD *)&unk_254519000;
    v15 = v177;
    v12 = v185;
    v9 = v194;
    v6 = v204;
    v3 = v215;
    v94 = v93;
    a1 = v227;
    if (v94)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v235 = 84;
      v95 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v95)
        v96 = v95;
      else
        v96 = v235;
      v97 = &v234[v96];
      v98 = v235 - v96;
      if (v235 - v96 >= 0x12)
        v99 = 18;
      else
        v99 = v235 - v96;
      v100 = v98 - v99;
      if (v100 >= v100 - 1)
        v101 = v100 - 1;
      else
        v101 = v100;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      v17 = (_QWORD *)&unk_254519000;
      v15 = v177;
      v12 = v185;
      v9 = v194;
      v6 = v204;
      v3 = v215;
      a1 = v227;
    }
  }
  v18 = v17[423];
  v20 = &unk_25451A000;
  if ((v19 & 1) == 0)
  {
    v216 = v3;
    v228 = a1;
    v205 = v6;
    v186 = v12;
    v195 = v9;
    v171 = v18;
    v178 = v15;
    v20 = (_QWORD *)&unk_25451A000;
    v18 = v171;
    v15 = v178;
    v12 = v186;
    v9 = v195;
    v6 = v205;
    v3 = v216;
    v103 = v102;
    a1 = v228;
    if (v103)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v235 = 89;
      v104 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v104)
        v105 = v104;
      else
        v105 = v235;
      v106 = &v234[v105];
      v107 = v235 - v105;
      if (v235 - v105 >= 0x12)
        v108 = 18;
      else
        v108 = v235 - v105;
      v109 = v107 - v108;
      if (v109 >= v109 - 1)
        v110 = v109 - 1;
      else
        v110 = v109;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      v20 = (_QWORD *)&unk_25451A000;
      v18 = v171;
      v15 = v178;
      v12 = v186;
      v9 = v195;
      v6 = v205;
      v3 = v216;
      a1 = v228;
    }
  }
  v21 = v20[310];
  v23 = &unk_254519000;
  if ((v22 & 1) == 0)
  {
    v217 = v3;
    v229 = a1;
    v206 = v6;
    v187 = v12;
    v196 = v9;
    v172 = v18;
    v179 = v15;
    v166 = v21;
    v23 = (_QWORD *)&unk_254519000;
    v21 = v166;
    v18 = v172;
    v15 = v179;
    v12 = v187;
    v9 = v196;
    v6 = v206;
    v3 = v217;
    v112 = v111;
    a1 = v229;
    if (v112)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
      v235 = 84;
      v113 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v113)
        v114 = v113;
      else
        v114 = v235;
      v115 = &v234[v114];
      v116 = v235 - v114;
      if (v235 - v114 >= 0x12)
        v117 = 18;
      else
        v117 = v235 - v114;
      v118 = v116 - v117;
      if (v118 >= v118 - 1)
        v119 = v118 - 1;
      else
        v119 = v118;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      v23 = (_QWORD *)&unk_254519000;
      v21 = v166;
      v18 = v172;
      v15 = v179;
      v12 = v187;
      v9 = v196;
      v6 = v206;
      v3 = v217;
      a1 = v229;
    }
  }
  v24 = v23[375];
  v26 = &unk_25451A000;
  if ((v25 & 1) == 0)
  {
    v218 = v3;
    v230 = a1;
    v207 = v6;
    v188 = v12;
    v197 = v9;
    v173 = v18;
    v180 = v15;
    v162 = v24;
    v167 = v21;
    v26 = (_QWORD *)&unk_25451A000;
    v24 = v162;
    v21 = v167;
    v18 = v173;
    v15 = v180;
    v12 = v188;
    v9 = v197;
    v6 = v207;
    v3 = v218;
    v121 = v120;
    a1 = v230;
    if (v121)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      v235 = 95;
      v122 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v122)
        v123 = v122;
      else
        v123 = v235;
      v124 = &v234[v123];
      v125 = v235 - v123;
      if (v235 - v123 >= 0x12)
        v126 = 18;
      else
        v126 = v235 - v123;
      v127 = v125 - v126;
      if (v127 >= v127 - 1)
        v128 = v127 - 1;
      else
        v128 = v127;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      v26 = (_QWORD *)&unk_25451A000;
      v24 = v162;
      v21 = v167;
      v18 = v173;
      v15 = v180;
      v12 = v188;
      v9 = v197;
      v6 = v207;
      v3 = v218;
      a1 = v230;
    }
  }
  v27 = v26[312];
  v29 = &unk_25451A000;
  if ((v28 & 1) == 0)
  {
    v219 = v3;
    v231 = a1;
    v208 = v6;
    v189 = v12;
    v198 = v9;
    v174 = v18;
    v181 = v15;
    v163 = v24;
    v168 = v21;
    v159 = v27;
    v29 = (_QWORD *)&unk_25451A000;
    v27 = v159;
    v24 = v163;
    v21 = v168;
    v18 = v174;
    v15 = v181;
    v12 = v189;
    v9 = v198;
    v6 = v208;
    v3 = v219;
    v130 = v129;
    a1 = v231;
    if (v130)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      v235 = 99;
      v131 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v131)
        v132 = v131;
      else
        v132 = v235;
      v133 = &v234[v132];
      v134 = v235 - v132;
      if (v235 - v132 >= 0x12)
        v135 = 18;
      else
        v135 = v235 - v132;
      v136 = v134 - v135;
      if (v136 >= v136 - 1)
        v137 = v136 - 1;
      else
        v137 = v136;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      v29 = (_QWORD *)&unk_25451A000;
      v27 = v159;
      v24 = v163;
      v21 = v168;
      v18 = v174;
      v15 = v181;
      v12 = v189;
      v9 = v198;
      v6 = v208;
      v3 = v219;
      a1 = v231;
    }
  }
  v30 = v29[314];
  v32 = &unk_25451A000;
  if ((v31 & 1) == 0)
  {
    v220 = v3;
    v232 = a1;
    v209 = v6;
    v190 = v12;
    v199 = v9;
    v175 = v18;
    v182 = v15;
    v164 = v24;
    v169 = v21;
    v157 = v30;
    v160 = v27;
    v32 = (_QWORD *)&unk_25451A000;
    v30 = v157;
    v27 = v160;
    v24 = v164;
    v21 = v169;
    v18 = v175;
    v15 = v182;
    v12 = v190;
    v9 = v199;
    v6 = v209;
    v3 = v220;
    v139 = v138;
    a1 = v232;
    if (v139)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v235 = 93;
      v140 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v140)
        v141 = v140;
      else
        v141 = v235;
      v142 = &v234[v141];
      v143 = v235 - v141;
      if (v235 - v141 >= 0x12)
        v144 = 18;
      else
        v144 = v235 - v141;
      v145 = v143 - v144;
      if (v145 >= v145 - 1)
        v146 = v145 - 1;
      else
        v146 = v145;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      v32 = (_QWORD *)&unk_25451A000;
      v30 = v157;
      v27 = v160;
      v24 = v164;
      v21 = v169;
      v18 = v175;
      v15 = v182;
      v12 = v190;
      v9 = v199;
      v6 = v209;
      v3 = v220;
      a1 = v232;
    }
  }
  v33 = v32[21];
  v35 = &unk_25451A000;
  if ((v34 & 1) == 0)
  {
    v221 = v3;
    v233 = a1;
    v210 = v6;
    v191 = v12;
    v200 = v9;
    v176 = v18;
    v183 = v15;
    v165 = v24;
    v170 = v21;
    v158 = v30;
    v161 = v27;
    v156 = v33;
    v35 = (_QWORD *)&unk_25451A000;
    v33 = v156;
    v30 = v158;
    v27 = v161;
    v24 = v165;
    v21 = v170;
    v18 = v176;
    v15 = v183;
    v12 = v191;
    v9 = v200;
    v6 = v210;
    v3 = v221;
    v148 = v147;
    a1 = v233;
    if (v148)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v235 = 86;
      v149 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v149)
        v150 = v149;
      else
        v150 = v235;
      v151 = &v234[v150];
      v152 = v235 - v150;
      if (v235 - v150 >= 0x12)
        v153 = 18;
      else
        v153 = v235 - v150;
      v154 = v152 - v153;
      if (v154 >= v154 - 1)
        v155 = v154 - 1;
      else
        v155 = v154;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      v35 = (_QWORD *)&unk_25451A000;
      v33 = v156;
      v30 = v158;
      v27 = v161;
      v24 = v165;
      v21 = v170;
      v18 = v176;
      v15 = v183;
      v12 = v191;
      v9 = v200;
      v6 = v210;
      v3 = v221;
      a1 = v233;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v35[340] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;

  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  v7 = a2;
  mlir::func::ConstantOp::print((mlir::func::ConstantOp *)&v7, a3);
}

BOOL mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroOperands(a1, v5))
    return 0;
  v7 = a1;
  if (!mlir::func::ConstantOp::verifyInvariantsImpl((uint64_t **)&v7))
    return 0;
  v7 = a1;
  return mlir::func::ConstantOp::verify((uint64_t **)&v7) != 0;
}

uint64_t mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"func.func", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C047228;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::getParseAssemblyFn(uint64_t (**a1)(mlir::AsmParser *a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::func::FuncOp::parse;
  a1[3] = (uint64_t (*)(mlir::AsmParser *, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                             + 2);
}

void mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                       + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::func::FuncOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  _QWORD *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::func::FuncOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::func::FuncOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::func::FuncOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::getOpPropertyByteSize()
{
  return 40;
}

double mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    *(_QWORD *)(a3 + 32) = *((_QWORD *)a4 + 4);
    *(_OWORD *)a3 = v4;
    *(_OWORD *)(a3 + 16) = v5;
  }
  else
  {
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)&v4 = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::func::FuncOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::func::FuncOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] == a2[3])
    return a3[4] == a2[4];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::func::FuncOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::writeProperties;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[302], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::ArrayAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::TypeAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::ArrayAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::StringAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::StringAttr>(a1, v3 + 4) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[4]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x80uLL, 0x800408754F03FuLL);
  *v2 = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getNameAttr;
  v2[1] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setName;
  v2[2] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getVisibility;
  v2[3] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isNested;
  v2[4] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isPrivate;
  v2[5] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isPublic;
  v2[6] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setVisibility;
  v2[7] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setNested;
  v2[8] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setPrivate;
  v2[9] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setPublic;
  v2[10] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getSymbolUses;
  v2[11] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::symbolKnownUseEmpty;
  v2[12] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::replaceAllSymbolUses;
  v2[13] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isOptionalSymbol;
  v2[14] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::canDiscardOnUseEmpty;
  v2[15] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isDeclaration;
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_254519000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SymbolOpInterface]";
      v15 = 73;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::SymbolOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_254519000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[399], v2);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getNameAttr(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolName(this, this);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setName(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::StringAttr *Context;
  uint64_t v6;
  _QWORD v7[4];
  __int16 v8;

  Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v8 = 261;
  v7[0] = "sym_name";
  v7[1] = 8;
  v6 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v7);
  mlir::Operation::setAttr(a2, v6, a3);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getVisibility(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this);
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isNested(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) == 2;
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isPrivate(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) == 1;
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isPublic(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) == 0;
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setVisibility(uint64_t a1, uint64_t a2, int a3)
{
  mlir::SymbolTable::setSymbolVisibility(a2, a3);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setNested(uint64_t a1, uint64_t a2)
{
  mlir::SymbolTable::setSymbolVisibility(a2, 2);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setPrivate(uint64_t a1, uint64_t a2)
{
  mlir::SymbolTable::setSymbolVisibility(a2, 1);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setPublic(uint64_t a1, uint64_t a2)
{
  mlir::SymbolTable::setSymbolVisibility(a2, 0);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getSymbolUses(mlir::SymbolTable *a1@<X1>, mlir::Operation *a2@<X2>, uint64_t a3@<X8>)
{
  mlir::SymbolTable::getSymbolUses(a1, a2, a3);
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::symbolKnownUseEmpty(uint64_t a1, mlir::SymbolTable *a2, mlir::Operation *a3)
{
  return mlir::SymbolTable::symbolKnownUseEmpty(a2, a3, a3);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::replaceAllSymbolUses(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4)
{
  return mlir::SymbolTable::replaceAllSymbolUses(a2, a3, a4);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isOptionalSymbol()
{
  return 0;
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::canDiscardOnUseEmpty(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) != 0;
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isDeclaration(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  _QWORD *v3;

  v2 = *(unsigned int *)(a2 + 44);
  if ((v2 & 0x7FFFFF) == 0)
    return MEMORY[0] == 0;
  v3 = (_QWORD *)(((a2 + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                + 32 * *(unsigned int *)(a2 + 40));
  return *v3 == (_QWORD)v3;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x48uLL, 0x800404C0E4D0CuLL);
  *v2 = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getCallableRegion;
  v2[1] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getArgumentTypes;
  v2[2] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getResultTypes;
  v2[3] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getArgAttrsAttr;
  v2[4] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getResAttrsAttr;
  v2[5] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setArgAttrsAttr;
  v2[6] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setResAttrsAttr;
  v2[7] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::removeArgAttrsAttr;
  v2[8] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::removeResAttrsAttr;
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_254519000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallableOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CallableOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_254519000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[387], v2);
}

_QWORD *mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getCallableRegion(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  _QWORD *v3;

  v2 = *(unsigned int *)(a2 + 44);
  if ((v2 & 0x7FFFFF) == 0)
    return 0;
  v3 = (_QWORD *)(((a2 + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                + 32 * *(unsigned int *)(a2 + 40));
  if ((_QWORD *)*v3 == v3)
    return 0;
  else
    return v3;
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getArgumentTypes(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t Value;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v2 = 0;
  Value = *(_QWORD *)(v2 + 8);
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value);
  return mlir::FunctionType::getInputs((mlir::FunctionType *)&Value);
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getResultTypes(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t Value;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v2 = 0;
  Value = *(_QWORD *)(v2 + 8);
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value);
  return mlir::FunctionType::getResults((mlir::FunctionType *)&Value);
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getArgAttrsAttr(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getResAttrsAttr(uint64_t a1, uint64_t a2)
{
  unint64_t v2;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v2 = 0;
  return *(_QWORD *)(v2 + 16);
}

void mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setArgAttrsAttr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Operation::setAttr(a2, **(_QWORD **)(*(_QWORD *)(a2 + 48) + 96), a3);
}

void mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setResAttrsAttr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Operation::setAttr(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 96) + 16), a3);
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::removeArgAttrsAttr(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v2 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v2 = 0;
  *v2 = 0;
  return 0;
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::removeResAttrsAttr(uint64_t a1, uint64_t a2)
{
  unint64_t v2;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v2 = 0;
  *(_QWORD *)(v2 + 16) = 0;
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  const char *v13;
  unint64_t v14;

  v2 = malloc_type_malloc(0x38uLL, 0xE004091171B8EuLL);
  *v2 = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getFunctionType;
  v2[1] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setFunctionTypeAttr;
  v2[2] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::cloneTypeWith;
  v2[3] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::verifyBody;
  v2[5] = 0;
  v2[6] = 0;
  v2[4] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::verifyType;
  v2[5] = mlir::detail::InterfaceMap::lookup<mlir::SymbolOpInterface>(a1);
  v2[6] = mlir::detail::InterfaceMap::lookup<mlir::CallableOpInterface>(a1);
  v4 = &unk_254519000;
  if ((v3 & 1) == 0)
  {
    v4 = (_QWORD *)&unk_254519000;
    if (v5)
    {
      v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::FunctionOpInterface]";
      v14 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v6)
        v7 = v6;
      else
        v7 = v14;
      v8 = &v13[v7];
      v9 = v14 - v7;
      if (v14 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v14 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::FunctionOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_254519000;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[405], v2);
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getFunctionType(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v2 = 0;
  v4 = *(_QWORD *)(v2 + 8);
  return mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v4);
}

void mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setFunctionTypeAttr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Operation::setAttr(a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 96) + 8), a3);
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::cloneTypeWith(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v10;
  uint64_t Value;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v10 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v10 = 0;
  Value = *(_QWORD *)(v10 + 8);
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value);
  return mlir::FunctionType::clone((mlir::Attribute *)&Value, a3, a4, a5, a6);
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::verifyBody(uint64_t a1, uint64_t *a2)
{
  uint64_t *v3;

  v3 = a2;
  return mlir::detail::FunctionOpInterfaceTrait<mlir::func::FuncOp>::verifyBody(&v3);
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::verifyType()
{
  return 1;
}

uint64_t mlir::detail::FunctionOpInterfaceTrait<mlir::func::FuncOp>::verifyBody(uint64_t **a1)
{
  uint64_t *v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t Inputs;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  unint64_t v16;
  uint64_t v17;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  char *v24;
  char *v25;
  __int128 v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  char *v36;
  char *v37;
  __int128 v38;
  int *v39;
  char *v40;
  char *v41;
  __int128 v42;
  uint64_t v43;
  int *v44;
  char *v45;
  char *v46;
  __int128 v47;
  uint64_t v48;
  int *v49;
  char *v50;
  char *v51;
  __int128 v52;
  uint64_t v53;
  int *v54;
  char *v55;
  char *v56;
  __int128 v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  _QWORD *v61;
  _QWORD *v62;
  void *v63;
  uint64_t v64;
  uint64_t v65;
  void *v66;
  unint64_t v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  BOOL v74;
  unint64_t v75;
  BOOL v76;
  unint64_t v77;
  int64_t v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  const void **v85[4];
  __int16 v86;
  int v87;
  const char *v88;
  uint64_t v89;
  uint64_t Value;
  _BYTE v91[16];
  void *v92;
  unsigned int v93;
  unsigned int v94;
  _BYTE v95[96];
  void *v96;
  _QWORD *v97;
  void *__p;
  _QWORD *v99;
  char v100;
  uint64_t v101;

  v101 = *MEMORY[0x24BDAC8D0];
  v2 = *a1;
  v3 = *((unsigned int *)*a1 + 11);
  if ((v3 & 0x7FFFFF) != 0)
  {
    v4 = (_QWORD *)((((unint64_t)&v2[2 * ((v3 >> 23) & 1) + 8] + ((v3 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)v2 + 10));
    if ((_QWORD *)*v4 == v4)
      return 1;
  }
  else if (!MEMORY[0])
  {
    return 1;
  }
  v5 = (uint64_t)&v2[2 * ((v3 >> 23) & 1) + 8];
  if (HIBYTE(*((_DWORD *)*a1 + 11)))
    v6 = v5;
  else
    v6 = 0;
  Value = *(_QWORD *)(v6 + 8);
  Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value);
  Inputs = mlir::FunctionType::getInputs((mlir::FunctionType *)&Value);
  v9 = v8;
  v10 = *(_QWORD *)((((unint64_t)&(*a1)[2 * (((unint64_t)*((unsigned int *)*a1 + 11) >> 23) & 1) + 8]
                    + (((unint64_t)*((unsigned int *)*a1 + 11) >> 21) & 0x7F8)
                    + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)*a1 + 10)
                  + 8);
  if (v10)
    v11 = v10 - 8;
  else
    v11 = 0;
  v13 = v11 + 48;
  v12 = *(_QWORD *)(v11 + 48);
  if (((unint64_t)(*(_QWORD *)(v13 + 8) - v12) >> 3) != v8)
  {
    v85[0] = (const void **)"entry block must have ";
    v86 = 259;
    mlir::OpState::emitOpError(a1, v85, (uint64_t)&Value);
    if (Value)
    {
      v87 = 5;
      v88 = (const char *)v9;
      v18 = &v87;
      v19 = (char *)v92;
      if (v93 >= v94)
      {
        v68 = v93 + 1;
        if (v92 <= &v87 && (char *)v92 + 24 * v93 > (char *)&v87)
        {
          v78 = (char *)&v87 - (_BYTE *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v68, 24);
          v19 = (char *)v92;
          v18 = (int *)((char *)v92 + v78);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v68, 24);
          v18 = &v87;
          v19 = (char *)v92;
        }
      }
      v20 = &v19[24 * v93];
      v21 = *(_OWORD *)v18;
      *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
      *(_OWORD *)v20 = v21;
      v22 = ++v93;
      if (Value)
      {
        v87 = 3;
        v88 = " arguments to match function signature";
        v89 = 38;
        v23 = &v87;
        v24 = (char *)v92;
        if (v22 >= v94)
        {
          v69 = v22 + 1;
          v70 = (char *)v92 + 24 * v22 > (char *)&v87;
          if (v92 <= &v87 && v70)
          {
            v79 = (char *)&v87 - (_BYTE *)v92;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v69, 24);
            v24 = (char *)v92;
            v23 = (int *)((char *)v92 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v69, 24);
            v23 = &v87;
            v24 = (char *)v92;
          }
        }
        v25 = &v24[24 * v93];
        v26 = *(_OWORD *)v23;
        *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
        *(_OWORD *)v25 = v26;
        ++v93;
      }
    }
    v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    if (!v100)
      return v17;
    v27 = __p;
    if (__p)
    {
      v28 = v99;
      v29 = __p;
      if (v99 != __p)
      {
        do
          v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
        while (v28 != v27);
        v29 = __p;
      }
      v99 = v27;
      operator delete(v29);
    }
    v30 = v96;
    if (v96)
    {
      v31 = v97;
      v32 = v96;
      if (v97 != v96)
      {
        do
        {
          v34 = *--v31;
          v33 = v34;
          *v31 = 0;
          if (v34)
            MEMORY[0x20BD002D4](v33, 0x1000C8077774924);
        }
        while (v31 != v30);
        v32 = v96;
      }
      v97 = v30;
      operator delete(v32);
    }
    v66 = v92;
    if (v92 == v95)
      return v17;
LABEL_66:
    free(v66);
    return v17;
  }
  if (!v8)
    return 1;
  v14 = Inputs;
  v15 = 0;
  while (1)
  {
    v16 = *(_QWORD *)(*(_QWORD *)(v12 + 8 * (_QWORD)v15) + 8) & 0xFFFFFFFFFFFFFFF8;
    if (*(_QWORD *)(Inputs + 8 * (_QWORD)v15) != v16)
      break;
    if ((const char *)v8 == ++v15)
      return 1;
  }
  v85[0] = (const void **)"type of entry block argument #";
  v86 = 259;
  mlir::OpState::emitOpError(a1, v85, (uint64_t)&Value);
  if (Value)
  {
    v87 = 5;
    v88 = v15;
    v35 = &v87;
    v36 = (char *)v92;
    if (v93 >= v94)
    {
      v71 = v93 + 1;
      if (v92 <= &v87 && (char *)v92 + 24 * v93 > (char *)&v87)
      {
        v80 = (char *)&v87 - (_BYTE *)v92;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v71, 24);
        v36 = (char *)v92;
        v35 = (int *)((char *)v92 + v80);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v71, 24);
        v35 = &v87;
        v36 = (char *)v92;
      }
    }
    v37 = &v36[24 * v93];
    v38 = *(_OWORD *)v35;
    *((_QWORD *)v37 + 2) = *((_QWORD *)v35 + 2);
    *(_OWORD *)v37 = v38;
    ++v93;
    if (Value)
    {
      mlir::Diagnostic::operator<<((uint64_t)v91, 40);
      if (Value)
      {
        v39 = &v87;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v87, v16);
        v40 = (char *)v92;
        if (v93 >= v94)
        {
          v72 = v93 + 1;
          if (v92 <= &v87 && (char *)v92 + 24 * v93 > (char *)&v87)
          {
            v81 = (char *)&v87 - (_BYTE *)v92;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v72, 24);
            v40 = (char *)v92;
            v39 = (int *)((char *)v92 + v81);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v72, 24);
            v39 = &v87;
            v40 = (char *)v92;
          }
        }
        v41 = &v40[24 * v93];
        v42 = *(_OWORD *)v39;
        *((_QWORD *)v41 + 2) = *((_QWORD *)v39 + 2);
        *(_OWORD *)v41 = v42;
        v43 = ++v93;
        if (Value)
        {
          v87 = 3;
          v88 = ") must match the type of the corresponding argument in ";
          v89 = 55;
          v44 = &v87;
          v45 = (char *)v92;
          if (v43 >= v94)
          {
            v73 = v43 + 1;
            v74 = (char *)v92 + 24 * v43 > (char *)&v87;
            if (v92 <= &v87 && v74)
            {
              v82 = (char *)&v87 - (_BYTE *)v92;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v73, 24);
              v45 = (char *)v92;
              v44 = (int *)((char *)v92 + v82);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v73, 24);
              v44 = &v87;
              v45 = (char *)v92;
            }
          }
          v46 = &v45[24 * v93];
          v47 = *(_OWORD *)v44;
          *((_QWORD *)v46 + 2) = *((_QWORD *)v44 + 2);
          *(_OWORD *)v46 = v47;
          v48 = ++v93;
          if (Value)
          {
            v87 = 3;
            v88 = "function signature(";
            v89 = 19;
            v49 = &v87;
            v50 = (char *)v92;
            if (v48 >= v94)
            {
              v75 = v48 + 1;
              v76 = (char *)v92 + 24 * v48 > (char *)&v87;
              if (v92 <= &v87 && v76)
              {
                v83 = (char *)&v87 - (_BYTE *)v92;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v75, 24);
                v50 = (char *)v92;
                v49 = (int *)((char *)v92 + v83);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v75, 24);
                v49 = &v87;
                v50 = (char *)v92;
              }
            }
            v51 = &v50[24 * v93];
            v52 = *(_OWORD *)v49;
            *((_QWORD *)v51 + 2) = *((_QWORD *)v49 + 2);
            *(_OWORD *)v51 = v52;
            ++v93;
            if (Value)
            {
              v53 = *(_QWORD *)(v14 + 8 * (_QWORD)v15);
              v54 = &v87;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v87, v53);
              v55 = (char *)v92;
              if (v93 >= v94)
              {
                v77 = v93 + 1;
                if (v92 <= &v87 && (char *)v92 + 24 * v93 > (char *)&v87)
                {
                  v84 = (char *)&v87 - (_BYTE *)v92;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v77, 24);
                  v55 = (char *)v92;
                  v54 = (int *)((char *)v92 + v84);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v77, 24);
                  v54 = &v87;
                  v55 = (char *)v92;
                }
              }
              v56 = &v55[24 * v93];
              v57 = *(_OWORD *)v54;
              *((_QWORD *)v56 + 2) = *((_QWORD *)v54 + 2);
              *(_OWORD *)v56 = v57;
              ++v93;
              if (Value)
                mlir::Diagnostic::operator<<((uint64_t)v91, 41);
            }
          }
        }
      }
    }
  }
  v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  if (v100)
  {
    v58 = __p;
    if (__p)
    {
      v59 = v99;
      v60 = __p;
      if (v99 != __p)
      {
        do
          v59 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v59 - 1);
        while (v59 != v58);
        v60 = __p;
      }
      v99 = v58;
      operator delete(v60);
    }
    v61 = v96;
    if (v96)
    {
      v62 = v97;
      v63 = v96;
      if (v97 != v96)
      {
        do
        {
          v65 = *--v62;
          v64 = v65;
          *v62 = 0;
          if (v65)
            MEMORY[0x20BD002D4](v64, 0x1000C8077774924);
        }
        while (v62 != v61);
        v63 = v96;
      }
      v97 = v61;
      operator delete(v63);
    }
    v66 = v92;
    if (v92 != v95)
      goto LABEL_66;
  }
  return v17;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getDefaultDialect;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[336], v2);
}

const char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getDefaultDialect()
{
  return "func";
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  _QWORD *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned __int8 v7;
  _QWORD *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned __int8 v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 v22;
  _QWORD *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  uint64_t v27;
  unsigned __int8 v28;
  _QWORD *v29;
  uint64_t v30;
  unsigned __int8 v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned __int8 v34;
  _QWORD *v35;
  uint64_t v36;
  unsigned __int8 v37;
  _QWORD *v38;
  int v52;
  int v53;
  unint64_t v54;
  unint64_t v55;
  const char *v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  unint64_t v63;
  unint64_t v64;
  const char *v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  int v70;
  int v71;
  unint64_t v72;
  unint64_t v73;
  const char *v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  unint64_t v81;
  unint64_t v82;
  const char *v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  int v88;
  int v89;
  unint64_t v90;
  unint64_t v91;
  const char *v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  unint64_t v99;
  unint64_t v100;
  const char *v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  int v106;
  int v107;
  unint64_t v108;
  unint64_t v109;
  const char *v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  int v115;
  int v116;
  unint64_t v117;
  unint64_t v118;
  const char *v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  int v124;
  int v125;
  unint64_t v126;
  unint64_t v127;
  const char *v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  int v133;
  int v134;
  unint64_t v135;
  unint64_t v136;
  const char *v137;
  unint64_t v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  int v142;
  int v143;
  unint64_t v144;
  unint64_t v145;
  const char *v146;
  unint64_t v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  int v151;
  int v152;
  unint64_t v153;
  unint64_t v154;
  const char *v155;
  unint64_t v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t v159;
  int v160;
  int v161;
  unint64_t v162;
  unint64_t v163;
  const char *v164;
  unint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  const char *v260;
  unint64_t v261;

  v2 = &unk_254519000;
  if ((v1 & 1) == 0)
  {
    v247 = a1;
    v2 = (_QWORD *)&unk_254519000;
    v53 = v52;
    a1 = v247;
    if (v53)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneRegion<Empty>]";
      v261 = 81;
      v54 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v54)
        v55 = v54;
      else
        v55 = v261;
      v56 = &v260[v55];
      v57 = v261 - v55;
      if (v261 - v55 >= 0x12)
        v58 = 18;
      else
        v58 = v261 - v55;
      v59 = v57 - v58;
      if (v59 >= v59 - 1)
        v60 = v59 - 1;
      else
        v60 = v59;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v56[v58], v60);
      v2 = (_QWORD *)&unk_254519000;
      a1 = v247;
    }
  }
  v3 = v2[415];
  v5 = &unk_254519000;
  if ((v4 & 1) == 0)
  {
    v235 = v3;
    v248 = a1;
    v5 = (_QWORD *)&unk_254519000;
    v62 = v61;
    v3 = v235;
    a1 = v248;
    if (v62)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      v261 = 83;
      v63 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v63)
        v64 = v63;
      else
        v64 = v261;
      v65 = &v260[v64];
      v66 = v261 - v64;
      if (v261 - v64 >= 0x12)
        v67 = 18;
      else
        v67 = v261 - v64;
      v68 = v66 - v67;
      if (v68 >= v68 - 1)
        v69 = v68 - 1;
      else
        v69 = v68;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v65[v67], v69);
      v5 = (_QWORD *)&unk_254519000;
      v3 = v235;
      a1 = v248;
    }
  }
  v6 = v5[417];
  v8 = &unk_254519000;
  if ((v7 & 1) == 0)
  {
    v236 = v3;
    v249 = a1;
    v224 = v6;
    v8 = (_QWORD *)&unk_254519000;
    v6 = v224;
    v3 = v236;
    v71 = v70;
    a1 = v249;
    if (v71)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v261 = 86;
      v72 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v72)
        v73 = v72;
      else
        v73 = v261;
      v74 = &v260[v73];
      v75 = v261 - v73;
      if (v261 - v73 >= 0x12)
        v76 = 18;
      else
        v76 = v261 - v73;
      v77 = v75 - v76;
      if (v77 >= v77 - 1)
        v78 = v77 - 1;
      else
        v78 = v77;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v74[v76], v78);
      v8 = (_QWORD *)&unk_254519000;
      v6 = v224;
      v3 = v236;
      a1 = v249;
    }
  }
  v9 = v8[419];
  v11 = &unk_254519000;
  if ((v10 & 1) == 0)
  {
    v237 = v3;
    v250 = a1;
    v214 = v9;
    v225 = v6;
    v11 = (_QWORD *)&unk_254519000;
    v9 = v214;
    v6 = v225;
    v80 = v79;
    v3 = v237;
    a1 = v250;
    if (v80)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroOperands<Empty>]";
      v261 = 84;
      v81 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v81)
        v82 = v81;
      else
        v82 = v261;
      v83 = &v260[v82];
      v84 = v261 - v82;
      if (v261 - v82 >= 0x12)
        v85 = 18;
      else
        v85 = v261 - v82;
      v86 = v84 - v85;
      if (v86 >= v86 - 1)
        v87 = v86 - 1;
      else
        v87 = v86;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v83[v85], v87);
      v11 = (_QWORD *)&unk_254519000;
      v9 = v214;
      v6 = v225;
      v3 = v237;
      a1 = v250;
    }
  }
  v12 = v11[421];
  v14 = &unk_254519000;
  if ((v13 & 1) == 0)
  {
    v238 = v3;
    v251 = a1;
    v215 = v9;
    v226 = v6;
    v205 = v12;
    v14 = (_QWORD *)&unk_254519000;
    v12 = v205;
    v9 = v215;
    v6 = v226;
    v89 = v88;
    v3 = v238;
    a1 = v251;
    if (v89)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v261 = 84;
      v90 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v90)
        v91 = v90;
      else
        v91 = v261;
      v92 = &v260[v91];
      v93 = v261 - v91;
      if (v261 - v91 >= 0x12)
        v94 = 18;
      else
        v94 = v261 - v91;
      v95 = v93 - v94;
      if (v95 >= v95 - 1)
        v96 = v95 - 1;
      else
        v96 = v95;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v92[v94], v96);
      v14 = (_QWORD *)&unk_254519000;
      v12 = v205;
      v9 = v215;
      v6 = v226;
      v3 = v238;
      a1 = v251;
    }
  }
  v15 = v14[423];
  v17 = &unk_25451A000;
  if ((v16 & 1) == 0)
  {
    v239 = v3;
    v252 = a1;
    v216 = v9;
    v227 = v6;
    v197 = v15;
    v206 = v12;
    v17 = (_QWORD *)&unk_25451A000;
    v15 = v197;
    v12 = v206;
    v9 = v216;
    v6 = v227;
    v98 = v97;
    v3 = v239;
    a1 = v252;
    if (v98)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v261 = 89;
      v99 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v99)
        v100 = v99;
      else
        v100 = v261;
      v101 = &v260[v100];
      v102 = v261 - v100;
      if (v261 - v100 >= 0x12)
        v103 = 18;
      else
        v103 = v261 - v100;
      v104 = v102 - v103;
      if (v104 >= v104 - 1)
        v105 = v104 - 1;
      else
        v105 = v104;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v101[v103], v105);
      v17 = (_QWORD *)&unk_25451A000;
      v15 = v197;
      v12 = v206;
      v9 = v216;
      v6 = v227;
      v3 = v239;
      a1 = v252;
    }
  }
  v18 = v17[310];
  v20 = &unk_25451B000;
  if ((v19 & 1) == 0)
  {
    v240 = v3;
    v253 = a1;
    v217 = v9;
    v228 = v6;
    v198 = v15;
    v207 = v12;
    v190 = v18;
    v20 = (_QWORD *)&unk_25451B000;
    v18 = v190;
    v15 = v198;
    v12 = v207;
    v9 = v217;
    v6 = v228;
    v107 = v106;
    v3 = v240;
    a1 = v253;
    if (v107)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AffineScope<Empty>]";
      v261 = 83;
      v108 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v108)
        v109 = v108;
      else
        v109 = v261;
      v110 = &v260[v109];
      v111 = v261 - v109;
      if (v261 - v109 >= 0x12)
        v112 = 18;
      else
        v112 = v261 - v109;
      v113 = v111 - v112;
      if (v113 >= v113 - 1)
        v114 = v113 - 1;
      else
        v114 = v113;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v110[v112], v114);
      v20 = (_QWORD *)&unk_25451B000;
      v18 = v190;
      v15 = v198;
      v12 = v207;
      v9 = v217;
      v6 = v228;
      v3 = v240;
      a1 = v253;
    }
  }
  v21 = v20[53];
  v23 = &unk_25451B000;
  if ((v22 & 1) == 0)
  {
    v241 = v3;
    v254 = a1;
    v218 = v9;
    v229 = v6;
    v199 = v15;
    v208 = v12;
    v184 = v21;
    v191 = v18;
    v23 = (_QWORD *)&unk_25451B000;
    v21 = v184;
    v18 = v191;
    v15 = v199;
    v12 = v208;
    v9 = v218;
    v6 = v229;
    v116 = v115;
    v3 = v241;
    a1 = v254;
    if (v116)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AutomaticAllocationScope<Empty>]";
      v261 = 96;
      v117 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v117)
        v118 = v117;
      else
        v118 = v261;
      v119 = &v260[v118];
      v120 = v261 - v118;
      if (v261 - v118 >= 0x12)
        v121 = 18;
      else
        v121 = v261 - v118;
      v122 = v120 - v121;
      if (v122 >= v122 - 1)
        v123 = v122 - 1;
      else
        v123 = v122;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AutomaticAllocationScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AutomaticAllocationScope>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v119[v121], v123);
      v23 = (_QWORD *)&unk_25451B000;
      v21 = v184;
      v18 = v191;
      v15 = v199;
      v12 = v208;
      v9 = v218;
      v6 = v229;
      v3 = v241;
      a1 = v254;
    }
  }
  v24 = v23[55];
  v26 = &unk_254519000;
  if ((v25 & 1) == 0)
  {
    v242 = v3;
    v255 = a1;
    v219 = v9;
    v230 = v6;
    v200 = v15;
    v209 = v12;
    v185 = v21;
    v192 = v18;
    v179 = v24;
    v26 = (_QWORD *)&unk_254519000;
    v24 = v179;
    v21 = v185;
    v18 = v192;
    v15 = v200;
    v12 = v209;
    v9 = v219;
    v6 = v230;
    v125 = v124;
    v3 = v242;
    a1 = v255;
    if (v125)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SymbolOpInterface::Trait<Empty>]";
      v261 = 87;
      v126 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v126)
        v127 = v126;
      else
        v127 = v261;
      v128 = &v260[v127];
      v129 = v261 - v127;
      if (v261 - v127 >= 0x12)
        v130 = 18;
      else
        v130 = v261 - v127;
      v131 = v129 - v130;
      if (v131 >= v131 - 1)
        v132 = v131 - 1;
      else
        v132 = v131;
      mlir::detail::TypeIDResolver<mlir::SymbolOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v128[v130], v132);
      v26 = (_QWORD *)&unk_254519000;
      v24 = v179;
      v21 = v185;
      v18 = v192;
      v15 = v200;
      v12 = v209;
      v9 = v219;
      v6 = v230;
      v3 = v242;
      a1 = v255;
    }
  }
  v27 = v26[425];
  v29 = &unk_254519000;
  if ((v28 & 1) == 0)
  {
    v243 = v3;
    v256 = a1;
    v220 = v9;
    v231 = v6;
    v201 = v15;
    v210 = v12;
    v186 = v21;
    v193 = v18;
    v175 = v27;
    v180 = v24;
    v29 = (_QWORD *)&unk_254519000;
    v27 = v175;
    v24 = v180;
    v21 = v186;
    v18 = v193;
    v15 = v201;
    v12 = v210;
    v9 = v220;
    v6 = v231;
    v134 = v133;
    v3 = v243;
    a1 = v256;
    if (v134)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallableOpInterface::Trait<Empty>]";
      v261 = 89;
      v135 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v135)
        v136 = v135;
      else
        v136 = v261;
      v137 = &v260[v136];
      v138 = v261 - v136;
      if (v261 - v136 >= 0x12)
        v139 = 18;
      else
        v139 = v261 - v136;
      v140 = v138 - v139;
      if (v140 >= v140 - 1)
        v141 = v140 - 1;
      else
        v141 = v140;
      mlir::detail::TypeIDResolver<mlir::CallableOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallableOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v137[v139], v141);
      v29 = (_QWORD *)&unk_254519000;
      v27 = v175;
      v24 = v180;
      v21 = v186;
      v18 = v193;
      v15 = v201;
      v12 = v210;
      v9 = v220;
      v6 = v231;
      v3 = v243;
      a1 = v256;
    }
  }
  v30 = v29[427];
  v32 = &unk_254519000;
  if ((v31 & 1) == 0)
  {
    v244 = v3;
    v257 = a1;
    v221 = v9;
    v232 = v6;
    v202 = v15;
    v211 = v12;
    v187 = v21;
    v194 = v18;
    v176 = v27;
    v181 = v24;
    v172 = v30;
    v32 = (_QWORD *)&unk_254519000;
    v30 = v172;
    v27 = v176;
    v24 = v181;
    v21 = v187;
    v18 = v194;
    v15 = v202;
    v12 = v211;
    v9 = v221;
    v6 = v232;
    v143 = v142;
    v3 = v244;
    a1 = v257;
    if (v143)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::FunctionOpInterface::Trait<Empty>]";
      v261 = 89;
      v144 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v144)
        v145 = v144;
      else
        v145 = v261;
      v146 = &v260[v145];
      v147 = v261 - v145;
      if (v261 - v145 >= 0x12)
        v148 = 18;
      else
        v148 = v261 - v145;
      v149 = v147 - v148;
      if (v149 >= v149 - 1)
        v150 = v149 - 1;
      else
        v150 = v149;
      mlir::detail::TypeIDResolver<mlir::FunctionOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::FunctionOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v146[v148], v150);
      v32 = (_QWORD *)&unk_254519000;
      v30 = v172;
      v27 = v176;
      v24 = v181;
      v21 = v187;
      v18 = v194;
      v15 = v202;
      v12 = v211;
      v9 = v221;
      v6 = v232;
      v3 = v244;
      a1 = v257;
    }
  }
  v33 = v32[429];
  v35 = &unk_254519000;
  if ((v34 & 1) == 0)
  {
    v245 = v3;
    v258 = a1;
    v222 = v9;
    v233 = v6;
    v203 = v15;
    v212 = v12;
    v188 = v21;
    v195 = v18;
    v177 = v27;
    v182 = v24;
    v170 = v33;
    v173 = v30;
    v35 = (_QWORD *)&unk_254519000;
    v33 = v170;
    v30 = v173;
    v27 = v177;
    v24 = v182;
    v21 = v188;
    v18 = v195;
    v15 = v203;
    v12 = v212;
    v9 = v222;
    v6 = v233;
    v152 = v151;
    v3 = v245;
    a1 = v258;
    if (v152)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsIsolatedFromAbove<Empty>]";
      v261 = 91;
      v153 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v153)
        v154 = v153;
      else
        v154 = v261;
      v155 = &v260[v154];
      v156 = v261 - v154;
      if (v261 - v154 >= 0x12)
        v157 = 18;
      else
        v157 = v261 - v154;
      v158 = v156 - v157;
      if (v158 >= v158 - 1)
        v159 = v158 - 1;
      else
        v159 = v158;
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v155[v157], v159);
      v35 = (_QWORD *)&unk_254519000;
      v33 = v170;
      v30 = v173;
      v27 = v177;
      v24 = v182;
      v21 = v188;
      v18 = v195;
      v15 = v203;
      v12 = v212;
      v9 = v222;
      v6 = v233;
      v3 = v245;
      a1 = v258;
    }
  }
  v36 = v35[431];
  v38 = &unk_25451A000;
  if ((v37 & 1) == 0)
  {
    v246 = v3;
    v259 = a1;
    v223 = v9;
    v234 = v6;
    v204 = v15;
    v213 = v12;
    v189 = v21;
    v196 = v18;
    v178 = v27;
    v183 = v24;
    v171 = v33;
    v174 = v30;
    v169 = v36;
    v38 = (_QWORD *)&unk_25451A000;
    v36 = v169;
    v33 = v171;
    v30 = v174;
    v27 = v178;
    v24 = v183;
    v21 = v189;
    v18 = v196;
    v15 = v204;
    v12 = v213;
    v9 = v223;
    v6 = v234;
    v161 = v160;
    v3 = v246;
    a1 = v259;
    if (v161)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v261 = 86;
      v162 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v162)
        v163 = v162;
      else
        v163 = v261;
      v164 = &v260[v163];
      v165 = v261 - v163;
      if (v261 - v163 >= 0x12)
        v166 = 18;
      else
        v166 = v261 - v163;
      v167 = v165 - v166;
      if (v167 >= v167 - 1)
        v168 = v167 - 1;
      else
        v168 = v167;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v164[v166], v168);
      v38 = (_QWORD *)&unk_25451A000;
      v36 = v169;
      v33 = v171;
      v30 = v174;
      v27 = v178;
      v24 = v183;
      v21 = v189;
      v18 = v196;
      v15 = v204;
      v12 = v213;
      v9 = v223;
      v6 = v234;
      v3 = v246;
      a1 = v259;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v27 == a1
      || v30 == a1
      || v33 == a1
      || v36 == a1
      || v38[340] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t InterfaceFor;
  uint64_t AttrData;
  uint64_t v9;
  uint64_t v10;

  mlir::OpState::printOpName(a2, a3, a4, a5);
  InterfaceFor = mlir::OpInterface<mlir::FunctionOpInterface,mlir::detail::FunctionOpInterfaceInterfaceTraits>::getInterfaceFor(a2);
  v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 96) + 8);
  AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  mlir::function_interface_impl::printFunctionOp(a3, a2, InterfaceFor, 0, AttrData, v9, **(_QWORD **)(*(_QWORD *)(a2 + 48) + 96), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 48) + 96) + 16));
}

BOOL mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::OneRegion<mlir::func::FuncOp>,mlir::OpTrait::ZeroResults<mlir::func::FuncOp>,mlir::OpTrait::ZeroSuccessors<mlir::func::FuncOp>,mlir::OpTrait::ZeroOperands<mlir::func::FuncOp>,mlir::OpTrait::OpInvariants<mlir::func::FuncOp>,mlir::BytecodeOpInterface::Trait<mlir::func::FuncOp>,mlir::OpTrait::AffineScope<mlir::func::FuncOp>,mlir::OpTrait::AutomaticAllocationScope<mlir::func::FuncOp>,mlir::SymbolOpInterface::Trait<mlir::func::FuncOp>,mlir::CallableOpInterface::Trait<mlir::func::FuncOp>,mlir::FunctionOpInterface::Trait<mlir::func::FuncOp>,mlir::OpTrait::IsIsolatedFromAbove<mlir::func::FuncOp>,mlir::OpAsmOpInterface::Trait<mlir::func::FuncOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::OneRegion<mlir::func::FuncOp>,mlir::OpTrait::ZeroResults<mlir::func::FuncOp>,mlir::OpTrait::ZeroSuccessors<mlir::func::FuncOp>,mlir::OpTrait::ZeroOperands<mlir::func::FuncOp>,mlir::OpTrait::OpInvariants<mlir::func::FuncOp>,mlir::BytecodeOpInterface::Trait<mlir::func::FuncOp>,mlir::OpTrait::AffineScope<mlir::func::FuncOp>,mlir::OpTrait::AutomaticAllocationScope<mlir::func::FuncOp>,mlir::SymbolOpInterface::Trait<mlir::func::FuncOp>,mlir::CallableOpInterface::Trait<mlir::func::FuncOp>,mlir::FunctionOpInterface::Trait<mlir::func::FuncOp>,mlir::OpTrait::IsIsolatedFromAbove<mlir::func::FuncOp>,mlir::OpAsmOpInterface::Trait<mlir::func::FuncOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyOneRegion(a1, a2)
    && mlir::OpTrait::impl::verifyZeroResults(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyZeroOperands(a1, v5)
    && (v8 = a1, mlir::func::FuncOp::verifyInvariantsImpl((uint64_t **)&v8))
    && mlir::detail::SymbolOpInterfaceTrait<mlir::func::FuncOp>::verifyTrait((uint64_t)a1, v6))
  {
    return mlir::function_interface_impl::verifyTrait<mlir::func::FuncOp>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::detail::SymbolOpInterfaceTrait<mlir::func::FuncOp>::verifyTrait(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  const void **v16;
  __int16 v17;
  uint64_t *v18;
  _QWORD v19[3];
  void *v20;
  uint64_t v21;
  void *v22;
  _QWORD *v23;
  void *__p;
  _QWORD *v25;
  char v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v18 = (uint64_t *)a1;
  if (!mlir::detail::verifySymbol((mlir::detail *)a1, a2))
    return 0;
  v4 = *(unsigned int *)(a1 + 44);
  if ((v4 & 0x7FFFFF) != 0)
  {
    v5 = (_QWORD *)(((a1 + 16 * ((v4 >> 23) & 1) + ((v4 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(a1 + 40));
    if ((_QWORD *)*v5 == v5)
      goto LABEL_7;
    return 1;
  }
  if (MEMORY[0])
    return 1;
LABEL_7:
  if (mlir::SymbolTable::getSymbolVisibility((mlir::SymbolTable *)a1, v3))
    return 1;
  v16 = (const void **)"symbol declaration cannot have public visibility";
  v17 = 259;
  mlir::OpState::emitOpError(&v18, &v16, (uint64_t)v19);
  v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
  if (v19[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
  if (v26)
  {
    v8 = __p;
    if (__p)
    {
      v9 = v25;
      v10 = __p;
      if (v25 != __p)
      {
        do
          v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
        while (v9 != v8);
        v10 = __p;
      }
      v25 = v8;
      operator delete(v10);
    }
    v11 = v22;
    if (v22)
    {
      v12 = v23;
      v13 = v22;
      if (v23 != v22)
      {
        do
        {
          v15 = *--v12;
          v14 = v15;
          *v12 = 0;
          if (v15)
            MEMORY[0x20BD002D4](v14, 0x1000C8077774924);
        }
        while (v12 != v11);
        v13 = v22;
      }
      v23 = v11;
      operator delete(v13);
    }
    if (v20 != &v21)
      free(v20);
  }
  return v6;
}

uint64_t mlir::function_interface_impl::verifyTrait<mlir::func::FuncOp>(uint64_t a1)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  __int128 *v12;
  uint64_t v13;
  __int128 *v14;
  _BYTE *AttrData;
  size_t v16;
  _BYTE *v17;
  char *v18;
  uint64_t NameDialect;
  uint64_t *v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  __int128 *v27;
  uint64_t v28;
  __int128 *v29;
  _BYTE *v30;
  size_t v31;
  _BYTE *v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  char *v37;
  char *v38;
  __int128 v39;
  uint64_t v40;
  char *v41;
  char *v42;
  char *v43;
  __int128 v44;
  uint64_t v45;
  char *v46;
  char *v47;
  char *v48;
  __int128 v49;
  uint64_t v50;
  char *v51;
  char *v52;
  char *v53;
  __int128 v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;
  __int128 v66;
  uint64_t v67;
  char *v68;
  char *v69;
  char *v70;
  __int128 v71;
  uint64_t v72;
  char *v73;
  char *v74;
  char *v75;
  __int128 v76;
  uint64_t v77;
  char *v78;
  char *v79;
  char *v80;
  __int128 v81;
  _QWORD *v82;
  _QWORD *v83;
  void *v84;
  _QWORD *v85;
  uint64_t v86;
  uint64_t v87;
  _QWORD *v88;
  _QWORD *v89;
  void *v90;
  _QWORD *v91;
  uint64_t v92;
  uint64_t v93;
  _QWORD *v94;
  _QWORD *v95;
  void *v96;
  _QWORD *v97;
  uint64_t v98;
  uint64_t v99;
  _QWORD *v100;
  _QWORD *v101;
  void *v102;
  _QWORD *v103;
  uint64_t v104;
  uint64_t v105;
  char *v106;
  char *v107;
  char *v108;
  __int128 v109;
  uint64_t Value;
  char *v111;
  char *v112;
  char *v113;
  __int128 v114;
  uint64_t v115;
  char *v116;
  char *v117;
  char *v118;
  __int128 v119;
  _QWORD *v120;
  _QWORD *v121;
  void *v122;
  _QWORD *v123;
  uint64_t v124;
  uint64_t v125;
  char *v126;
  char *v127;
  char *v128;
  __int128 v129;
  uint64_t v130;
  char *v131;
  char *v132;
  char *v133;
  __int128 v134;
  uint64_t v135;
  char *v136;
  char *v137;
  char *v138;
  __int128 v139;
  _QWORD *v140;
  _QWORD *v141;
  void *v142;
  _QWORD *v143;
  uint64_t v144;
  uint64_t v145;
  unint64_t v147;
  unint64_t v148;
  unint64_t v149;
  BOOL v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t v153;
  BOOL v154;
  unint64_t v155;
  BOOL v156;
  unint64_t v157;
  BOOL v158;
  unint64_t v159;
  unint64_t v160;
  unint64_t v161;
  BOOL v162;
  unint64_t v163;
  unint64_t v164;
  unint64_t v165;
  BOOL v166;
  int64_t v167;
  int64_t v168;
  int64_t v169;
  int64_t v170;
  int64_t v171;
  int64_t v172;
  int64_t v173;
  int64_t v174;
  int64_t v175;
  int64_t v176;
  int64_t v177;
  int64_t v178;
  int64_t v179;
  int64_t v180;
  uint64_t v181;
  const void **v182[4];
  __int16 v183;
  uint64_t v184;
  uint64_t *v185;
  __int128 v186;
  uint64_t v187;
  _QWORD v188[3];
  void *v189;
  unsigned int v190;
  unsigned int v191;
  _BYTE v192[96];
  void *v193;
  _QWORD *v194;
  void *__p;
  _QWORD *v196;
  char v197;
  uint64_t v198;

  v198 = *MEMORY[0x24BDAC8D0];
  v185 = (uint64_t *)a1;
  v1 = *(unsigned int *)(a1 + 44);
  v2 = a1 + 16 * ((v1 >> 23) & 1);
  v4 = *(_QWORD *)(v2 + 64);
  v3 = v2 + 64;
  v184 = v4;
  if (v4)
  {
    if (BYTE3(v1))
      v5 = v3;
    else
      v5 = 0;
    v188[0] = *(_QWORD *)(v5 + 8);
    v188[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v188);
    mlir::FunctionType::getInputs((mlir::FunctionType *)v188);
    v7 = v6;
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
    v8 = v7;
    if (v9 != v7)
    {
      v183 = 257;
      mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
      if (v188[0])
      {
        LODWORD(v186) = 3;
        *((_QWORD *)&v186 + 1) = "expects argument attribute array to have the same number of elements as the number of f"
                                 "unction arguments, got ";
        v187 = 110;
        v36 = (char *)&v186;
        v37 = (char *)v189;
        if (v190 >= v191)
        {
          v147 = v190 + 1;
          if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
          {
            v167 = (char *)&v186 - (_BYTE *)v189;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v147, 24);
            v37 = (char *)v189;
            v36 = (char *)v189 + v167;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v147, 24);
            v36 = (char *)&v186;
            v37 = (char *)v189;
          }
        }
        v38 = &v37[24 * v190];
        v39 = *(_OWORD *)v36;
        *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
        *(_OWORD *)v38 = v39;
        ++v190;
      }
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
      if (v188[0])
      {
        LODWORD(v186) = 5;
        *((_QWORD *)&v186 + 1) = v40;
        v41 = (char *)&v186;
        v42 = (char *)v189;
        if (v190 >= v191)
        {
          v148 = v190 + 1;
          if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
          {
            v168 = (char *)&v186 - (_BYTE *)v189;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v148, 24);
            v42 = (char *)v189;
            v41 = (char *)v189 + v168;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v148, 24);
            v41 = (char *)&v186;
            v42 = (char *)v189;
          }
        }
        v43 = &v42[24 * v190];
        v44 = *(_OWORD *)v41;
        *((_QWORD *)v43 + 2) = *((_QWORD *)v41 + 2);
        *(_OWORD *)v43 = v44;
        v45 = ++v190;
        if (v188[0])
        {
          LODWORD(v186) = 3;
          *((_QWORD *)&v186 + 1) = ", but expected ";
          v187 = 15;
          v46 = (char *)&v186;
          v47 = (char *)v189;
          if (v45 >= v191)
          {
            v149 = v45 + 1;
            v150 = (char *)v189 + 24 * v45 > (char *)&v186;
            if (v189 <= &v186 && v150)
            {
              v169 = (char *)&v186 - (_BYTE *)v189;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v149, 24);
              v47 = (char *)v189;
              v46 = (char *)v189 + v169;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v149, 24);
              v46 = (char *)&v186;
              v47 = (char *)v189;
            }
          }
          v48 = &v47[24 * v190];
          v49 = *(_OWORD *)v46;
          *((_QWORD *)v48 + 2) = *((_QWORD *)v46 + 2);
          *(_OWORD *)v48 = v49;
          v50 = ++v190;
          if (v188[0])
          {
            LODWORD(v186) = 5;
            *((_QWORD *)&v186 + 1) = v8;
            v51 = (char *)&v186;
            v52 = (char *)v189;
            if (v50 >= v191)
            {
              v153 = v50 + 1;
              v154 = (char *)v189 + 24 * v50 > (char *)&v186;
              if (v189 <= &v186 && v154)
              {
                v172 = (char *)&v186 - (_BYTE *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v153, 24);
                v52 = (char *)v189;
                v51 = (char *)v189 + v172;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v153, 24);
                v51 = (char *)&v186;
                v52 = (char *)v189;
              }
            }
            v53 = &v52[24 * v190];
            v54 = *(_OWORD *)v51;
            *((_QWORD *)v53 + 2) = *((_QWORD *)v51 + 2);
            *(_OWORD *)v53 = v54;
            ++v190;
          }
        }
      }
      v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
      if (v188[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
      if (v197)
      {
        v55 = __p;
        if (__p)
        {
          v56 = v196;
          v57 = __p;
          if (v196 != __p)
          {
            do
              v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            v57 = __p;
          }
          v196 = v55;
          operator delete(v57);
        }
        v58 = v193;
        if (!v193)
          goto LABEL_183;
        v59 = v194;
        v60 = v193;
        if (v194 == v193)
          goto LABEL_182;
        do
        {
          v62 = *--v59;
          v61 = v62;
          *v59 = 0;
          if (v62)
            MEMORY[0x20BD002D4](v61, 0x1000C8077774924);
        }
        while (v59 != v58);
        goto LABEL_181;
      }
      return v35;
    }
    if (v7)
    {
      v10 = 0;
      while (1)
      {
        v11 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184) + 8 * v10);
        if (!v11)
        {
          v181 = 0;
LABEL_136:
          v183 = 257;
          mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
          if (v188[0])
          {
            LODWORD(v186) = 3;
            v187 = 71;
            v106 = (char *)&v186;
            v107 = (char *)v189;
            if (v190 >= v191)
            {
              v159 = v190 + 1;
              if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
              {
                v175 = (char *)&v186 - (_BYTE *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v159, 24);
                v107 = (char *)v189;
                v106 = (char *)v189 + v175;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v159, 24);
                v106 = (char *)&v186;
                v107 = (char *)v189;
              }
            }
            v108 = &v107[24 * v190];
            v109 = *(_OWORD *)v106;
            *((_QWORD *)v108 + 2) = *((_QWORD *)v106 + 2);
            *(_OWORD *)v108 = v109;
            ++v190;
          }
          Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
          if (v188[0])
          {
            v111 = (char *)&v186;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v186, *(_QWORD *)(Value + 8 * v10));
            v112 = (char *)v189;
            if (v190 >= v191)
            {
              v160 = v190 + 1;
              if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
              {
                v176 = (char *)&v186 - (_BYTE *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v160, 24);
                v112 = (char *)v189;
                v111 = (char *)v189 + v176;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v160, 24);
                v111 = (char *)&v186;
                v112 = (char *)v189;
              }
            }
            v113 = &v112[24 * v190];
            v114 = *(_OWORD *)v111;
            *((_QWORD *)v113 + 2) = *((_QWORD *)v111 + 2);
            *(_OWORD *)v113 = v114;
            v115 = ++v190;
            if (v188[0])
            {
              LODWORD(v186) = 3;
              v187 = 1;
              v116 = (char *)&v186;
              v117 = (char *)v189;
              if (v115 >= v191)
              {
                v161 = v115 + 1;
                v162 = (char *)v189 + 24 * v115 > (char *)&v186;
                if (v189 <= &v186 && v162)
                {
                  v177 = (char *)&v186 - (_BYTE *)v189;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v161, 24);
                  v117 = (char *)v189;
                  v116 = (char *)v189 + v177;
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v161, 24);
                  v116 = (char *)&v186;
                  v117 = (char *)v189;
                }
              }
              v118 = &v117[24 * v190];
              v119 = *(_OWORD *)v116;
              *((_QWORD *)v118 + 2) = *((_QWORD *)v116 + 2);
              *(_OWORD *)v118 = v119;
              ++v190;
            }
          }
          v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
          if (v188[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
          if (!v197)
            return v35;
          v120 = __p;
          if (__p)
          {
            v121 = v196;
            v122 = __p;
            if (v196 != __p)
            {
              do
                v121 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v121 - 1);
              while (v121 != v120);
              v122 = __p;
            }
            v196 = v120;
            operator delete(v122);
          }
          v58 = v193;
          if (!v193)
            goto LABEL_183;
          v123 = v194;
          v60 = v193;
          if (v194 == v193)
            goto LABEL_182;
          do
          {
            v125 = *--v123;
            v124 = v125;
            *v123 = 0;
            if (v125)
              MEMORY[0x20BD002D4](v124, 0x1000C8077774924);
          }
          while (v123 != v58);
          goto LABEL_181;
        }
        if (*(_UNKNOWN **)(*(_QWORD *)v11 + 136) != &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
          v11 = 0;
        v181 = v11;
        if (!v11)
          goto LABEL_136;
        v12 = (__int128 *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v181);
        v13 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v181);
        if (v12 != (__int128 *)v13)
          break;
LABEL_21:
        if (++v10 == v7)
          goto LABEL_22;
      }
      v14 = (__int128 *)v13;
      while (1)
      {
        v186 = *v12;
        v188[0] = MirInfoChannelAssignment::GetNumNeededNEs((MirInfoChannelAssignment *)&v186);
        AttrData = (_BYTE *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v188);
        if (!v16)
          break;
        v17 = AttrData;
        v18 = (char *)memchr(AttrData, 46, v16);
        if (!v18 || v18 - v17 == -1)
          break;
        NameDialect = mlir::NamedAttribute::getNameDialect((mlir::NamedAttribute *)&v186);
        if (NameDialect
          && !(*(unsigned __int8 (**)(uint64_t, uint64_t *, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)NameDialect + 80))(NameDialect, v185, 0, v10, v186, *((_QWORD *)&v186 + 1)))
        {
          return 0;
        }
        if (++v12 == v14)
          goto LABEL_21;
      }
      v182[0] = (const void **)"arguments may only have dialect attributes";
      v183 = 259;
      mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
      v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
      if (v188[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
      if (!v197)
        return v35;
      v88 = __p;
      if (__p)
      {
        v89 = v196;
        v90 = __p;
        if (v196 != __p)
        {
          do
            v89 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v89 - 1);
          while (v89 != v88);
          v90 = __p;
        }
        v196 = v88;
        operator delete(v90);
      }
      v58 = v193;
      if (!v193)
        goto LABEL_183;
      v91 = v194;
      v60 = v193;
      if (v194 == v193)
        goto LABEL_182;
      do
      {
        v93 = *--v91;
        v92 = v93;
        *v91 = 0;
        if (v93)
          MEMORY[0x20BD002D4](v92, 0x1000C8077774924);
      }
      while (v91 != v58);
      goto LABEL_181;
    }
  }
LABEL_22:
  v20 = &v185[2 * (((unint64_t)*((unsigned int *)v185 + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)v185 + 11)))
    v20 = 0;
  v184 = v20[2];
  if (v184)
  {
    v188[0] = v20[1];
    v188[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v188);
    mlir::FunctionType::getResults((mlir::FunctionType *)v188);
    v22 = v21;
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
    v23 = v22;
    if (v24 != v22)
    {
      v183 = 257;
      mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
      if (v188[0])
      {
        LODWORD(v186) = 3;
        *((_QWORD *)&v186 + 1) = "expects result attribute array to have the same number of elements as the number of fun"
                                 "ction results, got ";
        v187 = 106;
        v63 = (char *)&v186;
        v64 = (char *)v189;
        if (v190 >= v191)
        {
          v151 = v190 + 1;
          if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
          {
            v170 = (char *)&v186 - (_BYTE *)v189;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v151, 24);
            v64 = (char *)v189;
            v63 = (char *)v189 + v170;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v151, 24);
            v63 = (char *)&v186;
            v64 = (char *)v189;
          }
        }
        v65 = &v64[24 * v190];
        v66 = *(_OWORD *)v63;
        *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
        *(_OWORD *)v65 = v66;
        ++v190;
      }
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
      if (v188[0])
      {
        LODWORD(v186) = 5;
        *((_QWORD *)&v186 + 1) = v67;
        v68 = (char *)&v186;
        v69 = (char *)v189;
        if (v190 >= v191)
        {
          v152 = v190 + 1;
          if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
          {
            v171 = (char *)&v186 - (_BYTE *)v189;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v152, 24);
            v69 = (char *)v189;
            v68 = (char *)v189 + v171;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v152, 24);
            v68 = (char *)&v186;
            v69 = (char *)v189;
          }
        }
        v70 = &v69[24 * v190];
        v71 = *(_OWORD *)v68;
        *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
        *(_OWORD *)v70 = v71;
        v72 = ++v190;
        if (v188[0])
        {
          LODWORD(v186) = 3;
          *((_QWORD *)&v186 + 1) = ", but expected ";
          v187 = 15;
          v73 = (char *)&v186;
          v74 = (char *)v189;
          if (v72 >= v191)
          {
            v155 = v72 + 1;
            v156 = (char *)v189 + 24 * v72 > (char *)&v186;
            if (v189 <= &v186 && v156)
            {
              v173 = (char *)&v186 - (_BYTE *)v189;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v155, 24);
              v74 = (char *)v189;
              v73 = (char *)v189 + v173;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v155, 24);
              v73 = (char *)&v186;
              v74 = (char *)v189;
            }
          }
          v75 = &v74[24 * v190];
          v76 = *(_OWORD *)v73;
          *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
          *(_OWORD *)v75 = v76;
          v77 = ++v190;
          if (v188[0])
          {
            LODWORD(v186) = 5;
            *((_QWORD *)&v186 + 1) = v23;
            v78 = (char *)&v186;
            v79 = (char *)v189;
            if (v77 >= v191)
            {
              v157 = v77 + 1;
              v158 = (char *)v189 + 24 * v77 > (char *)&v186;
              if (v189 <= &v186 && v158)
              {
                v174 = (char *)&v186 - (_BYTE *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v157, 24);
                v79 = (char *)v189;
                v78 = (char *)v189 + v174;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v157, 24);
                v78 = (char *)&v186;
                v79 = (char *)v189;
              }
            }
            v80 = &v79[24 * v190];
            v81 = *(_OWORD *)v78;
            *((_QWORD *)v80 + 2) = *((_QWORD *)v78 + 2);
            *(_OWORD *)v80 = v81;
            ++v190;
          }
        }
      }
      v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
      if (v188[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
      if (v197)
      {
        v82 = __p;
        if (__p)
        {
          v83 = v196;
          v84 = __p;
          if (v196 != __p)
          {
            do
              v83 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v83 - 1);
            while (v83 != v82);
            v84 = __p;
          }
          v196 = v82;
          operator delete(v84);
        }
        v58 = v193;
        if (!v193)
          goto LABEL_183;
        v85 = v194;
        v60 = v193;
        if (v194 == v193)
          goto LABEL_182;
        do
        {
          v87 = *--v85;
          v86 = v87;
          *v85 = 0;
          if (v87)
            MEMORY[0x20BD002D4](v86, 0x1000C8077774924);
        }
        while (v85 != v58);
        goto LABEL_181;
      }
      return v35;
    }
    if (v22)
    {
      v25 = 0;
      while (1)
      {
        v26 = *(_QWORD *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184) + 8 * v25);
        if (!v26)
        {
          v181 = 0;
LABEL_159:
          v183 = 257;
          mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
          if (v188[0])
          {
            LODWORD(v186) = 3;
            v187 = 69;
            v126 = (char *)&v186;
            v127 = (char *)v189;
            if (v190 >= v191)
            {
              v163 = v190 + 1;
              if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
              {
                v178 = (char *)&v186 - (_BYTE *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v163, 24);
                v127 = (char *)v189;
                v126 = (char *)v189 + v178;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v163, 24);
                v126 = (char *)&v186;
                v127 = (char *)v189;
              }
            }
            v128 = &v127[24 * v190];
            v129 = *(_OWORD *)v126;
            *((_QWORD *)v128 + 2) = *((_QWORD *)v126 + 2);
            *(_OWORD *)v128 = v129;
            ++v190;
          }
          v130 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
          if (v188[0])
          {
            v131 = (char *)&v186;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v186, *(_QWORD *)(v130 + 8 * v25));
            v132 = (char *)v189;
            if (v190 >= v191)
            {
              v164 = v190 + 1;
              if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
              {
                v179 = (char *)&v186 - (_BYTE *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v164, 24);
                v132 = (char *)v189;
                v131 = (char *)v189 + v179;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v164, 24);
                v131 = (char *)&v186;
                v132 = (char *)v189;
              }
            }
            v133 = &v132[24 * v190];
            v134 = *(_OWORD *)v131;
            *((_QWORD *)v133 + 2) = *((_QWORD *)v131 + 2);
            *(_OWORD *)v133 = v134;
            v135 = ++v190;
            if (v188[0])
            {
              LODWORD(v186) = 3;
              v187 = 1;
              v136 = (char *)&v186;
              v137 = (char *)v189;
              if (v135 >= v191)
              {
                v165 = v135 + 1;
                v166 = (char *)v189 + 24 * v135 > (char *)&v186;
                if (v189 <= &v186 && v166)
                {
                  v180 = (char *)&v186 - (_BYTE *)v189;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v165, 24);
                  v137 = (char *)v189;
                  v136 = (char *)v189 + v180;
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v165, 24);
                  v136 = (char *)&v186;
                  v137 = (char *)v189;
                }
              }
              v138 = &v137[24 * v190];
              v139 = *(_OWORD *)v136;
              *((_QWORD *)v138 + 2) = *((_QWORD *)v136 + 2);
              *(_OWORD *)v138 = v139;
              ++v190;
            }
          }
          v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
          if (v188[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
          if (!v197)
            return v35;
          v140 = __p;
          if (__p)
          {
            v141 = v196;
            v142 = __p;
            if (v196 != __p)
            {
              do
                v141 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v141 - 1);
              while (v141 != v140);
              v142 = __p;
            }
            v196 = v140;
            operator delete(v142);
          }
          v58 = v193;
          if (!v193)
            goto LABEL_183;
          v143 = v194;
          v60 = v193;
          if (v194 == v193)
            goto LABEL_182;
          do
          {
            v145 = *--v143;
            v144 = v145;
            *v143 = 0;
            if (v145)
              MEMORY[0x20BD002D4](v144, 0x1000C8077774924);
          }
          while (v143 != v58);
          goto LABEL_181;
        }
        if (*(_UNKNOWN **)(*(_QWORD *)v26 + 136) != &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
          v26 = 0;
        v181 = v26;
        if (!v26)
          goto LABEL_159;
        v27 = (__int128 *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v181);
        v28 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v181);
        if (v27 != (__int128 *)v28)
          break;
LABEL_41:
        if (++v25 == v22)
          goto LABEL_42;
      }
      v29 = (__int128 *)v28;
      while (1)
      {
        v186 = *v27;
        v188[0] = MirInfoChannelAssignment::GetNumNeededNEs((MirInfoChannelAssignment *)&v186);
        v30 = (_BYTE *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v188);
        if (!v31)
          break;
        v32 = v30;
        v33 = (char *)memchr(v30, 46, v31);
        if (!v33 || v33 - v32 == -1)
          break;
        v34 = mlir::NamedAttribute::getNameDialect((mlir::NamedAttribute *)&v186);
        if (v34
          && !(*(unsigned __int8 (**)(uint64_t, uint64_t *, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v34 + 88))(v34, v185, 0, v25, v186, *((_QWORD *)&v186 + 1)))
        {
          return 0;
        }
        if (++v27 == v29)
          goto LABEL_41;
      }
      v182[0] = (const void **)"results may only have dialect attributes";
      v183 = 259;
      mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
      v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
      if (v188[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
      if (!v197)
        return v35;
      v100 = __p;
      if (__p)
      {
        v101 = v196;
        v102 = __p;
        if (v196 != __p)
        {
          do
            v101 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v101 - 1);
          while (v101 != v100);
          v102 = __p;
        }
        v196 = v100;
        operator delete(v102);
      }
      v58 = v193;
      if (!v193)
        goto LABEL_183;
      v103 = v194;
      v60 = v193;
      if (v194 == v193)
        goto LABEL_182;
      do
      {
        v105 = *--v103;
        v104 = v105;
        *v103 = 0;
        if (v105)
          MEMORY[0x20BD002D4](v104, 0x1000C8077774924);
      }
      while (v103 != v58);
      goto LABEL_181;
    }
  }
LABEL_42:
  if ((*((_DWORD *)v185 + 11) & 0x7FFFFF) == 1)
    return mlir::detail::FunctionOpInterfaceTrait<mlir::func::FuncOp>::verifyBody(&v185);
  v182[0] = (const void **)"expects one region";
  v183 = 259;
  mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
  v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
  if (v188[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
  if (v197)
  {
    v94 = __p;
    if (__p)
    {
      v95 = v196;
      v96 = __p;
      if (v196 != __p)
      {
        do
          v95 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v95 - 1);
        while (v95 != v94);
        v96 = __p;
      }
      v196 = v94;
      operator delete(v96);
    }
    v58 = v193;
    if (!v193)
      goto LABEL_183;
    v97 = v194;
    v60 = v193;
    if (v194 == v193)
    {
LABEL_182:
      v194 = v58;
      operator delete(v60);
LABEL_183:
      if (v189 != v192)
        free(v189);
      return v35;
    }
    do
    {
      v99 = *--v97;
      v98 = v99;
      *v97 = 0;
      if (v99)
        MEMORY[0x20BD002D4](v98, 0x1000C8077774924);
    }
    while (v97 != v58);
LABEL_181:
    v60 = v193;
    goto LABEL_182;
  }
  return v35;
}

BOOL mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::OpTrait::impl::verifyIsIsolatedFromAbove(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x24BDAC8D0];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ReturnOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"func.return", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::ReturnOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_24C0472F0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_24C034118;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  JUMPOUT(0x20BD002F8);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::foldHook()
{
  uint64_t v0;
  llvm *v2;
  void *v3;

  v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::func::ReturnOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  llvm **v10;
  llvm *v11[2];
  unint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                    + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0)
        v10 = v11;
      else
        v10 = (llvm **)v11[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0)
      llvm::deallocate_buffer(v11[0], v11[1]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x24BDAC8D0];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD *v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = *--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            MEMORY[0x20BD002D4](v16, 0x1000C8077774924);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ReturnOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  *v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ReturnOp>::getSpeculatability;
  v4 = &unk_25451A000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_25451A000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      v15 = 81;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_25451A000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[304], v2);
}

