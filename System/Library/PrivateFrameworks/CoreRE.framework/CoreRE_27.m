uint64_t re::internal::setTypeMismatchError<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, re::TypeInfo *this, re::TypeInfo *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v7 = re::TypeInfo::name(this)[1];
  re::TypeInfo::name(a4);
}

BOOL re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(uint64_t a1, char *a2, unsigned __int8 *a3)
{
  int v3;
  char *v6;
  int v7;
  uint64_t v8;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), a2);
    v6 = *(char **)(a1 + 168);
    v7 = *a3;
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteBool((uint64_t *)v6, v7);
    v8 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v8 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(uint64_t a1, char *a2, uint64_t a3)
{
  int v3;
  char *v6;
  uint64_t v7;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), a2);
    v6 = *(char **)(a1 + 168);
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString((uint64_t *)v6, a3, 1u);
    v7 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v7 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeI8(uint64_t a1, char *a2, char *a3)
{
  int v3;
  char *v6;
  rapidjson::internal *v7;
  char *v8;
  uint64_t v9;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), a2);
    v6 = *(char **)(a1 + 168);
    v7 = (rapidjson::internal *)*a3;
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeI16(uint64_t a1, char *a2, __int16 *a3)
{
  int v3;
  char *v6;
  rapidjson::internal *v7;
  char *v8;
  uint64_t v9;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), a2);
    v6 = *(char **)(a1 + 168);
    v7 = (rapidjson::internal *)*a3;
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeI32(uint64_t a1, char *a2, unsigned int *a3)
{
  int v3;
  char *v6;
  rapidjson::internal *v7;
  char *v8;
  uint64_t v9;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), a2);
    v6 = *(char **)(a1 + 168);
    v7 = (rapidjson::internal *)*a3;
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeI64(uint64_t a1, char *a2, unint64_t *a3)
{
  int v3;
  char *v6;
  unint64_t v7;
  char *v8;
  uint64_t v9;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), a2);
    v6 = *(char **)(a1 + 168);
    v7 = *a3;
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteInt64((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeU8(uint64_t a1, char *a2, unsigned __int8 *a3)
{
  int v3;
  char *v6;
  rapidjson::internal *v7;
  char *v8;
  uint64_t v9;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), a2);
    v6 = *(char **)(a1 + 168);
    v7 = (rapidjson::internal *)*a3;
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeU16(uint64_t a1, char *a2, unsigned __int16 *a3)
{
  int v3;
  char *v6;
  rapidjson::internal *v7;
  char *v8;
  uint64_t v9;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), a2);
    v6 = *(char **)(a1 + 168);
    v7 = (rapidjson::internal *)*a3;
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeU32(uint64_t a1, char *a2, unsigned int *a3)
{
  int v3;
  char *v6;
  rapidjson::internal *v7;
  char *v8;
  uint64_t v9;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), a2);
    v6 = *(char **)(a1 + 168);
    v7 = (rapidjson::internal *)*a3;
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeU64(uint64_t a1, char *a2, rapidjson::internal **a3)
{
  int v3;
  char *v6;
  rapidjson::internal *v7;
  char *v8;
  uint64_t v9;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), a2);
    v6 = *(char **)(a1 + 168);
    v7 = *a3;
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint64((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeFloat(uint64_t a1, char *a2, float *a3)
{
  int v3;
  float v6;
  uint64_t v7;
  char *v8;
  double v9;
  uint64_t v10;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), a2);
    v6 = *a3;
    v7 = *(_QWORD *)(a1 + 168);
    if (fabsf(v6) == INFINITY)
    {
      if (v6 <= 0.0)
        v8 = "-Infinity";
      else
        v8 = "Infinity";
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), v8);
    }
    else
    {
      v9 = v6;
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(*(char **)(a1 + 168));
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteDouble(v7, v9);
    }
    v10 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v10 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeDouble(uint64_t a1, char *a2, double *a3)
{
  int v3;
  double v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), a2);
    v6 = *a3;
    v7 = *(_QWORD *)(a1 + 168);
    if (fabs(v6) == INFINITY)
    {
      if (v6 <= 0.0)
        v8 = "-Infinity";
      else
        v8 = "Infinity";
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), v8);
    }
    else
    {
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(*(char **)(a1 + 168));
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteDouble(v7, v6);
    }
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

uint64_t rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(char *a1, char *__s)
{
  unsigned int v4;

  v4 = strlen(__s);
  rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(a1);
  return rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString((uint64_t *)a1, (uint64_t)__s, v4);
}

char *rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(char *result)
{
  char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  _BYTE *v9;
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  char *v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v1 = result;
  v2 = *((_QWORD *)result + 4);
  if (v2 == *((_QWORD *)result + 3))
  {
    result[60] = 1;
    return result;
  }
  v3 = *(_QWORD *)(v2 - 16);
  if (*(_BYTE *)(v2 - 8))
  {
    if (v3)
    {
      v4 = *(_QWORD *)result;
      v5 = *(_BYTE **)(*(_QWORD *)result + 24);
      if ((uint64_t)(*(_QWORD *)(*(_QWORD *)result + 32) - (_QWORD)v5) <= 0)
      {
        v16 = *(_QWORD *)result;
        result = rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v4, 1);
        v4 = v16;
        v5 = *(_BYTE **)(v16 + 24);
      }
      *(_QWORD *)(v4 + 24) = v5 + 1;
      *v5 = 44;
      if ((v1[68] & 1) != 0)
      {
        v6 = *(_QWORD *)v1;
        v7 = *(_BYTE **)(*(_QWORD *)v1 + 24);
        if ((uint64_t)(*(_QWORD *)(*(_QWORD *)v1 + 32) - (_QWORD)v7) <= 0)
        {
          v19 = *(_QWORD *)v1;
          result = rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v6, 1);
          v6 = v19;
          v7 = *(_BYTE **)(v19 + 24);
        }
        *(_QWORD *)(v6 + 24) = v7 + 1;
        *v7 = 32;
      }
    }
    if ((v1[68] & 1) != 0)
      goto LABEL_30;
    v8 = *(_QWORD *)v1;
    v9 = *(_BYTE **)(*(_QWORD *)v1 + 24);
    if ((uint64_t)(*(_QWORD *)(*(_QWORD *)v1 + 32) - (_QWORD)v9) <= 0)
    {
      v17 = *(_QWORD *)v1;
      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v8, 1);
      v8 = v17;
      v9 = *(_BYTE **)(v17 + 24);
    }
    *(_QWORD *)(v8 + 24) = v9 + 1;
    *v9 = 10;
    goto LABEL_29;
  }
  if (!v3)
    goto LABEL_20;
  v10 = *(_QWORD *)result;
  v11 = *(_BYTE **)(*(_QWORD *)result + 24);
  if ((v3 & 1) == 0)
  {
    if ((uint64_t)(*(_QWORD *)(*(_QWORD *)result + 32) - (_QWORD)v11) <= 0)
    {
      v20 = *(_QWORD *)result;
      result = rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v10, 1);
      v10 = v20;
      v11 = *(_BYTE **)(v20 + 24);
    }
    *(_QWORD *)(v10 + 24) = v11 + 1;
    *v11 = 44;
LABEL_20:
    v12 = *(_QWORD *)v1;
    v13 = *(char **)(*(_QWORD *)v1 + 24);
    if ((uint64_t)(*(_QWORD *)(*(_QWORD *)v1 + 32) - (_QWORD)v13) <= 0)
    {
      v18 = *(_QWORD *)v1;
      result = rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v12, 1);
      v12 = v18;
      v13 = *(char **)(v18 + 24);
    }
    *(_QWORD *)(v12 + 24) = v13 + 1;
    v14 = 10;
    goto LABEL_28;
  }
  if ((uint64_t)(*(_QWORD *)(*(_QWORD *)result + 32) - (_QWORD)v11) <= 0)
  {
    v21 = *(_QWORD *)result;
    result = rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v10, 1);
    v10 = v21;
    v11 = *(_BYTE **)(v21 + 24);
  }
  *(_QWORD *)(v10 + 24) = v11 + 1;
  *v11 = 58;
  v15 = *(_QWORD *)v1;
  v13 = *(char **)(*(_QWORD *)v1 + 24);
  if ((uint64_t)(*(_QWORD *)(*(_QWORD *)v1 + 32) - (_QWORD)v13) <= 0)
  {
    v22 = *(_QWORD *)v1;
    result = rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(v15, 1);
    v15 = v22;
    v13 = *(char **)(v22 + 24);
  }
  *(_QWORD *)(v15 + 24) = v13 + 1;
  v14 = 32;
LABEL_28:
  *v13 = v14;
  if ((*(_BYTE *)(v2 - 16) & 1) == 0)
LABEL_29:
    result = rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteIndent(v1);
LABEL_30:
  ++*(_QWORD *)(v2 - 16);
  return result;
}

char *rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteIndent(char *result)
{
  uint64_t v1;
  uint64_t v2;
  char v3;
  char *v4;

  v1 = ((*((_QWORD *)result + 4) - *((_QWORD *)result + 3)) >> 4) * *((unsigned int *)result + 16);
  v2 = *(_QWORD *)result;
  v3 = result[61];
  if (*(_QWORD *)(*(_QWORD *)result + 32) - *(_QWORD *)(*(_QWORD *)result + 24) < v1)
  {
    result = rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*(_QWORD *)result, v1);
    if (!v1)
      return result;
  }
  else if (!v1)
  {
    return result;
  }
  do
  {
    v4 = *(char **)(v2 + 24);
    *(_QWORD *)(v2 + 24) = v4 + 1;
    *v4 = v3;
    --v1;
  }
  while (v1);
  return result;
}

BOOL re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(uint64_t a1, char *__s, uint64_t *a3)
{
  int v3;
  uint64_t v7;
  char *v8;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), __s);
    v7 = *a3;
    if (!*a3)
    {
      v8 = *(char **)(a1 + 168);
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v8);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString((uint64_t *)v8, (uint64_t)"", 0);
      v7 = *a3;
    }
    LOBYTE(v10) = 8;
    DWORD1(v10) = 0;
    *((_QWORD *)&v10 + 1) = __s;
    v11 = 0;
    v13 = 0;
    v14 = 0;
    v12 = v7;
  }
  return v3 == 0;
}

uint64_t re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;

  if (!*(_BYTE *)(result + 40))
  {
    v3 = result;
    v4 = *(_QWORD *)(*(_QWORD *)(result + 128) + 48 * *(_QWORD *)(result + 112) - 24);
    v5 = *(char **)(result + 168);
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v5);
    result = rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString((uint64_t *)v5, a2, v4);
    v6 = *(_QWORD *)(v3 + 128) + 48 * *(_QWORD *)(v3 + 112);
    *(_QWORD *)(v6 - 16) += v4;
  }
  return result;
}

double re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(uint64_t a1, char *__s, _BYTE *a3)
{
  uint64_t v6;
  char *v7;
  double result;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), __s);
    if (*a3)
    {
      v6 = 1;
    }
    else
    {
      v7 = *(char **)(a1 + 168);
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v7);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteNull((uint64_t *)v7);
      v6 = *a3;
    }
    LOBYTE(v9) = 3;
    DWORD1(v9) = 0;
    *((_QWORD *)&v9 + 1) = __s;
    v10 = 0;
    v12 = 0;
    v13 = 0;
    v11 = v6;
  }
  return result;
}

BOOL re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(uint64_t a1, char *__s, uint64_t *a3, int a4)
{
  int v4;
  uint64_t v9;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v4 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), __s);
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartArray(*(_QWORD *)(a1 + 168));
    v9 = *a3;
    LOBYTE(v11) = 5;
    DWORD1(v11) = a4 & 0xFFFFFFDF;
    *((_QWORD *)&v11 + 1) = __s;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = v9;
  }
  return v4 == 0;
}

_anonymous_namespace_ *re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endArray(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  _anonymous_namespace_ *v7;
  char v8;
  _BYTE v9[23];
  uint64_t v10;
  char v11;

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    v2 = *((_QWORD *)result + 16);
    v3 = *((_QWORD *)result + 14);
    if (*(_QWORD *)(v2 + 48 * v3 - 16) == *(_QWORD *)(v2 + 48 * v3 - 24))
    {
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::EndArray(*((uint64_t **)result + 21));
      v4 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      ++*(_QWORD *)(v4 - 16);
    }
    else
    {
      if ((v8 & 1) != 0)
        v5 = *(_BYTE **)&v9[7];
      else
        v5 = v9;
      v6 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize array \"%s\". Expected number of elements: %lld. Actual number of elements: %lld.", (re::DynamicString *)&v10, v5, *(_QWORD *)(v6 - 24), *(_QWORD *)(v6 - 16));
      if (v10 && (v11 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v10 + 40))();
      result = v7;
      if (v7)
      {
        if ((v8 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v7 + 40))();
      }
    }
  }
  return result;
}

uint64_t rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartArray(uint64_t a1)
{
  uint64_t v2;

  rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix((char *)a1);
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(a1 + 40) - v2 <= 15)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Level>(a1 + 8, 1);
    v2 = *(_QWORD *)(a1 + 32);
  }
  *(_QWORD *)(a1 + 32) = v2 + 16;
  *(_QWORD *)v2 = 0;
  *(_BYTE *)(v2 + 8) = 1;
  return rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteStartArray((uint64_t *)a1);
}

uint64_t rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::EndArray(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE *v5;

  v2 = a1[4];
  v3 = *(_QWORD *)(v2 - 16);
  a1[4] = v2 - 16;
  if (v3 && (*((_BYTE *)a1 + 68) & 1) == 0)
  {
    v4 = *a1;
    v5 = *(_BYTE **)(*a1 + 24);
    if ((uint64_t)(*(_QWORD *)(*a1 + 32) - (_QWORD)v5) <= 0)
    {
      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, 1);
      v5 = *(_BYTE **)(v4 + 24);
    }
    *(_QWORD *)(v4 + 24) = v5 + 1;
    *v5 = 10;
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteIndent((char *)a1);
  }
  rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndArray(a1);
  return 1;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unint64_t *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t **v29;
  unint64_t **v30;
  unint64_t *v31;
  unint64_t *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unint64_t **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unint64_t *, _BYTE *, _BYTE *, _QWORD))v18;
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unsigned int *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int **v29;
  unsigned int **v30;
  unsigned int *v31;
  unsigned int *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unsigned int **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unsigned int *, _BYTE *, _BYTE *, _QWORD))v18;
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__base_10_u32[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unsigned __int16 *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unsigned __int16 **v29;
  unsigned __int16 **v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unsigned __int16 **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unsigned __int16 *, _BYTE *, _BYTE *, _QWORD))v18;
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__base_10_u32[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unsigned __int8 *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unsigned __int8 **v29;
  unsigned __int8 **v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unsigned __int8 **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unsigned __int8 *, _BYTE *, _BYTE *, _QWORD))v18;
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__base_10_u32[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, uint64_t *, _BYTE *, _BYTE *, _QWORD);
  _anonymous_namespace_ *v20;
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t **v30;
  uint64_t **v31;
  unint64_t v32;
  __n128 *v33;
  uint64_t *v34;
  unsigned int v35;
  int64_t v36;
  _WORD *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  uint64_t **v52;
  __n128 v53[2];
  _QWORD v54[2];

  v54[0] = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, uint64_t *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
    if (v23)
    {
      v52 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v48 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v23);
      ++v51;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v45 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v24);
          v53[0].n128_u64[0] = v25;
          v53[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, v53);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v24, v17);
      v28 = 126 - 2 * __clz(v50);
      if (v50)
        v29 = v28;
      else
        v29 = 0;
      if (v50)
      {
        v30 = v52;
        v31 = &v52[2 * v50];
        do
        {
          v32 = **v30;
          if ((v32 & 0x8000000000000000) != 0)
          {
            v53[0].n128_u8[0] = 45;
            v32 = -(uint64_t)v32;
            v33 = (__n128 *)((char *)v53[0].n128_u64 + 1);
          }
          else
          {
            v33 = v53;
          }
          v34 = v30[1];
          if ((char *)v54 - (char *)v33 > 19
            || (v35 = (1233 * (64 - __clz(v32 | 1))) >> 12,
                v36 = v35 - (std::__itoa::__pow10_64[v35] > v32) + 1,
                v37 = v54,
                (char *)v54 - (char *)v33 >= v36))
          {
            v37 = std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:nn180100](v33, v32);
          }
          *(_BYTE *)v37 = 0;
          v19(a1, v53, 0, v34, v47, v46, 0);
          v30 += 2;
        }
        while (v30 != v31);
      }
      if (v48)
      {
        if (v52)
          (*(void (**)(void))(*(_QWORD *)v48 + 40))();
      }
      v20 = (_anonymous_namespace_ *)(a1 + 24);
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v38 = re::TypeInfo::name((re::TypeInfo *)v47);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, int *, _BYTE *, _BYTE *, _QWORD);
  _anonymous_namespace_ *v20;
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  int **v30;
  int **v31;
  unsigned int v32;
  __n128 *v33;
  int *v34;
  unsigned int v35;
  int64_t v36;
  _WORD *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  int **v52;
  __n128 v53[2];
  _QWORD v54[2];

  v54[0] = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, int *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
    if (v23)
    {
      v52 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v48 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v23);
      ++v51;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v45 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v24);
          v53[0].n128_u64[0] = v25;
          v53[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, v53);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v24, v17);
      v28 = 126 - 2 * __clz(v50);
      if (v50)
        v29 = v28;
      else
        v29 = 0;
      if (v50)
      {
        v30 = v52;
        v31 = &v52[2 * v50];
        do
        {
          v32 = **v30;
          if ((v32 & 0x80000000) != 0)
          {
            v53[0].n128_u8[0] = 45;
            v32 = -v32;
            v33 = (__n128 *)((char *)v53[0].n128_u64 + 1);
          }
          else
          {
            v33 = v53;
          }
          v34 = v30[1];
          if ((char *)v54 - (char *)v33 > 9
            || (v35 = (1233 * (32 - __clz(v32 | 1))) >> 12,
                v36 = (((__PAIR64__(v35, v32) - std::__itoa::__pow10_32[v35]) >> 32) + 1),
                v37 = v54,
                (char *)v54 - (char *)v33 >= v36))
          {
            v37 = std::__itoa::__base_10_u32[abi:nn180100](v33, v32);
          }
          *(_BYTE *)v37 = 0;
          v19(a1, v53, 0, v34, v47, v46, 0);
          v30 += 2;
        }
        while (v30 != v31);
      }
      if (v48)
      {
        if (v52)
          (*(void (**)(void))(*(_QWORD *)v48 + 40))();
      }
      v20 = (_anonymous_namespace_ *)(a1 + 24);
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v38 = re::TypeInfo::name((re::TypeInfo *)v47);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, __int16 *, _BYTE *, _BYTE *, _QWORD);
  _anonymous_namespace_ *v20;
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  __int16 **v30;
  __int16 **v31;
  unsigned int v32;
  __n128 *v33;
  __int16 *v34;
  unsigned int v35;
  int64_t v36;
  _WORD *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  __int16 **v52;
  __n128 v53[2];
  _QWORD v54[2];

  v54[0] = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, __int16 *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
    if (v23)
    {
      v52 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v48 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v23);
      ++v51;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v45 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v24);
          v53[0].n128_u64[0] = v25;
          v53[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, v53);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v24, v17);
      v28 = 126 - 2 * __clz(v50);
      if (v50)
        v29 = v28;
      else
        v29 = 0;
      if (v50)
      {
        v30 = v52;
        v31 = &v52[2 * v50];
        do
        {
          v32 = **v30;
          if ((v32 & 0x80000000) != 0)
          {
            v53[0].n128_u8[0] = 45;
            v32 = -v32;
            v33 = (__n128 *)((char *)v53[0].n128_u64 + 1);
          }
          else
          {
            v33 = v53;
          }
          v34 = v30[1];
          if ((char *)v54 - (char *)v33 > 9
            || (v35 = (1233 * (32 - __clz(v32 | 1))) >> 12,
                v36 = (((__PAIR64__(v35, v32) - std::__itoa::__pow10_32[v35]) >> 32) + 1),
                v37 = v54,
                (char *)v54 - (char *)v33 >= v36))
          {
            v37 = std::__itoa::__base_10_u32[abi:nn180100](v33, v32);
          }
          *(_BYTE *)v37 = 0;
          v19(a1, v53, 0, v34, v47, v46, 0);
          v30 += 2;
        }
        while (v30 != v31);
      }
      if (v48)
      {
        if (v52)
          (*(void (**)(void))(*(_QWORD *)v48 + 40))();
      }
      v20 = (_anonymous_namespace_ *)(a1 + 24);
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v38 = re::TypeInfo::name((re::TypeInfo *)v47);
  return 0;
}

BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v24;
  _BOOL8 result;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __n128 v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __n128 v43;
  char v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  uint64_t *v52;

  if (this == a6)
    goto LABEL_14;
  v13 = *(_QWORD **)this;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v14 = (uint64_t *)*((_QWORD *)a6 + 2);
    v16 = *v14;
    if ((unsigned __int16)v15 != (unsigned __int16)*v14)
      goto LABEL_10;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v21 = *(_QWORD *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
      re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
      v22 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
      if (!v22)
      {
        v37 = re::TypeInfo::name((re::TypeInfo *)v47);
        return 0;
      }
      v23 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v22;
      result = 0;
      if (!v24)
        return result;
      v26 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
      if (v26)
      {
        v52 = 0;
        v49 = 0;
        v50 = 0;
        v51 = 0;
        v48 = v21;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v26);
        ++v51;
        v27 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v21);
        if ((*(unsigned int (**)(void))(v45 + 120))())
        {
          do
          {
            v28 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v27);
            v29 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v27);
            v43.n128_u64[0] = v28;
            v43.n128_u64[1] = v29;
            v30 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, &v43);
          }
          while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v27, v30) & 1) != 0);
        }
        (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v27, v21);
        v31 = 126 - 2 * __clz(v50);
        if (v50)
          v32 = v31;
        else
          v32 = 0;
        if (v50)
        {
          v33 = v52;
          v34 = &v52[2 * v50];
          do
          {
            v35 = *v33;
            if ((*(_BYTE *)(*v33 + 8) & 1) != 0)
              v36 = *(_QWORD *)(v35 + 16);
            else
              v36 = v35 + 9;
            v23(a1, v36, 0, v33[1], v47, v46, 0);
            v33 += 2;
          }
          while (v33 != v34);
        }
        if (v48)
        {
          if (v52)
            (*(void (**)(void))(*(_QWORD *)v48 + 40))();
        }
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_14;
  v13 = *(_QWORD **)a6;
  v14 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v13, v14[9], &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  v19 = re::TypeInfo::name((re::TypeInfo *)v47);
  if ((unint64_t)*v19 >> 1 == 0x22C6ED80D0CLL)
  {
    v20 = (char *)v19[1];
    if (v20 == "StringID" || !strcmp(v20, "StringID"))
      goto LABEL_14;
  }
  return 0;
}

BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v24;
  _BOOL8 result;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __n128 v30;
  unint64_t v31;
  uint64_t v32;
  __int128 *v33;
  __int128 *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __n128 v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  __int128 *v52;

  if (this == a6)
    goto LABEL_14;
  v13 = *(_QWORD **)this;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v14 = (uint64_t *)*((_QWORD *)a6 + 2);
    v16 = *v14;
    if ((unsigned __int16)v15 != (unsigned __int16)*v14)
      goto LABEL_10;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v21 = *(_QWORD *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
      re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
      v22 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
      if (!v22)
      {
        v37 = re::TypeInfo::name((re::TypeInfo *)v47);
        return 0;
      }
      v23 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v22;
      result = 0;
      if (!v24)
        return result;
      v26 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
      if (v26)
      {
        v52 = 0;
        v49 = 0;
        v50 = 0;
        v51 = 0;
        v48 = v21;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v26);
        ++v51;
        v27 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v21);
        if ((*(unsigned int (**)(void))(v45 + 120))())
        {
          do
          {
            v28 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v27);
            v29 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v27);
            v43.n128_u64[0] = v28;
            v43.n128_u64[1] = v29;
            v30 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, &v43);
          }
          while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v27, v30) & 1) != 0);
        }
        (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v27, v21);
        v31 = 126 - 2 * __clz(v50);
        if (v50)
          v32 = v31;
        else
          v32 = 0;
        if (v50)
        {
          v33 = v52;
          v34 = &v52[v50];
          do
          {
            v36 = *(_QWORD *)v33;
            v35 = *((_QWORD *)v33++ + 1);
            v23(a1, *(_QWORD *)(v36 + 8), 0, v35, v47, v46, 0);
          }
          while (v33 != v34);
        }
        if (v48)
        {
          if (v52)
            (*(void (**)(void))(*(_QWORD *)v48 + 40))();
        }
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_14;
  v13 = *(_QWORD **)a6;
  v14 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v13, v14[9], &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  v19 = re::TypeInfo::name((re::TypeInfo *)v47);
  if ((unint64_t)*v19 >> 1 == 0x134375A94D9F7110)
  {
    v20 = (char *)v19[1];
    if (v20 == "DynamicString" || !strcmp(v20, "DynamicString"))
      goto LABEL_14;
  }
  return 0;
}

BOOL re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(uint64_t a1, char *__s, uint64_t *a3)
{
  int v3;
  uint64_t v7;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), __s);
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartArray(*(_QWORD *)(a1 + 168));
    v7 = *a3;
    LOBYTE(v9) = 6;
    DWORD1(v9) = 0;
    *((_QWORD *)&v9 + 1) = __s;
    v10 = 0;
    v12 = 0;
    v13 = 0;
    v11 = v7;
  }
  return v3 == 0;
}

double re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(uint64_t a1)
{
  double result;
  _OWORD v3[2];
  uint64_t v4;
  uint64_t v5;

  if (!*(_BYTE *)(a1 + 40))
  {
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartObject(*(_QWORD *)(a1 + 168));
    LOBYTE(v3[0]) = 7;
    DWORD1(v3[0]) = 32;
    *((_QWORD *)&v3[0] + 1) = "entry";
    v3[1] = xmmword_2260F4F20;
    v4 = 0;
    v5 = 0;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionaryEntry(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _BYTE *v5;
  _anonymous_namespace_ *v6;
  char v7;
  _BYTE v8[23];
  uint64_t v9;
  char v10;

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    v2 = *((_QWORD *)result + 16);
    v3 = *((_QWORD *)result + 14);
    if (*(_QWORD *)(v2 + 48 * v3 - 16) == 2)
    {
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::EndObject(*((uint64_t **)result + 21));
      v4 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      ++*(_QWORD *)(v4 - 16);
    }
    else
    {
      if ((v7 & 1) != 0)
        v5 = *(_BYTE **)&v8[7];
      else
        v5 = v8;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary entry \"%s\". Expected 2 objects (key+value). Actual number of objects: %lld.", (re::DynamicString *)&v9, v5, *(_QWORD *)(*((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14) - 16));
      if (v9 && (v10 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v9 + 40))();
      result = v6;
      if (v6)
      {
        if ((v7 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v6 + 40))();
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionary(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  _anonymous_namespace_ *v7;
  char v8;
  _BYTE v9[23];
  uint64_t v10;
  char v11;

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    v2 = *((_QWORD *)result + 16);
    v3 = *((_QWORD *)result + 14);
    if (*(_QWORD *)(v2 + 48 * v3 - 16) == *(_QWORD *)(v2 + 48 * v3 - 24))
    {
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::EndArray(*((uint64_t **)result + 21));
      v4 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      ++*(_QWORD *)(v4 - 16);
    }
    else
    {
      if ((v8 & 1) != 0)
        v5 = *(_BYTE **)&v9[7];
      else
        v5 = v9;
      v6 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary \"%s\". Expected number of entries: %lld. Actual number of entries: %lld.", (re::DynamicString *)&v10, v5, *(_QWORD *)(v6 - 24), *(_QWORD *)(v6 - 16));
      if (v10 && (v11 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v10 + 40))();
      result = v7;
      if (v7)
      {
        if ((v8 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v7 + 40))();
      }
    }
  }
  return result;
}

void std::sort[abi:nn180100]<re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1}>(char *a1, char *a2, uint64_t (*a3)(uint64_t, uint64_t))
{
  unint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t, uint64_t);

  v3 = 126 - 2 * __clz((a2 - a1) >> 4);
  v5 = a3;
  if (a2 == a1)
    v4 = 0;
  else
    v4 = v3;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*,false>(unint64_t **a1, unint64_t **a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t **v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t **v18;
  unint64_t **v19;
  unint64_t *v20;
  unint64_t *v21;
  __int128 *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t *v25;
  BOOL v26;
  unint64_t *v27;
  unint64_t **v28;
  _OWORD *v29;
  unint64_t *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t *v34;
  __int128 *v35;
  _QWORD *v36;
  __int128 *v37;
  __int128 *v38;
  __int128 *v39;
  unint64_t **v40;
  _QWORD *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  unint64_t **v45;
  BOOL v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t **v50;
  unint64_t *v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  _QWORD *v55;
  int64_t v56;
  int64_t v57;
  int64_t v58;
  uint64_t v59;
  unint64_t **v60;
  unint64_t v61;
  unint64_t v62;
  BOOL v63;
  unint64_t **v64;
  unint64_t *v65;
  unint64_t *v66;
  unint64_t **v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  BOOL v71;
  uint64_t v72;
  uint64_t v73;
  _OWORD *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  _OWORD *v80;
  _QWORD *v81;
  uint64_t v82;
  _OWORD *v83;
  unint64_t **v85;
  unint64_t *v86;
  unint64_t *v87;
  unint64_t **v88;
  unint64_t *v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(uint64_t a1, unint64_t **a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  unint64_t **v8;
  unint64_t **v9;
  uint64_t v10;
  int v11;
  unint64_t *v12;
  unint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t **v16;
  __int128 *v17;
  __int128 *v18;
  __int128 *v19;
  __int128 *v20;
  _QWORD *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  v4 = ((uint64_t)a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 2);
      if (**(a2 - 2) < **(_QWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32), (_OWORD *)a2 - 1);
      return 1;
    case 5:
      v17 = (__int128 *)(a1 + 16);
      v18 = (__int128 *)(a1 + 32);
      v19 = (__int128 *)(a1 + 48);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32), (_OWORD *)(a1 + 48));
      v21 = *(a2 - 2);
      v20 = (__int128 *)(a2 - 2);
      if (*v21 < **(_QWORD **)(a1 + 48))
      {
        v22 = *v19;
        *v19 = *v20;
        *v20 = v22;
        if (**(_QWORD **)v19 < **(_QWORD **)v18)
        {
          v23 = *v18;
          *v18 = *v19;
          *v19 = v23;
          if (**(_QWORD **)v18 < **(_QWORD **)v17)
          {
            v24 = *v17;
            *v17 = *v18;
            *v18 = v24;
            if (**(_QWORD **)(a1 + 16) < **(_QWORD **)a1)
            {
              v25 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v17;
              *v17 = v25;
            }
          }
        }
      }
      return 1;
    default:
      v8 = (unint64_t **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32));
      v9 = (unint64_t **)(a1 + 48);
      if ((unint64_t **)(a1 + 48) == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_QWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unint64_t **)(a1 + v14 + 48);
          goto LABEL_13;
        }
      }
      v16 = (unint64_t **)a1;
LABEL_13:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*,false>(unsigned int **a1, unsigned int **a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int **v12;
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int **v18;
  unsigned int **v19;
  unsigned int *v20;
  unsigned int *v21;
  __int128 *v22;
  unsigned int v23;
  unsigned int *v24;
  unsigned int *v25;
  BOOL v26;
  unsigned int *v27;
  unsigned int **v28;
  _OWORD *v29;
  unsigned int *v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int *v33;
  unsigned int *v34;
  __int128 *v35;
  _DWORD *v36;
  __int128 *v37;
  __int128 *v38;
  __int128 *v39;
  unsigned int **v40;
  _DWORD *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  unsigned int **v45;
  BOOL v47;
  uint64_t v48;
  unint64_t v49;
  unsigned int **v50;
  unsigned int *v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  _QWORD *v55;
  int64_t v56;
  int64_t v57;
  int64_t v58;
  uint64_t v59;
  unsigned int **v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  unsigned int **v64;
  unsigned int *v65;
  unsigned int *v66;
  unsigned int **v67;
  uint64_t v68;
  unsigned int v69;
  unsigned int v70;
  BOOL v71;
  uint64_t v72;
  uint64_t v73;
  _OWORD *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  _OWORD *v80;
  _DWORD *v81;
  uint64_t v82;
  _OWORD *v83;
  unsigned int **v85;
  unsigned int *v86;
  unsigned int *v87;
  unsigned int **v88;
  unsigned int *v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(uint64_t a1, unsigned int **a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  unsigned int **v8;
  unsigned int **v9;
  uint64_t v10;
  int v11;
  unsigned int *v12;
  unsigned int *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int **v16;
  __int128 *v17;
  __int128 *v18;
  __int128 *v19;
  __int128 *v20;
  _DWORD *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  v4 = ((uint64_t)a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 2);
      if (**(a2 - 2) < **(_DWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32), (_OWORD *)a2 - 1);
      return 1;
    case 5:
      v17 = (__int128 *)(a1 + 16);
      v18 = (__int128 *)(a1 + 32);
      v19 = (__int128 *)(a1 + 48);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32), (_OWORD *)(a1 + 48));
      v21 = *(a2 - 2);
      v20 = (__int128 *)(a2 - 2);
      if (*v21 < **(_DWORD **)(a1 + 48))
      {
        v22 = *v19;
        *v19 = *v20;
        *v20 = v22;
        if (**(_DWORD **)v19 < **(_DWORD **)v18)
        {
          v23 = *v18;
          *v18 = *v19;
          *v19 = v23;
          if (**(_DWORD **)v18 < **(_DWORD **)v17)
          {
            v24 = *v17;
            *v17 = *v18;
            *v18 = v24;
            if (**(_DWORD **)(a1 + 16) < **(_DWORD **)a1)
            {
              v25 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v17;
              *v17 = v25;
            }
          }
        }
      }
      return 1;
    default:
      v8 = (unsigned int **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32));
      v9 = (unsigned int **)(a1 + 48);
      if ((unsigned int **)(a1 + 48) == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_DWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unsigned int **)(a1 + v14 + 48);
          goto LABEL_13;
        }
      }
      v16 = (unsigned int **)a1;
LABEL_13:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*,false>(unsigned __int16 **a1, unsigned __int16 **a2, uint64_t a3, char a4)
{
  unsigned __int16 **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int16 **v12;
  unsigned __int16 *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned int v17;
  unsigned __int16 **v18;
  unsigned __int16 **v19;
  unsigned __int16 *v20;
  unsigned __int16 *v21;
  unsigned __int16 **v22;
  unsigned int v23;
  unsigned __int16 *v24;
  unsigned __int16 *v25;
  BOOL v26;
  unsigned __int16 *v27;
  unsigned __int16 **v28;
  unsigned __int16 **v29;
  unsigned __int16 *v30;
  unsigned __int16 *v31;
  unsigned int v32;
  unsigned __int16 *v33;
  unsigned __int16 *v34;
  unsigned __int16 **v35;
  unsigned __int16 *v36;
  unsigned __int16 **v37;
  unsigned __int16 **v38;
  unsigned __int16 **v39;
  unsigned __int16 **v40;
  unsigned __int16 *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  unsigned __int16 **v45;
  BOOL v47;
  uint64_t v48;
  unsigned __int16 **v49;
  unsigned __int16 **v50;
  unsigned __int16 *v51;
  unsigned __int16 *v52;
  uint64_t v53;
  unsigned int v54;
  unsigned __int16 **v55;
  int64_t v56;
  int64_t v57;
  int64_t v58;
  uint64_t v59;
  unsigned __int16 **v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  unsigned __int16 **v64;
  unsigned __int16 *v65;
  unsigned __int16 *v66;
  unsigned __int16 **v67;
  uint64_t v68;
  unsigned int v69;
  unsigned int v70;
  BOOL v71;
  unsigned int v72;
  uint64_t v73;
  uint64_t v74;
  unsigned __int16 **v75;
  unsigned __int16 **v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  unsigned __int16 **v81;
  unsigned __int16 *v82;
  unsigned __int16 *v83;
  unsigned __int16 **v84;
  unsigned __int16 **v86;
  unsigned __int16 *v87;
  unsigned __int16 *v88;
  unsigned __int16 **v89;
  unsigned __int16 *v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(unsigned __int16 **a1, unsigned __int16 **a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned __int16 **v6;
  __int128 v7;
  unsigned __int16 **v8;
  unsigned __int16 **v9;
  uint64_t v10;
  int v11;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned __int16 **v16;
  unsigned __int16 **v17;
  unsigned __int16 **v18;
  unsigned __int16 **v19;
  unsigned __int16 **v20;
  unsigned __int16 *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      v17 = a1 + 2;
      v18 = a1 + 4;
      v19 = a1 + 6;
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3);
      v21 = *(a2 - 2);
      v20 = a2 - 2;
      if (*v21 < *a1[6])
      {
        v22 = *(_OWORD *)v19;
        *(_OWORD *)v19 = *(_OWORD *)v20;
        *(_OWORD *)v20 = v22;
        if (**v19 < **v18)
        {
          v23 = *(_OWORD *)v18;
          *(_OWORD *)v18 = *(_OWORD *)v19;
          *(_OWORD *)v19 = v23;
          if (**v18 < **v17)
          {
            v24 = *(_OWORD *)v17;
            *(_OWORD *)v17 = *(_OWORD *)v18;
            *(_OWORD *)v18 = v24;
            if (*a1[2] < **a1)
            {
              v25 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *(_OWORD *)v17;
              *(_OWORD *)v17 = v25;
            }
          }
        }
      }
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(unsigned __int16 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unsigned __int16 **)((char *)a1 + v14 + 48);
          goto LABEL_13;
        }
      }
      v16 = a1;
LABEL_13:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*,false>(unsigned __int8 **a1, unsigned __int8 **a2, uint64_t a3, char a4)
{
  unsigned __int8 **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int8 **v12;
  unsigned __int8 *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unsigned int v17;
  unsigned __int8 **v18;
  unsigned __int8 **v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  unsigned __int8 **v22;
  unsigned int v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  BOOL v26;
  unsigned __int8 *v27;
  unsigned __int8 **v28;
  unsigned __int8 **v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  unsigned int v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  unsigned __int8 **v35;
  unsigned __int8 *v36;
  unsigned __int8 **v37;
  unsigned __int8 **v38;
  unsigned __int8 **v39;
  unsigned __int8 **v40;
  unsigned __int8 *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  unsigned __int8 **v45;
  BOOL v47;
  uint64_t v48;
  unsigned __int8 **v49;
  unsigned __int8 **v50;
  unsigned __int8 *v51;
  unsigned __int8 *v52;
  uint64_t v53;
  unsigned int v54;
  unsigned __int8 **v55;
  int64_t v56;
  int64_t v57;
  int64_t v58;
  uint64_t v59;
  unsigned __int8 **v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  unsigned __int8 **v64;
  unsigned __int8 *v65;
  unsigned __int8 *v66;
  unsigned __int8 **v67;
  uint64_t v68;
  unsigned int v69;
  unsigned int v70;
  BOOL v71;
  unsigned int v72;
  uint64_t v73;
  uint64_t v74;
  unsigned __int8 **v75;
  unsigned __int8 **v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  unsigned __int8 **v81;
  unsigned __int8 *v82;
  unsigned __int8 *v83;
  unsigned __int8 **v84;
  unsigned __int8 **v86;
  unsigned __int8 *v87;
  unsigned __int8 *v88;
  unsigned __int8 **v89;
  unsigned __int8 *v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(unsigned __int8 **a1, unsigned __int8 **a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned __int8 **v6;
  __int128 v7;
  unsigned __int8 **v8;
  unsigned __int8 **v9;
  uint64_t v10;
  int v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned __int8 **v16;
  unsigned __int8 **v17;
  unsigned __int8 **v18;
  unsigned __int8 **v19;
  unsigned __int8 **v20;
  unsigned __int8 *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      v17 = a1 + 2;
      v18 = a1 + 4;
      v19 = a1 + 6;
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3);
      v21 = *(a2 - 2);
      v20 = a2 - 2;
      if (*v21 < *a1[6])
      {
        v22 = *(_OWORD *)v19;
        *(_OWORD *)v19 = *(_OWORD *)v20;
        *(_OWORD *)v20 = v22;
        if (**v19 < **v18)
        {
          v23 = *(_OWORD *)v18;
          *(_OWORD *)v18 = *(_OWORD *)v19;
          *(_OWORD *)v19 = v23;
          if (**v18 < **v17)
          {
            v24 = *(_OWORD *)v17;
            *(_OWORD *)v17 = *(_OWORD *)v18;
            *(_OWORD *)v18 = v24;
            if (*a1[2] < **a1)
            {
              v25 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *(_OWORD *)v17;
              *(_OWORD *)v17 = v25;
            }
          }
        }
      }
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(unsigned __int8 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unsigned __int8 **)((char *)a1 + v14 + 48);
          goto LABEL_13;
        }
      }
      v16 = a1;
LABEL_13:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*,false>(uint64_t **a1, __int128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t **v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t **v18;
  __int128 *v19;
  _QWORD *v20;
  _QWORD *v21;
  __int128 *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  BOOL v26;
  _QWORD *v27;
  _QWORD **v28;
  __int128 *v29;
  _QWORD *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  __int128 *v35;
  _QWORD *v36;
  __int128 *v37;
  __int128 *v38;
  __int128 *v39;
  __int128 *v40;
  _QWORD *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 *v45;
  BOOL v47;
  uint64_t v48;
  unint64_t v49;
  __int128 *v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  _QWORD *v55;
  int64_t v56;
  int64_t v57;
  int64_t v58;
  uint64_t v59;
  uint64_t **v60;
  uint64_t v61;
  uint64_t v62;
  BOOL v63;
  uint64_t **v64;
  uint64_t *v65;
  uint64_t *v66;
  uint64_t **v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  BOOL v71;
  uint64_t v72;
  uint64_t v73;
  _OWORD *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  _OWORD *v80;
  _QWORD *v81;
  uint64_t v82;
  _OWORD *v83;
  __int128 *v84;
  uint64_t *v85;
  uint64_t *v86;
  __int128 *v87;
  uint64_t *v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  _QWORD **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  __int128 *v17;
  __int128 *v18;
  __int128 *v19;
  __int128 *v20;
  _QWORD *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      if (**(_QWORD **)(a2 - 16) < **(_QWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32), (_OWORD *)(a2 - 16));
      return 1;
    case 5:
      v17 = (__int128 *)(a1 + 16);
      v18 = (__int128 *)(a1 + 32);
      v19 = (__int128 *)(a1 + 48);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32), (_OWORD *)(a1 + 48));
      v21 = *(_QWORD **)(a2 - 16);
      v20 = (__int128 *)(a2 - 16);
      if (*v21 < **(_QWORD **)(a1 + 48))
      {
        v22 = *v19;
        *v19 = *v20;
        *v20 = v22;
        if (**(_QWORD **)v19 < **(_QWORD **)v18)
        {
          v23 = *v18;
          *v18 = *v19;
          *v19 = v23;
          if (**(_QWORD **)v18 < **(_QWORD **)v17)
          {
            v24 = *v17;
            *v17 = *v18;
            *v18 = v24;
            if (**(_QWORD **)(a1 + 16) < **(_QWORD **)a1)
            {
              v25 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v17;
              *v17 = v25;
            }
          }
        }
      }
      return 1;
    default:
      v8 = (_QWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32));
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(_QWORD **)v9;
    if (**(_QWORD **)v9 < **v8)
    {
      v13 = *(_QWORD *)(v9 + 8);
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_QWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (_QWORD *)(a1 + v14 + 48);
          goto LABEL_13;
        }
      }
      v16 = (_QWORD *)a1;
LABEL_13:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (_QWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*,false>(int **a1, __int128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int **v12;
  int *v13;
  int v14;
  uint64_t v15;
  int *v16;
  int v17;
  int **v18;
  __int128 *v19;
  _DWORD *v20;
  _DWORD *v21;
  __int128 *v22;
  int v23;
  int *v24;
  int *v25;
  BOOL v26;
  _DWORD *v27;
  _DWORD **v28;
  __int128 *v29;
  _DWORD *v30;
  int *v31;
  int v32;
  int *v33;
  int *v34;
  __int128 *v35;
  _DWORD *v36;
  __int128 *v37;
  __int128 *v38;
  __int128 *v39;
  __int128 *v40;
  _DWORD *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 *v45;
  BOOL v47;
  uint64_t v48;
  unint64_t v49;
  __int128 *v50;
  _DWORD *v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  _QWORD *v55;
  int64_t v56;
  int64_t v57;
  int64_t v58;
  uint64_t v59;
  int **v60;
  int v61;
  int v62;
  BOOL v63;
  int **v64;
  int *v65;
  int *v66;
  int **v67;
  uint64_t v68;
  int v69;
  int v70;
  BOOL v71;
  uint64_t v72;
  uint64_t v73;
  _OWORD *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  _OWORD *v80;
  _DWORD *v81;
  uint64_t v82;
  _OWORD *v83;
  __int128 *v84;
  int *v85;
  int *v86;
  __int128 *v87;
  int *v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  _DWORD **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  _QWORD *v16;
  __int128 *v17;
  __int128 *v18;
  __int128 *v19;
  __int128 *v20;
  _DWORD *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      if (**(_DWORD **)(a2 - 16) < **(_DWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a1 + 32), (_OWORD *)(a2 - 16));
      return 1;
    case 5:
      v17 = (__int128 *)(a1 + 16);
      v18 = (__int128 *)(a1 + 32);
      v19 = (__int128 *)(a1 + 48);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a1 + 32), (_OWORD *)(a1 + 48));
      v21 = *(_DWORD **)(a2 - 16);
      v20 = (__int128 *)(a2 - 16);
      if (*v21 < **(_DWORD **)(a1 + 48))
      {
        v22 = *v19;
        *v19 = *v20;
        *v20 = v22;
        if (**(_DWORD **)v19 < **(_DWORD **)v18)
        {
          v23 = *v18;
          *v18 = *v19;
          *v19 = v23;
          if (**(_DWORD **)v18 < **(_DWORD **)v17)
          {
            v24 = *v17;
            *v17 = *v18;
            *v18 = v24;
            if (**(_DWORD **)(a1 + 16) < **(_DWORD **)a1)
            {
              v25 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v17;
              *v17 = v25;
            }
          }
        }
      }
      return 1;
    default:
      v8 = (_DWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a1 + 32));
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(_DWORD **)v9;
    if (**(_DWORD **)v9 < **v8)
    {
      v13 = *(_QWORD *)(v9 + 8);
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_DWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (_QWORD *)(a1 + v14 + 48);
          goto LABEL_13;
        }
      }
      v16 = (_QWORD *)a1;
LABEL_13:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (_DWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*,false>(__int16 **a1, __int16 **a2, uint64_t a3, char a4)
{
  __int16 **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __int16 **v12;
  __int16 *v13;
  int v14;
  uint64_t v15;
  __int16 *v16;
  int v17;
  __int16 **v18;
  __int16 **v19;
  __int16 *v20;
  __int16 *v21;
  __int16 **v22;
  int v23;
  __int16 *v24;
  __int16 *v25;
  BOOL v26;
  __int16 *v27;
  __int16 **v28;
  __int16 **v29;
  __int16 *v30;
  __int16 *v31;
  int v32;
  __int16 *v33;
  __int16 *v34;
  __int16 **v35;
  __int16 *v36;
  __int16 **v37;
  __int16 **v38;
  __int16 **v39;
  __int16 **v40;
  __int16 *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int16 **v45;
  BOOL v47;
  uint64_t v48;
  __int16 **v49;
  __int16 **v50;
  __int16 *v51;
  __int16 *v52;
  uint64_t v53;
  int v54;
  __int16 **v55;
  int64_t v56;
  int64_t v57;
  int64_t v58;
  uint64_t v59;
  __int16 **v60;
  int v61;
  int v62;
  BOOL v63;
  __int16 **v64;
  __int16 *v65;
  __int16 *v66;
  __int16 **v67;
  uint64_t v68;
  int v69;
  int v70;
  BOOL v71;
  uint64_t v72;
  uint64_t v73;
  __int16 **v74;
  __int16 **v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  __int16 **v80;
  __int16 *v81;
  __int16 *v82;
  __int16 **v83;
  __int16 **v84;
  __int16 *v85;
  __int16 *v86;
  __int16 **v87;
  __int16 *v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(__int16 **a1, __int16 **a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int16 **v6;
  __int128 v7;
  __int16 **v8;
  __int16 **v9;
  uint64_t v10;
  int v11;
  __int16 *v12;
  __int16 *v13;
  uint64_t v14;
  int v15;
  __int16 **v16;
  __int16 **v17;
  __int16 **v18;
  __int16 **v19;
  __int16 **v20;
  __int16 *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      v17 = a1 + 2;
      v18 = a1 + 4;
      v19 = a1 + 6;
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3);
      v21 = *(a2 - 2);
      v20 = a2 - 2;
      if (*v21 < *a1[6])
      {
        v22 = *(_OWORD *)v19;
        *(_OWORD *)v19 = *(_OWORD *)v20;
        *(_OWORD *)v20 = v22;
        if (**v19 < **v18)
        {
          v23 = *(_OWORD *)v18;
          *(_OWORD *)v18 = *(_OWORD *)v19;
          *(_OWORD *)v19 = v23;
          if (**v18 < **v17)
          {
            v24 = *(_OWORD *)v17;
            *(_OWORD *)v17 = *(_OWORD *)v18;
            *(_OWORD *)v18 = v24;
            if (*a1[2] < **a1)
            {
              v25 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *(_OWORD *)v17;
              *(_OWORD *)v17 = v25;
            }
          }
        }
      }
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(__int16 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (__int16 **)((char *)a1 + v14 + 48);
          goto LABEL_13;
        }
      }
      v16 = a1;
LABEL_13:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*,false>(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t *v35;
  uint64_t *v36;
  uint64_t *v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t *v41;
  BOOL v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  uint64_t *v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  int64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  BOOL v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  BOOL v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  uint64_t *v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t *v91;
  uint64_t *v92;
  char v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t *v96;
  int64_t v97;
  uint64_t *v98;
  uint64_t *v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t *v6;
  __int128 v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (re::DynamicString::operator<(*(a2 - 2), *a1))
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      v17 = a1 + 2;
      v18 = a1 + 4;
      v19 = a1 + 6;
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4, a1 + 6);
      v21 = *(a2 - 2);
      v20 = a2 - 2;
      if (re::DynamicString::operator<(v21, a1[6]))
      {
        v22 = *(_OWORD *)v19;
        *(_OWORD *)v19 = *(_OWORD *)v20;
        *(_OWORD *)v20 = v22;
        if (re::DynamicString::operator<(*v19, *v18))
        {
          v23 = *(_OWORD *)v18;
          *(_OWORD *)v18 = *(_OWORD *)v19;
          *(_OWORD *)v19 = v23;
          if (re::DynamicString::operator<(*v18, *v17))
          {
            v24 = *(_OWORD *)v17;
            *(_OWORD *)v17 = *(_OWORD *)v18;
            *(_OWORD *)v18 = v24;
            if (re::DynamicString::operator<(a1[2], *a1))
            {
              v25 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *(_OWORD *)v17;
              *(_OWORD *)v17 = v25;
            }
          }
        }
      }
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (re::DynamicString::operator<(*v9, *v8))
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        v15 = (char *)a1 + v14;
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v14 -= 16;
        if ((re::DynamicString::operator<(v12, *((_QWORD *)v15 + 2)) & 1) == 0)
        {
          v16 = (uint64_t *)((char *)a1 + v14 + 48);
          goto LABEL_13;
        }
      }
      v16 = a1;
LABEL_13:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*,false>(__int128 *a1, __n128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __int128 *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  __int128 *v19;
  __n128 *v20;
  _QWORD *v21;
  _QWORD *v22;
  __int128 *v23;
  unint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  BOOL v27;
  _QWORD *v28;
  _QWORD **v29;
  __int128 *v30;
  _QWORD *v31;
  _QWORD *v32;
  unint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  __int128 *v36;
  _QWORD *v37;
  __int128 *v38;
  __int128 *v39;
  __int128 *v40;
  __n128 *v41;
  _QWORD *v42;
  __n128 v43;
  __int128 v44;
  __int128 v45;
  __n128 *v46;
  BOOL v48;
  uint64_t v49;
  unint64_t v50;
  __n128 *v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  _QWORD *v56;
  int64_t v57;
  int64_t v58;
  int64_t v59;
  uint64_t v60;
  unint64_t **v61;
  unint64_t v62;
  unint64_t v63;
  BOOL v64;
  unint64_t **v65;
  unint64_t *v66;
  unint64_t *v67;
  unint64_t **v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  _OWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  _OWORD *v79;
  _QWORD *v80;
  uint64_t v81;
  _OWORD *v82;
  __n128 *v84;
  _QWORD *v85;
  _QWORD *v86;
  __n128 *v87;
  _QWORD *v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  _QWORD **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  __int128 *v17;
  __int128 *v18;
  __int128 *v19;
  __int128 *v20;
  _QWORD *v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      if (**(_QWORD **)(a2 - 16) >> 1 < **(_QWORD **)a1 >> 1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (_QWORD **)(a1 + 16), (_QWORD **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (__n128 *)(a1 + 16), (__n128 *)(a1 + 32), (__n128 *)(a2 - 16));
      return 1;
    case 5:
      v17 = (__int128 *)(a1 + 16);
      v18 = (__int128 *)(a1 + 32);
      v19 = (__int128 *)(a1 + 48);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (__n128 *)(a1 + 16), (__n128 *)(a1 + 32), (__n128 *)(a1 + 48));
      v21 = *(_QWORD **)(a2 - 16);
      v20 = (__int128 *)(a2 - 16);
      if (*v21 >> 1 < **(_QWORD **)(a1 + 48) >> 1)
      {
        v22 = *v19;
        *v19 = *v20;
        *v20 = v22;
        if (**(_QWORD **)v19 >> 1 < **(_QWORD **)v18 >> 1)
        {
          v23 = *v18;
          *v18 = *v19;
          *v19 = v23;
          if (**(_QWORD **)v18 >> 1 < **(_QWORD **)v17 >> 1)
          {
            v24 = *v17;
            *v17 = *v18;
            *v18 = v24;
            if (**(_QWORD **)(a1 + 16) >> 1 < **(_QWORD **)a1 >> 1)
            {
              v25 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v17;
              *v17 = v25;
            }
          }
        }
      }
      return 1;
    default:
      v8 = (_QWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (_QWORD **)(a1 + 16), (_QWORD **)(a1 + 32));
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(_QWORD **)v9;
    if (**(_QWORD **)v9 >> 1 < **v8 >> 1)
    {
      v13 = *(_QWORD *)(v9 + 8);
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_QWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >> 1 >= v15 >> 1)
        {
          v16 = (_QWORD *)(a1 + v14 + 48);
          goto LABEL_13;
        }
      }
      v16 = (_QWORD *)a1;
LABEL_13:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (_QWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

uint64_t rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartObject(uint64_t a1)
{
  uint64_t v2;

  rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix((char *)a1);
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(a1 + 40) - v2 <= 15)
  {
    rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Level>(a1 + 8, 1);
    v2 = *(_QWORD *)(a1 + 32);
  }
  *(_QWORD *)(a1 + 32) = v2 + 16;
  *(_QWORD *)v2 = 0;
  *(_BYTE *)(v2 + 8) = 0;
  return rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteStartObject((uint64_t *)a1);
}

uint64_t rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::EndObject(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE *v5;

  v2 = a1[4];
  v3 = *(_QWORD *)(v2 - 16);
  a1[4] = v2 - 16;
  if (v3)
  {
    v4 = *a1;
    v5 = *(_BYTE **)(*a1 + 24);
    if ((uint64_t)(*(_QWORD *)(*a1 + 32) - (_QWORD)v5) <= 0)
    {
      rapidjson::internal::Stack<re::internal::RapidJSONAllocator>::Expand<char>(*a1, 1);
      v5 = *(_BYTE **)(v4 + 24);
    }
    *(_QWORD *)(v4 + 24) = v5 + 1;
    *v5 = 10;
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteIndent((char *)a1);
  }
  rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndObject(a1);
  return 1;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(char *a1, char *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  BOOL v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  char *v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t *v40;
  __n128 v41;
  char *v42;
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  char *v47;
  BOOL v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  char *v57;
  int64_t v58;
  int64_t v59;
  int64_t v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  uint64_t v69;
  char *v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t *v79;
  uint64_t v80;
  uint64_t *v81;
  __int128 v82;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  char *v87;
  char *v88;
  char v89;
  char *v90;
  unint64_t v91;
  char *v92;
  char *v93;
  uint64_t *v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  int64_t v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(_QWORD *a1, char *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  uint64_t v6;
  _BOOL8 result;
  char *v8;
  __int128 v9;
  char *v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  _OWORD *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;
  __n128 v21;
  char *v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;

  v6 = (a2 - (char *)a1) >> 4;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v8 = a2 - 16;
      if ((*a3)(*((_QWORD *)a2 - 2), *a1))
      {
        v9 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v8;
        *(_OWORD *)v8 = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, a1 + 2, (_QWORD *)a2 - 2, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, a1 + 2, a1 + 4, (_QWORD *)a2 - 2, a3);
      return 1;
    case 5:
      v18 = a1 + 2;
      v19 = a1 + 4;
      v20 = a1 + 6;
      v21 = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, a1 + 2, a1 + 4, a1 + 6, a3);
      v23 = *((_QWORD *)a2 - 2);
      v22 = a2 - 16;
      if (((unsigned int (*)(uint64_t, _QWORD, __n128))*a3)(v23, a1[6], v21))
      {
        v24 = *(_OWORD *)v20;
        *(_OWORD *)v20 = *(_OWORD *)v22;
        *(_OWORD *)v22 = v24;
        if ((*a3)(*v20, *v19))
        {
          v25 = *(_OWORD *)v19;
          *(_OWORD *)v19 = *(_OWORD *)v20;
          *(_OWORD *)v20 = v25;
          if ((*a3)(*v19, *v18))
          {
            v26 = *(_OWORD *)v18;
            *(_OWORD *)v18 = *(_OWORD *)v19;
            *(_OWORD *)v19 = v26;
            if ((*a3)(a1[2], *a1))
            {
              v27 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *(_OWORD *)v18;
              *(_OWORD *)v18 = v27;
            }
          }
        }
      }
      return 1;
    default:
      v10 = (char *)(a1 + 4);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, a1 + 2, a1 + 4, a3);
      v11 = (char *)(a1 + 6);
      if (a1 + 6 == (_QWORD *)a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(*(_QWORD *)v11, *(_QWORD *)v10))
    {
      v28 = *(_OWORD *)v11;
      v14 = *(_QWORD *)v11;
      v15 = v12;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v15 + 48) = *(_OWORD *)((char *)a1 + v15 + 32);
        if (v15 == -32)
          break;
        v16 = (*a3)(v14, *(_QWORD *)((char *)a1 + v15 + 16));
        v15 -= 16;
        if ((v16 & 1) == 0)
        {
          v17 = (_OWORD *)((char *)a1 + v15 + 48);
          goto LABEL_13;
        }
      }
      v17 = a1;
LABEL_13:
      *v17 = v28;
      if (++v13 == 8)
        return v11 + 16 == a2;
    }
    v10 = v11;
    v12 += 16;
    v11 += 16;
    if (v11 == a2)
      return 1;
  }
}

BOOL re::serializeDynamicString<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *__s, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t *v17;
  char *v18;
  _BOOL8 result;
  _anonymous_namespace_ *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  if (this == a6)
    goto LABEL_14;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_14;
  }
  v17 = re::TypeInfo::name(a6);
  if ((unint64_t)*v17 >> 1 != 0x22C6ED80D0CLL
    || (v18 = (char *)v17[1], v18 != "StringID") && strcmp(v18, "StringID"))
  {
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v24 = 0;
    if (!(_DWORD)result)
      return result;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_27;
  }
  v21 = *(_QWORD *)(a4 + 8);
  if ((v21 & 1) != 0)
    v22 = v21 >> 1;
  else
    v22 = v21 >> 1;
  v24 = v22;
  if ((_DWORD)result)
  {
    if (v22)
    {
      if ((*(_BYTE *)(a4 + 8) & 1) != 0)
        v23 = *(_QWORD *)(a4 + 16);
      else
        v23 = a4 + 9;
    }
    v20 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_27:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::internal::serializeMembers<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, uint64_t a2, uint64_t *a3, const re::TypeInfo *a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  unint64_t i;
  uint64_t v16;
  uint64_t v17;
  re *v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  uint64_t v22;
  re::internal *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _BYTE v36[32];
  _BYTE v37[32];
  _QWORD *v38[2];
  uint64_t v39;
  _QWORD *v40[2];
  uint64_t v41;
  uint64_t v42[4];
  unint64_t v43;
  uint64_t v44[5];
  _BYTE v45[8];
  _BYTE v46[32];
  _BYTE v47[8];
  uint64_t v48;
  uint8_t buf[4];
  uint64_t v50;
  __int16 v51;
  uint64_t v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  if (a3 == (uint64_t *)a4)
    return re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((_BYTE *)a1, a2, a3, a5);
  if (*a3 == *(_QWORD *)a4)
  {
    v11 = *(_QWORD *)a3[2];
    v12 = **((_QWORD **)a4 + 2);
    if ((unsigned __int16)v11 == (unsigned __int16)v12)
    {
      v14 = WORD1(v11) == WORD1(v12);
      v13 = (v12 ^ v11) & 0xFFFFFF00000000;
      v14 = v14 && v13 == 0;
      if (v14)
        return re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((_BYTE *)a1, a2, a3, a5);
    }
  }
  else if (re::areSameTranslatedVersion((re *)a3, a4, (const re::TypeInfo *)a3))
  {
    return re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((_BYTE *)a1, a2, a3, a5);
  }
  if (*((unsigned __int8 *)a3 + 12) == *((unsigned __int8 *)a4 + 12))
  {
    re::TypeRegistry::typeInfo((_QWORD *)*a3, *(_QWORD *)(a3[2] + 72), v47);
    re::TypeRegistry::typeInfo(*(_QWORD **)a4, *(_QWORD *)(*((_QWORD *)a4 + 2) + 72), v45);
    if (v45[0])
    {
      if (!v47[0])
      {
        v30 = re::TypeInfo::name((re::TypeInfo *)v46)[1];
        re::TypeInfo::name((re::TypeInfo *)a3);
      }
    }
    re::TypeMemberCollection::TypeMemberCollection((uint64_t)v44, *a3, a3[2]);
    result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v42, *(_QWORD *)a4, *((_QWORD *)a4 + 2));
    if (v43)
    {
      for (i = 0; i < v43; ++i)
      {
        if (*(_BYTE *)(a1 + 64))
          break;
        result = (uint64_t)re::TypeMemberCollection::operator[](v42, i, (uint64_t)v40);
        if (*(_BYTE *)(v41 + 28))
        {
          v16 = *(_QWORD *)(v41 + 16);
          if (strlen((const char *)v16) >= 3 && *(_BYTE *)v16 == 109)
            v16 += 2 * (*(_BYTE *)(v16 + 1) == 95);
          v17 = *(unsigned int *)(v41 + 32);
          v18 = *(re **)(*(_QWORD *)a4 + 856);
          if (!v18
            || (v18 = (re *)re::internal::TypeTranslationTable::translateMember(v18, (const re::TypeMemberInfo *)v40),
                (_DWORD)v18 == -1))
          {
            v20 = *re::foundationSerializationLogObjects(v18);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
            {
              v21 = v20;
              v22 = re::TypeInfo::name(a4)[1];
              *(_DWORD *)buf = 136315394;
              v50 = v22;
              v51 = 2080;
              v52 = v16;
              _os_log_impl(&dword_224FE9000, v21, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);

            }
            v23 = *(re::internal **)(a1 + 272);
            re::TypeRegistry::typeInfo(v40[0], *(_QWORD *)v41, buf);
            re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v50 + 4);
            result = re::internal::translateType(v23, (const re::TypeRegistry *)v38, (uint64_t)buf);
            if (!*(_BYTE *)(a1 + 64))
              result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint8_t *, uint8_t *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v16, v17, 0, buf, buf, 1);
          }
          else
          {
            re::TypeMemberCollection::operator[](v44, (int)v18, (uint64_t)v38);
            v19 = *(unsigned int *)(v39 + 24);
            re::TypeRegistry::typeInfo(v38[0], *(_QWORD *)v39, buf);
            re::TypeInfo::TypeInfo((uint64_t)v37, (uint64_t)&v50 + 4);
            re::TypeRegistry::typeInfo(v40[0], *(_QWORD *)v41, buf);
            result = re::TypeInfo::TypeInfo((uint64_t)v36, (uint64_t)&v50 + 4);
            if (!*(_BYTE *)(a1 + 64))
              result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v16, v17, a2 + v19, v37, v36, a5);
          }
        }
      }
    }
  }
  else
  {
    v24 = re::TypeInfo::name((re::TypeInfo *)a3)[1];
    re::TypeInfo::name(a4);
  }
  return result;
}

BOOL re::serializeBool<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned __int8 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned __int8 *)&v19;
  else
    v13 = a4;
}

BOOL re::serializeChar<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, char *a4, re *this, re::TypeInfo *a6, int a7)
{
  char *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = &v19;
  else
    v13 = a4;
}

BOOL re::serializeI8<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, char *a4, re *this, re::TypeInfo *a6, int a7)
{
  char *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = &v19;
  else
    v13 = a4;
}

BOOL re::serializeI16<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, __int16 *a4, re *this, re::TypeInfo *a6, int a7)
{
  __int16 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  __int16 v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = &v19;
  else
    v13 = a4;
}

BOOL re::serializeI32<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned int *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned int *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned int *)&v19;
  else
    v13 = a4;
}

BOOL re::serializeI64<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unint64_t *a4, re *this, re::TypeInfo *a6, int a7)
{
  unint64_t *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unint64_t *)&v19;
  else
    v13 = a4;
}

BOOL re::serializeU8<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned __int8 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned __int8 *)&v19;
  else
    v13 = a4;
}

BOOL re::serializeU16<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned __int16 *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned __int16 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  __int16 v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned __int16 *)&v19;
  else
    v13 = a4;
}

BOOL re::serializeU32<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned int *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned int *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned int *)&v19;
  else
    v13 = a4;
}

BOOL re::serializeU64<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, rapidjson::internal **a4, re *this, re::TypeInfo *a6, int a7)
{
  rapidjson::internal **v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (rapidjson::internal **)&v19;
  else
    v13 = a4;
}

BOOL re::serializeFloat<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, float *a4, re *this, re::TypeInfo *a6, int a7)
{
  float *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (float *)&v19;
  else
    v13 = a4;
}

BOOL re::serializeDouble<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, double *a4, re *this, re::TypeInfo *a6, int a7)
{
  double *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (double *)&v19;
  else
    v13 = a4;
}

uint64_t re::serializeCString<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *__s, const re::TypeInfo *a3, const char **a4, re *this, re::TypeInfo *a6, int a7)
{
  int v13;
  uint64_t result;
  _anonymous_namespace_ *v15;
  const char *v16;
  size_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  int v23;

  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_18:
      return 0;
    }
    v18 = **((_QWORD **)this + 2);
    v19 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v18 != (unsigned __int16)v19)
      goto LABEL_18;
    v21 = WORD1(v18) == WORD1(v19);
    v20 = (v19 ^ v18) & 0xFFFFFF00000000;
    v21 = v21 && v20 == 0;
    if (!v21)
      goto LABEL_18;
  }
LABEL_4:
  if (a7)
  {
    LODWORD(v22) = 0;
    result = 0;
    if (!v13)
      return result;
    v15 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_22;
  }
  v16 = *a4;
  v23 = 2 * (*a4 != 0);
  if (!(_DWORD)result)
    return result;
  if (v16)
  {
    if (*a4)
    {
      v17 = strlen(*a4);
      v22 = v17;
      {
        if (v17)
        goto LABEL_20;
      }
    }
    else
    {
      v22 = 0;
      {
LABEL_20:
      }
    }
  }
  v15 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_22:
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeStringID<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *__s, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t *v17;
  char *v18;
  _BOOL8 result;
  _anonymous_namespace_ *v20;
  size_t v21;
  size_t v22;

  if (this == a6)
    goto LABEL_14;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_14;
  }
  v17 = re::TypeInfo::name(a6);
  if ((unint64_t)*v17 >> 1 != 0x134375A94D9F7110
    || (v18 = (char *)v17[1], v18 != "DynamicString") && strcmp(v18, "DynamicString"))
  {
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v22 = 0;
    if (!(_DWORD)result)
      return result;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    v21 = strlen(*(const char **)(a4 + 8));
    v22 = v21;
    if (!(_DWORD)result)
      return result;
    if (v21)
    v20 = (_anonymous_namespace_ *)(a1 + 24);
  }
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *__s, const re::TypeInfo *a3, uint64_t a4, unint64_t **this, unint64_t **a6, int a7)
{
  _BOOL8 result;
  unint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34[2];

  if (this != a6)
  {
    if (*this != *a6)
    {
      if (re::areSameTranslatedVersion((re *)this, (const re::TypeInfo *)a6, a3))
        goto LABEL_4;
LABEL_26:
      return 0;
    }
    v21 = *this[2];
    v22 = *a6[2];
    if ((unsigned __int16)v21 != (unsigned __int16)v22)
      goto LABEL_26;
    v24 = WORD1(v21) == WORD1(v22);
    v23 = (v22 ^ v21) & 0xFFFFFF00000000;
    v24 = v24 && v23 == 0;
    if (!v24)
      goto LABEL_26;
  }
LABEL_4:
  if (!a7)
  {
    v14 = *this[2];
    v30 = (uint64_t)*this;
    v31 = v14;
    LODWORD(v32) = -1;
    v34[0] = 0x258C98EAAF29A10ALL;
    v34[1] = (uint64_t)"CallbackSerializerAttribute";
    v15 = (uint64_t *)re::TypeAttributeCollection::operator[](&v30, v34);
    re::StringID::destroyString((re::StringID *)v34);
    v16 = *v15;
    v17 = *(_QWORD *)(a1 + 264);
    v18 = *(_QWORD *)(a1 + 56);
    v32 = 0;
    v33 = 0;
    v30 = v18;
    v31 = 0;
    re::DynamicString::setCapacity(&v30, 0);
    if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v16 + 72))(v17, v16, a4, &v30) & 1) != 0)
    {
      if ((v31 & 1) != 0)
        v19 = v31 >> 1;
      else
        v19 = v31 >> 1;
      v34[0] = v19;
      {
        if (v19)
        {
          if ((v31 & 1) != 0)
            v20 = v32;
          else
            v20 = (char *)&v31 + 1;
        }
        if (v30)
        {
          if ((v31 & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v30 + 40))();
        }
        return *(_BYTE *)(a1 + 64) == 0;
      }
    }
    else
    {
      re::TypeInfo::name((re::TypeInfo *)this);
    }
    if (v30 && (v31 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v30 + 40))();
    return 0;
  }
  v30 = 0;
  if ((_DWORD)result)
  {
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(uint64_t a1, char *__s, int *a3)
{
  int v3;
  int v7;
  char *v8;
  uint64_t result;
  __int128 v10;
  uint64_t v11;
  _BOOL8 v12;
  uint64_t v13;
  uint64_t v14;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (*(_BYTE *)(a1 + 40))
    return v3 == 0;
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), __s);
  v7 = *a3;
  if ((*a3 - 1) < 2)
  {
LABEL_7:
    LOBYTE(v10) = 9;
    DWORD1(v10) = 0;
    *((_QWORD *)&v10 + 1) = __s;
    v11 = 0;
    v13 = 0;
    v14 = 0;
    v12 = v7 != 0;
    return v3 == 0;
  }
  if (!v7)
  {
    v8 = *(char **)(a1 + 168);
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v8);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteNull((uint64_t *)v8);
    v7 = *a3;
    goto LABEL_7;
  }
  re::internal::assertLog((re::internal *)4, (uint64_t)__s, "assertion failure: '%s' (%s:line %i) Unexpected PointerEncoding.", "!\"Unreachable code\"", "beginPointer", 1054);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString(_BYTE *a1, char *__s, const re::TypeInfo *a3, const char **a4, re *this, re::TypeInfo *a6)
{
  int *v11;
  int v12;
  _anonymous_namespace_ *v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  int v22;
  __int128 v23;
  int v24;
  const char *v25;

  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_14:
      return 0;
    }
    v15 = **((_QWORD **)this + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 != (unsigned __int16)v16)
      goto LABEL_14;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_14;
  }
LABEL_4:
  if (!*a4)
  {
    LODWORD(v25) = 0;
    v13 = (_anonymous_namespace_ *)(a1 + 24);
    result = 0;
    if (!v22)
      return result;
    goto LABEL_22;
  }
  if (!a1[336]
    || (v25 = *a4,
        (v11 = (int *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(a1 + 344), (uint64_t *)&v25)) == 0))
  {
    v24 = 2;
    {
      v19 = (const char *)strlen(*a4);
      v25 = v19;
      if (!(_DWORD)result)
        return result;
      if (v19)
      v20 = *a4;
      v21 = **((_QWORD **)this + 2);
      *(_QWORD *)&v23 = *(_QWORD *)this;
      *((_QWORD *)&v23 + 1) = v21;
      re::internal::SharedObjectGraph::addObject((uint64_t)(a1 + 336), (uint64_t)v20, &v23);
      return a1[64] == 0;
    }
    return 0;
  }
  v12 = *v11;
  v24 = 1;
  LODWORD(v25) = v12;
  v13 = (_anonymous_namespace_ *)(a1 + 24);
  if (!(_DWORD)result)
    return result;
LABEL_22:
  return a1[64] == 0;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer(uint64_t a1, char *a2, int a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  const re::TypeInfo *v13;
  _BOOL4 isPointerToPolymorphicType;
  int v15;
  char *v16;
  _DWORD *v17;
  _anonymous_namespace_ *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t *v32;
  uint64_t *v33;
  char *v34;
  re::TypeRegistry *v35;
  uint64_t *v36;
  uint64_t *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  __int128 v45;
  _BYTE v46[32];
  __int128 v47;
  _QWORD v48[4];
  _QWORD v49[4];
  char *v50;
  _BYTE v51[32];
  int v52[8];

  isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6)
    goto LABEL_4;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v28 = **((_QWORD **)this + 2);
    v29 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v28 == (unsigned __int16)v29)
    {
      v31 = WORD1(v28) == WORD1(v29);
      v30 = (v29 ^ v28) & 0xFFFFFF00000000;
      v31 = v31 && v30 == 0;
      if (v31)
        goto LABEL_4;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v13))
  {
LABEL_4:
    v15 = 0;
    goto LABEL_5;
  }
  if (*((_BYTE *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (v32 = re::TypeInfo::name(this), v33 = re::TypeInfo::name(a6), !re::StringID::operator==(v32, v33))))
  {
    return 0;
  }
  v15 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v50);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v51);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v50);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v51);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    v20 = *(_QWORD *)v49[2];
    *(_QWORD *)&v47 = v49[0];
    *((_QWORD *)&v47 + 1) = v20;
    if (v49[0])
      goto LABEL_8;
    goto LABEL_15;
  }
  re::internal::actualType(a4, (void **)this, &v47);
  if (!(_QWORD)v47)
  {
LABEL_15:
    v21 = re::TypeInfo::name(this);
    return 0;
  }
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, (re **)&v47, &v50);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)v51);
  if ((a7 & 1) != 0 || (v16 = *a4) == 0)
  {
    LODWORD(v50) = 0;
    v18 = (_anonymous_namespace_ *)(a1 + 24);
    result = 0;
    if (v27)
      goto LABEL_17;
    return result;
  }
  if (!*(_BYTE *)(a1 + 336))
  {
LABEL_33:
    v45 = v47;
    re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), (uint64_t)v16, &v45);
    v44 = 2;
    if (!(_DWORD)result)
      return result;
    if (!isPointerToPolymorphicType)
    {
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, char *, _QWORD, char *, _QWORD *, _QWORD *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, 0, *a4, v49, v48, 0);
      goto LABEL_45;
    }
    v34 = *a4;
    re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v46);
    if (v15)
    {
      v35 = (re::TypeRegistry *)v48[0];
      v36 = re::TypeInfo::name((re::TypeInfo *)v46);
      re::TypeRegistry::typeInfo(v35, (const re::StringID *)v36, &v50);
      if (!(_BYTE)v50)
      {
        v38 = re::TypeInfo::name((re::TypeInfo *)v46);
LABEL_45:
        if (*(_BYTE *)(a1 + 336))
        {
          --*(_QWORD *)(a1 + 488);
          ++*(_DWORD *)(a1 + 496);
        }
        return *(_BYTE *)(a1 + 64) == 0;
      }
      re::TypeInfo::operator=((uint64_t)v52, (uint64_t)v51);
    }
    {
      v37 = re::TypeInfo::polymorphicObjectName((re::TypeInfo *)v52);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, uint64_t, _QWORD, char *, _BYTE *, int *, _QWORD))(*(_QWORD *)a1 + 72))(a1, v37[1], 0, v34, v46, v52, 0);
    }
    goto LABEL_45;
  }
  v50 = *a4;
  v17 = (_DWORD *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 344, (uint64_t *)&v50);
  if (!v17)
  {
    v16 = *a4;
    goto LABEL_33;
  }
  LODWORD(v50) = *v17;
  v52[0] = 1;
  v18 = (_anonymous_namespace_ *)(a1 + 24);
  if ((_DWORD)result)
  {
LABEL_17:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<`anonymous namespace'::LegacyOutputStreamAdaptor,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference(uint64_t result, unsigned int *a2)
{
  _anonymous_namespace_ *v3;

  if (!*(_BYTE *)(result + 40))
  {
    v3 = (_anonymous_namespace_ *)result;
    if ((_DWORD)result)
    {
    }
  }
  return result;
}

uint64_t re::internal::translateType@<X0>(re::internal *this@<X0>, const re::TypeRegistry *a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *v7;
  uint64_t v8;
  const re::TypeRegistry *v9;
  uint64_t v10;
  _QWORD *v12;
  uint64_t v13;
  re *v14[2];

  if (*(re::internal **)a2 == this)
    return re::TypeInfo::TypeInfo(a3, (uint64_t)a2);
  v7 = *(_QWORD **)(*(_QWORD *)a2 + 856);
  if (!v7)
  {
    v14[0] = 0;
    v14[1] = (re *)0xFFFFFFFFLL;
    goto LABEL_7;
  }
  v8 = **((_QWORD **)a2 + 2);
  v12 = *(_QWORD **)a2;
  v13 = v8;
  re::internal::TypeTranslationTable::translateType(v7, (uint64_t)&v12, v14);
  if (!v14[0])
  {
LABEL_7:
    v10 = a3;
    v9 = a2;
    return re::TypeInfo::TypeInfo(v10, (uint64_t)v9);
  }
  re::TypeRegistry::typeInfo(this, v14, &v12);
  v9 = (const re::TypeRegistry *)&v13;
  v10 = a3;
  return re::TypeInfo::TypeInfo(v10, (uint64_t)v9);
}

uint64_t re::internal::getEnumConstantIndex(re::internal *this, const re::TypeInfo *a2, void *a3)
{
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;

  v5 = re::TypeInfo::enumConstants(this);
  if (!v6)
    return 0xFFFFFFFFLL;
  v7 = (char *)v5;
  v8 = v6;
  v9 = 0;
  v10 = *(unsigned int *)(*((_QWORD *)this + 2) + 8);
  while (memcmp(v7, a2, v10))
  {
    ++v9;
    v7 += 24;
    if (v8 == v9)
      return 0xFFFFFFFFLL;
  }
  return v9;
}

uint64_t re::internal::getEnumConstantIndex(re::internal *this, const re::TypeInfo *a2, const re::StringID *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *i;

  v5 = re::TypeInfo::enumConstants(this);
  v7 = v6;
  if (v6)
  {
    v8 = 0;
    v9 = (_QWORD *)(v5 + 8);
    while (!re::StringID::operator==(v9, a2))
    {
      ++v8;
      v9 += 3;
      if (v7 == v8)
        goto LABEL_5;
    }
    return v8;
  }
  else
  {
LABEL_5:
    v10 = re::TypeInfo::renamedEnumConstants(this);
    if (v11)
    {
      v12 = v11;
      for (i = (_QWORD *)(v10 + 8); !re::StringID::operator==(i, a2); i += 3)
      {
        v7 = (v7 + 1);
        if (!--v12)
          return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return v7;
}

__n128 re::internal::upgradeObject@<Q0>(void *a1@<X0>, uint64_t **a2@<X1>, void *a3@<X2>, uint64_t **a4@<X3>, re::Allocator *a5@<X4>, void *a6@<X5>, _BYTE *a7@<X8>)
{
  void *v7;
  re::Allocator *v8;
  uint64_t v12;
  uint64_t (**v13)(void *, void *, void *);
  uint64_t v14;
  int v15;
  _DWORD *Instance;
  int v17;
  void *v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  char v25;
  __n128 result;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _BYTE *v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD v43[2];
  _BYTE v44[8];
  _QWORD v45[2];
  uint64_t *v46;
  _BYTE buf[24];
  uint64_t v48;
  uint64_t v49;

  v7 = a6;
  v8 = a5;
  v49 = *MEMORY[0x24BDAC8D0];
  while (1)
  {
    re::TypeInfo::nextVersion((re::TypeInfo *)a2, (const re::TypeInfo *)a4, v44);
    if (!v44[0])
    {
      re::TypeInfo::releaseInstance((re::TypeInfo *)a2, a1, v8, v7);
      v30 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
      v31 = re::DataArray<re::TextureAtlasTile>::tryGet((uint64_t)(*a2 + 12), *a2[2]);
      if (v31)
        v32 = *(unsigned int *)(v31 + 16);
      else
        v32 = 0xFFFFFFFFLL;
      v36 = a7;
      re::DynamicString::format((re::DynamicString *)"Failed to upgrade type \"%s\" version %u to the next version. Type info is missing.", (re::DynamicString *)buf, v30, v32);
      goto LABEL_38;
    }
    v12 = *v46;
    *(_QWORD *)buf = v45[0];
    *(_QWORD *)&buf[8] = v12;
    *(_DWORD *)&buf[16] = -1;
    v43[0] = 0xAE8345F9D646D604;
    v43[1] = "ComplexVersioningAttribute";
    v13 = (uint64_t (**)(void *, void *, void *))re::TypeAttributeCollection::operator[]((uint64_t *)buf, v43);
    re::StringID::destroyString((re::StringID *)v43);
    if (!v13 || !*v13)
    {
      re::TypeInfo::releaseInstance((re::TypeInfo *)a2, a1, v8, v7);
      v27 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
      v28 = re::DataArray<re::TextureAtlasTile>::tryGet((uint64_t)(*a2 + 12), *a2[2]);
      if (v28)
        v29 = *(unsigned int *)(v28 + 16);
      else
        v29 = 0xFFFFFFFFLL;
      v36 = a7;
      re::DynamicString::format((re::DynamicString *)"Failed to upgrade type \"%s\" version %u to the next version. Upgrade function is missing.", (re::DynamicString *)buf, v27, v29);
      goto LABEL_38;
    }
    v14 = re::DataArray<re::TextureAtlasTile>::tryGet(v45[0] + 96, *v46);
    if (v14)
      v15 = *(_DWORD *)(v14 + 16);
    else
      v15 = -1;
    Instance = (_DWORD *)re::DataArray<re::TextureAtlasTile>::tryGet((uint64_t)(*a4 + 12), *a4[2]);
    if (Instance)
      v17 = Instance[4];
    else
      v17 = -1;
    v18 = a3;
    if (v15 != v17)
    {
      Instance = re::TypeInfo::createInstance((re::TypeInfo *)v45, v8, v7);
      v18 = Instance;
    }
    v19 = *re::foundationSerializationLogObjects((re *)Instance);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
    {
      v20 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
      v21 = re::DataArray<re::TextureAtlasTile>::tryGet((uint64_t)(*a2 + 12), *a2[2]);
      if (v21)
        v22 = *(_DWORD *)(v21 + 16);
      else
        v22 = -1;
      v23 = re::DataArray<re::TextureAtlasTile>::tryGet(v45[0] + 96, *v46);
      if (v23)
        v24 = *(_DWORD *)(v23 + 16);
      else
        v24 = -1;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = v20;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v22;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v24;
      _os_log_impl(&dword_224FE9000, v19, OS_LOG_TYPE_INFO, "Upgrading type \"%s\" from version %u to %u.", buf, 0x18u);
      v8 = a5;
      v7 = a6;
    }
    v25 = (*v13)(v7, a1, v18);
    re::TypeInfo::releaseInstance((re::TypeInfo *)a2, a1, v8, v7);
    if ((v25 & 1) == 0)
      break;
    re::TypeInfo::operator=((uint64_t)a2, (uint64_t)v45);
    a1 = v18;
    if (v15 == v17)
    {
      *a7 = 1;
      return result;
    }
  }
  if (v15 != v17)
    re::TypeInfo::releaseInstance((re::TypeInfo *)v45, v18, v8, v7);
  v33 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
  v34 = re::DataArray<re::TextureAtlasTile>::tryGet((uint64_t)(*a2 + 12), *a2[2]);
  if (v34)
    v35 = *(unsigned int *)(v34 + 16);
  else
    v35 = 0xFFFFFFFFLL;
  v36 = a7;
  re::DynamicString::format((re::DynamicString *)"Failed to upgrade type \"%s\" version %u to the next version. Upgrade function failed.", (re::DynamicString *)buf, v33, v35);
LABEL_38:
  result = *(__n128 *)buf;
  v37 = *(_QWORD *)&buf[16];
  v38 = v48;
  *v36 = 0;
  *((_QWORD *)v36 + 1) = 400;
  *((_QWORD *)v36 + 2) = &re::FoundationErrorCategory(void)::instance;
  *(__n128 *)(v36 + 24) = result;
  *((_QWORD *)v36 + 5) = v37;
  *((_QWORD *)v36 + 6) = v38;
  return result;
}

uint64_t re::internal::actualType@<X0>(char **this@<X0>, void **a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t result;
  uint64_t v8;
  _QWORD v9[4];
  _OWORD v10[2];

  re::TypeRegistry::typeInfo(*a2, *((_QWORD *)a2[2] + 9), v10);
  result = re::TypeInfo::TypeInfo((uint64_t)v9, (uint64_t)v10 + 8);
  if (*this)
  {
    result = (uint64_t)re::TypeInfo::getActualType((re::TypeInfo *)v9, *this, a3);
    if (!*a3)
    {
      result = re::TypeInfo::getActualTypeFromPointer((uint64_t)a2, (char *)this, v10);
      *(_OWORD *)a3 = v10[0];
    }
  }
  else
  {
    v8 = *(_QWORD *)v9[2];
    *a3 = v9[0];
    a3[1] = v8;
  }
  return result;
}

void re::internal::setActualType(_QWORD *a1, re **a2, re **a3)
{
  re *v6;
  const re::TypeInfo *v7;
  re *v8;
  _BYTE *v9;
  _QWORD v10[4];
  char v11[8];
  _QWORD *v12;
  uint64_t v13;
  __int128 v14;
  char v15[16];
  uint64_t v16;
  _BYTE v17[32];
  uint64_t v18;
  _BYTE v19[32];

  v6 = *a2;
  re::TypeRegistry::typeInfo(*a2, *((_QWORD *)a2[2] + 9), &v18);
  re::TypeInfo::TypeInfo((uint64_t)v17, (uint64_t)v19);
  re::TypeRegistry::typeInfo(v6, a3, &v18);
  re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)v19);
  if (*(_BYTE *)(v16 + 120))
  {
    v7 = *(const re::TypeInfo **)(v16 + 128);
    if (*((_BYTE *)a2 + 12) == 9 && (v8 = a2[2], (*((_DWORD *)v8 + 23) & 0xFFFFFF) != 0) && *((_DWORD *)v8 + 24))
    {
      v14 = *(_OWORD *)a3;
      re::TypeInfo::setActualTypeForPointer((_QWORD **)a2, (uint64_t)a1, (re **)&v14);
    }
    else
    {
      re::TypeInfo::rootClass((re::TypeInfo *)v17, (uint64_t)&v18);
      re::TypeInfo::customClassIDMember(&v18, (uint64_t)v11);
      if (v11[0])
      {
        v9 = (_BYTE *)(*a1 + *(unsigned int *)(v13 + 24));
        re::TypeRegistry::typeInfo(v12, *(_QWORD *)v13, &v18);
        re::TypeInfo::TypeInfo((uint64_t)v10, (uint64_t)v19);
        re::internal::writeUnsigned(v9, v10, v7);
      }
    }
  }
}

BOOL re::internal::areCompatible(re **a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  _BOOL8 result;
  uint64_t v9;
  _QWORD v10[2];
  _QWORD *v11;
  char v12;
  uint64_t v13;
  char v14;
  uint64_t *v15;
  _BYTE v16[8];
  _BYTE v17[32];

  re::TypeRegistry::typeInfo(*a1, *((_QWORD *)a1[2] + 9), v16);
  re::TypeInfo::TypeInfo((uint64_t)&v13, (uint64_t)v17);
  if (v13 == *(_QWORD *)a2)
  {
    v4 = *v15;
    v5 = *(_QWORD *)(a2 + 8);
    if ((unsigned __int16)*v15 == (unsigned __int16)v5)
    {
      v7 = WORD1(v4) == WORD1(v5);
      v6 = (v5 ^ v4) & 0xFFFFFF00000000;
      v7 = v7 && v6 == 0;
      if (v7)
        return 1;
    }
  }
  re::TypeRegistry::typeInfo(*a1, (re **)a2, v16);
  re::TypeInfo::TypeInfo((uint64_t)&v11, (uint64_t)v17);
  result = 0;
  if (v14 == 8 && v12 == 8)
  {
    v9 = *v15;
    v10[0] = v13;
    v10[1] = v9;
    return re::TypeInfo::isSubClassOf(&v11, v10);
  }
  return result;
}

void re::PropertyBagHelper::makeWithIntrospectedData(const re::IntrospectionBase *a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>, double a5@<D0>)
{
  char v7;
  void *v8;
  void *v9;
  double v10;
  unsigned __int8 v11;
  char v12;
  void *v13;
  void *v14;
  void *v15;
  _BYTE *v16;
  void *v17;
  id v18;
  NSObject *v19;
  double v20;
  NSObject *v21;
  __int128 *v22;
  const re::IntrospectionBase *v23;
  __int128 v24;
  __int128 v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD v29[3];
  _QWORD v30[3];
  _BYTE buf[12];
  _BYTE *v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  if (*((_DWORD *)a1 + 4) == 8)
  {
    v28 = a3;
    v9 = v8;
    if (v7)
    {
      v26 = 0;
      v24 = 0u;
      v25 = 0u;
      v27 = 0x7FFFFFFFLL;
      re::PersistedSchema::addIntrospectionGraph((re::PersistedSchema *)&v24, a1);
      v11 = atomic_load((unsigned __int8 *)&qword_254123128);
      if ((v11 & 1) == 0 && __cxa_guard_acquire(&qword_254123128))
      {
        _MergedGlobals_481 = (uint64_t)re::IntrospectionInfo<re::HashTable<re::DynamicString,re::IntrospectionBase const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>>::get(0, v23);
        __cxa_guard_release(&qword_254123128);
      }
      v14 = v13;
      if (v12)
      {
        v15 = (void *)MEMORY[0x24BDD17C8];
        re::getPrettyTypeName(a1, (const re::IntrospectionBase *)buf);
        if ((buf[8] & 1) != 0)
          v16 = v32;
        else
          v16 = &buf[9];
        objc_msgSend(v15, "stringWithUTF8String:", v16);
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        if (*(_QWORD *)buf)
        {
          if ((buf[8] & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)buf + 40))();
        }
        v29[0] = CFSTR("type");
        v29[1] = CFSTR("value");
        v30[0] = v17;
        v30[1] = v9;
        v29[2] = CFSTR("schema");
        v30[2] = v14;
        objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v30, v29, 3);
        v18 = (id)objc_claimAutoreleasedReturnValue();
        *(_BYTE *)a4 = 1;
        *(_QWORD *)(a4 + 8) = v18;

      }
      else
      {
        *(_BYTE *)a4 = 0;
      }

      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v24, v20);
    }
    else
    {
      *(_BYTE *)a4 = 0;
    }

  }
  else
  {
    v19 = *re::foundationSerializationLogObjects(a1);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v21 = v19;
      re::getPrettyTypeName(a1, (const re::IntrospectionBase *)&v24);
      v22 = (BYTE8(v24) & 1) != 0 ? (__int128 *)v25 : (__int128 *)((char *)&v24 + 9);
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v22;
      _os_log_error_impl(&dword_224FE9000, v21, OS_LOG_TYPE_ERROR, "PropertyBagWriter; only works on structures '%s'.",
        buf,
        0xCu);

      if ((_QWORD)v24)
      {
        if ((BYTE8(v24) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v24 + 40))();
      }
    }
    *(_BYTE *)a4 = 0;
  }
}

unint64_t `anonymous namespace'::PropertyBagWriter::writeValue(_anonymous_namespace_::PropertyBagWriter *this, const re::IntrospectionBase *a2, unsigned int *a3, double a4)
{
  unsigned __int8 v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  unsigned __int8 v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  unsigned __int8 v15;
  const re::IntrospectionBase *v16;
  NSObject *v17;
  NSObject *v18;
  _BYTE *v19;
  id v20;
  uint64_t v21;
  const void *v22;
  char v23;
  void *v24;
  void *v25;
  char *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t v29;
  int v30;
  char v31;
  void *v32;
  void *v33;
  uint64_t v34;
  const void *v35;
  char v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  const void *v42;
  char v43;
  void *v44;
  void *v45;
  char *v46;
  _QWORD *v47;
  int v48;
  _QWORD *v49;
  uint64_t v50;
  re *v51;
  _BYTE *v52;
  NSObject *v53;
  unint64_t v54;
  const re::IntrospectionBase *v55;
  char *v56;
  _anonymous_namespace_::PropertyBagWriter *v57;
  const re::IntrospectionBase *v58;
  unint64_t v59;
  uint64_t v60;
  BOOL v61;
  uint64_t v62;
  const re::IntrospectionBase **StructureMember;
  re *v64;
  unsigned int *v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  _DWORD *v69;
  NSObject *v70;
  NSMutableArray *v71;
  void *v72;
  _BYTE *v73;
  void *v74;
  NSObject *v75;
  void *v76;
  NSObject *v78;
  _BYTE *v79;
  uint64_t v80;
  NSObject *v81;
  _OWORD *v82;
  NSObject *v83;
  _BYTE *v84;
  const re::IntrospectionBase *v85;
  const re::IntrospectionBase *v86;
  const re::IntrospectionBase *v87;
  const re::IntrospectionBase *v88;
  const re::IntrospectionBase *v89;
  const re::IntrospectionBase *v90;
  const re::IntrospectionBase *v91;
  const re::IntrospectionBase *v92;
  const re::IntrospectionBase *v93;
  const re::IntrospectionBase *v94;
  __int128 v95;
  _OWORD *v96;
  uint8_t v97[4];
  _OWORD *v98;
  _BYTE buf[24];
  _BYTE *v100;
  uint64_t v101;

  v101 = *MEMORY[0x24BDAC8D0];
  switch(*((_DWORD *)a2 + 4))
  {
    case 0:
      if ((v7 & 1) == 0
      {
        re::introspect<BOOL>(void)::info = re::introspect_BOOL(0, v85);
      }
      if (re::introspect<BOOL>(void)::info == (_UNKNOWN *)a2)
      {
        if (*(_BYTE *)a3)
        {
          LOBYTE(v38) = 1;
          objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", 1);
          objc_claimAutoreleasedReturnValue();
          goto LABEL_118;
        }
        objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", 0);
        objc_claimAutoreleasedReturnValue();
        goto LABEL_99;
      }
      if ((v8 & 1) == 0
      {
        re::introspect<char>(void)::info = (uint64_t)re::introspect_char(0, v86);
      }
      if ((const re::IntrospectionBase *)re::introspect<char>(void)::info == a2)
      {
        objc_msgSend(MEMORY[0x24BDD16E0], "numberWithChar:", *(char *)a3);
        objc_claimAutoreleasedReturnValue();
        goto LABEL_99;
      }
      if ((v9 & 1) == 0
      {
        re::introspect<double>(void)::info = (uint64_t)re::introspect_double(0, v88);
      }
      if ((const re::IntrospectionBase *)re::introspect<double>(void)::info == a2)
      {
        objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *(double *)a3);
        objc_claimAutoreleasedReturnValue();
        goto LABEL_99;
      }
      if ((v10 & 1) == 0
      {
        re::introspect<float>(void)::info = re::introspect_float(0, v89);
      }
      if (re::introspect<float>(void)::info == (_UNKNOWN *)a2)
      {
        LODWORD(a4) = *a3;
        objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", a4);
        objc_claimAutoreleasedReturnValue();
        goto LABEL_99;
      }
      if ((v11 & 1) == 0
      {
        re::introspect<short>(void)::info = (uint64_t)re::introspect_short(0, v90);
      }
      if ((const re::IntrospectionBase *)re::introspect<short>(void)::info == a2)
      {
        objc_msgSend(MEMORY[0x24BDD16E0], "numberWithShort:", *(__int16 *)a3);
        objc_claimAutoreleasedReturnValue();
        goto LABEL_99;
      }
      if ((v12 & 1) == 0
      {
        re::introspect<int>(void)::info = re::introspect_int(0, v91);
      }
      if (re::introspect<int>(void)::info == (_UNKNOWN *)a2)
      {
        objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", *a3);
        objc_claimAutoreleasedReturnValue();
        goto LABEL_99;
      }
      if ((v13 & 1) == 0
      {
        re::introspect<long>(void)::info = (uint64_t)re::introspect_long(0, v92);
      }
      if ((const re::IntrospectionBase *)re::introspect<long>(void)::info == a2)
      {
        objc_msgSend(MEMORY[0x24BDD16E0], "numberWithLong:", *(_QWORD *)a3);
        objc_claimAutoreleasedReturnValue();
        goto LABEL_99;
      }
      if ((v14 & 1) == 0
      {
        re::introspect<unsigned long>(void)::info = (uint64_t)re::introspect_size_t(0, v93);
      }
      if ((const re::IntrospectionBase *)re::introspect<unsigned long>(void)::info == a2)
        goto LABEL_149;
      if ((v15 & 1) == 0
      {
        re::introspect<long long>(void)::info = (uint64_t)re::introspect_int64_t(0, v94);
      }
      if ((const re::IntrospectionBase *)re::introspect<long long>(void)::info == a2)
      {
        objc_msgSend(MEMORY[0x24BDD16E0], "numberWithLongLong:", *(_QWORD *)a3);
        objc_claimAutoreleasedReturnValue();
LABEL_99:
        v54 = 0;
        LOBYTE(v38) = 1;
        return v38 | v54;
      }
      if (re::introspect<unsigned char>() == a2)
      {
        objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedChar:", *(unsigned __int8 *)a3);
        objc_claimAutoreleasedReturnValue();
        goto LABEL_99;
      }
      if ((const re::IntrospectionBase *)re::introspect<unsigned short>() == a2)
      {
        objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedShort:", *(unsigned __int16 *)a3);
        objc_claimAutoreleasedReturnValue();
        goto LABEL_99;
      }
      if ((const re::IntrospectionBase *)re::introspect<unsigned int>() == a2)
      {
        objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", *a3);
        objc_claimAutoreleasedReturnValue();
        goto LABEL_99;
      }
      v16 = (const re::IntrospectionBase *)re::introspect<unsigned long long>();
      if (v16 == a2)
      {
LABEL_149:
        objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLongLong:", *(_QWORD *)a3);
        objc_claimAutoreleasedReturnValue();
        goto LABEL_99;
      }
      v17 = *re::foundationSerializationLogObjects(v16);
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        goto LABEL_67;
      v18 = v17;
      re::getPrettyTypeName(a2, (const re::IntrospectionBase *)buf);
      if ((buf[8] & 1) != 0)
        v19 = *(_BYTE **)&buf[16];
      else
        v19 = &buf[9];
      LODWORD(v95) = 136315138;
      *(_QWORD *)((char *)&v95 + 4) = v19;
LABEL_137:
      _os_log_error_impl(&dword_224FE9000, v18, OS_LOG_TYPE_ERROR, "PropertyBagWriter; unhandled type '%s'.",
        (uint8_t *)&v95,
        0xCu);

      if (*(_QWORD *)buf && (buf[8] & 1) != 0)
        (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)buf + 40))(*(_QWORD *)buf, *(_QWORD *)&buf[16]);
LABEL_67:
      v54 = 0;
      LOBYTE(v38) = 0;
      return v38 | v54;
    case 1:
      v26 = *(char **)a3;
      re::PolymorphicData::makeWithPointer(*((_QWORD *)a2 + 6), *(const re::IntrospectionBase **)a3, buf);
      if (!v26)
        goto LABEL_86;
      v27 = *((_QWORD *)a2 + 6);
      if ((v28 & 1) == 0
      {
        re::introspect<char>(void)::info = (uint64_t)re::introspect_char(0, v87);
      }
      if (v27 == re::introspect<char>(void)::info)
      {
        objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v26);
        objc_claimAutoreleasedReturnValue();
        goto LABEL_121;
      }
      if (*(_QWORD *)&buf[16])
      {
        goto LABEL_126;
      }
      v58 = (const re::IntrospectionBase *)*((_QWORD *)a2 + 6);
      v57 = this;
      v56 = v26;
      goto LABEL_125;
    case 2:
      v20 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
      if (*((int *)a2 + 16) < 1)
        goto LABEL_49;
      v30 = 0;
      while (1)
      {
        v33 = v32;
        if (!v31)
          break;
        objc_msgSend(v20, "addObject:", v32);

        if (++v30 >= *((_DWORD *)a2 + 16))
          goto LABEL_49;
      }

      goto LABEL_116;
    case 3:
      v20 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
      if (!(*(uint64_t (**)(const re::IntrospectionBase *, unsigned int *))(*(_QWORD *)a2 + 88))(a2, a3))
        goto LABEL_49;
      v34 = 0;
      while (1)
      {
        v35 = (const void *)(*(uint64_t (**)(const re::IntrospectionBase *, unsigned int *, uint64_t))(*(_QWORD *)a2 + 104))(a2, a3, v34);
        v25 = v37;
        if (!v36)
          goto LABEL_96;
        objc_msgSend(v20, "addObject:", v37);

        if ((*(uint64_t (**)(const re::IntrospectionBase *, unsigned int *))(*(_QWORD *)a2 + 88))(a2, a3) <= (unint64_t)++v34)
          goto LABEL_49;
      }
    case 4:
      v20 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
      if (!(*(uint64_t (**)(const re::IntrospectionBase *, unsigned int *))(*(_QWORD *)a2 + 80))(a2, a3))
        goto LABEL_49;
      v21 = 0;
      while (1)
      {
        v22 = (const void *)(*(uint64_t (**)(const re::IntrospectionBase *, unsigned int *, uint64_t))(*(_QWORD *)a2 + 104))(a2, a3, v21);
        v25 = v24;
        if (!v23)
          break;
        objc_msgSend(v20, "addObject:", v24);

        if ((*(uint64_t (**)(const re::IntrospectionBase *, unsigned int *))(*(_QWORD *)a2 + 80))(a2, a3) <= (unint64_t)++v21)
        {
LABEL_49:
          v20;
          LOBYTE(v38) = 1;
          goto LABEL_117;
        }
      }
LABEL_96:

LABEL_116:
      LOBYTE(v38) = 0;
LABEL_117:

      goto LABEL_118;
    case 5:
      v20 = objc_alloc_init(MEMORY[0x24BDBCEB8]);
      *(_QWORD *)buf = (*(uint64_t (**)(const re::IntrospectionBase *, unsigned int *))(*(_QWORD *)a2 + 88))(a2, a3);
      *(_QWORD *)&buf[8] = v39;
      while (2)
      {
        v40 = (*(uint64_t (**)(const re::IntrospectionBase *, unsigned int *))(*(_QWORD *)a2 + 96))(a2, a3);
        if (*(_QWORD *)buf == v40
          && *(unsigned __int16 *)&buf[8] == (unsigned __int16)v41
          && *(unsigned __int16 *)&buf[10] == HIWORD(v41))
        {
          goto LABEL_49;
        }
        v42 = (const void *)(*(uint64_t (**)(const re::IntrospectionBase *, _BYTE *))(*(_QWORD *)a2 + 104))(a2, buf);
        v45 = v44;
        if (v43)
        {
          objc_msgSend(v20, "addObject:", v44);

          re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(buf);
          continue;
        }
        break;
      }

      LOBYTE(v38) = 0;
      goto LABEL_117;
    case 6:
      if ((a3[2] & 1) != 0)
        v46 = (char *)*((_QWORD *)a3 + 2);
      else
        v46 = (char *)a3 + 9;
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v46);
      objc_claimAutoreleasedReturnValue();
      goto LABEL_99;
    case 7:
      *(_QWORD *)&v95 = objc_alloc_init(MEMORY[0x24BDBCED8]);
      v47 = operator new(0x20uLL);
      *v47 = &off_24ED88988;
      v47[1] = &v95;
      v47[2] = a2;
      v47[3] = this;
      v100 = v47;
      v48 = (*(uint64_t (**)(const re::IntrospectionBase *, unsigned int *, _BYTE *))(*(_QWORD *)a2 + 104))(a2, a3, buf);
      v49 = v100;
      if (v100 == buf)
      {
        v50 = 4;
        v49 = buf;
      }
      else
      {
        if (!v100)
          goto LABEL_109;
        v50 = 5;
      }
      (*(void (**)(void))(*v49 + 8 * v50))();
LABEL_109:
      v76 = (void *)v95;
      if (v48)
      {
        (id)v95;
        LOBYTE(v38) = 1;
      }
      else
      {
        LOBYTE(v38) = 0;
      }

      goto LABEL_118;
    case 8:
      v59 = *((unsigned int *)a2 + 14);
      if (!(_DWORD)v59)
        goto LABEL_87;
      v60 = 0;
      v61 = 1;
      do
      {
        v62 = *(_QWORD *)(*((_QWORD *)a2 + 8) + 8 * v60);
        if (*(_DWORD *)v62 == 4 && (*(_BYTE *)(v62 + 4) & 1) != 0)
          break;
        v61 = ++v60 < v59;
      }
      while (v59 != v60);
      if (v61)
      {
        StructureMember = (const re::IntrospectionBase **)re::introspectionFirstStructureMember(a2, a2);
        if (StructureMember)
        {
          goto LABEL_126;
        }
        v78 = *re::foundationSerializationLogObjects(0);
        if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
        {
          v83 = v78;
          re::getPrettyTypeName(a2, (const re::IntrospectionBase *)buf);
          v84 = (buf[8] & 1) != 0 ? *(_BYTE **)&buf[16] : &buf[9];
          LODWORD(v95) = 136315138;
          *(_QWORD *)((char *)&v95 + 4) = v84;
          _os_log_error_impl(&dword_224FE9000, v83, OS_LOG_TYPE_ERROR, "PropertyBagReader; expected member in for struct '%s'.",
            (uint8_t *)&v95,
            0xCu);

          if (*(_QWORD *)buf)
          {
            if ((buf[8] & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)buf + 40))();
          }
        }
        v38 = 0;
      }
      else
      {
LABEL_87:
        v71 = (NSMutableArray *)objc_alloc_init(MEMORY[0x24BDBCEB8]);
        {
          v72 = (void *)MEMORY[0x24BDD17C8];
          re::getPrettyTypeName(a2, (const re::IntrospectionBase *)buf);
          if ((buf[8] & 1) != 0)
            v73 = *(_BYTE **)&buf[16];
          else
            v73 = &buf[9];
          objc_msgSend(v72, "stringWithUTF8String:", v73);
          v74 = (void *)objc_claimAutoreleasedReturnValue();
          if (*(_QWORD *)buf && (buf[8] & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)buf + 40))();
          *(_QWORD *)&v95 = CFSTR("type");
          *((_QWORD *)&v95 + 1) = CFSTR("value");
          *(_QWORD *)buf = v74;
          *(_QWORD *)&buf[8] = v71;
          objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", buf, &v95, 2);
          objc_claimAutoreleasedReturnValue();

          v38 = 1;
        }
        else
        {
          v38 = 0;
        }

      }
      goto LABEL_127;
    case 9:
      *(_QWORD *)&v95 = 0;
      v64 = (re *)memcpy(&v95, a3, *((int *)a2 + 5));
      v65 = (unsigned int *)*((_QWORD *)a2 + 8);
      v66 = v95;
      v67 = *v65;
      if (!(_DWORD)v67)
        goto LABEL_83;
      v68 = (_QWORD *)*((_QWORD *)v65 + 1);
      do
      {
        v69 = (_DWORD *)*v68;
        if (*(_DWORD *)*v68 == 1 && *((_QWORD *)v69 + 1) == (_QWORD)v95)
        {
          objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", *((_QWORD *)v69 + 2));
          objc_claimAutoreleasedReturnValue();
          LOBYTE(v38) = 1;
          goto LABEL_118;
        }
        ++v68;
        --v67;
      }
      while (v67);
LABEL_83:
      v70 = *re::foundationSerializationLogObjects(v64);
      if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
      {
        v80 = *((_QWORD *)a2 + 6);
        *(_DWORD *)buf = 134218242;
        *(_QWORD *)&buf[4] = v66;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v80;
        _os_log_error_impl(&dword_224FE9000, v70, OS_LOG_TYPE_ERROR, "PropertyBagWriter; unknown enum value %llu in %s.",
          buf,
          0x16u);
      }
      LOBYTE(v38) = 0;
LABEL_118:
      v54 = 0;
      return v38 | v54;
    case 0xA:
      re::StringID::StringID((re::StringID *)buf, (const StringID *)a3);
      objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", *(_QWORD *)&buf[8]);
      objc_claimAutoreleasedReturnValue();
      re::StringID::destroyString((re::StringID *)buf);
      goto LABEL_99;
    case 0xB:
      *(_QWORD *)&buf[8] = 0;
      *(_QWORD *)&buf[16] = 0;
      v100 = 0;
      re::DynamicString::setCapacity(buf, 0);
      v51 = (re *)(*((uint64_t (**)(_QWORD, const re::IntrospectionBase *, unsigned int *, _BYTE *))a2 + 9))(*(_QWORD *)this, a2, a3, buf);
      if ((v51 & 1) != 0)
      {
        if ((buf[8] & 1) != 0)
          v52 = *(_BYTE **)&buf[16];
        else
          v52 = &buf[9];
        objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v52);
        objc_claimAutoreleasedReturnValue();
        LOBYTE(v38) = 1;
      }
      else
      {
        v75 = *re::foundationSerializationLogObjects(v51);
        if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
        {
          v81 = v75;
          re::getPrettyTypeName(a2, (const re::IntrospectionBase *)&v95);
          v82 = (BYTE8(v95) & 1) != 0 ? v96 : (__int128 *)((char *)&v95 + 9);
          *(_DWORD *)v97 = 136315138;
          v98 = v82;
          _os_log_error_impl(&dword_224FE9000, v81, OS_LOG_TYPE_ERROR, "PropertyBagWriter; serialization callback of type '%s' failed.",
            v97,
            0xCu);

          if ((_QWORD)v95)
          {
            if ((BYTE8(v95) & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v95 + 40))();
          }
        }
        LOBYTE(v38) = 0;
      }
      if (*(_QWORD *)buf && (buf[8] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)buf + 40))();
      goto LABEL_118;
    case 0xD:
      if (((*(uint64_t (**)(const re::IntrospectionBase *, unsigned int *))(*(_QWORD *)a2 + 56))(a2, a3) & 1) != 0)
      {
        v55 = (const re::IntrospectionBase *)*((_QWORD *)a2 + 6);
        v56 = (char *)(*(uint64_t (**)(const re::IntrospectionBase *, unsigned int *))(*(_QWORD *)a2 + 80))(a2, a3);
        v57 = this;
        v58 = v55;
LABEL_125:
LABEL_126:
        v38 = v29;
      }
      else
      {
LABEL_86:
        objc_msgSend(MEMORY[0x24BDBCEF8], "null");
        objc_claimAutoreleasedReturnValue();
LABEL_121:
        v38 = 1;
      }
LABEL_127:
      v54 = v38 & 0xFFFFFFFFFFFFFF00;
      return v38 | v54;
    default:
      v53 = *re::foundationSerializationLogObjects(this);
      if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
        goto LABEL_67;
      v18 = v53;
      re::getPrettyTypeName(a2, (const re::IntrospectionBase *)buf);
      if ((buf[8] & 1) != 0)
        v79 = *(_BYTE **)&buf[16];
      else
        v79 = &buf[9];
      LODWORD(v95) = 136315138;
      *(_QWORD *)((char *)&v95 + 4) = v79;
      goto LABEL_137;
  }
}

uint64_t `anonymous namespace'::PropertyBagWriter::writePolymorphicPointer(_anonymous_namespace_::PropertyBagWriter *this, re::PolymorphicData *a2, char *a3)
{
  const void *v6;
  uint64_t v7;
  re *v8;
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  re *v14;
  void *v15;
  void *v16;
  NSObject *v17;
  uint8_t v19[16];
  uint8_t buf[8];
  uint64_t __dst;

  v6 = *(const void **)a2;
  v7 = *((_QWORD *)a2 + 1);
  __dst = 0;
  v8 = (re *)memcpy(&__dst, v6, *(int *)(v7 + 20));
  v9 = (unsigned int *)*((_QWORD *)a2 + 2);
  v10 = *v9;
  if ((_DWORD)v10)
  {
    v11 = *((_QWORD *)v9 + 1) + 24;
    while (*(_QWORD *)v11 != __dst)
    {
      v11 += 40;
      if (!--v10)
        goto LABEL_5;
    }
    v16 = v15;
    if ((_BYTE)v14)
    {
      if (*(_DWORD *)(*(_QWORD *)(v11 - 16) + 16) == 8)
      {
        v15;
        v13 = 1;
LABEL_14:

        return v13;
      }
      v17 = *re::foundationSerializationLogObjects(v14);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v19 = 0;
        _os_log_error_impl(&dword_224FE9000, v17, OS_LOG_TYPE_ERROR, "PropertyBagWriter; polymorphic type must be structure.",
          v19,
          2u);
      }
    }
    v13 = 0;
    goto LABEL_14;
  }
LABEL_5:
  v12 = *re::foundationSerializationLogObjects(v8);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl(&dword_224FE9000, v12, OS_LOG_TYPE_ERROR, "PropertyBagWriter; failed to find polymorphic type.",
      buf,
      2u);
  }
  return 0;
}

void std::__function::__func<`anonymous namespace'::PropertyBagWriter::writeHashTable(re::IntrospectionBase const&,void const*)::{lambda(void const*,void *)#1},std::allocator<`anonymous namespace'::PropertyBagWriter::writeHashTable(re::IntrospectionBase const&,void const*)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

__n128 std::__function::__func<`anonymous namespace'::PropertyBagWriter::writeHashTable(re::IntrospectionBase const&,void const*)::{lambda(void const*,void *)#1},std::allocator<`anonymous namespace'::PropertyBagWriter::writeHashTable(re::IntrospectionBase const&,void const*)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x20uLL);
  *(_QWORD *)v2 = &off_24ED88988;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((_QWORD *)v2 + 3) = *(_QWORD *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<`anonymous namespace'::PropertyBagWriter::writeHashTable(re::IntrospectionBase const&,void const*)::{lambda(void const*,void *)#1},std::allocator<`anonymous namespace'::PropertyBagWriter::writeHashTable(re::IntrospectionBase const&,void const*)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED88988;
  result = *(__n128 *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL std::__function::__func<`anonymous namespace'::PropertyBagWriter::writeHashTable(re::IntrospectionBase const&,void const*)::{lambda(void const*,void *)#1},std::allocator<`anonymous namespace'::PropertyBagWriter::writeHashTable(re::IntrospectionBase const&,void const*)::{lambda(void const*,void *)#1}>,BOOL ()(void const*,void *)>::operator()(uint64_t a1, unsigned int **a2, unsigned int **a3, double a4)
{
  unsigned int *v5;
  _anonymous_namespace_::PropertyBagWriter *v6;
  char v7;
  double v8;
  void *v9;
  void *v10;
  char v11;
  void *v12;
  void *v13;
  _BOOL8 v14;

  v5 = *a3;
  v6 = *(_anonymous_namespace_::PropertyBagWriter **)(a1 + 24);
  v10 = v9;
  if (v7)
  {
    v13 = v12;
    v14 = v11 != 0;
    if (v11)
      objc_msgSend(**(id **)(a1 + 8), "setObject:forKey:", v12, v10);

  }
  else
  {
    v14 = 0;
  }

  return v14;
}

unint64_t `anonymous namespace'::PropertyBagWriter::writeMember(_anonymous_namespace_::PropertyBagWriter *this, const re::IntrospectionBase **a2, char *a3)
{
  char **v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  NSObject *v9;
  NSObject *v10;
  char *v11;
  const char *v12;
  const re::IntrospectionBase *v13;
  char *v14;
  re *v15;
  NSObject *v16;
  const re::IntrospectionBase *v17;
  const char *v18;
  char *v19;
  uint64_t v20;
  _QWORD *v21;
  _DWORD *v22;
  _DWORD **v23;
  uint64_t v24;
  _DWORD *v25;
  const re::IntrospectionBase *v26;
  NSObject *v27;
  char *v28;
  _OWORD *v29;
  uint64_t v30;
  _OWORD *v31;
  uint64_t v32;
  const re::IntrospectionBase *v34;
  unint64_t __dst;
  uint8_t buf[16];
  uint64_t v37;
  int v38;
  __int16 v39;
  uint64_t v40;
  uint64_t v41;
  __int128 *v42;
  _QWORD *v43;
  __int128 v44;
  char *v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v5 = (char **)&a3[*((int *)a2 + 9)];
  switch(*((_DWORD *)a2 + 10))
  {
    case 0:
      LOBYTE(v7) = v6;
      v8 = v6 & 0xFFFFFFFFFFFFFF00;
      return v8 & 0xFFFFFFFFFFFFFF00 | v7;
    case 1:
      v13 = a2[6];
      if (!v13)
      {
        v16 = *re::foundationSerializationLogObjects(this);
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          goto LABEL_26;
        v34 = a2[1];
        LODWORD(v44) = 136315138;
        *(_QWORD *)((char *)&v44 + 4) = v34;
        v18 = "PropertyBagWriter; failed to get array length for member '%s'.";
        goto LABEL_44;
      }
      v14 = &a3[*((int *)a2 + 16)];
      __dst = 0;
      v15 = (re *)memcpy(&__dst, v14, *((int *)v13 + 5));
      if (__dst >> 31)
      {
        v16 = *re::foundationSerializationLogObjects(v15);
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          goto LABEL_26;
        v17 = a2[1];
        LODWORD(v44) = 136315138;
        *(_QWORD *)((char *)&v44 + 4) = v17;
        v18 = "PropertyBagWriter; array too big for member '%s'.";
LABEL_44:
        _os_log_error_impl(&dword_224FE9000, v16, OS_LOG_TYPE_ERROR, v18, (uint8_t *)&v44, 0xCu);
        goto LABEL_26;
      }
      re::IntrospectionCStyleArray::IntrospectionCStyleArray((re::IntrospectionCStyleArray *)&v44, *((const re::IntrospectionBase **)a2[2] + 6), __dst);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)buf, 0);
      v37 = 0x800000001;
      v38 = 8;
      v39 = 0;
      v40 = 0;
      v41 = 0xFFFFFFFFLL;
      *(_QWORD *)buf = &off_24ED30800;
      v42 = &v44;
      v43 = 0;
      *(_QWORD *)buf = &off_24ED30800;
      v42 = 0;
      v29 = v43;
      if (v43)
      {
        v30 = *v43;
        if (*v43)
        {
          if ((v43[1] & 1) != 0)
            (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v30 + 40))(*v43, v43[2]);
          *v29 = 0u;
          v29[1] = 0u;
        }
        (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)v30 + 40))(v30, v29);
        v43 = 0;
      }
      v8 = v7 & 0xFFFFFFFFFFFFFF00;
      *(_QWORD *)buf = &off_24ED426B8;
      objc_destructInstance(&buf[8]);
      *(_QWORD *)&v44 = &off_24ED23640;
      v46 = 0;
      v31 = v47;
      if (v47)
      {
        v32 = *v47;
        if (*v47)
        {
          if ((v47[1] & 1) != 0)
            (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v32 + 40))(*v47, v47[2]);
          *v31 = 0u;
          v31[1] = 0u;
        }
        (*(void (**)(uint64_t, _OWORD *))(*(_QWORD *)v32 + 40))(v32, v31);
        v47 = 0;
      }
      *(_QWORD *)&v44 = &off_24ED426B8;
      objc_destructInstance((char *)&v44 + 8);
      return v8 & 0xFFFFFFFFFFFFFF00 | v7;
    case 2:
      v19 = *v5;
      if (*v5)
      {
        v20 = *((_QWORD *)a2[2] + 6);
        v21 = *(_QWORD **)(v20 + 64);
        v22 = (_DWORD *)*v21;
        if (*(_DWORD *)*v21 != 2)
        {
          v23 = (_DWORD **)(v21 + 1);
          v24 = *(unsigned int *)(v20 + 56) - 1;
          do
          {
            v25 = *v23++;
            v22 = v25;
            --v24;
          }
          while (*v25 != 2);
        }
        v26 = a2[6];
        *(_QWORD *)&v44 = &a3[*((int *)a2 + 16)];
        *((_QWORD *)&v44 + 1) = v26;
        v45 = (char *)*((_QWORD *)v22 + 1);
      }
      else
      {
        objc_msgSend(MEMORY[0x24BDBCEF8], "null");
        objc_claimAutoreleasedReturnValue();
        v7 = 1;
      }
      v8 = v7 & 0xFFFFFFFFFFFFFF00;
      return v8 & 0xFFFFFFFFFFFFFF00 | v7;
    case 3:
      v27 = *re::foundationSerializationLogObjects(this);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        goto LABEL_26;
      v10 = v27;
      re::makePrettyMemberName(a2[1], (re::DynamicString *)&v44);
      if ((BYTE8(v44) & 1) != 0)
        v28 = v45;
      else
        v28 = (char *)&v44 + 9;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v28;
      v12 = "PropertyBagWriter; unexpected parent for '%s'.";
      goto LABEL_22;
    default:
      v9 = *re::foundationSerializationLogObjects(this);
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        goto LABEL_26;
      v10 = v9;
      re::makePrettyMemberName(a2[1], (re::DynamicString *)&v44);
      if ((BYTE8(v44) & 1) != 0)
        v11 = v45;
      else
        v11 = (char *)&v44 + 9;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v11;
      v12 = "PropertyBagWriter; unknown member type for '%s'.";
LABEL_22:
      _os_log_error_impl(&dword_224FE9000, v10, OS_LOG_TYPE_ERROR, v12, buf, 0xCu);

      if ((_QWORD)v44 && (BYTE8(v44) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v44 + 40))();
LABEL_26:
      v8 = 0;
      LOBYTE(v7) = 0;
      return v8 & 0xFFFFFFFFFFFFFF00 | v7;
  }
}

uint64_t `anonymous namespace'::PropertyBagWriter::writeMemberArray(_anonymous_namespace_::PropertyBagWriter *this, const re::IntrospectionStructure *a2, char *a3, NSMutableArray *a4)
{
  NSMutableArray *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char v11;
  void *v12;
  void *v13;
  void *v14;
  _BYTE *v15;
  void *v16;
  unint64_t v17;
  void *v18;
  _BYTE *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  _BYTE *v24;
  uint64_t v25;
  char v26;
  _BYTE v27[7];
  _BYTE *v28;
  _QWORD v29[3];
  _QWORD v30[4];

  v30[3] = *MEMORY[0x24BDAC8D0];
  v7 = a4;
  if (!*((_DWORD *)a2 + 14))
  {
LABEL_22:
    v22 = 1;
    goto LABEL_25;
  }
  v8 = 0;
  v24 = v27;
  v9 = 0x24BDD1000uLL;
  while (1)
  {
    v10 = *(_QWORD *)(*((_QWORD *)a2 + 8) + 8 * v8);
    if (*(_DWORD *)v10 != 1)
      goto LABEL_21;
    if (*(_DWORD *)(v10 + 40) != 3)
      break;
LABEL_21:
    if (++v8 >= (unint64_t)*((unsigned int *)a2 + 14))
      goto LABEL_22;
  }
  v13 = v12;
  if (v11)
  {
    v14 = *(void **)(v9 + 1992);
    re::makePrettyMemberName(*(re **)(v10 + 8), (re::DynamicString *)&v25);
    if ((v26 & 1) != 0)
      v15 = v28;
    else
      v15 = v24;
    objc_msgSend(v14, "stringWithUTF8String:", v15, v24);
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    if (v25 && (v26 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v25 + 40))();
    v17 = v9;
    v18 = *(void **)(v9 + 1992);
    re::getPrettyTypeName(*(re **)(v10 + 16), (const re::IntrospectionBase *)&v25);
    if ((v26 & 1) != 0)
      v19 = v28;
    else
      v19 = v24;
    objc_msgSend(v18, "stringWithUTF8String:", v19);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    if (v25 && (v26 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v25 + 40))();
    v29[0] = CFSTR("name");
    v29[1] = CFSTR("type");
    v30[0] = v16;
    v30[1] = v20;
    v29[2] = CFSTR("value");
    v30[2] = v13;
    objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v30, v29, 3);
    v21 = (void *)objc_claimAutoreleasedReturnValue();
    -[NSMutableArray addObject:](v7, "addObject:", v21);

    v9 = v17;
    goto LABEL_21;
  }

LABEL_24:
  v22 = 0;
LABEL_25:

  return v22;
}

void serializeJSON(_anonymous_namespace_ *this@<X2>, uint64_t a2@<X0>, const re::TypeInfo *a3@<X1>, uint64_t *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, char a7@<W6>, uint64_t a8@<X8>)
{
  unsigned __int8 v13;
  _anonymous_namespace_ *v14;
  _anonymous_namespace_ *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  char isObject;
  __int128 v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  uint64_t (**v30)();
  uint64_t v31;
  void (***v32)(re::DynamicArrayBufferedOutputStream *__hidden);
  uint64_t v33;
  int v34;
  uint64_t *v35;
  _QWORD *v36;
  _BYTE v37[8];
  __int128 v38;
  _BYTE v39[32];
  _QWORD v40[3];
  int v41;
  uint64_t v42;
  int v43;
  char v44;
  uint64_t v45;
  __int128 v46;
  __int128 v47;
  _QWORD v48[5];
  __int16 v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  _BYTE v53[32];
  int v54;
  uint64_t v55;
  __int16 v56;
  uint64_t v57[4];
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  __int128 v64;
  __int128 v65;
  int v66;
  __int128 v67;
  __int128 v68;
  int v69;
  uint64_t v70;
  void (**v71)(re::DynamicArrayBufferedOutputStream *__hidden);
  __int16 v72;
  uint64_t v73;
  _QWORD v74[4];
  __int16 v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  _QWORD v80[4];
  _BYTE v81[32];
  int v82;
  uint64_t v83;
  StringID v84[4];

  *(_QWORD *)(a6 + 16) = 0;
  ++*(_DWORD *)(a6 + 24);
  re::Allocator::Allocator((re::Allocator *)v80, "ScratchAllocator", 1);
  v80[0] = &off_24ED421C8;
  v80[3] = a4;
  memset(v81, 0, sizeof(v81));
  v82 = 0;
  v83 = 0x7FFFFFFFLL;
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::init((uint64_t)v81, (uint64_t)a4, 3);
  v72 = 0;
  v71 = &off_24ED7C190;
  v73 = a6;
  v74[0] = &unk_24ED7C1E8;
  v74[1] = 0;
  v74[2] = &off_24ED1E8F0;
  v74[3] = v74;
  v75 = 0;
  v77 = 0;
  v76 = 0;
  v78 = 0x2000;
  v79 = 0;
  *(_QWORD *)&v84[0].var0 = 0x92C38D6C53AC6124;
  v84[0].var1 = "JSON-SerializerV1";
  v30 = &off_24ED88A38;
  re::StringID::StringID((re::StringID *)&v31, v84);
  v42 = 0;
  memset(v40, 0, sizeof(v40));
  v41 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37[0] = 0;
  v43 = 12;
  v44 = 0;
  v45 = 1024;
  v13 = atomic_load((unsigned __int8 *)&qword_254123138);
  if ((v13 & 1) == 0 && __cxa_guard_acquire(&qword_254123138))
  {
    re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v20, (uint64_t)&v26);
    if ((_BYTE)v26)
      v21 = SDWORD1(v26);
    else
      v21 = 0;
    _MergedGlobals_482 = v21;
    __cxa_guard_release(&qword_254123138);
  }
  if (_MergedGlobals_482)
    v45 = _MergedGlobals_482;
  v49 = 0;
  v46 = 0u;
  v47 = 0u;
  memset(v48, 0, 28);
  memset(v53, 0, sizeof(v53));
  v54 = 0;
  v50 = 0;
  v51 = 0;
  v52 = 0;
  v55 = 0x7FFFFFFFLL;
  v48[4] = 0;
  v30 = &off_24ED889D0;
  v56 = 1;
  v59 = 0x7FFFFFFFLL;
  v65 = 0u;
  v64 = 0u;
  memset(v57, 0, sizeof(v57));
  v58 = 0;
  v60 = 0;
  v61 = 0;
  v63 = 0;
  v62 = 0;
  v70 = 0;
  v66 = 0;
  v69 = 0;
  v67 = 0u;
  v68 = 0u;
  re::StringID::destroyString((re::StringID *)v84);
  v51 = *(_QWORD *)a3;
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)v53);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFuncs(&v30);
  v14 = (_anonymous_namespace_ *)((uint64_t (*)(uint64_t (***)()))v30[4])(&v30);
  v52 = *(_DWORD *)(v51 + 24);
  LOBYTE(v56) = a7;
  v50 = a5;
  v32 = &v71;
  v33 = 0;
  v34 = 0;
  if (!a4)
  {
  }
  v35 = a4;
  v36 = v80;
  *(_BYTE *)&v84[0].var0 = 0;
  re::Optional<re::DetailedError>::operator=((uint64_t)v37, (unsigned __int8 *)v84);
  if (*(_BYTE *)&v84[0].var0 && v84[1].var1 && (*(_BYTE *)&v84[2].var0 & 1) != 0)
    (*(void (**)(char *, char *))(*(_QWORD *)v84[1].var1 + 40))(v84[1].var1, v84[2].var1);
  v40[0] = v35;
  re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity(v40, 0x40uLL);
  ++v41;
  *(_BYTE *)&v84[0].var0 = 0;
  memset(&v84[0].var0 + 1, 0, 44);
  re::DynamicArray<re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::State>::add((uint64_t)v40, (uint64_t)v84);
  if (!re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance)
  {
  }
  v48[0] = v36;
  re::DynamicArray<char>::setCapacity(v48, 0);
  ++LODWORD(v48[3]);
  v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v35 + 32))(v35, 72, 8);
  *(_OWORD *)v16 = 0u;
  *(_OWORD *)(v16 + 16) = 0u;
  *(_OWORD *)(v16 + 32) = 0u;
  *(_QWORD *)(v16 + 48) = 512;
  *(_DWORD *)(v16 + 56) = 324;
  *(_WORD *)(v16 + 60) = 2304;
  *((_QWORD *)&v46 + 1) = v16;
  *(_QWORD *)(v16 + 64) = 0x100000001;
  v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v35 + 32))(v35, 48, 8);
  *(_OWORD *)v17 = 0u;
  *(_OWORD *)(v17 + 16) = 0u;
  *(_QWORD *)(v17 + 32) = 0;
  *(_QWORD *)(v17 + 40) = 256;
  *(_QWORD *)&v46 = v17;
  v18 = *((_QWORD *)&v46 + 1);
  **((_QWORD **)&v46 + 1) = v17;
  *(_BYTE *)(v18 + 60) = 0;
  *(_QWORD *)(v18 + 32) = *(_QWORD *)(v18 + 24);
  ((void (*)(uint64_t))v30[6])((uint64_t)&v30);
  if ((isObject & 1) != 0)
  {
    if (!v37[0])
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))v30[9])((uint64_t)&v30, (uint64_t)"object", 0, a2, a3, (uint64_t)this, 0);
  }
  else
  {
    if (!re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((uint64_t)&v32, "root", 0))
    {
      *(_BYTE *)&v84[0].var0 = v37[0];
      if (v37[0])
      {
        *(_OWORD *)&v84[0].var1 = v38;
        re::DynamicString::DynamicString((re::DynamicString *)&v84[1].var1, (const re::DynamicString *)v39);
      }
      v26 = *(_OWORD *)&v84[0].var1;
      goto LABEL_25;
    }
    if (!v37[0])
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))v30[9])((uint64_t)&v30, (uint64_t)"object", 0, a2, a3, (uint64_t)this, 0);
  }
  ((void (*)(uint64_t))v30[7])((uint64_t)&v30);
  if (!v37[0])
  {
    *(_BYTE *)a8 = 1;
    goto LABEL_29;
  }
  *(_BYTE *)&v84[0].var0 = 1;
  *(_OWORD *)&v84[0].var1 = v38;
  re::DynamicString::DynamicString((re::DynamicString *)&v84[1].var1, (const re::DynamicString *)v39);
  v26 = *(_OWORD *)&v84[0].var1;
LABEL_25:
  re::DynamicString::DynamicString((re::DynamicString *)&v27, (const re::DynamicString *)&v84[1].var1);
  *(_BYTE *)a8 = 0;
  *(_OWORD *)(a8 + 8) = v26;
  *(_QWORD *)(a8 + 24) = v27;
  *(_QWORD *)(a8 + 48) = v29;
  *(_OWORD *)(a8 + 32) = v28;
  v29 = 0;
  v27 = 0;
  v28 = 0uLL;
  if (*(_BYTE *)&v84[0].var0 && v84[1].var1 && (*(_BYTE *)&v84[2].var0 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v84[1].var1 + 40))();
LABEL_29:
  v30 = &off_24ED889D0;
  if (*((_QWORD *)&v67 + 1))
  {
    if (v70)
      (*(void (**)(void))(**((_QWORD **)&v67 + 1) + 40))();
    v70 = 0;
    v68 = 0uLL;
    *((_QWORD *)&v67 + 1) = 0;
    ++v69;
  }
  if (*((_QWORD *)&v64 + 1))
  {
    if ((_QWORD)v67)
      (*(void (**)(void))(**((_QWORD **)&v64 + 1) + 40))();
    *(_QWORD *)&v67 = 0;
    v65 = 0uLL;
    *((_QWORD *)&v64 + 1) = 0;
    ++v66;
  }
  if (v60)
  {
    if ((_QWORD)v64)
      (*(void (**)(void))(*(_QWORD *)v60 + 40))();
    *(_QWORD *)&v64 = 0;
    v61 = 0;
    v62 = 0;
    v60 = 0;
    ++v63;
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v57);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer((uint64_t)&v30);
  re::DynamicArrayBufferedOutputStream::~DynamicArrayBufferedOutputStream((re::DynamicArrayBufferedOutputStream *)&v71);
  re::LeakTestAllocator::~LeakTestAllocator((re::LeakTestAllocator *)v80, v19);
}

uint64_t `anonymous namespace'::isObject(_anonymous_namespace_ *this, const re::TypeInfo *a2)
{
  uint64_t *v3;
  char *v4;
  uint64_t result;
  uint64_t *v6;
  const char *v7;
  uint64_t *v8;
  const char *v9;

  if (*((_BYTE *)this + 12) != 8)
    return 0;
  v3 = re::TypeInfo::name(this);
  if ((unint64_t)*v3 >> 1 == 94623636)
  {
    v4 = (char *)v3[1];
    if (v4 == "char*")
      return 0;
    result = strcmp(v4, "char*");
    if (!(_DWORD)result)
      return result;
  }
  v6 = re::TypeInfo::name(this);
  if ((unint64_t)*v6 >> 1 != 0x134375A94D9F7110)
  {
LABEL_8:
    v8 = re::TypeInfo::name(this);
    if ((unint64_t)*v8 >> 1 != 0x22C6ED80D0CLL)
      return 1;
    v9 = (const char *)v8[1];
    if (v9 != "StringID")
      return strcmp(v9, "StringID") != 0;
    return 0;
  }
  v7 = (const char *)v6[1];
  if (v7 != "DynamicString")
  {
    result = strcmp(v7, "DynamicString");
    if (!(_DWORD)result)
      return result;
    goto LABEL_8;
  }
  return 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(uint64_t a1, char *__s, int a3)
{
  int v3;
  _OWORD v8[3];

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), __s);
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartObject(*(_QWORD *)(a1 + 168));
    LOBYTE(v8[0]) = 2;
    DWORD1(v8[0]) = a3 | 0x20;
    *((_QWORD *)&v8[0] + 1) = __s;
    memset(&v8[1], 0, 32);
    re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, v8);
  }
  return v3 == 0;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED889D0;
  v2 = *(_QWORD *)(a1 + 472);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 504))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 480) = 0;
    *(_QWORD *)(a1 + 488) = 0;
    *(_QWORD *)(a1 + 472) = 0;
    ++*(_DWORD *)(a1 + 496);
  }
  v3 = *(_QWORD *)(a1 + 432);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 464))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 464) = 0;
    *(_QWORD *)(a1 + 440) = 0;
    *(_QWORD *)(a1 + 448) = 0;
    *(_QWORD *)(a1 + 432) = 0;
    ++*(_DWORD *)(a1 + 456);
  }
  v4 = *(_QWORD *)(a1 + 392);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 344));
  return re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
}

void deserializeJSON(re::TypeInfo *this@<X2>, re::Allocator *a2@<X4>, uint64_t a3@<X0>, const re::TypeInfo *a4@<X1>, _anonymous_namespace_ *a5@<X3>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  void **Instance;
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  _BYTE v19[8];
  __int128 v20;
  uint64_t v21;
  char v22;

  Instance = re::TypeInfo::createInstance(this, a2, 0);
  deserializeJSONIntoExistingObject(a5, a3, a4, this, (uint64_t *)a2, a6, (uint64_t)Instance, (uint64_t)v19);
  if (v19[0])
  {
    *(_BYTE *)a7 = 1;
    *(_QWORD *)(a7 + 8) = Instance;
  }
  else
  {
    re::TypeInfo::releaseInstance(this, Instance, a2, 0);
    v15 = v20;
    re::DynamicString::DynamicString((re::DynamicString *)&v16, (const re::DynamicString *)&v21);
    *(_BYTE *)a7 = 0;
    *(_OWORD *)(a7 + 8) = v15;
    *(_QWORD *)(a7 + 24) = v16;
    *(_QWORD *)(a7 + 48) = v18;
    *(_OWORD *)(a7 + 32) = v17;
    if (v21)
    {
      if ((v22 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v21 + 40))();
    }
  }
}

void deserializeJSONIntoExistingObject(_anonymous_namespace_ *this@<X3>, uint64_t a2@<X0>, const re::TypeInfo *a3@<X1>, re::TypeInfo *a4@<X2>, uint64_t *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X8>)
{
  int v10;
  _anonymous_namespace_ *v13;
  _QWORD *v14;
  unsigned __int8 v15;
  _anonymous_namespace_ *v16;
  _anonymous_namespace_ *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  _anonymous_namespace_ *v27;
  char isObject;
  __int128 v30;
  uint64_t v31;
  __int128 v32;
  uint64_t v33;
  uint64_t (**v34)();
  uint64_t v35;
  void (***v36)(re::FixedArrayInputStream *__hidden);
  uint64_t v37;
  int v38;
  uint64_t *v39;
  _QWORD *v40;
  _BYTE v41[8];
  __int128 v42;
  _BYTE v43[32];
  _QWORD v44[3];
  int v45;
  uint64_t v46;
  int v47;
  char v48;
  uint64_t v49;
  __int128 v50;
  __int128 v51;
  _QWORD v52[5];
  __int16 v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  _BYTE v57[32];
  int v58;
  uint64_t v59;
  __int16 v60;
  uint64_t v61[4];
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  __int128 v68;
  __int128 v69;
  int v70;
  __int128 v71;
  __int128 v72;
  int v73;
  uint64_t v74;
  void (**v75)(re::FixedArrayInputStream *__hidden);
  __int16 v76;
  _QWORD *v77;
  void *v78;
  uint64_t v79;
  int v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  _QWORD v84[4];
  _BYTE v85[32];
  int v86;
  uint64_t v87;
  StringID v88[3];
  uint64_t v89;
  char v90;
  uint64_t v91;

  v26 = a7;
  v27 = this;
  v10 = (int)a3;
  re::Allocator::Allocator((re::Allocator *)v84, "ScratchAllocator", 1);
  v84[0] = &off_24ED421C8;
  v84[3] = a5;
  memset(v85, 0, sizeof(v85));
  v86 = 0;
  v87 = 0x7FFFFFFFLL;
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::init((uint64_t)v85, (uint64_t)a5, 3);
  v14[1] = 0;
  v14[2] = 0;
  *v14 = 0;
  v76 = 256;
  v75 = &off_24ED7C2E0;
  v77 = v14;
  v78 = &unk_24ED1E828;
  v79 = a2;
  v80 = v10;
  v81 = v10;
  v82 = 0;
  v83 = v10;
  *(_QWORD *)&v88[0].var0 = 0x3ADDC8B1C9D5BCA6;
  v88[0].var1 = "JSON-DeserializerV1";
  v34 = &off_24ED88B08;
  re::StringID::StringID((re::StringID *)&v35, v88);
  v46 = 0;
  memset(v44, 0, sizeof(v44));
  v45 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  v41[0] = 0;
  v47 = 12;
  v48 = 0;
  v49 = 1024;
  v15 = atomic_load((unsigned __int8 *)&qword_254123148);
  if ((v15 & 1) == 0 && __cxa_guard_acquire(&qword_254123148))
  {
    re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v24, (uint64_t)&v30);
    if ((_BYTE)v30)
      v25 = SDWORD1(v30);
    else
      v25 = 0;
    qword_254123140 = v25;
    __cxa_guard_release(&qword_254123148);
  }
  if (qword_254123140)
    v49 = qword_254123140;
  v53 = 0;
  v50 = 0u;
  v51 = 0u;
  memset(v52, 0, 28);
  memset(v57, 0, sizeof(v57));
  v58 = 0;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v59 = 0x7FFFFFFFLL;
  v52[4] = 0;
  v34 = &off_24ED88AA0;
  v60 = 1;
  v63 = 0x7FFFFFFFLL;
  v69 = 0u;
  v68 = 0u;
  memset(v61, 0, sizeof(v61));
  v62 = 0;
  v64 = 0;
  v65 = 0;
  v67 = 0;
  v66 = 0;
  v74 = 0;
  v70 = 0;
  v73 = 0;
  v71 = 0u;
  v72 = 0u;
  re::StringID::destroyString((re::StringID *)v88);
  v55 = *(_QWORD *)a4;
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)v57);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFuncs(&v34);
  v16 = (_anonymous_namespace_ *)((uint64_t (*)(uint64_t (***)()))v34[4])(&v34);
  v56 = *(_DWORD *)(v55 + 24);
  v54 = a6;
  v36 = &v75;
  v37 = 0;
  v38 = 0;
  if (!a5)
  {
  }
  v39 = a5;
  v40 = v84;
  *(_BYTE *)&v88[0].var0 = 0;
  re::Optional<re::DetailedError>::operator=((uint64_t)v41, (unsigned __int8 *)v88);
  if (*(_BYTE *)&v88[0].var0 && v88[1].var1 && (*(_BYTE *)&v88[2].var0 & 1) != 0)
    (*(void (**)(char *, char *))(*(_QWORD *)v88[1].var1 + 40))(v88[1].var1, v88[2].var1);
  v44[0] = v39;
  re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity(v44, 0x40uLL);
  ++v45;
  *(_BYTE *)&v88[0].var0 = 0;
  memset(&v88[0].var0 + 1, 0, 44);
  re::DynamicArray<re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::State>::add((uint64_t)v44, (uint64_t)v88);
  if (!re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance)
  {
  }
  v52[0] = v40;
  re::DynamicArray<char>::setCapacity(v52, 0);
  ++LODWORD(v52[3]);
  v18 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v39 + 32))(v39, 72, 8);
  *(_OWORD *)v18 = 0u;
  *(_OWORD *)(v18 + 16) = 0u;
  *(_QWORD *)(v18 + 32) = 0;
  *(_QWORD *)(v18 + 40) = 256;
  *(_DWORD *)(v18 + 48) = 0;
  *(_QWORD *)(v18 + 56) = 0;
  *(_DWORD *)(v18 + 64) = 2;
  *((_QWORD *)&v51 + 1) = v18;
  v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v39 + 32))(v39, 104, 8);
  *(_QWORD *)&v51 = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::GenericDocument(v19, 0, 1024, 0);
  v30 = (unint64_t)v36;
  LODWORD(v31) = 0;
  v32 = 0uLL;
  v20 = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::ParseStream<440u,rapidjson::UTF8<char>,re::internal::RapidJSONInputStream>(v51, &v30);
  v21 = *(_QWORD *)(v20 + 88);
  if ((_DWORD)v21)
  {
    v22 = v21 > 0x11
        ? "Unknown error."
        : *(char **)((char *)off_24ED88DD0 + (((v21 << 32) - 0x100000000) >> 29));
    re::DynamicString::format((re::DynamicString *)"Failed to deserialize JSON: %s (Offset %zu)", (re::DynamicString *)&v89, v22, *(_QWORD *)(v20 + 96), v26, v27);
    if (v89)
    {
      if ((v90 & 1) != 0)
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v89 + 40))(v89, v91);
    }
  }
  if ((unint64_t)v32 < (int)v31)
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v30 + 24))(v30, (v31 - v32));
  ((void (*)(uint64_t))v34[6])((uint64_t)&v34);
  if ((isObject & 1) != 0)
  {
    if (!v41[0])
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))v34[9])((uint64_t)&v34, (uint64_t)"object", 0, v26, a4, (uint64_t)v27, 0);
  }
  else
  {
    if ((re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((uint64_t)&v36, "root", 0) & 1) == 0)
    {
      *(_BYTE *)&v88[0].var0 = v41[0];
      if (v41[0])
      {
        *(_OWORD *)&v88[0].var1 = v42;
        re::DynamicString::DynamicString((re::DynamicString *)&v88[1].var1, (const re::DynamicString *)v43);
      }
      v30 = *(_OWORD *)&v88[0].var1;
      goto LABEL_34;
    }
    if (!v41[0])
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))v34[9])((uint64_t)&v34, (uint64_t)"object", 0, v26, a4, (uint64_t)v27, 0);
  }
  ((void (*)(uint64_t))v34[7])((uint64_t)&v34);
  if (!v41[0])
  {
    *(_BYTE *)a8 = 1;
    goto LABEL_38;
  }
  *(_BYTE *)&v88[0].var0 = 1;
  *(_OWORD *)&v88[0].var1 = v42;
  re::DynamicString::DynamicString((re::DynamicString *)&v88[1].var1, (const re::DynamicString *)v43);
  v30 = *(_OWORD *)&v88[0].var1;
LABEL_34:
  re::DynamicString::DynamicString((re::DynamicString *)&v31, (const re::DynamicString *)&v88[1].var1);
  *(_BYTE *)a8 = 0;
  *(_OWORD *)(a8 + 8) = v30;
  *(_QWORD *)(a8 + 24) = v31;
  *(_QWORD *)(a8 + 48) = v33;
  *(_OWORD *)(a8 + 32) = v32;
  v33 = 0;
  v31 = 0;
  v32 = 0uLL;
  if (*(_BYTE *)&v88[0].var0 && v88[1].var1 && (*(_BYTE *)&v88[2].var0 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v88[1].var1 + 40))();
LABEL_38:
  v34 = &off_24ED88AA0;
  if (*((_QWORD *)&v71 + 1))
  {
    if (v74)
      (*(void (**)(void))(**((_QWORD **)&v71 + 1) + 40))();
    v74 = 0;
    v72 = 0uLL;
    *((_QWORD *)&v71 + 1) = 0;
    ++v73;
  }
  if (*((_QWORD *)&v68 + 1))
  {
    if ((_QWORD)v71)
      (*(void (**)(void))(**((_QWORD **)&v68 + 1) + 40))();
    *(_QWORD *)&v71 = 0;
    v69 = 0uLL;
    *((_QWORD *)&v68 + 1) = 0;
    ++v70;
  }
  if (v64)
  {
    if ((_QWORD)v68)
      (*(void (**)(void))(*(_QWORD *)v64 + 40))();
    *(_QWORD *)&v68 = 0;
    v65 = 0;
    v66 = 0;
    v64 = 0;
    ++v67;
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v61);
  re::Serializer<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer((uint64_t)&v34);
  re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)&v75);
  re::LeakTestAllocator::~LeakTestAllocator((re::LeakTestAllocator *)v84, v23);
}

unsigned int *re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(uint64_t a1, char *a2, int a3)
{
  unsigned int *result;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if (result)
  {
    if (*((_WORD *)result + 11) == 3)
    {
      LOBYTE(v7) = 2;
      DWORD1(v7) = a3;
      *((_QWORD *)&v7 + 1) = a2;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = result;
      re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v7);
      return (unsigned int *)1;
    }
    return 0;
  }
  return result;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED88AA0;
  v2 = *(_QWORD *)(a1 + 472);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 504))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 480) = 0;
    *(_QWORD *)(a1 + 488) = 0;
    *(_QWORD *)(a1 + 472) = 0;
    ++*(_DWORD *)(a1 + 496);
  }
  v3 = *(_QWORD *)(a1 + 432);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 464))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 464) = 0;
    *(_QWORD *)(a1 + 440) = 0;
    *(_QWORD *)(a1 + 448) = 0;
    *(_QWORD *)(a1 + 432) = 0;
    ++*(_DWORD *)(a1 + 456);
  }
  v4 = *(_QWORD *)(a1 + 392);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 344));
  return re::Serializer<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
}

void serializeJSON(uint64_t a1@<X0>, const re::TypeInfo *a2@<X1>, const re::TypeInfo *a3@<X2>, re::Allocator *a4@<X3>, uint64_t a5@<X4>, CFDataRef theData@<X5>, char a7@<W6>, uint64_t a8@<X8>)
{
  if (CFDataGetLength(theData))
    serializeJSON<re::CFDataOutputStream>(a3, a1, a2, (uint64_t *)a4, a5, theData, a7, a8);
  else
    serializeJSON<re::CFDataBufferedOutputStream>(a3, a1, a2, (uint64_t *)a4, a5, theData, a7, a8);
}

void serializeJSON<re::CFDataBufferedOutputStream>(_anonymous_namespace_ *this@<X2>, uint64_t a2@<X0>, const re::TypeInfo *a3@<X1>, uint64_t *a4@<X3>, uint64_t a5@<X4>, const __CFData *a6@<X5>, char a7@<W6>, uint64_t a8@<X8>)
{
  int Length;
  int v14;
  unsigned __int8 v15;
  _anonymous_namespace_ *v16;
  _anonymous_namespace_ *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  char isObject;
  __int128 v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  uint64_t (**v32)();
  uint64_t v33;
  void (***v34)(re::CFDataBufferedOutputStream *__hidden);
  uint64_t v35;
  int v36;
  uint64_t *v37;
  _QWORD *v38;
  char v39[8];
  __int128 v40;
  _BYTE v41[32];
  _QWORD v42[3];
  int v43;
  uint64_t v44;
  int v45;
  char v46;
  uint64_t v47;
  __int128 v48;
  __int128 v49;
  _QWORD v50[5];
  __int16 v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  _OWORD v55[2];
  int v56;
  uint64_t v57;
  __int16 v58;
  uint64_t v59[4];
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  __int128 v66;
  __int128 v67;
  int v68;
  __int128 v69;
  __int128 v70;
  int v71;
  uint64_t v72;
  void (**v73)(re::CFDataBufferedOutputStream *__hidden);
  __int16 v74;
  const __CFData **v75;
  _QWORD v76[4];
  __int16 v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  uint64_t v82;
  _QWORD v83[4];
  _OWORD v84[2];
  int v85;
  uint64_t v86;
  const __CFData *v87;
  StringID v88[4];

  v87 = a6;
  re::Allocator::Allocator((re::Allocator *)v83, "ScratchAllocator", 1);
  v83[0] = &off_24ED421C8;
  v83[3] = a4;
  memset(v84, 0, sizeof(v84));
  v85 = 0;
  v86 = 0x7FFFFFFFLL;
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::init((uint64_t)v84, (uint64_t)a4, 3);
  Length = CFDataGetLength(a6);
  v74 = 0;
  v73 = &off_24ED7C210;
  v75 = &v87;
  v76[0] = &unk_24ED7C268;
  v76[1] = 0;
  v76[2] = &off_24ED1E8F0;
  v76[3] = v76;
  v77 = 0;
  if (Length <= 0)
    v14 = 0x2000;
  else
    v14 = Length;
  v79 = 0;
  v78 = 0;
  v80 = v14;
  v81 = 0;
  v82 = 0;
  CFRetain(a6);
  *(_QWORD *)&v88[0].var0 = 0x4C90FC40E60EA890;
  v88[0].var1 = "JSON-SerializerV1-CFData";
  v32 = &off_24ED88CA8;
  re::StringID::StringID((re::StringID *)&v33, v88);
  v44 = 0;
  memset(v42, 0, sizeof(v42));
  v43 = 0;
  v34 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39[0] = 0;
  v45 = 12;
  v46 = 0;
  v47 = 1024;
  v15 = atomic_load((unsigned __int8 *)&qword_254123158);
  if ((v15 & 1) == 0 && __cxa_guard_acquire(&qword_254123158))
  {
    re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v22, (uint64_t)&v28);
    if ((_BYTE)v28)
      v23 = SDWORD1(v28);
    else
      v23 = 0;
    qword_254123150 = v23;
    __cxa_guard_release(&qword_254123158);
  }
  if (qword_254123150)
    v47 = qword_254123150;
  v51 = 0;
  v48 = 0u;
  v49 = 0u;
  memset(v50, 0, 28);
  memset(v55, 0, sizeof(v55));
  v56 = 0;
  v52 = 0;
  v53 = 0;
  v54 = 0;
  v57 = 0x7FFFFFFFLL;
  v50[4] = 0;
  v32 = &off_24ED88C40;
  v58 = 1;
  v61 = 0x7FFFFFFFLL;
  v67 = 0u;
  v66 = 0u;
  memset(v59, 0, sizeof(v59));
  v60 = 0;
  v62 = 0;
  v63 = 0;
  v65 = 0;
  v64 = 0;
  v72 = 0;
  v68 = 0;
  v71 = 0;
  v69 = 0u;
  v70 = 0u;
  re::StringID::destroyString((re::StringID *)v88);
  v53 = *(_QWORD *)a3;
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)v55);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFuncs(&v32);
  v16 = (_anonymous_namespace_ *)((uint64_t (*)(uint64_t (***)()))v32[4])(&v32);
  v54 = *(_DWORD *)(v53 + 24);
  LOBYTE(v58) = a7;
  v52 = a5;
  v34 = &v73;
  v35 = 0;
  v36 = 0;
  if (!a4)
  {
  }
  v37 = a4;
  v38 = v83;
  *(_BYTE *)&v88[0].var0 = 0;
  re::Optional<re::DetailedError>::operator=((uint64_t)v39, (unsigned __int8 *)v88);
  if (*(_BYTE *)&v88[0].var0 && v88[1].var1 && (*(_BYTE *)&v88[2].var0 & 1) != 0)
    (*(void (**)(char *, char *))(*(_QWORD *)v88[1].var1 + 40))(v88[1].var1, v88[2].var1);
  v42[0] = v37;
  re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity(v42, 0x40uLL);
  ++v43;
  *(_BYTE *)&v88[0].var0 = 0;
  memset(&v88[0].var0 + 1, 0, 44);
  re::DynamicArray<re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::State>::add((uint64_t)v42, (uint64_t)v88);
  if (!re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance)
  {
  }
  v50[0] = v38;
  re::DynamicArray<char>::setCapacity(v50, 0);
  ++LODWORD(v50[3]);
  v18 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v37 + 32))(v37, 64, 8);
  *(_OWORD *)v18 = 0u;
  *(_OWORD *)(v18 + 16) = 0u;
  *(_OWORD *)(v18 + 32) = 0u;
  *(_QWORD *)(v18 + 48) = 512;
  *(_DWORD *)(v18 + 56) = 324;
  *(_BYTE *)(v18 + 60) = 0;
  *((_QWORD *)&v48 + 1) = v18;
  v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v37 + 32))(v37, 48, 8);
  *(_OWORD *)v19 = 0u;
  *(_OWORD *)(v19 + 16) = 0u;
  *(_QWORD *)(v19 + 32) = 0;
  *(_QWORD *)(v19 + 40) = 256;
  *(_QWORD *)&v48 = v19;
  v20 = *((_QWORD *)&v48 + 1);
  **((_QWORD **)&v48 + 1) = v19;
  *(_BYTE *)(v20 + 60) = 0;
  *(_QWORD *)(v20 + 32) = *(_QWORD *)(v20 + 24);
  ((void (*)(uint64_t))v32[6])((uint64_t)&v32);
  if ((isObject & 1) != 0)
  {
    if (!v39[0])
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))v32[9])((uint64_t)&v32, (uint64_t)"object", 0, a2, a3, (uint64_t)this, 0);
  }
  else
  {
    if (!re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((uint64_t)&v34, "root", 0))
    {
      *(_BYTE *)&v88[0].var0 = v39[0];
      if (v39[0])
      {
        *(_OWORD *)&v88[0].var1 = v40;
        re::DynamicString::DynamicString((re::DynamicString *)&v88[1].var1, (const re::DynamicString *)v41);
      }
      v28 = *(_OWORD *)&v88[0].var1;
      goto LABEL_28;
    }
    if (!v39[0])
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))v32[9])((uint64_t)&v32, (uint64_t)"object", 0, a2, a3, (uint64_t)this, 0);
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)&v34);
  }
  ((void (*)(uint64_t))v32[7])((uint64_t)&v32);
  if (!v39[0])
  {
    *(_BYTE *)a8 = 1;
    goto LABEL_32;
  }
  *(_BYTE *)&v88[0].var0 = 1;
  *(_OWORD *)&v88[0].var1 = v40;
  re::DynamicString::DynamicString((re::DynamicString *)&v88[1].var1, (const re::DynamicString *)v41);
  v28 = *(_OWORD *)&v88[0].var1;
LABEL_28:
  re::DynamicString::DynamicString((re::DynamicString *)&v29, (const re::DynamicString *)&v88[1].var1);
  *(_BYTE *)a8 = 0;
  *(_OWORD *)(a8 + 8) = v28;
  *(_QWORD *)(a8 + 24) = v29;
  *(_QWORD *)(a8 + 48) = v31;
  *(_OWORD *)(a8 + 32) = v30;
  v31 = 0;
  v29 = 0;
  v30 = 0uLL;
  if (*(_BYTE *)&v88[0].var0 && v88[1].var1 && (*(_BYTE *)&v88[2].var0 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v88[1].var1 + 40))();
LABEL_32:
  v32 = &off_24ED88C40;
  if (*((_QWORD *)&v69 + 1))
  {
    if (v72)
      (*(void (**)(void))(**((_QWORD **)&v69 + 1) + 40))();
    v72 = 0;
    v70 = 0uLL;
    *((_QWORD *)&v69 + 1) = 0;
    ++v71;
  }
  if (*((_QWORD *)&v66 + 1))
  {
    if ((_QWORD)v69)
      (*(void (**)(void))(**((_QWORD **)&v66 + 1) + 40))();
    *(_QWORD *)&v69 = 0;
    v67 = 0uLL;
    *((_QWORD *)&v66 + 1) = 0;
    ++v68;
  }
  if (v62)
  {
    if ((_QWORD)v66)
      (*(void (**)(void))(*(_QWORD *)v62 + 40))();
    *(_QWORD *)&v66 = 0;
    v63 = 0;
    v64 = 0;
    v62 = 0;
    ++v65;
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v59);
  re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer((uint64_t)&v32);
  re::CFDataBufferedOutputStream::~CFDataBufferedOutputStream((re::CFDataBufferedOutputStream *)&v73);
  re::LeakTestAllocator::~LeakTestAllocator((re::LeakTestAllocator *)v83, v21);
}

void serializeJSON<re::CFDataOutputStream>(_anonymous_namespace_ *this@<X2>, uint64_t a2@<X0>, const re::TypeInfo *a3@<X1>, uint64_t *a4@<X3>, uint64_t a5@<X4>, const __CFData *a6@<X5>, char a7@<W6>, uint64_t a8@<X8>)
{
  int Length;
  UInt8 *MutableBytePtr;
  unsigned __int8 v15;
  _anonymous_namespace_ *v16;
  _anonymous_namespace_ *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _anonymous_namespace_ *v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  char isObject;
  __int128 v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  uint64_t (**v33)();
  uint64_t v34;
  void (***v35)();
  uint64_t v36;
  int v37;
  uint64_t *v38;
  _QWORD *v39;
  char v40[8];
  __int128 v41;
  _BYTE v42[32];
  _QWORD v43[3];
  int v44;
  uint64_t v45;
  int v46;
  char v47;
  uint64_t v48;
  __int128 v49;
  __int128 v50;
  _QWORD v51[5];
  __int16 v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  _BYTE v56[32];
  int v57;
  uint64_t v58;
  __int16 v59;
  uint64_t v60[4];
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  __int128 v67;
  __int128 v68;
  int v69;
  __int128 v70;
  __int128 v71;
  int v72;
  uint64_t v73;
  void (**v74)();
  __int16 v75;
  const __CFData **v76;
  void *v77;
  UInt8 *v78;
  int v79;
  int v80;
  uint64_t v81;
  _QWORD v82[4];
  _OWORD v83[2];
  int v84;
  uint64_t v85;
  const __CFData *v86;
  StringID v87[4];

  v86 = a6;
  re::Allocator::Allocator((re::Allocator *)v82, "ScratchAllocator", 1);
  v82[0] = &off_24ED421C8;
  v82[3] = a4;
  memset(v83, 0, sizeof(v83));
  v84 = 0;
  v85 = 0x7FFFFFFFLL;
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::init((uint64_t)v83, (uint64_t)a4, 3);
  Length = CFDataGetLength(a6);
  v75 = 0;
  v76 = &v86;
  v74 = (void (**)())&off_24ED7C290;
  MutableBytePtr = CFDataGetMutableBytePtr(a6);
  v77 = &unk_24ED1E868;
  v78 = MutableBytePtr;
  v79 = Length;
  v80 = Length;
  v81 = 0;
  *(_QWORD *)&v87[0].var0 = 0x4C90FC40E60EA890;
  v87[0].var1 = "JSON-SerializerV1-CFData";
  v33 = &off_24ED88D78;
  re::StringID::StringID((re::StringID *)&v34, v87);
  v45 = 0;
  memset(v43, 0, sizeof(v43));
  v44 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40[0] = 0;
  v46 = 12;
  v47 = 0;
  v48 = 1024;
  v15 = atomic_load((unsigned __int8 *)&qword_254123168);
  if ((v15 & 1) == 0 && __cxa_guard_acquire(&qword_254123168))
  {
    re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v23, (uint64_t)&v29);
    if ((_BYTE)v29)
      v24 = SDWORD1(v29);
    else
      v24 = 0;
    qword_254123160 = v24;
    __cxa_guard_release(&qword_254123168);
  }
  if (qword_254123160)
    v48 = qword_254123160;
  v52 = 0;
  v49 = 0u;
  v50 = 0u;
  memset(v51, 0, 28);
  memset(v56, 0, sizeof(v56));
  v57 = 0;
  v53 = 0;
  v54 = 0;
  v55 = 0;
  v58 = 0x7FFFFFFFLL;
  v51[4] = 0;
  v33 = &off_24ED88D10;
  v59 = 1;
  v62 = 0x7FFFFFFFLL;
  v68 = 0u;
  v67 = 0u;
  memset(v60, 0, sizeof(v60));
  v61 = 0;
  v63 = 0;
  v64 = 0;
  v66 = 0;
  v65 = 0;
  v73 = 0;
  v69 = 0;
  v72 = 0;
  v70 = 0u;
  v71 = 0u;
  re::StringID::destroyString((re::StringID *)v87);
  v54 = *(_QWORD *)a3;
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)v56);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFuncs(&v33);
  v16 = (_anonymous_namespace_ *)((uint64_t (*)(uint64_t (***)()))v33[4])(&v33);
  v55 = *(_DWORD *)(v54 + 24);
  LOBYTE(v59) = a7;
  v53 = a5;
  v35 = &v74;
  v36 = 0;
  v37 = 0;
  if (!a4)
  {
  }
  v38 = a4;
  v39 = v82;
  *(_BYTE *)&v87[0].var0 = 0;
  re::Optional<re::DetailedError>::operator=((uint64_t)v40, (unsigned __int8 *)v87);
  if (*(_BYTE *)&v87[0].var0 && v87[1].var1 && (*(_BYTE *)&v87[2].var0 & 1) != 0)
    (*(void (**)(char *, char *))(*(_QWORD *)v87[1].var1 + 40))(v87[1].var1, v87[2].var1);
  v43[0] = v38;
  re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity(v43, 0x40uLL);
  ++v44;
  *(_BYTE *)&v87[0].var0 = 0;
  memset(&v87[0].var0 + 1, 0, 44);
  re::DynamicArray<re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::State>::add((uint64_t)v43, (uint64_t)v87);
  if (!re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance)
  {
  }
  v51[0] = v39;
  re::DynamicArray<char>::setCapacity(v51, 0);
  ++LODWORD(v51[3]);
  v18 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v38 + 32))(v38, 64, 8);
  *(_OWORD *)v18 = 0u;
  *(_OWORD *)(v18 + 16) = 0u;
  *(_OWORD *)(v18 + 32) = 0u;
  *(_QWORD *)(v18 + 48) = 512;
  *(_DWORD *)(v18 + 56) = 324;
  *(_BYTE *)(v18 + 60) = 0;
  *((_QWORD *)&v49 + 1) = v18;
  v19 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v38 + 32))(v38, 48, 8);
  *(_OWORD *)v19 = 0u;
  *(_OWORD *)(v19 + 16) = 0u;
  *(_QWORD *)(v19 + 32) = 0;
  *(_QWORD *)(v19 + 40) = 256;
  *(_QWORD *)&v49 = v19;
  v20 = *((_QWORD *)&v49 + 1);
  **((_QWORD **)&v49 + 1) = v19;
  *(_BYTE *)(v20 + 60) = 0;
  *(_QWORD *)(v20 + 32) = *(_QWORD *)(v20 + 24);
  ((void (*)(uint64_t))v33[6])((uint64_t)&v33);
  if ((isObject & 1) != 0)
  {
    if (!v40[0])
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))v33[9])((uint64_t)&v33, (uint64_t)"object", 0, a2, a3, (uint64_t)this, 0);
  }
  else
  {
    if (!re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((uint64_t)&v35, "root", 0))
    {
      *(_BYTE *)&v87[0].var0 = v40[0];
      if (v40[0])
      {
        *(_OWORD *)&v87[0].var1 = v41;
        re::DynamicString::DynamicString((re::DynamicString *)&v87[1].var1, (const re::DynamicString *)v42);
      }
      v29 = *(_OWORD *)&v87[0].var1;
      goto LABEL_25;
    }
    if (!v40[0])
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))v33[9])((uint64_t)&v33, (uint64_t)"object", 0, a2, a3, (uint64_t)this, 0);
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)&v35);
  }
  ((void (*)(uint64_t))v33[7])((uint64_t)&v33);
  if (!v40[0])
  {
    *(_BYTE *)a8 = 1;
    goto LABEL_29;
  }
  *(_BYTE *)&v87[0].var0 = 1;
  *(_OWORD *)&v87[0].var1 = v41;
  re::DynamicString::DynamicString((re::DynamicString *)&v87[1].var1, (const re::DynamicString *)v42);
  v29 = *(_OWORD *)&v87[0].var1;
LABEL_25:
  re::DynamicString::DynamicString((re::DynamicString *)&v30, (const re::DynamicString *)&v87[1].var1);
  *(_BYTE *)a8 = 0;
  *(_OWORD *)(a8 + 8) = v29;
  *(_QWORD *)(a8 + 24) = v30;
  *(_QWORD *)(a8 + 48) = v32;
  *(_OWORD *)(a8 + 32) = v31;
  v32 = 0;
  v30 = 0;
  v31 = 0uLL;
  if (*(_BYTE *)&v87[0].var0 && v87[1].var1 && (*(_BYTE *)&v87[2].var0 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v87[1].var1 + 40))();
LABEL_29:
  v33 = &off_24ED88D10;
  if (*((_QWORD *)&v70 + 1))
  {
    if (v73)
      (*(void (**)(void))(**((_QWORD **)&v70 + 1) + 40))();
    v73 = 0;
    v71 = 0uLL;
    *((_QWORD *)&v70 + 1) = 0;
    ++v72;
  }
  if (*((_QWORD *)&v67 + 1))
  {
    if ((_QWORD)v70)
      (*(void (**)(void))(**((_QWORD **)&v67 + 1) + 40))();
    *(_QWORD *)&v70 = 0;
    v68 = 0uLL;
    *((_QWORD *)&v67 + 1) = 0;
    ++v69;
  }
  if (v63)
  {
    if ((_QWORD)v67)
      (*(void (**)(void))(*(_QWORD *)v63 + 40))();
    *(_QWORD *)&v67 = 0;
    v64 = 0;
    v65 = 0;
    v63 = 0;
    ++v66;
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v60);
  v21 = (_anonymous_namespace_ *)re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer((uint64_t)&v33);
  v74 = off_24ED7C548;
  if (HIBYTE(v75))
  {
    v22 = (uint64_t)v76;
    if (v76)
  }
  re::LeakTestAllocator::~LeakTestAllocator((re::LeakTestAllocator *)v82, v22);
}

void deserializeJSON(const __CFData *a1@<X0>, const re::TypeInfo *this@<X1>, const re::TypeInfo *a3@<X2>, re::Allocator *a4@<X3>, void *a5@<X4>, uint64_t a6@<X8>)
{
  void **Instance;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  _BYTE v17[8];
  __int128 v18;
  uint64_t v19;
  char v20;

  Instance = re::TypeInfo::createInstance(this, a4, 0);
  deserializeJSONIntoExistingObject(a1, this, a3, a4, a5, (uint64_t)Instance, (uint64_t)v17);
  if (v17[0])
  {
    *(_BYTE *)a6 = 1;
    *(_QWORD *)(a6 + 8) = Instance;
  }
  else
  {
    re::TypeInfo::releaseInstance(this, Instance, a4, 0);
    v13 = v18;
    re::DynamicString::DynamicString((re::DynamicString *)&v14, (const re::DynamicString *)&v19);
    *(_BYTE *)a6 = 0;
    *(_OWORD *)(a6 + 8) = v13;
    *(_QWORD *)(a6 + 24) = v14;
    *(_QWORD *)(a6 + 48) = v16;
    *(_OWORD *)(a6 + 32) = v15;
    if (v19)
    {
      if ((v20 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v19 + 40))();
    }
  }
}

void deserializeJSONIntoExistingObject(const __CFData *a1@<X0>, const re::TypeInfo *a2@<X1>, const re::TypeInfo *this@<X2>, re::Allocator *a4@<X3>, void *a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  int Length;
  const UInt8 *BytePtr;
  unsigned __int8 v14;
  _anonymous_namespace_ *v15;
  _anonymous_namespace_ *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  _anonymous_namespace_ *v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  char isObject;
  __int128 v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  uint64_t (**v33)();
  uint64_t v34;
  void (***v35)();
  uint64_t v36;
  int v37;
  re::Allocator *v38;
  _QWORD *v39;
  _BYTE v40[8];
  __int128 v41;
  _BYTE v42[32];
  _QWORD v43[3];
  int v44;
  uint64_t v45;
  int v46;
  char v47;
  uint64_t v48;
  __int128 v49;
  __int128 v50;
  _QWORD v51[5];
  __int16 v52;
  void *v53;
  uint64_t v54;
  int v55;
  _BYTE v56[32];
  int v57;
  uint64_t v58;
  __int16 v59;
  uint64_t v60[4];
  int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  __int128 v67;
  __int128 v68;
  int v69;
  __int128 v70;
  __int128 v71;
  int v72;
  uint64_t v73;
  void (**v74)();
  __int16 v75;
  const __CFData **v76;
  void *v77;
  const UInt8 *v78;
  int v79;
  int v80;
  uint64_t v81;
  _QWORD v82[4];
  _OWORD v83[2];
  int v84;
  uint64_t v85;
  const __CFData *v86;
  StringID v87[3];
  uint64_t v88;
  char v89;
  uint64_t v90;

  v86 = a1;
  re::Allocator::Allocator((re::Allocator *)v82, "ScratchAllocator", 1);
  v82[0] = &off_24ED421C8;
  v82[3] = a4;
  memset(v83, 0, sizeof(v83));
  v84 = 0;
  v85 = 0x7FFFFFFFLL;
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::init((uint64_t)v83, (uint64_t)a4, 3);
  Length = CFDataGetLength(a1);
  v75 = 0;
  v76 = &v86;
  v74 = (void (**)())&off_24ED7C360;
  BytePtr = CFDataGetBytePtr(a1);
  v77 = &unk_24ED1E828;
  v78 = BytePtr;
  v79 = Length;
  v80 = Length;
  v81 = 0;
  *(_QWORD *)&v87[0].var0 = 0xD2A3148AB11B6CELL;
  v87[0].var1 = "JSON-DeserializerV1-CFData";
  v33 = &off_24ED88BD8;
  re::StringID::StringID((re::StringID *)&v34, v87);
  v45 = 0;
  memset(v43, 0, sizeof(v43));
  v44 = 0;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  v40[0] = 0;
  v46 = 12;
  v47 = 0;
  v48 = 1024;
  v14 = atomic_load((unsigned __int8 *)&qword_254123178);
  if ((v14 & 1) == 0 && __cxa_guard_acquire(&qword_254123178))
  {
    re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v24, (uint64_t)&v29);
    if ((_BYTE)v29)
      v25 = SDWORD1(v29);
    else
      v25 = 0;
    qword_254123170 = v25;
    __cxa_guard_release(&qword_254123178);
  }
  if (qword_254123170)
    v48 = qword_254123170;
  v52 = 0;
  v49 = 0u;
  v50 = 0u;
  memset(v51, 0, 28);
  memset(v56, 0, sizeof(v56));
  v57 = 0;
  v53 = 0;
  v54 = 0;
  v55 = 0;
  v58 = 0x7FFFFFFFLL;
  v51[4] = 0;
  v33 = &off_24ED88B70;
  v59 = 1;
  v62 = 0x7FFFFFFFLL;
  v68 = 0u;
  v67 = 0u;
  memset(v60, 0, sizeof(v60));
  v61 = 0;
  v63 = 0;
  v64 = 0;
  v66 = 0;
  v65 = 0;
  v73 = 0;
  v69 = 0;
  v72 = 0;
  v70 = 0u;
  v71 = 0u;
  re::StringID::destroyString((re::StringID *)v87);
  v54 = *(_QWORD *)a2;
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)v56);
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFuncs(&v33);
  v15 = (_anonymous_namespace_ *)((uint64_t (*)(uint64_t (***)()))v33[4])(&v33);
  v55 = *(_DWORD *)(v54 + 24);
  v53 = a5;
  v35 = &v74;
  v36 = 0;
  v37 = 0;
  if (!a4)
  {
  }
  v38 = a4;
  v39 = v82;
  *(_BYTE *)&v87[0].var0 = 0;
  re::Optional<re::DetailedError>::operator=((uint64_t)v40, (unsigned __int8 *)v87);
  if (*(_BYTE *)&v87[0].var0 && v87[1].var1 && (*(_BYTE *)&v87[2].var0 & 1) != 0)
    (*(void (**)(char *, char *))(*(_QWORD *)v87[1].var1 + 40))(v87[1].var1, v87[2].var1);
  v43[0] = v38;
  re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity(v43, 0x40uLL);
  ++v44;
  *(_BYTE *)&v87[0].var0 = 0;
  memset(&v87[0].var0 + 1, 0, 44);
  re::DynamicArray<re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::State>::add((uint64_t)v43, (uint64_t)v87);
  if (!re::internal::RapidJSONAllocator::InstanceData::instance(void)::s_instance)
  {
  }
  v51[0] = v39;
  re::DynamicArray<char>::setCapacity(v51, 0);
  ++LODWORD(v51[3]);
  v17 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)v38 + 32))(v38, 72, 8);
  *(_OWORD *)v17 = 0u;
  *(_OWORD *)(v17 + 16) = 0u;
  *(_QWORD *)(v17 + 32) = 0;
  *(_QWORD *)(v17 + 40) = 256;
  *(_DWORD *)(v17 + 48) = 0;
  *(_QWORD *)(v17 + 56) = 0;
  *(_DWORD *)(v17 + 64) = 2;
  *((_QWORD *)&v50 + 1) = v17;
  v18 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)v38 + 32))(v38, 104, 8);
  *(_QWORD *)&v50 = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::GenericDocument(v18, 0, 1024, 0);
  v29 = (unint64_t)v35;
  LODWORD(v30) = 0;
  v31 = 0uLL;
  v19 = rapidjson::GenericDocument<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>,re::internal::RapidJSONAllocator>::ParseStream<440u,rapidjson::UTF8<char>,re::internal::RapidJSONInputStream>(v50, &v29);
  v20 = *(_QWORD *)(v19 + 88);
  if ((_DWORD)v20)
  {
    v21 = v20 > 0x11
        ? "Unknown error."
        : *(char **)((char *)off_24ED88DD0 + (((v20 << 32) - 0x100000000) >> 29));
    re::DynamicString::format((re::DynamicString *)"Failed to deserialize JSON: %s (Offset %zu)", (re::DynamicString *)&v88, v21, *(_QWORD *)(v19 + 96));
    if (v88)
    {
      if ((v89 & 1) != 0)
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v88 + 40))(v88, v90);
    }
  }
  if ((unint64_t)v31 < (int)v30)
    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v29 + 24))(v29, (v30 - v31));
  ((void (*)(uint64_t))v33[6])((uint64_t)&v33);
  if ((isObject & 1) != 0)
  {
    if (!v40[0])
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))v33[9])((uint64_t)&v33, (uint64_t)"object", 0, a6, a2, (uint64_t)this, 0);
  }
  else
  {
    if ((re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((uint64_t)&v35, "root", 0) & 1) == 0)
    {
      *(_BYTE *)&v87[0].var0 = v40[0];
      if (v40[0])
      {
        *(_OWORD *)&v87[0].var1 = v41;
        re::DynamicString::DynamicString((re::DynamicString *)&v87[1].var1, (const re::DynamicString *)v42);
      }
      v29 = *(_OWORD *)&v87[0].var1;
      goto LABEL_34;
    }
    if (!v40[0])
      ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))v33[9])((uint64_t)&v33, (uint64_t)"object", 0, a6, a2, (uint64_t)this, 0);
  }
  ((void (*)(uint64_t))v33[7])((uint64_t)&v33);
  if (!v40[0])
  {
    *(_BYTE *)a7 = 1;
    goto LABEL_38;
  }
  *(_BYTE *)&v87[0].var0 = 1;
  *(_OWORD *)&v87[0].var1 = v41;
  re::DynamicString::DynamicString((re::DynamicString *)&v87[1].var1, (const re::DynamicString *)v42);
  v29 = *(_OWORD *)&v87[0].var1;
LABEL_34:
  re::DynamicString::DynamicString((re::DynamicString *)&v30, (const re::DynamicString *)&v87[1].var1);
  *(_BYTE *)a7 = 0;
  *(_OWORD *)(a7 + 8) = v29;
  *(_QWORD *)(a7 + 24) = v30;
  *(_QWORD *)(a7 + 48) = v32;
  *(_OWORD *)(a7 + 32) = v31;
  v32 = 0;
  v30 = 0;
  v31 = 0uLL;
  if (*(_BYTE *)&v87[0].var0 && v87[1].var1 && (*(_BYTE *)&v87[2].var0 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v87[1].var1 + 40))();
LABEL_38:
  v33 = &off_24ED88B70;
  if (*((_QWORD *)&v70 + 1))
  {
    if (v73)
      (*(void (**)(void))(**((_QWORD **)&v70 + 1) + 40))();
    v73 = 0;
    v71 = 0uLL;
    *((_QWORD *)&v70 + 1) = 0;
    ++v72;
  }
  if (*((_QWORD *)&v67 + 1))
  {
    if ((_QWORD)v70)
      (*(void (**)(void))(**((_QWORD **)&v67 + 1) + 40))();
    *(_QWORD *)&v70 = 0;
    v68 = 0uLL;
    *((_QWORD *)&v67 + 1) = 0;
    ++v69;
  }
  if (v63)
  {
    if ((_QWORD)v67)
      (*(void (**)(void))(*(_QWORD *)v63 + 40))();
    *(_QWORD *)&v67 = 0;
    v64 = 0;
    v65 = 0;
    v63 = 0;
    ++v66;
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(v60);
  v22 = (_anonymous_namespace_ *)re::Serializer<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer((uint64_t)&v33);
  v74 = off_24ED7C618;
  if (HIBYTE(v75))
  {
    v23 = (uint64_t)v76;
    if (v76)
  }
  re::LeakTestAllocator::~LeakTestAllocator((re::LeakTestAllocator *)v82, v23);
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED88B70;
  v2 = *(_QWORD *)(a1 + 472);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 504))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 480) = 0;
    *(_QWORD *)(a1 + 488) = 0;
    *(_QWORD *)(a1 + 472) = 0;
    ++*(_DWORD *)(a1 + 496);
  }
  v3 = *(_QWORD *)(a1 + 432);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 464))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 464) = 0;
    *(_QWORD *)(a1 + 440) = 0;
    *(_QWORD *)(a1 + 448) = 0;
    *(_QWORD *)(a1 + 432) = 0;
    ++*(_DWORD *)(a1 + 456);
  }
  v4 = *(_QWORD *)(a1 + 392);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 344));
  return re::Serializer<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  double v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_24ED88A38;
  if (*(_QWORD *)(a1 + 272))
  {
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(a1 + 288);
    *(_QWORD *)(a1 + 272) = 0;
  }
  v2 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)(a1 + 288));
  v3 = *(_QWORD *)(a1 + 216);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 248))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v3 + 40))(v3, v2);
    *(_QWORD *)(a1 + 248) = 0;
    *(_QWORD *)(a1 + 224) = 0;
    *(_QWORD *)(a1 + 232) = 0;
    *(_QWORD *)(a1 + 216) = 0;
    ++*(_DWORD *)(a1 + 240);
  }
  v4 = *(_QWORD *)(a1 + 120);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 152))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 152) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = 0;
    *(_QWORD *)(a1 + 120) = 0;
    ++*(_DWORD *)(a1 + 144);
  }
  if (*(_BYTE *)(a1 + 64))
  {
    v5 = *(_QWORD *)(a1 + 88);
    if (v5)
    {
      if ((*(_BYTE *)(a1 + 96) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *(_QWORD *)(a1 + 104));
      *(_OWORD *)(a1 + 88) = 0u;
      *(_OWORD *)(a1 + 104) = 0u;
    }
  }
  re::StringID::destroyString((re::StringID *)(a1 + 8));
  return a1;
}

void re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED889D0;
  v2 = *(_QWORD *)(a1 + 472);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 504))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 480) = 0;
    *(_QWORD *)(a1 + 488) = 0;
    *(_QWORD *)(a1 + 472) = 0;
    ++*(_DWORD *)(a1 + 496);
  }
  v3 = *(_QWORD *)(a1 + 432);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 464))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 464) = 0;
    *(_QWORD *)(a1 + 440) = 0;
    *(_QWORD *)(a1 + 448) = 0;
    *(_QWORD *)(a1 + 432) = 0;
    ++*(_DWORD *)(a1 + 456);
  }
  v4 = *(_QWORD *)(a1 + 392);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 344));
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::trackObject(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v4;

  v4 = *a3;
  return re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), a2, &v4);
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::untrackObject(uint64_t result)
{
  if (*(_BYTE *)(result + 336))
  {
    --*(_QWORD *)(result + 488);
    ++*(_DWORD *)(result + 496);
  }
  return result;
}

void re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doOpen(uint64_t a1)
{
  *(_BYTE *)(a1 + 337) = 0;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 344);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
  *(_QWORD *)(a1 + 448) = 0;
  ++*(_DWORD *)(a1 + 456);
  *(_QWORD *)(a1 + 488) = 0;
  ++*(_DWORD *)(a1 + 496);
}

void re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doClose(uint64_t a1)
{
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 344);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
  *(_QWORD *)(a1 + 448) = 0;
  ++*(_DWORD *)(a1 + 456);
  *(_QWORD *)(a1 + 488) = 0;
  ++*(_DWORD *)(a1 + 496);
}

void re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doRegisterSerializeFuncs(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 *v7;
  __int128 v8;
  __int128 v9;
  _QWORD v10[2];
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;

  v11 = 6059476;
  v12 = "BOOL";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeBool<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6104748;
  v12 = "char";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeChar<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x172E117BCLL;
  v12 = "int8_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI8<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93A4A92;
  v12 = "int16_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI16<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93BFE06;
  v12 = "int32_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI32<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93EC744;
  v12 = "int64_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6655224;
  v12 = "long";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x31CD534126;
  v12 = "uint8_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU8<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0D4E68;
  v12 = "uint16_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU16<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0F01DCLL;
  v12 = "uint32_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU32<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD11CB1ALL;
  v12 = "uint64_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x1947BDF6CLL;
  v12 = "size_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 195052728;
  v12 = "float";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeFloat<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x161EEF7A2;
  v12 = "double";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDouble<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 189247272;
  v12 = "char*";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeCString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2686EB529B3EE220;
  v12 = "DynamicString";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x458DDB01A18;
  v12 = "StringID";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v2 = *(_QWORD *)(a1 + 272);
  v11 = 0x258C98EAAF29A10ALL;
  v12 = "CallbackSerializerAttribute";
  v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v11);
  if (v3)
  {
    v4 = *v3;
    re::StringID::destroyString((re::StringID *)&v11);
    if (v2)
    {
      v5 = *(_QWORD *)(a1 + 272);
      v10[0] = v2;
      v10[1] = v4;
      re::TypeRegistry::attributesByAttributeType(v5, (uint64_t)v10, (uint64_t)&v11);
      if (v13)
      {
        v6 = 48 * v13;
        v7 = (__int128 *)(v14 + 16);
        do
        {
          v8 = *v7;
          v7 += 3;
          v9 = v8;
          re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, (uint64_t)&v9, (uint64_t)re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
          v6 -= 48;
        }
        while (v6);
      }
      if (v11)
      {
        if (v14)
          (*(void (**)(void))(*(_QWORD *)v11 + 40))();
      }
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v11);
  }
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t result;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;

  v14 = (_BYTE *)(a1 + 336);
  v15 = *(_QWORD *)(a1 + 488);
  if (!v15)
  {
    if ((_DWORD)a7)
      v16 = 0;
    else
      v16 = a4;
    v17 = **((_QWORD **)a5 + 2);
    *(_QWORD *)&v26 = *(_QWORD *)a5;
    *((_QWORD *)&v26 + 1) = v17;
    re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), v16, &v26);
  }
  v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v18)
  {
    result = v18(a1, a2, a3, a4, a5, a6, a7);
    if (!v15)
    {
      if (*v14)
      {
        --*(_QWORD *)(a1 + 488);
        ++*(_DWORD *)(a1 + 496);
      }
    }
  }
  else
  {
    v20 = re::TypeInfo::name(a5);
    return 0;
  }
  return result;
}

uint64_t (*re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, re::TypeInfo *this))(uint64_t a1, char *a2, int a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  uint64_t *v4;
  uint64_t v5;
  char *v6;
  unsigned int v7;
  uint64_t (*result)(uint64_t, char *, int, char **, re::TypeInfo *, const re::TypeInfo *, char);
  uint64_t v9;

  v4 = re::TypeInfo::name(this);
  if ((unint64_t)*v4 >> 1 == 94623636)
  {
    v6 = (char *)v4[1];
    if (v6 == "char*" || !strcmp(v6, "char*"))
      return (uint64_t (*)(uint64_t, char *, int, char **, re::TypeInfo *, const re::TypeInfo *, char))re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString;
  }
  if (*((_BYTE *)this + 12) == 9)
  {
    v7 = *(unsigned __int8 *)(*((_QWORD *)this + 2) + 80);
    if (v7 >= 2)
    {
      if (v7 == 2)
      {
        re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) External references are not supported by the SerializerV1.", "!\"Unreachable code\"", "doResolveSerializeFunc", 82);
        _os_crash();
        __break(1u);
      }
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Invalid PointerSharing type.", "!\"Unreachable code\"", "doResolveSerializeFunc", 84);
      result = (uint64_t (*)(uint64_t, char *, int, char **, re::TypeInfo *, const re::TypeInfo *, char))_os_crash();
      __break(1u);
    }
    else
    {
      return re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer;
    }
  }
  else if (*(_QWORD *)this == *(_QWORD *)(a1 + 272)
         && (v9 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, **((_QWORD **)this + 2) | 0xFFFFFFFF00000000)) != 0)
  {
    return *(uint64_t (**)(uint64_t, char *, int, char **, re::TypeInfo *, const re::TypeInfo *, char))v9;
  }
  else
  {
    return (uint64_t (*)(uint64_t, char *, int, char **, re::TypeInfo *, const re::TypeInfo *, char))re::serializeType<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  }
  return result;
}

void re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t (*v14)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v14)
    return v14(a1, a2, a3, a4, a5, a6, a7);
  v16 = re::TypeInfo::name(a5);
  return 0;
}

uint64_t (*re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(re::internal **a1, char *__s, const re::TypeInfo *a3, unsigned __int8 *a4, re *this, re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v3;

  if (*(_QWORD *)a2 == *(_QWORD *)(a1 + 272)
    && (v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, **(_QWORD **)(a2 + 16) | 0xFFFFFFFF00000000)) != 0)
  {
    return *(uint64_t (**)(re::internal **, char *, const re::TypeInfo *, unsigned __int8 *, re *, re::TypeInfo *, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  }
}

uint64_t re::serializeType<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::internal **a1, char *__s, const re::TypeInfo *a3, unsigned __int8 *a4, re *this, re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t *v23;
  unint64_t v24;
  uint64_t result;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  const re::TypeInfo *v30;
  uint64_t *v31;
  int v32;
  unint64_t v33;
  char *v34;
  BOOL (*v35)(uint64_t, char *, const re::TypeInfo *, uint64_t, re *, re::TypeInfo *, int);
  _anonymous_namespace_ *v36;
  uint64_t *v37;
  const re::TypeInfo *v38;
  char *v39;
  uint64_t v40;
  _BOOL4 v41;
  uint64_t v42;
  const re::TypeInfo *v43;
  uint64_t v44;
  unsigned __int32 v45;
  const char *v46;
  uint64_t *v47;
  unsigned __int8 *v48;
  const re::TypeInfo *v49;
  re *v50;
  uint64_t *v51;
  uint64_t v52;
  re::UnionAccessor *v53;
  unint64_t Tag;
  unint64_t v55;
  char *v56;
  re::TypeRegistry *v57;
  re *v58;
  re::TypeInfo *v59;
  uint64_t v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t *v69;
  _BOOL4 v70;
  uint64_t v71;
  uint64_t v72;
  _anonymous_namespace_ *v73;
  uint64_t v74;
  double v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v81;
  uint64_t v82;
  int v83;
  re::internal *v84;
  uint64_t v85;
  void (*v86)(re::internal **, _QWORD, _QWORD, _QWORD, rapidjson::internal **, rapidjson::internal **, uint64_t);
  uint64_t v87;
  int v88;
  unint64_t v89;
  int v90;
  uint64_t v91;
  void (*v92)(re::internal **, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD);
  _QWORD *v93;
  int v94;
  int v95;
  _anonymous_namespace_ *v96;
  BOOL v97;
  char v98;
  uint64_t v99;
  uint64_t v100;
  re::internal *v101;
  _BOOL4 v102;
  _anonymous_namespace_ *v103;
  uint64_t v104;
  void (*v105)(re::internal **, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD);
  uint64_t v106;
  _BOOL4 v107;
  uint64_t i;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  char *v114;
  const char *v115;
  char *v116;
  uint64_t v117;
  uint64_t v118;
  re::internal *v119;
  re::internal *v120;
  _anonymous_namespace_ *v121;
  re::TypeInfo *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  void (*v129)(re::internal **, const char *, _QWORD, uint64_t, _QWORD *, _QWORD **, _QWORD);
  uint64_t v130;
  void (*v131)(re::internal **, const char *, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD);
  unint64_t v132;
  _QWORD *v133;
  unint64_t *v134;
  unint64_t v135;
  unint64_t v136;
  uint64_t (**v137)(uint64_t, uint64_t);
  uint64_t (*v138)(uint64_t, uint64_t);
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  __n128 v142;
  uint64_t v143;
  unint64_t v144;
  double v145;
  unint64_t v146;
  void (*v147)(void);
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  BOOL v151;
  _anonymous_namespace_ *v152;
  unsigned int EnumConstantIndex;
  unsigned int v154;
  re::internal::TypeTranslationTable *v155;
  uint64_t v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t v159;
  BOOL v160;
  char v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  re::internal **v166;
  char *v167;
  const re::TypeInfo *v168;
  unsigned __int8 *v169;
  unint64_t v170;
  uint64_t v171;
  const char *v172;
  uint64_t v173;
  unint64_t v174;
  uint64_t v175;
  char *v176;
  uint64_t (*v177)(unsigned __int8 *, re::internal *);
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  double v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  unint64_t v195;
  char v196[16];
  uint64_t v197;
  _BYTE v198[32];
  uint64_t v199;
  rapidjson::internal *v200;
  uint64_t v201;
  unint64_t v202;
  int v203;
  char *v204;
  _QWORD *v205[4];
  uint64_t v206[4];
  _QWORD v207[4];
  _BYTE v208[28];
  __int16 v209;
  unint64_t v210;
  __n128 __dst;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  uint64_t v216;

  v216 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_18;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        goto LABEL_18;
    }
LABEL_10:
    if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12))
      goto LABEL_283;
    v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
    if (v19)
      v20 = *(_DWORD *)(v19 + 16);
    else
      v20 = -1;
    v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
    if (v21)
      v22 = *(_DWORD *)(v21 + 16);
    else
      v22 = -1;
    if (v20 != v22)
    {
      v26 = re::TypeInfo::name(this)[1];
      re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
      re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
      LOBYTE(v193) = v26;
      v46 = "Cannot serialize type \"%s\" version %u as version %u. Downgrading versions is not supported.";
LABEL_74:
      return 0;
    }
    goto LABEL_18;
  }
  if (!re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_10;
LABEL_18:
  switch(*((_BYTE *)this + 12))
  {
    case 1:
      if (this == a6)
        goto LABEL_22;
      if (*(_QWORD *)this != *(_QWORD *)a6)
      {
        if (!re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_283;
LABEL_22:
        v23 = re::TypeInfo::name(this);
        v24 = (unint64_t)*v23 >> 1;
        if (v24 <= 0xCA3DEFB5)
        {
          if ((unint64_t)*v23 >> 1 <= 0x5D0225B)
          {
            if ((unint64_t)*v23 >> 1 <= 0x2E9355)
            {
              if (v24 != 104431)
              {
                if (v24 == 3029738)
LABEL_335:
                v193 = re::TypeInfo::name(this)[1];
                v46 = "Unsupported basic type \"%s\".";
                goto LABEL_74;
              }
            }
            if (v24 == 3052374)
            v165 = 3327612;
LABEL_269:
            if (v24 == v165)
            goto LABEL_335;
          }
          if ((unint64_t)*v23 >> 1 > 0xB0F77BD0)
          {
            if (v24 == 2969009105)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>((uint64_t)(a1 + 3), __s, (double *)a4);
            if (v24 == 3111160798)
            goto LABEL_335;
          }
          if (v24 == 97526364)
            return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>((uint64_t)(a1 + 3), __s, (float *)a4);
          v52 = 109413500;
LABEL_176:
          if (v24 == v52)
          goto LABEL_335;
        }
        if ((unint64_t)*v23 >> 1 > 0x18E6A9A092)
        {
          if ((unint64_t)*v23 >> 1 <= 0x303EE8780EDLL)
          {
            if (v24 == 0x18E6A9A093)
            if (v24 == 0x303EE86A734)
            goto LABEL_335;
          }
          if (v24 == 0x303EE8780EELL)
          if (v24 != 0x303EE88E58DLL)
            goto LABEL_335;
        }
        else
        {
          if ((unint64_t)*v23 >> 1 > 0x16749DFF02)
          {
            if (v24 == 0x16749DFF03)
            v165 = 0x16749F63A2;
            goto LABEL_269;
          }
          if (v24 != 3393056694)
          {
            v52 = 0x16749D2549;
            goto LABEL_176;
          }
        }
      }
      v62 = **((_QWORD **)this + 2);
      v63 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v62 == (unsigned __int16)v63)
      {
        v18 = WORD1(v62) == WORD1(v63);
        v64 = (v63 ^ v62) & 0xFFFFFF00000000;
        if (v18 && v64 == 0)
          goto LABEL_22;
      }
      goto LABEL_283;
    case 2:
      if (this == a6)
        goto LABEL_227;
      if (*(_QWORD *)this != *(_QWORD *)a6)
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_109;
        v27 = *((unsigned __int8 *)this + 12);
LABEL_107:
        if (v27 == *((unsigned __int8 *)a6 + 12))
        {
          v68 = re::TypeInfo::name(this);
          v69 = re::TypeInfo::name(a6);
          if (re::StringID::operator==(v68, v69))
            goto LABEL_109;
        }
LABEL_283:
        return 0;
      }
      v66 = **((_QWORD **)this + 2);
      v67 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v66 != (unsigned __int16)v67
        || WORD1(v66) != WORD1(v67)
        || ((v67 ^ v66) & 0xFFFFFF00000000) != 0)
      {
        v27 = 2;
        goto LABEL_107;
      }
LABEL_109:
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v148 = **((_QWORD **)this + 2);
        v149 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v148 == (unsigned __int16)v149
          && ((v18 = WORD1(v148) == WORD1(v149), v150 = (v149 ^ v148) & 0xFFFFFF00000000, v18)
            ? (v151 = v150 == 0)
            : (v151 = 0),
              v151))
        {
LABEL_227:
          v70 = 0;
        }
        else
        {
          v70 = 1;
        }
      }
      else
      {
        v70 = !re::areSameTranslatedVersion(this, a6, a3);
      }
      if ((_DWORD)a7)
      {
        __dst.n128_u64[0] = 0;
        result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((uint64_t)(a1 + 3), __s, (uint64_t *)&__dst);
        if (!(_DWORD)result)
          return result;
        v152 = (_anonymous_namespace_ *)(a1 + 3);
LABEL_231:
        return *((_BYTE *)a1 + 64) == 0;
      }
      if (*(_DWORD *)(*((_QWORD *)this + 2) + 8) >= 9u)
      {
        v193 = re::TypeInfo::name(this)[1];
        v46 = "Enum type \"%s\" has invalid size: %zu bytes";
        goto LABEL_74;
      }
      EnumConstantIndex = re::internal::getEnumConstantIndex(this, (const re::TypeInfo *)a4, a3);
      if ((EnumConstantIndex & 0x80000000) != 0)
      {
        __dst.n128_u64[0] = 0;
        memcpy(&__dst, a4, *(unsigned int *)(*((_QWORD *)this + 2) + 8));
        LOBYTE(v193) = __dst.n128_u8[0];
        re::TypeInfo::name(this);
        v46 = "Value %zu is not a valid enum constant of \"%s\".";
        goto LABEL_74;
      }
      v154 = EnumConstantIndex;
      if (v70)
      {
        v155 = *(re::internal::TypeTranslationTable **)(*(_QWORD *)a6 + 856);
        if (!v155 || (v156 = re::internal::TypeTranslationTable::translateRuntimeEnum(v155, this, v154, a6)) == 0)
        {
          v157 = re::TypeInfo::enumConstants(this);
          v159 = v154;
          if (v158 > v154)
          {
            v193 = *(_QWORD *)(v157 + 24 * v154 + 16);
            re::TypeInfo::name(a6);
            v46 = "Runtime enum constant \"%s\" does not exist in serialized type \"%s\".";
            goto LABEL_74;
          }
LABEL_356:
          re::internal::assertLog((re::internal *)6, v158, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v159, v158);
          _os_crash();
          __break(1u);
        }
LABEL_292:
        v172 = *(const char **)(v156 + 16);
        __dst.n128_u64[0] = strlen(v172);
        if (!re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((uint64_t)(a1 + 3), __s, (uint64_t *)&__dst))return 0;
        v152 = (_anonymous_namespace_ *)(a1 + 3);
        goto LABEL_231;
      }
      result = re::TypeInfo::enumConstants(this);
      v171 = v154;
      if (v170 <= v154)
      {
LABEL_355:
        re::internal::assertLog((re::internal *)6, v170, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v171, v170);
        _os_crash();
        __break(1u);
        goto LABEL_356;
      }
      if (result)
      {
        v156 = result + 24 * v154;
        goto LABEL_292;
      }
      return result;
    case 3:
      if (this == a6)
        goto LABEL_116;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v71 = **((_QWORD **)this + 2);
        v72 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v71 == (unsigned __int16)v72
          && WORD1(v71) == WORD1(v72)
          && ((v72 ^ v71) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_116;
        }
        v28 = 3;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_116;
        v28 = *((unsigned __int8 *)this + 12);
      }
      if (v28 != *((unsigned __int8 *)a6 + 12))
        goto LABEL_283;
LABEL_116:
      if ((_DWORD)a7)
      {
        __dst.n128_u8[0] = 0;
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional((uint64_t)(a1 + 3), __s, &__dst);
        v73 = (_anonymous_namespace_ *)(a1 + 3);
      }
      else
      {
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)&v200, (uint64_t)&__dst.n128_i64[1]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
        re::TypeInfo::TypeInfo((uint64_t)&__dst, (uint64_t)this);
        v74 = (*(uint64_t (**)(unsigned __int8 *))(v212 + 80))(a4);
        LOBYTE(v207[0]) = v74 != 0;
        v75 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional((uint64_t)(a1 + 3), __s, v207);
        if (v74)
        {
          v76 = (*(uint64_t (**)(unsigned __int8 *, double))(v212 + 80))(a4, v75);
          if (!*((_BYTE *)a1 + 64))
            (*((void (**)(re::internal **, char *, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD))*a1
             + 9))(a1, __s, 0, v76, &v200, v208, 0);
        }
        v73 = (_anonymous_namespace_ *)(a1 + 3);
      }
      return *((_BYTE *)a1 + 64) == 0;
    case 4:
      if (this == a6)
        goto LABEL_131;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v77 = **((_QWORD **)this + 2);
        v78 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v77 == (unsigned __int16)v78)
        {
          v18 = WORD1(v77) == WORD1(v78);
          v79 = (v78 ^ v77) & 0xFFFFFF00000000;
          if (v18 && v79 == 0)
            goto LABEL_131;
        }
      }
      else if (re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_131;
      }
      if (*((_BYTE *)a6 + 12) != 4)
        goto LABEL_283;
      v81 = *((_QWORD *)this + 2);
      v82 = *((_QWORD *)a6 + 2);
      v83 = *(_DWORD *)(v82 + 84) & 0xFFFFFF;
      if ((*(_DWORD *)(v81 + 84) & 0xFFFFFF) != 0)
      {
        if (!v83)
          goto LABEL_283;
      }
      else if (v83 || *(_DWORD *)(v81 + 88) != *(_DWORD *)(v82 + 88))
      {
        goto LABEL_283;
      }
LABEL_131:
      if ((_DWORD)a7)
      {
        v84 = a1[34];
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
        re::internal::translateType(v84, (const re::TypeRegistry *)v208, (uint64_t)&v200);
        v85 = (*((uint64_t (**)(re::internal **, rapidjson::internal **))*a1 + 10))(a1, &v200);
        if (!v85)
          goto LABEL_201;
        v86 = (void (*)(re::internal **, _QWORD, _QWORD, _QWORD, rapidjson::internal **, rapidjson::internal **, uint64_t))v85;
        v87 = *((_QWORD *)a6 + 2);
        v88 = *(_DWORD *)(v87 + 84) & 0xFFFFFF;
        if (v88)
        {
          v89 = 0;
          v90 = 8;
        }
        else
        {
          v89 = *(int *)(v87 + 88);
          v90 = 4;
        }
        __dst.n128_u64[0] = v89;
        v96 = (_anonymous_namespace_ *)(a1 + 3);
        result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((uint64_t)(a1 + 3), __s, (uint64_t *)&__dst, v90);
        if (!(_DWORD)result)
          return result;
        if (v88)
          v160 = v89 == 0;
        else
          v160 = 1;
        v161 = v160;
        if (!v160)
        {
          v207[0] = 0;
          v207[1] = 0xFFFFFFFFLL;
          (*((void (**)(re::internal **, _QWORD, _QWORD *))*a1 + 2))(a1, 0, v207);
        }
        for (; v89; --v89)
          v86(a1, 0, 0, 0, &v200, &v200, 1);
        if ((v161 & 1) != 0)
          goto LABEL_298;
      }
      else
      {
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)&v200, (uint64_t)&__dst.n128_i64[1]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
        re::TypeInfo::TypeInfo((uint64_t)&__dst, (uint64_t)this);
        v91 = (*((uint64_t (**)(re::internal **, rapidjson::internal **))*a1 + 10))(a1, &v200);
        if (!v91)
          goto LABEL_201;
        v92 = (void (*)(re::internal **, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD))v91;
        v93 = (_QWORD *)re::ArrayAccessor::size((re::ArrayAccessor *)&__dst, (char *)a4);
        v205[0] = v93;
        v94 = *(_DWORD *)(*((_QWORD *)this + 2) + 84) & 0xFFFFFF;
        if (v94)
          v95 = 8;
        else
          v95 = 4;
        v96 = (_anonymous_namespace_ *)(a1 + 3);
        result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((uint64_t)(a1 + 3), __s, (uint64_t *)v205, v95);
        if (!(_DWORD)result)
          return result;
        if (v94)
          v97 = v93 == 0;
        else
          v97 = 1;
        v98 = v97;
        if (v97)
        {
          if (!v93)
            goto LABEL_298;
        }
        else
        {
          v173 = *(_QWORD *)a4;
          v206[0] = 0;
          v206[1] = 0xFFFFFFFFLL;
          (*((void (**)(re::internal **, uint64_t, uint64_t *))*a1 + 2))(a1, v173, v206);
        }
        v174 = 0;
        do
        {
          v175 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)&__dst, (char *)a4, v174);
          v92(a1, 0, 0, v175, &v200, v208, 0);
          ++v174;
        }
        while (v93 != (_QWORD *)v174);
        if ((v98 & 1) != 0)
        {
LABEL_298:
          v103 = v96;
LABEL_299:
          return *((_BYTE *)a1 + 64) == 0;
        }
      }
      (*((void (**)(re::internal **))*a1 + 3))(a1);
      goto LABEL_298;
    case 5:
      if (this == a6)
        goto LABEL_155;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v99 = **((_QWORD **)this + 2);
        v100 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v99 == (unsigned __int16)v100
          && WORD1(v99) == WORD1(v100)
          && ((v100 ^ v99) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_155;
        }
        v29 = 5;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_155;
        v29 = *((unsigned __int8 *)this + 12);
      }
      if (v29 != *((unsigned __int8 *)a6 + 12))
        goto LABEL_283;
LABEL_155:
      if ((_DWORD)a7)
      {
        v101 = a1[34];
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
        re::internal::translateType(v101, (const re::TypeRegistry *)v208, (uint64_t)&v200);
        if (!(*((uint64_t (**)(re::internal **, rapidjson::internal **))*a1 + 10))(a1, &v200))
          goto LABEL_201;
        __dst.n128_u64[0] = 0;
        v102 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((uint64_t)(a1 + 3), __s, (uint64_t *)&__dst, 0);
        result = 0;
        if (v102)
        {
          v103 = (_anonymous_namespace_ *)(a1 + 3);
          goto LABEL_299;
        }
        return result;
      }
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &__dst);
      re::TypeInfo::TypeInfo((uint64_t)&v200, (uint64_t)&__dst.n128_i64[1]);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
      re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
      re::TypeInfo::TypeInfo((uint64_t)&__dst, (uint64_t)this);
      v104 = (*((uint64_t (**)(re::internal **, rapidjson::internal **))*a1 + 10))(a1, &v200);
      if (!v104)
        goto LABEL_201;
      v105 = (void (*)(re::internal **, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD))v104;
      v106 = (*(uint64_t (**)(unsigned __int8 *))(v212 + 80))(a4);
      v206[0] = v106;
      v96 = (_anonymous_namespace_ *)(a1 + 3);
      v107 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((uint64_t)(a1 + 3), __s, v206, 0);
      result = 0;
      if (!v107)
        return result;
      if (*(_QWORD *)(v212 + 96))
      {
        if (v106)
        {
          for (i = 0; i != v106; ++i)
          {
            v109 = (*(uint64_t (**)(unsigned __int8 *, uint64_t))(v212 + 96))(a4, i);
            v105(a1, 0, 0, v109, &v200, v208, 0);
          }
        }
      }
      else
      {
        v177 = *(uint64_t (**)(unsigned __int8 *, re::internal *))(v212 + 104);
        if (!v177 || !*(_QWORD *)(v212 + 112) || !*(_QWORD *)(v212 + 120))
        {
          re::TypeInfo::TypeInfo((uint64_t)v207, (uint64_t)&__dst);
          v193 = re::TypeInfo::name((re::TypeInfo *)v207)[1];
          v46 = "List type \"%s\" does not provide an indexer or iterator.";
          goto LABEL_74;
        }
        v178 = v177(a4, a1[7]);
        v179 = (*(uint64_t (**)(void))(v212 + 112))();
        if (v179)
        {
          v180 = v179;
          do
          {
            v105(a1, 0, 0, v180, &v200, v208, 0);
            v180 = (*(uint64_t (**)(uint64_t))(v212 + 112))(v178);
          }
          while (v180);
        }
        (*(void (**)(uint64_t, re::internal *))(v212 + 120))(v178, a1[7]);
      }
      goto LABEL_298;
    case 6:
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &__dst);
      re::TypeInfo::TypeInfo((uint64_t)&v200, (uint64_t)&__dst.n128_i64[1]);
      v31 = re::TypeInfo::name((re::TypeInfo *)&v200);
      v32 = BYTE4(v201);
      if (BYTE4(v201) != 1)
        goto LABEL_89;
      if (!re::TypeInfo::isInteger((re::TypeInfo *)&v200))
      {
        v32 = BYTE4(v201);
LABEL_89:
        if (v32 == 8)
        {
          v55 = (unint64_t)*v31 >> 1;
          if (v55 == 0x22C6ED80D0CLL)
          {
            v116 = (char *)v31[1];
            if (v116 == "StringID" || !strcmp(v116, "StringID"))
            {
              v35 = re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
              goto LABEL_351;
            }
          }
          else if (v55 == 0x134375A94D9F7110)
          {
            v56 = (char *)v31[1];
            if (v56 == "DynamicString" || !strcmp(v56, "DynamicString"))
            {
              v35 = re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
              goto LABEL_351;
            }
          }
        }
LABEL_188:
        if (this == a6)
          goto LABEL_196;
        if (*(_QWORD *)this == *(_QWORD *)a6)
        {
          v117 = **((_QWORD **)this + 2);
          v118 = **((_QWORD **)a6 + 2);
          if ((unsigned __int16)v117 == (unsigned __int16)v118
            && WORD1(v117) == WORD1(v118)
            && ((v118 ^ v117) & 0xFFFFFF00000000) == 0)
          {
            goto LABEL_196;
          }
        }
        else if (re::areSameTranslatedVersion(this, a6, v30))
        {
          goto LABEL_196;
        }
        if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12))
          goto LABEL_283;
LABEL_196:
        if ((_DWORD)a7)
        {
          v119 = a1[34];
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
          re::internal::translateType(v119, (const re::TypeRegistry *)v208, (uint64_t)&v200);
          v120 = a1[34];
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v207, (uint64_t)&__dst.n128_i64[1]);
          re::internal::translateType(v120, (const re::TypeRegistry *)v207, (uint64_t)v208);
          if ((*((uint64_t (**)(re::internal **, rapidjson::internal **))*a1 + 10))(a1, &v200))
          {
            if ((*((uint64_t (**)(re::internal **, _BYTE *))*a1 + 10))(a1, v208))
            {
              __dst.n128_u64[0] = 0;
              result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary((uint64_t)(a1 + 3), __s, (uint64_t *)&__dst);
              if (!(_DWORD)result)
                return result;
              v121 = (_anonymous_namespace_ *)(a1 + 3);
              goto LABEL_348;
            }
            v122 = (re::TypeInfo *)v208;
          }
          else
          {
LABEL_201:
            v122 = (re::TypeInfo *)&v200;
          }
        }
        else
        {
          re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v207, (uint64_t)&__dst.n128_i64[1]);
          re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v206, (uint64_t)&__dst.n128_i64[1]);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v205, (uint64_t)&__dst.n128_i64[1]);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v198, (uint64_t)&__dst.n128_i64[1]);
          re::TypeInfo::TypeInfo((uint64_t)v196, (uint64_t)this);
          v128 = (*((uint64_t (**)(re::internal **, _QWORD *))*a1 + 10))(a1, v207);
          if (v128)
          {
            v129 = (void (*)(re::internal **, const char *, _QWORD, uint64_t, _QWORD *, _QWORD **, _QWORD))v128;
            v130 = (*((uint64_t (**)(re::internal **, uint64_t *))*a1 + 10))(a1, v206);
            if (v130)
            {
              v131 = (void (*)(re::internal **, const char *, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD))v130;
              v132 = (*(uint64_t (**)(unsigned __int8 *))(v197 + 88))(a4);
              v195 = v132;
              result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary((uint64_t)(a1 + 3), __s, (uint64_t *)&v195);
              if (!(_DWORD)result)
                return result;
              if (!v132)
                goto LABEL_347;
              v133 = *(_QWORD **)this;
              __dst.n128_u64[0] = 0x449AD97C4B77BED4;
              __dst.n128_u64[1] = (unint64_t)"_CompareFunc";
              v134 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)(v133 + 25), &__dst);
              if (v134)
              {
                v135 = *v134;
                re::StringID::destroyString((re::StringID *)&__dst);
                if (v133)
                {
                  v136 = *(_QWORD *)v207[2];
                  __dst.n128_u64[0] = v135;
                  __dst.n128_u64[1] = v136;
                  LODWORD(v212) = -1;
                  v137 = (uint64_t (**)(uint64_t, uint64_t))re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(v207[0] + 768, (uint64_t *)&__dst);
                  if (v137)
                  {
                    v138 = *v137;
                    if (*v137)
                    {
                      v204 = 0;
                      v201 = 0;
                      v202 = 0;
                      v203 = 0;
                      v200 = a1[7];
                      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v200, v132);
                      ++v203;
                      v139 = (*(uint64_t (**)(unsigned __int8 *, re::internal *))(v197 + 112))(a4, a1[7]);
                      if ((*(unsigned int (**)(void))(v197 + 120))())
                      {
                        do
                        {
                          v140 = (*(uint64_t (**)(uint64_t))(v197 + 128))(v139);
                          v141 = (*(uint64_t (**)(uint64_t))(v197 + 136))(v139);
                          __dst.n128_u64[0] = v140;
                          __dst.n128_u64[1] = v141;
                          v142 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v200, &__dst);
                        }
                        while (((*(uint64_t (**)(uint64_t, __n128))(v197 + 120))(v139, v142) & 1) != 0);
                      }
                      (*(void (**)(uint64_t, re::internal *))(v197 + 144))(v139, a1[7]);
                      std::sort[abi:nn180100]<re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1}>(v204, &v204[16 * v202], v138);
                      v143 = 0;
                      v144 = 0;
                      if (v132 <= 1)
                        v132 = 1;
                      while (1)
                      {
                        v145 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry((uint64_t)(a1 + 3), 0);
                        v146 = v202;
                        if (v202 <= v144)
                          break;
                        ((void (*)(re::internal **, const char *, _QWORD, _QWORD, _QWORD *, _QWORD **, _QWORD, double))v129)(a1, "key", 0, *(_QWORD *)&v204[v143], v207, v205, 0, v145);
                        v146 = v202;
                        if (v202 <= v144)
                          goto LABEL_354;
                        v131(a1, "value", 0, *(_QWORD *)&v204[v143 + 8], v206, v198, 0);
                        ++v144;
                        v143 += 16;
                        if (v132 == v144)
                        {
                          if (v200 && v204)
                          {
                            v147 = *(void (**)(void))(*(_QWORD *)v200 + 40);
                            goto LABEL_346;
                          }
                          goto LABEL_347;
                        }
                      }
                      v199 = 0;
                      v214 = 0u;
                      v215 = 0u;
                      v212 = 0u;
                      v213 = 0u;
                      __dst = 0u;
                      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                      *(_DWORD *)v208 = 136315906;
                      *(_QWORD *)&v208[4] = "operator[]";
                      *(_WORD *)&v208[12] = 1024;
                      *(_DWORD *)&v208[14] = 789;
                      *(_WORD *)&v208[18] = 2048;
                      *(_QWORD *)&v208[20] = v144;
                      v209 = 2048;
                      v210 = v146;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
LABEL_354:
                      v199 = 0;
                      v214 = 0u;
                      v215 = 0u;
                      v212 = 0u;
                      v213 = 0u;
                      __dst = 0u;
                      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                      *(_DWORD *)v208 = 136315906;
                      *(_QWORD *)&v208[4] = "operator[]";
                      *(_WORD *)&v208[12] = 1024;
                      *(_DWORD *)&v208[14] = 789;
                      *(_WORD *)&v208[18] = 2048;
                      *(_QWORD *)&v208[20] = v144;
                      v209 = 2048;
                      v210 = v146;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
                      goto LABEL_355;
                    }
                  }
                }
              }
              else
              {
                re::StringID::destroyString((re::StringID *)&__dst);
              }
              v189 = (*(uint64_t (**)(unsigned __int8 *, re::internal *))(v197 + 112))(a4, a1[7]);
              (*(void (**)(void))(v197 + 120))();
              do
              {
                v190 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry((uint64_t)(a1 + 3), 0);
                v191 = (*(uint64_t (**)(uint64_t, double))(v197 + 128))(v189, v190);
                v129(a1, "key", 0, v191, v207, v205, 0);
                v192 = (*(uint64_t (**)(uint64_t))(v197 + 136))(v189);
                v131(a1, "value", 0, v192, v206, v198, 0);
                (*(void (**)(uint64_t))(v197 + 120))(v189);
                --v132;
              }
              while (v132);
              v147 = *(void (**)(void))(v197 + 144);
LABEL_346:
              v147();
LABEL_347:
              v121 = (_anonymous_namespace_ *)(a1 + 3);
LABEL_348:
              return *((_BYTE *)a1 + 64) == 0;
            }
            v122 = (re::TypeInfo *)v206;
          }
          else
          {
            v122 = (re::TypeInfo *)v207;
          }
        }
        v194 = re::TypeInfo::name(v122)[1];
        return 0;
      }
      v33 = (unint64_t)*v31 >> 1;
      if (v33 > 0x303EE8780EDLL)
      {
        if (v33 == 0x303EE8780EELL)
        {
          v176 = (char *)v31[1];
          if (v176 == "uint32_t" || !strcmp(v176, "uint32_t"))
          {
            v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>;
            goto LABEL_351;
          }
          goto LABEL_306;
        }
        if (v33 != 0x303EE88E58DLL)
        {
LABEL_306:
          __dst.n128_u64[0] = 0x18E6A9A093;
          __dst.n128_u64[1] = (unint64_t)"uint8_t";
          if (re::StringID::operator==(v31, &__dst))
          {
            v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>;
            goto LABEL_351;
          }
          __dst.n128_u64[0] = 0x16749F63A2;
          __dst.n128_u64[1] = (unint64_t)"int64_t";
          if (re::StringID::operator==(v31, &__dst)
            || (*(_QWORD *)v208 = 3327612, *(_QWORD *)&v208[8] = "long", re::StringID::operator==(v31, v208)))
          {
            v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>;
            goto LABEL_351;
          }
          __dst.n128_u64[0] = 104431;
          __dst.n128_u64[1] = (unint64_t)"int";
          if (re::StringID::operator==(v31, &__dst))
          {
            v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>;
            goto LABEL_351;
          }
          __dst.n128_u64[0] = 109413500;
          __dst.n128_u64[1] = (unint64_t)"short";
          if (re::StringID::operator==(v31, &__dst))
          {
            v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>;
            goto LABEL_351;
          }
          goto LABEL_188;
        }
        v114 = (char *)v31[1];
        if (v114 != "uint64_t")
        {
          v115 = "uint64_t";
          goto LABEL_302;
        }
      }
      else
      {
        if (v33 != 3393056694)
        {
          if (v33 == 0x303EE86A734)
          {
            v34 = (char *)v31[1];
            if (v34 == "uint16_t" || !strcmp(v34, "uint16_t"))
            {
              v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>;
LABEL_351:
              v166 = a1;
              v167 = __s;
              v168 = a3;
              v169 = a4;
              v50 = this;
              v51 = (uint64_t *)a6;
              return ((uint64_t (*)(re::internal **, char *, const re::TypeInfo *, unsigned __int8 *, re *, uint64_t *, uint64_t))v35)(v166, v167, v168, v169, v50, v51, a7);
            }
          }
          goto LABEL_306;
        }
        v114 = (char *)v31[1];
        if (v114 != "size_t")
        {
          v115 = "size_t";
LABEL_302:
          if (!strcmp(v114, v115))
            goto LABEL_303;
          goto LABEL_306;
        }
      }
LABEL_303:
      v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>;
      goto LABEL_351;
    case 7:
      if (this == a6)
        goto LABEL_57;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v110 = **((_QWORD **)this + 2);
        v111 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v110 != (unsigned __int16)v111)
          goto LABEL_283;
        v18 = WORD1(v110) == WORD1(v111);
        v112 = (v111 ^ v110) & 0xFFFFFF00000000;
        if (!v18 || v112 != 0)
          goto LABEL_283;
      }
      else if (!re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_283;
      }
LABEL_57:
      v36 = (_anonymous_namespace_ *)(a1 + 3);
      result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((uint64_t)(a1 + 3), __s, 16);
      if ((_DWORD)a7)
      {
        if (!(_DWORD)result)
          return result;
        v200 = 0;
        if (*(_DWORD *)(*((_QWORD *)a6 + 2) + 88))
        {
          re::TypeInfo::unionMember(a6, 0, (uint64_t)&__dst);
          if (!*((_BYTE *)a1 + 64))
            (*((void (**)(re::internal **, const char *, _QWORD, _QWORD, __n128 *, __n128 *, uint64_t))*a1 + 9))(a1, "value", 0, 0, &__dst, &__dst, 1);
        }
      }
      else
      {
        if (!(_DWORD)result)
          return result;
        v53 = (re::UnionAccessor *)re::TypeInfo::TypeInfo((uint64_t)&__dst, (uint64_t)this);
        Tag = re::UnionAccessor::readTag(v53, (char *)a4);
        *(_QWORD *)v208 = Tag;
        if (Tag < *(unsigned int *)(*((_QWORD *)this + 2) + 88))
        {
          re::TypeInfo::unionMember(this, Tag, (uint64_t)&v200);
          if (!*((_BYTE *)a1 + 64))
            (*((void (**)(re::internal **, const char *, _QWORD, unsigned __int8 *, rapidjson::internal **, rapidjson::internal **, _QWORD))*a1
             + 9))(a1, "value", 0, a4, &v200, &v200, 0);
        }
      }
      goto LABEL_337;
    case 8:
      if (!(_DWORD)a7)
        goto LABEL_67;
      if ((*(_BYTE *)(*((_QWORD *)this + 2) + 49) & 1) != 0)
      {
        v57 = a1[34];
        *(_QWORD *)v208 = 0x2686EB529B3EE220;
        *(_QWORD *)&v208[8] = "DynamicString";
        re::TypeRegistry::typeInfo(v57, (const re::StringID *)v208, &__dst);
        re::TypeInfo::TypeInfo((uint64_t)&v200, (uint64_t)&__dst.n128_i64[1]);
        re::StringID::destroyString((re::StringID *)v208);
        v58 = (re *)&v200;
        v59 = (re::TypeInfo *)&v200;
        v60 = (uint64_t)a1;
        v61 = __s;
      }
      else
      {
        v37 = re::TypeInfo::name(this);
        if ((*v37 & 0xFFFFFFFFFFFFFFFELL) != 0x2686EB529B3EE220
          || (v39 = (char *)v37[1], v39 != "DynamicString") && strcmp(v39, "DynamicString"))
        {
LABEL_67:
          v40 = *((_QWORD *)this + 2);
          if ((*(_BYTE *)(v40 + 48) & 4) == 0)
          {
            v36 = (_anonymous_namespace_ *)(a1 + 3);
            v41 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((uint64_t)(a1 + 3), __s, 0);
            result = 0;
            if (!v41)
              return result;
            v42 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
            if (!v42 || *(_DWORD *)(v42 + 16) >= 2u)
            {
              v44 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
              if (v44)
                v45 = *(_DWORD *)(v44 + 16);
              else
                v45 = -1;
              __dst.n128_u32[0] = v45;
            }
            if (this == a6)
              goto LABEL_323;
            if (*(_QWORD *)this == *(_QWORD *)a6)
            {
              v181 = **((_QWORD **)this + 2);
              v182 = **((_QWORD **)a6 + 2);
              if ((unsigned __int16)v181 == (unsigned __int16)v182
                && WORD1(v181) == WORD1(v182)
                && ((v182 ^ v181) & 0xFFFFFF00000000) == 0)
              {
                goto LABEL_323;
              }
            }
            else if (re::areSameTranslatedVersion(this, a6, v43))
            {
LABEL_323:
              re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, (uint64_t)a4, (uint64_t *)this, a7);
LABEL_337:
              return *((_BYTE *)a1 + 64) == 0;
            }
            if (*((unsigned __int8 *)this + 12) == *((unsigned __int8 *)a6 + 12))
            {
              re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, (uint64_t)a4, (uint64_t *)this, (uint64_t *)a6, a7);
            }
            else
            {
              v183 = re::TypeInfo::name(this)[1];
              re::TypeInfo::name(a6);
            }
            goto LABEL_337;
          }
          v47 = (uint64_t *)re::TypeMemberCollection::TypeMemberCollection((uint64_t)&__dst, *(_QWORD *)this, v40);
          re::TypeMemberCollection::operator[](v47, 0, (uint64_t)v208);
          v48 = &a4[*(unsigned int *)(*(_QWORD *)&v208[16] + 24)];
          re::TypeRegistry::typeInfo(*(_QWORD **)v208, **(_QWORD **)&v208[16], &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v207, (uint64_t)&__dst.n128_i64[1]);
          if (this == a6)
            goto LABEL_78;
          if (*(_QWORD *)this == *(_QWORD *)a6)
          {
            v162 = **((_QWORD **)this + 2);
            v163 = *((_QWORD *)a6 + 2);
            v164 = *(_QWORD *)v163;
            if ((unsigned __int16)v162 == (unsigned __int16)*(_QWORD *)v163
              && WORD1(v162) == WORD1(v164)
              && ((v164 ^ v162) & 0xFFFFFF00000000) == 0)
            {
              goto LABEL_78;
            }
          }
          else
          {
            if (re::areSameTranslatedVersion(this, a6, v49))
            {
LABEL_78:
              if (*((_BYTE *)a1 + 64))
                return 0;
              v35 = (BOOL (*)(uint64_t, char *, const re::TypeInfo *, uint64_t, re *, re::TypeInfo *, int))*((_QWORD *)*a1 + 9);
              v50 = (re *)v207;
              v51 = v207;
LABEL_282:
              v166 = a1;
              v167 = __s;
              v168 = a3;
              v169 = v48;
              return ((uint64_t (*)(re::internal **, char *, const re::TypeInfo *, unsigned __int8 *, re *, uint64_t *, uint64_t))v35)(v166, v167, v168, v169, v50, v51, a7);
            }
            v163 = *((_QWORD *)a6 + 2);
          }
          if (*(_DWORD *)(v163 + 88) != 1)
            goto LABEL_283;
          re::TypeMemberCollection::TypeMemberCollection((uint64_t)&v200, *(_QWORD *)a6, v163);
          re::TypeMemberCollection::operator[]((uint64_t *)&v200, 0, (uint64_t)v205);
          re::TypeRegistry::typeInfo(v205[0], *v205[2], &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v206, (uint64_t)&__dst.n128_i64[1]);
          if (*((_BYTE *)a1 + 64))
            return 0;
          v35 = (BOOL (*)(uint64_t, char *, const re::TypeInfo *, uint64_t, re *, re::TypeInfo *, int))*((_QWORD *)*a1 + 9);
          v50 = (re *)v207;
          v51 = v206;
          goto LABEL_282;
        }
        v60 = (uint64_t)a1;
        v61 = __s;
        v58 = this;
        v59 = this;
      }
      re::serializeDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(v60, v61, v38, 0, v58, v59, 1);
      return *((_BYTE *)a1 + 64) == 0;
    case 9:
      v193 = re::TypeInfo::name(this)[1];
      v46 = "Pointer type (\"%s\") needs to be handled explicitly by the serializer.";
      goto LABEL_74;
    default:
      LOBYTE(v193) = *((_BYTE *)this + 12);
      v46 = "Invalid type category. Value = %d";
      goto LABEL_74;
  }
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(uint64_t a1, char *a2, float *a3)
{
  int v3;
  float v6;
  uint64_t v7;
  char *v8;
  double v9;
  uint64_t v10;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), a2);
    v6 = *a3;
    v7 = *(_QWORD *)(a1 + 168);
    if (fabsf(v6) == INFINITY)
    {
      if (v6 <= 0.0)
        v8 = "-Infinity";
      else
        v8 = "Infinity";
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), v8);
    }
    else
    {
      v9 = v6;
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(*(char **)(a1 + 168));
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteDouble(v7, v9);
    }
    v10 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v10 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(uint64_t a1, char *a2, double *a3)
{
  int v3;
  double v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), a2);
    v6 = *a3;
    v7 = *(_QWORD *)(a1 + 168);
    if (fabs(v6) == INFINITY)
    {
      if (v6 <= 0.0)
        v8 = "-Infinity";
      else
        v8 = "Infinity";
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), v8);
    }
    else
    {
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(*(char **)(a1 + 168));
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteDouble(v7, v6);
    }
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(uint64_t a1, char *__s, uint64_t *a3)
{
  int v3;
  uint64_t v7;
  char *v8;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), __s);
    v7 = *a3;
    if (!*a3)
    {
      v8 = *(char **)(a1 + 168);
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v8);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString((uint64_t *)v8, (uint64_t)"", 0);
      v7 = *a3;
    }
    LOBYTE(v10) = 8;
    DWORD1(v10) = 0;
    *((_QWORD *)&v10 + 1) = __s;
    v11 = 0;
    v13 = 0;
    v14 = 0;
    v12 = v7;
    re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v10);
  }
  return v3 == 0;
}

double re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(uint64_t a1, _OWORD *a2)
{
  __int128 v4;
  double result;
  _OWORD v6[3];
  uint64_t v7;
  char v8;
  uint64_t v9;

  if (*(_QWORD *)(a1 + 112) >= *(_QWORD *)(a1 + 152))
  {
    re::DynamicString::format((re::DynamicString *)"State stack overflow (max depth is %zu). Increase user default com.apple.maxSerializationDepth to allow deeper hierarchies.", (re::DynamicString *)&v7, *(_QWORD *)(a1 + 152));
    if (v7)
    {
      if ((v8 & 1) != 0)
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 40))(v7, v9);
    }
  }
  v4 = a2[1];
  v6[0] = *a2;
  v6[1] = v4;
  v6[2] = a2[2];
  *(_QWORD *)&result = re::DynamicArray<re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::State>::add(a1 + 96, (uint64_t)v6).n128_u64[0];
  return result;
}

__n128 re::DynamicArray<re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::State>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  __n128 result;
  __int128 v13;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(_QWORD *)a1)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity((_QWORD *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::State>::setCapacity((_QWORD *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    v5 = *(_QWORD *)(a1 + 16);
  }
  v11 = *(_QWORD *)(a1 + 32) + 48 * v5;
  result = *(__n128 *)a2;
  v13 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v11 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v11 + 32) = v13;
  *(__n128 *)v11 = result;
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

double re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(uint64_t a1, char *__s, _BYTE *a3)
{
  uint64_t v6;
  char *v7;
  double result;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), __s);
    if (*a3)
    {
      v6 = 1;
    }
    else
    {
      v7 = *(char **)(a1 + 168);
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v7);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteNull((uint64_t *)v7);
      v6 = *a3;
    }
    LOBYTE(v9) = 3;
    DWORD1(v9) = 0;
    *((_QWORD *)&v9 + 1) = __s;
    v10 = 0;
    v12 = 0;
    v13 = 0;
    v11 = v6;
    return re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v9);
  }
  return result;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(uint64_t a1, char *__s, uint64_t *a3, int a4)
{
  int v4;
  uint64_t v9;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v4 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), __s);
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartArray(*(_QWORD *)(a1 + 168));
    v9 = *a3;
    LOBYTE(v11) = 5;
    DWORD1(v11) = a4 & 0xFFFFFFDF;
    *((_QWORD *)&v11 + 1) = __s;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = v9;
    re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v11);
  }
  return v4 == 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unint64_t *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t **v29;
  unint64_t **v30;
  unint64_t *v31;
  unint64_t *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unint64_t **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unint64_t *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*,false>(v47, &v47[2 * v45], v28, 1);
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unsigned int *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int **v29;
  unsigned int **v30;
  unsigned int *v31;
  unsigned int *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unsigned int **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unsigned int *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*,false>(v47, &v47[2 * v45], v28, 1);
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__base_10_u32[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unsigned __int16 *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unsigned __int16 **v29;
  unsigned __int16 **v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unsigned __int16 **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unsigned __int16 *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*,false>(v47, &v47[2 * v45], v28, 1);
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__base_10_u32[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unsigned __int8 *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unsigned __int8 **v29;
  unsigned __int8 **v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unsigned __int8 **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unsigned __int8 *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*,false>(v47, &v47[2 * v45], v28, 1);
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__base_10_u32[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, uint64_t *, _BYTE *, _BYTE *, _QWORD);
  _anonymous_namespace_ *v20;
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t **v30;
  uint64_t **v31;
  unint64_t v32;
  __n128 *v33;
  uint64_t *v34;
  unsigned int v35;
  int64_t v36;
  _WORD *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  uint64_t **v52;
  __n128 v53[2];
  _QWORD v54[2];

  v54[0] = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, uint64_t *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
    if (v23)
    {
      v52 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v48 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v23);
      ++v51;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v45 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v24);
          v53[0].n128_u64[0] = v25;
          v53[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, v53);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v24, v17);
      v28 = 126 - 2 * __clz(v50);
      if (v50)
        v29 = v28;
      else
        v29 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*,false>(v52, (__n128 *)&v52[2 * v50], v29, 1);
      if (v50)
      {
        v30 = v52;
        v31 = &v52[2 * v50];
        do
        {
          v32 = **v30;
          if ((v32 & 0x8000000000000000) != 0)
          {
            v53[0].n128_u8[0] = 45;
            v32 = -(uint64_t)v32;
            v33 = (__n128 *)((char *)v53[0].n128_u64 + 1);
          }
          else
          {
            v33 = v53;
          }
          v34 = v30[1];
          if ((char *)v54 - (char *)v33 > 19
            || (v35 = (1233 * (64 - __clz(v32 | 1))) >> 12,
                v36 = v35 - (std::__itoa::__pow10_64[v35] > v32) + 1,
                v37 = v54,
                (char *)v54 - (char *)v33 >= v36))
          {
            v37 = std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:nn180100](v33, v32);
          }
          *(_BYTE *)v37 = 0;
          v19(a1, v53, 0, v34, v47, v46, 0);
          v30 += 2;
        }
        while (v30 != v31);
      }
      if (v48)
      {
        if (v52)
          (*(void (**)(void))(*(_QWORD *)v48 + 40))();
      }
      v20 = (_anonymous_namespace_ *)(a1 + 24);
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v38 = re::TypeInfo::name((re::TypeInfo *)v47);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, int *, _BYTE *, _BYTE *, _QWORD);
  _anonymous_namespace_ *v20;
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  int **v30;
  int **v31;
  unsigned int v32;
  __n128 *v33;
  int *v34;
  unsigned int v35;
  int64_t v36;
  _WORD *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  int **v52;
  __n128 v53[2];
  _QWORD v54[2];

  v54[0] = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, int *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
    if (v23)
    {
      v52 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v48 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v23);
      ++v51;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v45 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v24);
          v53[0].n128_u64[0] = v25;
          v53[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, v53);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v24, v17);
      v28 = 126 - 2 * __clz(v50);
      if (v50)
        v29 = v28;
      else
        v29 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*,false>(v52, (__n128 *)&v52[2 * v50], v29, 1);
      if (v50)
      {
        v30 = v52;
        v31 = &v52[2 * v50];
        do
        {
          v32 = **v30;
          if ((v32 & 0x80000000) != 0)
          {
            v53[0].n128_u8[0] = 45;
            v32 = -v32;
            v33 = (__n128 *)((char *)v53[0].n128_u64 + 1);
          }
          else
          {
            v33 = v53;
          }
          v34 = v30[1];
          if ((char *)v54 - (char *)v33 > 9
            || (v35 = (1233 * (32 - __clz(v32 | 1))) >> 12,
                v36 = (((__PAIR64__(v35, v32) - std::__itoa::__pow10_32[v35]) >> 32) + 1),
                v37 = v54,
                (char *)v54 - (char *)v33 >= v36))
          {
            v37 = std::__itoa::__base_10_u32[abi:nn180100](v33, v32);
          }
          *(_BYTE *)v37 = 0;
          v19(a1, v53, 0, v34, v47, v46, 0);
          v30 += 2;
        }
        while (v30 != v31);
      }
      if (v48)
      {
        if (v52)
          (*(void (**)(void))(*(_QWORD *)v48 + 40))();
      }
      v20 = (_anonymous_namespace_ *)(a1 + 24);
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v38 = re::TypeInfo::name((re::TypeInfo *)v47);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, __int16 *, _BYTE *, _BYTE *, _QWORD);
  _anonymous_namespace_ *v20;
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  __int16 **v30;
  __int16 **v31;
  unsigned int v32;
  __n128 *v33;
  __int16 *v34;
  unsigned int v35;
  int64_t v36;
  _WORD *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  __int16 **v52;
  __n128 v53[2];
  _QWORD v54[2];

  v54[0] = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, __int16 *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    v21 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
    if (v23)
    {
      v52 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v48 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v23);
      ++v51;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v45 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v24);
          v53[0].n128_u64[0] = v25;
          v53[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, v53);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v24, v17);
      v28 = 126 - 2 * __clz(v50);
      if (v50)
        v29 = v28;
      else
        v29 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*,false>(v52, &v52[2 * v50], v29, 1);
      if (v50)
      {
        v30 = v52;
        v31 = &v52[2 * v50];
        do
        {
          v32 = **v30;
          if ((v32 & 0x80000000) != 0)
          {
            v53[0].n128_u8[0] = 45;
            v32 = -v32;
            v33 = (__n128 *)((char *)v53[0].n128_u64 + 1);
          }
          else
          {
            v33 = v53;
          }
          v34 = v30[1];
          if ((char *)v54 - (char *)v33 > 9
            || (v35 = (1233 * (32 - __clz(v32 | 1))) >> 12,
                v36 = (((__PAIR64__(v35, v32) - std::__itoa::__pow10_32[v35]) >> 32) + 1),
                v37 = v54,
                (char *)v54 - (char *)v33 >= v36))
          {
            v37 = std::__itoa::__base_10_u32[abi:nn180100](v33, v32);
          }
          *(_BYTE *)v37 = 0;
          v19(a1, v53, 0, v34, v47, v46, 0);
          v30 += 2;
        }
        while (v30 != v31);
      }
      if (v48)
      {
        if (v52)
          (*(void (**)(void))(*(_QWORD *)v48 + 40))();
      }
      v20 = (_anonymous_namespace_ *)(a1 + 24);
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v38 = re::TypeInfo::name((re::TypeInfo *)v47);
  return 0;
}

BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v24;
  _BOOL8 result;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __n128 v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __n128 v43;
  char v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  uint64_t *v52;

  if (this == a6)
    goto LABEL_14;
  v13 = *(_QWORD **)this;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v14 = (uint64_t *)*((_QWORD *)a6 + 2);
    v16 = *v14;
    if ((unsigned __int16)v15 != (unsigned __int16)*v14)
      goto LABEL_10;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v21 = *(_QWORD *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
      re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
      v22 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
      if (!v22)
      {
        v37 = re::TypeInfo::name((re::TypeInfo *)v47);
        return 0;
      }
      v23 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v22;
      v24 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
      result = 0;
      if (!v24)
        return result;
      v26 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
      if (v26)
      {
        v52 = 0;
        v49 = 0;
        v50 = 0;
        v51 = 0;
        v48 = v21;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v26);
        ++v51;
        v27 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v21);
        if ((*(unsigned int (**)(void))(v45 + 120))())
        {
          do
          {
            v28 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v27);
            v29 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v27);
            v43.n128_u64[0] = v28;
            v43.n128_u64[1] = v29;
            v30 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, &v43);
          }
          while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v27, v30) & 1) != 0);
        }
        (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v27, v21);
        v31 = 126 - 2 * __clz(v50);
        if (v50)
          v32 = v31;
        else
          v32 = 0;
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*,false>(v52, &v52[2 * v50], v32, 1);
        if (v50)
        {
          v33 = v52;
          v34 = &v52[2 * v50];
          do
          {
            v35 = *v33;
            if ((*(_BYTE *)(*v33 + 8) & 1) != 0)
              v36 = *(_QWORD *)(v35 + 16);
            else
              v36 = v35 + 9;
            v23(a1, v36, 0, v33[1], v47, v46, 0);
            v33 += 2;
          }
          while (v33 != v34);
        }
        if (v48)
        {
          if (v52)
            (*(void (**)(void))(*(_QWORD *)v48 + 40))();
        }
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_14;
  v13 = *(_QWORD **)a6;
  v14 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v13, v14[9], &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  v19 = re::TypeInfo::name((re::TypeInfo *)v47);
  if ((unint64_t)*v19 >> 1 == 0x22C6ED80D0CLL)
  {
    v20 = (char *)v19[1];
    if (v20 == "StringID" || !strcmp(v20, "StringID"))
      goto LABEL_14;
  }
  return 0;
}

BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v24;
  _BOOL8 result;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __n128 v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __n128 v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  uint64_t *v52;

  if (this == a6)
    goto LABEL_14;
  v13 = *(_QWORD **)this;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v14 = (uint64_t *)*((_QWORD *)a6 + 2);
    v16 = *v14;
    if ((unsigned __int16)v15 != (unsigned __int16)*v14)
      goto LABEL_10;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v21 = *(_QWORD *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
      re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
      v22 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
      if (!v22)
      {
        v37 = re::TypeInfo::name((re::TypeInfo *)v47);
        return 0;
      }
      v23 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v22;
      v24 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
      result = 0;
      if (!v24)
        return result;
      v26 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
      if (v26)
      {
        v52 = 0;
        v49 = 0;
        v50 = 0;
        v51 = 0;
        v48 = v21;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v26);
        ++v51;
        v27 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v21);
        if ((*(unsigned int (**)(void))(v45 + 120))())
        {
          do
          {
            v28 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v27);
            v29 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v27);
            v43.n128_u64[0] = v28;
            v43.n128_u64[1] = v29;
            v30 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, &v43);
          }
          while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v27, v30) & 1) != 0);
        }
        (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v27, v21);
        v31 = 126 - 2 * __clz(v50);
        if (v50)
          v32 = v31;
        else
          v32 = 0;
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*,false>((uint64_t)v52, (__n128 *)&v52[2 * v50], v32, 1);
        if (v50)
        {
          v33 = v52;
          v34 = &v52[2 * v50];
          do
          {
            v36 = *v33;
            v35 = v33[1];
            v33 += 2;
            v23(a1, *(_QWORD *)(v36 + 8), 0, v35, v47, v46, 0);
          }
          while (v33 != v34);
        }
        if (v48)
        {
          if (v52)
            (*(void (**)(void))(*(_QWORD *)v48 + 40))();
        }
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_14;
  v13 = *(_QWORD **)a6;
  v14 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v13, v14[9], &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  v19 = re::TypeInfo::name((re::TypeInfo *)v47);
  if ((unint64_t)*v19 >> 1 == 0x134375A94D9F7110)
  {
    v20 = (char *)v19[1];
    if (v20 == "DynamicString" || !strcmp(v20, "DynamicString"))
      goto LABEL_14;
  }
  return 0;
}

BOOL re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(uint64_t a1, char *__s, uint64_t *a3)
{
  int v3;
  uint64_t v7;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), __s);
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartArray(*(_QWORD *)(a1 + 168));
    v7 = *a3;
    LOBYTE(v9) = 6;
    DWORD1(v9) = 0;
    *((_QWORD *)&v9 + 1) = __s;
    v10 = 0;
    v12 = 0;
    v13 = 0;
    v11 = v7;
    re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v9);
  }
  return v3 == 0;
}

double re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(uint64_t a1, int a2)
{
  double result;
  _OWORD v5[2];
  uint64_t v6;
  uint64_t v7;

  if (!*(_BYTE *)(a1 + 40))
  {
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartObject(*(_QWORD *)(a1 + 168));
    LOBYTE(v5[0]) = 7;
    DWORD1(v5[0]) = a2 | 0x20;
    *((_QWORD *)&v5[0] + 1) = "entry";
    v5[1] = xmmword_2260F4F20;
    v6 = 0;
    v7 = 0;
    return re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, v5);
  }
  return result;
}

void std::sort[abi:nn180100]<re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1}>(char *a1, char *a2, uint64_t (*a3)(uint64_t, uint64_t))
{
  unint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t, uint64_t);

  v3 = 126 - 2 * __clz((a2 - a1) >> 4);
  v5 = a3;
  if (a2 == a1)
    v4 = 0;
  else
    v4 = v3;
  std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(a1, a2, &v5, v4, 1);
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*,false>(unint64_t **a1, unint64_t **a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t **v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t **v18;
  unint64_t **v19;
  unint64_t *v20;
  unint64_t *v21;
  __int128 *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t *v25;
  BOOL v26;
  unint64_t *v27;
  unint64_t **v28;
  _OWORD *v29;
  unint64_t *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t *v34;
  __int128 *v35;
  _QWORD *v36;
  unint64_t **v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t **v42;
  unint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unint64_t **v52;
  unint64_t v53;
  unint64_t v54;
  BOOL v55;
  unint64_t **v56;
  unint64_t *v57;
  unint64_t *v58;
  unint64_t **v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  unint64_t **v77;
  unint64_t *v78;
  unint64_t *v79;
  unint64_t **v80;
  unint64_t *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(uint64_t a1, unint64_t **a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  unint64_t **v8;
  unint64_t **v9;
  uint64_t v10;
  int v11;
  unint64_t *v12;
  unint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t **v16;

  v4 = ((uint64_t)a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 2);
      if (**(a2 - 2) < **(_QWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32), (_OWORD *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = (unint64_t **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32));
      v9 = (unint64_t **)(a1 + 48);
      if ((unint64_t **)(a1 + 48) == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_QWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unint64_t **)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (unint64_t **)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*,false>(unsigned int **a1, unsigned int **a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int **v12;
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int **v18;
  unsigned int **v19;
  unsigned int *v20;
  unsigned int *v21;
  __int128 *v22;
  unsigned int v23;
  unsigned int *v24;
  unsigned int *v25;
  BOOL v26;
  unsigned int *v27;
  unsigned int **v28;
  _OWORD *v29;
  unsigned int *v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int *v33;
  unsigned int *v34;
  __int128 *v35;
  _DWORD *v36;
  unsigned int **v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  unsigned int **v42;
  unsigned int *v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unsigned int **v52;
  unsigned int v53;
  unsigned int v54;
  BOOL v55;
  unsigned int **v56;
  unsigned int *v57;
  unsigned int *v58;
  unsigned int **v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _DWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  unsigned int **v77;
  unsigned int *v78;
  unsigned int *v79;
  unsigned int **v80;
  unsigned int *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(uint64_t a1, unsigned int **a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  unsigned int **v8;
  unsigned int **v9;
  uint64_t v10;
  int v11;
  unsigned int *v12;
  unsigned int *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int **v16;

  v4 = ((uint64_t)a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 2);
      if (**(a2 - 2) < **(_DWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32), (_OWORD *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = (unsigned int **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32));
      v9 = (unsigned int **)(a1 + 48);
      if ((unsigned int **)(a1 + 48) == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_DWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unsigned int **)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (unsigned int **)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*,false>(unsigned __int16 **a1, unsigned __int16 **a2, uint64_t a3, char a4)
{
  unsigned __int16 **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int16 **v12;
  unsigned __int16 *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned int v17;
  unsigned __int16 **v18;
  unsigned __int16 **v19;
  unsigned __int16 *v20;
  unsigned __int16 *v21;
  unsigned __int16 **v22;
  unsigned int v23;
  unsigned __int16 *v24;
  unsigned __int16 *v25;
  BOOL v26;
  unsigned __int16 *v27;
  unsigned __int16 **v28;
  unsigned __int16 **v29;
  unsigned __int16 *v30;
  unsigned __int16 *v31;
  unsigned int v32;
  unsigned __int16 *v33;
  unsigned __int16 *v34;
  unsigned __int16 **v35;
  unsigned __int16 *v36;
  unsigned __int16 **v37;
  BOOL v39;
  uint64_t v40;
  unsigned __int16 **v41;
  unsigned __int16 **v42;
  unsigned __int16 *v43;
  unsigned __int16 *v44;
  uint64_t v45;
  unsigned int v46;
  unsigned __int16 **v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unsigned __int16 **v52;
  unsigned int v53;
  unsigned int v54;
  BOOL v55;
  unsigned __int16 **v56;
  unsigned __int16 *v57;
  unsigned __int16 *v58;
  unsigned __int16 **v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int16 **v67;
  unsigned __int16 **v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unsigned __int16 **v73;
  unsigned __int16 *v74;
  unsigned __int16 *v75;
  unsigned __int16 **v76;
  unsigned __int16 **v78;
  unsigned __int16 *v79;
  unsigned __int16 *v80;
  unsigned __int16 **v81;
  unsigned __int16 *v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(unsigned __int16 **a1, unsigned __int16 **a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned __int16 **v6;
  __int128 v7;
  unsigned __int16 **v8;
  unsigned __int16 **v9;
  uint64_t v10;
  int v11;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned __int16 **v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3, (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(unsigned __int16 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unsigned __int16 **)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*,false>(unsigned __int8 **a1, unsigned __int8 **a2, uint64_t a3, char a4)
{
  unsigned __int8 **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int8 **v12;
  unsigned __int8 *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unsigned int v17;
  unsigned __int8 **v18;
  unsigned __int8 **v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  unsigned __int8 **v22;
  unsigned int v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  BOOL v26;
  unsigned __int8 *v27;
  unsigned __int8 **v28;
  unsigned __int8 **v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  unsigned int v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  unsigned __int8 **v35;
  unsigned __int8 *v36;
  unsigned __int8 **v37;
  BOOL v39;
  uint64_t v40;
  unsigned __int8 **v41;
  unsigned __int8 **v42;
  unsigned __int8 *v43;
  unsigned __int8 *v44;
  uint64_t v45;
  unsigned int v46;
  unsigned __int8 **v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unsigned __int8 **v52;
  unsigned int v53;
  unsigned int v54;
  BOOL v55;
  unsigned __int8 **v56;
  unsigned __int8 *v57;
  unsigned __int8 *v58;
  unsigned __int8 **v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int8 **v67;
  unsigned __int8 **v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unsigned __int8 **v73;
  unsigned __int8 *v74;
  unsigned __int8 *v75;
  unsigned __int8 **v76;
  unsigned __int8 **v78;
  unsigned __int8 *v79;
  unsigned __int8 *v80;
  unsigned __int8 **v81;
  unsigned __int8 *v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(unsigned __int8 **a1, unsigned __int8 **a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned __int8 **v6;
  __int128 v7;
  unsigned __int8 **v8;
  unsigned __int8 **v9;
  uint64_t v10;
  int v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned __int8 **v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3, (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(unsigned __int8 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unsigned __int8 **)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*,false>(uint64_t **a1, __n128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t **v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t **v18;
  __n128 *v19;
  _QWORD *v20;
  _QWORD *v21;
  __int128 *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  BOOL v26;
  _QWORD *v27;
  _QWORD **v28;
  __int128 *v29;
  _QWORD *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  __int128 *v35;
  _QWORD *v36;
  __n128 *v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  __n128 *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  uint64_t **v52;
  uint64_t v53;
  uint64_t v54;
  BOOL v55;
  uint64_t **v56;
  uint64_t *v57;
  uint64_t *v58;
  uint64_t **v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  __n128 *v76;
  uint64_t *v77;
  uint64_t *v78;
  __n128 *v79;
  uint64_t *v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  _QWORD **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      if (**(_QWORD **)(a2 - 16) < **(_QWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32), (_OWORD *)(a2 - 16));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      v8 = (_QWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32));
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(_QWORD **)v9;
    if (**(_QWORD **)v9 < **v8)
    {
      v13 = *(_QWORD *)(v9 + 8);
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_QWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (_QWORD *)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (_QWORD *)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (_QWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*,false>(int **a1, __n128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int **v12;
  int *v13;
  int v14;
  uint64_t v15;
  int *v16;
  int v17;
  int **v18;
  __n128 *v19;
  _DWORD *v20;
  _DWORD *v21;
  __int128 *v22;
  int v23;
  int *v24;
  int *v25;
  BOOL v26;
  _DWORD *v27;
  _DWORD **v28;
  __int128 *v29;
  _DWORD *v30;
  int *v31;
  int v32;
  int *v33;
  int *v34;
  __int128 *v35;
  _DWORD *v36;
  __n128 *v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  __n128 *v42;
  _DWORD *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  int **v52;
  int v53;
  int v54;
  BOOL v55;
  int **v56;
  int *v57;
  int *v58;
  int **v59;
  uint64_t v60;
  int v61;
  int v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _DWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  __n128 *v76;
  int *v77;
  int *v78;
  __n128 *v79;
  int *v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  _DWORD **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  _QWORD *v16;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      if (**(_DWORD **)(a2 - 16) < **(_DWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a1 + 32), (_OWORD *)(a2 - 16));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      v8 = (_DWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a1 + 32));
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(_DWORD **)v9;
    if (**(_DWORD **)v9 < **v8)
    {
      v13 = *(_QWORD *)(v9 + 8);
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_DWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (_QWORD *)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (_QWORD *)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (_DWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*,false>(__int16 **a1, __int16 **a2, uint64_t a3, char a4)
{
  __int16 **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __int16 **v12;
  __int16 *v13;
  int v14;
  uint64_t v15;
  __int16 *v16;
  int v17;
  __int16 **v18;
  __int16 **v19;
  __int16 *v20;
  __int16 *v21;
  __int16 **v22;
  int v23;
  __int16 *v24;
  __int16 *v25;
  BOOL v26;
  __int16 *v27;
  __int16 **v28;
  __int16 **v29;
  __int16 *v30;
  __int16 *v31;
  int v32;
  __int16 *v33;
  __int16 *v34;
  __int16 **v35;
  __int16 *v36;
  __int16 **v37;
  BOOL v39;
  uint64_t v40;
  __int16 **v41;
  __int16 **v42;
  __int16 *v43;
  __int16 *v44;
  uint64_t v45;
  int v46;
  __int16 **v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  __int16 **v52;
  int v53;
  int v54;
  BOOL v55;
  __int16 **v56;
  __int16 *v57;
  __int16 *v58;
  __int16 **v59;
  uint64_t v60;
  int v61;
  int v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  __int16 **v66;
  __int16 **v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  __int16 **v72;
  __int16 *v73;
  __int16 *v74;
  __int16 **v75;
  __int16 **v76;
  __int16 *v77;
  __int16 *v78;
  __int16 **v79;
  __int16 *v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(__int16 **a1, __int16 **a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int16 **v6;
  __int128 v7;
  __int16 **v8;
  __int16 **v9;
  uint64_t v10;
  int v11;
  __int16 *v12;
  __int16 *v13;
  uint64_t v14;
  int v15;
  __int16 **v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3, (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(__int16 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (__int16 **)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*,false>(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  BOOL v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t *v44;
  int64_t v45;
  int64_t v46;
  int64_t v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  int64_t v52;
  uint64_t v53;
  int v54;
  BOOL v55;
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  BOOL v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t *v87;
  char v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t *v91;
  int64_t v92;
  uint64_t *v93;
  uint64_t *v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t *v6;
  __int128 v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t *v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (re::DynamicString::operator<(*(a2 - 2), *a1))
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (re::DynamicString::operator<(*v9, *v8))
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        v15 = (char *)a1 + v14;
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v14 -= 16;
        if ((re::DynamicString::operator<(v12, *((_QWORD *)v15 + 2)) & 1) == 0)
        {
          v16 = (uint64_t *)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*,false>(uint64_t a1, __n128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __int128 *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  __int128 *v19;
  _QWORD *v20;
  _QWORD *v21;
  __int128 *v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  BOOL v26;
  _QWORD *v27;
  unint64_t v28;
  __int128 *v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  __int128 *v35;
  _QWORD *v36;
  __n128 *v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  __n128 *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unint64_t **v52;
  unint64_t v53;
  unint64_t v54;
  BOOL v55;
  unint64_t **v56;
  unint64_t *v57;
  unint64_t *v58;
  unint64_t **v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  uint64_t v77;
  _QWORD *v78;
  uint64_t v79;
  uint64_t v80;
  _QWORD *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  _QWORD **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _QWORD *v16;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      if (**(_QWORD **)(a2 - 16) >> 1 < **(_QWORD **)a1 >> 1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (_QWORD **)(a1 + 16), (_QWORD **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (__n128 *)(a1 + 16), (__n128 *)(a1 + 32), (__n128 *)(a2 - 16));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (__n128 *)(a1 + 16), (__n128 *)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      v8 = (_QWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (_QWORD **)(a1 + 16), (_QWORD **)(a1 + 32));
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(_QWORD **)v9;
    if (**(_QWORD **)v9 >> 1 < **v8 >> 1)
    {
      v13 = *(_QWORD *)(v9 + 8);
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_QWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >> 1 >= v15 >> 1)
        {
          v16 = (_QWORD *)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (_QWORD *)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (_QWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(char *a1, char *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  BOOL v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  char *v36;
  uint64_t v37;
  char *v38;
  BOOL v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  char *v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  char *v73;
  uint64_t v74;
  uint64_t *v75;
  BOOL v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  char *v81;
  char v82;
  char *v83;
  unint64_t v84;
  char *v85;
  char *v86;
  char *v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  int64_t v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(char *a1, char *a2, uint64_t (**a3)(uint64_t, _QWORD))
{
  uint64_t v6;
  _BOOL8 result;
  char *v8;
  __int128 v9;
  char *v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  char *v17;
  __int128 v18;

  v6 = (a2 - a1) >> 4;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v8 = a2 - 16;
      if ((*a3)(*((_QWORD *)a2 - 2), *(_QWORD *)a1))
      {
        v9 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v8;
        *(_OWORD *)v8 = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a2 - 2, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, (_QWORD *)a2 - 2, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, (_QWORD *)a1 + 6, (_QWORD *)a2 - 2, a3);
      return 1;
    default:
      v10 = a1 + 32;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, a3);
      v11 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(*(_QWORD *)v11, *(_QWORD *)v10))
    {
      v18 = *(_OWORD *)v11;
      v14 = *(_QWORD *)v11;
      v15 = v12;
      while (1)
      {
        *(_OWORD *)&a1[v15 + 48] = *(_OWORD *)&a1[v15 + 32];
        if (v15 == -32)
          break;
        v16 = (*a3)(v14, *(_QWORD *)&a1[v15 + 16]);
        v15 -= 16;
        if ((v16 & 1) == 0)
        {
          v17 = &a1[v15 + 48];
          goto LABEL_12;
        }
      }
      v17 = a1;
LABEL_12:
      *(_OWORD *)v17 = v18;
      if (++v13 == 8)
        return v11 + 16 == a2;
    }
    v10 = v11;
    v12 += 16;
    v11 += 16;
    if (v11 == a2)
      return 1;
  }
}

BOOL re::serializeDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *__s, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t *v17;
  char *v18;
  _BOOL8 result;
  _anonymous_namespace_ *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  if (this == a6)
    goto LABEL_14;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_14;
  }
  v17 = re::TypeInfo::name(a6);
  if ((unint64_t)*v17 >> 1 != 0x22C6ED80D0CLL
    || (v18 = (char *)v17[1], v18 != "StringID") && strcmp(v18, "StringID"))
  {
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v24 = 0;
    result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, __s, &v24);
    if (!(_DWORD)result)
      return result;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_27;
  }
  v21 = *(_QWORD *)(a4 + 8);
  if ((v21 & 1) != 0)
    v22 = v21 >> 1;
  else
    v22 = v21 >> 1;
  v24 = v22;
  result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, __s, &v24);
  if ((_DWORD)result)
  {
    if (v22)
    {
      if ((*(_BYTE *)(a4 + 8) & 1) != 0)
        v23 = *(_QWORD *)(a4 + 16);
      else
        v23 = a4 + 9;
    }
    v20 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_27:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  const re::TypeInfo *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t i;
  uint64_t v29;
  uint64_t v30;
  re *v31;
  uint64_t v32;
  NSObject *v33;
  uint64_t v34;
  re::internal *v35;
  _BYTE v36[32];
  _BYTE v37[32];
  _QWORD *v38[2];
  uint64_t v39;
  _QWORD *v40[2];
  uint64_t v41;
  uint64_t v42[4];
  unint64_t v43;
  uint64_t v44[5];
  _BYTE v45[8];
  uint64_t v46;
  char v47;
  uint64_t *v48;
  _BYTE v49[8];
  uint64_t v50;
  char v51;
  uint64_t *v52;
  uint8_t buf[4];
  uint64_t v54;
  __int16 v55;
  uint64_t v56;
  uint64_t v57;

  v57 = *MEMORY[0x24BDAC8D0];
  re::TypeRegistry::typeInfo((_QWORD *)*a3, *(_QWORD *)(a3[2] + 72), v49);
  re::TypeRegistry::typeInfo((_QWORD *)*a4, *(_QWORD *)(a4[2] + 72), v45);
  if (v45[0])
  {
    if (!v49[0])
    {
      v11 = re::TypeInfo::name((re::TypeInfo *)&v46)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
    }
    if (v50 == v46)
    {
      v18 = *v52;
      v19 = *v48;
      if ((unsigned __int16)*v52 == (unsigned __int16)*v48)
      {
        v21 = WORD1(v18) == WORD1(v19);
        v20 = (v19 ^ v18) & 0xFFFFFF00000000;
        v21 = v21 && v20 == 0;
        if (v21)
          goto LABEL_5;
      }
    }
    else if (re::areSameTranslatedVersion((re *)&v50, (const re::TypeInfo *)&v46, v10))
    {
LABEL_5:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((_BYTE *)a1, a2, &v50, a5);
      goto LABEL_15;
    }
    if (v51 == v47)
    {
      re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, &v50, &v46, a5);
    }
    else
    {
      v22 = re::TypeInfo::name((re::TypeInfo *)&v50)[1];
      re::TypeInfo::name((re::TypeInfo *)&v46);
    }
  }
LABEL_15:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v44, *a3, a3[2]);
  result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v42, *a4, a4[2]);
  if (v43)
  {
    for (i = 0; i < v43; ++i)
    {
      if (*(_BYTE *)(a1 + 64))
        break;
      result = (uint64_t)re::TypeMemberCollection::operator[](v42, i, (uint64_t)v40);
      if (*(_BYTE *)(v41 + 28))
      {
        v29 = *(_QWORD *)(v41 + 16);
        if (strlen((const char *)v29) >= 3 && *(_BYTE *)v29 == 109)
          v29 += 2 * (*(_BYTE *)(v29 + 1) == 95);
        v30 = *(unsigned int *)(v41 + 32);
        v31 = *(re **)(*a4 + 856);
        if (!v31
          || (v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v40),
              (_DWORD)v31 == -1))
        {
          v33 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
          {
            v34 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            v54 = v34;
            v55 = 2080;
            v56 = v29;
            _os_log_impl(&dword_224FE9000, v33, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);
          }
          v35 = *(re::internal **)(a1 + 272);
          re::TypeRegistry::typeInfo(v40[0], *(_QWORD *)v41, buf);
          re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v54 + 4);
          result = re::internal::translateType(v35, (const re::TypeRegistry *)v38, (uint64_t)buf);
          if (!*(_BYTE *)(a1 + 64))
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint8_t *, uint8_t *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
        }
        else
        {
          re::TypeMemberCollection::operator[](v44, (int)v31, (uint64_t)v38);
          v32 = *(unsigned int *)(v39 + 24);
          re::TypeRegistry::typeInfo(v38[0], *(_QWORD *)v39, buf);
          re::TypeInfo::TypeInfo((uint64_t)v37, (uint64_t)&v54 + 4);
          re::TypeRegistry::typeInfo(v40[0], *(_QWORD *)v41, buf);
          result = re::TypeInfo::TypeInfo((uint64_t)v36, (uint64_t)&v54 + 4);
          if (!*(_BYTE *)(a1 + 64))
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, a2 + v32, v37, v36, a5);
        }
      }
    }
  }
  return result;
}

BOOL re::serializeBool<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned __int8 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned __int8 *)&v19;
  else
    v13 = a4;
}

BOOL re::serializeChar<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, char *a4, re *this, re::TypeInfo *a6, int a7)
{
  char *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = &v19;
  else
    v13 = a4;
}

BOOL re::serializeI8<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, char *a4, re *this, re::TypeInfo *a6, int a7)
{
  char *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = &v19;
  else
    v13 = a4;
}

BOOL re::serializeI16<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, __int16 *a4, re *this, re::TypeInfo *a6, int a7)
{
  __int16 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  __int16 v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = &v19;
  else
    v13 = a4;
}

BOOL re::serializeI32<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned int *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned int *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned int *)&v19;
  else
    v13 = a4;
}

BOOL re::serializeI64<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unint64_t *a4, re *this, re::TypeInfo *a6, int a7)
{
  unint64_t *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unint64_t *)&v19;
  else
    v13 = a4;
}

BOOL re::serializeU8<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned __int8 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned __int8 *)&v19;
  else
    v13 = a4;
}

BOOL re::serializeU16<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned __int16 *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned __int16 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  __int16 v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned __int16 *)&v19;
  else
    v13 = a4;
}

BOOL re::serializeU32<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned int *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned int *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned int *)&v19;
  else
    v13 = a4;
}

BOOL re::serializeU64<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, rapidjson::internal **a4, re *this, re::TypeInfo *a6, int a7)
{
  rapidjson::internal **v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (rapidjson::internal **)&v19;
  else
    v13 = a4;
}

BOOL re::serializeFloat<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, float *a4, re *this, re::TypeInfo *a6, int a7)
{
  float *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (float *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, v13);
}

BOOL re::serializeDouble<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, double *a4, re *this, re::TypeInfo *a6, int a7)
{
  double *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (double *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, v13);
}

uint64_t re::serializeCString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *__s, const re::TypeInfo *a3, const char **a4, re *this, re::TypeInfo *a6, int a7)
{
  int v13;
  uint64_t result;
  _anonymous_namespace_ *v15;
  const char *v16;
  size_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  int v23;

  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_18:
      return 0;
    }
    v18 = **((_QWORD **)this + 2);
    v19 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v18 != (unsigned __int16)v19)
      goto LABEL_18;
    v21 = WORD1(v18) == WORD1(v19);
    v20 = (v19 ^ v18) & 0xFFFFFF00000000;
    v21 = v21 && v20 == 0;
    if (!v21)
      goto LABEL_18;
  }
LABEL_4:
  if (a7)
  {
    LODWORD(v22) = 0;
    v13 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, __s, (int *)&v22);
    result = 0;
    if (!v13)
      return result;
    v15 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_22;
  }
  v16 = *a4;
  v23 = 2 * (*a4 != 0);
  result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, __s, &v23);
  if (!(_DWORD)result)
    return result;
  if (v16)
  {
    if (*a4)
    {
      v17 = strlen(*a4);
      v22 = v17;
      if (re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, __s, (uint64_t *)&v22))
      {
        if (v17)
        goto LABEL_20;
      }
    }
    else
    {
      v22 = 0;
      if (re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, __s, (uint64_t *)&v22))
      {
LABEL_20:
      }
    }
  }
  v15 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_22:
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *__s, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t *v17;
  char *v18;
  _BOOL8 result;
  _anonymous_namespace_ *v20;
  size_t v21;
  size_t v22;

  if (this == a6)
    goto LABEL_14;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_14;
  }
  v17 = re::TypeInfo::name(a6);
  if ((unint64_t)*v17 >> 1 != 0x134375A94D9F7110
    || (v18 = (char *)v17[1], v18 != "DynamicString") && strcmp(v18, "DynamicString"))
  {
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v22 = 0;
    result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, __s, (uint64_t *)&v22);
    if (!(_DWORD)result)
      return result;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    v21 = strlen(*(const char **)(a4 + 8));
    v22 = v21;
    result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, __s, (uint64_t *)&v22);
    if (!(_DWORD)result)
      return result;
    if (v21)
    v20 = (_anonymous_namespace_ *)(a1 + 24);
  }
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *__s, const re::TypeInfo *a3, uint64_t a4, unint64_t **this, unint64_t **a6, int a7)
{
  _BOOL8 result;
  unint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34[2];

  if (this != a6)
  {
    if (*this != *a6)
    {
      if (re::areSameTranslatedVersion((re *)this, (const re::TypeInfo *)a6, a3))
        goto LABEL_4;
LABEL_26:
      return 0;
    }
    v21 = *this[2];
    v22 = *a6[2];
    if ((unsigned __int16)v21 != (unsigned __int16)v22)
      goto LABEL_26;
    v24 = WORD1(v21) == WORD1(v22);
    v23 = (v22 ^ v21) & 0xFFFFFF00000000;
    v24 = v24 && v23 == 0;
    if (!v24)
      goto LABEL_26;
  }
LABEL_4:
  if (!a7)
  {
    v14 = *this[2];
    v30 = (uint64_t)*this;
    v31 = v14;
    LODWORD(v32) = -1;
    v34[0] = 0x258C98EAAF29A10ALL;
    v34[1] = (uint64_t)"CallbackSerializerAttribute";
    v15 = (uint64_t *)re::TypeAttributeCollection::operator[](&v30, v34);
    re::StringID::destroyString((re::StringID *)v34);
    v16 = *v15;
    v17 = *(_QWORD *)(a1 + 264);
    v18 = *(_QWORD *)(a1 + 56);
    v32 = 0;
    v33 = 0;
    v30 = v18;
    v31 = 0;
    re::DynamicString::setCapacity(&v30, 0);
    if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v16 + 72))(v17, v16, a4, &v30) & 1) != 0)
    {
      if ((v31 & 1) != 0)
        v19 = v31 >> 1;
      else
        v19 = v31 >> 1;
      v34[0] = v19;
      if (re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, __s, v34))
      {
        if (v19)
        {
          if ((v31 & 1) != 0)
            v20 = v32;
          else
            v20 = (char *)&v31 + 1;
        }
        if (v30)
        {
          if ((v31 & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v30 + 40))();
        }
        return *(_BYTE *)(a1 + 64) == 0;
      }
    }
    else
    {
      re::TypeInfo::name((re::TypeInfo *)this);
    }
    if (v30 && (v31 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v30 + 40))();
    return 0;
  }
  v30 = 0;
  result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, __s, &v30);
  if ((_DWORD)result)
  {
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(uint64_t a1, char *__s, int *a3)
{
  int v3;
  int v7;
  char *v8;
  uint64_t result;
  __int128 v10;
  uint64_t v11;
  _BOOL8 v12;
  uint64_t v13;
  uint64_t v14;

  v3 = *(unsigned __int8 *)(a1 + 40);
  if (*(_BYTE *)(a1 + 40))
    return v3 == 0;
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), __s);
  v7 = *a3;
  if ((*a3 - 1) < 2)
  {
LABEL_7:
    LOBYTE(v10) = 9;
    DWORD1(v10) = 0;
    *((_QWORD *)&v10 + 1) = __s;
    v11 = 0;
    v13 = 0;
    v14 = 0;
    v12 = v7 != 0;
    re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v10);
    return v3 == 0;
  }
  if (!v7)
  {
    v8 = *(char **)(a1 + 168);
    rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::PrettyPrefix(v8);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteNull((uint64_t *)v8);
    v7 = *a3;
    goto LABEL_7;
  }
  re::internal::assertLog((re::internal *)4, (uint64_t)__s, "assertion failure: '%s' (%s:line %i) Unexpected PointerEncoding.", "!\"Unreachable code\"", "beginPointer", 1054);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString(_BYTE *a1, char *__s, const re::TypeInfo *a3, const char **a4, re *this, re::TypeInfo *a6)
{
  int *v11;
  int v12;
  _anonymous_namespace_ *v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  int v22;
  __int128 v23;
  int v24;
  const char *v25;

  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_14:
      return 0;
    }
    v15 = **((_QWORD **)this + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 != (unsigned __int16)v16)
      goto LABEL_14;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_14;
  }
LABEL_4:
  if (!*a4)
  {
    LODWORD(v25) = 0;
    v13 = (_anonymous_namespace_ *)(a1 + 24);
    v22 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((uint64_t)(a1 + 24), __s, (int *)&v25);
    result = 0;
    if (!v22)
      return result;
    goto LABEL_22;
  }
  if (!a1[336]
    || (v25 = *a4,
        (v11 = (int *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(a1 + 344), (uint64_t *)&v25)) == 0))
  {
    v24 = 2;
    if ((re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((uint64_t)(a1 + 24), __s, &v24) & 1) != 0)
    {
      v19 = (const char *)strlen(*a4);
      v25 = v19;
      result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((uint64_t)(a1 + 24), __s, (uint64_t *)&v25);
      if (!(_DWORD)result)
        return result;
      if (v19)
      v20 = *a4;
      v21 = **((_QWORD **)this + 2);
      *(_QWORD *)&v23 = *(_QWORD *)this;
      *((_QWORD *)&v23 + 1) = v21;
      re::internal::SharedObjectGraph::addObject((uint64_t)(a1 + 336), (uint64_t)v20, &v23);
      return a1[64] == 0;
    }
    return 0;
  }
  v12 = *v11;
  v24 = 1;
  LODWORD(v25) = v12;
  v13 = (_anonymous_namespace_ *)(a1 + 24);
  result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((uint64_t)(a1 + 24), __s, &v24);
  if (!(_DWORD)result)
    return result;
  re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference((uint64_t)(a1 + 24), (unsigned int *)&v25);
LABEL_22:
  return a1[64] == 0;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer(uint64_t a1, char *a2, int a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  const re::TypeInfo *v13;
  _BOOL4 isPointerToPolymorphicType;
  int v15;
  char *v16;
  _DWORD *v17;
  _anonymous_namespace_ *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t *v32;
  uint64_t *v33;
  __int128 v34;
  int v35;
  _BYTE v36[32];
  __int128 v37;
  re::TypeRegistry *v38[4];
  _QWORD v39[4];
  char *v40;
  _BYTE v41[32];

  isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6)
    goto LABEL_4;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v28 = **((_QWORD **)this + 2);
    v29 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v28 == (unsigned __int16)v29)
    {
      v31 = WORD1(v28) == WORD1(v29);
      v30 = (v29 ^ v28) & 0xFFFFFF00000000;
      v31 = v31 && v30 == 0;
      if (v31)
        goto LABEL_4;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v13))
  {
LABEL_4:
    v15 = 0;
    goto LABEL_5;
  }
  if (*((_BYTE *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (v32 = re::TypeInfo::name(this), v33 = re::TypeInfo::name(a6), !re::StringID::operator==(v32, v33))))
  {
    return 0;
  }
  v15 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v40);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)v41);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v40);
  re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)v41);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    v20 = *(_QWORD *)v39[2];
    *(_QWORD *)&v37 = v39[0];
    *((_QWORD *)&v37 + 1) = v20;
    if (v39[0])
      goto LABEL_8;
    goto LABEL_15;
  }
  re::internal::actualType(a4, (void **)this, &v37);
  if (!(_QWORD)v37)
  {
LABEL_15:
    v21 = re::TypeInfo::name(this);
    return 0;
  }
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, (re **)&v37, &v40);
  re::TypeInfo::TypeInfo((uint64_t)v36, (uint64_t)v41);
  if ((a7 & 1) != 0 || (v16 = *a4) == 0)
  {
    LODWORD(v40) = 0;
    v18 = (_anonymous_namespace_ *)(a1 + 24);
    v27 = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, (int *)&v40);
    result = 0;
    if (v27)
      goto LABEL_17;
    return result;
  }
  if (!*(_BYTE *)(a1 + 336))
  {
LABEL_33:
    v34 = v37;
    re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), (uint64_t)v16, &v34);
    LODWORD(v40) = 2;
    result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, (int *)&v40);
    if ((_DWORD)result)
    {
      if (isPointerToPolymorphicType)
      {
        re::internal::serializePolymorphicObject<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((_BYTE *)a1, a2, (uint64_t)*a4, (re::TypeInfo *)v36, v38, v15);
      }
      else if (!*(_BYTE *)(a1 + 64))
      {
        (*(void (**)(uint64_t, char *, _QWORD, char *, _QWORD *, re::TypeRegistry **, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, 0, *a4, v39, v38, 0);
      }
      if (*(_BYTE *)(a1 + 336))
      {
        --*(_QWORD *)(a1 + 488);
        ++*(_DWORD *)(a1 + 496);
      }
      return *(_BYTE *)(a1 + 64) == 0;
    }
    return result;
  }
  v40 = *a4;
  v17 = (_DWORD *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 344, (uint64_t *)&v40);
  if (!v17)
  {
    v16 = *a4;
    goto LABEL_33;
  }
  LODWORD(v40) = *v17;
  v35 = 1;
  v18 = (_anonymous_namespace_ *)(a1 + 24);
  result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v35);
  if ((_DWORD)result)
  {
    re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference(a1 + 24, (unsigned int *)&v40);
LABEL_17:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference(uint64_t result, unsigned int *a2)
{
  _anonymous_namespace_ *v3;

  if (!*(_BYTE *)(result + 40))
  {
    v3 = (_anonymous_namespace_ *)result;
    result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(result, 0, 0);
    if ((_DWORD)result)
    {
    }
  }
  return result;
}

uint64_t re::internal::serializePolymorphicObject<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(_BYTE *a1, char *a2, uint64_t a3, re::TypeInfo *a4, re::TypeRegistry **a5, int a6)
{
  re::TypeRegistry *v12;
  uint64_t *v13;
  uint64_t result;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE v22[8];
  uint64_t v23;
  _BYTE v24[32];

  re::TypeInfo::TypeInfo((uint64_t)v24, (uint64_t)a4);
  if (a6)
  {
    v12 = *a5;
    v13 = re::TypeInfo::name(a4);
    re::TypeRegistry::typeInfo(v12, (const re::StringID *)v13, v22);
    if (!v22[0])
    {
      v16 = re::TypeInfo::name(a4);
    }
    re::TypeInfo::operator=((uint64_t)v24, (uint64_t)&v23);
  }
  result = re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((uint64_t)(a1 + 24), a2, 0);
  if ((_DWORD)result)
  {
    v15 = re::TypeInfo::polymorphicObjectName((re::TypeInfo *)v24);
    if (!a1[64])
      (*(void (**)(_BYTE *, uint64_t, _QWORD, uint64_t, re::TypeInfo *, _BYTE *, _QWORD))(*(_QWORD *)a1 + 72))(a1, v15[1], 0, a3, a4, v24, 0);
  }
  return result;
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  double v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_24ED88B08;
  if (*(_QWORD *)(a1 + 272))
  {
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(a1 + 288);
    *(_QWORD *)(a1 + 272) = 0;
  }
  v2 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)(a1 + 288));
  v3 = *(_QWORD *)(a1 + 216);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 248))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v3 + 40))(v3, v2);
    *(_QWORD *)(a1 + 248) = 0;
    *(_QWORD *)(a1 + 224) = 0;
    *(_QWORD *)(a1 + 232) = 0;
    *(_QWORD *)(a1 + 216) = 0;
    ++*(_DWORD *)(a1 + 240);
  }
  v4 = *(_QWORD *)(a1 + 120);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 152))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 152) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = 0;
    *(_QWORD *)(a1 + 120) = 0;
    ++*(_DWORD *)(a1 + 144);
  }
  if (*(_BYTE *)(a1 + 64))
  {
    v5 = *(_QWORD *)(a1 + 88);
    if (v5)
    {
      if ((*(_BYTE *)(a1 + 96) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *(_QWORD *)(a1 + 104));
      *(_OWORD *)(a1 + 88) = 0u;
      *(_OWORD *)(a1 + 104) = 0u;
    }
  }
  re::StringID::destroyString((re::StringID *)(a1 + 8));
  return a1;
}

void re::SerializerV1<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED88AA0;
  v2 = *(_QWORD *)(a1 + 472);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 504))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 480) = 0;
    *(_QWORD *)(a1 + 488) = 0;
    *(_QWORD *)(a1 + 472) = 0;
    ++*(_DWORD *)(a1 + 496);
  }
  v3 = *(_QWORD *)(a1 + 432);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 464))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 464) = 0;
    *(_QWORD *)(a1 + 440) = 0;
    *(_QWORD *)(a1 + 448) = 0;
    *(_QWORD *)(a1 + 432) = 0;
    ++*(_DWORD *)(a1 + 456);
  }
  v4 = *(_QWORD *)(a1 + 392);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 344));
  re::Serializer<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::SerializerV1<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::trackObject(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v4;

  v4 = *a3;
  return re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), a2, &v4);
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::untrackObject(uint64_t result)
{
  if (*(_BYTE *)(result + 336))
  {
    --*(_QWORD *)(result + 488);
    ++*(_DWORD *)(result + 496);
  }
  return result;
}

void re::SerializerV1<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doOpen(uint64_t a1)
{
  *(_BYTE *)(a1 + 337) = 1;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 344);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
  *(_QWORD *)(a1 + 448) = 0;
  ++*(_DWORD *)(a1 + 456);
  *(_QWORD *)(a1 + 488) = 0;
  ++*(_DWORD *)(a1 + 496);
}

void re::SerializerV1<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doClose(uint64_t a1)
{
  re::internal::SharedObjectGraph::markAndSweep((re::internal::SharedObjectGraph *)(a1 + 336), *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 344);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
  *(_QWORD *)(a1 + 448) = 0;
  ++*(_DWORD *)(a1 + 456);
  *(_QWORD *)(a1 + 488) = 0;
  ++*(_DWORD *)(a1 + 496);
}

void re::Serializer<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doRegisterSerializeFuncs(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 *v7;
  __int128 v8;
  __int128 v9;
  _QWORD v10[2];
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;

  v11 = 6059476;
  v12 = "BOOL";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeBool<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6104748;
  v12 = "char";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeChar<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x172E117BCLL;
  v12 = "int8_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI8<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93A4A92;
  v12 = "int16_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI16<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93BFE06;
  v12 = "int32_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI32<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93EC744;
  v12 = "int64_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6655224;
  v12 = "long";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x31CD534126;
  v12 = "uint8_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU8<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0D4E68;
  v12 = "uint16_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU16<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0F01DCLL;
  v12 = "uint32_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU32<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD11CB1ALL;
  v12 = "uint64_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x1947BDF6CLL;
  v12 = "size_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 195052728;
  v12 = "float";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeFloat<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x161EEF7A2;
  v12 = "double";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDouble<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 189247272;
  v12 = "char*";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeCString<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2686EB529B3EE220;
  v12 = "DynamicString";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDynamicString<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x458DDB01A18;
  v12 = "StringID";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeStringID<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v2 = *(_QWORD *)(a1 + 272);
  v11 = 0x258C98EAAF29A10ALL;
  v12 = "CallbackSerializerAttribute";
  v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v11);
  if (v3)
  {
    v4 = *v3;
    re::StringID::destroyString((re::StringID *)&v11);
    if (v2)
    {
      v5 = *(_QWORD *)(a1 + 272);
      v10[0] = v2;
      v10[1] = v4;
      re::TypeRegistry::attributesByAttributeType(v5, (uint64_t)v10, (uint64_t)&v11);
      if (v13)
      {
        v6 = 48 * v13;
        v7 = (__int128 *)(v14 + 16);
        do
        {
          v8 = *v7;
          v7 += 3;
          v9 = v8;
          re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, (uint64_t)&v9, (uint64_t)re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
          v6 -= 48;
        }
        while (v6);
      }
      if (v11)
      {
        if (v14)
          (*(void (**)(void))(*(_QWORD *)v11 + 40))();
      }
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v11);
  }
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t result;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;

  v14 = (_BYTE *)(a1 + 336);
  v15 = *(_QWORD *)(a1 + 488);
  if (!v15)
  {
    if ((_DWORD)a7)
      v16 = 0;
    else
      v16 = a4;
    v17 = **((_QWORD **)a5 + 2);
    *(_QWORD *)&v26 = *(_QWORD *)a5;
    *((_QWORD *)&v26 + 1) = v17;
    re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), v16, &v26);
  }
  v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v18)
  {
    result = v18(a1, a2, a3, a4, a5, a6, a7);
    if (!v15)
    {
      if (*v14)
      {
        --*(_QWORD *)(a1 + 488);
        ++*(_DWORD *)(a1 + 496);
      }
    }
  }
  else
  {
    v20 = re::TypeInfo::name(a5);
    return 0;
  }
  return result;
}

BOOL (*re::SerializerV1<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, re::TypeInfo *this))(uint64_t a1, char *a2, int a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, int a7)
{
  uint64_t *v4;
  uint64_t v5;
  char *v6;
  unsigned int v7;
  BOOL (*result)(uint64_t, char *, int, char **, re::TypeInfo *, const re::TypeInfo *, int);
  uint64_t v9;

  v4 = re::TypeInfo::name(this);
  if ((unint64_t)*v4 >> 1 == 94623636)
  {
    v6 = (char *)v4[1];
    if (v6 == "char*" || !strcmp(v6, "char*"))
      return (BOOL (*)(uint64_t, char *, int, char **, re::TypeInfo *, const re::TypeInfo *, int))re::SerializerV1<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString;
  }
  if (*((_BYTE *)this + 12) == 9)
  {
    v7 = *(unsigned __int8 *)(*((_QWORD *)this + 2) + 80);
    if (v7 >= 2)
    {
      if (v7 == 2)
      {
        re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) External references are not supported by the SerializerV1.", "!\"Unreachable code\"", "doResolveSerializeFunc", 82);
        _os_crash();
        __break(1u);
      }
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Invalid PointerSharing type.", "!\"Unreachable code\"", "doResolveSerializeFunc", 84);
      result = (BOOL (*)(uint64_t, char *, int, char **, re::TypeInfo *, const re::TypeInfo *, int))_os_crash();
      __break(1u);
    }
    else
    {
      return re::SerializerV1<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer;
    }
  }
  else if (*(_QWORD *)this == *(_QWORD *)(a1 + 272)
         && (v9 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, **((_QWORD **)this + 2) | 0xFFFFFFFF00000000)) != 0)
  {
    return *(BOOL (**)(uint64_t, char *, int, char **, re::TypeInfo *, const re::TypeInfo *, int))v9;
  }
  else
  {
    return (BOOL (*)(uint64_t, char *, int, char **, re::TypeInfo *, const re::TypeInfo *, int))re::serializeType<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  }
  return result;
}

void re::Serializer<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  re::Serializer<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t (*v14)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v14)
    return v14(a1, a2, a3, a4, a5, a6, a7);
  v16 = re::TypeInfo::name(a5);
  return 0;
}

uint64_t (*re::Serializer<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t *a4, re *this, re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v3;

  if (*(_QWORD *)a2 == *(_QWORD *)(a1 + 272)
    && (v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, **(_QWORD **)(a2 + 16) | 0xFFFFFFFF00000000)) != 0)
  {
    return *(uint64_t (**)(uint64_t, char *, const re::TypeInfo *, uint64_t *, re *, re::TypeInfo *, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  }
}

uint64_t re::serializeType<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t *a4, re *this, re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t *v23;
  unint64_t v24;
  uint64_t result;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  int v29;
  const char *v30;
  int v31;
  int v32;
  int v33;
  const re::TypeInfo *v34;
  uint64_t *v35;
  int v36;
  unint64_t v37;
  char *v38;
  BOOL (*v39)(uint64_t, char *, const re::TypeInfo *, uint64_t, re *, re::TypeInfo *, int);
  _anonymous_namespace_ *v40;
  uint64_t *v41;
  const re::TypeInfo *v42;
  char *v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  const char *v48;
  int v49;
  uint64_t v50;
  const re::TypeInfo *v51;
  int v52;
  uint64_t v53;
  uint64_t *v54;
  char *v55;
  const re::TypeInfo *v56;
  re *v57;
  re::TypeInfo *v58;
  uint64_t v59;
  re::UnionAccessor *v60;
  uint64_t *v61;
  void **Instance;
  uint64_t v63;
  unint64_t v64;
  char *v65;
  re::TypeRegistry *v66;
  re *v67;
  re::TypeInfo *v68;
  uint64_t v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v75;
  uint64_t v76;
  uint64_t *v77;
  uint64_t *v78;
  BOOL v79;
  uint64_t v80;
  uint64_t v81;
  re::internal *v82;
  _anonymous_namespace_ *v83;
  double v84;
  void **v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v91;
  uint64_t v92;
  int v93;
  re::internal *v94;
  uint64_t v95;
  void (*v96)(uint64_t, _QWORD, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t);
  uint64_t v97;
  int v98;
  uint64_t v99;
  int v100;
  uint64_t v101;
  void (*v102)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD);
  uint64_t v103;
  int v104;
  int v105;
  _anonymous_namespace_ *v106;
  unint64_t v107;
  unsigned int v108;
  uint64_t v109;
  uint64_t v110;
  re::internal *v111;
  uint64_t v112;
  void (*v113)(uint64_t, _QWORD, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t);
  unsigned int v114;
  uint64_t i;
  uint64_t v116;
  void (*v117)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD);
  _QWORD *v118;
  unsigned int v119;
  _QWORD *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  re::Allocator *v125;
  void *v126;
  unint64_t *v127;
  void **v128;
  char *v129;
  const char *v130;
  char *v131;
  uint64_t v132;
  uint64_t v133;
  re::internal *v134;
  re::internal *v135;
  uint64_t v136;
  void (*v137)(uint64_t, const char *, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t);
  uint64_t v138;
  void (*v139)(uint64_t, const char *, _QWORD, _QWORD, uint64_t *, uint64_t *, uint64_t);
  _anonymous_namespace_ *v140;
  uint64_t k;
  uint64_t v142;
  void (*v143)(uint64_t, const char *, _QWORD, void **, unint64_t *, _BYTE *, _QWORD);
  uint64_t v144;
  void (*v145)(uint64_t, const char *, _QWORD, uint64_t, uint64_t *, _QWORD **, _QWORD);
  uint64_t v146;
  void (*v147)(uint64_t *, _BYTE *, uint64_t);
  uint64_t v148;
  void **v149;
  uint64_t v150;
  unint64_t *v151;
  uint64_t v152;
  const char *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  BOOL v157;
  unint64_t v158;
  uint64_t v159;
  BOOL v160;
  char v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  char *v167;
  const re::TypeInfo *v168;
  uint64_t *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  char *v178;
  const re::StringID *v179;
  void (*v180)(void);
  char *v181;
  uint64_t v182;
  void (*v183)(uint64_t *, _BYTE *, uint64_t, _QWORD *);
  _QWORD *j;
  uint64_t v185;
  uint64_t (*v186)(uint64_t *, _QWORD);
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  re::TypeInfo *v190;
  uint64_t v191;
  char v192;
  unsigned __int8 *v193;
  int v194;
  unsigned int EnumConstantIndex;
  re *v196;
  uint64_t v197;
  unint64_t v198;
  unint64_t v199;
  const void *v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  BOOL v209;
  char v210;
  uint64_t v211;
  unint64_t v212;
  uint64_t v213;
  _BYTE *v214;
  void **v215;
  NSObject *v216;
  uint64_t v217;
  re::internal::TypeTranslationTable *v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  unint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  _BYTE *v231;
  uint64_t v232;
  uint64_t *v233[4];
  _QWORD v234[2];
  unint64_t v235;
  unint64_t v236;
  uint64_t v237;
  uint64_t v238;
  _QWORD *v239[2];
  uint64_t v240;
  _QWORD *v241[2];
  uint64_t v242;
  _BYTE v243[32];
  uint64_t Tag;
  const char *v245;
  uint64_t v246;
  _BYTE buf[24];
  uint64_t v248;
  char v249;
  _BYTE v250[7];
  uint64_t v251;
  uint64_t v252;

  v252 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_18;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        goto LABEL_18;
    }
LABEL_10:
    if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12))
      goto LABEL_292;
    v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
    if (v19)
      v20 = *(_DWORD *)(v19 + 16);
    else
      v20 = -1;
    v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
    if (v21)
      v22 = *(_DWORD *)(v21 + 16);
    else
      v22 = -1;
    if (v20 != v22)
    {
      v26 = re::TypeInfo::name(this);
      v27 = re::TypeInfo::name(a6);
      if (re::StringID::operator==(v26, v27))
      {
        v28 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
        if (v28)
          v29 = *(_DWORD *)(v28 + 16);
        else
          v29 = -1;
        re::TypeInfo::atVersion(this, v29, (unsigned __int8 *)&v236);
        if ((_BYTE)v236)
        {
          if ((a7 & 1) != 0)
            Instance = 0;
          else
            Instance = re::TypeInfo::createInstance((re::TypeInfo *)&v237, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
          if (*(_BYTE *)(a1 + 64)
            || ((*(void (**)(uint64_t, char *, const re::TypeInfo *, void **, uint64_t *, re::TypeInfo *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, a3, Instance, &v237, a6, a7), *(_BYTE *)(a1 + 64)))
          {
            if (!Instance)
              return 0;
            v125 = *(re::Allocator **)(a1 + 48);
            v126 = *(void **)(a1 + 264);
            v127 = (unint64_t *)&v237;
            v128 = Instance;
LABEL_187:
            re::TypeInfo::releaseInstance((re::TypeInfo *)v127, v128, v125, v126);
            return 0;
          }
          if ((a7 & 1) == 0)
          {
            re::TypeInfo::TypeInfo((uint64_t)v233, (uint64_t)&v237);
            re::internal::upgradeObject(Instance, v233, a4, (uint64_t **)this, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264), buf);
            if (!buf[0])
            {
              if ((v249 & 1) != 0)
                LOBYTE(v214) = v251;
              else
                v214 = v250;
              if (!buf[0] && v248 && (v249 & 1) != 0)
              {
                v180 = *(void (**)(void))(*(_QWORD *)v248 + 40);
LABEL_312:
                v180();
              }
              return 0;
            }
          }
          return 1;
        }
        v63 = re::TypeInfo::name(a6)[1];
        re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
        LOBYTE(v232) = v63;
        v30 = "Unknown serialized type \"%s\" version %u. No matching runtime type found.";
      }
      else
      {
        v53 = re::TypeInfo::name(a6)[1];
        re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
        re::TypeInfo::name(this);
        re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
        LOBYTE(v232) = v53;
        v30 = "Type name changed: Serialized type \"%s\" version %u, runtime type \"%s\" version %u.";
      }
LABEL_250:
      v152 = a1;
      v153 = a2;
      goto LABEL_251;
    }
    goto LABEL_18;
  }
  if (!re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_10;
LABEL_18:
  switch(*((_BYTE *)this + 12))
  {
    case 1:
      if (this == a6)
        goto LABEL_22;
      if (*(_QWORD *)this != *(_QWORD *)a6)
      {
        if (!re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_292;
LABEL_22:
        v23 = re::TypeInfo::name(this);
        v24 = (unint64_t)*v23 >> 1;
        if (v24 <= 0xCA3DEFB5)
        {
          if ((unint64_t)*v23 >> 1 <= 0x5D0225B)
          {
            if ((unint64_t)*v23 >> 1 <= 0x2E9355)
            {
              if (v24 != 104431)
              {
                if (v24 == 3029738)
LABEL_332:
                v232 = re::TypeInfo::name(this)[1];
                v30 = "Unsupported basic type \"%s\".";
                goto LABEL_250;
              }
            }
            if (v24 == 3052374)
            v165 = 3327612;
LABEL_278:
            if (v24 == v165)
            goto LABEL_332;
          }
          if ((unint64_t)*v23 >> 1 > 0xB0F77BD0)
          {
            if (v24 == 2969009105)
              return (uint64_t)re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, (double *)a4, a7);
            if (v24 == 3111160798)
            goto LABEL_332;
          }
          if (v24 == 97526364)
            return (uint64_t)re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, (float *)a4, a7);
          v59 = 109413500;
LABEL_194:
          if (v24 == v59)
          goto LABEL_332;
        }
        if ((unint64_t)*v23 >> 1 > 0x18E6A9A092)
        {
          if ((unint64_t)*v23 >> 1 <= 0x303EE8780EDLL)
          {
            if (v24 == 0x18E6A9A093)
            if (v24 == 0x303EE86A734)
            goto LABEL_332;
          }
          if (v24 == 0x303EE8780EELL)
          if (v24 != 0x303EE88E58DLL)
            goto LABEL_332;
        }
        else
        {
          if ((unint64_t)*v23 >> 1 > 0x16749DFF02)
          {
            if (v24 == 0x16749DFF03)
            v165 = 0x16749F63A2;
            goto LABEL_278;
          }
          if (v24 != 3393056694)
          {
            v59 = 0x16749D2549;
            goto LABEL_194;
          }
        }
      }
      v71 = **((_QWORD **)this + 2);
      v72 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v71 == (unsigned __int16)v72)
      {
        v18 = WORD1(v71) == WORD1(v72);
        v73 = (v72 ^ v71) & 0xFFFFFF00000000;
        if (v18 && v73 == 0)
          goto LABEL_22;
      }
      goto LABEL_292;
    case 2:
      if (this == a6)
        goto LABEL_240;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v75 = **((_QWORD **)this + 2);
        v76 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v75 == (unsigned __int16)v76
          && WORD1(v75) == WORD1(v76)
          && ((v76 ^ v75) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_123;
        }
        v31 = 2;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
        {
LABEL_123:
          if (*(_QWORD *)this == *(_QWORD *)a6)
          {
            v154 = **((_QWORD **)this + 2);
            v155 = **((_QWORD **)a6 + 2);
            if ((unsigned __int16)v154 == (unsigned __int16)v155
              && ((v18 = WORD1(v154) == WORD1(v155), v156 = (v155 ^ v154) & 0xFFFFFF00000000, v18)
                ? (v157 = v156 == 0)
                : (v157 = 0),
                  v157))
            {
LABEL_240:
              v79 = 1;
            }
            else
            {
              v79 = 0;
            }
          }
          else
          {
            v79 = re::areSameTranslatedVersion(this, a6, a3);
          }
          if ((_DWORD)a7)
          {
            *(_QWORD *)buf = 0;
            result = (uint64_t)re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)buf);
            if (!(_DWORD)result)
              return result;
            if (*(_QWORD *)buf)
            return *(_BYTE *)(a1 + 64) == 0;
          }
          v236 = 0;
          if (!re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v236))return 0;
          v158 = v236;
          if (!v236)
          {
            v30 = "Failed to read enum constant. String is empty.";
            goto LABEL_233;
          }
          if (v236 >= 0x401)
          {
            LOBYTE(v232) = v236;
            v30 = "Failed to read enum constant. String is too long. Length: %zu";
            goto LABEL_233;
          }
          v178 = (char *)(*(uint64_t (**)(_QWORD, unint64_t, _QWORD))(**(_QWORD **)(a1 + 56) + 32))(*(_QWORD *)(a1 + 56), v236 + 1, 0);
          v178[v158] = 0;
          if (*(_BYTE *)(a1 + 64))
          {
LABEL_311:
            v180 = *(void (**)(void))(**(_QWORD **)(a1 + 56) + 40);
            goto LABEL_312;
          }
          v191 = *v178;
          if (*v178)
          {
            v192 = v178[1];
            if (v192)
            {
              v193 = (unsigned __int8 *)(v178 + 2);
              do
              {
                v191 = 31 * v191 + v192;
                v194 = *v193++;
                v192 = v194;
              }
              while (v194);
            }
          }
          *(_QWORD *)buf = 2 * v191;
          *(_QWORD *)&buf[8] = v178;
          EnumConstantIndex = re::internal::getEnumConstantIndex(a6, (const re::TypeInfo *)buf, v179);
          re::StringID::destroyString((re::StringID *)buf);
          if ((EnumConstantIndex & 0x80000000) != 0)
          {
            v216 = *re::foundationSerializationLogObjects(v196);
            if (os_log_type_enabled(v216, OS_LOG_TYPE_INFO))
            {
              v217 = re::TypeInfo::name(a6)[1];
              *(_DWORD *)buf = 136315394;
              *(_QWORD *)&buf[4] = v178;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = v217;
              _os_log_impl(&dword_224FE9000, v216, OS_LOG_TYPE_INFO, "String \"%s\" is not a valid enum constant of type \"%s\" - skipping.", buf, 0x16u);
            }
            v200 = 0;
          }
          else if (v79)
          {
            v197 = re::TypeInfo::enumConstants(this);
            v199 = EnumConstantIndex - v198;
            if (EnumConstantIndex >= v198)
            {
              v224 = re::TypeInfo::renamedEnumConstants(this);
              if (v225 <= v199)
              {
                re::internal::assertLog((re::internal *)6, v225, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v199, v225);
                _os_crash();
                __break(1u);
                JUMPOUT(0x225CD9F3CLL);
              }
              v200 = (const void *)(v224 + 24 * v199);
            }
            else
            {
              v200 = (const void *)(v197 + 24 * EnumConstantIndex);
            }
          }
          else
          {
            v218 = *(re::internal::TypeTranslationTable **)(*(_QWORD *)a6 + 856);
            if (!v218
              || (v200 = (const void *)re::internal::TypeTranslationTable::translateSerializedEnum(v218, a6, EnumConstantIndex, this)) == 0)
            {
              re::TypeInfo::name(this);
              goto LABEL_311;
            }
          }
          (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 56) + 40))(*(_QWORD *)(a1 + 56), v178);
          if (v200)
            memcpy(a4, v200, *(unsigned int *)(*((_QWORD *)this + 2) + 8));
          return *(_BYTE *)(a1 + 64) == 0;
        }
        v31 = *((unsigned __int8 *)this + 12);
      }
      if (v31 == *((unsigned __int8 *)a6 + 12))
      {
        v77 = re::TypeInfo::name(this);
        v78 = re::TypeInfo::name(a6);
        if (re::StringID::operator==(v77, v78))
          goto LABEL_123;
      }
      goto LABEL_292;
    case 3:
      if (this == a6)
        goto LABEL_130;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v80 = **((_QWORD **)this + 2);
        v81 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v80 == (unsigned __int16)v81
          && WORD1(v80) == WORD1(v81)
          && ((v81 ^ v80) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_130;
        }
        v32 = 3;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_130;
        v32 = *((unsigned __int8 *)this + 12);
      }
      if (v32 != *((unsigned __int8 *)a6 + 12))
        goto LABEL_292;
LABEL_130:
      if ((_DWORD)a7)
      {
        LOBYTE(Tag) = 0;
        re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(a1 + 24, a2, &Tag);
        if ((_BYTE)Tag)
        {
          v82 = *(re::internal **)(a1 + 272);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
          re::TypeInfo::TypeInfo((uint64_t)&v236, (uint64_t)&buf[8]);
          re::internal::translateType(v82, (const re::TypeRegistry *)&v236, (uint64_t)buf);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, 0, 0, buf, buf, 1);
        }
        v83 = (_anonymous_namespace_ *)(a1 + 24);
      }
      else
      {
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)&v236, (uint64_t)&buf[8]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&buf[8]);
        re::TypeInfo::TypeInfo((uint64_t)buf, (uint64_t)this);
        v243[0] = (*(uint64_t (**)(uint64_t *))(*(_QWORD *)&buf[16] + 80))(a4) != 0;
        v84 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(a1 + 24, a2, v243);
        if (v243[0])
        {
          v85 = re::TypeInfo::createInstance((re::TypeInfo *)&v236, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
          (*(void (**)(uint64_t *, void **))(*(_QWORD *)&buf[16] + 88))(a4, v85);
          re::TypeInfo::releaseInstance((re::TypeInfo *)&v236, v85, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
          v86 = (*(uint64_t (**)(uint64_t *))(*(_QWORD *)&buf[16] + 80))(a4);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, char *, _QWORD, uint64_t, unint64_t *, uint64_t *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, 0, v86, &v236, &Tag, 0);
        }
        else
        {
          (*(void (**)(uint64_t *, _QWORD, double))(*(_QWORD *)&buf[16] + 88))(a4, 0, v84);
        }
        v83 = (_anonymous_namespace_ *)(a1 + 24);
      }
      return *(_BYTE *)(a1 + 64) == 0;
    case 4:
      if (this == a6)
        goto LABEL_146;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v87 = **((_QWORD **)this + 2);
        v88 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v87 == (unsigned __int16)v88)
        {
          v18 = WORD1(v87) == WORD1(v88);
          v89 = (v88 ^ v87) & 0xFFFFFF00000000;
          if (v18 && v89 == 0)
            goto LABEL_146;
        }
      }
      else if (re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_146;
      }
      if (*((_BYTE *)a6 + 12) != 4)
        goto LABEL_292;
      v91 = *((_QWORD *)this + 2);
      v92 = *((_QWORD *)a6 + 2);
      v93 = *(_DWORD *)(v92 + 84) & 0xFFFFFF;
      if ((*(_DWORD *)(v91 + 84) & 0xFFFFFF) == 0)
      {
        if (!v93 && *(_DWORD *)(v91 + 88) == *(_DWORD *)(v92 + 88))
          goto LABEL_146;
LABEL_292:
        return 0;
      }
      if (!v93)
        goto LABEL_292;
LABEL_146:
      if ((_DWORD)a7)
      {
        v94 = *(re::internal **)(a1 + 272);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&buf[8]);
        re::internal::translateType(v94, (const re::TypeRegistry *)&Tag, (uint64_t)&v236);
        v95 = (*(uint64_t (**)(uint64_t, unint64_t *))(*(_QWORD *)a1 + 80))(a1, &v236);
        if (!v95)
          goto LABEL_230;
        v96 = (void (*)(uint64_t, _QWORD, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t))v95;
        v97 = *((_QWORD *)a6 + 2);
        v98 = *(_DWORD *)(v97 + 84) & 0xFFFFFF;
        if (v98)
        {
          v99 = 0;
          v100 = 8;
        }
        else
        {
          v99 = *(int *)(v97 + 88);
          v100 = 4;
        }
        *(_QWORD *)buf = v99;
        v106 = (_anonymous_namespace_ *)(a1 + 24);
        result = (uint64_t)re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, buf, v100);
        if ((_DWORD)result)
        {
          v159 = *(_QWORD *)buf;
          if (v98)
            v160 = *(_QWORD *)buf == 0;
          else
            v160 = 1;
          v161 = v160;
          if (v160)
          {
            if (!*(_QWORD *)buf)
              goto LABEL_379;
          }
          else
          {
            v239[0] = 0;
            v239[1] = (_QWORD *)0xFFFFFFFFLL;
            (*(void (**)(uint64_t, _QWORD, _QWORD **))(*(_QWORD *)a1 + 16))(a1, 0, v239);
          }
          do
          {
            v96(a1, 0, 0, 0, &v236, &v236, 1);
            --v159;
          }
          while (v159);
          if ((v161 & 1) != 0)
          {
LABEL_379:
            return *(_BYTE *)(a1 + 64) == 0;
          }
LABEL_378:
          (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
          goto LABEL_379;
        }
      }
      else
      {
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&buf[8]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)v243, (uint64_t)&buf[8]);
        re::TypeInfo::TypeInfo((uint64_t)v241, (uint64_t)this);
        v101 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 80))(a1, &Tag);
        if (!v101)
          goto LABEL_231;
        v102 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD))v101;
        v103 = re::ArrayAccessor::size((re::ArrayAccessor *)v241, (char *)a4);
        v235 = v103;
        v104 = *(_DWORD *)(*((_QWORD *)this + 2) + 84) & 0xFFFFFF;
        if (v104)
          v105 = 8;
        else
          v105 = 4;
        v106 = (_anonymous_namespace_ *)(a1 + 24);
        result = (uint64_t)re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, &v235, v105);
        if ((_DWORD)result)
        {
          v107 = v235;
          if (v103 != v235)
          {
            if ((*(_DWORD *)(v242 + 84) & 0xFFFFFF) == 0)
            {
              LOBYTE(v232) = v103;
              v30 = "Invalid array size. Expected size = %zu, actual size = %zu";
              goto LABEL_233;
            }
            re::TypeRegistry::typeInfo(v241[0], *(_QWORD *)(v242 + 72), buf);
            re::TypeInfo::TypeInfo((uint64_t)&v236, (uint64_t)&buf[8]);
            v108 = *(_DWORD *)(v238 + 8);
            if (!is_mul_ok(v108, v107))
              goto LABEL_174;
            re::ArrayAccessor::reset((re::ArrayAccessor *)v241, (void **)a4, *(re::Allocator **)(a1 + 48), (const re::TypeInfo *)v107);
            v103 = v107;
          }
          if (v104)
            v209 = v103 == 0;
          else
            v209 = 1;
          v210 = v209;
          if (!v209)
          {
            v211 = *a4;
            v234[0] = 0;
            v234[1] = 0xFFFFFFFFLL;
            (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 16))(a1, v211, v234);
            v103 = v107;
          }
          if (v103)
          {
            v212 = 0;
            if (v107 <= 1)
              v107 = 1;
            do
            {
              v213 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)v241, (char *)a4, v212);
              v102(a1, 0, 0, v213, &Tag, v243, 0);
              ++v212;
            }
            while (v107 != v212);
          }
          if ((v210 & 1) != 0)
            goto LABEL_379;
          goto LABEL_378;
        }
      }
      return result;
    case 5:
      if (this == a6)
        goto LABEL_164;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v109 = **((_QWORD **)this + 2);
        v110 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v109 == (unsigned __int16)v110
          && WORD1(v109) == WORD1(v110)
          && ((v110 ^ v109) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_164;
        }
        v33 = 5;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_164;
        v33 = *((unsigned __int8 *)this + 12);
      }
      if (v33 != *((unsigned __int8 *)a6 + 12))
        goto LABEL_292;
LABEL_164:
      if ((_DWORD)a7)
      {
        v111 = *(re::internal **)(a1 + 272);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&buf[8]);
        re::internal::translateType(v111, (const re::TypeRegistry *)&Tag, (uint64_t)&v236);
        v112 = (*(uint64_t (**)(uint64_t, unint64_t *))(*(_QWORD *)a1 + 80))(a1, &v236);
        if (!v112)
          goto LABEL_230;
        v113 = (void (*)(uint64_t, _QWORD, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t))v112;
        *(_QWORD *)buf = 0;
        v106 = (_anonymous_namespace_ *)(a1 + 24);
        v114 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, buf, 0);
        result = 0;
        if (v114)
        {
          for (i = *(_QWORD *)buf; i; --i)
            v113(a1, 0, 0, 0, &v236, &v236, 1);
          goto LABEL_379;
        }
        return result;
      }
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), buf);
      re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&buf[8]);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
      re::TypeInfo::TypeInfo((uint64_t)v243, (uint64_t)&buf[8]);
      re::TypeInfo::TypeInfo((uint64_t)v241, (uint64_t)this);
      v116 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 80))(a1, &Tag);
      if (!v116)
        goto LABEL_231;
      v117 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD))v116;
      v118 = (_QWORD *)(*(uint64_t (**)(uint64_t *))(v242 + 80))(a4);
      v239[0] = v118;
      v106 = (_anonymous_namespace_ *)(a1 + 24);
      v119 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, v239, 0);
      result = 0;
      if (!v119)
        return result;
      v120 = v239[0];
      if (v118 != v239[0])
      {
        re::TypeRegistry::typeInfo(v241[0], *(_QWORD *)(v242 + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)&v236, (uint64_t)&buf[8]);
        v108 = *(_DWORD *)(v238 + 8);
        if (!is_mul_ok(v108, (unint64_t)v120))
        {
LABEL_174:
          LOBYTE(v232) = v108;
          v30 = "Size overflow during deserialization. Element size = %zu, count = %zu";
          goto LABEL_233;
        }
        v182 = *(_QWORD *)(a1 + 48);
        v183 = *(void (**)(uint64_t *, _BYTE *, uint64_t, _QWORD *))(v242 + 88);
        re::TypeInfo::TypeInfo((uint64_t)buf, (uint64_t)v241);
        v183(a4, buf, v182, v120);
      }
      if (*(_QWORD *)(v242 + 96))
      {
        if (v120)
        {
          for (j = 0; j != v120; j = (_QWORD *)((char *)j + 1))
          {
            v185 = (*(uint64_t (**)(uint64_t *, _QWORD *))(v242 + 96))(a4, j);
            v117(a1, 0, 0, v185, &Tag, v243, 0);
          }
        }
      }
      else
      {
        v186 = *(uint64_t (**)(uint64_t *, _QWORD))(v242 + 104);
        if (!v186 || !*(_QWORD *)(v242 + 112) || !*(_QWORD *)(v242 + 120))
        {
          v190 = (re::TypeInfo *)re::TypeInfo::TypeInfo((uint64_t)buf, (uint64_t)v241);
          v232 = re::TypeInfo::name(v190)[1];
          v30 = "List type \"%s\" does not provide an indexer or iterator.";
          goto LABEL_250;
        }
        v187 = v186(a4, *(_QWORD *)(a1 + 56));
        v188 = (*(uint64_t (**)(void))(v242 + 112))();
        if (v188)
        {
          v189 = v188;
          do
          {
            v117(a1, 0, 0, v189, &Tag, v243, 0);
            v189 = (*(uint64_t (**)(uint64_t))(v242 + 112))(v187);
          }
          while (v189);
        }
        (*(void (**)(uint64_t, _QWORD))(v242 + 120))(v187, *(_QWORD *)(a1 + 56));
      }
      goto LABEL_379;
    case 6:
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), buf);
      re::TypeInfo::TypeInfo((uint64_t)&v236, (uint64_t)&buf[8]);
      v35 = re::TypeInfo::name((re::TypeInfo *)&v236);
      v36 = BYTE4(v237);
      if (BYTE4(v237) != 1)
        goto LABEL_103;
      if (!re::TypeInfo::isInteger((re::TypeInfo *)&v236))
      {
        v36 = BYTE4(v237);
LABEL_103:
        if (v36 == 8)
        {
          v64 = (unint64_t)*v35 >> 1;
          if (v64 == 0x22C6ED80D0CLL)
          {
            v131 = (char *)v35[1];
            if (v131 == "StringID" || !strcmp(v131, "StringID"))
            {
              v39 = re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
              goto LABEL_393;
            }
          }
          else if (v64 == 0x134375A94D9F7110)
          {
            v65 = (char *)v35[1];
            if (v65 == "DynamicString" || !strcmp(v65, "DynamicString"))
            {
              v39 = re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
              goto LABEL_393;
            }
          }
        }
LABEL_206:
        if (this != a6)
        {
          if (*(_QWORD *)this == *(_QWORD *)a6)
          {
            v132 = **((_QWORD **)this + 2);
            v133 = **((_QWORD **)a6 + 2);
            if ((unsigned __int16)v132 == (unsigned __int16)v133
              && WORD1(v132) == WORD1(v133)
              && ((v133 ^ v132) & 0xFFFFFF00000000) == 0)
            {
              goto LABEL_214;
            }
          }
          else if (re::areSameTranslatedVersion(this, a6, v34))
          {
            goto LABEL_214;
          }
          if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12))
            goto LABEL_292;
        }
LABEL_214:
        if ((_DWORD)a7)
        {
          v134 = *(re::internal **)(a1 + 272);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
          re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&buf[8]);
          re::internal::translateType(v134, (const re::TypeRegistry *)&Tag, (uint64_t)&v236);
          v135 = *(re::internal **)(a1 + 272);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), buf);
          re::TypeInfo::TypeInfo((uint64_t)v243, (uint64_t)&buf[8]);
          re::internal::translateType(v135, (const re::TypeRegistry *)v243, (uint64_t)&Tag);
          v136 = (*(uint64_t (**)(uint64_t, unint64_t *))(*(_QWORD *)a1 + 80))(a1, &v236);
          if (v136)
          {
            v137 = (void (*)(uint64_t, const char *, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t))v136;
            v138 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 80))(a1, &Tag);
            if (v138)
            {
              v139 = (void (*)(uint64_t, const char *, _QWORD, _QWORD, uint64_t *, uint64_t *, uint64_t))v138;
              *(_QWORD *)buf = 0;
              v140 = (_anonymous_namespace_ *)(a1 + 24);
              result = (uint64_t)re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(a1 + 24, a2, buf);
              if (!(_DWORD)result)
                return result;
              for (k = *(_QWORD *)buf; k; --k)
              {
                re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(a1 + 24, 1);
                v137(a1, "key", 0, 0, &v236, &v236, 1);
                v139(a1, "value", 0, 0, &Tag, &Tag, 1);
              }
              goto LABEL_229;
            }
            goto LABEL_231;
          }
LABEL_230:
          v151 = &v236;
LABEL_232:
          v232 = re::TypeInfo::name((re::TypeInfo *)v151)[1];
          v30 = "Failed to resolve serialize function for type \"%s\"";
          goto LABEL_233;
        }
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)&v236, (uint64_t)&buf[8]);
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), buf);
        re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&buf[8]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)v243, (uint64_t)&buf[8]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), buf);
        re::TypeInfo::TypeInfo((uint64_t)v241, (uint64_t)&buf[8]);
        re::TypeInfo::TypeInfo((uint64_t)v239, (uint64_t)this);
        v142 = (*(uint64_t (**)(uint64_t, unint64_t *))(*(_QWORD *)a1 + 80))(a1, &v236);
        if (!v142)
          goto LABEL_230;
        v143 = (void (*)(uint64_t, const char *, _QWORD, void **, unint64_t *, _BYTE *, _QWORD))v142;
        v144 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 80))(a1, &Tag);
        if (!v144)
        {
LABEL_231:
          v151 = (unint64_t *)&Tag;
          goto LABEL_232;
        }
        v145 = (void (*)(uint64_t, const char *, _QWORD, uint64_t, uint64_t *, _QWORD **, _QWORD))v144;
        v234[0] = (*(uint64_t (**)(uint64_t *))(v240 + 88))(a4);
        v140 = (_anonymous_namespace_ *)(a1 + 24);
        result = (uint64_t)re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(a1 + 24, a2, v234);
        if (!(_DWORD)result)
          return result;
        v146 = *(_QWORD *)(a1 + 48);
        v147 = *(void (**)(uint64_t *, _BYTE *, uint64_t))(v240 + 96);
        re::TypeInfo::TypeInfo((uint64_t)buf, (uint64_t)v239);
        v147(a4, buf, v146);
        v148 = v234[0];
        if (!v234[0])
          goto LABEL_229;
        v149 = re::TypeInfo::createInstance((re::TypeInfo *)&v236, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
        while (1)
        {
          re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(a1 + 24, 0);
          v143(a1, "key", 0, v149, &v236, v243, 0);
          v125 = *(re::Allocator **)(a1 + 48);
          if (*(_BYTE *)(a1 + 64))
            break;
          v150 = (*(uint64_t (**)(uint64_t *, _QWORD **, re::Allocator *, void **))(v240 + 104))(a4, v239, v125, v149);
          v145(a1, "value", 0, v150, &Tag, v241, 0);
          if (!--v148)
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)&v236, v149, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
LABEL_229:
            return *(_BYTE *)(a1 + 64) == 0;
          }
        }
        v126 = *(void **)(a1 + 264);
        v127 = &v236;
        v128 = v149;
        goto LABEL_187;
      }
      v37 = (unint64_t)*v35 >> 1;
      if (v37 > 0x303EE8780EDLL)
      {
        if (v37 == 0x303EE8780EELL)
        {
          v181 = (char *)v35[1];
          if (v181 == "uint32_t" || !strcmp(v181, "uint32_t"))
          {
            v39 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>;
            goto LABEL_393;
          }
          goto LABEL_322;
        }
        if (v37 != 0x303EE88E58DLL)
        {
LABEL_322:
          *(_QWORD *)buf = 0x18E6A9A093;
          *(_QWORD *)&buf[8] = "uint8_t";
          if (re::StringID::operator==(v35, buf))
          {
            v39 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>;
            goto LABEL_393;
          }
          *(_QWORD *)buf = 0x16749F63A2;
          *(_QWORD *)&buf[8] = "int64_t";
          if (re::StringID::operator==(v35, buf)
            || (Tag = 3327612, v245 = "long", re::StringID::operator==(v35, &Tag)))
          {
            v39 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>;
            goto LABEL_393;
          }
          *(_QWORD *)buf = 104431;
          *(_QWORD *)&buf[8] = "int";
          if (re::StringID::operator==(v35, buf))
          {
            v39 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>;
            goto LABEL_393;
          }
          *(_QWORD *)buf = 109413500;
          *(_QWORD *)&buf[8] = "short";
          if (re::StringID::operator==(v35, buf))
          {
            v39 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>;
            goto LABEL_393;
          }
          goto LABEL_206;
        }
        v129 = (char *)v35[1];
        if (v129 != "uint64_t")
        {
          v130 = "uint64_t";
          goto LABEL_318;
        }
      }
      else
      {
        if (v37 != 3393056694)
        {
          if (v37 == 0x303EE86A734)
          {
            v38 = (char *)v35[1];
            if (v38 == "uint16_t" || !strcmp(v38, "uint16_t"))
            {
              v39 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>;
LABEL_393:
              v166 = a1;
              v167 = a2;
              v168 = a3;
              v169 = a4;
              v57 = this;
              v58 = a6;
              return ((uint64_t (*)(uint64_t, char *, const re::TypeInfo *, uint64_t *, re *, re::TypeInfo *, uint64_t))v39)(v166, v167, v168, v169, v57, v58, a7);
            }
          }
          goto LABEL_322;
        }
        v129 = (char *)v35[1];
        if (v129 != "size_t")
        {
          v130 = "size_t";
LABEL_318:
          if (!strcmp(v129, v130))
            goto LABEL_319;
          goto LABEL_322;
        }
      }
LABEL_319:
      v39 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>;
      goto LABEL_393;
    case 7:
      if (this == a6)
        goto LABEL_59;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v121 = **((_QWORD **)this + 2);
        v122 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v121 != (unsigned __int16)v122)
          goto LABEL_292;
        v18 = WORD1(v121) == WORD1(v122);
        v123 = (v122 ^ v121) & 0xFFFFFF00000000;
        if (!v18 || v123 != 0)
          goto LABEL_292;
      }
      else if (!re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_292;
      }
LABEL_59:
      v40 = (_anonymous_namespace_ *)(a1 + 24);
      result = (uint64_t)re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 16);
      if ((_DWORD)a7)
      {
        if (!(_DWORD)result)
          return result;
        v236 = 0;
        if (v236 < *(unsigned int *)(*((_QWORD *)a6 + 2) + 88))
        {
          re::TypeInfo::unionMember(a6, v236, (uint64_t)buf);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, "value", 0, 0, buf, buf, 1);
        }
      }
      else
      {
        if (!(_DWORD)result)
          return result;
        v60 = (re::UnionAccessor *)re::TypeInfo::TypeInfo((uint64_t)buf, (uint64_t)this);
        Tag = re::UnionAccessor::readTag(v60, (char *)a4);
        v61 = (uint64_t *)Tag;
        re::UnionAccessor::reset((re::UnionAccessor *)buf, (char *)a4, (const re::TypeInfo *)Tag, *(re::Allocator **)(a1 + 48));
        if ((unint64_t)v61 < *(unsigned int *)(*((_QWORD *)this + 2) + 88))
        {
          re::TypeInfo::unionMember(this, (uint64_t)v61, (uint64_t)&v236);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, const char *, _QWORD, uint64_t *, unint64_t *, unint64_t *, _QWORD))(*(_QWORD *)a1 + 72))(a1, "value", 0, a4, &v236, &v236, 0);
        }
      }
      goto LABEL_363;
    case 8:
      if (!(_DWORD)a7)
        goto LABEL_69;
      if ((*(_BYTE *)(*((_QWORD *)this + 2) + 49) & 1) != 0)
      {
        v66 = *(re::TypeRegistry **)(a1 + 272);
        Tag = 0x2686EB529B3EE220;
        v245 = "DynamicString";
        re::TypeRegistry::typeInfo(v66, (const re::StringID *)&Tag, buf);
        re::TypeInfo::TypeInfo((uint64_t)&v236, (uint64_t)&buf[8]);
        re::StringID::destroyString((re::StringID *)&Tag);
        v67 = (re *)&v236;
        v68 = (re::TypeInfo *)&v236;
        v69 = a1;
        v70 = a2;
      }
      else
      {
        v41 = re::TypeInfo::name(this);
        if ((unint64_t)*v41 >> 1 != 0x134375A94D9F7110
          || (v43 = (char *)v41[1], v43 != "DynamicString") && strcmp(v43, "DynamicString"))
        {
LABEL_69:
          v44 = *((_QWORD *)this + 2);
          if ((*(_BYTE *)(v44 + 48) & 4) == 0)
          {
            v40 = (_anonymous_namespace_ *)(a1 + 24);
            v45 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
            result = 0;
            if (!v45)
              return result;
            v46 = *(_QWORD *)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
            if (v46
              && *(_WORD *)(v46 + 22) == 3
              && *(_DWORD *)v46
              && (v47 = *(_QWORD *)(v46 + 8), (*(_WORD *)(v47 + 46) & 0x40) != 0)
              && ((*(_WORD *)(v47 + 22) & 0x1000) != 0
                ? (v48 = *(const char **)(v46 + 8))
                : (v48 = *(const char **)(v47 + 8)),
                  !strcmp(v48, "@version")))
            {
              v49 = *(_DWORD *)(v47 + 24);
            }
            else
            {
              v49 = 1;
            }
            v50 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
            if (v50)
              v52 = *(_DWORD *)(v50 + 16);
            else
              v52 = -1;
            if (v49 == v52)
            {
              if (this != a6)
              {
                if (*(_QWORD *)this == *(_QWORD *)a6)
                {
                  v201 = **((_QWORD **)this + 2);
                  v202 = **((_QWORD **)a6 + 2);
                  if ((unsigned __int16)v201 == (unsigned __int16)v202
                    && WORD1(v201) == WORD1(v202)
                    && ((v202 ^ v201) & 0xFFFFFF00000000) == 0)
                  {
                    goto LABEL_304;
                  }
                }
                else if (re::areSameTranslatedVersion(this, a6, v51))
                {
                  goto LABEL_304;
                }
                if (*((unsigned __int8 *)this + 12) == *((unsigned __int8 *)a6 + 12))
                {
                  re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, (uint64_t)a4, (uint64_t *)this, (uint64_t *)a6, a7);
                }
                else
                {
                  v203 = re::TypeInfo::name(this)[1];
                  re::TypeInfo::name(a6);
                }
                goto LABEL_363;
              }
LABEL_304:
              re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>((_BYTE *)a1, (uint64_t)a4, (uint64_t *)this, a7);
LABEL_363:
              return *(_BYTE *)(a1 + 64) == 0;
            }
            if (*(_QWORD *)this != *(_QWORD *)a6
              || (v175 = **((_QWORD **)this + 2),
                  v176 = **((_QWORD **)a6 + 2),
                  (unsigned __int16)v175 != (unsigned __int16)v176)
              || WORD1(v175) != WORD1(v176)
              || ((v176 ^ v175) & 0xFFFFFF00000000) != 0)
            {
              v177 = re::TypeInfo::name(a6)[1];
              re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
              LOBYTE(v232) = v177;
              v30 = "Type \"%s\" version %u expected in JSON. Actual version found in JSON: %u";
LABEL_233:
              v152 = a1;
              v153 = 0;
LABEL_251:
              return 0;
            }
            re::TypeInfo::atVersion(this, v49, (unsigned __int8 *)&v236);
            if (!(_BYTE)v236)
            {
              v232 = re::TypeInfo::name(this)[1];
              v30 = "Unknown serialized type \"%s\" version %u. No matching runtime type found.";
              goto LABEL_233;
            }
            if ((a7 & 1) != 0)
              v215 = 0;
            else
              v215 = re::TypeInfo::createInstance((re::TypeInfo *)&v237, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
            re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>((_BYTE *)a1, (uint64_t)v215, &v237, a7);
            if (*(_BYTE *)(a1 + 64))
            {
              if (!v215)
                return 0;
              v125 = *(re::Allocator **)(a1 + 48);
              v126 = *(void **)(a1 + 264);
              v127 = (unint64_t *)&v237;
              v128 = v215;
              goto LABEL_187;
            }
            if ((a7 & 1) == 0)
            {
              re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&v237);
              re::internal::upgradeObject(v215, (uint64_t **)&Tag, a4, (uint64_t **)this, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264), buf);
              if (!buf[0])
              {
                if ((v249 & 1) != 0)
                  LOBYTE(v231) = v251;
                else
                  v231 = v250;
                if (!buf[0] && v248 && (v249 & 1) != 0)
                  (*(void (**)(void))(*(_QWORD *)v248 + 40))();
              }
            }
            return 1;
          }
          v54 = (uint64_t *)re::TypeMemberCollection::TypeMemberCollection((uint64_t)buf, *(_QWORD *)this, v44);
          re::TypeMemberCollection::operator[](v54, 0, (uint64_t)&Tag);
          v55 = (char *)a4 + *(unsigned int *)(v246 + 24);
          re::TypeRegistry::typeInfo((_QWORD *)Tag, *(_QWORD *)v246, buf);
          re::TypeInfo::TypeInfo((uint64_t)v243, (uint64_t)&buf[8]);
          if (this == a6)
            goto LABEL_87;
          if (*(_QWORD *)this == *(_QWORD *)a6)
          {
            v162 = **((_QWORD **)this + 2);
            v163 = *((_QWORD *)a6 + 2);
            v164 = *(_QWORD *)v163;
            if ((unsigned __int16)v162 == (unsigned __int16)*(_QWORD *)v163
              && WORD1(v162) == WORD1(v164)
              && ((v164 ^ v162) & 0xFFFFFF00000000) == 0)
            {
              goto LABEL_87;
            }
          }
          else
          {
            if (re::areSameTranslatedVersion(this, a6, v56))
            {
LABEL_87:
              if (*(_BYTE *)(a1 + 64))
                return 0;
              v39 = *(BOOL (**)(uint64_t, char *, const re::TypeInfo *, uint64_t, re *, re::TypeInfo *, int))(*(_QWORD *)a1 + 72);
              v57 = (re *)v243;
              v58 = (re::TypeInfo *)v243;
LABEL_291:
              v166 = a1;
              v167 = a2;
              v168 = a3;
              v169 = (uint64_t *)v55;
              return ((uint64_t (*)(uint64_t, char *, const re::TypeInfo *, uint64_t *, re *, re::TypeInfo *, uint64_t))v39)(v166, v167, v168, v169, v57, v58, a7);
            }
            v163 = *((_QWORD *)a6 + 2);
          }
          if (*(_DWORD *)(v163 + 88) != 1)
            goto LABEL_292;
          re::TypeMemberCollection::TypeMemberCollection((uint64_t)&v236, *(_QWORD *)a6, v163);
          re::TypeMemberCollection::operator[]((uint64_t *)&v236, 0, (uint64_t)v239);
          re::TypeRegistry::typeInfo(v239[0], *(_QWORD *)v240, buf);
          re::TypeInfo::TypeInfo((uint64_t)v241, (uint64_t)&buf[8]);
          if (*(_BYTE *)(a1 + 64))
            return 0;
          v39 = *(BOOL (**)(uint64_t, char *, const re::TypeInfo *, uint64_t, re *, re::TypeInfo *, int))(*(_QWORD *)a1 + 72);
          v57 = (re *)v243;
          v58 = (re::TypeInfo *)v241;
          goto LABEL_291;
        }
        v69 = a1;
        v70 = a2;
        v67 = this;
        v68 = this;
      }
      re::serializeDynamicString<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(v69, v70, v42, 0, v67, v68, 1);
      return *(_BYTE *)(a1 + 64) == 0;
    case 9:
      v232 = re::TypeInfo::name(this)[1];
      v30 = "Pointer type (\"%s\") needs to be handled explicitly by the serializer.";
      goto LABEL_250;
    default:
      LOBYTE(v232) = *((_BYTE *)this + 12);
      v30 = "Invalid type category. Value = %d";
      goto LABEL_250;
  }
}

unsigned int *re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(uint64_t a1, char *a2, float *a3, char a4)
{
  unsigned int *result;
  double v9;
  __int16 v10;
  float Double;
  const char *v12;
  unsigned int v13;
  int v14;
  re *v15;
  float v16;
  BOOL v17;
  NSObject *v18;
  uint64_t v19;
  _BYTE v20[24];
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 40))
    return 0;
  if (result)
  {
    v10 = *((_WORD *)result + 11);
    if ((v10 & 0x400) == 0)
    {
      if ((v10 & 0x10) != 0)
      {
        Double = rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::GetDouble(result, v9);
LABEL_35:
        if ((a4 & 1) == 0)
          *a3 = Double;
        v19 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
        ++*(_QWORD *)(v19 - 16);
        return (unsigned int *)1;
      }
LABEL_32:
      return 0;
    }
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      v12 = (const char *)result;
    else
      v12 = (const char *)*((_QWORD *)result + 1);
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      v13 = 21 - *((char *)result + 21);
    else
      v13 = *result;
    if (v13 == 9)
    {
      if (!strcasecmp(v12, "-Infinity"))
      {
        *(float *)&v14 = -INFINITY;
        goto LABEL_34;
      }
    }
    else if (v13 == 8)
    {
      if (!strcasecmp(v12, "Infinity"))
      {
        *(float *)&v14 = INFINITY;
        goto LABEL_34;
      }
    }
    else if (v13 == 3 && !strcasecmp(v12, "NaN"))
    {
      *(float *)&v14 = NAN;
LABEL_34:
      Double = *(float *)&v14;
      goto LABEL_35;
    }
    if (*(_BYTE *)(a1 + 232))
    {
      *(_QWORD *)v20 = 0;
      v16 = strtof(v12, (char **)v20);
      v17 = *(const char **)v20 != &v12[v13] || v16 == INFINITY;
      Double = v17 ? INFINITY : v16;
      if (Double != INFINITY)
      {
        v18 = *re::foundationSerializationLogObjects(v15);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v20 = 136315138;
          *(_QWORD *)&v20[4] = v12;
          _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", v20, 0xCu);
        }
        goto LABEL_35;
      }
    }
    goto LABEL_32;
  }
  return result;
}

unsigned int *re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(uint64_t a1, char *a2, double *a3, char a4)
{
  unsigned int *result;
  double v9;
  __int16 v10;
  double Double;
  const char *v12;
  unsigned int v13;
  unint64_t v14;
  re *v15;
  float v16;
  BOOL v17;
  NSObject *v18;
  uint64_t v19;
  _BYTE v20[24];
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 40))
    return 0;
  if (result)
  {
    v10 = *((_WORD *)result + 11);
    if ((v10 & 0x400) == 0)
    {
      if ((v10 & 0x10) != 0)
      {
        Double = rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::GetDouble(result, v9);
LABEL_35:
        if ((a4 & 1) == 0)
          *a3 = Double;
        v19 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
        ++*(_QWORD *)(v19 - 16);
        return (unsigned int *)1;
      }
LABEL_32:
      return 0;
    }
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      v12 = (const char *)result;
    else
      v12 = (const char *)*((_QWORD *)result + 1);
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      v13 = 21 - *((char *)result + 21);
    else
      v13 = *result;
    if (v13 == 9)
    {
      if (!strcasecmp(v12, "-Infinity"))
      {
        *(double *)&v14 = -INFINITY;
        goto LABEL_34;
      }
    }
    else if (v13 == 8)
    {
      if (!strcasecmp(v12, "Infinity"))
      {
        *(double *)&v14 = INFINITY;
        goto LABEL_34;
      }
    }
    else if (v13 == 3 && !strcasecmp(v12, "NaN"))
    {
      *(double *)&v14 = NAN;
LABEL_34:
      Double = *(double *)&v14;
      goto LABEL_35;
    }
    if (*(_BYTE *)(a1 + 232))
    {
      *(_QWORD *)v20 = 0;
      v16 = strtod(v12, (char **)v20);
      v17 = *(const char **)v20 != &v12[v13] || v16 == INFINITY;
      Double = v17 ? INFINITY : v16;
      if (Double != INFINITY)
      {
        v18 = *re::foundationSerializationLogObjects(v15);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v20 = 136315138;
          *(_QWORD *)&v20[4] = v12;
          _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", v20, 0xCu);
        }
        goto LABEL_35;
      }
    }
    goto LABEL_32;
  }
  return result;
}

unsigned int *re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(_BYTE *a1, char *a2, uint64_t *a3)
{
  unsigned int *result;
  double v7;
  unsigned int *v8;
  __int16 v9;
  double Double;
  int v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  char __str[64];
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (a1[40])
    return 0;
  if (result)
  {
    v8 = result;
    v9 = *((_WORD *)result + 11);
    if ((v9 & 0x400) != 0)
    {
      if ((*((_WORD *)result + 11) & 0x1000) != 0)
        LODWORD(v12) = 21 - *((char *)result + 21);
      else
        LODWORD(v12) = *result;
      v12 = v12;
    }
    else if ((v9 & 0x10) != 0
           && a1[232]
           && (Double = rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::GetDouble(result, v7), (v11 = snprintf(__str, 0x40uLL, "%g", Double)) != 0))
    {
      v12 = v11;
    }
    else
    {
      if (!a1[233] || (v13 = *((unsigned __int16 *)v8 + 11), (v13 & 8) == 0))
      {
        return 0;
      }
      v14 = v13 == 10;
      v12 = 4;
      if (!v14)
        v12 = 5;
    }
    *a3 = v12;
    LOBYTE(v15) = 8;
    DWORD1(v15) = 0;
    *((_QWORD *)&v15 + 1) = a2;
    v16 = 0;
    v17 = v12;
    v18 = 0;
    v19 = v8;
    re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState((uint64_t)a1, &v15);
    return (unsigned int *)1;
  }
  return result;
}

double re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(uint64_t a1, char *a2, _BYTE *a3)
{
  unsigned int *JSONValue;
  _BOOL4 v7;
  double result;
  __int128 v9;
  uint64_t v10;
  _BOOL8 v11;
  uint64_t v12;
  unsigned int *v13;

  if (!*(_BYTE *)(a1 + 40))
  {
    if (JSONValue)
      v7 = *((_WORD *)JSONValue + 11) != 0;
    else
      v7 = 0;
    *a3 = v7;
    LOBYTE(v9) = 3;
    DWORD1(v9) = 0;
    *((_QWORD *)&v9 + 1) = a2;
    v10 = 0;
    v11 = v7;
    v12 = 0;
    v13 = JSONValue;
    return re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v9);
  }
  return result;
}

unsigned int *re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(uint64_t a1, char *a2, _QWORD *a3, int a4)
{
  unsigned int *result;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if (result)
  {
    if (*((_WORD *)result + 11) == 4)
    {
      v9 = *result;
      *a3 = v9;
      LOBYTE(v10) = 5;
      DWORD1(v10) = a4;
      *((_QWORD *)&v10 + 1) = a2;
      v11 = 0;
      v12 = v9;
      v13 = 0;
      v14 = result;
      re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v10);
      return (unsigned int *)1;
    }
    return 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v20)(uint64_t, uint64_t *, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  _BOOL8 result;
  unsigned int *v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _BYTE v45[16];
  uint64_t v46;
  _BYTE v47[32];
  _BYTE v48[32];
  uint64_t v49;
  uint64_t v50;
  _BYTE v51[40];

  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v50),
        re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v51),
        v48[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v48))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v50);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v51);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v50);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)v51);
  re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v48);
  if (!v18)
  {
    v43 = re::TypeInfo::name((re::TypeInfo *)v48)[1];
    return 0;
  }
  v19 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v18;
  v20 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v46 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v50, (uint64_t)v45);
  v20(a4, &v50, v17);
  v26 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
  result = 0;
  if (v26)
  {
    v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v28 && *v28)
    {
      v29 = *((_QWORD *)v28 + 1);
      while (1)
      {
        if ((*(_WORD *)(v29 + 22) & 0x1000) != 0)
          v30 = v29;
        else
          v30 = *(_QWORD *)(v29 + 8);
        if ((*(_WORD *)(v29 + 22) & 0x1000) != 0)
          v31 = 21 - *(char *)(v29 + 21);
        else
          v31 = *(_DWORD *)v29;
        v44 = 0;
        if (!v31)
          goto LABEL_42;
        v32 = 0;
        v33 = (unsigned __int8 *)(v30 + v31);
        while (*(_BYTE *)(v30 + v32) == 48)
        {
          if (v31 == ++v32)
            goto LABEL_42;
        }
        if (v31 == v32)
          goto LABEL_42;
        v34 = (unsigned __int8 *)(v30 + v32);
        if (*(unsigned __int8 *)(v30 + v32) - 48 > 9)
          goto LABEL_41;
        v34 = std::__itoa::__traits<unsigned long long>::__read[abi:nn180100](v34, v33, &v50, &v49);
        if (v34 == v33)
          break;
        if (*v34 - 48 > 9)
        {
          v36 = v49;
          v35 = v50;
          if (!__CFADD__(v50, v49))
            goto LABEL_40;
        }
        while (*v34 - 48 <= 9)
        {
          if (++v34 == v33)
          {
            v34 = v33;
            break;
          }
        }
LABEL_41:
        if (v33 != v34)
        {
          return 0;
        }
LABEL_42:
        v37 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, uint64_t *))(v46 + 104))(a4, v45, *(_QWORD *)(a1 + 48), &v44);
        v19(a1, v30, 0, v37, v48, v47, 0);
        v29 += 48;
        if (v29 == *((_QWORD *)v28 + 1) + 48 * *v28)
          goto LABEL_43;
      }
      v36 = v49;
      v35 = v50;
      if (__CFADD__(v50, v49))
        goto LABEL_42;
LABEL_40:
      v44 = v35 + v36;
      goto LABEL_41;
    }
LABEL_43:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v20)(uint64_t, int *, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  _BOOL8 result;
  unsigned int *v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  _BYTE v45[16];
  uint64_t v46;
  _BYTE v47[32];
  _BYTE v48[36];
  int v49;
  int v50;
  _BYTE v51[40];

  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v50),
        re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v51),
        v48[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v48))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v50);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v51);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v50);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)v51);
  re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v48);
  if (!v18)
  {
    v43 = re::TypeInfo::name((re::TypeInfo *)v48)[1];
    return 0;
  }
  v19 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v18;
  v20 = *(void (**)(uint64_t, int *, uint64_t))(v46 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v50, (uint64_t)v45);
  v20(a4, &v50, v17);
  v26 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
  result = 0;
  if (v26)
  {
    v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v28 && *v28)
    {
      v29 = *((_QWORD *)v28 + 1);
      while (1)
      {
        if ((*(_WORD *)(v29 + 22) & 0x1000) != 0)
          v30 = v29;
        else
          v30 = *(_QWORD *)(v29 + 8);
        if ((*(_WORD *)(v29 + 22) & 0x1000) != 0)
          v31 = 21 - *(char *)(v29 + 21);
        else
          v31 = *(_DWORD *)v29;
        v44 = 0;
        if (!v31)
          goto LABEL_42;
        v32 = 0;
        v33 = (unsigned __int8 *)(v30 + v31);
        while (*(_BYTE *)(v30 + v32) == 48)
        {
          if (v31 == ++v32)
            goto LABEL_42;
        }
        if (v31 == v32)
          goto LABEL_42;
        v34 = (unsigned __int8 *)(v30 + v32);
        if (*(unsigned __int8 *)(v30 + v32) - 48 > 9)
          goto LABEL_41;
        v34 = std::__itoa::__traits<unsigned int>::__read[abi:nn180100](v34, v33, &v50, &v49);
        if (v34 == v33)
          break;
        if (*v34 - 48 > 9)
        {
          v36 = v49;
          v35 = v50;
          if (!__CFADD__(v50, v49))
            goto LABEL_40;
        }
        while (*v34 - 48 <= 9)
        {
          if (++v34 == v33)
          {
            v34 = v33;
            break;
          }
        }
LABEL_41:
        if (v33 != v34)
        {
          return 0;
        }
LABEL_42:
        v37 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, int *))(v46 + 104))(a4, v45, *(_QWORD *)(a1 + 48), &v44);
        v19(a1, v30, 0, v37, v48, v47, 0);
        v29 += 48;
        if (v29 == *((_QWORD *)v28 + 1) + 48 * *v28)
          goto LABEL_43;
      }
      v36 = v49;
      v35 = v50;
      if (__CFADD__(v50, v49))
        goto LABEL_42;
LABEL_40:
      v44 = v35 + v36;
      goto LABEL_41;
    }
LABEL_43:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v20)(uint64_t, unsigned int *, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  _BOOL8 result;
  unsigned int *v28;
  uint64_t i;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  __int16 v42;
  _BYTE v43[16];
  uint64_t v44;
  _BYTE v45[32];
  _BYTE v46[36];
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[40];

  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)v49),
        v46[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v46))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)v49);
  re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v46);
  if (!v18)
  {
    v41 = re::TypeInfo::name((re::TypeInfo *)v46)[1];
    return 0;
  }
  v19 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v18;
  v20 = *(void (**)(uint64_t, unsigned int *, uint64_t))(v44 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v48, (uint64_t)v43);
  v20(a4, &v48, v17);
  v26 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
  result = 0;
  if (v26)
  {
    v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v28 && *v28)
    {
      for (i = *((_QWORD *)v28 + 1); i != *((_QWORD *)v28 + 1) + 48 * *v28; i += 48)
      {
        if ((*(_WORD *)(i + 22) & 0x1000) != 0)
          v30 = i;
        else
          v30 = *(_QWORD *)(i + 8);
        if ((*(_WORD *)(i + 22) & 0x1000) != 0)
          v31 = 21 - *(char *)(i + 21);
        else
          v31 = *(_DWORD *)i;
        v42 = 0;
        if (!v31)
          goto LABEL_42;
        v32 = 0;
        v33 = (unsigned __int8 *)(v30 + v31);
        while (*(_BYTE *)(v30 + v32) == 48)
        {
          if (v31 == ++v32)
            goto LABEL_42;
        }
        if (v31 == v32)
          goto LABEL_42;
        v34 = (unsigned __int8 *)(v30 + v32);
        if (*(unsigned __int8 *)(v30 + v32) - 48 <= 9)
        {
          v34 = std::__itoa::__traits<unsigned short>::__read[abi:nn180100](v34, v33, &v48, &v47);
          if (v34 == v33 || *v34 - 48 > 9)
          {
            if (HIWORD(v48) || 0xFFFF - v48 < v47)
            {
              if (v34 != v33)
                goto LABEL_37;
              goto LABEL_42;
            }
            v42 = v47 + v48;
          }
          else
          {
LABEL_37:
            while (*v34 - 48 <= 9)
            {
              if (++v34 == v33)
              {
                v34 = v33;
                break;
              }
            }
          }
        }
        if (v33 != v34)
        {
          return 0;
        }
LABEL_42:
        v35 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, __int16 *))(v44 + 104))(a4, v43, *(_QWORD *)(a1 + 48), &v42);
        v19(a1, v30, 0, v35, v46, v45, 0);
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v20)(uint64_t, unsigned int *, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  _BOOL8 result;
  unsigned int *v28;
  uint64_t i;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  _BYTE v43[16];
  uint64_t v44;
  _BYTE v45[32];
  _BYTE v46[36];
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[40];

  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)v49),
        v46[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v46))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)v49);
  re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v46);
  if (!v18)
  {
    v41 = re::TypeInfo::name((re::TypeInfo *)v46)[1];
    return 0;
  }
  v19 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v18;
  v20 = *(void (**)(uint64_t, unsigned int *, uint64_t))(v44 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v48, (uint64_t)v43);
  v20(a4, &v48, v17);
  v26 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
  result = 0;
  if (v26)
  {
    v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v28 && *v28)
    {
      for (i = *((_QWORD *)v28 + 1); i != *((_QWORD *)v28 + 1) + 48 * *v28; i += 48)
      {
        if ((*(_WORD *)(i + 22) & 0x1000) != 0)
          v30 = i;
        else
          v30 = *(_QWORD *)(i + 8);
        if ((*(_WORD *)(i + 22) & 0x1000) != 0)
          v31 = 21 - *(char *)(i + 21);
        else
          v31 = *(_DWORD *)i;
        v42 = 0;
        if (!v31)
          goto LABEL_42;
        v32 = 0;
        v33 = (unsigned __int8 *)(v30 + v31);
        while (*(_BYTE *)(v30 + v32) == 48)
        {
          if (v31 == ++v32)
            goto LABEL_42;
        }
        if (v31 == v32)
          goto LABEL_42;
        v34 = (unsigned __int8 *)(v30 + v32);
        if (*(unsigned __int8 *)(v30 + v32) - 48 <= 9)
        {
          v34 = std::__itoa::__traits<unsigned char>::__read[abi:nn180100](v34, v33, &v48, &v47);
          if (v34 == v33 || *v34 - 48 > 9)
          {
            if (v48 > 0xFF || 255 - v48 < v47)
            {
              if (v34 != v33)
                goto LABEL_37;
              goto LABEL_42;
            }
            v42 = v47 + v48;
          }
          else
          {
LABEL_37:
            while (*v34 - 48 <= 9)
            {
              if (++v34 == v33)
              {
                v34 = v33;
                break;
              }
            }
          }
        }
        if (v33 != v34)
        {
          return 0;
        }
LABEL_42:
        v35 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, char *))(v44 + 104))(a4, v43, *(_QWORD *)(a1 + 48), &v42);
        v19(a1, v30, 0, v35, v46, v45, 0);
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v20)(uint64_t, uint64_t *, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  _BOOL8 result;
  unsigned int *v28;
  uint64_t v29;
  unsigned __int8 *v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  unsigned __int8 *v34;
  char v35;
  unsigned __int8 *v36;
  uint64_t v37;
  unsigned __int8 *v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  _BYTE v50[16];
  uint64_t v51;
  _BYTE v52[32];
  _BYTE v53[32];
  uint64_t v54;
  uint64_t v55;
  _BYTE v56[40];

  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v55),
        re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56),
        v53[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v53))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v56);
  re::TypeInfo::TypeInfo((uint64_t)v50, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v53);
  if (!v18)
  {
    v48 = re::TypeInfo::name((re::TypeInfo *)v53)[1];
    return 0;
  }
  v19 = (void (*)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v18;
  v20 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v51 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v55, (uint64_t)v50);
  v20(a4, &v55, v17);
  v26 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
  result = 0;
  if (v26)
  {
    v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v28 && *v28)
    {
      v29 = *((_QWORD *)v28 + 1);
      while (1)
      {
        v30 = (*(_WORD *)(v29 + 22) & 0x1000) != 0 ? (unsigned __int8 *)v29 : *(unsigned __int8 **)(v29 + 8);
        v31 = (*(_WORD *)(v29 + 22) & 0x1000) != 0 ? 21 - *(char *)(v29 + 21) : *(_DWORD *)v29;
        v49 = 0;
        v32 = v31 && *v30 == 45;
        v33 = v31;
        v34 = &v30[v31];
        v35 = v32;
        v36 = &v30[v32];
        if (v33 == v32)
          break;
        v37 = v33 - v32;
        v38 = v36;
        while (*v38 == 48)
        {
          ++v38;
          if (!--v37)
            goto LABEL_42;
        }
        if (!v37)
          break;
        if (*v38 - 48 >= 0xA)
          goto LABEL_43;
        v38 = std::__itoa::__traits<unsigned long long>::__read[abi:nn180100](v38, v34, &v55, &v54);
        if (v38 == v34)
        {
          v40 = v54;
          v39 = v55;
          if (__CFADD__(v55, v54))
          {
LABEL_53:
            v38 = v34;
            goto LABEL_48;
          }
        }
        else if (*v38 - 48 <= 9 || (v40 = v54, v39 = v55, __CFADD__(v55, v54)))
        {
          while (*v38 - 48 <= 9)
          {
            if (++v38 == v34)
              goto LABEL_53;
          }
          goto LABEL_48;
        }
        v41 = v39 + v40;
        if ((v35 & 1) != 0)
        {
          if (v41 <= 0x8000000000000000)
            goto LABEL_45;
        }
        else if ((v41 & 0x8000000000000000) == 0)
        {
          goto LABEL_46;
        }
LABEL_48:
        if (v34 != v38)
        {
          return 0;
        }
        v42 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, unint64_t *))(v51 + 104))(a4, v50, *(_QWORD *)(a1 + 48), &v49);
        v19(a1, v30, 0, v42, v53, v52, 0);
        v29 += 48;
        if (v29 == *((_QWORD *)v28 + 1) + 48 * *v28)
          goto LABEL_62;
      }
LABEL_42:
      v38 = v34;
LABEL_43:
      if (v38 != v36)
      {
        v41 = 0;
        if ((v35 & 1) != 0)
LABEL_45:
          v41 = -(uint64_t)v41;
LABEL_46:
        v49 = v41;
        goto LABEL_48;
      }
      v38 = v30;
      goto LABEL_48;
    }
LABEL_62:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v20)(uint64_t, int *, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  _BOOL8 result;
  unsigned int *v28;
  uint64_t v29;
  unsigned __int8 *v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  unsigned __int8 *v34;
  char v35;
  unsigned __int8 *v36;
  uint64_t v37;
  unsigned __int8 *v38;
  int v39;
  int v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  _BYTE v50[16];
  uint64_t v51;
  _BYTE v52[32];
  _BYTE v53[36];
  int v54;
  int v55;
  _BYTE v56[40];

  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v55),
        re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56),
        v53[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v53))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v56);
  re::TypeInfo::TypeInfo((uint64_t)v50, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v53);
  if (!v18)
  {
    v48 = re::TypeInfo::name((re::TypeInfo *)v53)[1];
    return 0;
  }
  v19 = (void (*)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v18;
  v20 = *(void (**)(uint64_t, int *, uint64_t))(v51 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v55, (uint64_t)v50);
  v20(a4, &v55, v17);
  v26 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
  result = 0;
  if (v26)
  {
    v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v28 && *v28)
    {
      v29 = *((_QWORD *)v28 + 1);
      while (1)
      {
        v30 = (*(_WORD *)(v29 + 22) & 0x1000) != 0 ? (unsigned __int8 *)v29 : *(unsigned __int8 **)(v29 + 8);
        v31 = (*(_WORD *)(v29 + 22) & 0x1000) != 0 ? 21 - *(char *)(v29 + 21) : *(_DWORD *)v29;
        v49 = 0;
        v32 = v31 && *v30 == 45;
        v33 = v31;
        v34 = &v30[v31];
        v35 = v32;
        v36 = &v30[v32];
        if (v33 == v32)
          break;
        v37 = v33 - v32;
        v38 = v36;
        while (*v38 == 48)
        {
          ++v38;
          if (!--v37)
            goto LABEL_42;
        }
        if (!v37)
          break;
        if (*v38 - 48 >= 0xA)
          goto LABEL_43;
        v38 = std::__itoa::__traits<unsigned int>::__read[abi:nn180100](v38, v34, &v55, &v54);
        if (v38 == v34)
        {
          v40 = v54;
          v39 = v55;
          if (__CFADD__(v55, v54))
          {
LABEL_53:
            v38 = v34;
            goto LABEL_48;
          }
        }
        else if (*v38 - 48 <= 9 || (v40 = v54, v39 = v55, __CFADD__(v55, v54)))
        {
          while (*v38 - 48 <= 9)
          {
            if (++v38 == v34)
              goto LABEL_53;
          }
          goto LABEL_48;
        }
        v41 = v39 + v40;
        if ((v35 & 1) != 0)
        {
          if (v41 <= 0x80000000)
            goto LABEL_45;
        }
        else if ((v41 & 0x80000000) == 0)
        {
          goto LABEL_46;
        }
LABEL_48:
        if (v34 != v38)
        {
          return 0;
        }
        v42 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, unsigned int *))(v51 + 104))(a4, v50, *(_QWORD *)(a1 + 48), &v49);
        v19(a1, v30, 0, v42, v53, v52, 0);
        v29 += 48;
        if (v29 == *((_QWORD *)v28 + 1) + 48 * *v28)
          goto LABEL_62;
      }
LABEL_42:
      v38 = v34;
LABEL_43:
      if (v38 != v36)
      {
        v41 = 0;
        if ((v35 & 1) != 0)
LABEL_45:
          v41 = -v41;
LABEL_46:
        v49 = v41;
        goto LABEL_48;
      }
      v38 = v30;
      goto LABEL_48;
    }
LABEL_62:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  _BOOL8 result;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v21)(uint64_t, unsigned int *, uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int *v28;
  unsigned __int8 *v29;
  unsigned __int8 *v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  unsigned __int8 *v34;
  char v35;
  unsigned __int8 *v36;
  uint64_t v37;
  unsigned __int8 *v38;
  __int16 v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __int16 v48;
  _BYTE v49[16];
  uint64_t v50;
  _BYTE v51[32];
  _BYTE v52[36];
  unsigned int v53;
  unsigned int v54;
  _BYTE v55[40];

  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v54),
        re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v55),
        v52[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v52))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v18 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v54);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v55);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v54);
  re::TypeInfo::TypeInfo((uint64_t)v51, (uint64_t)v55);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)this);
  v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v52);
  if (!v19)
  {
    v47 = re::TypeInfo::name((re::TypeInfo *)v52)[1];
    return 0;
  }
  v20 = (void (*)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v19;
  v21 = *(void (**)(uint64_t, unsigned int *, uint64_t))(v50 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v54, (uint64_t)v49);
  v21(a4, &v54, v18);
  v27 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
  result = 0;
  if (v27)
  {
    v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (!v28 || !*v28)
    {
LABEL_62:
      return *(_BYTE *)(a1 + 64) == 0;
    }
    v29 = (unsigned __int8 *)*((_QWORD *)v28 + 1);
    while (1)
    {
      if ((*((_WORD *)v29 + 11) & 0x1000) != 0)
        v30 = v29;
      else
        v30 = (unsigned __int8 *)*((_QWORD *)v29 + 1);
      if ((*((_WORD *)v29 + 11) & 0x1000) != 0)
        v31 = 21 - (char)v29[21];
      else
        v31 = *(_DWORD *)v29;
      v48 = 0;
      if (v31)
        v32 = *v30 == 45;
      else
        v32 = 0;
      v33 = v31;
      v34 = &v30[v31];
      v35 = v32;
      v36 = &v30[v32];
      if (v33 == v32)
        goto LABEL_44;
      v37 = v33 - v32;
      v38 = v36;
      while (*v38 == 48)
      {
        ++v38;
        if (!--v37)
          goto LABEL_44;
      }
      if (!v37)
      {
LABEL_44:
        v38 = v34;
LABEL_45:
        if (v38 == v36)
        {
          v38 = v30;
          goto LABEL_52;
        }
        v39 = 0;
        v40 = 0;
        if ((v35 & 1) != 0)
        {
LABEL_47:
          v48 = -v39;
          goto LABEL_52;
        }
LABEL_51:
        v48 = v40;
        goto LABEL_52;
      }
      if (*v38 - 48 >= 0xA)
        goto LABEL_45;
      v38 = std::__itoa::__traits<unsigned short>::__read[abi:nn180100](v38, v34, &v54, &v53);
      if (v38 != v34 && *v38 - 48 <= 9)
        goto LABEL_56;
      if (HIWORD(v54) || 0xFFFF - v54 < v53)
        break;
      v39 = v53 + v54;
      if ((v35 & 1) == 0)
      {
        if ((((_WORD)v53 + (_WORD)v54) & 0x8000) != 0)
          goto LABEL_52;
        v40 = v53 + v54;
        goto LABEL_51;
      }
      if ((unsigned __int16)(v53 + v54) <= 0x8000u)
        goto LABEL_47;
LABEL_52:
      if (v34 != v38)
      {
        return 0;
      }
      v41 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, __int16 *))(v50 + 104))(a4, v49, *(_QWORD *)(a1 + 48), &v48);
      v20(a1, v30, 0, v41, v52, v51, 0);
      v29 += 48;
      if (v29 == (unsigned __int8 *)(*((_QWORD *)v28 + 1) + 48 * *v28))
        goto LABEL_62;
    }
    while (1)
    {
      if (v38 == v34)
      {
        v38 = v34;
        goto LABEL_52;
      }
LABEL_56:
      if (*v38 - 48 > 9)
        goto LABEL_52;
      ++v38;
    }
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  unsigned int v25;
  _BOOL8 result;
  void (*v27)(uint64_t, const char **, uint64_t);
  re::DynamicString *v28;
  unsigned int *v29;
  uint64_t v30;
  const char *v31;
  size_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE v40[16];
  uint64_t v41;
  _BYTE v42[32];
  _BYTE v43[32];
  const char *v44;
  _QWORD v45[5];

  if (this == a6)
    goto LABEL_14;
  v13 = *(_QWORD **)this;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v14 = (uint64_t *)*((_QWORD *)a6 + 2);
    v16 = *v14;
    if ((unsigned __int16)v15 != (unsigned __int16)*v14)
      goto LABEL_10;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v22 = *(_QWORD *)(a1 + 48);
      v21 = *(_QWORD *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v44);
      re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)v45);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v44);
      re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)v45);
      re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)this);
      v23 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v43);
      if (!v23)
      {
        v34 = re::TypeInfo::name((re::TypeInfo *)v43);
        return 0;
      }
      v24 = (void (*)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v23;
      v25 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
      result = 0;
      if (!v25)
        return result;
      v27 = *(void (**)(uint64_t, const char **, uint64_t))(v41 + 96);
      re::TypeInfo::TypeInfo((uint64_t)&v44, (uint64_t)v40);
      v27(a4, &v44, v22);
      v28 = (re::DynamicString *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v21 + 32))(v21, 32, 8);
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = 0;
      *((_QWORD *)v28 + 3) = 0;
      *(_QWORD *)v28 = v22;
      re::DynamicString::setCapacity(v28, 0);
      v29 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
      if (v29 && *v29)
      {
        v30 = *((_QWORD *)v29 + 1);
        do
        {
          if ((*(_WORD *)(v30 + 22) & 0x1000) != 0)
            v31 = (const char *)v30;
          else
            v31 = *(const char **)(v30 + 8);
          v32 = strlen(v31);
          v44 = v31;
          v45[0] = v32;
          re::DynamicString::operator=(v28, (uint64_t)&v44);
          v33 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, re::DynamicString *))(v41 + 104))(a4, v40, *(_QWORD *)(a1 + 48), v28);
          v24(a1, v31, 0, v33, v43, v42, 0);
          v30 += 48;
        }
        while (v30 != *((_QWORD *)v29 + 1) + 48 * *v29);
      }
      if (*(_QWORD *)v28)
      {
        if ((*((_BYTE *)v28 + 8) & 1) != 0)
          (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)v28 + 40))(*(_QWORD *)v28, *((_QWORD *)v28 + 2));
        *(_OWORD *)v28 = 0u;
        *((_OWORD *)v28 + 1) = 0u;
      }
      (*(void (**)(uint64_t, re::DynamicString *))(*(_QWORD *)v21 + 40))(v21, v28);
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_14;
  v13 = *(_QWORD **)a6;
  v14 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v13, v14[9], &v44);
  re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)v45);
  v19 = re::TypeInfo::name((re::TypeInfo *)v43);
  if ((unint64_t)*v19 >> 1 == 0x22C6ED80D0CLL)
  {
    v20 = (char *)v19[1];
    if (v20 == "StringID" || !strcmp(v20, "StringID"))
      goto LABEL_14;
  }
  return 0;
}

BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t (*v23)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  unsigned int v24;
  _BOOL8 result;
  uint64_t (*v26)(uint64_t, unint64_t *, uint64_t);
  _anonymous_namespace_ *v27;
  unsigned int *v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  void *v32;
  char v33;
  void *v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  void *v45;
  _BYTE v46[16];
  uint64_t v47;
  _BYTE v48[32];
  _BYTE v49[32];
  unint64_t v50;
  _QWORD v51[5];

  if (this == a6)
    goto LABEL_14;
  v13 = *(_QWORD **)this;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v14 = (uint64_t *)*((_QWORD *)a6 + 2);
    v16 = *v14;
    if ((unsigned __int16)v15 != (unsigned __int16)*v14)
      goto LABEL_10;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v21 = *(_QWORD *)(a1 + 48);
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v50);
      re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v51);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v50);
      re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v51);
      re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)this);
      v22 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v49);
      if (!v22)
      {
        v36 = re::TypeInfo::name((re::TypeInfo *)v49);
        return 0;
      }
      v23 = (uint64_t (*)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v22;
      v24 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
      result = 0;
      if (!v24)
        return result;
      v26 = *(uint64_t (**)(uint64_t, unint64_t *, uint64_t))(v47 + 96);
      re::TypeInfo::TypeInfo((uint64_t)&v50, (uint64_t)v46);
      v27 = (_anonymous_namespace_ *)v26(a4, &v50, v21);
      v44 = 0;
      v45 = &str_110;
      v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
      if (v28 && *v28)
      {
        v29 = *((_QWORD *)v28 + 1);
        do
        {
          if ((*(_WORD *)(v29 + 22) & 0x1000) != 0)
            v30 = (const char *)v29;
          else
            v30 = *(const char **)(v29 + 8);
          v42 = 0;
          v43 = &str_110;
          v31 = v42;
          v32 = v43;
          v42 = 0;
          v43 = &str_110;
          v33 = v44;
          v34 = v45;
          v44 = v31;
          v45 = v32;
          v50 = v31 & 0xFFFFFFFFFFFFFFFELL | v33 & 1;
          v51[0] = v34;
          re::StringID::destroyString((re::StringID *)&v50);
          re::StringID::destroyString((re::StringID *)&v42);
          v35 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, uint64_t *))(v47 + 104))(a4, v46, *(_QWORD *)(a1 + 48), &v44);
          v27 = (_anonymous_namespace_ *)v23(a1, v30, 0, v35, v49, v48, 0);
          v29 += 48;
        }
        while (v29 != *((_QWORD *)v28 + 1) + 48 * *v28);
      }
      re::StringID::destroyString((re::StringID *)&v44);
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_14;
  v13 = *(_QWORD **)a6;
  v14 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v13, v14[9], &v50);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v51);
  v19 = re::TypeInfo::name((re::TypeInfo *)v49);
  if ((unint64_t)*v19 >> 1 == 0x134375A94D9F7110)
  {
    v20 = (char *)v19[1];
    if (v20 == "DynamicString" || !strcmp(v20, "DynamicString"))
      goto LABEL_14;
  }
  return 0;
}

unsigned int *re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(uint64_t a1, char *a2, _QWORD *a3)
{
  unsigned int *result;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if (result)
  {
    if (*((_WORD *)result + 11) == 4)
    {
      v7 = *result;
      *a3 = v7;
      LOBYTE(v8) = 6;
      DWORD1(v8) = 0;
      *((_QWORD *)&v8 + 1) = a2;
      v9 = 0;
      v10 = v7;
      v11 = 0;
      v12 = result;
      re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v8);
      return (unsigned int *)1;
    }
    return 0;
  }
  return result;
}

void re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(uint64_t a1, int a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE *v8;
  _OWORD v9[2];
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  _BYTE v14[23];
  uint64_t v15;
  char v16;

  if (*(_BYTE *)(a1 + 40))
    return;
  v3 = *(_QWORD *)(a1 + 128);
  v4 = *(_QWORD *)(a1 + 112);
  v5 = *(_QWORD *)(v3 + 48 * (v4 - 1) + 40);
  if (!v5)
  {
    v7 = 0;
LABEL_7:
    if (*(_WORD *)(v7 + 22) == 3)
    {
      LOBYTE(v9[0]) = 7;
      DWORD1(v9[0]) = a2;
      *((_QWORD *)&v9[0] + 1) = "entry";
      v9[1] = xmmword_2260F4F20;
      v10 = 0;
      v11 = v7;
      re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, v9);
    }
    else
    {
    }
    return;
  }
  v6 = *(_QWORD *)(v3 + 48 * (v4 - 1) + 32);
  if (*(_DWORD *)v5 > v6)
  {
    v7 = *(_QWORD *)(v5 + 8) + 24 * v6;
    goto LABEL_7;
  }
  if ((v13 & 1) != 0)
    v8 = *(_BYTE **)&v14[7];
  else
    v8 = v14;
  re::DynamicString::format((re::DynamicString *)"Failed to deserialize \"%s\". Index out of range.", (re::DynamicString *)&v15, v8);
  if (v15 && (v16 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  if (v12 && (v13 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v12 + 40))();
}

unsigned int *re::serializeDynamicString<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _QWORD *a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t *v17;
  char *v18;
  unsigned int *result;
  _anonymous_namespace_ *v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;

  if (this == a6)
    goto LABEL_14;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_14;
  }
  v17 = re::TypeInfo::name(a6);
  if ((unint64_t)*v17 >> 1 != 0x22C6ED80D0CLL
    || (v18 = (char *)v17[1], v18 != "StringID") && strcmp(v18, "StringID"))
  {
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v30 = 0;
    result = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v30);
    if (!(_DWORD)result)
      return result;
    if (v30)
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_34;
  }
  v21 = a4[1];
  if ((v21 & 1) != 0)
    v22 = v21 >> 1;
  else
    v22 = v21 >> 1;
  v30 = v22;
  result = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v30);
  if ((_DWORD)result)
  {
    v23 = v30;
    if (v23 <= (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24)))
    {
      if (!*a4)
      {
        *a4 = *(_QWORD *)(a1 + 48);
        re::DynamicString::setCapacity(a4, v23 + 1);
      }
      re::DynamicString::resize(a4, v23, 0);
      if (v23)
      {
        if ((a4[1] & 1) != 0)
          v29 = (char *)a4[2];
        else
          v29 = (char *)a4 + 9;
      }
      v20 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_34:
      return (unsigned int *)(*(_BYTE *)(a1 + 64) == 0);
    }
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
    return 0;
  }
  return result;
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  const re::TypeInfo *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t i;
  uint64_t v29;
  uint64_t v30;
  re *v31;
  uint64_t v32;
  uint64_t v33;
  _DWORD *v34;
  NSObject *v35;
  uint64_t v36;
  re::internal *v37;
  uint64_t v38;
  _BYTE v39[32];
  _BYTE v40[32];
  _QWORD *v41[2];
  uint64_t v42;
  _QWORD *v43[2];
  uint64_t v44;
  uint64_t v45[4];
  unint64_t v46;
  uint64_t v47[5];
  _BYTE v48[8];
  uint64_t v49;
  char v50;
  uint64_t *v51;
  _BYTE v52[8];
  uint64_t v53;
  char v54;
  uint64_t *v55;
  uint8_t buf[4];
  uint64_t v57;
  __int16 v58;
  uint64_t v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  re::TypeRegistry::typeInfo((_QWORD *)*a3, *(_QWORD *)(a3[2] + 72), v52);
  re::TypeRegistry::typeInfo((_QWORD *)*a4, *(_QWORD *)(a4[2] + 72), v48);
  if (v48[0])
  {
    if (!v52[0])
    {
      v11 = re::TypeInfo::name((re::TypeInfo *)&v49)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
    }
    if (v53 == v49)
    {
      v18 = *v55;
      v19 = *v51;
      if ((unsigned __int16)*v55 == (unsigned __int16)*v51)
      {
        v21 = WORD1(v18) == WORD1(v19);
        v20 = (v19 ^ v18) & 0xFFFFFF00000000;
        v21 = v21 && v20 == 0;
        if (v21)
          goto LABEL_5;
      }
    }
    else if (re::areSameTranslatedVersion((re *)&v53, (const re::TypeInfo *)&v49, v10))
    {
LABEL_5:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>((_BYTE *)a1, a2, &v53, a5);
      goto LABEL_15;
    }
    if (v54 == v50)
    {
      re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, a2, &v53, &v49, a5);
    }
    else
    {
      v22 = re::TypeInfo::name((re::TypeInfo *)&v53)[1];
      re::TypeInfo::name((re::TypeInfo *)&v49);
    }
  }
LABEL_15:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v47, *a3, a3[2]);
  result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v45, *a4, a4[2]);
  if (v46)
  {
    for (i = 0; i < v46; ++i)
    {
      if (*(_BYTE *)(a1 + 64))
        break;
      result = (uint64_t)re::TypeMemberCollection::operator[](v45, i, (uint64_t)v43);
      if (*(_BYTE *)(v44 + 28))
      {
        v29 = *(_QWORD *)(v44 + 16);
        if (strlen((const char *)v29) >= 3 && *(_BYTE *)v29 == 109)
          v29 += 2 * (*(_BYTE *)(v29 + 1) == 95);
        v30 = *(unsigned int *)(v44 + 32);
        v31 = *(re **)(*a4 + 856);
        if (!v31
          || (v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v43),
              (_DWORD)v31 == -1))
        {
          v35 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
          {
            v36 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            v57 = v36;
            v58 = 2080;
            v59 = v29;
            _os_log_impl(&dword_224FE9000, v35, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);
          }
          v37 = *(re::internal **)(a1 + 272);
          re::TypeRegistry::typeInfo(v43[0], *(_QWORD *)v44, buf);
          re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v57 + 4);
          result = re::internal::translateType(v37, (const re::TypeRegistry *)v41, (uint64_t)buf);
          if (!*(_BYTE *)(a1 + 64))
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint8_t *, uint8_t *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
        }
        else
        {
          re::TypeMemberCollection::operator[](v47, (int)v31, (uint64_t)v41);
          v32 = a2 + *(unsigned int *)(v42 + 24);
          re::TypeRegistry::typeInfo(v41[0], *(_QWORD *)v42, buf);
          re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v57 + 4);
          re::TypeRegistry::typeInfo(v43[0], *(_QWORD *)v44, buf);
          re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v57 + 4);
          if (*(_BYTE *)(a1 + 64)
            || (result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, v32, v40, v39, a5), (result & 1) == 0))
          {
            result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a4);
            if (v33)
            {
              v34 = (_DWORD *)(result + 16);
              while (i != *v34)
              {
                v34 += 6;
                if (!--v33)
                  goto LABEL_35;
              }
              v38 = *((_QWORD *)v34 - 1);
              re::TypeRegistry::typeInfo(v41[0], *(_QWORD *)v42, buf);
              re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v57 + 4);
              re::TypeRegistry::typeInfo(v43[0], *(_QWORD *)v44, buf);
              result = re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v57 + 4);
              if (!*(_BYTE *)(a1 + 64))
                result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v38, v30, v32, v40, v39, a5);
            }
          }
        }
      }
LABEL_35:
      ;
    }
  }
  return result;
}

unsigned int *re::serializeBool<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, BOOL *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeChar<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _BYTE *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeI8<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _BYTE *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeI16<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _WORD *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeI32<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned int *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeI64<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unint64_t *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeU8<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _BYTE *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeU16<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _WORD *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeU32<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _DWORD *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeU64<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _QWORD *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeFloat<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, float *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
    return re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, a4, a7);
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    return re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, a4, a7);
  }
  return 0;
}

unsigned int *re::serializeDouble<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, double *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
    return re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, a4, a7);
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    return re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, a4, a7);
  }
  return 0;
}

unsigned int *re::serializeCString<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, const char **a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int *result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  size_t v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  char v40;
  size_t v41;
  int v42;

  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_23:
      return 0;
    }
    v20 = **((_QWORD **)this + 2);
    v21 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v20 != (unsigned __int16)v21)
      goto LABEL_23;
    v23 = WORD1(v20) == WORD1(v21);
    v22 = (v21 ^ v20) & 0xFFFFFF00000000;
    v23 = v23 && v22 == 0;
    if (!v23)
      goto LABEL_23;
  }
LABEL_4:
  if (a7)
  {
    v42 = 0;
    v18 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v42);
    result = 0;
    if (!v18)
      return result;
    if (!v42)
      goto LABEL_12;
    if (v42 != 1)
    {
      v41 = 0;
      if (re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v41))
      {
        if (v41)
      }
LABEL_12:
      goto LABEL_47;
    }
    goto LABEL_17;
  }
  v42 = 2 * (*a4 != 0);
  result = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v42);
  if (!(_DWORD)result)
    return result;
  if (v42)
  {
    if (v42 == 2)
    {
      if (*a4)
        v24 = strlen(*a4);
      else
        v24 = 0;
      v41 = v24;
      if (re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v41))
      {
        v25 = (char *)*a4;
        v26 = v41;
        if (!*a4 || v41 != v24)
        {
          if (v25)
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
            *a4 = 0;
          }
          if (v26 > (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24)))
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
            return 0;
          }
          v37 = v26 == -1;
          v38 = v37 << 63 >> 63;
          if (v38 != v37 || v38 < 0)
          {
            return 0;
          }
          v25 = (char *)(*(uint64_t (**)(_QWORD, unint64_t, _QWORD))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v26 + 1, 0);
          *a4 = v25;
          v24 = v26;
        }
        if (v24)
        {
          v25 = (char *)*a4;
        }
        else
        {
          v26 = 0;
        }
        v25[v26] = 0;
      }
    }
    else if (v42 == 1)
    {
LABEL_17:
      return 0;
    }
  }
  else if (*a4)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
    *a4 = 0;
  }
  v39 = *(unsigned __int8 *)(a1 + 64);
  if (!*a4 || !*(_BYTE *)(a1 + 64))
    return (unsigned int *)(v39 == 0);
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
  *a4 = 0;
LABEL_47:
  v39 = *(unsigned __int8 *)(a1 + 64);
  return (unsigned int *)(v39 == 0);
}

unsigned int *re::serializeStringID<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t *a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t *v17;
  char *v18;
  unsigned int *result;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  _anonymous_namespace_ *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;

  if (this == a6)
    goto LABEL_14;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_14;
  }
  v17 = re::TypeInfo::name(a6);
  if ((unint64_t)*v17 >> 1 != 0x134375A94D9F7110
    || (v18 = (char *)v17[1], v18 != "DynamicString") && strcmp(v18, "DynamicString"))
  {
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v43 = 0;
    result = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v43);
    if (!(_DWORD)result)
      return result;
    if (v43)
    goto LABEL_26;
  }
  v42 = 0;
  if (re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v42))
  {
    v20 = v42;
    if (v42)
    {
      if (v20 > (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24)))
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
        return 0;
      }
      v32 = v20 == -1;
      v33 = v32 << 63 >> 63;
      if (v33 != v32 || v33 < 0)
      {
        return 0;
      }
      v34 = (char *)(*(uint64_t (**)(_QWORD, unint64_t, _QWORD))(**(_QWORD **)(a1 + 56) + 32))(*(_QWORD *)(a1 + 56), v20 + 1, 0);
      v34[v20] = 0;
      v40 = 0;
      v41 = &str_110;
      v36 = v40;
      v37 = (uint64_t)v41;
      v40 = 0;
      v41 = &str_110;
      v38 = *a4;
      v39 = a4[1];
      *a4 = v36;
      a4[1] = v37;
      v43 = v36 & 0xFFFFFFFFFFFFFFFELL | v38 & 1;
      v44 = v39;
      re::StringID::destroyString((re::StringID *)&v43);
      re::StringID::destroyString((re::StringID *)&v40);
      (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 56) + 40))(*(_QWORD *)(a1 + 56), v34);
    }
    else
    {
      v40 = 0;
      v41 = &str_110;
      v31 = a4[1];
      v43 = *a4 & 1;
      v44 = v31;
      *a4 = 0;
      a4[1] = (uint64_t)&str_110;
      re::StringID::destroyString((re::StringID *)&v43);
      re::StringID::destroyString((re::StringID *)&v40);
    }
LABEL_26:
    return (unsigned int *)(*(_BYTE *)(a1 + 64) == 0);
  }
  return 0;
}

unsigned int *re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned int *result;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  char *v19;
  char *v20;
  re *v21;
  NSObject *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  _QWORD *v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  unint64_t v33;
  _BYTE buf[22];
  __int16 v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_4;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v25 = **((_QWORD **)this + 2);
    v26 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v25 == (unsigned __int16)v26)
    {
      v28 = WORD1(v25) == WORD1(v26);
      v27 = (v26 ^ v25) & 0xFFFFFF00000000;
      v28 = v28 && v27 == 0;
      if (v28)
        goto LABEL_4;
    }
LABEL_33:
    return 0;
  }
  if (!re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_33;
LABEL_4:
  if (a7)
  {
    v29 = 0;
    result = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v29);
    if (!(_DWORD)result)
      return result;
    if (v29)
  }
  else
  {
    v14 = **((_QWORD **)this + 2);
    v29 = *(_QWORD **)this;
    v30 = v14;
    LODWORD(v31) = -1;
    *(_QWORD *)buf = 0x258C98EAAF29A10ALL;
    *(_QWORD *)&buf[8] = "CallbackSerializerAttribute";
    v15 = (uint64_t *)re::TypeAttributeCollection::operator[]((uint64_t *)&v29, buf);
    re::StringID::destroyString((re::StringID *)buf);
    v16 = *v15;
    v17 = *(_QWORD *)(a1 + 264);
    v33 = 0;
    result = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v33);
    if (!(_DWORD)result)
      return result;
    v18 = *(_QWORD **)(a1 + 56);
    v31 = 0;
    v32 = 0;
    v29 = v18;
    v30 = 0;
    re::DynamicString::setCapacity(&v29, 0);
    if (v33)
    {
      re::DynamicString::resize(&v29, v33, 0);
      if ((v30 & 1) != 0)
        v19 = v31;
      else
        v19 = (char *)&v30 + 1;
    }
    if ((v30 & 1) != 0)
      v20 = v31;
    else
      v20 = (char *)&v30 + 1;
    v21 = (re *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, char *))(v16 + 80))(*(_QWORD *)(a1 + 48), v17, v16, a4, v20);
    if ((v21 & 1) == 0)
    {
      v22 = *re::foundationSerializationLogObjects(v21);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        if ((v30 & 1) != 0)
          v23 = v31;
        else
          v23 = (char *)&v30 + 1;
        v24 = re::TypeInfo::name(this)[1];
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = a2;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v23;
        v35 = 2080;
        v36 = v24;
        _os_log_impl(&dword_224FE9000, v22, OS_LOG_TYPE_INFO, "Failed to parse \"%s\": \"%s\" (type %s) using deserialization callback - skipping.", buf, 0x20u);
      }
    }
    if (v29 && (v30 & 1) != 0)
      (*(void (**)(void))(*v29 + 40))();
  }
  return (unsigned int *)(*(_BYTE *)(a1 + 64) == 0);
}

unsigned int *re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(uint64_t a1, char *a2, int *a3)
{
  unsigned int *result;
  unsigned int *v7;
  int v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if (result)
  {
    v7 = result;
    v8 = *((unsigned __int16 *)result + 11);
    if (*((_WORD *)result + 11))
    {
      if (v8 != 3
        || (int *)(*((_QWORD *)result + 1) + 48 * *result) == rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::FindMember(result, "@ref"))
      {
        v8 = 2;
        v9 = 1;
      }
      else
      {
        v9 = 1;
        v8 = 1;
      }
    }
    else
    {
      v9 = *((unsigned __int16 *)result + 11);
    }
    *a3 = v8;
    LOBYTE(v10) = 9;
    DWORD1(v10) = 0;
    *((_QWORD *)&v10 + 1) = a2;
    v11 = 0;
    v12 = v9;
    v13 = 0;
    v14 = v7;
    re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v10);
    return (unsigned int *)1;
  }
  return result;
}

BOOL re::SerializerV1<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString(uint64_t a1, char *a2, const re::TypeInfo *a3, char **a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  _anonymous_namespace_ *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  __int128 v44;
  uint64_t v45;
  unsigned __int16 v46;
  unsigned __int16 v47;
  int v48;
  unsigned int v49;
  int v50;

  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_15:
      return 0;
    }
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 != (unsigned __int16)v14)
      goto LABEL_15;
    v16 = WORD1(v13) == WORD1(v14);
    v15 = (v14 ^ v13) & 0xFFFFFF00000000;
    v16 = v16 && v15 == 0;
    if (!v16)
      goto LABEL_15;
  }
LABEL_4:
  v50 = 0;
  if (re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v50))
  {
    if (v50 == 1)
    {
      v49 = 0;
      re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference((unsigned int *)(a1 + 24), &v49);
      if (!*(_BYTE *)(a1 + 64))
      {
        v23 = v49;
        if (*(_QWORD *)(a1 + 408) <= (unint64_t)v49)
        {
        }
        else
        {
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v49, (uint64_t)&v45);
          if (v45 == *(_QWORD *)this)
          {
            v24 = **((_QWORD **)this + 2);
            if (v46 == (unsigned __int16)v24 && v47 == WORD1(v24) && ((v48 ^ HIDWORD(v24)) & 0xFFFFFF) == 0)
            {
              if ((a7 & 1) == 0)
              {
                if (*a4)
                {
                  v42 = *a4;
                  if (v42 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v23))
                  {
                    (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48), *a4);
                    *a4 = 0;
                  }
                }
                *a4 = (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v23);
                re::internal::SharedObjectGraph::addReference((_QWORD *)(a1 + 336), v23);
              }
              goto LABEL_36;
            }
          }
          v25 = *(_anonymous_namespace_ **)(a1 + 272);
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v23, (uint64_t)&v45);
          v43 = *((_QWORD *)re::TypeRegistry::typeName(v25, &v45) + 1);
        }
      }
    }
    else
    {
      if (!v50)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
            *a4 = 0;
          }
        }
LABEL_36:
        return *(_BYTE *)(a1 + 64) == 0;
      }
      if ((a7 & 1) == 0 && *a4)
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
        *a4 = 0;
      }
      v45 = 0;
      if (re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, &v45))
      {
        v36 = v45;
        v37 = v45 == -1;
        v38 = v37 << 63 >> 63;
        if (v38 == v37 && (v38 & 0x8000000000000000) == 0)
        {
          v39 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v45 + 1, 0);
          v40 = (uint64_t)v39;
          if ((a7 & 1) == 0)
            *a4 = v39;
          if (v36)
          *(_BYTE *)(v40 + v36) = 0;
          v41 = **((_QWORD **)this + 2);
          *(_QWORD *)&v44 = *(_QWORD *)this;
          *((_QWORD *)&v44 + 1) = v41;
          re::internal::SharedObjectGraph::addObject(a1 + 336, v40, &v44);
          goto LABEL_36;
        }
      }
    }
  }
  return 0;
}

BOOL re::SerializerV1<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer(uint64_t a1, char *a2, int a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, int a7)
{
  const re::TypeInfo *v13;
  _BOOL4 isPointerToPolymorphicType;
  int v15;
  re *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  uint64_t *v29;
  uint64_t *v30;
  unsigned int v32;
  char *v33;
  uint64_t v34;
  char **v35;
  void **v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  uint64_t v45;
  char v46;
  unsigned __int8 *v47;
  int v48;
  re::TypeRegistry *v49;
  uint64_t *v50;
  char *v51;
  uint64_t v52;
  re *v53;
  uint64_t v54;
  _anonymous_namespace_ *v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t *v60;
  const char *v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  re::TypeRegistry *v65;
  NSObject *v66;
  uint64_t *v67;
  uint64_t *v68;
  re *v69;
  uint64_t v70;
  void (*v71)(uint64_t);
  NSObject *v72;
  uint64_t v73;
  void **Instance;
  void **v75;
  char v76;
  uint64_t v77;
  char *__s2;
  __int128 v79;
  re *v80[2];
  _BYTE v81[20];
  int v82;
  _QWORD v83[2];
  uint64_t *v84;
  re *v85[2];
  re *v86[2];
  uint64_t *v87;
  _QWORD v88[2];
  re **v89;
  _QWORD v90[2];
  re *v91[4];
  re *v92;
  uint64_t v93;
  _QWORD v94[2];
  __int128 buf;
  uint64_t *v96;
  uint64_t v97;

  v97 = *MEMORY[0x24BDAC8D0];
  isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6)
    goto LABEL_4;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v25 = **((_QWORD **)this + 2);
    v26 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v25 == (unsigned __int16)v26)
    {
      v28 = WORD1(v25) == WORD1(v26);
      v27 = (v26 ^ v25) & 0xFFFFFF00000000;
      v28 = v28 && v27 == 0;
      if (v28)
        goto LABEL_4;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v13))
  {
LABEL_4:
    v15 = 0;
    goto LABEL_5;
  }
  if (*((_BYTE *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (v29 = re::TypeInfo::name(this), v30 = re::TypeInfo::name(a6), !re::StringID::operator==(v29, v30))))
  {
    return 0;
  }
  v15 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &buf);
  re::TypeInfo::TypeInfo((uint64_t)v88, (uint64_t)&buf + 8);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &buf);
  re::TypeInfo::TypeInfo((uint64_t)v86, (uint64_t)&buf + 8);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    v16 = *v89;
    v85[0] = (re *)v88[0];
    v85[1] = v16;
    if (v88[0])
      goto LABEL_8;
LABEL_15:
    v77 = re::TypeInfo::name(this)[1];
    v22 = "Failed to get actual type of polymorphic object. Type \"%s\".";
    v23 = a1;
    v24 = a2;
LABEL_16:
    return 0;
  }
  re::internal::actualType(a4, (void **)this, v85);
  if (!v85[0])
    goto LABEL_15;
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, v85, &buf);
  re::TypeInfo::TypeInfo((uint64_t)v83, (uint64_t)&buf + 8);
  v82 = 0;
  if (re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v82))
  {
    if (v82 != 1)
    {
      if (!v82)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)v83, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
            *a4 = 0;
          }
        }
        goto LABEL_111;
      }
      if (isPointerToPolymorphicType)
      {
        if (re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0))
        {
          v42 = *(_QWORD *)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
          if (*(_DWORD *)v42)
          {
            v43 = *(char **)(v42 + 8);
            if ((*((_WORD *)v43 + 11) & 0x1000) != 0)
              v44 = v43;
            else
              v44 = (char *)*((_QWORD *)v43 + 1);
            if (v44)
            {
              v45 = *v44;
              if (*v44)
              {
                v46 = v44[1];
                if (v46)
                {
                  v47 = (unsigned __int8 *)(v44 + 2);
                  do
                  {
                    v45 = 31 * v45 + v46;
                    v48 = *v47++;
                    v46 = v48;
                  }
                  while (v48);
                }
              }
            }
            else
            {
              v45 = 0;
            }
            v56 = 2 * v45;
            __s2 = v44;
            v94[0] = 2 * v45;
            v94[1] = v44;
            v57 = *((_DWORD *)v87 + 20);
            v58 = (v57 - 1);
            if (v57 == 1)
              goto LABEL_80;
            v59 = 0;
            while (1)
            {
              re::TypeInfo::derivedClass((re::TypeInfo *)v86, v59, (uint64_t)&buf);
              v60 = re::TypeInfo::polymorphicObjectName((re::TypeInfo *)&buf);
              if ((*v60 ^ (unint64_t)v56) <= 1)
              {
                v61 = (const char *)v60[1];
                if (v61 == __s2 || !strcmp(v61, __s2))
                  break;
              }
              if (v58 == ++v59)
                goto LABEL_80;
            }
            v62 = *v96;
            v92 = (re *)buf;
            v93 = v62;
            if (!(_QWORD)buf)
            {
LABEL_80:
              v63 = re::TypeInfo::polymorphicObjectName((re::TypeInfo *)v86);
              if ((*v63 ^ (unint64_t)v56) > 1
                || (v63 = (uint64_t *)v63[1], v63 != (uint64_t *)__s2)
                && (v63 = (uint64_t *)strcmp((const char *)v63, __s2), (_DWORD)v63)
                || (v64 = *v87, v92 = v86[0], v93 = v64, !v86[0]))
              {
                v66 = *re::foundationSerializationLogObjects((re *)v63);
                if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
                {
                  LODWORD(buf) = 136315138;
                  *(_QWORD *)((char *)&buf + 4) = __s2;
                  _os_log_error_impl(&dword_224FE9000, v66, OS_LOG_TYPE_ERROR, "Skipping unknown polymorphic type. Type name = \"%s\"", (uint8_t *)&buf, 0xCu);
                  if ((a7 & 1) != 0)
                    goto LABEL_110;
                }
                else if ((a7 & 1) != 0)
                {
LABEL_110:
                  re::StringID::destroyString((re::StringID *)v94);
                  goto LABEL_111;
                }
                if (*a4)
                {
                  re::TypeInfo::releaseInstance((re::TypeInfo *)v83, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
                  *a4 = 0;
                }
                goto LABEL_110;
              }
            }
            if ((a7 & 1) == 0 && *a4)
            {
              re::TypeInfo::releaseInstance((re::TypeInfo *)v83, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
              *a4 = 0;
            }
            re::TypeRegistry::typeInfo(v86[0], &v92, &buf);
            re::TypeInfo::TypeInfo((uint64_t)v91, (uint64_t)&buf + 8);
            if (v15)
            {
              v65 = *(re::TypeRegistry **)(a1 + 272);
            }
            else
            {
              v65 = *(re::TypeRegistry **)(a1 + 272);
              if (*(re::TypeRegistry **)this == v65)
              {
                re::TypeInfo::operator=((uint64_t)v83, (uint64_t)v91);
                v69 = v92;
                v70 = v93;
                goto LABEL_105;
              }
            }
            v67 = re::TypeInfo::name((re::TypeInfo *)v91);
            v68 = re::TypeRegistry::typeInfo(v65, (const re::StringID *)v67, &buf);
            if (!(_BYTE)buf)
            {
              v72 = *re::foundationSerializationLogObjects((re *)v68);
              if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
              {
                v73 = re::TypeInfo::name((re::TypeInfo *)v91)[1];
                LODWORD(buf) = 136315138;
                *(_QWORD *)((char *)&buf + 4) = v73;
                _os_log_impl(&dword_224FE9000, v72, OS_LOG_TYPE_DEFAULT, "No matching runtime type found for serialized polymorphic type \"%s\". Skipping unknown type.", (uint8_t *)&buf, 0xCu);
              }
              *(_QWORD *)&buf = 0;
              *((_QWORD *)&buf + 1) = 0xFFFFFFFFLL;
              (*(void (**)(uint64_t, _QWORD, __int128 *))(*(_QWORD *)a1 + 16))(a1, 0, &buf);
              if (!*(_BYTE *)(a1 + 64))
                (*(void (**)(uint64_t, char *, _QWORD, _QWORD, re **, re **, uint64_t))(*(_QWORD *)a1 + 72))(a1, __s2, 0, 0, v91, v91, 1);
              goto LABEL_109;
            }
            re::TypeInfo::operator=((uint64_t)v83, (uint64_t)&buf + 8);
            v69 = (re *)v83[0];
            v70 = *v84;
LABEL_105:
            Instance = re::TypeInfo::createInstance((re::TypeInfo *)v83, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
            v75 = Instance;
            if ((a7 & 1) == 0)
            {
              *a4 = (char *)Instance;
              *(_QWORD *)&buf = v69;
              *((_QWORD *)&buf + 1) = v70;
              re::internal::setActualType(a4, (re **)this, (re **)&buf);
            }
            v90[0] = v69;
            v90[1] = v70;
            (*(void (**)(uint64_t, void **, _QWORD *))(*(_QWORD *)a1 + 16))(a1, v75, v90);
            if (!*(_BYTE *)(a1 + 64))
              (*(void (**)(uint64_t, char *, _QWORD, void **, _QWORD *, re **, BOOL))(*(_QWORD *)a1 + 72))(a1, __s2, 0, v75, v83, v91, v75 == 0);
LABEL_109:
            (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
            goto LABEL_110;
          }
        }
LABEL_111:
        return *(_BYTE *)(a1 + 64) == 0;
      }
      if (!a7)
      {
        v51 = *a4;
        if (!*a4)
          v51 = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v88, *(re::Allocator **)(a1 + 48), 0);
        v52 = 0;
        *a4 = v51;
        goto LABEL_62;
      }
      v49 = *(re::TypeRegistry **)(a1 + 272);
      if ((re::TypeRegistry *)v88[0] != v49)
      {
        v50 = re::TypeInfo::name((re::TypeInfo *)v88);
        re::TypeRegistry::typeInfo(v49, (const re::StringID *)v50, &buf);
        if (!(_BYTE)buf)
        {
          v51 = 0;
          v52 = 1;
          goto LABEL_62;
        }
        re::TypeInfo::operator=((uint64_t)v88, (uint64_t)&buf + 8);
      }
      v51 = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v88, *(re::Allocator **)(a1 + 48), 0);
      v52 = 0;
LABEL_62:
      v53 = *v89;
      *(_QWORD *)&v79 = v88[0];
      *((_QWORD *)&v79 + 1) = v53;
      re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), (uint64_t)v51, &v79);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, char *, _QWORD, char *, _QWORD *, re **, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, 0, v51, v88, v86, v52);
      if (*(_BYTE *)(a1 + 336))
      {
        --*(_QWORD *)(a1 + 488);
        ++*(_DWORD *)(a1 + 496);
      }
      goto LABEL_111;
    }
    LODWORD(v94[0]) = 0;
    re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference((unsigned int *)(a1 + 24), v94);
    if (!*(_BYTE *)(a1 + 64))
    {
      v32 = v94[0];
      if (*(_QWORD *)(a1 + 408) > (unint64_t)LODWORD(v94[0]))
      {
        re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v94[0], (uint64_t)v81);
        if (!re::internal::areCompatible((re **)this, (uint64_t)v81))
        {
          v54 = re::TypeInfo::name((re::TypeInfo *)v88)[1];
          v55 = *(_anonymous_namespace_ **)(a1 + 272);
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v32, (uint64_t)&buf);
          LOBYTE(v77) = v54;
          re::TypeRegistry::typeName(v55, &buf);
          v22 = "Invalid reference. Objects are not compatible. Expected type \"%s\". Actual type \"%s\".";
          goto LABEL_68;
        }
        if ((a7 & 1) != 0)
          goto LABEL_111;
        if (*a4)
        {
          v33 = *a4;
          if (v33 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v32))
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)v83, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
            *a4 = 0;
          }
        }
        v34 = re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v32);
        v35 = (char **)v34;
        *a4 = (char *)v34;
        if ((*((_BYTE *)v84 + 49) & 2) != 0)
        {
          v71 = (void (*)(uint64_t))v84[4];
          if (v71)
            v71(v34);
          re::internal::SharedObjectGraph::addReference((_QWORD *)(a1 + 336), v32);
        }
        else
        {
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v32, (uint64_t)v91);
          if (!v91[0])
          {
            LOBYTE(v77) = v32;
            v22 = "TypeID for shared object at index %d is invalid.";
            goto LABEL_68;
          }
          re::TypeRegistry::typeInfo(v91[0], v91, &buf);
          if (!(_BYTE)buf)
          {
            LOBYTE(v77) = v32;
            v22 = "No TypeInfo found for shared object at index %d.";
            goto LABEL_68;
          }
          v36 = re::TypeInfo::createInstance((re::TypeInfo *)((char *)&buf + 8), *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
          *a4 = (char *)v36;
          if ((re::TypeInfo::copy((re::TypeInfo *)((char *)&buf + 8), v36, v35, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264)) & 1) == 0)
          {
            v77 = re::TypeInfo::name((re::TypeInfo *)((char *)&buf + 8))[1];
            v22 = "Failed to copy non-shareable object of type '%s'.";
LABEL_68:
            v23 = a1;
            v24 = 0;
            goto LABEL_16;
          }
        }
        re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v32, (uint64_t)v80);
        re::TypeInfo::setActualTypeForPointer((_QWORD **)this, (uint64_t)a4, v80);
        goto LABEL_111;
      }
      LOBYTE(v77) = v94[0];
      v22 = "Invalid reference ID for shared object: %u";
      goto LABEL_68;
    }
  }
  return 0;
}

unsigned int *re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference(unsigned int *result, _DWORD *a2)
{
  _anonymous_namespace_ *v3;

  if (!*((_BYTE *)result + 40))
  {
    v3 = (_anonymous_namespace_ *)result;
    result = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((uint64_t)result, 0, 0);
    if ((_DWORD)result)
    {
    }
  }
  return result;
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  double v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_24ED88BD8;
  if (*(_QWORD *)(a1 + 272))
  {
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(a1 + 288);
    *(_QWORD *)(a1 + 272) = 0;
  }
  v2 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)(a1 + 288));
  v3 = *(_QWORD *)(a1 + 216);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 248))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v3 + 40))(v3, v2);
    *(_QWORD *)(a1 + 248) = 0;
    *(_QWORD *)(a1 + 224) = 0;
    *(_QWORD *)(a1 + 232) = 0;
    *(_QWORD *)(a1 + 216) = 0;
    ++*(_DWORD *)(a1 + 240);
  }
  v4 = *(_QWORD *)(a1 + 120);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 152))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 152) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = 0;
    *(_QWORD *)(a1 + 120) = 0;
    ++*(_DWORD *)(a1 + 144);
  }
  if (*(_BYTE *)(a1 + 64))
  {
    v5 = *(_QWORD *)(a1 + 88);
    if (v5)
    {
      if ((*(_BYTE *)(a1 + 96) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *(_QWORD *)(a1 + 104));
      *(_OWORD *)(a1 + 88) = 0u;
      *(_OWORD *)(a1 + 104) = 0u;
    }
  }
  re::StringID::destroyString((re::StringID *)(a1 + 8));
  return a1;
}

void re::SerializerV1<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED88B70;
  v2 = *(_QWORD *)(a1 + 472);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 504))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 480) = 0;
    *(_QWORD *)(a1 + 488) = 0;
    *(_QWORD *)(a1 + 472) = 0;
    ++*(_DWORD *)(a1 + 496);
  }
  v3 = *(_QWORD *)(a1 + 432);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 464))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 464) = 0;
    *(_QWORD *)(a1 + 440) = 0;
    *(_QWORD *)(a1 + 448) = 0;
    *(_QWORD *)(a1 + 432) = 0;
    ++*(_DWORD *)(a1 + 456);
  }
  v4 = *(_QWORD *)(a1 + 392);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 344));
  re::Serializer<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::SerializerV1<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::trackObject(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v4;

  v4 = *a3;
  return re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), a2, &v4);
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::untrackObject(uint64_t result)
{
  if (*(_BYTE *)(result + 336))
  {
    --*(_QWORD *)(result + 488);
    ++*(_DWORD *)(result + 496);
  }
  return result;
}

void re::SerializerV1<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doOpen(uint64_t a1)
{
  *(_BYTE *)(a1 + 337) = 1;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 344);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
  *(_QWORD *)(a1 + 448) = 0;
  ++*(_DWORD *)(a1 + 456);
  *(_QWORD *)(a1 + 488) = 0;
  ++*(_DWORD *)(a1 + 496);
}

void re::SerializerV1<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doClose(uint64_t a1)
{
  re::internal::SharedObjectGraph::markAndSweep((re::internal::SharedObjectGraph *)(a1 + 336), *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 344);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
  *(_QWORD *)(a1 + 448) = 0;
  ++*(_DWORD *)(a1 + 456);
  *(_QWORD *)(a1 + 488) = 0;
  ++*(_DWORD *)(a1 + 496);
}

void re::Serializer<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doRegisterSerializeFuncs(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 *v7;
  __int128 v8;
  __int128 v9;
  _QWORD v10[2];
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;

  v11 = 6059476;
  v12 = "BOOL";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeBool<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6104748;
  v12 = "char";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeChar<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x172E117BCLL;
  v12 = "int8_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI8<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93A4A92;
  v12 = "int16_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI16<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93BFE06;
  v12 = "int32_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI32<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93EC744;
  v12 = "int64_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6655224;
  v12 = "long";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x31CD534126;
  v12 = "uint8_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU8<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0D4E68;
  v12 = "uint16_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU16<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0F01DCLL;
  v12 = "uint32_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU32<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD11CB1ALL;
  v12 = "uint64_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x1947BDF6CLL;
  v12 = "size_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 195052728;
  v12 = "float";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeFloat<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x161EEF7A2;
  v12 = "double";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDouble<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 189247272;
  v12 = "char*";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeCString<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2686EB529B3EE220;
  v12 = "DynamicString";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDynamicString<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x458DDB01A18;
  v12 = "StringID";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeStringID<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v2 = *(_QWORD *)(a1 + 272);
  v11 = 0x258C98EAAF29A10ALL;
  v12 = "CallbackSerializerAttribute";
  v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v11);
  if (v3)
  {
    v4 = *v3;
    re::StringID::destroyString((re::StringID *)&v11);
    if (v2)
    {
      v5 = *(_QWORD *)(a1 + 272);
      v10[0] = v2;
      v10[1] = v4;
      re::TypeRegistry::attributesByAttributeType(v5, (uint64_t)v10, (uint64_t)&v11);
      if (v13)
      {
        v6 = 48 * v13;
        v7 = (__int128 *)(v14 + 16);
        do
        {
          v8 = *v7;
          v7 += 3;
          v9 = v8;
          re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, (uint64_t)&v9, (uint64_t)re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
          v6 -= 48;
        }
        while (v6);
      }
      if (v11)
      {
        if (v14)
          (*(void (**)(void))(*(_QWORD *)v11 + 40))();
      }
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v11);
  }
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t result;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;

  v14 = (_BYTE *)(a1 + 336);
  v15 = *(_QWORD *)(a1 + 488);
  if (!v15)
  {
    if ((_DWORD)a7)
      v16 = 0;
    else
      v16 = a4;
    v17 = **((_QWORD **)a5 + 2);
    *(_QWORD *)&v26 = *(_QWORD *)a5;
    *((_QWORD *)&v26 + 1) = v17;
    re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), v16, &v26);
  }
  v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v18)
  {
    result = v18(a1, a2, a3, a4, a5, a6, a7);
    if (!v15)
    {
      if (*v14)
      {
        --*(_QWORD *)(a1 + 488);
        ++*(_DWORD *)(a1 + 496);
      }
    }
  }
  else
  {
    v20 = re::TypeInfo::name(a5);
    return 0;
  }
  return result;
}

BOOL (*re::SerializerV1<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, re::TypeInfo *this))(uint64_t a1, char *a2, int a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, int a7)
{
  uint64_t *v4;
  uint64_t v5;
  char *v6;
  unsigned int v7;
  BOOL (*result)(uint64_t, char *, int, char **, re::TypeInfo *, const re::TypeInfo *, int);
  uint64_t v9;

  v4 = re::TypeInfo::name(this);
  if ((unint64_t)*v4 >> 1 == 94623636)
  {
    v6 = (char *)v4[1];
    if (v6 == "char*" || !strcmp(v6, "char*"))
      return (BOOL (*)(uint64_t, char *, int, char **, re::TypeInfo *, const re::TypeInfo *, int))re::SerializerV1<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString;
  }
  if (*((_BYTE *)this + 12) == 9)
  {
    v7 = *(unsigned __int8 *)(*((_QWORD *)this + 2) + 80);
    if (v7 >= 2)
    {
      if (v7 == 2)
      {
        re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) External references are not supported by the SerializerV1.", "!\"Unreachable code\"", "doResolveSerializeFunc", 82);
        _os_crash();
        __break(1u);
      }
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Invalid PointerSharing type.", "!\"Unreachable code\"", "doResolveSerializeFunc", 84);
      result = (BOOL (*)(uint64_t, char *, int, char **, re::TypeInfo *, const re::TypeInfo *, int))_os_crash();
      __break(1u);
    }
    else
    {
      return re::SerializerV1<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer;
    }
  }
  else if (*(_QWORD *)this == *(_QWORD *)(a1 + 272)
         && (v9 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, **((_QWORD **)this + 2) | 0xFFFFFFFF00000000)) != 0)
  {
    return *(BOOL (**)(uint64_t, char *, int, char **, re::TypeInfo *, const re::TypeInfo *, int))v9;
  }
  else
  {
    return (BOOL (*)(uint64_t, char *, int, char **, re::TypeInfo *, const re::TypeInfo *, int))re::serializeType<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  }
  return result;
}

void re::Serializer<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  re::Serializer<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t (*v14)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v14)
    return v14(a1, a2, a3, a4, a5, a6, a7);
  v16 = re::TypeInfo::name(a5);
  return 0;
}

uint64_t (*re::Serializer<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t *a4, re *this, re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v3;

  if (*(_QWORD *)a2 == *(_QWORD *)(a1 + 272)
    && (v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, **(_QWORD **)(a2 + 16) | 0xFFFFFFFF00000000)) != 0)
  {
    return *(uint64_t (**)(uint64_t, char *, const re::TypeInfo *, uint64_t *, re *, re::TypeInfo *, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  }
}

uint64_t re::serializeType<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t *a4, re *this, re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t *v23;
  unint64_t v24;
  uint64_t result;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  int v29;
  const char *v30;
  int v31;
  int v32;
  int v33;
  const re::TypeInfo *v34;
  uint64_t *v35;
  int v36;
  unint64_t v37;
  char *v38;
  BOOL (*v39)(uint64_t, char *, const re::TypeInfo *, uint64_t, re *, re::TypeInfo *, int);
  _anonymous_namespace_ *v40;
  uint64_t *v41;
  const re::TypeInfo *v42;
  char *v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  const char *v48;
  int v49;
  uint64_t v50;
  const re::TypeInfo *v51;
  int v52;
  uint64_t v53;
  uint64_t *v54;
  char *v55;
  const re::TypeInfo *v56;
  re *v57;
  re::TypeInfo *v58;
  uint64_t v59;
  re::UnionAccessor *v60;
  uint64_t *v61;
  void **Instance;
  uint64_t v63;
  unint64_t v64;
  char *v65;
  re::TypeRegistry *v66;
  re *v67;
  re::TypeInfo *v68;
  uint64_t v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v75;
  uint64_t v76;
  uint64_t *v77;
  uint64_t *v78;
  BOOL v79;
  uint64_t v80;
  uint64_t v81;
  re::internal *v82;
  _anonymous_namespace_ *v83;
  double v84;
  void **v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v91;
  uint64_t v92;
  int v93;
  re::internal *v94;
  uint64_t v95;
  void (*v96)(uint64_t, _QWORD, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t);
  uint64_t v97;
  int v98;
  uint64_t v99;
  int v100;
  uint64_t v101;
  void (*v102)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD);
  uint64_t v103;
  int v104;
  int v105;
  _anonymous_namespace_ *v106;
  unint64_t v107;
  unsigned int v108;
  uint64_t v109;
  uint64_t v110;
  re::internal *v111;
  uint64_t v112;
  void (*v113)(uint64_t, _QWORD, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t);
  unsigned int v114;
  uint64_t i;
  uint64_t v116;
  void (*v117)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD);
  _QWORD *v118;
  unsigned int v119;
  _QWORD *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  re::Allocator *v125;
  void *v126;
  unint64_t *v127;
  void **v128;
  char *v129;
  const char *v130;
  char *v131;
  uint64_t v132;
  uint64_t v133;
  re::internal *v134;
  re::internal *v135;
  uint64_t v136;
  void (*v137)(uint64_t, const char *, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t);
  uint64_t v138;
  void (*v139)(uint64_t, const char *, _QWORD, _QWORD, uint64_t *, uint64_t *, uint64_t);
  _anonymous_namespace_ *v140;
  uint64_t k;
  uint64_t v142;
  void (*v143)(uint64_t, const char *, _QWORD, void **, unint64_t *, _BYTE *, _QWORD);
  uint64_t v144;
  void (*v145)(uint64_t, const char *, _QWORD, uint64_t, uint64_t *, _QWORD **, _QWORD);
  uint64_t v146;
  void (*v147)(uint64_t *, _BYTE *, uint64_t);
  uint64_t v148;
  void **v149;
  uint64_t v150;
  unint64_t *v151;
  uint64_t v152;
  const char *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  BOOL v157;
  unint64_t v158;
  uint64_t v159;
  BOOL v160;
  char v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  char *v167;
  const re::TypeInfo *v168;
  uint64_t *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  char *v178;
  const re::StringID *v179;
  void (*v180)(void);
  char *v181;
  uint64_t v182;
  void (*v183)(uint64_t *, _BYTE *, uint64_t, _QWORD *);
  _QWORD *j;
  uint64_t v185;
  uint64_t (*v186)(uint64_t *, _QWORD);
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  re::TypeInfo *v190;
  uint64_t v191;
  char v192;
  unsigned __int8 *v193;
  int v194;
  unsigned int EnumConstantIndex;
  re *v196;
  uint64_t v197;
  unint64_t v198;
  unint64_t v199;
  const void *v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  BOOL v209;
  char v210;
  uint64_t v211;
  unint64_t v212;
  uint64_t v213;
  _BYTE *v214;
  void **v215;
  NSObject *v216;
  uint64_t v217;
  re::internal::TypeTranslationTable *v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  unint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  _BYTE *v231;
  uint64_t v232;
  uint64_t *v233[4];
  _QWORD v234[2];
  unint64_t v235;
  unint64_t v236;
  uint64_t v237;
  uint64_t v238;
  _QWORD *v239[2];
  uint64_t v240;
  _QWORD *v241[2];
  uint64_t v242;
  _BYTE v243[32];
  uint64_t Tag;
  const char *v245;
  uint64_t v246;
  _BYTE buf[24];
  uint64_t v248;
  char v249;
  _BYTE v250[7];
  uint64_t v251;
  uint64_t v252;

  v252 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_18;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        goto LABEL_18;
    }
LABEL_10:
    if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12))
      goto LABEL_292;
    v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
    if (v19)
      v20 = *(_DWORD *)(v19 + 16);
    else
      v20 = -1;
    v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
    if (v21)
      v22 = *(_DWORD *)(v21 + 16);
    else
      v22 = -1;
    if (v20 != v22)
    {
      v26 = re::TypeInfo::name(this);
      v27 = re::TypeInfo::name(a6);
      if (re::StringID::operator==(v26, v27))
      {
        v28 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
        if (v28)
          v29 = *(_DWORD *)(v28 + 16);
        else
          v29 = -1;
        re::TypeInfo::atVersion(this, v29, (unsigned __int8 *)&v236);
        if ((_BYTE)v236)
        {
          if ((a7 & 1) != 0)
            Instance = 0;
          else
            Instance = re::TypeInfo::createInstance((re::TypeInfo *)&v237, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
          if (*(_BYTE *)(a1 + 64)
            || ((*(void (**)(uint64_t, char *, const re::TypeInfo *, void **, uint64_t *, re::TypeInfo *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, a3, Instance, &v237, a6, a7), *(_BYTE *)(a1 + 64)))
          {
            if (!Instance)
              return 0;
            v125 = *(re::Allocator **)(a1 + 48);
            v126 = *(void **)(a1 + 264);
            v127 = (unint64_t *)&v237;
            v128 = Instance;
LABEL_187:
            re::TypeInfo::releaseInstance((re::TypeInfo *)v127, v128, v125, v126);
            return 0;
          }
          if ((a7 & 1) == 0)
          {
            re::TypeInfo::TypeInfo((uint64_t)v233, (uint64_t)&v237);
            re::internal::upgradeObject(Instance, v233, a4, (uint64_t **)this, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264), buf);
            if (!buf[0])
            {
              if ((v249 & 1) != 0)
                LOBYTE(v214) = v251;
              else
                v214 = v250;
              if (!buf[0] && v248 && (v249 & 1) != 0)
              {
                v180 = *(void (**)(void))(*(_QWORD *)v248 + 40);
LABEL_312:
                v180();
              }
              return 0;
            }
          }
          return 1;
        }
        v63 = re::TypeInfo::name(a6)[1];
        re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
        LOBYTE(v232) = v63;
        v30 = "Unknown serialized type \"%s\" version %u. No matching runtime type found.";
      }
      else
      {
        v53 = re::TypeInfo::name(a6)[1];
        re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
        re::TypeInfo::name(this);
        re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
        LOBYTE(v232) = v53;
        v30 = "Type name changed: Serialized type \"%s\" version %u, runtime type \"%s\" version %u.";
      }
LABEL_250:
      v152 = a1;
      v153 = a2;
      goto LABEL_251;
    }
    goto LABEL_18;
  }
  if (!re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_10;
LABEL_18:
  switch(*((_BYTE *)this + 12))
  {
    case 1:
      if (this == a6)
        goto LABEL_22;
      if (*(_QWORD *)this != *(_QWORD *)a6)
      {
        if (!re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_292;
LABEL_22:
        v23 = re::TypeInfo::name(this);
        v24 = (unint64_t)*v23 >> 1;
        if (v24 <= 0xCA3DEFB5)
        {
          if ((unint64_t)*v23 >> 1 <= 0x5D0225B)
          {
            if ((unint64_t)*v23 >> 1 <= 0x2E9355)
            {
              if (v24 != 104431)
              {
                if (v24 == 3029738)
LABEL_332:
                v232 = re::TypeInfo::name(this)[1];
                v30 = "Unsupported basic type \"%s\".";
                goto LABEL_250;
              }
            }
            if (v24 == 3052374)
            v165 = 3327612;
LABEL_278:
            if (v24 == v165)
            goto LABEL_332;
          }
          if ((unint64_t)*v23 >> 1 > 0xB0F77BD0)
          {
            if (v24 == 2969009105)
              return (uint64_t)re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, (double *)a4, a7);
            if (v24 == 3111160798)
            goto LABEL_332;
          }
          if (v24 == 97526364)
            return (uint64_t)re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, (float *)a4, a7);
          v59 = 109413500;
LABEL_194:
          if (v24 == v59)
          goto LABEL_332;
        }
        if ((unint64_t)*v23 >> 1 > 0x18E6A9A092)
        {
          if ((unint64_t)*v23 >> 1 <= 0x303EE8780EDLL)
          {
            if (v24 == 0x18E6A9A093)
            if (v24 == 0x303EE86A734)
            goto LABEL_332;
          }
          if (v24 == 0x303EE8780EELL)
          if (v24 != 0x303EE88E58DLL)
            goto LABEL_332;
        }
        else
        {
          if ((unint64_t)*v23 >> 1 > 0x16749DFF02)
          {
            if (v24 == 0x16749DFF03)
            v165 = 0x16749F63A2;
            goto LABEL_278;
          }
          if (v24 != 3393056694)
          {
            v59 = 0x16749D2549;
            goto LABEL_194;
          }
        }
      }
      v71 = **((_QWORD **)this + 2);
      v72 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v71 == (unsigned __int16)v72)
      {
        v18 = WORD1(v71) == WORD1(v72);
        v73 = (v72 ^ v71) & 0xFFFFFF00000000;
        if (v18 && v73 == 0)
          goto LABEL_22;
      }
      goto LABEL_292;
    case 2:
      if (this == a6)
        goto LABEL_240;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v75 = **((_QWORD **)this + 2);
        v76 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v75 == (unsigned __int16)v76
          && WORD1(v75) == WORD1(v76)
          && ((v76 ^ v75) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_123;
        }
        v31 = 2;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
        {
LABEL_123:
          if (*(_QWORD *)this == *(_QWORD *)a6)
          {
            v154 = **((_QWORD **)this + 2);
            v155 = **((_QWORD **)a6 + 2);
            if ((unsigned __int16)v154 == (unsigned __int16)v155
              && ((v18 = WORD1(v154) == WORD1(v155), v156 = (v155 ^ v154) & 0xFFFFFF00000000, v18)
                ? (v157 = v156 == 0)
                : (v157 = 0),
                  v157))
            {
LABEL_240:
              v79 = 1;
            }
            else
            {
              v79 = 0;
            }
          }
          else
          {
            v79 = re::areSameTranslatedVersion(this, a6, a3);
          }
          if ((_DWORD)a7)
          {
            *(_QWORD *)buf = 0;
            result = (uint64_t)re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)buf);
            if (!(_DWORD)result)
              return result;
            if (*(_QWORD *)buf)
            return *(_BYTE *)(a1 + 64) == 0;
          }
          v236 = 0;
          if (!re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v236))return 0;
          v158 = v236;
          if (!v236)
          {
            v30 = "Failed to read enum constant. String is empty.";
            goto LABEL_233;
          }
          if (v236 >= 0x401)
          {
            LOBYTE(v232) = v236;
            v30 = "Failed to read enum constant. String is too long. Length: %zu";
            goto LABEL_233;
          }
          v178 = (char *)(*(uint64_t (**)(_QWORD, unint64_t, _QWORD))(**(_QWORD **)(a1 + 56) + 32))(*(_QWORD *)(a1 + 56), v236 + 1, 0);
          v178[v158] = 0;
          if (*(_BYTE *)(a1 + 64))
          {
LABEL_311:
            v180 = *(void (**)(void))(**(_QWORD **)(a1 + 56) + 40);
            goto LABEL_312;
          }
          v191 = *v178;
          if (*v178)
          {
            v192 = v178[1];
            if (v192)
            {
              v193 = (unsigned __int8 *)(v178 + 2);
              do
              {
                v191 = 31 * v191 + v192;
                v194 = *v193++;
                v192 = v194;
              }
              while (v194);
            }
          }
          *(_QWORD *)buf = 2 * v191;
          *(_QWORD *)&buf[8] = v178;
          EnumConstantIndex = re::internal::getEnumConstantIndex(a6, (const re::TypeInfo *)buf, v179);
          re::StringID::destroyString((re::StringID *)buf);
          if ((EnumConstantIndex & 0x80000000) != 0)
          {
            v216 = *re::foundationSerializationLogObjects(v196);
            if (os_log_type_enabled(v216, OS_LOG_TYPE_INFO))
            {
              v217 = re::TypeInfo::name(a6)[1];
              *(_DWORD *)buf = 136315394;
              *(_QWORD *)&buf[4] = v178;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = v217;
              _os_log_impl(&dword_224FE9000, v216, OS_LOG_TYPE_INFO, "String \"%s\" is not a valid enum constant of type \"%s\" - skipping.", buf, 0x16u);
            }
            v200 = 0;
          }
          else if (v79)
          {
            v197 = re::TypeInfo::enumConstants(this);
            v199 = EnumConstantIndex - v198;
            if (EnumConstantIndex >= v198)
            {
              v224 = re::TypeInfo::renamedEnumConstants(this);
              if (v225 <= v199)
              {
                re::internal::assertLog((re::internal *)6, v225, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v199, v225);
                _os_crash();
                __break(1u);
                JUMPOUT(0x225CE1DE0);
              }
              v200 = (const void *)(v224 + 24 * v199);
            }
            else
            {
              v200 = (const void *)(v197 + 24 * EnumConstantIndex);
            }
          }
          else
          {
            v218 = *(re::internal::TypeTranslationTable **)(*(_QWORD *)a6 + 856);
            if (!v218
              || (v200 = (const void *)re::internal::TypeTranslationTable::translateSerializedEnum(v218, a6, EnumConstantIndex, this)) == 0)
            {
              re::TypeInfo::name(this);
              goto LABEL_311;
            }
          }
          (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 56) + 40))(*(_QWORD *)(a1 + 56), v178);
          if (v200)
            memcpy(a4, v200, *(unsigned int *)(*((_QWORD *)this + 2) + 8));
          return *(_BYTE *)(a1 + 64) == 0;
        }
        v31 = *((unsigned __int8 *)this + 12);
      }
      if (v31 == *((unsigned __int8 *)a6 + 12))
      {
        v77 = re::TypeInfo::name(this);
        v78 = re::TypeInfo::name(a6);
        if (re::StringID::operator==(v77, v78))
          goto LABEL_123;
      }
      goto LABEL_292;
    case 3:
      if (this == a6)
        goto LABEL_130;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v80 = **((_QWORD **)this + 2);
        v81 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v80 == (unsigned __int16)v81
          && WORD1(v80) == WORD1(v81)
          && ((v81 ^ v80) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_130;
        }
        v32 = 3;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_130;
        v32 = *((unsigned __int8 *)this + 12);
      }
      if (v32 != *((unsigned __int8 *)a6 + 12))
        goto LABEL_292;
LABEL_130:
      if ((_DWORD)a7)
      {
        LOBYTE(Tag) = 0;
        re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(a1 + 24, a2, &Tag);
        if ((_BYTE)Tag)
        {
          v82 = *(re::internal **)(a1 + 272);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
          re::TypeInfo::TypeInfo((uint64_t)&v236, (uint64_t)&buf[8]);
          re::internal::translateType(v82, (const re::TypeRegistry *)&v236, (uint64_t)buf);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, 0, 0, buf, buf, 1);
        }
        v83 = (_anonymous_namespace_ *)(a1 + 24);
      }
      else
      {
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)&v236, (uint64_t)&buf[8]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&buf[8]);
        re::TypeInfo::TypeInfo((uint64_t)buf, (uint64_t)this);
        v243[0] = (*(uint64_t (**)(uint64_t *))(*(_QWORD *)&buf[16] + 80))(a4) != 0;
        v84 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(a1 + 24, a2, v243);
        if (v243[0])
        {
          v85 = re::TypeInfo::createInstance((re::TypeInfo *)&v236, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
          (*(void (**)(uint64_t *, void **))(*(_QWORD *)&buf[16] + 88))(a4, v85);
          re::TypeInfo::releaseInstance((re::TypeInfo *)&v236, v85, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
          v86 = (*(uint64_t (**)(uint64_t *))(*(_QWORD *)&buf[16] + 80))(a4);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, char *, _QWORD, uint64_t, unint64_t *, uint64_t *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, 0, v86, &v236, &Tag, 0);
        }
        else
        {
          (*(void (**)(uint64_t *, _QWORD, double))(*(_QWORD *)&buf[16] + 88))(a4, 0, v84);
        }
        v83 = (_anonymous_namespace_ *)(a1 + 24);
      }
      return *(_BYTE *)(a1 + 64) == 0;
    case 4:
      if (this == a6)
        goto LABEL_146;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v87 = **((_QWORD **)this + 2);
        v88 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v87 == (unsigned __int16)v88)
        {
          v18 = WORD1(v87) == WORD1(v88);
          v89 = (v88 ^ v87) & 0xFFFFFF00000000;
          if (v18 && v89 == 0)
            goto LABEL_146;
        }
      }
      else if (re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_146;
      }
      if (*((_BYTE *)a6 + 12) != 4)
        goto LABEL_292;
      v91 = *((_QWORD *)this + 2);
      v92 = *((_QWORD *)a6 + 2);
      v93 = *(_DWORD *)(v92 + 84) & 0xFFFFFF;
      if ((*(_DWORD *)(v91 + 84) & 0xFFFFFF) == 0)
      {
        if (!v93 && *(_DWORD *)(v91 + 88) == *(_DWORD *)(v92 + 88))
          goto LABEL_146;
LABEL_292:
        return 0;
      }
      if (!v93)
        goto LABEL_292;
LABEL_146:
      if ((_DWORD)a7)
      {
        v94 = *(re::internal **)(a1 + 272);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&buf[8]);
        re::internal::translateType(v94, (const re::TypeRegistry *)&Tag, (uint64_t)&v236);
        v95 = (*(uint64_t (**)(uint64_t, unint64_t *))(*(_QWORD *)a1 + 80))(a1, &v236);
        if (!v95)
          goto LABEL_230;
        v96 = (void (*)(uint64_t, _QWORD, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t))v95;
        v97 = *((_QWORD *)a6 + 2);
        v98 = *(_DWORD *)(v97 + 84) & 0xFFFFFF;
        if (v98)
        {
          v99 = 0;
          v100 = 8;
        }
        else
        {
          v99 = *(int *)(v97 + 88);
          v100 = 4;
        }
        *(_QWORD *)buf = v99;
        v106 = (_anonymous_namespace_ *)(a1 + 24);
        result = (uint64_t)re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, buf, v100);
        if ((_DWORD)result)
        {
          v159 = *(_QWORD *)buf;
          if (v98)
            v160 = *(_QWORD *)buf == 0;
          else
            v160 = 1;
          v161 = v160;
          if (v160)
          {
            if (!*(_QWORD *)buf)
              goto LABEL_379;
          }
          else
          {
            v239[0] = 0;
            v239[1] = (_QWORD *)0xFFFFFFFFLL;
            (*(void (**)(uint64_t, _QWORD, _QWORD **))(*(_QWORD *)a1 + 16))(a1, 0, v239);
          }
          do
          {
            v96(a1, 0, 0, 0, &v236, &v236, 1);
            --v159;
          }
          while (v159);
          if ((v161 & 1) != 0)
          {
LABEL_379:
            return *(_BYTE *)(a1 + 64) == 0;
          }
LABEL_378:
          (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
          goto LABEL_379;
        }
      }
      else
      {
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&buf[8]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)v243, (uint64_t)&buf[8]);
        re::TypeInfo::TypeInfo((uint64_t)v241, (uint64_t)this);
        v101 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 80))(a1, &Tag);
        if (!v101)
          goto LABEL_231;
        v102 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD))v101;
        v103 = re::ArrayAccessor::size((re::ArrayAccessor *)v241, (char *)a4);
        v235 = v103;
        v104 = *(_DWORD *)(*((_QWORD *)this + 2) + 84) & 0xFFFFFF;
        if (v104)
          v105 = 8;
        else
          v105 = 4;
        v106 = (_anonymous_namespace_ *)(a1 + 24);
        result = (uint64_t)re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, &v235, v105);
        if ((_DWORD)result)
        {
          v107 = v235;
          if (v103 != v235)
          {
            if ((*(_DWORD *)(v242 + 84) & 0xFFFFFF) == 0)
            {
              LOBYTE(v232) = v103;
              v30 = "Invalid array size. Expected size = %zu, actual size = %zu";
              goto LABEL_233;
            }
            re::TypeRegistry::typeInfo(v241[0], *(_QWORD *)(v242 + 72), buf);
            re::TypeInfo::TypeInfo((uint64_t)&v236, (uint64_t)&buf[8]);
            v108 = *(_DWORD *)(v238 + 8);
            if (!is_mul_ok(v108, v107))
              goto LABEL_174;
            re::ArrayAccessor::reset((re::ArrayAccessor *)v241, (void **)a4, *(re::Allocator **)(a1 + 48), (const re::TypeInfo *)v107);
            v103 = v107;
          }
          if (v104)
            v209 = v103 == 0;
          else
            v209 = 1;
          v210 = v209;
          if (!v209)
          {
            v211 = *a4;
            v234[0] = 0;
            v234[1] = 0xFFFFFFFFLL;
            (*(void (**)(uint64_t, uint64_t, _QWORD *))(*(_QWORD *)a1 + 16))(a1, v211, v234);
            v103 = v107;
          }
          if (v103)
          {
            v212 = 0;
            if (v107 <= 1)
              v107 = 1;
            do
            {
              v213 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)v241, (char *)a4, v212);
              v102(a1, 0, 0, v213, &Tag, v243, 0);
              ++v212;
            }
            while (v107 != v212);
          }
          if ((v210 & 1) != 0)
            goto LABEL_379;
          goto LABEL_378;
        }
      }
      return result;
    case 5:
      if (this == a6)
        goto LABEL_164;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v109 = **((_QWORD **)this + 2);
        v110 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v109 == (unsigned __int16)v110
          && WORD1(v109) == WORD1(v110)
          && ((v110 ^ v109) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_164;
        }
        v33 = 5;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_164;
        v33 = *((unsigned __int8 *)this + 12);
      }
      if (v33 != *((unsigned __int8 *)a6 + 12))
        goto LABEL_292;
LABEL_164:
      if ((_DWORD)a7)
      {
        v111 = *(re::internal **)(a1 + 272);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&buf[8]);
        re::internal::translateType(v111, (const re::TypeRegistry *)&Tag, (uint64_t)&v236);
        v112 = (*(uint64_t (**)(uint64_t, unint64_t *))(*(_QWORD *)a1 + 80))(a1, &v236);
        if (!v112)
          goto LABEL_230;
        v113 = (void (*)(uint64_t, _QWORD, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t))v112;
        *(_QWORD *)buf = 0;
        v106 = (_anonymous_namespace_ *)(a1 + 24);
        v114 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, buf, 0);
        result = 0;
        if (v114)
        {
          for (i = *(_QWORD *)buf; i; --i)
            v113(a1, 0, 0, 0, &v236, &v236, 1);
          goto LABEL_379;
        }
        return result;
      }
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), buf);
      re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&buf[8]);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
      re::TypeInfo::TypeInfo((uint64_t)v243, (uint64_t)&buf[8]);
      re::TypeInfo::TypeInfo((uint64_t)v241, (uint64_t)this);
      v116 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 80))(a1, &Tag);
      if (!v116)
        goto LABEL_231;
      v117 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD))v116;
      v118 = (_QWORD *)(*(uint64_t (**)(uint64_t *))(v242 + 80))(a4);
      v239[0] = v118;
      v106 = (_anonymous_namespace_ *)(a1 + 24);
      v119 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(a1 + 24, a2, v239, 0);
      result = 0;
      if (!v119)
        return result;
      v120 = v239[0];
      if (v118 != v239[0])
      {
        re::TypeRegistry::typeInfo(v241[0], *(_QWORD *)(v242 + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)&v236, (uint64_t)&buf[8]);
        v108 = *(_DWORD *)(v238 + 8);
        if (!is_mul_ok(v108, (unint64_t)v120))
        {
LABEL_174:
          LOBYTE(v232) = v108;
          v30 = "Size overflow during deserialization. Element size = %zu, count = %zu";
          goto LABEL_233;
        }
        v182 = *(_QWORD *)(a1 + 48);
        v183 = *(void (**)(uint64_t *, _BYTE *, uint64_t, _QWORD *))(v242 + 88);
        re::TypeInfo::TypeInfo((uint64_t)buf, (uint64_t)v241);
        v183(a4, buf, v182, v120);
      }
      if (*(_QWORD *)(v242 + 96))
      {
        if (v120)
        {
          for (j = 0; j != v120; j = (_QWORD *)((char *)j + 1))
          {
            v185 = (*(uint64_t (**)(uint64_t *, _QWORD *))(v242 + 96))(a4, j);
            v117(a1, 0, 0, v185, &Tag, v243, 0);
          }
        }
      }
      else
      {
        v186 = *(uint64_t (**)(uint64_t *, _QWORD))(v242 + 104);
        if (!v186 || !*(_QWORD *)(v242 + 112) || !*(_QWORD *)(v242 + 120))
        {
          v190 = (re::TypeInfo *)re::TypeInfo::TypeInfo((uint64_t)buf, (uint64_t)v241);
          v232 = re::TypeInfo::name(v190)[1];
          v30 = "List type \"%s\" does not provide an indexer or iterator.";
          goto LABEL_250;
        }
        v187 = v186(a4, *(_QWORD *)(a1 + 56));
        v188 = (*(uint64_t (**)(void))(v242 + 112))();
        if (v188)
        {
          v189 = v188;
          do
          {
            v117(a1, 0, 0, v189, &Tag, v243, 0);
            v189 = (*(uint64_t (**)(uint64_t))(v242 + 112))(v187);
          }
          while (v189);
        }
        (*(void (**)(uint64_t, _QWORD))(v242 + 120))(v187, *(_QWORD *)(a1 + 56));
      }
      goto LABEL_379;
    case 6:
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), buf);
      re::TypeInfo::TypeInfo((uint64_t)&v236, (uint64_t)&buf[8]);
      v35 = re::TypeInfo::name((re::TypeInfo *)&v236);
      v36 = BYTE4(v237);
      if (BYTE4(v237) != 1)
        goto LABEL_103;
      if (!re::TypeInfo::isInteger((re::TypeInfo *)&v236))
      {
        v36 = BYTE4(v237);
LABEL_103:
        if (v36 == 8)
        {
          v64 = (unint64_t)*v35 >> 1;
          if (v64 == 0x22C6ED80D0CLL)
          {
            v131 = (char *)v35[1];
            if (v131 == "StringID" || !strcmp(v131, "StringID"))
            {
              v39 = re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
              goto LABEL_393;
            }
          }
          else if (v64 == 0x134375A94D9F7110)
          {
            v65 = (char *)v35[1];
            if (v65 == "DynamicString" || !strcmp(v65, "DynamicString"))
            {
              v39 = re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
              goto LABEL_393;
            }
          }
        }
LABEL_206:
        if (this != a6)
        {
          if (*(_QWORD *)this == *(_QWORD *)a6)
          {
            v132 = **((_QWORD **)this + 2);
            v133 = **((_QWORD **)a6 + 2);
            if ((unsigned __int16)v132 == (unsigned __int16)v133
              && WORD1(v132) == WORD1(v133)
              && ((v133 ^ v132) & 0xFFFFFF00000000) == 0)
            {
              goto LABEL_214;
            }
          }
          else if (re::areSameTranslatedVersion(this, a6, v34))
          {
            goto LABEL_214;
          }
          if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12))
            goto LABEL_292;
        }
LABEL_214:
        if ((_DWORD)a7)
        {
          v134 = *(re::internal **)(a1 + 272);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
          re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&buf[8]);
          re::internal::translateType(v134, (const re::TypeRegistry *)&Tag, (uint64_t)&v236);
          v135 = *(re::internal **)(a1 + 272);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), buf);
          re::TypeInfo::TypeInfo((uint64_t)v243, (uint64_t)&buf[8]);
          re::internal::translateType(v135, (const re::TypeRegistry *)v243, (uint64_t)&Tag);
          v136 = (*(uint64_t (**)(uint64_t, unint64_t *))(*(_QWORD *)a1 + 80))(a1, &v236);
          if (v136)
          {
            v137 = (void (*)(uint64_t, const char *, _QWORD, _QWORD, unint64_t *, unint64_t *, uint64_t))v136;
            v138 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 80))(a1, &Tag);
            if (v138)
            {
              v139 = (void (*)(uint64_t, const char *, _QWORD, _QWORD, uint64_t *, uint64_t *, uint64_t))v138;
              *(_QWORD *)buf = 0;
              v140 = (_anonymous_namespace_ *)(a1 + 24);
              result = (uint64_t)re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(a1 + 24, a2, buf);
              if (!(_DWORD)result)
                return result;
              for (k = *(_QWORD *)buf; k; --k)
              {
                re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(a1 + 24, 1);
                v137(a1, "key", 0, 0, &v236, &v236, 1);
                v139(a1, "value", 0, 0, &Tag, &Tag, 1);
              }
              goto LABEL_229;
            }
            goto LABEL_231;
          }
LABEL_230:
          v151 = &v236;
LABEL_232:
          v232 = re::TypeInfo::name((re::TypeInfo *)v151)[1];
          v30 = "Failed to resolve serialize function for type \"%s\"";
          goto LABEL_233;
        }
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)&v236, (uint64_t)&buf[8]);
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), buf);
        re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&buf[8]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), buf);
        re::TypeInfo::TypeInfo((uint64_t)v243, (uint64_t)&buf[8]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), buf);
        re::TypeInfo::TypeInfo((uint64_t)v241, (uint64_t)&buf[8]);
        re::TypeInfo::TypeInfo((uint64_t)v239, (uint64_t)this);
        v142 = (*(uint64_t (**)(uint64_t, unint64_t *))(*(_QWORD *)a1 + 80))(a1, &v236);
        if (!v142)
          goto LABEL_230;
        v143 = (void (*)(uint64_t, const char *, _QWORD, void **, unint64_t *, _BYTE *, _QWORD))v142;
        v144 = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 80))(a1, &Tag);
        if (!v144)
        {
LABEL_231:
          v151 = (unint64_t *)&Tag;
          goto LABEL_232;
        }
        v145 = (void (*)(uint64_t, const char *, _QWORD, uint64_t, uint64_t *, _QWORD **, _QWORD))v144;
        v234[0] = (*(uint64_t (**)(uint64_t *))(v240 + 88))(a4);
        v140 = (_anonymous_namespace_ *)(a1 + 24);
        result = (uint64_t)re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(a1 + 24, a2, v234);
        if (!(_DWORD)result)
          return result;
        v146 = *(_QWORD *)(a1 + 48);
        v147 = *(void (**)(uint64_t *, _BYTE *, uint64_t))(v240 + 96);
        re::TypeInfo::TypeInfo((uint64_t)buf, (uint64_t)v239);
        v147(a4, buf, v146);
        v148 = v234[0];
        if (!v234[0])
          goto LABEL_229;
        v149 = re::TypeInfo::createInstance((re::TypeInfo *)&v236, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
        while (1)
        {
          re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(a1 + 24, 0);
          v143(a1, "key", 0, v149, &v236, v243, 0);
          v125 = *(re::Allocator **)(a1 + 48);
          if (*(_BYTE *)(a1 + 64))
            break;
          v150 = (*(uint64_t (**)(uint64_t *, _QWORD **, re::Allocator *, void **))(v240 + 104))(a4, v239, v125, v149);
          v145(a1, "value", 0, v150, &Tag, v241, 0);
          if (!--v148)
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)&v236, v149, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
LABEL_229:
            return *(_BYTE *)(a1 + 64) == 0;
          }
        }
        v126 = *(void **)(a1 + 264);
        v127 = &v236;
        v128 = v149;
        goto LABEL_187;
      }
      v37 = (unint64_t)*v35 >> 1;
      if (v37 > 0x303EE8780EDLL)
      {
        if (v37 == 0x303EE8780EELL)
        {
          v181 = (char *)v35[1];
          if (v181 == "uint32_t" || !strcmp(v181, "uint32_t"))
          {
            v39 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>;
            goto LABEL_393;
          }
          goto LABEL_322;
        }
        if (v37 != 0x303EE88E58DLL)
        {
LABEL_322:
          *(_QWORD *)buf = 0x18E6A9A093;
          *(_QWORD *)&buf[8] = "uint8_t";
          if (re::StringID::operator==(v35, buf))
          {
            v39 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>;
            goto LABEL_393;
          }
          *(_QWORD *)buf = 0x16749F63A2;
          *(_QWORD *)&buf[8] = "int64_t";
          if (re::StringID::operator==(v35, buf)
            || (Tag = 3327612, v245 = "long", re::StringID::operator==(v35, &Tag)))
          {
            v39 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>;
            goto LABEL_393;
          }
          *(_QWORD *)buf = 104431;
          *(_QWORD *)&buf[8] = "int";
          if (re::StringID::operator==(v35, buf))
          {
            v39 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>;
            goto LABEL_393;
          }
          *(_QWORD *)buf = 109413500;
          *(_QWORD *)&buf[8] = "short";
          if (re::StringID::operator==(v35, buf))
          {
            v39 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>;
            goto LABEL_393;
          }
          goto LABEL_206;
        }
        v129 = (char *)v35[1];
        if (v129 != "uint64_t")
        {
          v130 = "uint64_t";
          goto LABEL_318;
        }
      }
      else
      {
        if (v37 != 3393056694)
        {
          if (v37 == 0x303EE86A734)
          {
            v38 = (char *)v35[1];
            if (v38 == "uint16_t" || !strcmp(v38, "uint16_t"))
            {
              v39 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>;
LABEL_393:
              v166 = a1;
              v167 = a2;
              v168 = a3;
              v169 = a4;
              v57 = this;
              v58 = a6;
              return ((uint64_t (*)(uint64_t, char *, const re::TypeInfo *, uint64_t *, re *, re::TypeInfo *, uint64_t))v39)(v166, v167, v168, v169, v57, v58, a7);
            }
          }
          goto LABEL_322;
        }
        v129 = (char *)v35[1];
        if (v129 != "size_t")
        {
          v130 = "size_t";
LABEL_318:
          if (!strcmp(v129, v130))
            goto LABEL_319;
          goto LABEL_322;
        }
      }
LABEL_319:
      v39 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>;
      goto LABEL_393;
    case 7:
      if (this == a6)
        goto LABEL_59;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v121 = **((_QWORD **)this + 2);
        v122 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v121 != (unsigned __int16)v122)
          goto LABEL_292;
        v18 = WORD1(v121) == WORD1(v122);
        v123 = (v122 ^ v121) & 0xFFFFFF00000000;
        if (!v18 || v123 != 0)
          goto LABEL_292;
      }
      else if (!re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_292;
      }
LABEL_59:
      v40 = (_anonymous_namespace_ *)(a1 + 24);
      result = (uint64_t)re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 16);
      if ((_DWORD)a7)
      {
        if (!(_DWORD)result)
          return result;
        v236 = 0;
        if (v236 < *(unsigned int *)(*((_QWORD *)a6 + 2) + 88))
        {
          re::TypeInfo::unionMember(a6, v236, (uint64_t)buf);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, "value", 0, 0, buf, buf, 1);
        }
      }
      else
      {
        if (!(_DWORD)result)
          return result;
        v60 = (re::UnionAccessor *)re::TypeInfo::TypeInfo((uint64_t)buf, (uint64_t)this);
        Tag = re::UnionAccessor::readTag(v60, (char *)a4);
        v61 = (uint64_t *)Tag;
        re::UnionAccessor::reset((re::UnionAccessor *)buf, (char *)a4, (const re::TypeInfo *)Tag, *(re::Allocator **)(a1 + 48));
        if ((unint64_t)v61 < *(unsigned int *)(*((_QWORD *)this + 2) + 88))
        {
          re::TypeInfo::unionMember(this, (uint64_t)v61, (uint64_t)&v236);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, const char *, _QWORD, uint64_t *, unint64_t *, unint64_t *, _QWORD))(*(_QWORD *)a1 + 72))(a1, "value", 0, a4, &v236, &v236, 0);
        }
      }
      goto LABEL_363;
    case 8:
      if (!(_DWORD)a7)
        goto LABEL_69;
      if ((*(_BYTE *)(*((_QWORD *)this + 2) + 49) & 1) != 0)
      {
        v66 = *(re::TypeRegistry **)(a1 + 272);
        Tag = 0x2686EB529B3EE220;
        v245 = "DynamicString";
        re::TypeRegistry::typeInfo(v66, (const re::StringID *)&Tag, buf);
        re::TypeInfo::TypeInfo((uint64_t)&v236, (uint64_t)&buf[8]);
        re::StringID::destroyString((re::StringID *)&Tag);
        v67 = (re *)&v236;
        v68 = (re::TypeInfo *)&v236;
        v69 = a1;
        v70 = a2;
      }
      else
      {
        v41 = re::TypeInfo::name(this);
        if ((unint64_t)*v41 >> 1 != 0x134375A94D9F7110
          || (v43 = (char *)v41[1], v43 != "DynamicString") && strcmp(v43, "DynamicString"))
        {
LABEL_69:
          v44 = *((_QWORD *)this + 2);
          if ((*(_BYTE *)(v44 + 48) & 4) == 0)
          {
            v40 = (_anonymous_namespace_ *)(a1 + 24);
            v45 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
            result = 0;
            if (!v45)
              return result;
            v46 = *(_QWORD *)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
            if (v46
              && *(_WORD *)(v46 + 22) == 3
              && *(_DWORD *)v46
              && (v47 = *(_QWORD *)(v46 + 8), (*(_WORD *)(v47 + 46) & 0x40) != 0)
              && ((*(_WORD *)(v47 + 22) & 0x1000) != 0
                ? (v48 = *(const char **)(v46 + 8))
                : (v48 = *(const char **)(v47 + 8)),
                  !strcmp(v48, "@version")))
            {
              v49 = *(_DWORD *)(v47 + 24);
            }
            else
            {
              v49 = 1;
            }
            v50 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
            if (v50)
              v52 = *(_DWORD *)(v50 + 16);
            else
              v52 = -1;
            if (v49 == v52)
            {
              if (this != a6)
              {
                if (*(_QWORD *)this == *(_QWORD *)a6)
                {
                  v201 = **((_QWORD **)this + 2);
                  v202 = **((_QWORD **)a6 + 2);
                  if ((unsigned __int16)v201 == (unsigned __int16)v202
                    && WORD1(v201) == WORD1(v202)
                    && ((v202 ^ v201) & 0xFFFFFF00000000) == 0)
                  {
                    goto LABEL_304;
                  }
                }
                else if (re::areSameTranslatedVersion(this, a6, v51))
                {
                  goto LABEL_304;
                }
                if (*((unsigned __int8 *)this + 12) == *((unsigned __int8 *)a6 + 12))
                {
                  re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(a1, (uint64_t)a4, (uint64_t *)this, (uint64_t *)a6, a7);
                }
                else
                {
                  v203 = re::TypeInfo::name(this)[1];
                  re::TypeInfo::name(a6);
                }
                goto LABEL_363;
              }
LABEL_304:
              re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>((_BYTE *)a1, (uint64_t)a4, (uint64_t *)this, a7);
LABEL_363:
              return *(_BYTE *)(a1 + 64) == 0;
            }
            if (*(_QWORD *)this != *(_QWORD *)a6
              || (v175 = **((_QWORD **)this + 2),
                  v176 = **((_QWORD **)a6 + 2),
                  (unsigned __int16)v175 != (unsigned __int16)v176)
              || WORD1(v175) != WORD1(v176)
              || ((v176 ^ v175) & 0xFFFFFF00000000) != 0)
            {
              v177 = re::TypeInfo::name(a6)[1];
              re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
              LOBYTE(v232) = v177;
              v30 = "Type \"%s\" version %u expected in JSON. Actual version found in JSON: %u";
LABEL_233:
              v152 = a1;
              v153 = 0;
LABEL_251:
              return 0;
            }
            re::TypeInfo::atVersion(this, v49, (unsigned __int8 *)&v236);
            if (!(_BYTE)v236)
            {
              v232 = re::TypeInfo::name(this)[1];
              v30 = "Unknown serialized type \"%s\" version %u. No matching runtime type found.";
              goto LABEL_233;
            }
            if ((a7 & 1) != 0)
              v215 = 0;
            else
              v215 = re::TypeInfo::createInstance((re::TypeInfo *)&v237, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
            re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>((_BYTE *)a1, (uint64_t)v215, &v237, a7);
            if (*(_BYTE *)(a1 + 64))
            {
              if (!v215)
                return 0;
              v125 = *(re::Allocator **)(a1 + 48);
              v126 = *(void **)(a1 + 264);
              v127 = (unint64_t *)&v237;
              v128 = v215;
              goto LABEL_187;
            }
            if ((a7 & 1) == 0)
            {
              re::TypeInfo::TypeInfo((uint64_t)&Tag, (uint64_t)&v237);
              re::internal::upgradeObject(v215, (uint64_t **)&Tag, a4, (uint64_t **)this, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264), buf);
              if (!buf[0])
              {
                if ((v249 & 1) != 0)
                  LOBYTE(v231) = v251;
                else
                  v231 = v250;
                if (!buf[0] && v248 && (v249 & 1) != 0)
                  (*(void (**)(void))(*(_QWORD *)v248 + 40))();
              }
            }
            return 1;
          }
          v54 = (uint64_t *)re::TypeMemberCollection::TypeMemberCollection((uint64_t)buf, *(_QWORD *)this, v44);
          re::TypeMemberCollection::operator[](v54, 0, (uint64_t)&Tag);
          v55 = (char *)a4 + *(unsigned int *)(v246 + 24);
          re::TypeRegistry::typeInfo((_QWORD *)Tag, *(_QWORD *)v246, buf);
          re::TypeInfo::TypeInfo((uint64_t)v243, (uint64_t)&buf[8]);
          if (this == a6)
            goto LABEL_87;
          if (*(_QWORD *)this == *(_QWORD *)a6)
          {
            v162 = **((_QWORD **)this + 2);
            v163 = *((_QWORD *)a6 + 2);
            v164 = *(_QWORD *)v163;
            if ((unsigned __int16)v162 == (unsigned __int16)*(_QWORD *)v163
              && WORD1(v162) == WORD1(v164)
              && ((v164 ^ v162) & 0xFFFFFF00000000) == 0)
            {
              goto LABEL_87;
            }
          }
          else
          {
            if (re::areSameTranslatedVersion(this, a6, v56))
            {
LABEL_87:
              if (*(_BYTE *)(a1 + 64))
                return 0;
              v39 = *(BOOL (**)(uint64_t, char *, const re::TypeInfo *, uint64_t, re *, re::TypeInfo *, int))(*(_QWORD *)a1 + 72);
              v57 = (re *)v243;
              v58 = (re::TypeInfo *)v243;
LABEL_291:
              v166 = a1;
              v167 = a2;
              v168 = a3;
              v169 = (uint64_t *)v55;
              return ((uint64_t (*)(uint64_t, char *, const re::TypeInfo *, uint64_t *, re *, re::TypeInfo *, uint64_t))v39)(v166, v167, v168, v169, v57, v58, a7);
            }
            v163 = *((_QWORD *)a6 + 2);
          }
          if (*(_DWORD *)(v163 + 88) != 1)
            goto LABEL_292;
          re::TypeMemberCollection::TypeMemberCollection((uint64_t)&v236, *(_QWORD *)a6, v163);
          re::TypeMemberCollection::operator[]((uint64_t *)&v236, 0, (uint64_t)v239);
          re::TypeRegistry::typeInfo(v239[0], *(_QWORD *)v240, buf);
          re::TypeInfo::TypeInfo((uint64_t)v241, (uint64_t)&buf[8]);
          if (*(_BYTE *)(a1 + 64))
            return 0;
          v39 = *(BOOL (**)(uint64_t, char *, const re::TypeInfo *, uint64_t, re *, re::TypeInfo *, int))(*(_QWORD *)a1 + 72);
          v57 = (re *)v243;
          v58 = (re::TypeInfo *)v241;
          goto LABEL_291;
        }
        v69 = a1;
        v70 = a2;
        v67 = this;
        v68 = this;
      }
      re::serializeDynamicString<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(v69, v70, v42, 0, v67, v68, 1);
      return *(_BYTE *)(a1 + 64) == 0;
    case 9:
      v232 = re::TypeInfo::name(this)[1];
      v30 = "Pointer type (\"%s\") needs to be handled explicitly by the serializer.";
      goto LABEL_250;
    default:
      LOBYTE(v232) = *((_BYTE *)this + 12);
      v30 = "Invalid type category. Value = %d";
      goto LABEL_250;
  }
}

unsigned int *re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(uint64_t a1, char *a2, float *a3, char a4)
{
  unsigned int *result;
  double v9;
  __int16 v10;
  float Double;
  const char *v12;
  unsigned int v13;
  int v14;
  re *v15;
  float v16;
  BOOL v17;
  NSObject *v18;
  uint64_t v19;
  _BYTE v20[24];
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 40))
    return 0;
  if (result)
  {
    v10 = *((_WORD *)result + 11);
    if ((v10 & 0x400) == 0)
    {
      if ((v10 & 0x10) != 0)
      {
        Double = rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::GetDouble(result, v9);
LABEL_35:
        if ((a4 & 1) == 0)
          *a3 = Double;
        v19 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
        ++*(_QWORD *)(v19 - 16);
        return (unsigned int *)1;
      }
LABEL_32:
      return 0;
    }
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      v12 = (const char *)result;
    else
      v12 = (const char *)*((_QWORD *)result + 1);
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      v13 = 21 - *((char *)result + 21);
    else
      v13 = *result;
    if (v13 == 9)
    {
      if (!strcasecmp(v12, "-Infinity"))
      {
        *(float *)&v14 = -INFINITY;
        goto LABEL_34;
      }
    }
    else if (v13 == 8)
    {
      if (!strcasecmp(v12, "Infinity"))
      {
        *(float *)&v14 = INFINITY;
        goto LABEL_34;
      }
    }
    else if (v13 == 3 && !strcasecmp(v12, "NaN"))
    {
      *(float *)&v14 = NAN;
LABEL_34:
      Double = *(float *)&v14;
      goto LABEL_35;
    }
    if (*(_BYTE *)(a1 + 232))
    {
      *(_QWORD *)v20 = 0;
      v16 = strtof(v12, (char **)v20);
      v17 = *(const char **)v20 != &v12[v13] || v16 == INFINITY;
      Double = v17 ? INFINITY : v16;
      if (Double != INFINITY)
      {
        v18 = *re::foundationSerializationLogObjects(v15);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v20 = 136315138;
          *(_QWORD *)&v20[4] = v12;
          _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", v20, 0xCu);
        }
        goto LABEL_35;
      }
    }
    goto LABEL_32;
  }
  return result;
}

unsigned int *re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(uint64_t a1, char *a2, double *a3, char a4)
{
  unsigned int *result;
  double v9;
  __int16 v10;
  double Double;
  const char *v12;
  unsigned int v13;
  unint64_t v14;
  re *v15;
  float v16;
  BOOL v17;
  NSObject *v18;
  uint64_t v19;
  _BYTE v20[24];
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 40))
    return 0;
  if (result)
  {
    v10 = *((_WORD *)result + 11);
    if ((v10 & 0x400) == 0)
    {
      if ((v10 & 0x10) != 0)
      {
        Double = rapidjson::GenericValue<rapidjson::UTF8<char>,re::internal::RapidJSONPoolAllocator<re::internal::RapidJSONAllocator>>::GetDouble(result, v9);
LABEL_35:
        if ((a4 & 1) == 0)
          *a3 = Double;
        v19 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
        ++*(_QWORD *)(v19 - 16);
        return (unsigned int *)1;
      }
LABEL_32:
      return 0;
    }
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      v12 = (const char *)result;
    else
      v12 = (const char *)*((_QWORD *)result + 1);
    if ((*((_WORD *)result + 11) & 0x1000) != 0)
      v13 = 21 - *((char *)result + 21);
    else
      v13 = *result;
    if (v13 == 9)
    {
      if (!strcasecmp(v12, "-Infinity"))
      {
        *(double *)&v14 = -INFINITY;
        goto LABEL_34;
      }
    }
    else if (v13 == 8)
    {
      if (!strcasecmp(v12, "Infinity"))
      {
        *(double *)&v14 = INFINITY;
        goto LABEL_34;
      }
    }
    else if (v13 == 3 && !strcasecmp(v12, "NaN"))
    {
      *(double *)&v14 = NAN;
LABEL_34:
      Double = *(double *)&v14;
      goto LABEL_35;
    }
    if (*(_BYTE *)(a1 + 232))
    {
      *(_QWORD *)v20 = 0;
      v16 = strtod(v12, (char **)v20);
      v17 = *(const char **)v20 != &v12[v13] || v16 == INFINITY;
      Double = v17 ? INFINITY : v16;
      if (Double != INFINITY)
      {
        v18 = *re::foundationSerializationLogObjects(v15);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v20 = 136315138;
          *(_QWORD *)&v20[4] = v12;
          _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "Reading JSON string \"%s\" as number in Number/String Compatibility Mode", v20, 0xCu);
        }
        goto LABEL_35;
      }
    }
    goto LABEL_32;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v20)(uint64_t, uint64_t *, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  _BOOL8 result;
  unsigned int *v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _BYTE v45[16];
  uint64_t v46;
  _BYTE v47[32];
  _BYTE v48[32];
  uint64_t v49;
  uint64_t v50;
  _BYTE v51[40];

  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v50),
        re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v51),
        v48[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v48))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v50);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v51);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v50);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)v51);
  re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v48);
  if (!v18)
  {
    v43 = re::TypeInfo::name((re::TypeInfo *)v48)[1];
    return 0;
  }
  v19 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v18;
  v20 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v46 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v50, (uint64_t)v45);
  v20(a4, &v50, v17);
  v26 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
  result = 0;
  if (v26)
  {
    v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v28 && *v28)
    {
      v29 = *((_QWORD *)v28 + 1);
      while (1)
      {
        if ((*(_WORD *)(v29 + 22) & 0x1000) != 0)
          v30 = v29;
        else
          v30 = *(_QWORD *)(v29 + 8);
        if ((*(_WORD *)(v29 + 22) & 0x1000) != 0)
          v31 = 21 - *(char *)(v29 + 21);
        else
          v31 = *(_DWORD *)v29;
        v44 = 0;
        if (!v31)
          goto LABEL_42;
        v32 = 0;
        v33 = (unsigned __int8 *)(v30 + v31);
        while (*(_BYTE *)(v30 + v32) == 48)
        {
          if (v31 == ++v32)
            goto LABEL_42;
        }
        if (v31 == v32)
          goto LABEL_42;
        v34 = (unsigned __int8 *)(v30 + v32);
        if (*(unsigned __int8 *)(v30 + v32) - 48 > 9)
          goto LABEL_41;
        v34 = std::__itoa::__traits<unsigned long long>::__read[abi:nn180100](v34, v33, &v50, &v49);
        if (v34 == v33)
          break;
        if (*v34 - 48 > 9)
        {
          v36 = v49;
          v35 = v50;
          if (!__CFADD__(v50, v49))
            goto LABEL_40;
        }
        while (*v34 - 48 <= 9)
        {
          if (++v34 == v33)
          {
            v34 = v33;
            break;
          }
        }
LABEL_41:
        if (v33 != v34)
        {
          return 0;
        }
LABEL_42:
        v37 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, uint64_t *))(v46 + 104))(a4, v45, *(_QWORD *)(a1 + 48), &v44);
        v19(a1, v30, 0, v37, v48, v47, 0);
        v29 += 48;
        if (v29 == *((_QWORD *)v28 + 1) + 48 * *v28)
          goto LABEL_43;
      }
      v36 = v49;
      v35 = v50;
      if (__CFADD__(v50, v49))
        goto LABEL_42;
LABEL_40:
      v44 = v35 + v36;
      goto LABEL_41;
    }
LABEL_43:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v20)(uint64_t, int *, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  _BOOL8 result;
  unsigned int *v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  _BYTE v45[16];
  uint64_t v46;
  _BYTE v47[32];
  _BYTE v48[36];
  int v49;
  int v50;
  _BYTE v51[40];

  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v50),
        re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v51),
        v48[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v48))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v50);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v51);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v50);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)v51);
  re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v48);
  if (!v18)
  {
    v43 = re::TypeInfo::name((re::TypeInfo *)v48)[1];
    return 0;
  }
  v19 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v18;
  v20 = *(void (**)(uint64_t, int *, uint64_t))(v46 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v50, (uint64_t)v45);
  v20(a4, &v50, v17);
  v26 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
  result = 0;
  if (v26)
  {
    v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v28 && *v28)
    {
      v29 = *((_QWORD *)v28 + 1);
      while (1)
      {
        if ((*(_WORD *)(v29 + 22) & 0x1000) != 0)
          v30 = v29;
        else
          v30 = *(_QWORD *)(v29 + 8);
        if ((*(_WORD *)(v29 + 22) & 0x1000) != 0)
          v31 = 21 - *(char *)(v29 + 21);
        else
          v31 = *(_DWORD *)v29;
        v44 = 0;
        if (!v31)
          goto LABEL_42;
        v32 = 0;
        v33 = (unsigned __int8 *)(v30 + v31);
        while (*(_BYTE *)(v30 + v32) == 48)
        {
          if (v31 == ++v32)
            goto LABEL_42;
        }
        if (v31 == v32)
          goto LABEL_42;
        v34 = (unsigned __int8 *)(v30 + v32);
        if (*(unsigned __int8 *)(v30 + v32) - 48 > 9)
          goto LABEL_41;
        v34 = std::__itoa::__traits<unsigned int>::__read[abi:nn180100](v34, v33, &v50, &v49);
        if (v34 == v33)
          break;
        if (*v34 - 48 > 9)
        {
          v36 = v49;
          v35 = v50;
          if (!__CFADD__(v50, v49))
            goto LABEL_40;
        }
        while (*v34 - 48 <= 9)
        {
          if (++v34 == v33)
          {
            v34 = v33;
            break;
          }
        }
LABEL_41:
        if (v33 != v34)
        {
          return 0;
        }
LABEL_42:
        v37 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, int *))(v46 + 104))(a4, v45, *(_QWORD *)(a1 + 48), &v44);
        v19(a1, v30, 0, v37, v48, v47, 0);
        v29 += 48;
        if (v29 == *((_QWORD *)v28 + 1) + 48 * *v28)
          goto LABEL_43;
      }
      v36 = v49;
      v35 = v50;
      if (__CFADD__(v50, v49))
        goto LABEL_42;
LABEL_40:
      v44 = v35 + v36;
      goto LABEL_41;
    }
LABEL_43:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v20)(uint64_t, unsigned int *, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  _BOOL8 result;
  unsigned int *v28;
  uint64_t i;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  __int16 v42;
  _BYTE v43[16];
  uint64_t v44;
  _BYTE v45[32];
  _BYTE v46[36];
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[40];

  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)v49),
        v46[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v46))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)v49);
  re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v46);
  if (!v18)
  {
    v41 = re::TypeInfo::name((re::TypeInfo *)v46)[1];
    return 0;
  }
  v19 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v18;
  v20 = *(void (**)(uint64_t, unsigned int *, uint64_t))(v44 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v48, (uint64_t)v43);
  v20(a4, &v48, v17);
  v26 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
  result = 0;
  if (v26)
  {
    v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v28 && *v28)
    {
      for (i = *((_QWORD *)v28 + 1); i != *((_QWORD *)v28 + 1) + 48 * *v28; i += 48)
      {
        if ((*(_WORD *)(i + 22) & 0x1000) != 0)
          v30 = i;
        else
          v30 = *(_QWORD *)(i + 8);
        if ((*(_WORD *)(i + 22) & 0x1000) != 0)
          v31 = 21 - *(char *)(i + 21);
        else
          v31 = *(_DWORD *)i;
        v42 = 0;
        if (!v31)
          goto LABEL_42;
        v32 = 0;
        v33 = (unsigned __int8 *)(v30 + v31);
        while (*(_BYTE *)(v30 + v32) == 48)
        {
          if (v31 == ++v32)
            goto LABEL_42;
        }
        if (v31 == v32)
          goto LABEL_42;
        v34 = (unsigned __int8 *)(v30 + v32);
        if (*(unsigned __int8 *)(v30 + v32) - 48 <= 9)
        {
          v34 = std::__itoa::__traits<unsigned short>::__read[abi:nn180100](v34, v33, &v48, &v47);
          if (v34 == v33 || *v34 - 48 > 9)
          {
            if (HIWORD(v48) || 0xFFFF - v48 < v47)
            {
              if (v34 != v33)
                goto LABEL_37;
              goto LABEL_42;
            }
            v42 = v47 + v48;
          }
          else
          {
LABEL_37:
            while (*v34 - 48 <= 9)
            {
              if (++v34 == v33)
              {
                v34 = v33;
                break;
              }
            }
          }
        }
        if (v33 != v34)
        {
          return 0;
        }
LABEL_42:
        v35 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, __int16 *))(v44 + 104))(a4, v43, *(_QWORD *)(a1 + 48), &v42);
        v19(a1, v30, 0, v35, v46, v45, 0);
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v20)(uint64_t, unsigned int *, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  _BOOL8 result;
  unsigned int *v28;
  uint64_t i;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  _BYTE v43[16];
  uint64_t v44;
  _BYTE v45[32];
  _BYTE v46[36];
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[40];

  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)v49),
        v46[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v46))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v45, (uint64_t)v49);
  re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v46);
  if (!v18)
  {
    v41 = re::TypeInfo::name((re::TypeInfo *)v46)[1];
    return 0;
  }
  v19 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v18;
  v20 = *(void (**)(uint64_t, unsigned int *, uint64_t))(v44 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v48, (uint64_t)v43);
  v20(a4, &v48, v17);
  v26 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
  result = 0;
  if (v26)
  {
    v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v28 && *v28)
    {
      for (i = *((_QWORD *)v28 + 1); i != *((_QWORD *)v28 + 1) + 48 * *v28; i += 48)
      {
        if ((*(_WORD *)(i + 22) & 0x1000) != 0)
          v30 = i;
        else
          v30 = *(_QWORD *)(i + 8);
        if ((*(_WORD *)(i + 22) & 0x1000) != 0)
          v31 = 21 - *(char *)(i + 21);
        else
          v31 = *(_DWORD *)i;
        v42 = 0;
        if (!v31)
          goto LABEL_42;
        v32 = 0;
        v33 = (unsigned __int8 *)(v30 + v31);
        while (*(_BYTE *)(v30 + v32) == 48)
        {
          if (v31 == ++v32)
            goto LABEL_42;
        }
        if (v31 == v32)
          goto LABEL_42;
        v34 = (unsigned __int8 *)(v30 + v32);
        if (*(unsigned __int8 *)(v30 + v32) - 48 <= 9)
        {
          v34 = std::__itoa::__traits<unsigned char>::__read[abi:nn180100](v34, v33, &v48, &v47);
          if (v34 == v33 || *v34 - 48 > 9)
          {
            if (v48 > 0xFF || 255 - v48 < v47)
            {
              if (v34 != v33)
                goto LABEL_37;
              goto LABEL_42;
            }
            v42 = v47 + v48;
          }
          else
          {
LABEL_37:
            while (*v34 - 48 <= 9)
            {
              if (++v34 == v33)
              {
                v34 = v33;
                break;
              }
            }
          }
        }
        if (v33 != v34)
        {
          return 0;
        }
LABEL_42:
        v35 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, char *))(v44 + 104))(a4, v43, *(_QWORD *)(a1 + 48), &v42);
        v19(a1, v30, 0, v35, v46, v45, 0);
      }
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v20)(uint64_t, uint64_t *, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  _BOOL8 result;
  unsigned int *v28;
  uint64_t v29;
  unsigned __int8 *v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  unsigned __int8 *v34;
  char v35;
  unsigned __int8 *v36;
  uint64_t v37;
  unsigned __int8 *v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  _BYTE v50[16];
  uint64_t v51;
  _BYTE v52[32];
  _BYTE v53[32];
  uint64_t v54;
  uint64_t v55;
  _BYTE v56[40];

  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v55),
        re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56),
        v53[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v53))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v56);
  re::TypeInfo::TypeInfo((uint64_t)v50, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v53);
  if (!v18)
  {
    v48 = re::TypeInfo::name((re::TypeInfo *)v53)[1];
    return 0;
  }
  v19 = (void (*)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v18;
  v20 = *(void (**)(uint64_t, uint64_t *, uint64_t))(v51 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v55, (uint64_t)v50);
  v20(a4, &v55, v17);
  v26 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
  result = 0;
  if (v26)
  {
    v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v28 && *v28)
    {
      v29 = *((_QWORD *)v28 + 1);
      while (1)
      {
        v30 = (*(_WORD *)(v29 + 22) & 0x1000) != 0 ? (unsigned __int8 *)v29 : *(unsigned __int8 **)(v29 + 8);
        v31 = (*(_WORD *)(v29 + 22) & 0x1000) != 0 ? 21 - *(char *)(v29 + 21) : *(_DWORD *)v29;
        v49 = 0;
        v32 = v31 && *v30 == 45;
        v33 = v31;
        v34 = &v30[v31];
        v35 = v32;
        v36 = &v30[v32];
        if (v33 == v32)
          break;
        v37 = v33 - v32;
        v38 = v36;
        while (*v38 == 48)
        {
          ++v38;
          if (!--v37)
            goto LABEL_42;
        }
        if (!v37)
          break;
        if (*v38 - 48 >= 0xA)
          goto LABEL_43;
        v38 = std::__itoa::__traits<unsigned long long>::__read[abi:nn180100](v38, v34, &v55, &v54);
        if (v38 == v34)
        {
          v40 = v54;
          v39 = v55;
          if (__CFADD__(v55, v54))
          {
LABEL_53:
            v38 = v34;
            goto LABEL_48;
          }
        }
        else if (*v38 - 48 <= 9 || (v40 = v54, v39 = v55, __CFADD__(v55, v54)))
        {
          while (*v38 - 48 <= 9)
          {
            if (++v38 == v34)
              goto LABEL_53;
          }
          goto LABEL_48;
        }
        v41 = v39 + v40;
        if ((v35 & 1) != 0)
        {
          if (v41 <= 0x8000000000000000)
            goto LABEL_45;
        }
        else if ((v41 & 0x8000000000000000) == 0)
        {
          goto LABEL_46;
        }
LABEL_48:
        if (v34 != v38)
        {
          return 0;
        }
        v42 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, unint64_t *))(v51 + 104))(a4, v50, *(_QWORD *)(a1 + 48), &v49);
        v19(a1, v30, 0, v42, v53, v52, 0);
        v29 += 48;
        if (v29 == *((_QWORD *)v28 + 1) + 48 * *v28)
          goto LABEL_62;
      }
LABEL_42:
      v38 = v34;
LABEL_43:
      if (v38 != v36)
      {
        v41 = 0;
        if ((v35 & 1) != 0)
LABEL_45:
          v41 = -(uint64_t)v41;
LABEL_46:
        v49 = v41;
        goto LABEL_48;
      }
      v38 = v30;
      goto LABEL_48;
    }
LABEL_62:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v20)(uint64_t, int *, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  _BOOL8 result;
  unsigned int *v28;
  uint64_t v29;
  unsigned __int8 *v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  unsigned __int8 *v34;
  char v35;
  unsigned __int8 *v36;
  uint64_t v37;
  unsigned __int8 *v38;
  int v39;
  int v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  _BYTE v50[16];
  uint64_t v51;
  _BYTE v52[32];
  _BYTE v53[36];
  int v54;
  int v55;
  _BYTE v56[40];

  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v55),
        re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56),
        v53[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v53))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v56);
  re::TypeInfo::TypeInfo((uint64_t)v50, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v53);
  if (!v18)
  {
    v48 = re::TypeInfo::name((re::TypeInfo *)v53)[1];
    return 0;
  }
  v19 = (void (*)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v18;
  v20 = *(void (**)(uint64_t, int *, uint64_t))(v51 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v55, (uint64_t)v50);
  v20(a4, &v55, v17);
  v26 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
  result = 0;
  if (v26)
  {
    v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (v28 && *v28)
    {
      v29 = *((_QWORD *)v28 + 1);
      while (1)
      {
        v30 = (*(_WORD *)(v29 + 22) & 0x1000) != 0 ? (unsigned __int8 *)v29 : *(unsigned __int8 **)(v29 + 8);
        v31 = (*(_WORD *)(v29 + 22) & 0x1000) != 0 ? 21 - *(char *)(v29 + 21) : *(_DWORD *)v29;
        v49 = 0;
        v32 = v31 && *v30 == 45;
        v33 = v31;
        v34 = &v30[v31];
        v35 = v32;
        v36 = &v30[v32];
        if (v33 == v32)
          break;
        v37 = v33 - v32;
        v38 = v36;
        while (*v38 == 48)
        {
          ++v38;
          if (!--v37)
            goto LABEL_42;
        }
        if (!v37)
          break;
        if (*v38 - 48 >= 0xA)
          goto LABEL_43;
        v38 = std::__itoa::__traits<unsigned int>::__read[abi:nn180100](v38, v34, &v55, &v54);
        if (v38 == v34)
        {
          v40 = v54;
          v39 = v55;
          if (__CFADD__(v55, v54))
          {
LABEL_53:
            v38 = v34;
            goto LABEL_48;
          }
        }
        else if (*v38 - 48 <= 9 || (v40 = v54, v39 = v55, __CFADD__(v55, v54)))
        {
          while (*v38 - 48 <= 9)
          {
            if (++v38 == v34)
              goto LABEL_53;
          }
          goto LABEL_48;
        }
        v41 = v39 + v40;
        if ((v35 & 1) != 0)
        {
          if (v41 <= 0x80000000)
            goto LABEL_45;
        }
        else if ((v41 & 0x80000000) == 0)
        {
          goto LABEL_46;
        }
LABEL_48:
        if (v34 != v38)
        {
          return 0;
        }
        v42 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, unsigned int *))(v51 + 104))(a4, v50, *(_QWORD *)(a1 + 48), &v49);
        v19(a1, v30, 0, v42, v53, v52, 0);
        v29 += 48;
        if (v29 == *((_QWORD *)v28 + 1) + 48 * *v28)
          goto LABEL_62;
      }
LABEL_42:
      v38 = v34;
LABEL_43:
      if (v38 != v36)
      {
        v41 = 0;
        if ((v35 & 1) != 0)
LABEL_45:
          v41 = -v41;
LABEL_46:
        v49 = v41;
        goto LABEL_48;
      }
      v38 = v30;
      goto LABEL_48;
    }
LABEL_62:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  _BOOL8 result;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  void (*v21)(uint64_t, unsigned int *, uint64_t);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int *v28;
  unsigned __int8 *v29;
  unsigned __int8 *v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  unsigned __int8 *v34;
  char v35;
  unsigned __int8 *v36;
  uint64_t v37;
  unsigned __int8 *v38;
  __int16 v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __int16 v48;
  _BYTE v49[16];
  uint64_t v50;
  _BYTE v51[32];
  _BYTE v52[36];
  unsigned int v53;
  unsigned int v54;
  _BYTE v55[40];

  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v54),
        re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v55),
        v52[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v52))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v18 = *(_QWORD *)(a1 + 48);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v54);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v55);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v54);
  re::TypeInfo::TypeInfo((uint64_t)v51, (uint64_t)v55);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)this);
  v19 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v52);
  if (!v19)
  {
    v47 = re::TypeInfo::name((re::TypeInfo *)v52)[1];
    return 0;
  }
  v20 = (void (*)(uint64_t, unsigned __int8 *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v19;
  v21 = *(void (**)(uint64_t, unsigned int *, uint64_t))(v50 + 96);
  re::TypeInfo::TypeInfo((uint64_t)&v54, (uint64_t)v49);
  v21(a4, &v54, v18);
  v27 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
  result = 0;
  if (v27)
  {
    v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
    if (!v28 || !*v28)
    {
LABEL_62:
      return *(_BYTE *)(a1 + 64) == 0;
    }
    v29 = (unsigned __int8 *)*((_QWORD *)v28 + 1);
    while (1)
    {
      if ((*((_WORD *)v29 + 11) & 0x1000) != 0)
        v30 = v29;
      else
        v30 = (unsigned __int8 *)*((_QWORD *)v29 + 1);
      if ((*((_WORD *)v29 + 11) & 0x1000) != 0)
        v31 = 21 - (char)v29[21];
      else
        v31 = *(_DWORD *)v29;
      v48 = 0;
      if (v31)
        v32 = *v30 == 45;
      else
        v32 = 0;
      v33 = v31;
      v34 = &v30[v31];
      v35 = v32;
      v36 = &v30[v32];
      if (v33 == v32)
        goto LABEL_44;
      v37 = v33 - v32;
      v38 = v36;
      while (*v38 == 48)
      {
        ++v38;
        if (!--v37)
          goto LABEL_44;
      }
      if (!v37)
      {
LABEL_44:
        v38 = v34;
LABEL_45:
        if (v38 == v36)
        {
          v38 = v30;
          goto LABEL_52;
        }
        v39 = 0;
        v40 = 0;
        if ((v35 & 1) != 0)
        {
LABEL_47:
          v48 = -v39;
          goto LABEL_52;
        }
LABEL_51:
        v48 = v40;
        goto LABEL_52;
      }
      if (*v38 - 48 >= 0xA)
        goto LABEL_45;
      v38 = std::__itoa::__traits<unsigned short>::__read[abi:nn180100](v38, v34, &v54, &v53);
      if (v38 != v34 && *v38 - 48 <= 9)
        goto LABEL_56;
      if (HIWORD(v54) || 0xFFFF - v54 < v53)
        break;
      v39 = v53 + v54;
      if ((v35 & 1) == 0)
      {
        if ((((_WORD)v53 + (_WORD)v54) & 0x8000) != 0)
          goto LABEL_52;
        v40 = v53 + v54;
        goto LABEL_51;
      }
      if ((unsigned __int16)(v53 + v54) <= 0x8000u)
        goto LABEL_47;
LABEL_52:
      if (v34 != v38)
      {
        return 0;
      }
      v41 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, __int16 *))(v50 + 104))(a4, v49, *(_QWORD *)(a1 + 48), &v48);
      v20(a1, v30, 0, v41, v52, v51, 0);
      v29 += 48;
      if (v29 == (unsigned __int8 *)(*((_QWORD *)v28 + 1) + 48 * *v28))
        goto LABEL_62;
    }
    while (1)
    {
      if (v38 == v34)
      {
        v38 = v34;
        goto LABEL_52;
      }
LABEL_56:
      if (*v38 - 48 > 9)
        goto LABEL_52;
      ++v38;
    }
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  unsigned int v25;
  _BOOL8 result;
  void (*v27)(uint64_t, const char **, uint64_t);
  re::DynamicString *v28;
  unsigned int *v29;
  uint64_t v30;
  const char *v31;
  size_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE v40[16];
  uint64_t v41;
  _BYTE v42[32];
  _BYTE v43[32];
  const char *v44;
  _QWORD v45[5];

  if (this == a6)
    goto LABEL_14;
  v13 = *(_QWORD **)this;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v14 = (uint64_t *)*((_QWORD *)a6 + 2);
    v16 = *v14;
    if ((unsigned __int16)v15 != (unsigned __int16)*v14)
      goto LABEL_10;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v22 = *(_QWORD *)(a1 + 48);
      v21 = *(_QWORD *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v44);
      re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)v45);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v44);
      re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)v45);
      re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)this);
      v23 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v43);
      if (!v23)
      {
        v34 = re::TypeInfo::name((re::TypeInfo *)v43);
        return 0;
      }
      v24 = (void (*)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v23;
      v25 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
      result = 0;
      if (!v25)
        return result;
      v27 = *(void (**)(uint64_t, const char **, uint64_t))(v41 + 96);
      re::TypeInfo::TypeInfo((uint64_t)&v44, (uint64_t)v40);
      v27(a4, &v44, v22);
      v28 = (re::DynamicString *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v21 + 32))(v21, 32, 8);
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = 0;
      *((_QWORD *)v28 + 3) = 0;
      *(_QWORD *)v28 = v22;
      re::DynamicString::setCapacity(v28, 0);
      v29 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
      if (v29 && *v29)
      {
        v30 = *((_QWORD *)v29 + 1);
        do
        {
          if ((*(_WORD *)(v30 + 22) & 0x1000) != 0)
            v31 = (const char *)v30;
          else
            v31 = *(const char **)(v30 + 8);
          v32 = strlen(v31);
          v44 = v31;
          v45[0] = v32;
          re::DynamicString::operator=(v28, (uint64_t)&v44);
          v33 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, re::DynamicString *))(v41 + 104))(a4, v40, *(_QWORD *)(a1 + 48), v28);
          v24(a1, v31, 0, v33, v43, v42, 0);
          v30 += 48;
        }
        while (v30 != *((_QWORD *)v29 + 1) + 48 * *v29);
      }
      if (*(_QWORD *)v28)
      {
        if ((*((_BYTE *)v28 + 8) & 1) != 0)
          (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)v28 + 40))(*(_QWORD *)v28, *((_QWORD *)v28 + 2));
        *(_OWORD *)v28 = 0u;
        *((_OWORD *)v28 + 1) = 0u;
      }
      (*(void (**)(uint64_t, re::DynamicString *))(*(_QWORD *)v21 + 40))(v21, v28);
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_14;
  v13 = *(_QWORD **)a6;
  v14 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v13, v14[9], &v44);
  re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)v45);
  v19 = re::TypeInfo::name((re::TypeInfo *)v43);
  if ((unint64_t)*v19 >> 1 == 0x22C6ED80D0CLL)
  {
    v20 = (char *)v19[1];
    if (v20 == "StringID" || !strcmp(v20, "StringID"))
      goto LABEL_14;
  }
  return 0;
}

BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t (*v23)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  unsigned int v24;
  _BOOL8 result;
  uint64_t (*v26)(uint64_t, unint64_t *, uint64_t);
  _anonymous_namespace_ *v27;
  unsigned int *v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  void *v32;
  char v33;
  void *v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  void *v45;
  _BYTE v46[16];
  uint64_t v47;
  _BYTE v48[32];
  _BYTE v49[32];
  unint64_t v50;
  _QWORD v51[5];

  if (this == a6)
    goto LABEL_14;
  v13 = *(_QWORD **)this;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v14 = (uint64_t *)*((_QWORD *)a6 + 2);
    v16 = *v14;
    if ((unsigned __int16)v15 != (unsigned __int16)*v14)
      goto LABEL_10;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v21 = *(_QWORD *)(a1 + 48);
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v50);
      re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v51);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v50);
      re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v51);
      re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)this);
      v22 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v49);
      if (!v22)
      {
        v36 = re::TypeInfo::name((re::TypeInfo *)v49);
        return 0;
      }
      v23 = (uint64_t (*)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v22;
      v24 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
      result = 0;
      if (!v24)
        return result;
      v26 = *(uint64_t (**)(uint64_t, unint64_t *, uint64_t))(v47 + 96);
      re::TypeInfo::TypeInfo((uint64_t)&v50, (uint64_t)v46);
      v27 = (_anonymous_namespace_ *)v26(a4, &v50, v21);
      v44 = 0;
      v45 = &str_110;
      v28 = *(unsigned int **)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
      if (v28 && *v28)
      {
        v29 = *((_QWORD *)v28 + 1);
        do
        {
          if ((*(_WORD *)(v29 + 22) & 0x1000) != 0)
            v30 = (const char *)v29;
          else
            v30 = *(const char **)(v29 + 8);
          v42 = 0;
          v43 = &str_110;
          v31 = v42;
          v32 = v43;
          v42 = 0;
          v43 = &str_110;
          v33 = v44;
          v34 = v45;
          v44 = v31;
          v45 = v32;
          v50 = v31 & 0xFFFFFFFFFFFFFFFELL | v33 & 1;
          v51[0] = v34;
          re::StringID::destroyString((re::StringID *)&v50);
          re::StringID::destroyString((re::StringID *)&v42);
          v35 = (*(uint64_t (**)(uint64_t, _BYTE *, _QWORD, uint64_t *))(v47 + 104))(a4, v46, *(_QWORD *)(a1 + 48), &v44);
          v27 = (_anonymous_namespace_ *)v23(a1, v30, 0, v35, v49, v48, 0);
          v29 += 48;
        }
        while (v29 != *((_QWORD *)v28 + 1) + 48 * *v28);
      }
      re::StringID::destroyString((re::StringID *)&v44);
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_14;
  v13 = *(_QWORD **)a6;
  v14 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v13, v14[9], &v50);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v51);
  v19 = re::TypeInfo::name((re::TypeInfo *)v49);
  if ((unint64_t)*v19 >> 1 == 0x134375A94D9F7110)
  {
    v20 = (char *)v19[1];
    if (v20 == "DynamicString" || !strcmp(v20, "DynamicString"))
      goto LABEL_14;
  }
  return 0;
}

unsigned int *re::serializeDynamicString<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _QWORD *a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t *v17;
  char *v18;
  unsigned int *result;
  _anonymous_namespace_ *v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  unint64_t v30;

  if (this == a6)
    goto LABEL_14;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_14;
  }
  v17 = re::TypeInfo::name(a6);
  if ((unint64_t)*v17 >> 1 != 0x22C6ED80D0CLL
    || (v18 = (char *)v17[1], v18 != "StringID") && strcmp(v18, "StringID"))
  {
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v30 = 0;
    result = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v30);
    if (!(_DWORD)result)
      return result;
    if (v30)
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_34;
  }
  v21 = a4[1];
  if ((v21 & 1) != 0)
    v22 = v21 >> 1;
  else
    v22 = v21 >> 1;
  v30 = v22;
  result = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v30);
  if ((_DWORD)result)
  {
    v23 = v30;
    if (v23 <= (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24)))
    {
      if (!*a4)
      {
        *a4 = *(_QWORD *)(a1 + 48);
        re::DynamicString::setCapacity(a4, v23 + 1);
      }
      re::DynamicString::resize(a4, v23, 0);
      if (v23)
      {
        if ((a4[1] & 1) != 0)
          v29 = (char *)a4[2];
        else
          v29 = (char *)a4 + 9;
      }
      v20 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_34:
      return (unsigned int *)(*(_BYTE *)(a1 + 64) == 0);
    }
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
    return 0;
  }
  return result;
}

unsigned int *re::serializeBool<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, BOOL *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeChar<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _BYTE *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeI8<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _BYTE *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeI16<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _WORD *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeI32<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unsigned int *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeI64<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, unint64_t *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeU8<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _BYTE *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeU16<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _WORD *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeU32<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _DWORD *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeU64<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, _QWORD *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
  }
  return 0;
}

unsigned int *re::serializeFloat<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, float *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
    return re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, a4, a7);
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    return re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, a4, a7);
  }
  return 0;
}

unsigned int *re::serializeDouble<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, double *a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  if (this == a6)
    return re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, a4, a7);
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)this + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    return re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, a4, a7);
  }
  return 0;
}

unsigned int *re::serializeCString<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, const char **a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int *result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  size_t v24;
  char *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  char v40;
  size_t v41;
  int v42;

  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_23:
      return 0;
    }
    v20 = **((_QWORD **)this + 2);
    v21 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v20 != (unsigned __int16)v21)
      goto LABEL_23;
    v23 = WORD1(v20) == WORD1(v21);
    v22 = (v21 ^ v20) & 0xFFFFFF00000000;
    v23 = v23 && v22 == 0;
    if (!v23)
      goto LABEL_23;
  }
LABEL_4:
  if (a7)
  {
    v42 = 0;
    v18 = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v42);
    result = 0;
    if (!v18)
      return result;
    if (!v42)
      goto LABEL_12;
    if (v42 != 1)
    {
      v41 = 0;
      if (re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v41))
      {
        if (v41)
      }
LABEL_12:
      goto LABEL_47;
    }
    goto LABEL_17;
  }
  v42 = 2 * (*a4 != 0);
  result = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v42);
  if (!(_DWORD)result)
    return result;
  if (v42)
  {
    if (v42 == 2)
    {
      if (*a4)
        v24 = strlen(*a4);
      else
        v24 = 0;
      v41 = v24;
      if (re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v41))
      {
        v25 = (char *)*a4;
        v26 = v41;
        if (!*a4 || v41 != v24)
        {
          if (v25)
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
            *a4 = 0;
          }
          if (v26 > (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24)))
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
            return 0;
          }
          v37 = v26 == -1;
          v38 = v37 << 63 >> 63;
          if (v38 != v37 || v38 < 0)
          {
            return 0;
          }
          v25 = (char *)(*(uint64_t (**)(_QWORD, unint64_t, _QWORD))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v26 + 1, 0);
          *a4 = v25;
          v24 = v26;
        }
        if (v24)
        {
          v25 = (char *)*a4;
        }
        else
        {
          v26 = 0;
        }
        v25[v26] = 0;
      }
    }
    else if (v42 == 1)
    {
LABEL_17:
      return 0;
    }
  }
  else if (*a4)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
    *a4 = 0;
  }
  v39 = *(unsigned __int8 *)(a1 + 64);
  if (!*a4 || !*(_BYTE *)(a1 + 64))
    return (unsigned int *)(v39 == 0);
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
  *a4 = 0;
LABEL_47:
  v39 = *(unsigned __int8 *)(a1 + 64);
  return (unsigned int *)(v39 == 0);
}

unsigned int *re::serializeStringID<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t *a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t *v17;
  char *v18;
  unsigned int *result;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  _anonymous_namespace_ *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;

  if (this == a6)
    goto LABEL_14;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_14;
  }
  v17 = re::TypeInfo::name(a6);
  if ((unint64_t)*v17 >> 1 != 0x134375A94D9F7110
    || (v18 = (char *)v17[1], v18 != "DynamicString") && strcmp(v18, "DynamicString"))
  {
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v43 = 0;
    result = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v43);
    if (!(_DWORD)result)
      return result;
    if (v43)
    goto LABEL_26;
  }
  v42 = 0;
  if (re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v42))
  {
    v20 = v42;
    if (v42)
    {
      if (v20 > (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24)))
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
        return 0;
      }
      v32 = v20 == -1;
      v33 = v32 << 63 >> 63;
      if (v33 != v32 || v33 < 0)
      {
        return 0;
      }
      v34 = (char *)(*(uint64_t (**)(_QWORD, unint64_t, _QWORD))(**(_QWORD **)(a1 + 56) + 32))(*(_QWORD *)(a1 + 56), v20 + 1, 0);
      v34[v20] = 0;
      v40 = 0;
      v41 = &str_110;
      v36 = v40;
      v37 = (uint64_t)v41;
      v40 = 0;
      v41 = &str_110;
      v38 = *a4;
      v39 = a4[1];
      *a4 = v36;
      a4[1] = v37;
      v43 = v36 & 0xFFFFFFFFFFFFFFFELL | v38 & 1;
      v44 = v39;
      re::StringID::destroyString((re::StringID *)&v43);
      re::StringID::destroyString((re::StringID *)&v40);
      (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 56) + 40))(*(_QWORD *)(a1 + 56), v34);
    }
    else
    {
      v40 = 0;
      v41 = &str_110;
      v31 = a4[1];
      v43 = *a4 & 1;
      v44 = v31;
      *a4 = 0;
      a4[1] = (uint64_t)&str_110;
      re::StringID::destroyString((re::StringID *)&v43);
      re::StringID::destroyString((re::StringID *)&v40);
    }
LABEL_26:
    return (unsigned int *)(*(_BYTE *)(a1 + 64) == 0);
  }
  return 0;
}

unsigned int *re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned int *result;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  char *v19;
  char *v20;
  re *v21;
  NSObject *v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  _QWORD *v29;
  uint64_t v30;
  char *v31;
  uint64_t v32;
  unint64_t v33;
  _BYTE buf[22];
  __int16 v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_4;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v25 = **((_QWORD **)this + 2);
    v26 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v25 == (unsigned __int16)v26)
    {
      v28 = WORD1(v25) == WORD1(v26);
      v27 = (v26 ^ v25) & 0xFFFFFF00000000;
      v28 = v28 && v27 == 0;
      if (v28)
        goto LABEL_4;
    }
LABEL_33:
    return 0;
  }
  if (!re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_33;
LABEL_4:
  if (a7)
  {
    v29 = 0;
    result = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v29);
    if (!(_DWORD)result)
      return result;
    if (v29)
  }
  else
  {
    v14 = **((_QWORD **)this + 2);
    v29 = *(_QWORD **)this;
    v30 = v14;
    LODWORD(v31) = -1;
    *(_QWORD *)buf = 0x258C98EAAF29A10ALL;
    *(_QWORD *)&buf[8] = "CallbackSerializerAttribute";
    v15 = (uint64_t *)re::TypeAttributeCollection::operator[]((uint64_t *)&v29, buf);
    re::StringID::destroyString((re::StringID *)buf);
    v16 = *v15;
    v17 = *(_QWORD *)(a1 + 264);
    v33 = 0;
    result = re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, (uint64_t *)&v33);
    if (!(_DWORD)result)
      return result;
    v18 = *(_QWORD **)(a1 + 56);
    v31 = 0;
    v32 = 0;
    v29 = v18;
    v30 = 0;
    re::DynamicString::setCapacity(&v29, 0);
    if (v33)
    {
      re::DynamicString::resize(&v29, v33, 0);
      if ((v30 & 1) != 0)
        v19 = v31;
      else
        v19 = (char *)&v30 + 1;
    }
    if ((v30 & 1) != 0)
      v20 = v31;
    else
      v20 = (char *)&v30 + 1;
    v21 = (re *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, char *))(v16 + 80))(*(_QWORD *)(a1 + 48), v17, v16, a4, v20);
    if ((v21 & 1) == 0)
    {
      v22 = *re::foundationSerializationLogObjects(v21);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
        if ((v30 & 1) != 0)
          v23 = v31;
        else
          v23 = (char *)&v30 + 1;
        v24 = re::TypeInfo::name(this)[1];
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = a2;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v23;
        v35 = 2080;
        v36 = v24;
        _os_log_impl(&dword_224FE9000, v22, OS_LOG_TYPE_INFO, "Failed to parse \"%s\": \"%s\" (type %s) using deserialization callback - skipping.", buf, 0x20u);
      }
    }
    if (v29 && (v30 & 1) != 0)
      (*(void (**)(void))(*v29 + 40))();
  }
  return (unsigned int *)(*(_BYTE *)(a1 + 64) == 0);
}

BOOL re::SerializerV1<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString(uint64_t a1, char *a2, const re::TypeInfo *a3, char **a4, re *this, re::TypeInfo *a6, char a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  _anonymous_namespace_ *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  __int128 v44;
  uint64_t v45;
  unsigned __int16 v46;
  unsigned __int16 v47;
  int v48;
  unsigned int v49;
  int v50;

  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_15:
      return 0;
    }
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 != (unsigned __int16)v14)
      goto LABEL_15;
    v16 = WORD1(v13) == WORD1(v14);
    v15 = (v14 ^ v13) & 0xFFFFFF00000000;
    v16 = v16 && v15 == 0;
    if (!v16)
      goto LABEL_15;
  }
LABEL_4:
  v50 = 0;
  if (re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v50))
  {
    if (v50 == 1)
    {
      v49 = 0;
      re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference((unsigned int *)(a1 + 24), &v49);
      if (!*(_BYTE *)(a1 + 64))
      {
        v23 = v49;
        if (*(_QWORD *)(a1 + 408) <= (unint64_t)v49)
        {
        }
        else
        {
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v49, (uint64_t)&v45);
          if (v45 == *(_QWORD *)this)
          {
            v24 = **((_QWORD **)this + 2);
            if (v46 == (unsigned __int16)v24 && v47 == WORD1(v24) && ((v48 ^ HIDWORD(v24)) & 0xFFFFFF) == 0)
            {
              if ((a7 & 1) == 0)
              {
                if (*a4)
                {
                  v42 = *a4;
                  if (v42 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v23))
                  {
                    (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48), *a4);
                    *a4 = 0;
                  }
                }
                *a4 = (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v23);
                re::internal::SharedObjectGraph::addReference((_QWORD *)(a1 + 336), v23);
              }
              goto LABEL_36;
            }
          }
          v25 = *(_anonymous_namespace_ **)(a1 + 272);
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v23, (uint64_t)&v45);
          v43 = *((_QWORD *)re::TypeRegistry::typeName(v25, &v45) + 1);
        }
      }
    }
    else
    {
      if (!v50)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
            *a4 = 0;
          }
        }
LABEL_36:
        return *(_BYTE *)(a1 + 64) == 0;
      }
      if ((a7 & 1) == 0 && *a4)
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
        *a4 = 0;
      }
      v45 = 0;
      if (re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((_BYTE *)(a1 + 24), a2, &v45))
      {
        v36 = v45;
        v37 = v45 == -1;
        v38 = v37 << 63 >> 63;
        if (v38 == v37 && (v38 & 0x8000000000000000) == 0)
        {
          v39 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v45 + 1, 0);
          v40 = (uint64_t)v39;
          if ((a7 & 1) == 0)
            *a4 = v39;
          if (v36)
          *(_BYTE *)(v40 + v36) = 0;
          v41 = **((_QWORD **)this + 2);
          *(_QWORD *)&v44 = *(_QWORD *)this;
          *((_QWORD *)&v44 + 1) = v41;
          re::internal::SharedObjectGraph::addObject(a1 + 336, v40, &v44);
          goto LABEL_36;
        }
      }
    }
  }
  return 0;
}

BOOL re::SerializerV1<re::EncoderRapidJSON<re::CFDataInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer(uint64_t a1, char *a2, int a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, int a7)
{
  const re::TypeInfo *v13;
  _BOOL4 isPointerToPolymorphicType;
  int v15;
  re *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  uint64_t *v29;
  uint64_t *v30;
  unsigned int v32;
  char *v33;
  uint64_t v34;
  char **v35;
  void **v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  char *v44;
  uint64_t v45;
  char v46;
  unsigned __int8 *v47;
  int v48;
  re::TypeRegistry *v49;
  uint64_t *v50;
  char *v51;
  uint64_t v52;
  re *v53;
  uint64_t v54;
  _anonymous_namespace_ *v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t *v60;
  const char *v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  re::TypeRegistry *v65;
  NSObject *v66;
  uint64_t *v67;
  uint64_t *v68;
  re *v69;
  uint64_t v70;
  void (*v71)(uint64_t);
  NSObject *v72;
  uint64_t v73;
  void **Instance;
  void **v75;
  char v76;
  uint64_t v77;
  char *__s2;
  __int128 v79;
  re *v80[2];
  _BYTE v81[20];
  int v82;
  _QWORD v83[2];
  uint64_t *v84;
  re *v85[2];
  re *v86[2];
  uint64_t *v87;
  _QWORD v88[2];
  re **v89;
  _QWORD v90[2];
  re *v91[4];
  re *v92;
  uint64_t v93;
  _QWORD v94[2];
  __int128 buf;
  uint64_t *v96;
  uint64_t v97;

  v97 = *MEMORY[0x24BDAC8D0];
  isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6)
    goto LABEL_4;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v25 = **((_QWORD **)this + 2);
    v26 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v25 == (unsigned __int16)v26)
    {
      v28 = WORD1(v25) == WORD1(v26);
      v27 = (v26 ^ v25) & 0xFFFFFF00000000;
      v28 = v28 && v27 == 0;
      if (v28)
        goto LABEL_4;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v13))
  {
LABEL_4:
    v15 = 0;
    goto LABEL_5;
  }
  if (*((_BYTE *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (v29 = re::TypeInfo::name(this), v30 = re::TypeInfo::name(a6), !re::StringID::operator==(v29, v30))))
  {
    return 0;
  }
  v15 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &buf);
  re::TypeInfo::TypeInfo((uint64_t)v88, (uint64_t)&buf + 8);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &buf);
  re::TypeInfo::TypeInfo((uint64_t)v86, (uint64_t)&buf + 8);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    v16 = *v89;
    v85[0] = (re *)v88[0];
    v85[1] = v16;
    if (v88[0])
      goto LABEL_8;
LABEL_15:
    v77 = re::TypeInfo::name(this)[1];
    v22 = "Failed to get actual type of polymorphic object. Type \"%s\".";
    v23 = a1;
    v24 = a2;
LABEL_16:
    return 0;
  }
  re::internal::actualType(a4, (void **)this, v85);
  if (!v85[0])
    goto LABEL_15;
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, v85, &buf);
  re::TypeInfo::TypeInfo((uint64_t)v83, (uint64_t)&buf + 8);
  v82 = 0;
  if (re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v82))
  {
    if (v82 != 1)
    {
      if (!v82)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)v83, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
            *a4 = 0;
          }
        }
        goto LABEL_111;
      }
      if (isPointerToPolymorphicType)
      {
        if (re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0))
        {
          v42 = *(_QWORD *)(*(_QWORD *)(a1 + 152) + 48 * *(_QWORD *)(a1 + 136) - 8);
          if (*(_DWORD *)v42)
          {
            v43 = *(char **)(v42 + 8);
            if ((*((_WORD *)v43 + 11) & 0x1000) != 0)
              v44 = v43;
            else
              v44 = (char *)*((_QWORD *)v43 + 1);
            if (v44)
            {
              v45 = *v44;
              if (*v44)
              {
                v46 = v44[1];
                if (v46)
                {
                  v47 = (unsigned __int8 *)(v44 + 2);
                  do
                  {
                    v45 = 31 * v45 + v46;
                    v48 = *v47++;
                    v46 = v48;
                  }
                  while (v48);
                }
              }
            }
            else
            {
              v45 = 0;
            }
            v56 = 2 * v45;
            __s2 = v44;
            v94[0] = 2 * v45;
            v94[1] = v44;
            v57 = *((_DWORD *)v87 + 20);
            v58 = (v57 - 1);
            if (v57 == 1)
              goto LABEL_80;
            v59 = 0;
            while (1)
            {
              re::TypeInfo::derivedClass((re::TypeInfo *)v86, v59, (uint64_t)&buf);
              v60 = re::TypeInfo::polymorphicObjectName((re::TypeInfo *)&buf);
              if ((*v60 ^ (unint64_t)v56) <= 1)
              {
                v61 = (const char *)v60[1];
                if (v61 == __s2 || !strcmp(v61, __s2))
                  break;
              }
              if (v58 == ++v59)
                goto LABEL_80;
            }
            v62 = *v96;
            v92 = (re *)buf;
            v93 = v62;
            if (!(_QWORD)buf)
            {
LABEL_80:
              v63 = re::TypeInfo::polymorphicObjectName((re::TypeInfo *)v86);
              if ((*v63 ^ (unint64_t)v56) > 1
                || (v63 = (uint64_t *)v63[1], v63 != (uint64_t *)__s2)
                && (v63 = (uint64_t *)strcmp((const char *)v63, __s2), (_DWORD)v63)
                || (v64 = *v87, v92 = v86[0], v93 = v64, !v86[0]))
              {
                v66 = *re::foundationSerializationLogObjects((re *)v63);
                if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
                {
                  LODWORD(buf) = 136315138;
                  *(_QWORD *)((char *)&buf + 4) = __s2;
                  _os_log_error_impl(&dword_224FE9000, v66, OS_LOG_TYPE_ERROR, "Skipping unknown polymorphic type. Type name = \"%s\"", (uint8_t *)&buf, 0xCu);
                  if ((a7 & 1) != 0)
                    goto LABEL_110;
                }
                else if ((a7 & 1) != 0)
                {
LABEL_110:
                  re::StringID::destroyString((re::StringID *)v94);
                  goto LABEL_111;
                }
                if (*a4)
                {
                  re::TypeInfo::releaseInstance((re::TypeInfo *)v83, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
                  *a4 = 0;
                }
                goto LABEL_110;
              }
            }
            if ((a7 & 1) == 0 && *a4)
            {
              re::TypeInfo::releaseInstance((re::TypeInfo *)v83, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
              *a4 = 0;
            }
            re::TypeRegistry::typeInfo(v86[0], &v92, &buf);
            re::TypeInfo::TypeInfo((uint64_t)v91, (uint64_t)&buf + 8);
            if (v15)
            {
              v65 = *(re::TypeRegistry **)(a1 + 272);
            }
            else
            {
              v65 = *(re::TypeRegistry **)(a1 + 272);
              if (*(re::TypeRegistry **)this == v65)
              {
                re::TypeInfo::operator=((uint64_t)v83, (uint64_t)v91);
                v69 = v92;
                v70 = v93;
                goto LABEL_105;
              }
            }
            v67 = re::TypeInfo::name((re::TypeInfo *)v91);
            v68 = re::TypeRegistry::typeInfo(v65, (const re::StringID *)v67, &buf);
            if (!(_BYTE)buf)
            {
              v72 = *re::foundationSerializationLogObjects((re *)v68);
              if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
              {
                v73 = re::TypeInfo::name((re::TypeInfo *)v91)[1];
                LODWORD(buf) = 136315138;
                *(_QWORD *)((char *)&buf + 4) = v73;
                _os_log_impl(&dword_224FE9000, v72, OS_LOG_TYPE_DEFAULT, "No matching runtime type found for serialized polymorphic type \"%s\". Skipping unknown type.", (uint8_t *)&buf, 0xCu);
              }
              *(_QWORD *)&buf = 0;
              *((_QWORD *)&buf + 1) = 0xFFFFFFFFLL;
              (*(void (**)(uint64_t, _QWORD, __int128 *))(*(_QWORD *)a1 + 16))(a1, 0, &buf);
              if (!*(_BYTE *)(a1 + 64))
                (*(void (**)(uint64_t, char *, _QWORD, _QWORD, re **, re **, uint64_t))(*(_QWORD *)a1 + 72))(a1, __s2, 0, 0, v91, v91, 1);
              goto LABEL_109;
            }
            re::TypeInfo::operator=((uint64_t)v83, (uint64_t)&buf + 8);
            v69 = (re *)v83[0];
            v70 = *v84;
LABEL_105:
            Instance = re::TypeInfo::createInstance((re::TypeInfo *)v83, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
            v75 = Instance;
            if ((a7 & 1) == 0)
            {
              *a4 = (char *)Instance;
              *(_QWORD *)&buf = v69;
              *((_QWORD *)&buf + 1) = v70;
              re::internal::setActualType(a4, (re **)this, (re **)&buf);
            }
            v90[0] = v69;
            v90[1] = v70;
            (*(void (**)(uint64_t, void **, _QWORD *))(*(_QWORD *)a1 + 16))(a1, v75, v90);
            if (!*(_BYTE *)(a1 + 64))
              (*(void (**)(uint64_t, char *, _QWORD, void **, _QWORD *, re **, BOOL))(*(_QWORD *)a1 + 72))(a1, __s2, 0, v75, v83, v91, v75 == 0);
LABEL_109:
            (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
            goto LABEL_110;
          }
        }
LABEL_111:
        return *(_BYTE *)(a1 + 64) == 0;
      }
      if (!a7)
      {
        v51 = *a4;
        if (!*a4)
          v51 = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v88, *(re::Allocator **)(a1 + 48), 0);
        v52 = 0;
        *a4 = v51;
        goto LABEL_62;
      }
      v49 = *(re::TypeRegistry **)(a1 + 272);
      if ((re::TypeRegistry *)v88[0] != v49)
      {
        v50 = re::TypeInfo::name((re::TypeInfo *)v88);
        re::TypeRegistry::typeInfo(v49, (const re::StringID *)v50, &buf);
        if (!(_BYTE)buf)
        {
          v51 = 0;
          v52 = 1;
          goto LABEL_62;
        }
        re::TypeInfo::operator=((uint64_t)v88, (uint64_t)&buf + 8);
      }
      v51 = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v88, *(re::Allocator **)(a1 + 48), 0);
      v52 = 0;
LABEL_62:
      v53 = *v89;
      *(_QWORD *)&v79 = v88[0];
      *((_QWORD *)&v79 + 1) = v53;
      re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), (uint64_t)v51, &v79);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, char *, _QWORD, char *, _QWORD *, re **, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, 0, v51, v88, v86, v52);
      if (*(_BYTE *)(a1 + 336))
      {
        --*(_QWORD *)(a1 + 488);
        ++*(_DWORD *)(a1 + 496);
      }
      goto LABEL_111;
    }
    LODWORD(v94[0]) = 0;
    re::EncoderRapidJSON<re::FixedArrayInputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference((unsigned int *)(a1 + 24), v94);
    if (!*(_BYTE *)(a1 + 64))
    {
      v32 = v94[0];
      if (*(_QWORD *)(a1 + 408) > (unint64_t)LODWORD(v94[0]))
      {
        re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v94[0], (uint64_t)v81);
        if (!re::internal::areCompatible((re **)this, (uint64_t)v81))
        {
          v54 = re::TypeInfo::name((re::TypeInfo *)v88)[1];
          v55 = *(_anonymous_namespace_ **)(a1 + 272);
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v32, (uint64_t)&buf);
          LOBYTE(v77) = v54;
          re::TypeRegistry::typeName(v55, &buf);
          v22 = "Invalid reference. Objects are not compatible. Expected type \"%s\". Actual type \"%s\".";
          goto LABEL_68;
        }
        if ((a7 & 1) != 0)
          goto LABEL_111;
        if (*a4)
        {
          v33 = *a4;
          if (v33 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v32))
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)v83, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
            *a4 = 0;
          }
        }
        v34 = re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 336), v32);
        v35 = (char **)v34;
        *a4 = (char *)v34;
        if ((*((_BYTE *)v84 + 49) & 2) != 0)
        {
          v71 = (void (*)(uint64_t))v84[4];
          if (v71)
            v71(v34);
          re::internal::SharedObjectGraph::addReference((_QWORD *)(a1 + 336), v32);
        }
        else
        {
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v32, (uint64_t)v91);
          if (!v91[0])
          {
            LOBYTE(v77) = v32;
            v22 = "TypeID for shared object at index %d is invalid.";
            goto LABEL_68;
          }
          re::TypeRegistry::typeInfo(v91[0], v91, &buf);
          if (!(_BYTE)buf)
          {
            LOBYTE(v77) = v32;
            v22 = "No TypeInfo found for shared object at index %d.";
            goto LABEL_68;
          }
          v36 = re::TypeInfo::createInstance((re::TypeInfo *)((char *)&buf + 8), *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264));
          *a4 = (char *)v36;
          if ((re::TypeInfo::copy((re::TypeInfo *)((char *)&buf + 8), v36, v35, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 264)) & 1) == 0)
          {
            v77 = re::TypeInfo::name((re::TypeInfo *)((char *)&buf + 8))[1];
            v22 = "Failed to copy non-shareable object of type '%s'.";
LABEL_68:
            v23 = a1;
            v24 = 0;
            goto LABEL_16;
          }
        }
        re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 336), v32, (uint64_t)v80);
        re::TypeInfo::setActualTypeForPointer((_QWORD **)this, (uint64_t)a4, v80);
        goto LABEL_111;
      }
      LOBYTE(v77) = v94[0];
      v22 = "Invalid reference ID for shared object: %u";
      goto LABEL_68;
    }
  }
  return 0;
}

BOOL re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(uint64_t a1, const char *a2, int a3)
{
  int v3;
  _OWORD v7[3];
  const char *v8;

  v8 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v8);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartObject(*(_QWORD *)(a1 + 168));
    LOBYTE(v7[0]) = 2;
    DWORD1(v7[0]) = a3 | 0x20;
    *((_QWORD *)&v7[0] + 1) = v8;
    memset(&v7[1], 0, 32);
    re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, v7);
  }
  return v3 == 0;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t *v2;
  uint64_t v3;

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    v2 = (uint64_t *)*((_QWORD *)result + 21);
    v2[4] -= 16;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndObject(v2);
    v3 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
    ++*(_QWORD *)(v3 - 16);
  }
  return result;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED88C40;
  v2 = *(_QWORD *)(a1 + 472);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 504))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 480) = 0;
    *(_QWORD *)(a1 + 488) = 0;
    *(_QWORD *)(a1 + 472) = 0;
    ++*(_DWORD *)(a1 + 496);
  }
  v3 = *(_QWORD *)(a1 + 432);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 464))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 464) = 0;
    *(_QWORD *)(a1 + 440) = 0;
    *(_QWORD *)(a1 + 448) = 0;
    *(_QWORD *)(a1 + 432) = 0;
    ++*(_DWORD *)(a1 + 456);
  }
  v4 = *(_QWORD *)(a1 + 392);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 344));
  return re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
}

void re::SerializerV1<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED88C40;
  v2 = *(_QWORD *)(a1 + 472);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 504))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 480) = 0;
    *(_QWORD *)(a1 + 488) = 0;
    *(_QWORD *)(a1 + 472) = 0;
    ++*(_DWORD *)(a1 + 496);
  }
  v3 = *(_QWORD *)(a1 + 432);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 464))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 464) = 0;
    *(_QWORD *)(a1 + 440) = 0;
    *(_QWORD *)(a1 + 448) = 0;
    *(_QWORD *)(a1 + 432) = 0;
    ++*(_DWORD *)(a1 + 456);
  }
  v4 = *(_QWORD *)(a1 + 392);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 344));
  re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::SerializerV1<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::trackObject(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v4;

  v4 = *a3;
  return re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), a2, &v4);
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::untrackObject(uint64_t result)
{
  if (*(_BYTE *)(result + 336))
  {
    --*(_QWORD *)(result + 488);
    ++*(_DWORD *)(result + 496);
  }
  return result;
}

void re::SerializerV1<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doOpen(uint64_t a1)
{
  *(_BYTE *)(a1 + 337) = 0;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 344);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
  *(_QWORD *)(a1 + 448) = 0;
  ++*(_DWORD *)(a1 + 456);
  *(_QWORD *)(a1 + 488) = 0;
  ++*(_DWORD *)(a1 + 496);
}

void re::SerializerV1<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doClose(uint64_t a1)
{
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 344);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
  *(_QWORD *)(a1 + 448) = 0;
  ++*(_DWORD *)(a1 + 456);
  *(_QWORD *)(a1 + 488) = 0;
  ++*(_DWORD *)(a1 + 496);
}

void re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doRegisterSerializeFuncs(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 *v7;
  __int128 v8;
  __int128 v9;
  _QWORD v10[2];
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;

  v11 = 6059476;
  v12 = "BOOL";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeBool<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6104748;
  v12 = "char";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeChar<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x172E117BCLL;
  v12 = "int8_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI8<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93A4A92;
  v12 = "int16_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI16<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93BFE06;
  v12 = "int32_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI32<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93EC744;
  v12 = "int64_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6655224;
  v12 = "long";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x31CD534126;
  v12 = "uint8_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU8<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0D4E68;
  v12 = "uint16_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU16<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0F01DCLL;
  v12 = "uint32_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU32<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD11CB1ALL;
  v12 = "uint64_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x1947BDF6CLL;
  v12 = "size_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 195052728;
  v12 = "float";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeFloat<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x161EEF7A2;
  v12 = "double";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDouble<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 189247272;
  v12 = "char*";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeCString<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2686EB529B3EE220;
  v12 = "DynamicString";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDynamicString<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x458DDB01A18;
  v12 = "StringID";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeStringID<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v2 = *(_QWORD *)(a1 + 272);
  v11 = 0x258C98EAAF29A10ALL;
  v12 = "CallbackSerializerAttribute";
  v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v11);
  if (v3)
  {
    v4 = *v3;
    re::StringID::destroyString((re::StringID *)&v11);
    if (v2)
    {
      v5 = *(_QWORD *)(a1 + 272);
      v10[0] = v2;
      v10[1] = v4;
      re::TypeRegistry::attributesByAttributeType(v5, (uint64_t)v10, (uint64_t)&v11);
      if (v13)
      {
        v6 = 48 * v13;
        v7 = (__int128 *)(v14 + 16);
        do
        {
          v8 = *v7;
          v7 += 3;
          v9 = v8;
          re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, (uint64_t)&v9, (uint64_t)re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
          v6 -= 48;
        }
        while (v6);
      }
      if (v11)
      {
        if (v14)
          (*(void (**)(void))(*(_QWORD *)v11 + 40))();
      }
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v11);
  }
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t result;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;

  v14 = (_BYTE *)(a1 + 336);
  v15 = *(_QWORD *)(a1 + 488);
  if (!v15)
  {
    if ((_DWORD)a7)
      v16 = 0;
    else
      v16 = a4;
    v17 = **((_QWORD **)a5 + 2);
    *(_QWORD *)&v26 = *(_QWORD *)a5;
    *((_QWORD *)&v26 + 1) = v17;
    re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), v16, &v26);
  }
  v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v18)
  {
    result = v18(a1, a2, a3, a4, a5, a6, a7);
    if (!v15)
    {
      if (*v14)
      {
        --*(_QWORD *)(a1 + 488);
        ++*(_DWORD *)(a1 + 496);
      }
    }
  }
  else
  {
    v20 = re::TypeInfo::name(a5);
    return 0;
  }
  return result;
}

uint64_t (*re::SerializerV1<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, re::TypeInfo *this))(uint64_t a1, const char *a2, int a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  uint64_t *v4;
  uint64_t v5;
  char *v6;
  unsigned int v7;
  uint64_t (*result)(uint64_t, const char *, int, char **, re::TypeInfo *, const re::TypeInfo *, char);
  uint64_t v9;

  v4 = re::TypeInfo::name(this);
  if ((unint64_t)*v4 >> 1 == 94623636)
  {
    v6 = (char *)v4[1];
    if (v6 == "char*" || !strcmp(v6, "char*"))
      return (uint64_t (*)(uint64_t, const char *, int, char **, re::TypeInfo *, const re::TypeInfo *, char))re::SerializerV1<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString;
  }
  if (*((_BYTE *)this + 12) == 9)
  {
    v7 = *(unsigned __int8 *)(*((_QWORD *)this + 2) + 80);
    if (v7 >= 2)
    {
      if (v7 == 2)
      {
        re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) External references are not supported by the SerializerV1.", "!\"Unreachable code\"", "doResolveSerializeFunc", 82);
        _os_crash();
        __break(1u);
      }
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Invalid PointerSharing type.", "!\"Unreachable code\"", "doResolveSerializeFunc", 84);
      result = (uint64_t (*)(uint64_t, const char *, int, char **, re::TypeInfo *, const re::TypeInfo *, char))_os_crash();
      __break(1u);
    }
    else
    {
      return re::SerializerV1<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer;
    }
  }
  else if (*(_QWORD *)this == *(_QWORD *)(a1 + 272)
         && (v9 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, **((_QWORD **)this + 2) | 0xFFFFFFFF00000000)) != 0)
  {
    return *(uint64_t (**)(uint64_t, const char *, int, char **, re::TypeInfo *, const re::TypeInfo *, char))v9;
  }
  else
  {
    return (uint64_t (*)(uint64_t, const char *, int, char **, re::TypeInfo *, const re::TypeInfo *, char))re::serializeType<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  }
  return result;
}

void re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t (*v14)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v14)
    return v14(a1, a2, a3, a4, a5, a6, a7);
  v16 = re::TypeInfo::name(a5);
  return 0;
}

uint64_t (*re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(re::internal **a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *this, re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v3;

  if (*(_QWORD *)a2 == *(_QWORD *)(a1 + 272)
    && (v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, **(_QWORD **)(a2 + 16) | 0xFFFFFFFF00000000)) != 0)
  {
    return *(uint64_t (**)(re::internal **, const char *, const re::TypeInfo *, unsigned __int8 *, re *, re::TypeInfo *, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  }
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  double v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_24ED88CA8;
  if (*(_QWORD *)(a1 + 272))
  {
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(a1 + 288);
    *(_QWORD *)(a1 + 272) = 0;
  }
  v2 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)(a1 + 288));
  v3 = *(_QWORD *)(a1 + 216);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 248))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v3 + 40))(v3, v2);
    *(_QWORD *)(a1 + 248) = 0;
    *(_QWORD *)(a1 + 224) = 0;
    *(_QWORD *)(a1 + 232) = 0;
    *(_QWORD *)(a1 + 216) = 0;
    ++*(_DWORD *)(a1 + 240);
  }
  v4 = *(_QWORD *)(a1 + 120);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 152))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 152) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = 0;
    *(_QWORD *)(a1 + 120) = 0;
    ++*(_DWORD *)(a1 + 144);
  }
  if (*(_BYTE *)(a1 + 64))
  {
    v5 = *(_QWORD *)(a1 + 88);
    if (v5)
    {
      if ((*(_BYTE *)(a1 + 96) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *(_QWORD *)(a1 + 104));
      *(_OWORD *)(a1 + 88) = 0u;
      *(_OWORD *)(a1 + 104) = 0u;
    }
  }
  re::StringID::destroyString((re::StringID *)(a1 + 8));
  return a1;
}

uint64_t re::serializeType<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::internal **a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *this, re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t *v23;
  unint64_t v24;
  uint64_t result;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  const re::TypeInfo *v30;
  uint64_t *v31;
  int v32;
  unint64_t v33;
  char *v34;
  BOOL (*v35)(uint64_t, const char *, const re::TypeInfo *, uint64_t, re *, re::TypeInfo *, int);
  _anonymous_namespace_ *v36;
  uint64_t *v37;
  const re::TypeInfo *v38;
  char *v39;
  uint64_t v40;
  _BOOL4 v41;
  uint64_t v42;
  const re::TypeInfo *v43;
  uint64_t v44;
  unsigned __int32 v45;
  const char *v46;
  uint64_t *v47;
  unsigned __int8 *v48;
  const re::TypeInfo *v49;
  re *v50;
  uint64_t *v51;
  uint64_t v52;
  re::UnionAccessor *v53;
  unint64_t Tag;
  unint64_t v55;
  char *v56;
  re::TypeRegistry *v57;
  re *v58;
  re::TypeInfo *v59;
  uint64_t v60;
  const char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t *v69;
  _BOOL4 v70;
  uint64_t v71;
  uint64_t v72;
  _anonymous_namespace_ *v73;
  uint64_t v74;
  double v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v81;
  uint64_t v82;
  int v83;
  re::internal *v84;
  uint64_t v85;
  void (*v86)(re::internal **, _QWORD, _QWORD, _QWORD, rapidjson::internal **, rapidjson::internal **, uint64_t);
  uint64_t v87;
  int v88;
  unint64_t v89;
  int v90;
  uint64_t v91;
  void (*v92)(re::internal **, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD);
  _QWORD *v93;
  int v94;
  int v95;
  _anonymous_namespace_ *v96;
  BOOL v97;
  char v98;
  uint64_t v99;
  uint64_t v100;
  re::internal *v101;
  _BOOL4 v102;
  _anonymous_namespace_ *v103;
  uint64_t v104;
  void (*v105)(re::internal **, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD);
  uint64_t v106;
  _BOOL4 v107;
  uint64_t i;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  char *v114;
  const char *v115;
  char *v116;
  uint64_t v117;
  uint64_t v118;
  re::internal *v119;
  re::internal *v120;
  _anonymous_namespace_ *v121;
  re::TypeInfo *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  void (*v129)(re::internal **, const char *, _QWORD, uint64_t, _QWORD *, _QWORD **, _QWORD);
  uint64_t v130;
  void (*v131)(re::internal **, const char *, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD);
  unint64_t v132;
  _QWORD *v133;
  unint64_t *v134;
  unint64_t v135;
  unint64_t v136;
  uint64_t (**v137)(uint64_t, uint64_t);
  uint64_t (*v138)(uint64_t, uint64_t);
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  __n128 v142;
  uint64_t v143;
  unint64_t v144;
  double v145;
  unint64_t v146;
  void (*v147)(void);
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  BOOL v151;
  _anonymous_namespace_ *v152;
  unsigned int EnumConstantIndex;
  unsigned int v154;
  re::internal::TypeTranslationTable *v155;
  uint64_t v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t v159;
  BOOL v160;
  char v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  re::internal **v166;
  const char *v167;
  const re::TypeInfo *v168;
  unsigned __int8 *v169;
  unint64_t v170;
  uint64_t v171;
  const char *v172;
  uint64_t v173;
  unint64_t v174;
  uint64_t v175;
  char *v176;
  uint64_t (*v177)(unsigned __int8 *, re::internal *);
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  double v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  unint64_t v195;
  char v196[16];
  uint64_t v197;
  _BYTE v198[32];
  uint64_t v199;
  rapidjson::internal *v200;
  uint64_t v201;
  unint64_t v202;
  int v203;
  char *v204;
  _QWORD *v205[4];
  uint64_t v206[4];
  _QWORD v207[4];
  _BYTE v208[28];
  __int16 v209;
  unint64_t v210;
  __n128 __dst;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  uint64_t v216;

  v216 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_18;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        goto LABEL_18;
    }
LABEL_10:
    if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12))
      goto LABEL_283;
    v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
    if (v19)
      v20 = *(_DWORD *)(v19 + 16);
    else
      v20 = -1;
    v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
    if (v21)
      v22 = *(_DWORD *)(v21 + 16);
    else
      v22 = -1;
    if (v20 != v22)
    {
      v26 = re::TypeInfo::name(this)[1];
      re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
      re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
      LOBYTE(v193) = v26;
      v46 = "Cannot serialize type \"%s\" version %u as version %u. Downgrading versions is not supported.";
LABEL_74:
      return 0;
    }
    goto LABEL_18;
  }
  if (!re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_10;
LABEL_18:
  switch(*((_BYTE *)this + 12))
  {
    case 1:
      if (this == a6)
        goto LABEL_22;
      if (*(_QWORD *)this != *(_QWORD *)a6)
      {
        if (!re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_283;
LABEL_22:
        v23 = re::TypeInfo::name(this);
        v24 = (unint64_t)*v23 >> 1;
        if (v24 <= 0xCA3DEFB5)
        {
          if ((unint64_t)*v23 >> 1 <= 0x5D0225B)
          {
            if ((unint64_t)*v23 >> 1 <= 0x2E9355)
            {
              if (v24 != 104431)
              {
                if (v24 == 3029738)
                  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool((uint64_t)(a1 + 3), a2, a4);
LABEL_335:
                v193 = re::TypeInfo::name(this)[1];
                v46 = "Unsupported basic type \"%s\".";
                goto LABEL_74;
              }
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>((uint64_t)(a1 + 3), a2, (unsigned int *)a4);
            }
            if (v24 == 3052374)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar((uint64_t)(a1 + 3), a2, (uint64_t)a4);
            v165 = 3327612;
LABEL_269:
            if (v24 == v165)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>((uint64_t)(a1 + 3), a2, (unint64_t *)a4);
            goto LABEL_335;
          }
          if ((unint64_t)*v23 >> 1 > 0xB0F77BD0)
          {
            if (v24 == 2969009105)
              return re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>((uint64_t)(a1 + 3), a2, (double *)a4);
            if (v24 == 3111160798)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>((uint64_t)(a1 + 3), a2, (char *)a4);
            goto LABEL_335;
          }
          if (v24 == 97526364)
            return re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>((uint64_t)(a1 + 3), a2, (float *)a4);
          v52 = 109413500;
LABEL_176:
          if (v24 == v52)
            return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>((uint64_t)(a1 + 3), a2, (__int16 *)a4);
          goto LABEL_335;
        }
        if ((unint64_t)*v23 >> 1 > 0x18E6A9A092)
        {
          if ((unint64_t)*v23 >> 1 <= 0x303EE8780EDLL)
          {
            if (v24 == 0x18E6A9A093)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>((uint64_t)(a1 + 3), a2, a4);
            if (v24 == 0x303EE86A734)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>((uint64_t)(a1 + 3), a2, (unsigned __int16 *)a4);
            goto LABEL_335;
          }
          if (v24 == 0x303EE8780EELL)
            return re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>((uint64_t)(a1 + 3), a2, (unsigned int *)a4);
          if (v24 != 0x303EE88E58DLL)
            goto LABEL_335;
        }
        else
        {
          if ((unint64_t)*v23 >> 1 > 0x16749DFF02)
          {
            if (v24 == 0x16749DFF03)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>((uint64_t)(a1 + 3), a2, (unsigned int *)a4);
            v165 = 0x16749F63A2;
            goto LABEL_269;
          }
          if (v24 != 3393056694)
          {
            v52 = 0x16749D2549;
            goto LABEL_176;
          }
        }
        return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>((uint64_t)(a1 + 3), a2, (rapidjson::internal **)a4);
      }
      v62 = **((_QWORD **)this + 2);
      v63 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v62 == (unsigned __int16)v63)
      {
        v18 = WORD1(v62) == WORD1(v63);
        v64 = (v63 ^ v62) & 0xFFFFFF00000000;
        if (v18 && v64 == 0)
          goto LABEL_22;
      }
      goto LABEL_283;
    case 2:
      if (this == a6)
        goto LABEL_227;
      if (*(_QWORD *)this != *(_QWORD *)a6)
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_109;
        v27 = *((unsigned __int8 *)this + 12);
LABEL_107:
        if (v27 == *((unsigned __int8 *)a6 + 12))
        {
          v68 = re::TypeInfo::name(this);
          v69 = re::TypeInfo::name(a6);
          if (re::StringID::operator==(v68, v69))
            goto LABEL_109;
        }
LABEL_283:
        return 0;
      }
      v66 = **((_QWORD **)this + 2);
      v67 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v66 != (unsigned __int16)v67
        || WORD1(v66) != WORD1(v67)
        || ((v67 ^ v66) & 0xFFFFFF00000000) != 0)
      {
        v27 = 2;
        goto LABEL_107;
      }
LABEL_109:
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v148 = **((_QWORD **)this + 2);
        v149 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v148 == (unsigned __int16)v149
          && ((v18 = WORD1(v148) == WORD1(v149), v150 = (v149 ^ v148) & 0xFFFFFF00000000, v18)
            ? (v151 = v150 == 0)
            : (v151 = 0),
              v151))
        {
LABEL_227:
          v70 = 0;
        }
        else
        {
          v70 = 1;
        }
      }
      else
      {
        v70 = !re::areSameTranslatedVersion(this, a6, a3);
      }
      if ((_DWORD)a7)
      {
        __dst.n128_u64[0] = 0;
        result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((uint64_t)(a1 + 3), a2, (uint64_t *)&__dst);
        if (!(_DWORD)result)
          return result;
        v152 = (_anonymous_namespace_ *)(a1 + 3);
LABEL_231:
        return *((_BYTE *)a1 + 64) == 0;
      }
      if (*(_DWORD *)(*((_QWORD *)this + 2) + 8) >= 9u)
      {
        v193 = re::TypeInfo::name(this)[1];
        v46 = "Enum type \"%s\" has invalid size: %zu bytes";
        goto LABEL_74;
      }
      EnumConstantIndex = re::internal::getEnumConstantIndex(this, (const re::TypeInfo *)a4, a3);
      if ((EnumConstantIndex & 0x80000000) != 0)
      {
        __dst.n128_u64[0] = 0;
        memcpy(&__dst, a4, *(unsigned int *)(*((_QWORD *)this + 2) + 8));
        LOBYTE(v193) = __dst.n128_u8[0];
        re::TypeInfo::name(this);
        v46 = "Value %zu is not a valid enum constant of \"%s\".";
        goto LABEL_74;
      }
      v154 = EnumConstantIndex;
      if (v70)
      {
        v155 = *(re::internal::TypeTranslationTable **)(*(_QWORD *)a6 + 856);
        if (!v155 || (v156 = re::internal::TypeTranslationTable::translateRuntimeEnum(v155, this, v154, a6)) == 0)
        {
          v157 = re::TypeInfo::enumConstants(this);
          v159 = v154;
          if (v158 > v154)
          {
            v193 = *(_QWORD *)(v157 + 24 * v154 + 16);
            re::TypeInfo::name(a6);
            v46 = "Runtime enum constant \"%s\" does not exist in serialized type \"%s\".";
            goto LABEL_74;
          }
LABEL_356:
          re::internal::assertLog((re::internal *)6, v158, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v159, v158);
          _os_crash();
          __break(1u);
        }
LABEL_292:
        v172 = *(const char **)(v156 + 16);
        __dst.n128_u64[0] = strlen(v172);
        if (!re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((uint64_t)(a1 + 3), a2, (uint64_t *)&__dst))return 0;
        re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString((uint64_t)(a1 + 3), (uint64_t)v172);
        v152 = (_anonymous_namespace_ *)(a1 + 3);
        goto LABEL_231;
      }
      result = re::TypeInfo::enumConstants(this);
      v171 = v154;
      if (v170 <= v154)
      {
LABEL_355:
        re::internal::assertLog((re::internal *)6, v170, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v171, v170);
        _os_crash();
        __break(1u);
        goto LABEL_356;
      }
      if (result)
      {
        v156 = result + 24 * v154;
        goto LABEL_292;
      }
      return result;
    case 3:
      if (this == a6)
        goto LABEL_116;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v71 = **((_QWORD **)this + 2);
        v72 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v71 == (unsigned __int16)v72
          && WORD1(v71) == WORD1(v72)
          && ((v72 ^ v71) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_116;
        }
        v28 = 3;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_116;
        v28 = *((unsigned __int8 *)this + 12);
      }
      if (v28 != *((unsigned __int8 *)a6 + 12))
        goto LABEL_283;
LABEL_116:
      if ((_DWORD)a7)
      {
        __dst.n128_u8[0] = 0;
        re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional((uint64_t)(a1 + 3), a2, &__dst);
        v73 = (_anonymous_namespace_ *)(a1 + 3);
      }
      else
      {
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)&v200, (uint64_t)&__dst.n128_i64[1]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
        re::TypeInfo::TypeInfo((uint64_t)&__dst, (uint64_t)this);
        v74 = (*(uint64_t (**)(unsigned __int8 *))(v212 + 80))(a4);
        LOBYTE(v207[0]) = v74 != 0;
        v75 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional((uint64_t)(a1 + 3), a2, v207);
        if (v74)
        {
          v76 = (*(uint64_t (**)(unsigned __int8 *, double))(v212 + 80))(a4, v75);
          if (!*((_BYTE *)a1 + 64))
            (*((void (**)(re::internal **, const char *, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD))*a1
             + 9))(a1, a2, 0, v76, &v200, v208, 0);
        }
        v73 = (_anonymous_namespace_ *)(a1 + 3);
      }
      return *((_BYTE *)a1 + 64) == 0;
    case 4:
      if (this == a6)
        goto LABEL_131;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v77 = **((_QWORD **)this + 2);
        v78 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v77 == (unsigned __int16)v78)
        {
          v18 = WORD1(v77) == WORD1(v78);
          v79 = (v78 ^ v77) & 0xFFFFFF00000000;
          if (v18 && v79 == 0)
            goto LABEL_131;
        }
      }
      else if (re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_131;
      }
      if (*((_BYTE *)a6 + 12) != 4)
        goto LABEL_283;
      v81 = *((_QWORD *)this + 2);
      v82 = *((_QWORD *)a6 + 2);
      v83 = *(_DWORD *)(v82 + 84) & 0xFFFFFF;
      if ((*(_DWORD *)(v81 + 84) & 0xFFFFFF) != 0)
      {
        if (!v83)
          goto LABEL_283;
      }
      else if (v83 || *(_DWORD *)(v81 + 88) != *(_DWORD *)(v82 + 88))
      {
        goto LABEL_283;
      }
LABEL_131:
      if ((_DWORD)a7)
      {
        v84 = a1[34];
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
        re::internal::translateType(v84, (const re::TypeRegistry *)v208, (uint64_t)&v200);
        v85 = (*((uint64_t (**)(re::internal **, rapidjson::internal **))*a1 + 10))(a1, &v200);
        if (!v85)
          goto LABEL_201;
        v86 = (void (*)(re::internal **, _QWORD, _QWORD, _QWORD, rapidjson::internal **, rapidjson::internal **, uint64_t))v85;
        v87 = *((_QWORD *)a6 + 2);
        v88 = *(_DWORD *)(v87 + 84) & 0xFFFFFF;
        if (v88)
        {
          v89 = 0;
          v90 = 8;
        }
        else
        {
          v89 = *(int *)(v87 + 88);
          v90 = 4;
        }
        __dst.n128_u64[0] = v89;
        v96 = (_anonymous_namespace_ *)(a1 + 3);
        result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((uint64_t)(a1 + 3), a2, (uint64_t *)&__dst, v90);
        if (!(_DWORD)result)
          return result;
        if (v88)
          v160 = v89 == 0;
        else
          v160 = 1;
        v161 = v160;
        if (!v160)
        {
          v207[0] = 0;
          v207[1] = 0xFFFFFFFFLL;
          (*((void (**)(re::internal **, _QWORD, _QWORD *))*a1 + 2))(a1, 0, v207);
        }
        for (; v89; --v89)
          v86(a1, 0, 0, 0, &v200, &v200, 1);
        if ((v161 & 1) != 0)
          goto LABEL_298;
      }
      else
      {
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)&v200, (uint64_t)&__dst.n128_i64[1]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
        re::TypeInfo::TypeInfo((uint64_t)&__dst, (uint64_t)this);
        v91 = (*((uint64_t (**)(re::internal **, rapidjson::internal **))*a1 + 10))(a1, &v200);
        if (!v91)
          goto LABEL_201;
        v92 = (void (*)(re::internal **, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD))v91;
        v93 = (_QWORD *)re::ArrayAccessor::size((re::ArrayAccessor *)&__dst, (char *)a4);
        v205[0] = v93;
        v94 = *(_DWORD *)(*((_QWORD *)this + 2) + 84) & 0xFFFFFF;
        if (v94)
          v95 = 8;
        else
          v95 = 4;
        v96 = (_anonymous_namespace_ *)(a1 + 3);
        result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((uint64_t)(a1 + 3), a2, (uint64_t *)v205, v95);
        if (!(_DWORD)result)
          return result;
        if (v94)
          v97 = v93 == 0;
        else
          v97 = 1;
        v98 = v97;
        if (v97)
        {
          if (!v93)
            goto LABEL_298;
        }
        else
        {
          v173 = *(_QWORD *)a4;
          v206[0] = 0;
          v206[1] = 0xFFFFFFFFLL;
          (*((void (**)(re::internal **, uint64_t, uint64_t *))*a1 + 2))(a1, v173, v206);
        }
        v174 = 0;
        do
        {
          v175 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)&__dst, (char *)a4, v174);
          v92(a1, 0, 0, v175, &v200, v208, 0);
          ++v174;
        }
        while (v93 != (_QWORD *)v174);
        if ((v98 & 1) != 0)
        {
LABEL_298:
          v103 = v96;
LABEL_299:
          re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endArray(v103);
          return *((_BYTE *)a1 + 64) == 0;
        }
      }
      (*((void (**)(re::internal **))*a1 + 3))(a1);
      goto LABEL_298;
    case 5:
      if (this == a6)
        goto LABEL_155;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v99 = **((_QWORD **)this + 2);
        v100 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v99 == (unsigned __int16)v100
          && WORD1(v99) == WORD1(v100)
          && ((v100 ^ v99) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_155;
        }
        v29 = 5;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_155;
        v29 = *((unsigned __int8 *)this + 12);
      }
      if (v29 != *((unsigned __int8 *)a6 + 12))
        goto LABEL_283;
LABEL_155:
      if ((_DWORD)a7)
      {
        v101 = a1[34];
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
        re::internal::translateType(v101, (const re::TypeRegistry *)v208, (uint64_t)&v200);
        if (!(*((uint64_t (**)(re::internal **, rapidjson::internal **))*a1 + 10))(a1, &v200))
          goto LABEL_201;
        __dst.n128_u64[0] = 0;
        v102 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((uint64_t)(a1 + 3), a2, (uint64_t *)&__dst, 0);
        result = 0;
        if (v102)
        {
          v103 = (_anonymous_namespace_ *)(a1 + 3);
          goto LABEL_299;
        }
        return result;
      }
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &__dst);
      re::TypeInfo::TypeInfo((uint64_t)&v200, (uint64_t)&__dst.n128_i64[1]);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
      re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
      re::TypeInfo::TypeInfo((uint64_t)&__dst, (uint64_t)this);
      v104 = (*((uint64_t (**)(re::internal **, rapidjson::internal **))*a1 + 10))(a1, &v200);
      if (!v104)
        goto LABEL_201;
      v105 = (void (*)(re::internal **, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD))v104;
      v106 = (*(uint64_t (**)(unsigned __int8 *))(v212 + 80))(a4);
      v206[0] = v106;
      v96 = (_anonymous_namespace_ *)(a1 + 3);
      v107 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((uint64_t)(a1 + 3), a2, v206, 0);
      result = 0;
      if (!v107)
        return result;
      if (*(_QWORD *)(v212 + 96))
      {
        if (v106)
        {
          for (i = 0; i != v106; ++i)
          {
            v109 = (*(uint64_t (**)(unsigned __int8 *, uint64_t))(v212 + 96))(a4, i);
            v105(a1, 0, 0, v109, &v200, v208, 0);
          }
        }
      }
      else
      {
        v177 = *(uint64_t (**)(unsigned __int8 *, re::internal *))(v212 + 104);
        if (!v177 || !*(_QWORD *)(v212 + 112) || !*(_QWORD *)(v212 + 120))
        {
          re::TypeInfo::TypeInfo((uint64_t)v207, (uint64_t)&__dst);
          v193 = re::TypeInfo::name((re::TypeInfo *)v207)[1];
          v46 = "List type \"%s\" does not provide an indexer or iterator.";
          goto LABEL_74;
        }
        v178 = v177(a4, a1[7]);
        v179 = (*(uint64_t (**)(void))(v212 + 112))();
        if (v179)
        {
          v180 = v179;
          do
          {
            v105(a1, 0, 0, v180, &v200, v208, 0);
            v180 = (*(uint64_t (**)(uint64_t))(v212 + 112))(v178);
          }
          while (v180);
        }
        (*(void (**)(uint64_t, re::internal *))(v212 + 120))(v178, a1[7]);
      }
      goto LABEL_298;
    case 6:
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &__dst);
      re::TypeInfo::TypeInfo((uint64_t)&v200, (uint64_t)&__dst.n128_i64[1]);
      v31 = re::TypeInfo::name((re::TypeInfo *)&v200);
      v32 = BYTE4(v201);
      if (BYTE4(v201) != 1)
        goto LABEL_89;
      if (!re::TypeInfo::isInteger((re::TypeInfo *)&v200))
      {
        v32 = BYTE4(v201);
LABEL_89:
        if (v32 == 8)
        {
          v55 = (unint64_t)*v31 >> 1;
          if (v55 == 0x22C6ED80D0CLL)
          {
            v116 = (char *)v31[1];
            if (v116 == "StringID" || !strcmp(v116, "StringID"))
            {
              v35 = re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
              goto LABEL_351;
            }
          }
          else if (v55 == 0x134375A94D9F7110)
          {
            v56 = (char *)v31[1];
            if (v56 == "DynamicString" || !strcmp(v56, "DynamicString"))
            {
              v35 = re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
              goto LABEL_351;
            }
          }
        }
LABEL_188:
        if (this == a6)
          goto LABEL_196;
        if (*(_QWORD *)this == *(_QWORD *)a6)
        {
          v117 = **((_QWORD **)this + 2);
          v118 = **((_QWORD **)a6 + 2);
          if ((unsigned __int16)v117 == (unsigned __int16)v118
            && WORD1(v117) == WORD1(v118)
            && ((v118 ^ v117) & 0xFFFFFF00000000) == 0)
          {
            goto LABEL_196;
          }
        }
        else if (re::areSameTranslatedVersion(this, a6, v30))
        {
          goto LABEL_196;
        }
        if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12))
          goto LABEL_283;
LABEL_196:
        if ((_DWORD)a7)
        {
          v119 = a1[34];
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
          re::internal::translateType(v119, (const re::TypeRegistry *)v208, (uint64_t)&v200);
          v120 = a1[34];
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v207, (uint64_t)&__dst.n128_i64[1]);
          re::internal::translateType(v120, (const re::TypeRegistry *)v207, (uint64_t)v208);
          if ((*((uint64_t (**)(re::internal **, rapidjson::internal **))*a1 + 10))(a1, &v200))
          {
            if ((*((uint64_t (**)(re::internal **, _BYTE *))*a1 + 10))(a1, v208))
            {
              __dst.n128_u64[0] = 0;
              result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary((uint64_t)(a1 + 3), a2, (uint64_t *)&__dst);
              if (!(_DWORD)result)
                return result;
              v121 = (_anonymous_namespace_ *)(a1 + 3);
              goto LABEL_348;
            }
            v122 = (re::TypeInfo *)v208;
          }
          else
          {
LABEL_201:
            v122 = (re::TypeInfo *)&v200;
          }
        }
        else
        {
          re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v207, (uint64_t)&__dst.n128_i64[1]);
          re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v206, (uint64_t)&__dst.n128_i64[1]);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v205, (uint64_t)&__dst.n128_i64[1]);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v198, (uint64_t)&__dst.n128_i64[1]);
          re::TypeInfo::TypeInfo((uint64_t)v196, (uint64_t)this);
          v128 = (*((uint64_t (**)(re::internal **, _QWORD *))*a1 + 10))(a1, v207);
          if (v128)
          {
            v129 = (void (*)(re::internal **, const char *, _QWORD, uint64_t, _QWORD *, _QWORD **, _QWORD))v128;
            v130 = (*((uint64_t (**)(re::internal **, uint64_t *))*a1 + 10))(a1, v206);
            if (v130)
            {
              v131 = (void (*)(re::internal **, const char *, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD))v130;
              v132 = (*(uint64_t (**)(unsigned __int8 *))(v197 + 88))(a4);
              v195 = v132;
              result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary((uint64_t)(a1 + 3), a2, (uint64_t *)&v195);
              if (!(_DWORD)result)
                return result;
              if (!v132)
                goto LABEL_347;
              v133 = *(_QWORD **)this;
              __dst.n128_u64[0] = 0x449AD97C4B77BED4;
              __dst.n128_u64[1] = (unint64_t)"_CompareFunc";
              v134 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)(v133 + 25), &__dst);
              if (v134)
              {
                v135 = *v134;
                re::StringID::destroyString((re::StringID *)&__dst);
                if (v133)
                {
                  v136 = *(_QWORD *)v207[2];
                  __dst.n128_u64[0] = v135;
                  __dst.n128_u64[1] = v136;
                  LODWORD(v212) = -1;
                  v137 = (uint64_t (**)(uint64_t, uint64_t))re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(v207[0] + 768, (uint64_t *)&__dst);
                  if (v137)
                  {
                    v138 = *v137;
                    if (*v137)
                    {
                      v204 = 0;
                      v201 = 0;
                      v202 = 0;
                      v203 = 0;
                      v200 = a1[7];
                      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v200, v132);
                      ++v203;
                      v139 = (*(uint64_t (**)(unsigned __int8 *, re::internal *))(v197 + 112))(a4, a1[7]);
                      if ((*(unsigned int (**)(void))(v197 + 120))())
                      {
                        do
                        {
                          v140 = (*(uint64_t (**)(uint64_t))(v197 + 128))(v139);
                          v141 = (*(uint64_t (**)(uint64_t))(v197 + 136))(v139);
                          __dst.n128_u64[0] = v140;
                          __dst.n128_u64[1] = v141;
                          v142 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v200, &__dst);
                        }
                        while (((*(uint64_t (**)(uint64_t, __n128))(v197 + 120))(v139, v142) & 1) != 0);
                      }
                      (*(void (**)(uint64_t, re::internal *))(v197 + 144))(v139, a1[7]);
                      std::sort[abi:nn180100]<re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1}>(v204, &v204[16 * v202], v138);
                      v143 = 0;
                      v144 = 0;
                      if (v132 <= 1)
                        v132 = 1;
                      while (1)
                      {
                        v145 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry((uint64_t)(a1 + 3), 0);
                        v146 = v202;
                        if (v202 <= v144)
                          break;
                        ((void (*)(re::internal **, const char *, _QWORD, _QWORD, _QWORD *, _QWORD **, _QWORD, double))v129)(a1, "key", 0, *(_QWORD *)&v204[v143], v207, v205, 0, v145);
                        v146 = v202;
                        if (v202 <= v144)
                          goto LABEL_354;
                        v131(a1, "value", 0, *(_QWORD *)&v204[v143 + 8], v206, v198, 0);
                        re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 3));
                        ++v144;
                        v143 += 16;
                        if (v132 == v144)
                        {
                          if (v200 && v204)
                          {
                            v147 = *(void (**)(void))(*(_QWORD *)v200 + 40);
                            goto LABEL_346;
                          }
                          goto LABEL_347;
                        }
                      }
                      v199 = 0;
                      v214 = 0u;
                      v215 = 0u;
                      v212 = 0u;
                      v213 = 0u;
                      __dst = 0u;
                      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                      *(_DWORD *)v208 = 136315906;
                      *(_QWORD *)&v208[4] = "operator[]";
                      *(_WORD *)&v208[12] = 1024;
                      *(_DWORD *)&v208[14] = 789;
                      *(_WORD *)&v208[18] = 2048;
                      *(_QWORD *)&v208[20] = v144;
                      v209 = 2048;
                      v210 = v146;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
LABEL_354:
                      v199 = 0;
                      v214 = 0u;
                      v215 = 0u;
                      v212 = 0u;
                      v213 = 0u;
                      __dst = 0u;
                      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                      *(_DWORD *)v208 = 136315906;
                      *(_QWORD *)&v208[4] = "operator[]";
                      *(_WORD *)&v208[12] = 1024;
                      *(_DWORD *)&v208[14] = 789;
                      *(_WORD *)&v208[18] = 2048;
                      *(_QWORD *)&v208[20] = v144;
                      v209 = 2048;
                      v210 = v146;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
                      goto LABEL_355;
                    }
                  }
                }
              }
              else
              {
                re::StringID::destroyString((re::StringID *)&__dst);
              }
              v189 = (*(uint64_t (**)(unsigned __int8 *, re::internal *))(v197 + 112))(a4, a1[7]);
              (*(void (**)(void))(v197 + 120))();
              do
              {
                v190 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry((uint64_t)(a1 + 3), 0);
                v191 = (*(uint64_t (**)(uint64_t, double))(v197 + 128))(v189, v190);
                v129(a1, "key", 0, v191, v207, v205, 0);
                v192 = (*(uint64_t (**)(uint64_t))(v197 + 136))(v189);
                v131(a1, "value", 0, v192, v206, v198, 0);
                re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 3));
                (*(void (**)(uint64_t))(v197 + 120))(v189);
                --v132;
              }
              while (v132);
              v147 = *(void (**)(void))(v197 + 144);
LABEL_346:
              v147();
LABEL_347:
              v121 = (_anonymous_namespace_ *)(a1 + 3);
LABEL_348:
              re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionary(v121);
              return *((_BYTE *)a1 + 64) == 0;
            }
            v122 = (re::TypeInfo *)v206;
          }
          else
          {
            v122 = (re::TypeInfo *)v207;
          }
        }
        v194 = re::TypeInfo::name(v122)[1];
        return 0;
      }
      v33 = (unint64_t)*v31 >> 1;
      if (v33 > 0x303EE8780EDLL)
      {
        if (v33 == 0x303EE8780EELL)
        {
          v176 = (char *)v31[1];
          if (v176 == "uint32_t" || !strcmp(v176, "uint32_t"))
          {
            v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>;
            goto LABEL_351;
          }
          goto LABEL_306;
        }
        if (v33 != 0x303EE88E58DLL)
        {
LABEL_306:
          __dst.n128_u64[0] = 0x18E6A9A093;
          __dst.n128_u64[1] = (unint64_t)"uint8_t";
          if (re::StringID::operator==(v31, &__dst))
          {
            v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>;
            goto LABEL_351;
          }
          __dst.n128_u64[0] = 0x16749F63A2;
          __dst.n128_u64[1] = (unint64_t)"int64_t";
          if (re::StringID::operator==(v31, &__dst)
            || (*(_QWORD *)v208 = 3327612, *(_QWORD *)&v208[8] = "long", re::StringID::operator==(v31, v208)))
          {
            v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>;
            goto LABEL_351;
          }
          __dst.n128_u64[0] = 104431;
          __dst.n128_u64[1] = (unint64_t)"int";
          if (re::StringID::operator==(v31, &__dst))
          {
            v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>;
            goto LABEL_351;
          }
          __dst.n128_u64[0] = 109413500;
          __dst.n128_u64[1] = (unint64_t)"short";
          if (re::StringID::operator==(v31, &__dst))
          {
            v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>;
            goto LABEL_351;
          }
          goto LABEL_188;
        }
        v114 = (char *)v31[1];
        if (v114 != "uint64_t")
        {
          v115 = "uint64_t";
          goto LABEL_302;
        }
      }
      else
      {
        if (v33 != 3393056694)
        {
          if (v33 == 0x303EE86A734)
          {
            v34 = (char *)v31[1];
            if (v34 == "uint16_t" || !strcmp(v34, "uint16_t"))
            {
              v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>;
LABEL_351:
              v166 = a1;
              v167 = a2;
              v168 = a3;
              v169 = a4;
              v50 = this;
              v51 = (uint64_t *)a6;
              return ((uint64_t (*)(re::internal **, const char *, const re::TypeInfo *, unsigned __int8 *, re *, uint64_t *, uint64_t))v35)(v166, v167, v168, v169, v50, v51, a7);
            }
          }
          goto LABEL_306;
        }
        v114 = (char *)v31[1];
        if (v114 != "size_t")
        {
          v115 = "size_t";
LABEL_302:
          if (!strcmp(v114, v115))
            goto LABEL_303;
          goto LABEL_306;
        }
      }
LABEL_303:
      v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>;
      goto LABEL_351;
    case 7:
      if (this == a6)
        goto LABEL_57;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v110 = **((_QWORD **)this + 2);
        v111 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v110 != (unsigned __int16)v111)
          goto LABEL_283;
        v18 = WORD1(v110) == WORD1(v111);
        v112 = (v111 ^ v110) & 0xFFFFFF00000000;
        if (!v18 || v112 != 0)
          goto LABEL_283;
      }
      else if (!re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_283;
      }
LABEL_57:
      v36 = (_anonymous_namespace_ *)(a1 + 3);
      result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((uint64_t)(a1 + 3), a2, 16);
      if ((_DWORD)a7)
      {
        if (!(_DWORD)result)
          return result;
        v200 = 0;
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>((uint64_t)(a1 + 3), "tag", &v200);
        if (*(_DWORD *)(*((_QWORD *)a6 + 2) + 88))
        {
          re::TypeInfo::unionMember(a6, 0, (uint64_t)&__dst);
          if (!*((_BYTE *)a1 + 64))
            (*((void (**)(re::internal **, const char *, _QWORD, _QWORD, __n128 *, __n128 *, uint64_t))*a1 + 9))(a1, "value", 0, 0, &__dst, &__dst, 1);
        }
      }
      else
      {
        if (!(_DWORD)result)
          return result;
        v53 = (re::UnionAccessor *)re::TypeInfo::TypeInfo((uint64_t)&__dst, (uint64_t)this);
        Tag = re::UnionAccessor::readTag(v53, (char *)a4);
        *(_QWORD *)v208 = Tag;
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>((uint64_t)(a1 + 3), "tag", (rapidjson::internal **)v208);
        if (Tag < *(unsigned int *)(*((_QWORD *)this + 2) + 88))
        {
          re::TypeInfo::unionMember(this, Tag, (uint64_t)&v200);
          if (!*((_BYTE *)a1 + 64))
            (*((void (**)(re::internal **, const char *, _QWORD, unsigned __int8 *, rapidjson::internal **, rapidjson::internal **, _QWORD))*a1
             + 9))(a1, "value", 0, a4, &v200, &v200, 0);
        }
      }
      goto LABEL_337;
    case 8:
      if (!(_DWORD)a7)
        goto LABEL_67;
      if ((*(_BYTE *)(*((_QWORD *)this + 2) + 49) & 1) != 0)
      {
        v57 = a1[34];
        *(_QWORD *)v208 = 0x2686EB529B3EE220;
        *(_QWORD *)&v208[8] = "DynamicString";
        re::TypeRegistry::typeInfo(v57, (const re::StringID *)v208, &__dst);
        re::TypeInfo::TypeInfo((uint64_t)&v200, (uint64_t)&__dst.n128_i64[1]);
        re::StringID::destroyString((re::StringID *)v208);
        v58 = (re *)&v200;
        v59 = (re::TypeInfo *)&v200;
        v60 = (uint64_t)a1;
        v61 = a2;
      }
      else
      {
        v37 = re::TypeInfo::name(this);
        if ((*v37 & 0xFFFFFFFFFFFFFFFELL) != 0x2686EB529B3EE220
          || (v39 = (char *)v37[1], v39 != "DynamicString") && strcmp(v39, "DynamicString"))
        {
LABEL_67:
          v40 = *((_QWORD *)this + 2);
          if ((*(_BYTE *)(v40 + 48) & 4) == 0)
          {
            v36 = (_anonymous_namespace_ *)(a1 + 3);
            v41 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((uint64_t)(a1 + 3), a2, 0);
            result = 0;
            if (!v41)
              return result;
            v42 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
            if (!v42 || *(_DWORD *)(v42 + 16) >= 2u)
            {
              v44 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
              if (v44)
                v45 = *(_DWORD *)(v44 + 16);
              else
                v45 = -1;
              __dst.n128_u32[0] = v45;
              re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>((uint64_t)(a1 + 3), "@version", (unsigned int *)&__dst);
            }
            if (this == a6)
              goto LABEL_323;
            if (*(_QWORD *)this == *(_QWORD *)a6)
            {
              v181 = **((_QWORD **)this + 2);
              v182 = **((_QWORD **)a6 + 2);
              if ((unsigned __int16)v181 == (unsigned __int16)v182
                && WORD1(v181) == WORD1(v182)
                && ((v182 ^ v181) & 0xFFFFFF00000000) == 0)
              {
                goto LABEL_323;
              }
            }
            else if (re::areSameTranslatedVersion(this, a6, v43))
            {
LABEL_323:
              re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, (uint64_t)a4, (uint64_t *)this, a7);
LABEL_337:
              re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v36);
              return *((_BYTE *)a1 + 64) == 0;
            }
            if (*((unsigned __int8 *)this + 12) == *((unsigned __int8 *)a6 + 12))
            {
              re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, (uint64_t)a4, (uint64_t *)this, (uint64_t *)a6, a7);
            }
            else
            {
              v183 = re::TypeInfo::name(this)[1];
              re::TypeInfo::name(a6);
            }
            goto LABEL_337;
          }
          v47 = (uint64_t *)re::TypeMemberCollection::TypeMemberCollection((uint64_t)&__dst, *(_QWORD *)this, v40);
          re::TypeMemberCollection::operator[](v47, 0, (uint64_t)v208);
          v48 = &a4[*(unsigned int *)(*(_QWORD *)&v208[16] + 24)];
          re::TypeRegistry::typeInfo(*(_QWORD **)v208, **(_QWORD **)&v208[16], &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v207, (uint64_t)&__dst.n128_i64[1]);
          if (this == a6)
            goto LABEL_78;
          if (*(_QWORD *)this == *(_QWORD *)a6)
          {
            v162 = **((_QWORD **)this + 2);
            v163 = *((_QWORD *)a6 + 2);
            v164 = *(_QWORD *)v163;
            if ((unsigned __int16)v162 == (unsigned __int16)*(_QWORD *)v163
              && WORD1(v162) == WORD1(v164)
              && ((v164 ^ v162) & 0xFFFFFF00000000) == 0)
            {
              goto LABEL_78;
            }
          }
          else
          {
            if (re::areSameTranslatedVersion(this, a6, v49))
            {
LABEL_78:
              if (*((_BYTE *)a1 + 64))
                return 0;
              v35 = (BOOL (*)(uint64_t, const char *, const re::TypeInfo *, uint64_t, re *, re::TypeInfo *, int))*((_QWORD *)*a1 + 9);
              v50 = (re *)v207;
              v51 = v207;
LABEL_282:
              v166 = a1;
              v167 = a2;
              v168 = a3;
              v169 = v48;
              return ((uint64_t (*)(re::internal **, const char *, const re::TypeInfo *, unsigned __int8 *, re *, uint64_t *, uint64_t))v35)(v166, v167, v168, v169, v50, v51, a7);
            }
            v163 = *((_QWORD *)a6 + 2);
          }
          if (*(_DWORD *)(v163 + 88) != 1)
            goto LABEL_283;
          re::TypeMemberCollection::TypeMemberCollection((uint64_t)&v200, *(_QWORD *)a6, v163);
          re::TypeMemberCollection::operator[]((uint64_t *)&v200, 0, (uint64_t)v205);
          re::TypeRegistry::typeInfo(v205[0], *v205[2], &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v206, (uint64_t)&__dst.n128_i64[1]);
          if (*((_BYTE *)a1 + 64))
            return 0;
          v35 = (BOOL (*)(uint64_t, const char *, const re::TypeInfo *, uint64_t, re *, re::TypeInfo *, int))*((_QWORD *)*a1 + 9);
          v50 = (re *)v207;
          v51 = v206;
          goto LABEL_282;
        }
        v60 = (uint64_t)a1;
        v61 = a2;
        v58 = this;
        v59 = this;
      }
      re::serializeDynamicString<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(v60, v61, v38, 0, v58, v59, 1);
      return *((_BYTE *)a1 + 64) == 0;
    case 9:
      v193 = re::TypeInfo::name(this)[1];
      v46 = "Pointer type (\"%s\") needs to be handled explicitly by the serializer.";
      goto LABEL_74;
    default:
      LOBYTE(v193) = *((_BYTE *)this + 12);
      v46 = "Invalid type category. Value = %d";
      goto LABEL_74;
  }
}

BOOL re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(uint64_t a1, const char *a2, unsigned int *a3)
{
  int v3;
  char *v6;
  rapidjson::internal *v7;
  char *v8;
  uint64_t v9;
  const char *v11;

  v11 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v11);
    v6 = *(char **)(a1 + 168);
    v7 = (rapidjson::internal *)*a3;
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteUint((uint64_t *)v6, v7, v8);
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(uint64_t a1, const char *a2, float *a3)
{
  int v3;
  float v6;
  char *v7;
  const char *v8;
  double v9;
  uint64_t v10;
  const char *v12;
  const char *v13;

  v13 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v13);
    v6 = *a3;
    v7 = *(char **)(a1 + 168);
    if (fabsf(v6) == INFINITY)
    {
      v8 = "-Infinity";
      if (v6 > 0.0)
        v8 = "Infinity";
      v12 = v8;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(v7, &v12);
    }
    else
    {
      v9 = v6;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(*(char **)(a1 + 168));
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteDouble((uint64_t)v7, v9);
    }
    v10 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v10 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(uint64_t a1, const char *a2, double *a3)
{
  int v3;
  double v6;
  char *v7;
  const char *v8;
  uint64_t v9;
  const char *v11;
  const char *v12;

  v12 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v12);
    v6 = *a3;
    v7 = *(char **)(a1 + 168);
    if (fabs(v6) == INFINITY)
    {
      v8 = "-Infinity";
      if (v6 > 0.0)
        v8 = "Infinity";
      v11 = v8;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(v7, &v11);
    }
    else
    {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(*(char **)(a1 + 168));
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteDouble((uint64_t)v7, v6);
    }
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(uint64_t a1, const char *a2, uint64_t *a3)
{
  int v3;
  uint64_t v6;
  char *v7;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;

  v14 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v14);
    v6 = *a3;
    if (!*a3)
    {
      v7 = *(char **)(a1 + 168);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v7);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString((uint64_t *)v7, (uint64_t)"", 0);
      v6 = *a3;
    }
    LOBYTE(v9) = 8;
    DWORD1(v9) = 0;
    *((_QWORD *)&v9 + 1) = v14;
    v10 = 0;
    v12 = 0;
    v13 = 0;
    v11 = v6;
    re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v9);
  }
  return v3 == 0;
}

uint64_t re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;

  if (!*(_BYTE *)(result + 40))
  {
    v3 = result;
    v4 = *(_QWORD *)(*(_QWORD *)(result + 128) + 48 * *(_QWORD *)(result + 112) - 24);
    v5 = *(char **)(result + 168);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v5);
    result = rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteString((uint64_t *)v5, a2, v4);
    v6 = *(_QWORD *)(v3 + 128) + 48 * *(_QWORD *)(v3 + 112);
    *(_QWORD *)(v6 - 16) += v4;
  }
  return result;
}

double re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional(uint64_t a1, const char *a2, _BYTE *a3)
{
  uint64_t v5;
  char *v6;
  double result;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;

  v13 = a2;
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v13);
    if (*a3)
    {
      v5 = 1;
    }
    else
    {
      v6 = *(char **)(a1 + 168);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v6);
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteNull((uint64_t *)v6);
      v5 = *a3;
    }
    LOBYTE(v8) = 3;
    DWORD1(v8) = 0;
    *((_QWORD *)&v8 + 1) = v13;
    v9 = 0;
    v11 = 0;
    v12 = 0;
    v10 = v5;
    return re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v8);
  }
  return result;
}

BOOL re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray(uint64_t a1, const char *a2, uint64_t *a3, int a4)
{
  int v4;
  uint64_t v8;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;

  v15 = a2;
  v4 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v15);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartArray(*(_QWORD *)(a1 + 168));
    v8 = *a3;
    LOBYTE(v10) = 5;
    DWORD1(v10) = a4 & 0xFFFFFFDF;
    *((_QWORD *)&v10 + 1) = v15;
    v11 = 0;
    v13 = 0;
    v14 = 0;
    v12 = v8;
    re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v10);
  }
  return v4 == 0;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endArray(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  _BYTE *v6;
  uint64_t v7;
  _anonymous_namespace_ *v8;
  char v9;
  _BYTE v10[23];
  uint64_t v11;
  char v12;

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    v2 = *((_QWORD *)result + 16);
    v3 = *((_QWORD *)result + 14);
    if (*(_QWORD *)(v2 + 48 * v3 - 16) == *(_QWORD *)(v2 + 48 * v3 - 24))
    {
      v4 = (uint64_t *)*((_QWORD *)result + 21);
      v4[4] -= 16;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndArray(v4);
      v5 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      ++*(_QWORD *)(v5 - 16);
    }
    else
    {
      if ((v9 & 1) != 0)
        v6 = *(_BYTE **)&v10[7];
      else
        v6 = v10;
      v7 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize array \"%s\". Expected number of elements: %lld. Actual number of elements: %lld.", (re::DynamicString *)&v11, v6, *(_QWORD *)(v7 - 24), *(_QWORD *)(v7 - 16));
      if (v11 && (v12 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v11 + 40))();
      result = v8;
      if (v8)
      {
        if ((v9 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v8 + 40))();
      }
    }
  }
  return result;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unint64_t *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t **v29;
  unint64_t **v30;
  unint64_t *v31;
  unint64_t *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unint64_t **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unint64_t *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*,false>(v47, &v47[2 * v45], v28, 1);
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unsigned int *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int **v29;
  unsigned int **v30;
  unsigned int *v31;
  unsigned int *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unsigned int **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unsigned int *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*,false>(v47, &v47[2 * v45], v28, 1);
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__base_10_u32[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unsigned __int16 *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unsigned __int16 **v29;
  unsigned __int16 **v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unsigned __int16 **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unsigned __int16 *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*,false>(v47, &v47[2 * v45], v28, 1);
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__base_10_u32[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unsigned __int8 *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unsigned __int8 **v29;
  unsigned __int8 **v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unsigned __int8 **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unsigned __int8 *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*,false>(v47, &v47[2 * v45], v28, 1);
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__base_10_u32[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, uint64_t *, _BYTE *, _BYTE *, _QWORD);
  _anonymous_namespace_ *v20;
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t **v30;
  uint64_t **v31;
  unint64_t v32;
  __n128 *v33;
  uint64_t *v34;
  unsigned int v35;
  int64_t v36;
  _WORD *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  uint64_t **v52;
  __n128 v53[2];
  _QWORD v54[2];

  v54[0] = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, uint64_t *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    v21 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
    if (v23)
    {
      v52 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v48 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v23);
      ++v51;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v45 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v24);
          v53[0].n128_u64[0] = v25;
          v53[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, v53);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v24, v17);
      v28 = 126 - 2 * __clz(v50);
      if (v50)
        v29 = v28;
      else
        v29 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*,false>(v52, (__n128 *)&v52[2 * v50], v29, 1);
      if (v50)
      {
        v30 = v52;
        v31 = &v52[2 * v50];
        do
        {
          v32 = **v30;
          if ((v32 & 0x8000000000000000) != 0)
          {
            v53[0].n128_u8[0] = 45;
            v32 = -(uint64_t)v32;
            v33 = (__n128 *)((char *)v53[0].n128_u64 + 1);
          }
          else
          {
            v33 = v53;
          }
          v34 = v30[1];
          if ((char *)v54 - (char *)v33 > 19
            || (v35 = (1233 * (64 - __clz(v32 | 1))) >> 12,
                v36 = v35 - (std::__itoa::__pow10_64[v35] > v32) + 1,
                v37 = v54,
                (char *)v54 - (char *)v33 >= v36))
          {
            v37 = std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:nn180100](v33, v32);
          }
          *(_BYTE *)v37 = 0;
          v19(a1, v53, 0, v34, v47, v46, 0);
          v30 += 2;
        }
        while (v30 != v31);
      }
      if (v48)
      {
        if (v52)
          (*(void (**)(void))(*(_QWORD *)v48 + 40))();
      }
      v20 = (_anonymous_namespace_ *)(a1 + 24);
    }
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v20);
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v38 = re::TypeInfo::name((re::TypeInfo *)v47);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, int *, _BYTE *, _BYTE *, _QWORD);
  _anonymous_namespace_ *v20;
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  int **v30;
  int **v31;
  unsigned int v32;
  __n128 *v33;
  int *v34;
  unsigned int v35;
  int64_t v36;
  _WORD *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  int **v52;
  __n128 v53[2];
  _QWORD v54[2];

  v54[0] = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, int *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    v21 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
    if (v23)
    {
      v52 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v48 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v23);
      ++v51;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v45 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v24);
          v53[0].n128_u64[0] = v25;
          v53[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, v53);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v24, v17);
      v28 = 126 - 2 * __clz(v50);
      if (v50)
        v29 = v28;
      else
        v29 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*,false>(v52, (__n128 *)&v52[2 * v50], v29, 1);
      if (v50)
      {
        v30 = v52;
        v31 = &v52[2 * v50];
        do
        {
          v32 = **v30;
          if ((v32 & 0x80000000) != 0)
          {
            v53[0].n128_u8[0] = 45;
            v32 = -v32;
            v33 = (__n128 *)((char *)v53[0].n128_u64 + 1);
          }
          else
          {
            v33 = v53;
          }
          v34 = v30[1];
          if ((char *)v54 - (char *)v33 > 9
            || (v35 = (1233 * (32 - __clz(v32 | 1))) >> 12,
                v36 = (((__PAIR64__(v35, v32) - std::__itoa::__pow10_32[v35]) >> 32) + 1),
                v37 = v54,
                (char *)v54 - (char *)v33 >= v36))
          {
            v37 = std::__itoa::__base_10_u32[abi:nn180100](v33, v32);
          }
          *(_BYTE *)v37 = 0;
          v19(a1, v53, 0, v34, v47, v46, 0);
          v30 += 2;
        }
        while (v30 != v31);
      }
      if (v48)
      {
        if (v52)
          (*(void (**)(void))(*(_QWORD *)v48 + 40))();
      }
      v20 = (_anonymous_namespace_ *)(a1 + 24);
    }
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v20);
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v38 = re::TypeInfo::name((re::TypeInfo *)v47);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, __int16 *, _BYTE *, _BYTE *, _QWORD);
  _anonymous_namespace_ *v20;
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  __int16 **v30;
  __int16 **v31;
  unsigned int v32;
  __n128 *v33;
  __int16 *v34;
  unsigned int v35;
  int64_t v36;
  _WORD *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  __int16 **v52;
  __n128 v53[2];
  _QWORD v54[2];

  v54[0] = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, __int16 *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    v21 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
    if (v23)
    {
      v52 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v48 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v23);
      ++v51;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v45 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v24);
          v53[0].n128_u64[0] = v25;
          v53[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, v53);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v24, v17);
      v28 = 126 - 2 * __clz(v50);
      if (v50)
        v29 = v28;
      else
        v29 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*,false>(v52, &v52[2 * v50], v29, 1);
      if (v50)
      {
        v30 = v52;
        v31 = &v52[2 * v50];
        do
        {
          v32 = **v30;
          if ((v32 & 0x80000000) != 0)
          {
            v53[0].n128_u8[0] = 45;
            v32 = -v32;
            v33 = (__n128 *)((char *)v53[0].n128_u64 + 1);
          }
          else
          {
            v33 = v53;
          }
          v34 = v30[1];
          if ((char *)v54 - (char *)v33 > 9
            || (v35 = (1233 * (32 - __clz(v32 | 1))) >> 12,
                v36 = (((__PAIR64__(v35, v32) - std::__itoa::__pow10_32[v35]) >> 32) + 1),
                v37 = v54,
                (char *)v54 - (char *)v33 >= v36))
          {
            v37 = std::__itoa::__base_10_u32[abi:nn180100](v33, v32);
          }
          *(_BYTE *)v37 = 0;
          v19(a1, v53, 0, v34, v47, v46, 0);
          v30 += 2;
        }
        while (v30 != v31);
      }
      if (v48)
      {
        if (v52)
          (*(void (**)(void))(*(_QWORD *)v48 + 40))();
      }
      v20 = (_anonymous_namespace_ *)(a1 + 24);
    }
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v20);
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v38 = re::TypeInfo::name((re::TypeInfo *)v47);
  return 0;
}

BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v24;
  _BOOL8 result;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __n128 v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __n128 v43;
  char v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  uint64_t *v52;

  if (this == a6)
    goto LABEL_14;
  v13 = *(_QWORD **)this;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v14 = (uint64_t *)*((_QWORD *)a6 + 2);
    v16 = *v14;
    if ((unsigned __int16)v15 != (unsigned __int16)*v14)
      goto LABEL_10;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v21 = *(_QWORD *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
      re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
      v22 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
      if (!v22)
      {
        v37 = re::TypeInfo::name((re::TypeInfo *)v47);
        return 0;
      }
      v23 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v22;
      v24 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
      result = 0;
      if (!v24)
        return result;
      v26 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
      if (v26)
      {
        v52 = 0;
        v49 = 0;
        v50 = 0;
        v51 = 0;
        v48 = v21;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v26);
        ++v51;
        v27 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v21);
        if ((*(unsigned int (**)(void))(v45 + 120))())
        {
          do
          {
            v28 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v27);
            v29 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v27);
            v43.n128_u64[0] = v28;
            v43.n128_u64[1] = v29;
            v30 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, &v43);
          }
          while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v27, v30) & 1) != 0);
        }
        (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v27, v21);
        v31 = 126 - 2 * __clz(v50);
        if (v50)
          v32 = v31;
        else
          v32 = 0;
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*,false>(v52, &v52[2 * v50], v32, 1);
        if (v50)
        {
          v33 = v52;
          v34 = &v52[2 * v50];
          do
          {
            v35 = *v33;
            if ((*(_BYTE *)(*v33 + 8) & 1) != 0)
              v36 = *(_QWORD *)(v35 + 16);
            else
              v36 = v35 + 9;
            v23(a1, v36, 0, v33[1], v47, v46, 0);
            v33 += 2;
          }
          while (v33 != v34);
        }
        if (v48)
        {
          if (v52)
            (*(void (**)(void))(*(_QWORD *)v48 + 40))();
        }
      }
      re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_14;
  v13 = *(_QWORD **)a6;
  v14 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v13, v14[9], &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  v19 = re::TypeInfo::name((re::TypeInfo *)v47);
  if ((unint64_t)*v19 >> 1 == 0x22C6ED80D0CLL)
  {
    v20 = (char *)v19[1];
    if (v20 == "StringID" || !strcmp(v20, "StringID"))
      goto LABEL_14;
  }
  return 0;
}

BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v24;
  _BOOL8 result;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __n128 v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __n128 v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  uint64_t *v52;

  if (this == a6)
    goto LABEL_14;
  v13 = *(_QWORD **)this;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v14 = (uint64_t *)*((_QWORD *)a6 + 2);
    v16 = *v14;
    if ((unsigned __int16)v15 != (unsigned __int16)*v14)
      goto LABEL_10;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v21 = *(_QWORD *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
      re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
      v22 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
      if (!v22)
      {
        v37 = re::TypeInfo::name((re::TypeInfo *)v47);
        return 0;
      }
      v23 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v22;
      v24 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
      result = 0;
      if (!v24)
        return result;
      v26 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
      if (v26)
      {
        v52 = 0;
        v49 = 0;
        v50 = 0;
        v51 = 0;
        v48 = v21;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v26);
        ++v51;
        v27 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v21);
        if ((*(unsigned int (**)(void))(v45 + 120))())
        {
          do
          {
            v28 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v27);
            v29 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v27);
            v43.n128_u64[0] = v28;
            v43.n128_u64[1] = v29;
            v30 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, &v43);
          }
          while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v27, v30) & 1) != 0);
        }
        (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v27, v21);
        v31 = 126 - 2 * __clz(v50);
        if (v50)
          v32 = v31;
        else
          v32 = 0;
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*,false>((uint64_t)v52, (__n128 *)&v52[2 * v50], v32, 1);
        if (v50)
        {
          v33 = v52;
          v34 = &v52[2 * v50];
          do
          {
            v36 = *v33;
            v35 = v33[1];
            v33 += 2;
            v23(a1, *(_QWORD *)(v36 + 8), 0, v35, v47, v46, 0);
          }
          while (v33 != v34);
        }
        if (v48)
        {
          if (v52)
            (*(void (**)(void))(*(_QWORD *)v48 + 40))();
        }
      }
      re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_14;
  v13 = *(_QWORD **)a6;
  v14 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v13, v14[9], &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  v19 = re::TypeInfo::name((re::TypeInfo *)v47);
  if ((unint64_t)*v19 >> 1 == 0x134375A94D9F7110)
  {
    v20 = (char *)v19[1];
    if (v20 == "DynamicString" || !strcmp(v20, "DynamicString"))
      goto LABEL_14;
  }
  return 0;
}

BOOL re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary(uint64_t a1, const char *a2, uint64_t *a3)
{
  int v3;
  uint64_t v6;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;

  v13 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v13);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartArray(*(_QWORD *)(a1 + 168));
    v6 = *a3;
    LOBYTE(v8) = 6;
    DWORD1(v8) = 0;
    *((_QWORD *)&v8 + 1) = v13;
    v9 = 0;
    v11 = 0;
    v12 = 0;
    v10 = v6;
    re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v8);
  }
  return v3 == 0;
}

double re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry(uint64_t a1, int a2)
{
  double result;
  _OWORD v5[2];
  uint64_t v6;
  uint64_t v7;

  if (!*(_BYTE *)(a1 + 40))
  {
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::StartObject(*(_QWORD *)(a1 + 168));
    LOBYTE(v5[0]) = 7;
    DWORD1(v5[0]) = a2 | 0x20;
    *((_QWORD *)&v5[0] + 1) = "entry";
    v5[1] = xmmword_2260F4F20;
    v6 = 0;
    v7 = 0;
    return re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, v5);
  }
  return result;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionaryEntry(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  _BYTE *v6;
  _anonymous_namespace_ *v7;
  char v8;
  _BYTE v9[23];
  uint64_t v10;
  char v11;

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    v2 = *((_QWORD *)result + 16);
    v3 = *((_QWORD *)result + 14);
    if (*(_QWORD *)(v2 + 48 * v3 - 16) == 2)
    {
      v4 = (uint64_t *)*((_QWORD *)result + 21);
      v4[4] -= 16;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndObject(v4);
      v5 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      ++*(_QWORD *)(v5 - 16);
    }
    else
    {
      if ((v8 & 1) != 0)
        v6 = *(_BYTE **)&v9[7];
      else
        v6 = v9;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary entry \"%s\". Expected 2 objects (key+value). Actual number of objects: %lld.", (re::DynamicString *)&v10, v6, *(_QWORD *)(*((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14) - 16));
      if (v10 && (v11 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v10 + 40))();
      result = v7;
      if (v7)
      {
        if ((v8 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v7 + 40))();
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionary(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  _BYTE *v6;
  uint64_t v7;
  _anonymous_namespace_ *v8;
  char v9;
  _BYTE v10[23];
  uint64_t v11;
  char v12;

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    v2 = *((_QWORD *)result + 16);
    v3 = *((_QWORD *)result + 14);
    if (*(_QWORD *)(v2 + 48 * v3 - 16) == *(_QWORD *)(v2 + 48 * v3 - 24))
    {
      v4 = (uint64_t *)*((_QWORD *)result + 21);
      v4[4] -= 16;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteEndArray(v4);
      v5 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      ++*(_QWORD *)(v5 - 16);
    }
    else
    {
      if ((v9 & 1) != 0)
        v6 = *(_BYTE **)&v10[7];
      else
        v6 = v10;
      v7 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary \"%s\". Expected number of entries: %lld. Actual number of entries: %lld.", (re::DynamicString *)&v11, v6, *(_QWORD *)(v7 - 24), *(_QWORD *)(v7 - 16));
      if (v11 && (v12 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v11 + 40))();
      result = v8;
      if (v8)
      {
        if ((v9 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v8 + 40))();
      }
    }
  }
  return result;
}

void std::sort[abi:nn180100]<re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1}>(char *a1, char *a2, uint64_t (*a3)(uint64_t, uint64_t))
{
  unint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t, uint64_t);

  v3 = 126 - 2 * __clz((a2 - a1) >> 4);
  v5 = a3;
  if (a2 == a1)
    v4 = 0;
  else
    v4 = v3;
  std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(a1, a2, &v5, v4, 1);
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*,false>(unint64_t **a1, unint64_t **a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t **v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t **v18;
  unint64_t **v19;
  unint64_t *v20;
  unint64_t *v21;
  __int128 *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t *v25;
  BOOL v26;
  unint64_t *v27;
  unint64_t **v28;
  _OWORD *v29;
  unint64_t *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t *v34;
  __int128 *v35;
  _QWORD *v36;
  unint64_t **v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t **v42;
  unint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unint64_t **v52;
  unint64_t v53;
  unint64_t v54;
  BOOL v55;
  unint64_t **v56;
  unint64_t *v57;
  unint64_t *v58;
  unint64_t **v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  unint64_t **v77;
  unint64_t *v78;
  unint64_t *v79;
  unint64_t **v80;
  unint64_t *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(uint64_t a1, unint64_t **a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  unint64_t **v8;
  unint64_t **v9;
  uint64_t v10;
  int v11;
  unint64_t *v12;
  unint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t **v16;

  v4 = ((uint64_t)a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 2);
      if (**(a2 - 2) < **(_QWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32), (_OWORD *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = (unint64_t **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32));
      v9 = (unint64_t **)(a1 + 48);
      if ((unint64_t **)(a1 + 48) == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_QWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unint64_t **)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (unint64_t **)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*,false>(unsigned int **a1, unsigned int **a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int **v12;
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int **v18;
  unsigned int **v19;
  unsigned int *v20;
  unsigned int *v21;
  __int128 *v22;
  unsigned int v23;
  unsigned int *v24;
  unsigned int *v25;
  BOOL v26;
  unsigned int *v27;
  unsigned int **v28;
  _OWORD *v29;
  unsigned int *v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int *v33;
  unsigned int *v34;
  __int128 *v35;
  _DWORD *v36;
  unsigned int **v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  unsigned int **v42;
  unsigned int *v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unsigned int **v52;
  unsigned int v53;
  unsigned int v54;
  BOOL v55;
  unsigned int **v56;
  unsigned int *v57;
  unsigned int *v58;
  unsigned int **v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _DWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  unsigned int **v77;
  unsigned int *v78;
  unsigned int *v79;
  unsigned int **v80;
  unsigned int *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(uint64_t a1, unsigned int **a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  unsigned int **v8;
  unsigned int **v9;
  uint64_t v10;
  int v11;
  unsigned int *v12;
  unsigned int *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int **v16;

  v4 = ((uint64_t)a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 2);
      if (**(a2 - 2) < **(_DWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32), (_OWORD *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = (unsigned int **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32));
      v9 = (unsigned int **)(a1 + 48);
      if ((unsigned int **)(a1 + 48) == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_DWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unsigned int **)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (unsigned int **)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*,false>(unsigned __int16 **a1, unsigned __int16 **a2, uint64_t a3, char a4)
{
  unsigned __int16 **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int16 **v12;
  unsigned __int16 *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned int v17;
  unsigned __int16 **v18;
  unsigned __int16 **v19;
  unsigned __int16 *v20;
  unsigned __int16 *v21;
  unsigned __int16 **v22;
  unsigned int v23;
  unsigned __int16 *v24;
  unsigned __int16 *v25;
  BOOL v26;
  unsigned __int16 *v27;
  unsigned __int16 **v28;
  unsigned __int16 **v29;
  unsigned __int16 *v30;
  unsigned __int16 *v31;
  unsigned int v32;
  unsigned __int16 *v33;
  unsigned __int16 *v34;
  unsigned __int16 **v35;
  unsigned __int16 *v36;
  unsigned __int16 **v37;
  BOOL v39;
  uint64_t v40;
  unsigned __int16 **v41;
  unsigned __int16 **v42;
  unsigned __int16 *v43;
  unsigned __int16 *v44;
  uint64_t v45;
  unsigned int v46;
  unsigned __int16 **v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unsigned __int16 **v52;
  unsigned int v53;
  unsigned int v54;
  BOOL v55;
  unsigned __int16 **v56;
  unsigned __int16 *v57;
  unsigned __int16 *v58;
  unsigned __int16 **v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int16 **v67;
  unsigned __int16 **v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unsigned __int16 **v73;
  unsigned __int16 *v74;
  unsigned __int16 *v75;
  unsigned __int16 **v76;
  unsigned __int16 **v78;
  unsigned __int16 *v79;
  unsigned __int16 *v80;
  unsigned __int16 **v81;
  unsigned __int16 *v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(unsigned __int16 **a1, unsigned __int16 **a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned __int16 **v6;
  __int128 v7;
  unsigned __int16 **v8;
  unsigned __int16 **v9;
  uint64_t v10;
  int v11;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned __int16 **v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3, (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(unsigned __int16 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unsigned __int16 **)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*,false>(unsigned __int8 **a1, unsigned __int8 **a2, uint64_t a3, char a4)
{
  unsigned __int8 **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int8 **v12;
  unsigned __int8 *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unsigned int v17;
  unsigned __int8 **v18;
  unsigned __int8 **v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  unsigned __int8 **v22;
  unsigned int v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  BOOL v26;
  unsigned __int8 *v27;
  unsigned __int8 **v28;
  unsigned __int8 **v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  unsigned int v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  unsigned __int8 **v35;
  unsigned __int8 *v36;
  unsigned __int8 **v37;
  BOOL v39;
  uint64_t v40;
  unsigned __int8 **v41;
  unsigned __int8 **v42;
  unsigned __int8 *v43;
  unsigned __int8 *v44;
  uint64_t v45;
  unsigned int v46;
  unsigned __int8 **v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unsigned __int8 **v52;
  unsigned int v53;
  unsigned int v54;
  BOOL v55;
  unsigned __int8 **v56;
  unsigned __int8 *v57;
  unsigned __int8 *v58;
  unsigned __int8 **v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int8 **v67;
  unsigned __int8 **v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unsigned __int8 **v73;
  unsigned __int8 *v74;
  unsigned __int8 *v75;
  unsigned __int8 **v76;
  unsigned __int8 **v78;
  unsigned __int8 *v79;
  unsigned __int8 *v80;
  unsigned __int8 **v81;
  unsigned __int8 *v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(unsigned __int8 **a1, unsigned __int8 **a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned __int8 **v6;
  __int128 v7;
  unsigned __int8 **v8;
  unsigned __int8 **v9;
  uint64_t v10;
  int v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned __int8 **v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3, (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(unsigned __int8 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unsigned __int8 **)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*,false>(uint64_t **a1, __n128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t **v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t **v18;
  __n128 *v19;
  _QWORD *v20;
  _QWORD *v21;
  __int128 *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  BOOL v26;
  _QWORD *v27;
  _QWORD **v28;
  __int128 *v29;
  _QWORD *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  __int128 *v35;
  _QWORD *v36;
  __n128 *v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  __n128 *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  uint64_t **v52;
  uint64_t v53;
  uint64_t v54;
  BOOL v55;
  uint64_t **v56;
  uint64_t *v57;
  uint64_t *v58;
  uint64_t **v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  __n128 *v76;
  uint64_t *v77;
  uint64_t *v78;
  __n128 *v79;
  uint64_t *v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  _QWORD **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      if (**(_QWORD **)(a2 - 16) < **(_QWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32), (_OWORD *)(a2 - 16));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      v8 = (_QWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32));
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(_QWORD **)v9;
    if (**(_QWORD **)v9 < **v8)
    {
      v13 = *(_QWORD *)(v9 + 8);
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_QWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (_QWORD *)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (_QWORD *)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (_QWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*,false>(int **a1, __n128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int **v12;
  int *v13;
  int v14;
  uint64_t v15;
  int *v16;
  int v17;
  int **v18;
  __n128 *v19;
  _DWORD *v20;
  _DWORD *v21;
  __int128 *v22;
  int v23;
  int *v24;
  int *v25;
  BOOL v26;
  _DWORD *v27;
  _DWORD **v28;
  __int128 *v29;
  _DWORD *v30;
  int *v31;
  int v32;
  int *v33;
  int *v34;
  __int128 *v35;
  _DWORD *v36;
  __n128 *v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  __n128 *v42;
  _DWORD *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  int **v52;
  int v53;
  int v54;
  BOOL v55;
  int **v56;
  int *v57;
  int *v58;
  int **v59;
  uint64_t v60;
  int v61;
  int v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _DWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  __n128 *v76;
  int *v77;
  int *v78;
  __n128 *v79;
  int *v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  _DWORD **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  _QWORD *v16;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      if (**(_DWORD **)(a2 - 16) < **(_DWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a1 + 32), (_OWORD *)(a2 - 16));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      v8 = (_DWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a1 + 32));
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(_DWORD **)v9;
    if (**(_DWORD **)v9 < **v8)
    {
      v13 = *(_QWORD *)(v9 + 8);
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_DWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (_QWORD *)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (_QWORD *)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (_DWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*,false>(__int16 **a1, __int16 **a2, uint64_t a3, char a4)
{
  __int16 **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __int16 **v12;
  __int16 *v13;
  int v14;
  uint64_t v15;
  __int16 *v16;
  int v17;
  __int16 **v18;
  __int16 **v19;
  __int16 *v20;
  __int16 *v21;
  __int16 **v22;
  int v23;
  __int16 *v24;
  __int16 *v25;
  BOOL v26;
  __int16 *v27;
  __int16 **v28;
  __int16 **v29;
  __int16 *v30;
  __int16 *v31;
  int v32;
  __int16 *v33;
  __int16 *v34;
  __int16 **v35;
  __int16 *v36;
  __int16 **v37;
  BOOL v39;
  uint64_t v40;
  __int16 **v41;
  __int16 **v42;
  __int16 *v43;
  __int16 *v44;
  uint64_t v45;
  int v46;
  __int16 **v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  __int16 **v52;
  int v53;
  int v54;
  BOOL v55;
  __int16 **v56;
  __int16 *v57;
  __int16 *v58;
  __int16 **v59;
  uint64_t v60;
  int v61;
  int v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  __int16 **v66;
  __int16 **v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  __int16 **v72;
  __int16 *v73;
  __int16 *v74;
  __int16 **v75;
  __int16 **v76;
  __int16 *v77;
  __int16 *v78;
  __int16 **v79;
  __int16 *v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(__int16 **a1, __int16 **a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int16 **v6;
  __int128 v7;
  __int16 **v8;
  __int16 **v9;
  uint64_t v10;
  int v11;
  __int16 *v12;
  __int16 *v13;
  uint64_t v14;
  int v15;
  __int16 **v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3, (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(__int16 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (__int16 **)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*,false>(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  BOOL v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t *v44;
  int64_t v45;
  int64_t v46;
  int64_t v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  int64_t v52;
  uint64_t v53;
  int v54;
  BOOL v55;
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  BOOL v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t *v87;
  char v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t *v91;
  int64_t v92;
  uint64_t *v93;
  uint64_t *v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t *v6;
  __int128 v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t *v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (re::DynamicString::operator<(*(a2 - 2), *a1))
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (re::DynamicString::operator<(*v9, *v8))
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        v15 = (char *)a1 + v14;
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v14 -= 16;
        if ((re::DynamicString::operator<(v12, *((_QWORD *)v15 + 2)) & 1) == 0)
        {
          v16 = (uint64_t *)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*,false>(uint64_t a1, __n128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __int128 *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  __int128 *v19;
  _QWORD *v20;
  _QWORD *v21;
  __int128 *v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  BOOL v26;
  _QWORD *v27;
  unint64_t v28;
  __int128 *v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  __int128 *v35;
  _QWORD *v36;
  __n128 *v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  __n128 *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unint64_t **v52;
  unint64_t v53;
  unint64_t v54;
  BOOL v55;
  unint64_t **v56;
  unint64_t *v57;
  unint64_t *v58;
  unint64_t **v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  uint64_t v77;
  _QWORD *v78;
  uint64_t v79;
  uint64_t v80;
  _QWORD *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  _QWORD **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _QWORD *v16;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      if (**(_QWORD **)(a2 - 16) >> 1 < **(_QWORD **)a1 >> 1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (_QWORD **)(a1 + 16), (_QWORD **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (__n128 *)(a1 + 16), (__n128 *)(a1 + 32), (__n128 *)(a2 - 16));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (__n128 *)(a1 + 16), (__n128 *)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      v8 = (_QWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (_QWORD **)(a1 + 16), (_QWORD **)(a1 + 32));
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(_QWORD **)v9;
    if (**(_QWORD **)v9 >> 1 < **v8 >> 1)
    {
      v13 = *(_QWORD *)(v9 + 8);
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_QWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >> 1 >= v15 >> 1)
        {
          v16 = (_QWORD *)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (_QWORD *)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (_QWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(char *a1, char *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  BOOL v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  char *v36;
  uint64_t v37;
  char *v38;
  BOOL v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  char *v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  char *v73;
  uint64_t v74;
  uint64_t *v75;
  BOOL v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  char *v81;
  char v82;
  char *v83;
  unint64_t v84;
  char *v85;
  char *v86;
  char *v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  int64_t v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(char *a1, char *a2, uint64_t (**a3)(uint64_t, _QWORD))
{
  uint64_t v6;
  _BOOL8 result;
  char *v8;
  __int128 v9;
  char *v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  char *v17;
  __int128 v18;

  v6 = (a2 - a1) >> 4;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v8 = a2 - 16;
      if ((*a3)(*((_QWORD *)a2 - 2), *(_QWORD *)a1))
      {
        v9 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v8;
        *(_OWORD *)v8 = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a2 - 2, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, (_QWORD *)a2 - 2, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, (_QWORD *)a1 + 6, (_QWORD *)a2 - 2, a3);
      return 1;
    default:
      v10 = a1 + 32;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, a3);
      v11 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(*(_QWORD *)v11, *(_QWORD *)v10))
    {
      v18 = *(_OWORD *)v11;
      v14 = *(_QWORD *)v11;
      v15 = v12;
      while (1)
      {
        *(_OWORD *)&a1[v15 + 48] = *(_OWORD *)&a1[v15 + 32];
        if (v15 == -32)
          break;
        v16 = (*a3)(v14, *(_QWORD *)&a1[v15 + 16]);
        v15 -= 16;
        if ((v16 & 1) == 0)
        {
          v17 = &a1[v15 + 48];
          goto LABEL_12;
        }
      }
      v17 = a1;
LABEL_12:
      *(_OWORD *)v17 = v18;
      if (++v13 == 8)
        return v11 + 16 == a2;
    }
    v10 = v11;
    v12 += 16;
    v11 += 16;
    if (v11 == a2)
      return 1;
  }
}

BOOL re::serializeDynamicString<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t *v17;
  char *v18;
  _BOOL8 result;
  _anonymous_namespace_ *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  if (this == a6)
    goto LABEL_14;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_14;
  }
  v17 = re::TypeInfo::name(a6);
  if ((unint64_t)*v17 >> 1 != 0x22C6ED80D0CLL
    || (v18 = (char *)v17[1], v18 != "StringID") && strcmp(v18, "StringID"))
  {
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v24 = 0;
    result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, &v24);
    if (!(_DWORD)result)
      return result;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_27;
  }
  v21 = *(_QWORD *)(a4 + 8);
  if ((v21 & 1) != 0)
    v22 = v21 >> 1;
  else
    v22 = v21 >> 1;
  v24 = v22;
  result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, &v24);
  if ((_DWORD)result)
  {
    if (v22)
    {
      if ((*(_BYTE *)(a4 + 8) & 1) != 0)
        v23 = *(_QWORD *)(a4 + 16);
      else
        v23 = a4 + 9;
      re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v23);
    }
    v20 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_27:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::serializeBool<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned __int8 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned __int8 *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(a1 + 24, a2, v13);
}

BOOL re::serializeChar<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *this, re::TypeInfo *a6, int a7)
{
  char *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = &v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(a1 + 24, a2, (uint64_t)v13);
}

BOOL re::serializeI8<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *this, re::TypeInfo *a6, int a7)
{
  char *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = &v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(a1 + 24, a2, v13);
}

BOOL re::serializeI16<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, __int16 *a4, re *this, re::TypeInfo *a6, int a7)
{
  __int16 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  __int16 v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = &v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(a1 + 24, a2, v13);
}

BOOL re::serializeI32<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned int *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned int *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned int *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(a1 + 24, a2, v13);
}

BOOL re::serializeI64<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unint64_t *a4, re *this, re::TypeInfo *a6, int a7)
{
  unint64_t *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unint64_t *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(a1 + 24, a2, v13);
}

BOOL re::serializeU8<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned __int8 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned __int8 *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(a1 + 24, a2, v13);
}

BOOL re::serializeU16<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int16 *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned __int16 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  __int16 v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned __int16 *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(a1 + 24, a2, v13);
}

BOOL re::serializeU32<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned int *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned int *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned int *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(a1 + 24, a2, v13);
}

BOOL re::serializeU64<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, rapidjson::internal **a4, re *this, re::TypeInfo *a6, int a7)
{
  rapidjson::internal **v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (rapidjson::internal **)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, a2, v13);
}

BOOL re::serializeFloat<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, float *a4, re *this, re::TypeInfo *a6, int a7)
{
  float *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (float *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, v13);
}

BOOL re::serializeDouble<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, double *a4, re *this, re::TypeInfo *a6, int a7)
{
  double *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (double *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, v13);
}

uint64_t re::serializeCString<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *this, re::TypeInfo *a6, int a7)
{
  int v13;
  uint64_t result;
  _anonymous_namespace_ *v15;
  const char *v16;
  size_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  int v23;

  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_18:
      return 0;
    }
    v18 = **((_QWORD **)this + 2);
    v19 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v18 != (unsigned __int16)v19)
      goto LABEL_18;
    v21 = WORD1(v18) == WORD1(v19);
    v20 = (v19 ^ v18) & 0xFFFFFF00000000;
    v21 = v21 && v20 == 0;
    if (!v21)
      goto LABEL_18;
  }
LABEL_4:
  if (a7)
  {
    LODWORD(v22) = 0;
    v13 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, (int *)&v22);
    result = 0;
    if (!v13)
      return result;
    v15 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_22;
  }
  v16 = *a4;
  v23 = 2 * (*a4 != 0);
  result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v23);
  if (!(_DWORD)result)
    return result;
  if (v16)
  {
    if (*a4)
    {
      v17 = strlen(*a4);
      v22 = v17;
      if (re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t *)&v22))
      {
        if (v17)
          re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, (uint64_t)*a4);
        goto LABEL_20;
      }
    }
    else
    {
      v22 = 0;
      if (re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t *)&v22))
      {
LABEL_20:
      }
    }
  }
  v15 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_22:
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeStringID<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t *v17;
  char *v18;
  _BOOL8 result;
  _anonymous_namespace_ *v20;
  size_t v21;
  size_t v22;

  if (this == a6)
    goto LABEL_14;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_14;
  }
  v17 = re::TypeInfo::name(a6);
  if ((unint64_t)*v17 >> 1 != 0x134375A94D9F7110
    || (v18 = (char *)v17[1], v18 != "DynamicString") && strcmp(v18, "DynamicString"))
  {
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v22 = 0;
    result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t *)&v22);
    if (!(_DWORD)result)
      return result;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    v21 = strlen(*(const char **)(a4 + 8));
    v22 = v21;
    result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t *)&v22);
    if (!(_DWORD)result)
      return result;
    if (v21)
      re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, *(_QWORD *)(a4 + 8));
    v20 = (_anonymous_namespace_ *)(a1 + 24);
  }
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, unint64_t **this, unint64_t **a6, int a7)
{
  _BOOL8 result;
  unint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34[2];

  if (this != a6)
  {
    if (*this != *a6)
    {
      if (re::areSameTranslatedVersion((re *)this, (const re::TypeInfo *)a6, a3))
        goto LABEL_4;
LABEL_26:
      return 0;
    }
    v21 = *this[2];
    v22 = *a6[2];
    if ((unsigned __int16)v21 != (unsigned __int16)v22)
      goto LABEL_26;
    v24 = WORD1(v21) == WORD1(v22);
    v23 = (v22 ^ v21) & 0xFFFFFF00000000;
    v24 = v24 && v23 == 0;
    if (!v24)
      goto LABEL_26;
  }
LABEL_4:
  if (!a7)
  {
    v14 = *this[2];
    v30 = (uint64_t)*this;
    v31 = v14;
    LODWORD(v32) = -1;
    v34[0] = 0x258C98EAAF29A10ALL;
    v34[1] = (uint64_t)"CallbackSerializerAttribute";
    v15 = (uint64_t *)re::TypeAttributeCollection::operator[](&v30, v34);
    re::StringID::destroyString((re::StringID *)v34);
    v16 = *v15;
    v17 = *(_QWORD *)(a1 + 264);
    v18 = *(_QWORD *)(a1 + 56);
    v32 = 0;
    v33 = 0;
    v30 = v18;
    v31 = 0;
    re::DynamicString::setCapacity(&v30, 0);
    if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v16 + 72))(v17, v16, a4, &v30) & 1) != 0)
    {
      if ((v31 & 1) != 0)
        v19 = v31 >> 1;
      else
        v19 = v31 >> 1;
      v34[0] = v19;
      if (re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, v34))
      {
        if (v19)
        {
          if ((v31 & 1) != 0)
            v20 = v32;
          else
            v20 = (char *)&v31 + 1;
          re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, (uint64_t)v20);
        }
        if (v30)
        {
          if ((v31 & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v30 + 40))();
        }
        return *(_BYTE *)(a1 + 64) == 0;
      }
    }
    else
    {
      re::TypeInfo::name((re::TypeInfo *)this);
    }
    if (v30 && (v31 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v30 + 40))();
    return 0;
  }
  v30 = 0;
  result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, &v30);
  if ((_DWORD)result)
  {
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(uint64_t a1, const char *a2, int *a3)
{
  int v3;
  int v6;
  char *v7;
  uint64_t result;
  __int128 v9;
  uint64_t v10;
  _BOOL8 v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;

  v14 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (*(_BYTE *)(a1 + 40))
    return v3 == 0;
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v14);
  v6 = *a3;
  if ((*a3 - 1) < 2)
  {
LABEL_7:
    LOBYTE(v9) = 9;
    DWORD1(v9) = 0;
    *((_QWORD *)&v9 + 1) = v14;
    v10 = 0;
    v12 = 0;
    v13 = 0;
    v11 = v6 != 0;
    re::Encoder<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v9);
    return v3 == 0;
  }
  if (!v6)
  {
    v7 = *(char **)(a1 + 168);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(v7);
    rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteNull((uint64_t *)v7);
    v6 = *a3;
    goto LABEL_7;
  }
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Unexpected PointerEncoding.", "!\"Unreachable code\"", "beginPointer", 1054);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString(_BYTE *a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *this, re::TypeInfo *a6)
{
  int *v11;
  int v12;
  _anonymous_namespace_ *v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  int v22;
  __int128 v23;
  int v24;
  const char *v25;

  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_14:
      return 0;
    }
    v15 = **((_QWORD **)this + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 != (unsigned __int16)v16)
      goto LABEL_14;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_14;
  }
LABEL_4:
  if (!*a4)
  {
    LODWORD(v25) = 0;
    v13 = (_anonymous_namespace_ *)(a1 + 24);
    v22 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((uint64_t)(a1 + 24), a2, (int *)&v25);
    result = 0;
    if (!v22)
      return result;
    goto LABEL_22;
  }
  if (!a1[336]
    || (v25 = *a4,
        (v11 = (int *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(a1 + 344), (uint64_t *)&v25)) == 0))
  {
    v24 = 2;
    if ((re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((uint64_t)(a1 + 24), a2, &v24) & 1) != 0)
    {
      v19 = (const char *)strlen(*a4);
      v25 = v19;
      result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((uint64_t)(a1 + 24), a2, (uint64_t *)&v25);
      if (!(_DWORD)result)
        return result;
      if (v19)
        re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString((uint64_t)(a1 + 24), (uint64_t)*a4);
      v20 = *a4;
      v21 = **((_QWORD **)this + 2);
      *(_QWORD *)&v23 = *(_QWORD *)this;
      *((_QWORD *)&v23 + 1) = v21;
      re::internal::SharedObjectGraph::addObject((uint64_t)(a1 + 336), (uint64_t)v20, &v23);
      return a1[64] == 0;
    }
    return 0;
  }
  v12 = *v11;
  v24 = 1;
  LODWORD(v25) = v12;
  v13 = (_anonymous_namespace_ *)(a1 + 24);
  result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((uint64_t)(a1 + 24), a2, &v24);
  if (!(_DWORD)result)
    return result;
  re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference((uint64_t)(a1 + 24), (unsigned int *)&v25);
LABEL_22:
  return a1[64] == 0;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer(uint64_t a1, const char *a2, int a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  const re::TypeInfo *v13;
  _BOOL4 isPointerToPolymorphicType;
  int v15;
  char *v16;
  _DWORD *v17;
  _anonymous_namespace_ *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t *v32;
  uint64_t *v33;
  char *v34;
  re::TypeRegistry *v35;
  uint64_t *v36;
  uint64_t *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  __int128 v45;
  _BYTE v46[32];
  __int128 v47;
  _QWORD v48[4];
  _QWORD v49[4];
  char *v50;
  _BYTE v51[32];
  int v52[8];

  isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6)
    goto LABEL_4;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v28 = **((_QWORD **)this + 2);
    v29 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v28 == (unsigned __int16)v29)
    {
      v31 = WORD1(v28) == WORD1(v29);
      v30 = (v29 ^ v28) & 0xFFFFFF00000000;
      v31 = v31 && v30 == 0;
      if (v31)
        goto LABEL_4;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v13))
  {
LABEL_4:
    v15 = 0;
    goto LABEL_5;
  }
  if (*((_BYTE *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (v32 = re::TypeInfo::name(this), v33 = re::TypeInfo::name(a6), !re::StringID::operator==(v32, v33))))
  {
    return 0;
  }
  v15 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v50);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v51);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v50);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v51);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    v20 = *(_QWORD *)v49[2];
    *(_QWORD *)&v47 = v49[0];
    *((_QWORD *)&v47 + 1) = v20;
    if (v49[0])
      goto LABEL_8;
    goto LABEL_15;
  }
  re::internal::actualType(a4, (void **)this, &v47);
  if (!(_QWORD)v47)
  {
LABEL_15:
    v21 = re::TypeInfo::name(this);
    return 0;
  }
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, (re **)&v47, &v50);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)v51);
  if ((a7 & 1) != 0 || (v16 = *a4) == 0)
  {
    LODWORD(v50) = 0;
    v18 = (_anonymous_namespace_ *)(a1 + 24);
    v27 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, (int *)&v50);
    result = 0;
    if (v27)
      goto LABEL_17;
    return result;
  }
  if (!*(_BYTE *)(a1 + 336))
  {
LABEL_33:
    v45 = v47;
    re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), (uint64_t)v16, &v45);
    v44 = 2;
    result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v44);
    if (!(_DWORD)result)
      return result;
    if (!isPointerToPolymorphicType)
    {
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, char *, _QWORD *, _QWORD *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, 0, *a4, v49, v48, 0);
      goto LABEL_45;
    }
    v34 = *a4;
    re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v46);
    if (v15)
    {
      v35 = (re::TypeRegistry *)v48[0];
      v36 = re::TypeInfo::name((re::TypeInfo *)v46);
      re::TypeRegistry::typeInfo(v35, (const re::StringID *)v36, &v50);
      if (!(_BYTE)v50)
      {
        v38 = re::TypeInfo::name((re::TypeInfo *)v46);
LABEL_45:
        if (*(_BYTE *)(a1 + 336))
        {
          --*(_QWORD *)(a1 + 488);
          ++*(_DWORD *)(a1 + 496);
        }
        return *(_BYTE *)(a1 + 64) == 0;
      }
      re::TypeInfo::operator=((uint64_t)v52, (uint64_t)v51);
    }
    if (re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0))
    {
      v37 = re::TypeInfo::polymorphicObjectName((re::TypeInfo *)v52);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, uint64_t, _QWORD, char *, _BYTE *, int *, _QWORD))(*(_QWORD *)a1 + 72))(a1, v37[1], 0, v34, v46, v52, 0);
      re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    }
    goto LABEL_45;
  }
  v50 = *a4;
  v17 = (_DWORD *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 344, (uint64_t *)&v50);
  if (!v17)
  {
    v16 = *a4;
    goto LABEL_33;
  }
  LODWORD(v50) = *v17;
  v52[0] = 1;
  v18 = (_anonymous_namespace_ *)(a1 + 24);
  result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, v52);
  if ((_DWORD)result)
  {
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference(a1 + 24, (unsigned int *)&v50);
LABEL_17:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference(uint64_t result, unsigned int *a2)
{
  _anonymous_namespace_ *v3;

  if (!*(_BYTE *)(result + 40))
  {
    v3 = (_anonymous_namespace_ *)result;
    result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(result, 0, 0);
    if ((_DWORD)result)
    {
      re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>((uint64_t)v3, "@ref", a2);
      return (uint64_t)re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v3);
    }
  }
  return result;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED88D10;
  v2 = *(_QWORD *)(a1 + 472);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 504))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 480) = 0;
    *(_QWORD *)(a1 + 488) = 0;
    *(_QWORD *)(a1 + 472) = 0;
    ++*(_DWORD *)(a1 + 496);
  }
  v3 = *(_QWORD *)(a1 + 432);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 464))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 464) = 0;
    *(_QWORD *)(a1 + 440) = 0;
    *(_QWORD *)(a1 + 448) = 0;
    *(_QWORD *)(a1 + 432) = 0;
    ++*(_DWORD *)(a1 + 456);
  }
  v4 = *(_QWORD *)(a1 + 392);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 344));
  return re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
}

void re::SerializerV1<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED88D10;
  v2 = *(_QWORD *)(a1 + 472);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 504))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 480) = 0;
    *(_QWORD *)(a1 + 488) = 0;
    *(_QWORD *)(a1 + 472) = 0;
    ++*(_DWORD *)(a1 + 496);
  }
  v3 = *(_QWORD *)(a1 + 432);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 464))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 464) = 0;
    *(_QWORD *)(a1 + 440) = 0;
    *(_QWORD *)(a1 + 448) = 0;
    *(_QWORD *)(a1 + 432) = 0;
    ++*(_DWORD *)(a1 + 456);
  }
  v4 = *(_QWORD *)(a1 + 392);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 344));
  re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::SerializerV1<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::trackObject(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v4;

  v4 = *a3;
  return re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), a2, &v4);
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::untrackObject(uint64_t result)
{
  if (*(_BYTE *)(result + 336))
  {
    --*(_QWORD *)(result + 488);
    ++*(_DWORD *)(result + 496);
  }
  return result;
}

void re::SerializerV1<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doOpen(uint64_t a1)
{
  *(_BYTE *)(a1 + 337) = 0;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 344);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
  *(_QWORD *)(a1 + 448) = 0;
  ++*(_DWORD *)(a1 + 456);
  *(_QWORD *)(a1 + 488) = 0;
  ++*(_DWORD *)(a1 + 496);
}

void re::SerializerV1<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doClose(uint64_t a1)
{
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 344);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
  *(_QWORD *)(a1 + 448) = 0;
  ++*(_DWORD *)(a1 + 456);
  *(_QWORD *)(a1 + 488) = 0;
  ++*(_DWORD *)(a1 + 496);
}

void re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doRegisterSerializeFuncs(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 *v7;
  __int128 v8;
  __int128 v9;
  _QWORD v10[2];
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;

  v11 = 6059476;
  v12 = "BOOL";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeBool<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6104748;
  v12 = "char";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeChar<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x172E117BCLL;
  v12 = "int8_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI8<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93A4A92;
  v12 = "int16_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI16<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93BFE06;
  v12 = "int32_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI32<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93EC744;
  v12 = "int64_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6655224;
  v12 = "long";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x31CD534126;
  v12 = "uint8_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU8<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0D4E68;
  v12 = "uint16_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU16<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0F01DCLL;
  v12 = "uint32_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU32<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD11CB1ALL;
  v12 = "uint64_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x1947BDF6CLL;
  v12 = "size_t";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 195052728;
  v12 = "float";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeFloat<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x161EEF7A2;
  v12 = "double";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDouble<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 189247272;
  v12 = "char*";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeCString<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2686EB529B3EE220;
  v12 = "DynamicString";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDynamicString<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x458DDB01A18;
  v12 = "StringID";
  re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeStringID<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v2 = *(_QWORD *)(a1 + 272);
  v11 = 0x258C98EAAF29A10ALL;
  v12 = "CallbackSerializerAttribute";
  v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v11);
  if (v3)
  {
    v4 = *v3;
    re::StringID::destroyString((re::StringID *)&v11);
    if (v2)
    {
      v5 = *(_QWORD *)(a1 + 272);
      v10[0] = v2;
      v10[1] = v4;
      re::TypeRegistry::attributesByAttributeType(v5, (uint64_t)v10, (uint64_t)&v11);
      if (v13)
      {
        v6 = 48 * v13;
        v7 = (__int128 *)(v14 + 16);
        do
        {
          v8 = *v7;
          v7 += 3;
          v9 = v8;
          re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::registerSerializeFunc(a1, (uint64_t)&v9, (uint64_t)re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>);
          v6 -= 48;
        }
        while (v6);
      }
      if (v11)
      {
        if (v14)
          (*(void (**)(void))(*(_QWORD *)v11 + 40))();
      }
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v11);
  }
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t result;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;

  v14 = (_BYTE *)(a1 + 336);
  v15 = *(_QWORD *)(a1 + 488);
  if (!v15)
  {
    if ((_DWORD)a7)
      v16 = 0;
    else
      v16 = a4;
    v17 = **((_QWORD **)a5 + 2);
    *(_QWORD *)&v26 = *(_QWORD *)a5;
    *((_QWORD *)&v26 + 1) = v17;
    re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), v16, &v26);
  }
  v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v18)
  {
    result = v18(a1, a2, a3, a4, a5, a6, a7);
    if (!v15)
    {
      if (*v14)
      {
        --*(_QWORD *)(a1 + 488);
        ++*(_DWORD *)(a1 + 496);
      }
    }
  }
  else
  {
    v20 = re::TypeInfo::name(a5);
    return 0;
  }
  return result;
}

uint64_t (*re::SerializerV1<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, re::TypeInfo *this))(uint64_t a1, const char *a2, int a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  uint64_t *v4;
  uint64_t v5;
  char *v6;
  unsigned int v7;
  uint64_t (*result)(uint64_t, const char *, int, char **, re::TypeInfo *, const re::TypeInfo *, char);
  uint64_t v9;

  v4 = re::TypeInfo::name(this);
  if ((unint64_t)*v4 >> 1 == 94623636)
  {
    v6 = (char *)v4[1];
    if (v6 == "char*" || !strcmp(v6, "char*"))
      return (uint64_t (*)(uint64_t, const char *, int, char **, re::TypeInfo *, const re::TypeInfo *, char))re::SerializerV1<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString;
  }
  if (*((_BYTE *)this + 12) == 9)
  {
    v7 = *(unsigned __int8 *)(*((_QWORD *)this + 2) + 80);
    if (v7 >= 2)
    {
      if (v7 == 2)
      {
        re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) External references are not supported by the SerializerV1.", "!\"Unreachable code\"", "doResolveSerializeFunc", 82);
        _os_crash();
        __break(1u);
      }
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Invalid PointerSharing type.", "!\"Unreachable code\"", "doResolveSerializeFunc", 84);
      result = (uint64_t (*)(uint64_t, const char *, int, char **, re::TypeInfo *, const re::TypeInfo *, char))_os_crash();
      __break(1u);
    }
    else
    {
      return re::SerializerV1<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer;
    }
  }
  else if (*(_QWORD *)this == *(_QWORD *)(a1 + 272)
         && (v9 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, **((_QWORD **)this + 2) | 0xFFFFFFFF00000000)) != 0)
  {
    return *(uint64_t (**)(uint64_t, const char *, int, char **, re::TypeInfo *, const re::TypeInfo *, char))v9;
  }
  else
  {
    return (uint64_t (*)(uint64_t, const char *, int, char **, re::TypeInfo *, const re::TypeInfo *, char))re::serializeType<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  }
  return result;
}

void re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t (*v14)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v14)
    return v14(a1, a2, a3, a4, a5, a6, a7);
  v16 = re::TypeInfo::name(a5);
  return 0;
}

uint64_t (*re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(re::internal **a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *this, re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v3;

  if (*(_QWORD *)a2 == *(_QWORD *)(a1 + 272)
    && (v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 288, **(_QWORD **)(a2 + 16) | 0xFFFFFFFF00000000)) != 0)
  {
    return *(uint64_t (**)(re::internal **, const char *, const re::TypeInfo *, unsigned __int8 *, re *, re::TypeInfo *, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
  }
}

uint64_t re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::~Serializer(uint64_t a1)
{
  double v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)a1 = &off_24ED88D78;
  if (*(_QWORD *)(a1 + 272))
  {
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::SeekableInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(a1 + 288);
    *(_QWORD *)(a1 + 272) = 0;
  }
  v2 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)(a1 + 288));
  v3 = *(_QWORD *)(a1 + 216);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 248))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v3 + 40))(v3, v2);
    *(_QWORD *)(a1 + 248) = 0;
    *(_QWORD *)(a1 + 224) = 0;
    *(_QWORD *)(a1 + 232) = 0;
    *(_QWORD *)(a1 + 216) = 0;
    ++*(_DWORD *)(a1 + 240);
  }
  v4 = *(_QWORD *)(a1 + 120);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 152))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 152) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 136) = 0;
    *(_QWORD *)(a1 + 120) = 0;
    ++*(_DWORD *)(a1 + 144);
  }
  if (*(_BYTE *)(a1 + 64))
  {
    v5 = *(_QWORD *)(a1 + 88);
    if (v5)
    {
      if ((*(_BYTE *)(a1 + 96) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *(_QWORD *)(a1 + 104));
      *(_OWORD *)(a1 + 88) = 0u;
      *(_OWORD *)(a1 + 104) = 0u;
    }
  }
  re::StringID::destroyString((re::StringID *)(a1 + 8));
  return a1;
}

uint64_t re::serializeType<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::internal **a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *this, re::TypeInfo *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t *v23;
  unint64_t v24;
  uint64_t result;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  const re::TypeInfo *v30;
  uint64_t *v31;
  int v32;
  unint64_t v33;
  char *v34;
  BOOL (*v35)(uint64_t, const char *, const re::TypeInfo *, uint64_t, re *, re::TypeInfo *, int);
  _anonymous_namespace_ *v36;
  uint64_t *v37;
  const re::TypeInfo *v38;
  char *v39;
  uint64_t v40;
  _BOOL4 v41;
  uint64_t v42;
  const re::TypeInfo *v43;
  uint64_t v44;
  unsigned __int32 v45;
  const char *v46;
  uint64_t *v47;
  unsigned __int8 *v48;
  const re::TypeInfo *v49;
  re *v50;
  uint64_t *v51;
  uint64_t v52;
  re::UnionAccessor *v53;
  unint64_t Tag;
  unint64_t v55;
  char *v56;
  re::TypeRegistry *v57;
  re *v58;
  re::TypeInfo *v59;
  uint64_t v60;
  const char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t *v69;
  _BOOL4 v70;
  uint64_t v71;
  uint64_t v72;
  _anonymous_namespace_ *v73;
  uint64_t v74;
  double v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v81;
  uint64_t v82;
  int v83;
  re::internal *v84;
  uint64_t v85;
  void (*v86)(re::internal **, _QWORD, _QWORD, _QWORD, rapidjson::internal **, rapidjson::internal **, uint64_t);
  uint64_t v87;
  int v88;
  unint64_t v89;
  int v90;
  uint64_t v91;
  void (*v92)(re::internal **, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD);
  _QWORD *v93;
  int v94;
  int v95;
  _anonymous_namespace_ *v96;
  BOOL v97;
  char v98;
  uint64_t v99;
  uint64_t v100;
  re::internal *v101;
  _BOOL4 v102;
  _anonymous_namespace_ *v103;
  uint64_t v104;
  void (*v105)(re::internal **, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD);
  uint64_t v106;
  _BOOL4 v107;
  uint64_t i;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  char *v114;
  const char *v115;
  char *v116;
  uint64_t v117;
  uint64_t v118;
  re::internal *v119;
  re::internal *v120;
  _anonymous_namespace_ *v121;
  re::TypeInfo *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  void (*v129)(re::internal **, const char *, _QWORD, uint64_t, _QWORD *, _QWORD **, _QWORD);
  uint64_t v130;
  void (*v131)(re::internal **, const char *, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD);
  unint64_t v132;
  _QWORD *v133;
  unint64_t *v134;
  unint64_t v135;
  unint64_t v136;
  uint64_t (**v137)(uint64_t, uint64_t);
  uint64_t (*v138)(uint64_t, uint64_t);
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  __n128 v142;
  uint64_t v143;
  unint64_t v144;
  double v145;
  unint64_t v146;
  void (*v147)(void);
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  BOOL v151;
  _anonymous_namespace_ *v152;
  unsigned int EnumConstantIndex;
  unsigned int v154;
  re::internal::TypeTranslationTable *v155;
  uint64_t v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t v159;
  BOOL v160;
  char v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  re::internal **v166;
  const char *v167;
  const re::TypeInfo *v168;
  unsigned __int8 *v169;
  unint64_t v170;
  uint64_t v171;
  const char *v172;
  uint64_t v173;
  unint64_t v174;
  uint64_t v175;
  char *v176;
  uint64_t (*v177)(unsigned __int8 *, re::internal *);
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  double v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  unint64_t v195;
  char v196[16];
  uint64_t v197;
  _BYTE v198[32];
  uint64_t v199;
  rapidjson::internal *v200;
  uint64_t v201;
  unint64_t v202;
  int v203;
  char *v204;
  _QWORD *v205[4];
  uint64_t v206[4];
  _QWORD v207[4];
  _BYTE v208[28];
  __int16 v209;
  unint64_t v210;
  __n128 __dst;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  uint64_t v216;

  v216 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_18;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        goto LABEL_18;
    }
LABEL_10:
    if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12))
      goto LABEL_283;
    v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
    if (v19)
      v20 = *(_DWORD *)(v19 + 16);
    else
      v20 = -1;
    v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
    if (v21)
      v22 = *(_DWORD *)(v21 + 16);
    else
      v22 = -1;
    if (v20 != v22)
    {
      v26 = re::TypeInfo::name(this)[1];
      re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
      re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **((_QWORD **)a6 + 2));
      LOBYTE(v193) = v26;
      v46 = "Cannot serialize type \"%s\" version %u as version %u. Downgrading versions is not supported.";
LABEL_74:
      return 0;
    }
    goto LABEL_18;
  }
  if (!re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_10;
LABEL_18:
  switch(*((_BYTE *)this + 12))
  {
    case 1:
      if (this == a6)
        goto LABEL_22;
      if (*(_QWORD *)this != *(_QWORD *)a6)
      {
        if (!re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_283;
LABEL_22:
        v23 = re::TypeInfo::name(this);
        v24 = (unint64_t)*v23 >> 1;
        if (v24 <= 0xCA3DEFB5)
        {
          if ((unint64_t)*v23 >> 1 <= 0x5D0225B)
          {
            if ((unint64_t)*v23 >> 1 <= 0x2E9355)
            {
              if (v24 != 104431)
              {
                if (v24 == 3029738)
                  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool((uint64_t)(a1 + 3), a2, a4);
LABEL_335:
                v193 = re::TypeInfo::name(this)[1];
                v46 = "Unsupported basic type \"%s\".";
                goto LABEL_74;
              }
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>((uint64_t)(a1 + 3), a2, (unsigned int *)a4);
            }
            if (v24 == 3052374)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar((uint64_t)(a1 + 3), a2, (uint64_t)a4);
            v165 = 3327612;
LABEL_269:
            if (v24 == v165)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>((uint64_t)(a1 + 3), a2, (unint64_t *)a4);
            goto LABEL_335;
          }
          if ((unint64_t)*v23 >> 1 > 0xB0F77BD0)
          {
            if (v24 == 2969009105)
              return re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>((uint64_t)(a1 + 3), a2, (double *)a4);
            if (v24 == 3111160798)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>((uint64_t)(a1 + 3), a2, (char *)a4);
            goto LABEL_335;
          }
          if (v24 == 97526364)
            return re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>((uint64_t)(a1 + 3), a2, (float *)a4);
          v52 = 109413500;
LABEL_176:
          if (v24 == v52)
            return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>((uint64_t)(a1 + 3), a2, (__int16 *)a4);
          goto LABEL_335;
        }
        if ((unint64_t)*v23 >> 1 > 0x18E6A9A092)
        {
          if ((unint64_t)*v23 >> 1 <= 0x303EE8780EDLL)
          {
            if (v24 == 0x18E6A9A093)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>((uint64_t)(a1 + 3), a2, a4);
            if (v24 == 0x303EE86A734)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>((uint64_t)(a1 + 3), a2, (unsigned __int16 *)a4);
            goto LABEL_335;
          }
          if (v24 == 0x303EE8780EELL)
            return re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>((uint64_t)(a1 + 3), a2, (unsigned int *)a4);
          if (v24 != 0x303EE88E58DLL)
            goto LABEL_335;
        }
        else
        {
          if ((unint64_t)*v23 >> 1 > 0x16749DFF02)
          {
            if (v24 == 0x16749DFF03)
              return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>((uint64_t)(a1 + 3), a2, (unsigned int *)a4);
            v165 = 0x16749F63A2;
            goto LABEL_269;
          }
          if (v24 != 3393056694)
          {
            v52 = 0x16749D2549;
            goto LABEL_176;
          }
        }
        return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>((uint64_t)(a1 + 3), a2, (rapidjson::internal **)a4);
      }
      v62 = **((_QWORD **)this + 2);
      v63 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v62 == (unsigned __int16)v63)
      {
        v18 = WORD1(v62) == WORD1(v63);
        v64 = (v63 ^ v62) & 0xFFFFFF00000000;
        if (v18 && v64 == 0)
          goto LABEL_22;
      }
      goto LABEL_283;
    case 2:
      if (this == a6)
        goto LABEL_227;
      if (*(_QWORD *)this != *(_QWORD *)a6)
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_109;
        v27 = *((unsigned __int8 *)this + 12);
LABEL_107:
        if (v27 == *((unsigned __int8 *)a6 + 12))
        {
          v68 = re::TypeInfo::name(this);
          v69 = re::TypeInfo::name(a6);
          if (re::StringID::operator==(v68, v69))
            goto LABEL_109;
        }
LABEL_283:
        return 0;
      }
      v66 = **((_QWORD **)this + 2);
      v67 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v66 != (unsigned __int16)v67
        || WORD1(v66) != WORD1(v67)
        || ((v67 ^ v66) & 0xFFFFFF00000000) != 0)
      {
        v27 = 2;
        goto LABEL_107;
      }
LABEL_109:
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v148 = **((_QWORD **)this + 2);
        v149 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v148 == (unsigned __int16)v149
          && ((v18 = WORD1(v148) == WORD1(v149), v150 = (v149 ^ v148) & 0xFFFFFF00000000, v18)
            ? (v151 = v150 == 0)
            : (v151 = 0),
              v151))
        {
LABEL_227:
          v70 = 0;
        }
        else
        {
          v70 = 1;
        }
      }
      else
      {
        v70 = !re::areSameTranslatedVersion(this, a6, a3);
      }
      if ((_DWORD)a7)
      {
        __dst.n128_u64[0] = 0;
        result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((uint64_t)(a1 + 3), a2, (uint64_t *)&__dst);
        if (!(_DWORD)result)
          return result;
        v152 = (_anonymous_namespace_ *)(a1 + 3);
LABEL_231:
        return *((_BYTE *)a1 + 64) == 0;
      }
      if (*(_DWORD *)(*((_QWORD *)this + 2) + 8) >= 9u)
      {
        v193 = re::TypeInfo::name(this)[1];
        v46 = "Enum type \"%s\" has invalid size: %zu bytes";
        goto LABEL_74;
      }
      EnumConstantIndex = re::internal::getEnumConstantIndex(this, (const re::TypeInfo *)a4, a3);
      if ((EnumConstantIndex & 0x80000000) != 0)
      {
        __dst.n128_u64[0] = 0;
        memcpy(&__dst, a4, *(unsigned int *)(*((_QWORD *)this + 2) + 8));
        LOBYTE(v193) = __dst.n128_u8[0];
        re::TypeInfo::name(this);
        v46 = "Value %zu is not a valid enum constant of \"%s\".";
        goto LABEL_74;
      }
      v154 = EnumConstantIndex;
      if (v70)
      {
        v155 = *(re::internal::TypeTranslationTable **)(*(_QWORD *)a6 + 856);
        if (!v155 || (v156 = re::internal::TypeTranslationTable::translateRuntimeEnum(v155, this, v154, a6)) == 0)
        {
          v157 = re::TypeInfo::enumConstants(this);
          v159 = v154;
          if (v158 > v154)
          {
            v193 = *(_QWORD *)(v157 + 24 * v154 + 16);
            re::TypeInfo::name(a6);
            v46 = "Runtime enum constant \"%s\" does not exist in serialized type \"%s\".";
            goto LABEL_74;
          }
LABEL_356:
          re::internal::assertLog((re::internal *)6, v158, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v159, v158);
          _os_crash();
          __break(1u);
        }
LABEL_292:
        v172 = *(const char **)(v156 + 16);
        __dst.n128_u64[0] = strlen(v172);
        if (!re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((uint64_t)(a1 + 3), a2, (uint64_t *)&__dst))return 0;
        re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString((uint64_t)(a1 + 3), (uint64_t)v172);
        v152 = (_anonymous_namespace_ *)(a1 + 3);
        goto LABEL_231;
      }
      result = re::TypeInfo::enumConstants(this);
      v171 = v154;
      if (v170 <= v154)
      {
LABEL_355:
        re::internal::assertLog((re::internal *)6, v170, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v171, v170);
        _os_crash();
        __break(1u);
        goto LABEL_356;
      }
      if (result)
      {
        v156 = result + 24 * v154;
        goto LABEL_292;
      }
      return result;
    case 3:
      if (this == a6)
        goto LABEL_116;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v71 = **((_QWORD **)this + 2);
        v72 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v71 == (unsigned __int16)v72
          && WORD1(v71) == WORD1(v72)
          && ((v72 ^ v71) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_116;
        }
        v28 = 3;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_116;
        v28 = *((unsigned __int8 *)this + 12);
      }
      if (v28 != *((unsigned __int8 *)a6 + 12))
        goto LABEL_283;
LABEL_116:
      if ((_DWORD)a7)
      {
        __dst.n128_u8[0] = 0;
        re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional((uint64_t)(a1 + 3), a2, &__dst);
        v73 = (_anonymous_namespace_ *)(a1 + 3);
      }
      else
      {
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)&v200, (uint64_t)&__dst.n128_i64[1]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
        re::TypeInfo::TypeInfo((uint64_t)&__dst, (uint64_t)this);
        v74 = (*(uint64_t (**)(unsigned __int8 *))(v212 + 80))(a4);
        LOBYTE(v207[0]) = v74 != 0;
        v75 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginOptional((uint64_t)(a1 + 3), a2, v207);
        if (v74)
        {
          v76 = (*(uint64_t (**)(unsigned __int8 *, double))(v212 + 80))(a4, v75);
          if (!*((_BYTE *)a1 + 64))
            (*((void (**)(re::internal **, const char *, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD))*a1
             + 9))(a1, a2, 0, v76, &v200, v208, 0);
        }
        v73 = (_anonymous_namespace_ *)(a1 + 3);
      }
      return *((_BYTE *)a1 + 64) == 0;
    case 4:
      if (this == a6)
        goto LABEL_131;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v77 = **((_QWORD **)this + 2);
        v78 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v77 == (unsigned __int16)v78)
        {
          v18 = WORD1(v77) == WORD1(v78);
          v79 = (v78 ^ v77) & 0xFFFFFF00000000;
          if (v18 && v79 == 0)
            goto LABEL_131;
        }
      }
      else if (re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_131;
      }
      if (*((_BYTE *)a6 + 12) != 4)
        goto LABEL_283;
      v81 = *((_QWORD *)this + 2);
      v82 = *((_QWORD *)a6 + 2);
      v83 = *(_DWORD *)(v82 + 84) & 0xFFFFFF;
      if ((*(_DWORD *)(v81 + 84) & 0xFFFFFF) != 0)
      {
        if (!v83)
          goto LABEL_283;
      }
      else if (v83 || *(_DWORD *)(v81 + 88) != *(_DWORD *)(v82 + 88))
      {
        goto LABEL_283;
      }
LABEL_131:
      if ((_DWORD)a7)
      {
        v84 = a1[34];
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
        re::internal::translateType(v84, (const re::TypeRegistry *)v208, (uint64_t)&v200);
        v85 = (*((uint64_t (**)(re::internal **, rapidjson::internal **))*a1 + 10))(a1, &v200);
        if (!v85)
          goto LABEL_201;
        v86 = (void (*)(re::internal **, _QWORD, _QWORD, _QWORD, rapidjson::internal **, rapidjson::internal **, uint64_t))v85;
        v87 = *((_QWORD *)a6 + 2);
        v88 = *(_DWORD *)(v87 + 84) & 0xFFFFFF;
        if (v88)
        {
          v89 = 0;
          v90 = 8;
        }
        else
        {
          v89 = *(int *)(v87 + 88);
          v90 = 4;
        }
        __dst.n128_u64[0] = v89;
        v96 = (_anonymous_namespace_ *)(a1 + 3);
        result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((uint64_t)(a1 + 3), a2, (uint64_t *)&__dst, v90);
        if (!(_DWORD)result)
          return result;
        if (v88)
          v160 = v89 == 0;
        else
          v160 = 1;
        v161 = v160;
        if (!v160)
        {
          v207[0] = 0;
          v207[1] = 0xFFFFFFFFLL;
          (*((void (**)(re::internal **, _QWORD, _QWORD *))*a1 + 2))(a1, 0, v207);
        }
        for (; v89; --v89)
          v86(a1, 0, 0, 0, &v200, &v200, 1);
        if ((v161 & 1) != 0)
          goto LABEL_298;
      }
      else
      {
        re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)&v200, (uint64_t)&__dst.n128_i64[1]);
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
        re::TypeInfo::TypeInfo((uint64_t)&__dst, (uint64_t)this);
        v91 = (*((uint64_t (**)(re::internal **, rapidjson::internal **))*a1 + 10))(a1, &v200);
        if (!v91)
          goto LABEL_201;
        v92 = (void (*)(re::internal **, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD))v91;
        v93 = (_QWORD *)re::ArrayAccessor::size((re::ArrayAccessor *)&__dst, (char *)a4);
        v205[0] = v93;
        v94 = *(_DWORD *)(*((_QWORD *)this + 2) + 84) & 0xFFFFFF;
        if (v94)
          v95 = 8;
        else
          v95 = 4;
        v96 = (_anonymous_namespace_ *)(a1 + 3);
        result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((uint64_t)(a1 + 3), a2, (uint64_t *)v205, v95);
        if (!(_DWORD)result)
          return result;
        if (v94)
          v97 = v93 == 0;
        else
          v97 = 1;
        v98 = v97;
        if (v97)
        {
          if (!v93)
            goto LABEL_298;
        }
        else
        {
          v173 = *(_QWORD *)a4;
          v206[0] = 0;
          v206[1] = 0xFFFFFFFFLL;
          (*((void (**)(re::internal **, uint64_t, uint64_t *))*a1 + 2))(a1, v173, v206);
        }
        v174 = 0;
        do
        {
          v175 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)&__dst, (char *)a4, v174);
          v92(a1, 0, 0, v175, &v200, v208, 0);
          ++v174;
        }
        while (v93 != (_QWORD *)v174);
        if ((v98 & 1) != 0)
        {
LABEL_298:
          v103 = v96;
LABEL_299:
          re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endArray(v103);
          return *((_BYTE *)a1 + 64) == 0;
        }
      }
      (*((void (**)(re::internal **))*a1 + 3))(a1);
      goto LABEL_298;
    case 5:
      if (this == a6)
        goto LABEL_155;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v99 = **((_QWORD **)this + 2);
        v100 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v99 == (unsigned __int16)v100
          && WORD1(v99) == WORD1(v100)
          && ((v100 ^ v99) & 0xFFFFFF00000000) == 0)
        {
          goto LABEL_155;
        }
        v29 = 5;
      }
      else
      {
        if (re::areSameTranslatedVersion(this, a6, a3))
          goto LABEL_155;
        v29 = *((unsigned __int8 *)this + 12);
      }
      if (v29 != *((unsigned __int8 *)a6 + 12))
        goto LABEL_283;
LABEL_155:
      if ((_DWORD)a7)
      {
        v101 = a1[34];
        re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
        re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
        re::internal::translateType(v101, (const re::TypeRegistry *)v208, (uint64_t)&v200);
        if (!(*((uint64_t (**)(re::internal **, rapidjson::internal **))*a1 + 10))(a1, &v200))
          goto LABEL_201;
        __dst.n128_u64[0] = 0;
        v102 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((uint64_t)(a1 + 3), a2, (uint64_t *)&__dst, 0);
        result = 0;
        if (v102)
        {
          v103 = (_anonymous_namespace_ *)(a1 + 3);
          goto LABEL_299;
        }
        return result;
      }
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &__dst);
      re::TypeInfo::TypeInfo((uint64_t)&v200, (uint64_t)&__dst.n128_i64[1]);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
      re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
      re::TypeInfo::TypeInfo((uint64_t)&__dst, (uint64_t)this);
      v104 = (*((uint64_t (**)(re::internal **, rapidjson::internal **))*a1 + 10))(a1, &v200);
      if (!v104)
        goto LABEL_201;
      v105 = (void (*)(re::internal **, _QWORD, _QWORD, uint64_t, rapidjson::internal **, _BYTE *, _QWORD))v104;
      v106 = (*(uint64_t (**)(unsigned __int8 *))(v212 + 80))(a4);
      v206[0] = v106;
      v96 = (_anonymous_namespace_ *)(a1 + 3);
      v107 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginArray((uint64_t)(a1 + 3), a2, v206, 0);
      result = 0;
      if (!v107)
        return result;
      if (*(_QWORD *)(v212 + 96))
      {
        if (v106)
        {
          for (i = 0; i != v106; ++i)
          {
            v109 = (*(uint64_t (**)(unsigned __int8 *, uint64_t))(v212 + 96))(a4, i);
            v105(a1, 0, 0, v109, &v200, v208, 0);
          }
        }
      }
      else
      {
        v177 = *(uint64_t (**)(unsigned __int8 *, re::internal *))(v212 + 104);
        if (!v177 || !*(_QWORD *)(v212 + 112) || !*(_QWORD *)(v212 + 120))
        {
          re::TypeInfo::TypeInfo((uint64_t)v207, (uint64_t)&__dst);
          v193 = re::TypeInfo::name((re::TypeInfo *)v207)[1];
          v46 = "List type \"%s\" does not provide an indexer or iterator.";
          goto LABEL_74;
        }
        v178 = v177(a4, a1[7]);
        v179 = (*(uint64_t (**)(void))(v212 + 112))();
        if (v179)
        {
          v180 = v179;
          do
          {
            v105(a1, 0, 0, v180, &v200, v208, 0);
            v180 = (*(uint64_t (**)(uint64_t))(v212 + 112))(v178);
          }
          while (v180);
        }
        (*(void (**)(uint64_t, re::internal *))(v212 + 120))(v178, a1[7]);
      }
      goto LABEL_298;
    case 6:
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &__dst);
      re::TypeInfo::TypeInfo((uint64_t)&v200, (uint64_t)&__dst.n128_i64[1]);
      v31 = re::TypeInfo::name((re::TypeInfo *)&v200);
      v32 = BYTE4(v201);
      if (BYTE4(v201) != 1)
        goto LABEL_89;
      if (!re::TypeInfo::isInteger((re::TypeInfo *)&v200))
      {
        v32 = BYTE4(v201);
LABEL_89:
        if (v32 == 8)
        {
          v55 = (unint64_t)*v31 >> 1;
          if (v55 == 0x22C6ED80D0CLL)
          {
            v116 = (char *)v31[1];
            if (v116 == "StringID" || !strcmp(v116, "StringID"))
            {
              v35 = re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
              goto LABEL_351;
            }
          }
          else if (v55 == 0x134375A94D9F7110)
          {
            v56 = (char *)v31[1];
            if (v56 == "DynamicString" || !strcmp(v56, "DynamicString"))
            {
              v35 = re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>;
              goto LABEL_351;
            }
          }
        }
LABEL_188:
        if (this == a6)
          goto LABEL_196;
        if (*(_QWORD *)this == *(_QWORD *)a6)
        {
          v117 = **((_QWORD **)this + 2);
          v118 = **((_QWORD **)a6 + 2);
          if ((unsigned __int16)v117 == (unsigned __int16)v118
            && WORD1(v117) == WORD1(v118)
            && ((v118 ^ v117) & 0xFFFFFF00000000) == 0)
          {
            goto LABEL_196;
          }
        }
        else if (re::areSameTranslatedVersion(this, a6, v30))
        {
          goto LABEL_196;
        }
        if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12))
          goto LABEL_283;
LABEL_196:
        if ((_DWORD)a7)
        {
          v119 = a1[34];
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v208, (uint64_t)&__dst.n128_i64[1]);
          re::internal::translateType(v119, (const re::TypeRegistry *)v208, (uint64_t)&v200);
          v120 = a1[34];
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v207, (uint64_t)&__dst.n128_i64[1]);
          re::internal::translateType(v120, (const re::TypeRegistry *)v207, (uint64_t)v208);
          if ((*((uint64_t (**)(re::internal **, rapidjson::internal **))*a1 + 10))(a1, &v200))
          {
            if ((*((uint64_t (**)(re::internal **, _BYTE *))*a1 + 10))(a1, v208))
            {
              __dst.n128_u64[0] = 0;
              result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary((uint64_t)(a1 + 3), a2, (uint64_t *)&__dst);
              if (!(_DWORD)result)
                return result;
              v121 = (_anonymous_namespace_ *)(a1 + 3);
              goto LABEL_348;
            }
            v122 = (re::TypeInfo *)v208;
          }
          else
          {
LABEL_201:
            v122 = (re::TypeInfo *)&v200;
          }
        }
        else
        {
          re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v207, (uint64_t)&__dst.n128_i64[1]);
          re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v206, (uint64_t)&__dst.n128_i64[1]);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v205, (uint64_t)&__dst.n128_i64[1]);
          re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v198, (uint64_t)&__dst.n128_i64[1]);
          re::TypeInfo::TypeInfo((uint64_t)v196, (uint64_t)this);
          v128 = (*((uint64_t (**)(re::internal **, _QWORD *))*a1 + 10))(a1, v207);
          if (v128)
          {
            v129 = (void (*)(re::internal **, const char *, _QWORD, uint64_t, _QWORD *, _QWORD **, _QWORD))v128;
            v130 = (*((uint64_t (**)(re::internal **, uint64_t *))*a1 + 10))(a1, v206);
            if (v130)
            {
              v131 = (void (*)(re::internal **, const char *, _QWORD, uint64_t, uint64_t *, _BYTE *, _QWORD))v130;
              v132 = (*(uint64_t (**)(unsigned __int8 *))(v197 + 88))(a4);
              v195 = v132;
              result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionary((uint64_t)(a1 + 3), a2, (uint64_t *)&v195);
              if (!(_DWORD)result)
                return result;
              if (!v132)
                goto LABEL_347;
              v133 = *(_QWORD **)this;
              __dst.n128_u64[0] = 0x449AD97C4B77BED4;
              __dst.n128_u64[1] = (unint64_t)"_CompareFunc";
              v134 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)(v133 + 25), &__dst);
              if (v134)
              {
                v135 = *v134;
                re::StringID::destroyString((re::StringID *)&__dst);
                if (v133)
                {
                  v136 = *(_QWORD *)v207[2];
                  __dst.n128_u64[0] = v135;
                  __dst.n128_u64[1] = v136;
                  LODWORD(v212) = -1;
                  v137 = (uint64_t (**)(uint64_t, uint64_t))re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(v207[0] + 768, (uint64_t *)&__dst);
                  if (v137)
                  {
                    v138 = *v137;
                    if (*v137)
                    {
                      v204 = 0;
                      v201 = 0;
                      v202 = 0;
                      v203 = 0;
                      v200 = a1[7];
                      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v200, v132);
                      ++v203;
                      v139 = (*(uint64_t (**)(unsigned __int8 *, re::internal *))(v197 + 112))(a4, a1[7]);
                      if ((*(unsigned int (**)(void))(v197 + 120))())
                      {
                        do
                        {
                          v140 = (*(uint64_t (**)(uint64_t))(v197 + 128))(v139);
                          v141 = (*(uint64_t (**)(uint64_t))(v197 + 136))(v139);
                          __dst.n128_u64[0] = v140;
                          __dst.n128_u64[1] = v141;
                          v142 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v200, &__dst);
                        }
                        while (((*(uint64_t (**)(uint64_t, __n128))(v197 + 120))(v139, v142) & 1) != 0);
                      }
                      (*(void (**)(uint64_t, re::internal *))(v197 + 144))(v139, a1[7]);
                      std::sort[abi:nn180100]<re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1}>(v204, &v204[16 * v202], v138);
                      v143 = 0;
                      v144 = 0;
                      if (v132 <= 1)
                        v132 = 1;
                      while (1)
                      {
                        v145 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry((uint64_t)(a1 + 3), 0);
                        v146 = v202;
                        if (v202 <= v144)
                          break;
                        ((void (*)(re::internal **, const char *, _QWORD, _QWORD, _QWORD *, _QWORD **, _QWORD, double))v129)(a1, "key", 0, *(_QWORD *)&v204[v143], v207, v205, 0, v145);
                        v146 = v202;
                        if (v202 <= v144)
                          goto LABEL_354;
                        v131(a1, "value", 0, *(_QWORD *)&v204[v143 + 8], v206, v198, 0);
                        re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 3));
                        ++v144;
                        v143 += 16;
                        if (v132 == v144)
                        {
                          if (v200 && v204)
                          {
                            v147 = *(void (**)(void))(*(_QWORD *)v200 + 40);
                            goto LABEL_346;
                          }
                          goto LABEL_347;
                        }
                      }
                      v199 = 0;
                      v214 = 0u;
                      v215 = 0u;
                      v212 = 0u;
                      v213 = 0u;
                      __dst = 0u;
                      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                      *(_DWORD *)v208 = 136315906;
                      *(_QWORD *)&v208[4] = "operator[]";
                      *(_WORD *)&v208[12] = 1024;
                      *(_DWORD *)&v208[14] = 789;
                      *(_WORD *)&v208[18] = 2048;
                      *(_QWORD *)&v208[20] = v144;
                      v209 = 2048;
                      v210 = v146;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
LABEL_354:
                      v199 = 0;
                      v214 = 0u;
                      v215 = 0u;
                      v212 = 0u;
                      v213 = 0u;
                      __dst = 0u;
                      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                      *(_DWORD *)v208 = 136315906;
                      *(_QWORD *)&v208[4] = "operator[]";
                      *(_WORD *)&v208[12] = 1024;
                      *(_DWORD *)&v208[14] = 789;
                      *(_WORD *)&v208[18] = 2048;
                      *(_QWORD *)&v208[20] = v144;
                      v209 = 2048;
                      v210 = v146;
                      _os_log_send_and_compose_impl();
                      _os_crash_msg();
                      __break(1u);
                      goto LABEL_355;
                    }
                  }
                }
              }
              else
              {
                re::StringID::destroyString((re::StringID *)&__dst);
              }
              v189 = (*(uint64_t (**)(unsigned __int8 *, re::internal *))(v197 + 112))(a4, a1[7]);
              (*(void (**)(void))(v197 + 120))();
              do
              {
                v190 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginDictionaryEntry((uint64_t)(a1 + 3), 0);
                v191 = (*(uint64_t (**)(uint64_t, double))(v197 + 128))(v189, v190);
                v129(a1, "key", 0, v191, v207, v205, 0);
                v192 = (*(uint64_t (**)(uint64_t))(v197 + 136))(v189);
                v131(a1, "value", 0, v192, v206, v198, 0);
                re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 3));
                (*(void (**)(uint64_t))(v197 + 120))(v189);
                --v132;
              }
              while (v132);
              v147 = *(void (**)(void))(v197 + 144);
LABEL_346:
              v147();
LABEL_347:
              v121 = (_anonymous_namespace_ *)(a1 + 3);
LABEL_348:
              re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endDictionary(v121);
              return *((_BYTE *)a1 + 64) == 0;
            }
            v122 = (re::TypeInfo *)v206;
          }
          else
          {
            v122 = (re::TypeInfo *)v207;
          }
        }
        v194 = re::TypeInfo::name(v122)[1];
        return 0;
      }
      v33 = (unint64_t)*v31 >> 1;
      if (v33 > 0x303EE8780EDLL)
      {
        if (v33 == 0x303EE8780EELL)
        {
          v176 = (char *)v31[1];
          if (v176 == "uint32_t" || !strcmp(v176, "uint32_t"))
          {
            v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>;
            goto LABEL_351;
          }
          goto LABEL_306;
        }
        if (v33 != 0x303EE88E58DLL)
        {
LABEL_306:
          __dst.n128_u64[0] = 0x18E6A9A093;
          __dst.n128_u64[1] = (unint64_t)"uint8_t";
          if (re::StringID::operator==(v31, &__dst))
          {
            v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>;
            goto LABEL_351;
          }
          __dst.n128_u64[0] = 0x16749F63A2;
          __dst.n128_u64[1] = (unint64_t)"int64_t";
          if (re::StringID::operator==(v31, &__dst)
            || (*(_QWORD *)v208 = 3327612, *(_QWORD *)&v208[8] = "long", re::StringID::operator==(v31, v208)))
          {
            v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>;
            goto LABEL_351;
          }
          __dst.n128_u64[0] = 104431;
          __dst.n128_u64[1] = (unint64_t)"int";
          if (re::StringID::operator==(v31, &__dst))
          {
            v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>;
            goto LABEL_351;
          }
          __dst.n128_u64[0] = 109413500;
          __dst.n128_u64[1] = (unint64_t)"short";
          if (re::StringID::operator==(v31, &__dst))
          {
            v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>;
            goto LABEL_351;
          }
          goto LABEL_188;
        }
        v114 = (char *)v31[1];
        if (v114 != "uint64_t")
        {
          v115 = "uint64_t";
          goto LABEL_302;
        }
      }
      else
      {
        if (v33 != 3393056694)
        {
          if (v33 == 0x303EE86A734)
          {
            v34 = (char *)v31[1];
            if (v34 == "uint16_t" || !strcmp(v34, "uint16_t"))
            {
              v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>;
LABEL_351:
              v166 = a1;
              v167 = a2;
              v168 = a3;
              v169 = a4;
              v50 = this;
              v51 = (uint64_t *)a6;
              return ((uint64_t (*)(re::internal **, const char *, const re::TypeInfo *, unsigned __int8 *, re *, uint64_t *, uint64_t))v35)(v166, v167, v168, v169, v50, v51, a7);
            }
          }
          goto LABEL_306;
        }
        v114 = (char *)v31[1];
        if (v114 != "size_t")
        {
          v115 = "size_t";
LABEL_302:
          if (!strcmp(v114, v115))
            goto LABEL_303;
          goto LABEL_306;
        }
      }
LABEL_303:
      v35 = re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>;
      goto LABEL_351;
    case 7:
      if (this == a6)
        goto LABEL_57;
      if (*(_QWORD *)this == *(_QWORD *)a6)
      {
        v110 = **((_QWORD **)this + 2);
        v111 = **((_QWORD **)a6 + 2);
        if ((unsigned __int16)v110 != (unsigned __int16)v111)
          goto LABEL_283;
        v18 = WORD1(v110) == WORD1(v111);
        v112 = (v111 ^ v110) & 0xFFFFFF00000000;
        if (!v18 || v112 != 0)
          goto LABEL_283;
      }
      else if (!re::areSameTranslatedVersion(this, a6, a3))
      {
        goto LABEL_283;
      }
LABEL_57:
      v36 = (_anonymous_namespace_ *)(a1 + 3);
      result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((uint64_t)(a1 + 3), a2, 16);
      if ((_DWORD)a7)
      {
        if (!(_DWORD)result)
          return result;
        v200 = 0;
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>((uint64_t)(a1 + 3), "tag", &v200);
        if (*(_DWORD *)(*((_QWORD *)a6 + 2) + 88))
        {
          re::TypeInfo::unionMember(a6, 0, (uint64_t)&__dst);
          if (!*((_BYTE *)a1 + 64))
            (*((void (**)(re::internal **, const char *, _QWORD, _QWORD, __n128 *, __n128 *, uint64_t))*a1 + 9))(a1, "value", 0, 0, &__dst, &__dst, 1);
        }
      }
      else
      {
        if (!(_DWORD)result)
          return result;
        v53 = (re::UnionAccessor *)re::TypeInfo::TypeInfo((uint64_t)&__dst, (uint64_t)this);
        Tag = re::UnionAccessor::readTag(v53, (char *)a4);
        *(_QWORD *)v208 = Tag;
        re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>((uint64_t)(a1 + 3), "tag", (rapidjson::internal **)v208);
        if (Tag < *(unsigned int *)(*((_QWORD *)this + 2) + 88))
        {
          re::TypeInfo::unionMember(this, Tag, (uint64_t)&v200);
          if (!*((_BYTE *)a1 + 64))
            (*((void (**)(re::internal **, const char *, _QWORD, unsigned __int8 *, rapidjson::internal **, rapidjson::internal **, _QWORD))*a1
             + 9))(a1, "value", 0, a4, &v200, &v200, 0);
        }
      }
      goto LABEL_337;
    case 8:
      if (!(_DWORD)a7)
        goto LABEL_67;
      if ((*(_BYTE *)(*((_QWORD *)this + 2) + 49) & 1) != 0)
      {
        v57 = a1[34];
        *(_QWORD *)v208 = 0x2686EB529B3EE220;
        *(_QWORD *)&v208[8] = "DynamicString";
        re::TypeRegistry::typeInfo(v57, (const re::StringID *)v208, &__dst);
        re::TypeInfo::TypeInfo((uint64_t)&v200, (uint64_t)&__dst.n128_i64[1]);
        re::StringID::destroyString((re::StringID *)v208);
        v58 = (re *)&v200;
        v59 = (re::TypeInfo *)&v200;
        v60 = (uint64_t)a1;
        v61 = a2;
      }
      else
      {
        v37 = re::TypeInfo::name(this);
        if ((*v37 & 0xFFFFFFFFFFFFFFFELL) != 0x2686EB529B3EE220
          || (v39 = (char *)v37[1], v39 != "DynamicString") && strcmp(v39, "DynamicString"))
        {
LABEL_67:
          v40 = *((_QWORD *)this + 2);
          if ((*(_BYTE *)(v40 + 48) & 4) == 0)
          {
            v36 = (_anonymous_namespace_ *)(a1 + 3);
            v41 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject((uint64_t)(a1 + 3), a2, 0);
            result = 0;
            if (!v41)
              return result;
            v42 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
            if (!v42 || *(_DWORD *)(v42 + 16) >= 2u)
            {
              v44 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
              if (v44)
                v45 = *(_DWORD *)(v44 + 16);
              else
                v45 = -1;
              __dst.n128_u32[0] = v45;
              re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>((uint64_t)(a1 + 3), "@version", (unsigned int *)&__dst);
            }
            if (this == a6)
              goto LABEL_323;
            if (*(_QWORD *)this == *(_QWORD *)a6)
            {
              v181 = **((_QWORD **)this + 2);
              v182 = **((_QWORD **)a6 + 2);
              if ((unsigned __int16)v181 == (unsigned __int16)v182
                && WORD1(v181) == WORD1(v182)
                && ((v182 ^ v181) & 0xFFFFFF00000000) == 0)
              {
                goto LABEL_323;
              }
            }
            else if (re::areSameTranslatedVersion(this, a6, v43))
            {
LABEL_323:
              re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, (uint64_t)a4, (uint64_t *)this, a7);
LABEL_337:
              re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v36);
              return *((_BYTE *)a1 + 64) == 0;
            }
            if (*((unsigned __int8 *)this + 12) == *((unsigned __int8 *)a6 + 12))
            {
              re::internal::serializeMembersWithVersioning<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::PrettyWriter<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>((uint64_t)a1, (uint64_t)a4, (uint64_t *)this, (uint64_t *)a6, a7);
            }
            else
            {
              v183 = re::TypeInfo::name(this)[1];
              re::TypeInfo::name(a6);
            }
            goto LABEL_337;
          }
          v47 = (uint64_t *)re::TypeMemberCollection::TypeMemberCollection((uint64_t)&__dst, *(_QWORD *)this, v40);
          re::TypeMemberCollection::operator[](v47, 0, (uint64_t)v208);
          v48 = &a4[*(unsigned int *)(*(_QWORD *)&v208[16] + 24)];
          re::TypeRegistry::typeInfo(*(_QWORD **)v208, **(_QWORD **)&v208[16], &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v207, (uint64_t)&__dst.n128_i64[1]);
          if (this == a6)
            goto LABEL_78;
          if (*(_QWORD *)this == *(_QWORD *)a6)
          {
            v162 = **((_QWORD **)this + 2);
            v163 = *((_QWORD *)a6 + 2);
            v164 = *(_QWORD *)v163;
            if ((unsigned __int16)v162 == (unsigned __int16)*(_QWORD *)v163
              && WORD1(v162) == WORD1(v164)
              && ((v164 ^ v162) & 0xFFFFFF00000000) == 0)
            {
              goto LABEL_78;
            }
          }
          else
          {
            if (re::areSameTranslatedVersion(this, a6, v49))
            {
LABEL_78:
              if (*((_BYTE *)a1 + 64))
                return 0;
              v35 = (BOOL (*)(uint64_t, const char *, const re::TypeInfo *, uint64_t, re *, re::TypeInfo *, int))*((_QWORD *)*a1 + 9);
              v50 = (re *)v207;
              v51 = v207;
LABEL_282:
              v166 = a1;
              v167 = a2;
              v168 = a3;
              v169 = v48;
              return ((uint64_t (*)(re::internal **, const char *, const re::TypeInfo *, unsigned __int8 *, re *, uint64_t *, uint64_t))v35)(v166, v167, v168, v169, v50, v51, a7);
            }
            v163 = *((_QWORD *)a6 + 2);
          }
          if (*(_DWORD *)(v163 + 88) != 1)
            goto LABEL_283;
          re::TypeMemberCollection::TypeMemberCollection((uint64_t)&v200, *(_QWORD *)a6, v163);
          re::TypeMemberCollection::operator[]((uint64_t *)&v200, 0, (uint64_t)v205);
          re::TypeRegistry::typeInfo(v205[0], *v205[2], &__dst);
          re::TypeInfo::TypeInfo((uint64_t)v206, (uint64_t)&__dst.n128_i64[1]);
          if (*((_BYTE *)a1 + 64))
            return 0;
          v35 = (BOOL (*)(uint64_t, const char *, const re::TypeInfo *, uint64_t, re *, re::TypeInfo *, int))*((_QWORD *)*a1 + 9);
          v50 = (re *)v207;
          v51 = v206;
          goto LABEL_282;
        }
        v60 = (uint64_t)a1;
        v61 = a2;
        v58 = this;
        v59 = this;
      }
      re::serializeDynamicString<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(v60, v61, v38, 0, v58, v59, 1);
      return *((_BYTE *)a1 + 64) == 0;
    case 9:
      v193 = re::TypeInfo::name(this)[1];
      v46 = "Pointer type (\"%s\") needs to be handled explicitly by the serializer.";
      goto LABEL_74;
    default:
      LOBYTE(v193) = *((_BYTE *)this + 12);
      v46 = "Invalid type category. Value = %d";
      goto LABEL_74;
  }
}

BOOL re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(uint64_t a1, const char *a2, float *a3)
{
  int v3;
  float v6;
  char *v7;
  const char *v8;
  double v9;
  uint64_t v10;
  const char *v12;
  const char *v13;

  v13 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v13);
    v6 = *a3;
    v7 = *(char **)(a1 + 168);
    if (fabsf(v6) == INFINITY)
    {
      v8 = "-Infinity";
      if (v6 > 0.0)
        v8 = "Infinity";
      v12 = v8;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(v7, &v12);
    }
    else
    {
      v9 = v6;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(*(char **)(a1 + 168));
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteDouble((uint64_t)v7, v9);
    }
    v10 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v10 - 16);
  }
  return v3 == 0;
}

BOOL re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(uint64_t a1, const char *a2, double *a3)
{
  int v3;
  double v6;
  char *v7;
  const char *v8;
  uint64_t v9;
  const char *v11;
  const char *v12;

  v12 = a2;
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (!*(_BYTE *)(a1 + 40))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 44) & 0x20) != 0)
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(*(char **)(a1 + 168), &v12);
    v6 = *a3;
    v7 = *(char **)(a1 + 168);
    if (fabs(v6) == INFINITY)
    {
      v8 = "-Infinity";
      if (v6 > 0.0)
        v8 = "Infinity";
      v11 = v8;
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Key(v7, &v11);
    }
    else
    {
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::Prefix(*(char **)(a1 + 168));
      rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>::WriteDouble((uint64_t)v7, v6);
    }
    v9 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v9 - 16);
  }
  return v3 == 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unint64_t *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t **v29;
  unint64_t **v30;
  unint64_t *v31;
  unint64_t *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unint64_t **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unint64_t *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*,false>(v47, &v47[2 * v45], v28, 1);
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unsigned int *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int **v29;
  unsigned int **v30;
  unsigned int *v31;
  unsigned int *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unsigned int **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unsigned int *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*,false>(v47, &v47[2 * v45], v28, 1);
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__base_10_u32[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unsigned __int16 *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unsigned __int16 **v29;
  unsigned __int16 **v30;
  unsigned __int16 *v31;
  unsigned __int16 *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unsigned __int16 **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unsigned __int16 *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*,false>(v47, &v47[2 * v45], v28, 1);
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__base_10_u32[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, unsigned __int8 *, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __n128 v26;
  unint64_t v27;
  uint64_t v28;
  unsigned __int8 **v29;
  unsigned __int8 **v30;
  unsigned __int8 *v31;
  unsigned __int8 *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE v39[16];
  uint64_t v40;
  _BYTE v41[32];
  _BYTE v42[32];
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unsigned __int8 **v47;
  __n128 v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v43),
        re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44),
        v42[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v42))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v44);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v43);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v44);
  re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v42);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, unsigned __int8 *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v20)
      return result;
    v22 = (*(uint64_t (**)(uint64_t))(v40 + 88))(a4);
    if (v22)
    {
      v47 = 0;
      v44 = 0;
      v45 = 0;
      v46 = 0;
      v43 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v43, v22);
      ++v46;
      v23 = (*(uint64_t (**)(uint64_t, uint64_t))(v40 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v40 + 120))())
      {
        do
        {
          v24 = (*(uint64_t (**)(uint64_t))(v40 + 128))(v23);
          v25 = (*(uint64_t (**)(uint64_t))(v40 + 136))(v23);
          v48[0].n128_u64[0] = v24;
          v48[0].n128_u64[1] = v25;
          v26 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v43, v48);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v40 + 120))(v23, v26) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v40 + 144))(v23, v17);
      v27 = 126 - 2 * __clz(v45);
      if (v45)
        v28 = v27;
      else
        v28 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*,false>(v47, &v47[2 * v45], v28, 1);
      if (v45)
      {
        v29 = v47;
        v30 = &v47[2 * v45];
        do
        {
          v31 = *v29;
          v32 = v29[1];
          v29 += 2;
          *(_BYTE *)std::__itoa::__base_10_u32[abi:nn180100](v48, *v31) = 0;
          v19(a1, v48, 0, v32, v42, v41, 0);
        }
        while (v29 != v30);
      }
      if (v43)
      {
        if (v47)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
      }
    }
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v33 = re::TypeInfo::name((re::TypeInfo *)v42);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, uint64_t *, _BYTE *, _BYTE *, _QWORD);
  _anonymous_namespace_ *v20;
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t **v30;
  uint64_t **v31;
  unint64_t v32;
  __n128 *v33;
  uint64_t *v34;
  unsigned int v35;
  int64_t v36;
  _WORD *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  uint64_t **v52;
  __n128 v53[2];
  _QWORD v54[2];

  v54[0] = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, uint64_t *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    v21 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
    if (v23)
    {
      v52 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v48 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v23);
      ++v51;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v45 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v24);
          v53[0].n128_u64[0] = v25;
          v53[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, v53);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v24, v17);
      v28 = 126 - 2 * __clz(v50);
      if (v50)
        v29 = v28;
      else
        v29 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*,false>(v52, (__n128 *)&v52[2 * v50], v29, 1);
      if (v50)
      {
        v30 = v52;
        v31 = &v52[2 * v50];
        do
        {
          v32 = **v30;
          if ((v32 & 0x8000000000000000) != 0)
          {
            v53[0].n128_u8[0] = 45;
            v32 = -(uint64_t)v32;
            v33 = (__n128 *)((char *)v53[0].n128_u64 + 1);
          }
          else
          {
            v33 = v53;
          }
          v34 = v30[1];
          if ((char *)v54 - (char *)v33 > 19
            || (v35 = (1233 * (64 - __clz(v32 | 1))) >> 12,
                v36 = v35 - (std::__itoa::__pow10_64[v35] > v32) + 1,
                v37 = v54,
                (char *)v54 - (char *)v33 >= v36))
          {
            v37 = std::__itoa::__traits_base<unsigned long long,void>::__convert[abi:nn180100](v33, v32);
          }
          *(_BYTE *)v37 = 0;
          v19(a1, v53, 0, v34, v47, v46, 0);
          v30 += 2;
        }
        while (v30 != v31);
      }
      if (v48)
      {
        if (v52)
          (*(void (**)(void))(*(_QWORD *)v48 + 40))();
      }
      v20 = (_anonymous_namespace_ *)(a1 + 24);
    }
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v20);
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v38 = re::TypeInfo::name((re::TypeInfo *)v47);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, int *, _BYTE *, _BYTE *, _QWORD);
  _anonymous_namespace_ *v20;
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  int **v30;
  int **v31;
  unsigned int v32;
  __n128 *v33;
  int *v34;
  unsigned int v35;
  int64_t v36;
  _WORD *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  int **v52;
  __n128 v53[2];
  _QWORD v54[2];

  v54[0] = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, int *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    v21 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
    if (v23)
    {
      v52 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v48 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v23);
      ++v51;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v45 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v24);
          v53[0].n128_u64[0] = v25;
          v53[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, v53);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v24, v17);
      v28 = 126 - 2 * __clz(v50);
      if (v50)
        v29 = v28;
      else
        v29 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*,false>(v52, (__n128 *)&v52[2 * v50], v29, 1);
      if (v50)
      {
        v30 = v52;
        v31 = &v52[2 * v50];
        do
        {
          v32 = **v30;
          if ((v32 & 0x80000000) != 0)
          {
            v53[0].n128_u8[0] = 45;
            v32 = -v32;
            v33 = (__n128 *)((char *)v53[0].n128_u64 + 1);
          }
          else
          {
            v33 = v53;
          }
          v34 = v30[1];
          if ((char *)v54 - (char *)v33 > 9
            || (v35 = (1233 * (32 - __clz(v32 | 1))) >> 12,
                v36 = (((__PAIR64__(v35, v32) - std::__itoa::__pow10_32[v35]) >> 32) + 1),
                v37 = v54,
                (char *)v54 - (char *)v33 >= v36))
          {
            v37 = std::__itoa::__base_10_u32[abi:nn180100](v33, v32);
          }
          *(_BYTE *)v37 = 0;
          v19(a1, v53, 0, v34, v47, v46, 0);
          v30 += 2;
        }
        while (v30 != v31);
      }
      if (v48)
      {
        if (v52)
          (*(void (**)(void))(*(_QWORD *)v48 + 40))();
      }
      v20 = (_anonymous_namespace_ *)(a1 + 24);
    }
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v20);
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v38 = re::TypeInfo::name((re::TypeInfo *)v47);
  return 0;
}

BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(uint64_t, __n128 *, _QWORD, __int16 *, _BYTE *, _BYTE *, _QWORD);
  _anonymous_namespace_ *v20;
  _BOOL4 v21;
  _BOOL8 result;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __n128 v27;
  unint64_t v28;
  uint64_t v29;
  __int16 **v30;
  __int16 **v31;
  unsigned int v32;
  __n128 *v33;
  __int16 *v34;
  unsigned int v35;
  int64_t v36;
  _WORD *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  __int16 **v52;
  __n128 v53[2];
  _QWORD v54[2];

  v54[0] = *MEMORY[0x24BDAC8D0];
  if (this == a6)
    goto LABEL_13;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_13;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_13;
  }
  if (*((unsigned __int8 *)this + 12) != *((unsigned __int8 *)a6 + 12)
    || (re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v48),
        re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49),
        v47[12] != 1)
    || !re::TypeInfo::isInteger((re::TypeInfo *)v47))
  {
    return 0;
  }
LABEL_13:
  if (a7)
    return *(_BYTE *)(a1 + 64) == 0;
  v17 = *(_QWORD *)(a1 + 56);
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
  re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
  v18 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
  if (v18)
  {
    v19 = (void (*)(uint64_t, __n128 *, _QWORD, __int16 *, _BYTE *, _BYTE *, _QWORD))v18;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    v21 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
    result = 0;
    if (!v21)
      return result;
    v23 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
    if (v23)
    {
      v52 = 0;
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v48 = v17;
      re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v23);
      ++v51;
      v24 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v17);
      if ((*(unsigned int (**)(void))(v45 + 120))())
      {
        do
        {
          v25 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v24);
          v26 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v24);
          v53[0].n128_u64[0] = v25;
          v53[0].n128_u64[1] = v26;
          v27 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, v53);
        }
        while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v24, v27) & 1) != 0);
      }
      (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v24, v17);
      v28 = 126 - 2 * __clz(v50);
      if (v50)
        v29 = v28;
      else
        v29 = 0;
      std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*,false>(v52, &v52[2 * v50], v29, 1);
      if (v50)
      {
        v30 = v52;
        v31 = &v52[2 * v50];
        do
        {
          v32 = **v30;
          if ((v32 & 0x80000000) != 0)
          {
            v53[0].n128_u8[0] = 45;
            v32 = -v32;
            v33 = (__n128 *)((char *)v53[0].n128_u64 + 1);
          }
          else
          {
            v33 = v53;
          }
          v34 = v30[1];
          if ((char *)v54 - (char *)v33 > 9
            || (v35 = (1233 * (32 - __clz(v32 | 1))) >> 12,
                v36 = (((__PAIR64__(v35, v32) - std::__itoa::__pow10_32[v35]) >> 32) + 1),
                v37 = v54,
                (char *)v54 - (char *)v33 >= v36))
          {
            v37 = std::__itoa::__base_10_u32[abi:nn180100](v33, v32);
          }
          *(_BYTE *)v37 = 0;
          v19(a1, v53, 0, v34, v47, v46, 0);
          v30 += 2;
        }
        while (v30 != v31);
      }
      if (v48)
      {
        if (v52)
          (*(void (**)(void))(*(_QWORD *)v48 + 40))();
      }
      v20 = (_anonymous_namespace_ *)(a1 + 24);
    }
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject(v20);
    return *(_BYTE *)(a1 + 64) == 0;
  }
  v38 = re::TypeInfo::name((re::TypeInfo *)v47);
  return 0;
}

BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v24;
  _BOOL8 result;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __n128 v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __n128 v43;
  char v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  uint64_t *v52;

  if (this == a6)
    goto LABEL_14;
  v13 = *(_QWORD **)this;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v14 = (uint64_t *)*((_QWORD *)a6 + 2);
    v16 = *v14;
    if ((unsigned __int16)v15 != (unsigned __int16)*v14)
      goto LABEL_10;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v21 = *(_QWORD *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
      re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
      v22 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
      if (!v22)
      {
        v37 = re::TypeInfo::name((re::TypeInfo *)v47);
        return 0;
      }
      v23 = (void (*)(uint64_t, uint64_t, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v22;
      v24 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
      result = 0;
      if (!v24)
        return result;
      v26 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
      if (v26)
      {
        v52 = 0;
        v49 = 0;
        v50 = 0;
        v51 = 0;
        v48 = v21;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v26);
        ++v51;
        v27 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v21);
        if ((*(unsigned int (**)(void))(v45 + 120))())
        {
          do
          {
            v28 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v27);
            v29 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v27);
            v43.n128_u64[0] = v28;
            v43.n128_u64[1] = v29;
            v30 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, &v43);
          }
          while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v27, v30) & 1) != 0);
        }
        (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v27, v21);
        v31 = 126 - 2 * __clz(v50);
        if (v50)
          v32 = v31;
        else
          v32 = 0;
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*,false>(v52, &v52[2 * v50], v32, 1);
        if (v50)
        {
          v33 = v52;
          v34 = &v52[2 * v50];
          do
          {
            v35 = *v33;
            if ((*(_BYTE *)(*v33 + 8) & 1) != 0)
              v36 = *(_QWORD *)(v35 + 16);
            else
              v36 = v35 + 9;
            v23(a1, v36, 0, v33[1], v47, v46, 0);
            v33 += 2;
          }
          while (v33 != v34);
        }
        if (v48)
        {
          if (v52)
            (*(void (**)(void))(*(_QWORD *)v48 + 40))();
        }
      }
      re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_14;
  v13 = *(_QWORD **)a6;
  v14 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v13, v14[9], &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  v19 = re::TypeInfo::name((re::TypeInfo *)v47);
  if ((unint64_t)*v19 >> 1 == 0x22C6ED80D0CLL)
  {
    v20 = (char *)v19[1];
    if (v20 == "StringID" || !strcmp(v20, "StringID"))
      goto LABEL_14;
  }
  return 0;
}

BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  _QWORD *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v24;
  _BOOL8 result;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __n128 v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __n128 v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[32];
  _BYTE v47[32];
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  uint64_t *v52;

  if (this == a6)
    goto LABEL_14;
  v13 = *(_QWORD **)this;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)this + 2);
    v14 = (uint64_t *)*((_QWORD *)a6 + 2);
    v16 = *v14;
    if ((unsigned __int16)v15 != (unsigned __int16)*v14)
      goto LABEL_10;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_10;
LABEL_14:
    if (!a7)
    {
      v21 = *(_QWORD *)(a1 + 56);
      re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v48);
      re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v49);
      re::TypeInfo::TypeInfo((uint64_t)v44, (uint64_t)this);
      v22 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v47);
      if (!v22)
      {
        v37 = re::TypeInfo::name((re::TypeInfo *)v47);
        return 0;
      }
      v23 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v22;
      v24 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0);
      result = 0;
      if (!v24)
        return result;
      v26 = (*(uint64_t (**)(uint64_t))(v45 + 88))(a4);
      if (v26)
      {
        v52 = 0;
        v49 = 0;
        v50 = 0;
        v51 = 0;
        v48 = v21;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity(&v48, v26);
        ++v51;
        v27 = (*(uint64_t (**)(uint64_t, uint64_t))(v45 + 112))(a4, v21);
        if ((*(unsigned int (**)(void))(v45 + 120))())
        {
          do
          {
            v28 = (*(uint64_t (**)(uint64_t))(v45 + 128))(v27);
            v29 = (*(uint64_t (**)(uint64_t))(v45 + 136))(v27);
            v43.n128_u64[0] = v28;
            v43.n128_u64[1] = v29;
            v30 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&v48, &v43);
          }
          while (((*(uint64_t (**)(uint64_t, __n128))(v45 + 120))(v27, v30) & 1) != 0);
        }
        (*(void (**)(uint64_t, uint64_t))(v45 + 144))(v27, v21);
        v31 = 126 - 2 * __clz(v50);
        if (v50)
          v32 = v31;
        else
          v32 = 0;
        std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*,false>((uint64_t)v52, (__n128 *)&v52[2 * v50], v32, 1);
        if (v50)
        {
          v33 = v52;
          v34 = &v52[2 * v50];
          do
          {
            v36 = *v33;
            v35 = v33[1];
            v33 += 2;
            v23(a1, *(_QWORD *)(v36 + 8), 0, v35, v47, v46, 0);
          }
          while (v33 != v34);
        }
        if (v48)
        {
          if (v52)
            (*(void (**)(void))(*(_QWORD *)v48 + 40))();
        }
      }
      re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    }
    return *(_BYTE *)(a1 + 64) == 0;
  }
  if (re::areSameTranslatedVersion(this, a6, a3))
    goto LABEL_14;
  v13 = *(_QWORD **)a6;
  v14 = (uint64_t *)*((_QWORD *)a6 + 2);
LABEL_10:
  re::TypeRegistry::typeInfo(v13, v14[9], &v48);
  re::TypeInfo::TypeInfo((uint64_t)v47, (uint64_t)&v49);
  v19 = re::TypeInfo::name((re::TypeInfo *)v47);
  if ((unint64_t)*v19 >> 1 == 0x134375A94D9F7110)
  {
    v20 = (char *)v19[1];
    if (v20 == "DynamicString" || !strcmp(v20, "DynamicString"))
      goto LABEL_14;
  }
  return 0;
}

void std::sort[abi:nn180100]<re::Pair<void const*,void *,true> *,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1}>(char *a1, char *a2, uint64_t (*a3)(uint64_t, uint64_t))
{
  unint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(uint64_t, uint64_t);

  v3 = 126 - 2 * __clz((a2 - a1) >> 4);
  v5 = a3;
  if (a2 == a1)
    v4 = 0;
  else
    v4 = v3;
  std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(a1, a2, &v5, v4, 1);
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*,false>(unint64_t **a1, unint64_t **a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t **v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t **v18;
  unint64_t **v19;
  unint64_t *v20;
  unint64_t *v21;
  __int128 *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t *v25;
  BOOL v26;
  unint64_t *v27;
  unint64_t **v28;
  _OWORD *v29;
  unint64_t *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t *v34;
  __int128 *v35;
  _QWORD *v36;
  unint64_t **v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t **v42;
  unint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unint64_t **v52;
  unint64_t v53;
  unint64_t v54;
  BOOL v55;
  unint64_t **v56;
  unint64_t *v57;
  unint64_t *v58;
  unint64_t **v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  unint64_t **v77;
  unint64_t *v78;
  unint64_t *v79;
  unint64_t **v80;
  unint64_t *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>(uint64_t a1, unint64_t **a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  unint64_t **v8;
  unint64_t **v9;
  uint64_t v10;
  int v11;
  unint64_t *v12;
  unint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t **v16;

  v4 = ((uint64_t)a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 2);
      if (**(a2 - 2) < **(_QWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32), (_OWORD *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = (unint64_t **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned long long const*,void *,true> const&,re::Pair<unsigned long long const*,void *,true> const&)#1} &,re::Pair<unsigned long long const*,void *,true>*>((__int128 *)a1, (unint64_t **)(a1 + 16), (unint64_t **)(a1 + 32));
      v9 = (unint64_t **)(a1 + 48);
      if ((unint64_t **)(a1 + 48) == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_QWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unint64_t **)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (unint64_t **)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*,false>(unsigned int **a1, unsigned int **a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int **v12;
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int **v18;
  unsigned int **v19;
  unsigned int *v20;
  unsigned int *v21;
  __int128 *v22;
  unsigned int v23;
  unsigned int *v24;
  unsigned int *v25;
  BOOL v26;
  unsigned int *v27;
  unsigned int **v28;
  _OWORD *v29;
  unsigned int *v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int *v33;
  unsigned int *v34;
  __int128 *v35;
  _DWORD *v36;
  unsigned int **v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  unsigned int **v42;
  unsigned int *v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unsigned int **v52;
  unsigned int v53;
  unsigned int v54;
  BOOL v55;
  unsigned int **v56;
  unsigned int *v57;
  unsigned int *v58;
  unsigned int **v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _DWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  unsigned int **v77;
  unsigned int *v78;
  unsigned int *v79;
  unsigned int **v80;
  unsigned int *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>(uint64_t a1, unsigned int **a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  unsigned int **v8;
  unsigned int **v9;
  uint64_t v10;
  int v11;
  unsigned int *v12;
  unsigned int *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int **v16;

  v4 = ((uint64_t)a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 2);
      if (**(a2 - 2) < **(_DWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32), (_OWORD *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = (unsigned int **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned int const*,void *,true> const&,re::Pair<unsigned int const*,void *,true> const&)#1} &,re::Pair<unsigned int const*,void *,true>*>((__int128 *)a1, (unsigned int **)(a1 + 16), (unsigned int **)(a1 + 32));
      v9 = (unsigned int **)(a1 + 48);
      if ((unsigned int **)(a1 + 48) == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_DWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unsigned int **)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (unsigned int **)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*,false>(unsigned __int16 **a1, unsigned __int16 **a2, uint64_t a3, char a4)
{
  unsigned __int16 **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int16 **v12;
  unsigned __int16 *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int16 *v16;
  unsigned int v17;
  unsigned __int16 **v18;
  unsigned __int16 **v19;
  unsigned __int16 *v20;
  unsigned __int16 *v21;
  unsigned __int16 **v22;
  unsigned int v23;
  unsigned __int16 *v24;
  unsigned __int16 *v25;
  BOOL v26;
  unsigned __int16 *v27;
  unsigned __int16 **v28;
  unsigned __int16 **v29;
  unsigned __int16 *v30;
  unsigned __int16 *v31;
  unsigned int v32;
  unsigned __int16 *v33;
  unsigned __int16 *v34;
  unsigned __int16 **v35;
  unsigned __int16 *v36;
  unsigned __int16 **v37;
  BOOL v39;
  uint64_t v40;
  unsigned __int16 **v41;
  unsigned __int16 **v42;
  unsigned __int16 *v43;
  unsigned __int16 *v44;
  uint64_t v45;
  unsigned int v46;
  unsigned __int16 **v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unsigned __int16 **v52;
  unsigned int v53;
  unsigned int v54;
  BOOL v55;
  unsigned __int16 **v56;
  unsigned __int16 *v57;
  unsigned __int16 *v58;
  unsigned __int16 **v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int16 **v67;
  unsigned __int16 **v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unsigned __int16 **v73;
  unsigned __int16 *v74;
  unsigned __int16 *v75;
  unsigned __int16 **v76;
  unsigned __int16 **v78;
  unsigned __int16 *v79;
  unsigned __int16 *v80;
  unsigned __int16 **v81;
  unsigned __int16 *v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(unsigned __int16 **a1, unsigned __int16 **a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned __int16 **v6;
  __int128 v7;
  unsigned __int16 **v8;
  unsigned __int16 **v9;
  uint64_t v10;
  int v11;
  unsigned __int16 *v12;
  unsigned __int16 *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned __int16 **v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3, (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned short const*,void *,true> const&,re::Pair<unsigned short const*,void *,true> const&)#1} &,re::Pair<unsigned short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(unsigned __int16 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unsigned __int16 **)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*,false>(unsigned __int8 **a1, unsigned __int8 **a2, uint64_t a3, char a4)
{
  unsigned __int8 **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int8 **v12;
  unsigned __int8 *v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unsigned int v17;
  unsigned __int8 **v18;
  unsigned __int8 **v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  unsigned __int8 **v22;
  unsigned int v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  BOOL v26;
  unsigned __int8 *v27;
  unsigned __int8 **v28;
  unsigned __int8 **v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  unsigned int v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  unsigned __int8 **v35;
  unsigned __int8 *v36;
  unsigned __int8 **v37;
  BOOL v39;
  uint64_t v40;
  unsigned __int8 **v41;
  unsigned __int8 **v42;
  unsigned __int8 *v43;
  unsigned __int8 *v44;
  uint64_t v45;
  unsigned int v46;
  unsigned __int8 **v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unsigned __int8 **v52;
  unsigned int v53;
  unsigned int v54;
  BOOL v55;
  unsigned __int8 **v56;
  unsigned __int8 *v57;
  unsigned __int8 *v58;
  unsigned __int8 **v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  BOOL v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int8 **v67;
  unsigned __int8 **v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unsigned __int8 **v73;
  unsigned __int8 *v74;
  unsigned __int8 *v75;
  unsigned __int8 **v76;
  unsigned __int8 **v78;
  unsigned __int8 *v79;
  unsigned __int8 *v80;
  unsigned __int8 **v81;
  unsigned __int8 *v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(unsigned __int8 **a1, unsigned __int8 **a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned __int8 **v6;
  __int128 v7;
  unsigned __int8 **v8;
  unsigned __int8 **v9;
  uint64_t v10;
  int v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unsigned int v15;
  unsigned __int8 **v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3, (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,unsigned char>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<unsigned char const*,void *,true> const&,re::Pair<unsigned char const*,void *,true> const&)#1} &,re::Pair<unsigned char const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(unsigned __int8 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (unsigned __int8 **)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*,false>(uint64_t **a1, __n128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t **v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t **v18;
  __n128 *v19;
  _QWORD *v20;
  _QWORD *v21;
  __int128 *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  BOOL v26;
  _QWORD *v27;
  _QWORD **v28;
  __int128 *v29;
  _QWORD *v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  __int128 *v35;
  _QWORD *v36;
  __n128 *v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  __n128 *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  uint64_t **v52;
  uint64_t v53;
  uint64_t v54;
  BOOL v55;
  uint64_t **v56;
  uint64_t *v57;
  uint64_t *v58;
  uint64_t **v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  __n128 *v76;
  uint64_t *v77;
  uint64_t *v78;
  __n128 *v79;
  uint64_t *v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  _QWORD **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      if (**(_QWORD **)(a2 - 16) < **(_QWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32), (_OWORD *)(a2 - 16));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      v8 = (_QWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,long long>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<long long const*,void *,true> const&,re::Pair<long long const*,void *,true> const&)#1} &,re::Pair<long long const*,void *,true>*>((__int128 *)a1, (uint64_t **)(a1 + 16), (uint64_t **)(a1 + 32));
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(_QWORD **)v9;
    if (**(_QWORD **)v9 < **v8)
    {
      v13 = *(_QWORD *)(v9 + 8);
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_QWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (_QWORD *)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (_QWORD *)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (_QWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*,false>(int **a1, __n128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int **v12;
  int *v13;
  int v14;
  uint64_t v15;
  int *v16;
  int v17;
  int **v18;
  __n128 *v19;
  _DWORD *v20;
  _DWORD *v21;
  __int128 *v22;
  int v23;
  int *v24;
  int *v25;
  BOOL v26;
  _DWORD *v27;
  _DWORD **v28;
  __int128 *v29;
  _DWORD *v30;
  int *v31;
  int v32;
  int *v33;
  int *v34;
  __int128 *v35;
  _DWORD *v36;
  __n128 *v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  __n128 *v42;
  _DWORD *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  int **v52;
  int v53;
  int v54;
  BOOL v55;
  int **v56;
  int *v57;
  int *v58;
  int **v59;
  uint64_t v60;
  int v61;
  int v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _DWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  __n128 *v76;
  int *v77;
  int *v78;
  __n128 *v79;
  int *v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  _DWORD **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  _QWORD *v16;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      if (**(_DWORD **)(a2 - 16) < **(_DWORD **)a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a1 + 32), (_OWORD *)(a2 - 16));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      v8 = (_DWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,int>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<int const*,void *,true> const&,re::Pair<int const*,void *,true> const&)#1} &,re::Pair<int const*,void *,true>*>((__int128 *)a1, (int **)(a1 + 16), (int **)(a1 + 32));
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(_DWORD **)v9;
    if (**(_DWORD **)v9 < **v8)
    {
      v13 = *(_QWORD *)(v9 + 8);
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_DWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (_QWORD *)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (_QWORD *)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (_DWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*,false>(__int16 **a1, __int16 **a2, uint64_t a3, char a4)
{
  __int16 **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __int16 **v12;
  __int16 *v13;
  int v14;
  uint64_t v15;
  __int16 *v16;
  int v17;
  __int16 **v18;
  __int16 **v19;
  __int16 *v20;
  __int16 *v21;
  __int16 **v22;
  int v23;
  __int16 *v24;
  __int16 *v25;
  BOOL v26;
  __int16 *v27;
  __int16 **v28;
  __int16 **v29;
  __int16 *v30;
  __int16 *v31;
  int v32;
  __int16 *v33;
  __int16 *v34;
  __int16 **v35;
  __int16 *v36;
  __int16 **v37;
  BOOL v39;
  uint64_t v40;
  __int16 **v41;
  __int16 **v42;
  __int16 *v43;
  __int16 *v44;
  uint64_t v45;
  int v46;
  __int16 **v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  __int16 **v52;
  int v53;
  int v54;
  BOOL v55;
  __int16 **v56;
  __int16 *v57;
  __int16 *v58;
  __int16 **v59;
  uint64_t v60;
  int v61;
  int v62;
  BOOL v63;
  uint64_t v64;
  uint64_t v65;
  __int16 **v66;
  __int16 **v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  __int16 **v72;
  __int16 *v73;
  __int16 *v74;
  __int16 **v75;
  __int16 **v76;
  __int16 *v77;
  __int16 *v78;
  __int16 **v79;
  __int16 *v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(__int16 **a1, __int16 **a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int16 **v6;
  __int128 v7;
  __int16 **v8;
  __int16 **v9;
  uint64_t v10;
  int v11;
  __int16 *v12;
  __int16 *v13;
  uint64_t v14;
  int v15;
  __int16 **v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (**(a2 - 2) < **a1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (__n128 *)a1 + 2, (__n128 *)a1 + 3, (__n128 *)a2 - 1);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithInteger<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>,short>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<short const*,void *,true> const&,re::Pair<short const*,void *,true> const&)#1} &,re::Pair<short const*,void *,true>*>(a1, a1 + 2, (_OWORD *)a1 + 2);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (**v9 < **v8)
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(__int16 **)((char *)a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >= v15)
        {
          v16 = (__int16 **)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*,false>(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  BOOL v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t *v44;
  int64_t v45;
  int64_t v46;
  int64_t v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  int64_t v52;
  uint64_t v53;
  int v54;
  BOOL v55;
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  BOOL v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t *v87;
  char v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t *v91;
  int64_t v92;
  uint64_t *v93;
  uint64_t *v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t *v6;
  __int128 v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t *v16;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = a2 - 2;
      if (re::DynamicString::operator<(*(a2 - 2), *a1))
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *(_OWORD *)v6 = v7;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      v8 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithDynamicString<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::DynamicString const*,void *,true> const&,re::Pair<re::DynamicString const*,void *,true> const&)#1} &,re::Pair<re::DynamicString const*,void *,true>*>(a1, a1 + 2, a1 + 4);
      v9 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *v9;
    if (re::DynamicString::operator<(*v9, *v8))
    {
      v13 = v9[1];
      v14 = v10;
      while (1)
      {
        v15 = (char *)a1 + v14;
        *(_OWORD *)((char *)a1 + v14 + 48) = *(_OWORD *)((char *)a1 + v14 + 32);
        if (v14 == -32)
          break;
        v14 -= 16;
        if ((re::DynamicString::operator<(v12, *((_QWORD *)v15 + 2)) & 1) == 0)
        {
          v16 = (uint64_t *)((char *)a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 2 == a2;
    }
    v8 = v9;
    v10 += 16;
    v9 += 2;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*,false>(uint64_t a1, __n128 *a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __int128 *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  __int128 *v19;
  _QWORD *v20;
  _QWORD *v21;
  __int128 *v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  BOOL v26;
  _QWORD *v27;
  unint64_t v28;
  __int128 *v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  __int128 *v35;
  _QWORD *v36;
  __n128 *v37;
  BOOL v39;
  uint64_t v40;
  unint64_t v41;
  __n128 *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  _QWORD *v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  uint64_t v51;
  unint64_t **v52;
  unint64_t v53;
  unint64_t v54;
  BOOL v55;
  unint64_t **v56;
  unint64_t *v57;
  unint64_t *v58;
  unint64_t **v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _OWORD *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  _OWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  _OWORD *v75;
  uint64_t v77;
  _QWORD *v78;
  uint64_t v79;
  uint64_t v80;
  _QWORD *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  _QWORD **v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _QWORD *v16;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      if (**(_QWORD **)(a2 - 16) >> 1 < **(_QWORD **)a1 >> 1)
      {
        v7 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (_QWORD **)(a1 + 16), (_QWORD **)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (__n128 *)(a1 + 16), (__n128 *)(a1 + 32), (__n128 *)(a2 - 16));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (__n128 *)(a1 + 16), (__n128 *)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      v8 = (_QWORD **)(a1 + 32);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::internal::serializeDictionaryWithStringID<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<re::StringID const*,void *,true> const&,re::Pair<re::StringID const*,void *,true> const&)#1} &,re::Pair<re::StringID const*,void *,true>*>((__int128 *)a1, (_QWORD **)(a1 + 16), (_QWORD **)(a1 + 32));
      v9 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v10 = 0;
      v11 = 0;
      break;
  }
  while (1)
  {
    v12 = *(_QWORD **)v9;
    if (**(_QWORD **)v9 >> 1 < **v8 >> 1)
    {
      v13 = *(_QWORD *)(v9 + 8);
      v14 = v10;
      while (1)
      {
        *(_OWORD *)(a1 + v14 + 48) = *(_OWORD *)(a1 + v14 + 32);
        if (v14 == -32)
          break;
        v15 = **(_QWORD **)(a1 + v14 + 16);
        v14 -= 16;
        if (*v12 >> 1 >= v15 >> 1)
        {
          v16 = (_QWORD *)(a1 + v14 + 48);
          goto LABEL_12;
        }
      }
      v16 = (_QWORD *)a1;
LABEL_12:
      *v16 = v12;
      v16[1] = v13;
      if (++v11 == 8)
        return v9 + 16 == a2;
    }
    v8 = (_QWORD **)v9;
    v10 += 16;
    v9 += 16;
    if (v9 == a2)
      return 1;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(char *a1, char *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  char *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  BOOL v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  char *v36;
  uint64_t v37;
  char *v38;
  BOOL v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  char *v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  char *v73;
  uint64_t v74;
  uint64_t *v75;
  BOOL v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  char *v80;
  char *v81;
  char v82;
  char *v83;
  unint64_t v84;
  char *v85;
  char *v86;
  char *v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  int64_t v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(char *a1, char *a2, uint64_t (**a3)(uint64_t, _QWORD))
{
  uint64_t v6;
  _BOOL8 result;
  char *v8;
  __int128 v9;
  char *v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  char *v17;
  __int128 v18;

  v6 = (a2 - a1) >> 4;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v8 = a2 - 16;
      if ((*a3)(*((_QWORD *)a2 - 2), *(_QWORD *)a1))
      {
        v9 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v8;
        *(_OWORD *)v8 = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a2 - 2, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, (_QWORD *)a2 - 2, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, (_QWORD *)a1 + 6, (_QWORD *)a2 - 2, a3);
      return 1;
    default:
      v10 = a1 + 32;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(re::Serializer<re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, a3);
      v11 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(*(_QWORD *)v11, *(_QWORD *)v10))
    {
      v18 = *(_OWORD *)v11;
      v14 = *(_QWORD *)v11;
      v15 = v12;
      while (1)
      {
        *(_OWORD *)&a1[v15 + 48] = *(_OWORD *)&a1[v15 + 32];
        if (v15 == -32)
          break;
        v16 = (*a3)(v14, *(_QWORD *)&a1[v15 + 16]);
        v15 -= 16;
        if ((v16 & 1) == 0)
        {
          v17 = &a1[v15 + 48];
          goto LABEL_12;
        }
      }
      v17 = a1;
LABEL_12:
      *(_OWORD *)v17 = v18;
      if (++v13 == 8)
        return v11 + 16 == a2;
    }
    v10 = v11;
    v12 += 16;
    v11 += 16;
    if (v11 == a2)
      return 1;
  }
}

BOOL re::serializeDynamicString<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t *v17;
  char *v18;
  _BOOL8 result;
  _anonymous_namespace_ *v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  if (this == a6)
    goto LABEL_14;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_14;
  }
  v17 = re::TypeInfo::name(a6);
  if ((unint64_t)*v17 >> 1 != 0x22C6ED80D0CLL
    || (v18 = (char *)v17[1], v18 != "StringID") && strcmp(v18, "StringID"))
  {
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v24 = 0;
    result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, &v24);
    if (!(_DWORD)result)
      return result;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_27;
  }
  v21 = *(_QWORD *)(a4 + 8);
  if ((v21 & 1) != 0)
    v22 = v21 >> 1;
  else
    v22 = v21 >> 1;
  v24 = v22;
  result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, &v24);
  if ((_DWORD)result)
  {
    if (v22)
    {
      if ((*(_BYTE *)(a4 + 8) & 1) != 0)
        v23 = *(_QWORD *)(a4 + 16);
      else
        v23 = a4 + 9;
      re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, v23);
    }
    v20 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_27:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::serializeBool<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned __int8 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned __int8 *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeBool(a1 + 24, a2, v13);
}

BOOL re::serializeChar<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *this, re::TypeInfo *a6, int a7)
{
  char *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = &v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeChar(a1 + 24, a2, (uint64_t)v13);
}

BOOL re::serializeI8<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *this, re::TypeInfo *a6, int a7)
{
  char *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = &v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<signed char>(a1 + 24, a2, v13);
}

BOOL re::serializeI16<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, __int16 *a4, re *this, re::TypeInfo *a6, int a7)
{
  __int16 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  __int16 v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = &v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<short>(a1 + 24, a2, v13);
}

BOOL re::serializeI32<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned int *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned int *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned int *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<int>(a1 + 24, a2, v13);
}

BOOL re::serializeI64<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unint64_t *a4, re *this, re::TypeInfo *a6, int a7)
{
  unint64_t *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unint64_t *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<long long>(a1 + 24, a2, v13);
}

BOOL re::serializeU8<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int8 *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned __int8 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  char v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned __int8 *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned char>(a1 + 24, a2, v13);
}

BOOL re::serializeU16<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned __int16 *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned __int16 *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  __int16 v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned __int16 *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned short>(a1 + 24, a2, v13);
}

BOOL re::serializeU32<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, unsigned int *a4, re *this, re::TypeInfo *a6, int a7)
{
  unsigned int *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (unsigned int *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned int>(a1 + 24, a2, v13);
}

BOOL re::serializeU64<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, rapidjson::internal **a4, re *this, re::TypeInfo *a6, int a7)
{
  rapidjson::internal **v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (rapidjson::internal **)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::DynamicArrayBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeInt<unsigned long long>(a1 + 24, a2, v13);
}

BOOL re::serializeFloat<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, float *a4, re *this, re::TypeInfo *a6, int a7)
{
  float *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  int v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (float *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<float>(a1 + 24, a2, v13);
}

BOOL re::serializeDouble<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, double *a4, re *this, re::TypeInfo *a6, int a7)
{
  double *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;

  v19 = 0;
  if (this != a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(this, a6, a3))
    {
      goto LABEL_4;
    }
    return 0;
  }
LABEL_4:
  if (a7)
    v13 = (double *)&v19;
  else
    v13 = a4;
  return re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReal<double>(a1 + 24, a2, v13);
}

uint64_t re::serializeCString<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *this, re::TypeInfo *a6, int a7)
{
  int v13;
  uint64_t result;
  _anonymous_namespace_ *v15;
  const char *v16;
  size_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  size_t v22;
  int v23;

  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_18:
      return 0;
    }
    v18 = **((_QWORD **)this + 2);
    v19 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v18 != (unsigned __int16)v19)
      goto LABEL_18;
    v21 = WORD1(v18) == WORD1(v19);
    v20 = (v19 ^ v18) & 0xFFFFFF00000000;
    v21 = v21 && v20 == 0;
    if (!v21)
      goto LABEL_18;
  }
LABEL_4:
  if (a7)
  {
    LODWORD(v22) = 0;
    v13 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, (int *)&v22);
    result = 0;
    if (!v13)
      return result;
    v15 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_22;
  }
  v16 = *a4;
  v23 = 2 * (*a4 != 0);
  result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v23);
  if (!(_DWORD)result)
    return result;
  if (v16)
  {
    if (*a4)
    {
      v17 = strlen(*a4);
      v22 = v17;
      if (re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t *)&v22))
      {
        if (v17)
          re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, (uint64_t)*a4);
        goto LABEL_20;
      }
    }
    else
    {
      v22 = 0;
      if (re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t *)&v22))
      {
LABEL_20:
      }
    }
  }
  v15 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_22:
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeStringID<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *this, re::TypeInfo *a6, int a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t *v17;
  char *v18;
  _BOOL8 result;
  _anonymous_namespace_ *v20;
  size_t v21;
  size_t v22;

  if (this == a6)
    goto LABEL_14;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v13 = **((_QWORD **)this + 2);
    v14 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v13 == (unsigned __int16)v14)
    {
      v16 = WORD1(v13) == WORD1(v14);
      v15 = (v14 ^ v13) & 0xFFFFFF00000000;
      v16 = v16 && v15 == 0;
      if (v16)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, a3))
  {
    goto LABEL_14;
  }
  v17 = re::TypeInfo::name(a6);
  if ((unint64_t)*v17 >> 1 != 0x134375A94D9F7110
    || (v18 = (char *)v17[1], v18 != "DynamicString") && strcmp(v18, "DynamicString"))
  {
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v22 = 0;
    result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t *)&v22);
    if (!(_DWORD)result)
      return result;
    v20 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    v21 = strlen(*(const char **)(a4 + 8));
    v22 = v21;
    result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, (uint64_t *)&v22);
    if (!(_DWORD)result)
      return result;
    if (v21)
      re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, *(_QWORD *)(a4 + 8));
    v20 = (_anonymous_namespace_ *)(a1 + 24);
  }
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeIntrospectionCallbackSerializer<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, unint64_t **this, unint64_t **a6, int a7)
{
  _BOOL8 result;
  unint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  uint64_t v33;
  uint64_t v34[2];

  if (this != a6)
  {
    if (*this != *a6)
    {
      if (re::areSameTranslatedVersion((re *)this, (const re::TypeInfo *)a6, a3))
        goto LABEL_4;
LABEL_26:
      return 0;
    }
    v21 = *this[2];
    v22 = *a6[2];
    if ((unsigned __int16)v21 != (unsigned __int16)v22)
      goto LABEL_26;
    v24 = WORD1(v21) == WORD1(v22);
    v23 = (v22 ^ v21) & 0xFFFFFF00000000;
    v24 = v24 && v23 == 0;
    if (!v24)
      goto LABEL_26;
  }
LABEL_4:
  if (!a7)
  {
    v14 = *this[2];
    v30 = (uint64_t)*this;
    v31 = v14;
    LODWORD(v32) = -1;
    v34[0] = 0x258C98EAAF29A10ALL;
    v34[1] = (uint64_t)"CallbackSerializerAttribute";
    v15 = (uint64_t *)re::TypeAttributeCollection::operator[](&v30, v34);
    re::StringID::destroyString((re::StringID *)v34);
    v16 = *v15;
    v17 = *(_QWORD *)(a1 + 264);
    v18 = *(_QWORD *)(a1 + 56);
    v32 = 0;
    v33 = 0;
    v30 = v18;
    v31 = 0;
    re::DynamicString::setCapacity(&v30, 0);
    if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v16 + 72))(v17, v16, a4, &v30) & 1) != 0)
    {
      if ((v31 & 1) != 0)
        v19 = v31 >> 1;
      else
        v19 = v31 >> 1;
      v34[0] = v19;
      if (re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, v34))
      {
        if (v19)
        {
          if ((v31 & 1) != 0)
            v20 = v32;
          else
            v20 = (char *)&v31 + 1;
          re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString(a1 + 24, (uint64_t)v20);
        }
        if (v30)
        {
          if ((v31 & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v30 + 40))();
        }
        return *(_BYTE *)(a1 + 64) == 0;
      }
    }
    else
    {
      re::TypeInfo::name((re::TypeInfo *)this);
    }
    if (v30 && (v31 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v30 + 40))();
    return 0;
  }
  v30 = 0;
  result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString(a1 + 24, a2, &v30);
  if ((_DWORD)result)
  {
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializeCString(_BYTE *a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *this, re::TypeInfo *a6)
{
  int *v11;
  int v12;
  _anonymous_namespace_ *v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  int v22;
  __int128 v23;
  int v24;
  const char *v25;

  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_14:
      return 0;
    }
    v15 = **((_QWORD **)this + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 != (unsigned __int16)v16)
      goto LABEL_14;
    v18 = WORD1(v15) == WORD1(v16);
    v17 = (v16 ^ v15) & 0xFFFFFF00000000;
    v18 = v18 && v17 == 0;
    if (!v18)
      goto LABEL_14;
  }
LABEL_4:
  if (!*a4)
  {
    LODWORD(v25) = 0;
    v13 = (_anonymous_namespace_ *)(a1 + 24);
    v22 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((uint64_t)(a1 + 24), a2, (int *)&v25);
    result = 0;
    if (!v22)
      return result;
    goto LABEL_22;
  }
  if (!a1[336]
    || (v25 = *a4,
        (v11 = (int *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(a1 + 344), (uint64_t *)&v25)) == 0))
  {
    v24 = 2;
    if ((re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((uint64_t)(a1 + 24), a2, &v24) & 1) != 0)
    {
      v19 = (const char *)strlen(*a4);
      v25 = v19;
      result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginString((uint64_t)(a1 + 24), a2, (uint64_t *)&v25);
      if (!(_DWORD)result)
        return result;
      if (v19)
        re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeString((uint64_t)(a1 + 24), (uint64_t)*a4);
      v20 = *a4;
      v21 = **((_QWORD **)this + 2);
      *(_QWORD *)&v23 = *(_QWORD *)this;
      *((_QWORD *)&v23 + 1) = v21;
      re::internal::SharedObjectGraph::addObject((uint64_t)(a1 + 336), (uint64_t)v20, &v23);
      return a1[64] == 0;
    }
    return 0;
  }
  v12 = *v11;
  v24 = 1;
  LODWORD(v25) = v12;
  v13 = (_anonymous_namespace_ *)(a1 + 24);
  result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer((uint64_t)(a1 + 24), a2, &v24);
  if (!(_DWORD)result)
    return result;
  re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference((uint64_t)(a1 + 24), (unsigned int *)&v25);
LABEL_22:
  return a1[64] == 0;
}

uint64_t re::SerializerV1<re::EncoderRapidJSON<re::CFDataOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>>::serializePointer(uint64_t a1, const char *a2, int a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  const re::TypeInfo *v13;
  _BOOL4 isPointerToPolymorphicType;
  int v15;
  char *v16;
  _DWORD *v17;
  _anonymous_namespace_ *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t *v32;
  uint64_t *v33;
  char *v34;
  re::TypeRegistry *v35;
  uint64_t *v36;
  uint64_t *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  __int128 v45;
  _BYTE v46[32];
  __int128 v47;
  _QWORD v48[4];
  _QWORD v49[4];
  char *v50;
  _BYTE v51[32];
  int v52[8];

  isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6)
    goto LABEL_4;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v28 = **((_QWORD **)this + 2);
    v29 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v28 == (unsigned __int16)v29)
    {
      v31 = WORD1(v28) == WORD1(v29);
      v30 = (v29 ^ v28) & 0xFFFFFF00000000;
      v31 = v31 && v30 == 0;
      if (v31)
        goto LABEL_4;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v13))
  {
LABEL_4:
    v15 = 0;
    goto LABEL_5;
  }
  if (*((_BYTE *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (v32 = re::TypeInfo::name(this), v33 = re::TypeInfo::name(a6), !re::StringID::operator==(v32, v33))))
  {
    return 0;
  }
  v15 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v50);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)v51);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v50);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)v51);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    v20 = *(_QWORD *)v49[2];
    *(_QWORD *)&v47 = v49[0];
    *((_QWORD *)&v47 + 1) = v20;
    if (v49[0])
      goto LABEL_8;
    goto LABEL_15;
  }
  re::internal::actualType(a4, (void **)this, &v47);
  if (!(_QWORD)v47)
  {
LABEL_15:
    v21 = re::TypeInfo::name(this);
    return 0;
  }
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, (re **)&v47, &v50);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)v51);
  if ((a7 & 1) != 0 || (v16 = *a4) == 0)
  {
    LODWORD(v50) = 0;
    v18 = (_anonymous_namespace_ *)(a1 + 24);
    v27 = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, (int *)&v50);
    result = 0;
    if (v27)
      goto LABEL_17;
    return result;
  }
  if (!*(_BYTE *)(a1 + 336))
  {
LABEL_33:
    v45 = v47;
    re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 336), (uint64_t)v16, &v45);
    v44 = 2;
    result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, &v44);
    if (!(_DWORD)result)
      return result;
    if (!isPointerToPolymorphicType)
    {
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, char *, _QWORD *, _QWORD *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, 0, *a4, v49, v48, 0);
      goto LABEL_45;
    }
    v34 = *a4;
    re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v46);
    if (v15)
    {
      v35 = (re::TypeRegistry *)v48[0];
      v36 = re::TypeInfo::name((re::TypeInfo *)v46);
      re::TypeRegistry::typeInfo(v35, (const re::StringID *)v36, &v50);
      if (!(_BYTE)v50)
      {
        v38 = re::TypeInfo::name((re::TypeInfo *)v46);
LABEL_45:
        if (*(_BYTE *)(a1 + 336))
        {
          --*(_QWORD *)(a1 + 488);
          ++*(_DWORD *)(a1 + 496);
        }
        return *(_BYTE *)(a1 + 64) == 0;
      }
      re::TypeInfo::operator=((uint64_t)v52, (uint64_t)v51);
    }
    if (re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginObject(a1 + 24, a2, 0))
    {
      v37 = re::TypeInfo::polymorphicObjectName((re::TypeInfo *)v52);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, uint64_t, _QWORD, char *, _BYTE *, int *, _QWORD))(*(_QWORD *)a1 + 72))(a1, v37[1], 0, v34, v46, v52, 0);
      re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::endObject((_anonymous_namespace_ *)(a1 + 24));
    }
    goto LABEL_45;
  }
  v50 = *a4;
  v17 = (_DWORD *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 344, (uint64_t *)&v50);
  if (!v17)
  {
    v16 = *a4;
    goto LABEL_33;
  }
  LODWORD(v50) = *v17;
  v52[0] = 1;
  v18 = (_anonymous_namespace_ *)(a1 + 24);
  result = re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::beginPointer(a1 + 24, a2, v52);
  if ((_DWORD)result)
  {
    re::EncoderRapidJSON<re::CFDataBufferedOutputStream,rapidjson::Writer<rapidjson::GenericStringBuffer<rapidjson::UTF8<char>,re::internal::RapidJSONAllocator>,rapidjson::UTF8<char>,rapidjson::UTF8<char>,re::internal::RapidJSONAllocator,0u>>::serializeReference(a1 + 24, (unsigned int *)&v50);
LABEL_17:
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

void re::ServiceRegistry::~ServiceRegistry(re::ServiceRegistry *this)
{
  uint64_t *v1;

  v1 = (uint64_t *)((char *)this + 16);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::deinit((uint64_t *)this + 2);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::deinit(v1);
}

{
  uint64_t *v1;

  v1 = (uint64_t *)((char *)this + 16);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::deinit((uint64_t *)this + 2);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::deinit(v1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::ServiceRegistry::doGetService(re::ServiceRegistry *this, const re::IntrospectionBase *a2, StringID *a3)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const re::IntrospectionBase *v9;
  unint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  const re::IntrospectionBase *v14;
  const char *v15;
  uint64_t v16;
  StringID v18;
  const re::IntrospectionBase *v19;
  _QWORD v20[2];
  char v21;

  re::StringID::StringID((re::StringID *)&v18, a3);
  v19 = a2;
  re::StringID::StringID((re::StringID *)v20, &v18);
  re::StringID::destroyString((re::StringID *)&v18);
  v5 = re::internal::ServiceKeyHash::operator()((uint64_t)&v21, &v19);
  v6 = *((unsigned int *)this + 10);
  if (!(_DWORD)v6 || (v7 = *(unsigned int *)(*((_QWORD *)this + 3) + 4 * (v5 % v6)), (_DWORD)v7 == 0x7FFFFFFF))
  {
LABEL_9:
    v16 = 0;
  }
  else
  {
    v8 = *((_QWORD *)this + 4);
    v9 = v19;
    v10 = v20[0];
    v11 = (const char *)v20[1];
    while (1)
    {
      v12 = v8 + 40 * v7;
      v14 = *(const re::IntrospectionBase **)(v12 + 8);
      v13 = v12 + 8;
      if (v14 == v9 && (v10 ^ *(_QWORD *)(v13 + 8)) <= 1)
      {
        v15 = *(const char **)(v13 + 16);
        if (v15 == v11 || !strcmp(v15, v11))
          break;
      }
      v7 = *(_DWORD *)(v8 + 40 * v7) & 0x7FFFFFFF;
      if (v7 == 0x7FFFFFFF)
        goto LABEL_9;
    }
    v16 = *(_QWORD *)(v8 + 40 * v7 + 32);
  }
  re::StringID::destroyString((re::StringID *)v20);
  return v16;
}

uint64_t *re::allocInfo_ServiceRegistry(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_483);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_483))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254123188, 0);
    *(uint64_t *)((char *)&qword_254123198 + 6) = 0;
    qword_254123198 = 0;
    qword_2541231A8 = 0;
    qword_2541231B0 = 0xFFFFFFFFLL;
    qword_254123188 = (uint64_t)&off_24ED7DAA8;
    qword_2541231B8 = (uint64_t)"ServiceRegistry";
    dword_2541231C0 = 0;
    unk_2541231C8 = 0u;
    unk_2541231D8 = 0u;
    unk_2541231E8 = 0u;
    qword_2541231F8 = 0;
    __cxa_guard_release(&_MergedGlobals_483);
  }
  return &qword_254123188;
}

void re::initInfo_ServiceRegistry(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x196524EDC9931BE4;
  v5[1] = "ServiceRegistry";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x4000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_ServiceRegistry(re::IntrospectionBase *)::structureAttributes;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::ServiceRegistry>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::ServiceRegistry>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::ServiceRegistry>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::ServiceRegistry>;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

void re::internal::defaultConstruct<re::ServiceRegistry>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)a3 = &off_24ED88E68;
  *(_QWORD *)(a3 + 8) = 0;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_DWORD *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_QWORD *)(a3 + 52) = 0x7FFFFFFFLL;
}

double re::internal::defaultDestruct<re::ServiceRegistry>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v3;

  v3 = (uint64_t *)(a3 + 16);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::deinit((uint64_t *)(a3 + 16));
  return re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::deinit(v3);
}

void re::internal::defaultConstructV2<re::ServiceRegistry>(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24ED88E68;
  *(_QWORD *)(a1 + 8) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 52) = 0x7FFFFFFFLL;
}

double re::internal::defaultDestructV2<re::ServiceRegistry>(uint64_t a1)
{
  uint64_t *v1;

  v1 = (uint64_t *)(a1 + 16);
  re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::deinit((uint64_t *)(a1 + 16));
  return re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::deinit(v1);
}

uint64_t re::introspect_ServiceRegistry(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ServiceRegistry", (uint64_t (*)(re::internal *))re::allocInfo_ServiceRegistry, (re::IntrospectionBase *(*)(void))re::initInfo_ServiceRegistry, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ServiceRegistry>, this);
}

uint64_t *re::allocInfo_EntitlementService(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_484);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_484))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254123208, 0);
    *(uint64_t *)((char *)&qword_254123218 + 6) = 0;
    qword_254123218 = 0;
    qword_254123228 = 0;
    qword_254123230 = 0xFFFFFFFFLL;
    qword_254123208 = (uint64_t)&off_24ED7DAA8;
    qword_254123238 = (uint64_t)"EntitlementService";
    dword_254123240 = 0;
    unk_254123248 = 0u;
    unk_254123258 = 0u;
    unk_254123268 = 0u;
    qword_254123278 = 0;
    __cxa_guard_release(&_MergedGlobals_484);
  }
  return &qword_254123208;
}

void re::initInfo_EntitlementService(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x522BBC3B11E1D0;
  v5[1] = "EntitlementService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_EntitlementService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_EntitlementService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"EntitlementService", (uint64_t (*)(re::internal *))re::allocInfo_EntitlementService, (re::IntrospectionBase *(*)(void))re::initInfo_EntitlementService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::EntitlementService>, this);
}

void *re::internal::missingServiceErrorMessage@<X0>(re::internal *this@<X0>, const re::IntrospectionBase *a2@<X1>, re::DynamicString *a3@<X8>)
{
  const char *v7;
  size_t v8;
  char *v9;
  int v10;
  const char *v11;
  size_t v12;
  unint64_t v14;
  char *__s2[3];

  *((_QWORD *)a3 + 1) = 0;
  *((_QWORD *)a3 + 2) = 0;
  *((_QWORD *)a3 + 3) = 0;
  re::DynamicString::setCapacity(a3, 0);
  re::DynamicString::append(a3, "Service of type '", 0x11uLL);
  re::getPrettyTypeName(this, (const re::IntrospectionBase *)&v14);
  if (((uint64_t)__s2[0] & 1) != 0)
    v7 = __s2[1];
  else
    v7 = (char *)__s2 + 1;
  if (((uint64_t)__s2[0] & 1) != 0)
    v8 = (unint64_t)__s2[0] >> 1;
  else
    v8 = LOBYTE(__s2[0]) >> 1;
  re::DynamicString::append(a3, v7, v8);
  if (v14 && ((uint64_t)__s2[0] & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v14 + 40))();
  re::StringID::invalid((re::StringID *)&v14);
  if ((v14 ^ *(_QWORD *)a2) >= 2)
  {
    re::StringID::destroyString((re::StringID *)&v14);
  }
  else
  {
    v9 = (char *)*((_QWORD *)a2 + 1);
    if (v9 == __s2[0])
    {
      re::StringID::destroyString((re::StringID *)&v14);
      return re::DynamicString::append(a3, "' is required but is not registered in the service locator.", 0x3BuLL);
    }
    v10 = strcmp(v9, __s2[0]);
    re::StringID::destroyString((re::StringID *)&v14);
    if (!v10)
      return re::DynamicString::append(a3, "' is required but is not registered in the service locator.", 0x3BuLL);
  }
  re::DynamicString::append(a3, "' and key '", 0xBuLL);
  v11 = (const char *)*((_QWORD *)a2 + 1);
  v12 = strlen(v11);
  re::DynamicString::append(a3, v11, v12);
  return re::DynamicString::append(a3, "' is required but is not registered in the service locator.", 0x3BuLL);
}

uint64_t re::BackgroundTask::BackgroundTask(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v6;
  void *v7;

  *(_QWORD *)a1 = a2;
  std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100](a1 + 8, a3);
  std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100](a1 + 40, a4);
  *(_WORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 850045863;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 1018212795;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  v6 = dispatch_group_create();

  v7 = *(void **)(a1 + 208);
  *(_QWORD *)(a1 + 208) = v6;

  return a1;
}

void re::BackgroundTask::~BackgroundTask(re::BackgroundTask *this)
{
  re::BackgroundTask *v2;
  uint64_t v3;
  re::BackgroundTask *v4;
  uint64_t v5;

  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 160));
  std::mutex::~mutex((std::mutex *)((char *)this + 96));
  v2 = (re::BackgroundTask *)*((_QWORD *)this + 8);
  if (v2 == (re::BackgroundTask *)((char *)this + 40))
  {
    v3 = 4;
    v2 = (re::BackgroundTask *)((char *)this + 40);
  }
  else
  {
    if (!v2)
      goto LABEL_6;
    v3 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v2 + 8 * v3))();
LABEL_6:
  v4 = (re::BackgroundTask *)*((_QWORD *)this + 4);
  if (v4 == (re::BackgroundTask *)((char *)this + 8))
  {
    v5 = 4;
    v4 = (re::BackgroundTask *)((char *)this + 8);
  }
  else
  {
    if (!v4)
      return;
    v5 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v4 + 8 * v5))();
}

uint64_t *re::foundationThreadingLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::foundationThreadingLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Threading");
    qword_25582AF48 = (uint64_t)os_log_create("com.apple.re", "Foundation.JobSystem");
  }
  return &re::foundationThreadingLogObjects(void)::logObjects;
}

void re::internal::WorkerThread::~WorkerThread(re::internal::WorkerThread *this)
{
  uint64_t v2;
  void *v3;

  re::internal::WorkerThread::deinit((uint64_t)this);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 464));
  std::mutex::~mutex((std::mutex *)((char *)this + 400));
  re::WorkStealingQueue<re::Job *>::deinit((uint64_t)this + 192);
  v2 = *((_QWORD *)this + 13);
  if (v2)
  {
    if (*((_QWORD *)this + 17))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 17) = 0;
    *((_QWORD *)this + 14) = 0;
    *((_QWORD *)this + 15) = 0;
    *((_QWORD *)this + 13) = 0;
    ++*((_DWORD *)this + 32);
  }
  v3 = (void *)*((_QWORD *)this + 8);
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  if (v3)
  {
    free(v3);
    *((_QWORD *)this + 8) = 0;
    *((_QWORD *)this + 9) = 0;
  }
  std::thread::~thread((std::thread *)this + 1);
}

uint64_t re::internal::WorkerThread::deinit(uint64_t this)
{
  uint64_t v1;

  if (*(_QWORD *)this)
  {
    v1 = this;
    re::WorkStealingQueue<re::Job *>::deinit(this + 192);
    this = *(_QWORD *)(v1 + 104);
    if (this)
    {
      if (*(_QWORD *)(v1 + 136))
        this = (*(uint64_t (**)(uint64_t))(*(_QWORD *)this + 40))(this);
      *(_QWORD *)(v1 + 136) = 0;
      *(_QWORD *)(v1 + 112) = 0;
      *(_QWORD *)(v1 + 120) = 0;
      *(_QWORD *)(v1 + 104) = 0;
      ++*(_DWORD *)(v1 + 128);
    }
    *(_QWORD *)v1 = 0;
  }
  return this;
}

void re::internal::WorkerThread::init(re::internal::WorkerThread *this, re::FiberJobManager *a2, int a3, int a4, re::AlignedAllocator *a5)
{
  unint64_t v9;
  uint64_t v10;
  std::__thread_struct *v11;
  _QWORD *v12;
  int v13;
  std::thread v14;
  uint64_t *v15;

  *(_QWORD *)this = a2;
  v9 = *((unsigned int *)a2 + 84);
  *((_QWORD *)this + 13) = a5;
  re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)this + 13, v9);
  ++*((_DWORD *)this + 32);
  atomic_store(1uLL, (unint64_t *)this + 24);
  atomic_store(1uLL, (unint64_t *)this + 32);
  v10 = (*(uint64_t (**)(re::AlignedAllocator *, uint64_t, uint64_t))(*(_QWORD *)a5 + 32))(a5, 32, 8);
  *(_OWORD *)v10 = 0u;
  *(_OWORD *)(v10 + 16) = 0u;
  re::FixedArray<unsigned long>::init<>((uint64_t *)v10, (uint64_t)a5, 0x400uLL);
  *((_QWORD *)this + 40) = v10;
  *((_DWORD *)this + 96) = 0;
  std::mutex::lock((std::mutex *)((char *)this + 400));
  *((_BYTE *)this + 392) = 0;
  std::mutex::unlock((std::mutex *)((char *)this + 400));
  *((_DWORD *)this + 4) = a4;
  v11 = (std::__thread_struct *)operator new();
  std::__thread_struct::__thread_struct(v11);
  v12 = (_QWORD *)operator new();
  *v12 = v11;
  v12[1] = re::internal::WorkerThread::threadFunction;
  v12[2] = 0;
  v12[3] = this;
  v13 = pthread_create(&v14.__t_, 0, (void *(__cdecl *)(void *))std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::internal::WorkerThread::*)(void),re::internal::WorkerThread*>>, v12);
  if (v13)
  {
    std::__throw_system_error(v13, "thread constructor failed");
LABEL_7:
    std::terminate();
  }
  v15 = 0;
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::internal::WorkerThread::*)(void),re::internal::WorkerThread*>>::reset[abi:nn180100](&v15, 0);
  if (*((_QWORD *)this + 1))
    goto LABEL_7;
  *((std::thread *)this + 1) = v14;
  v14.__t_ = 0;
  std::thread::~thread(&v14);
  if (a3)
    re::internal::setThreadPriority(*((_opaque_pthread_t **)this + 1), (_opaque_pthread_t *)0x28);
}

uint64_t re::internal::WorkerThread::threadFunction(re::internal::WorkerThread *this)
{
  const char *v2;
  void *v3;
  unsigned int FreeFiberIndex;
  uint64_t v5;
  double v6;
  uint64_t result;
  uint64_t v8;
  char v9;
  _BYTE v10[23];

  re::DynamicString::format((re::DynamicString *)"Job Service worker %d", (re::DynamicString *)&v8, *((unsigned int *)this + 4));
  if ((v9 & 1) != 0)
    v2 = *(const char **)&v10[7];
  else
    v2 = v10;
  pthread_setname_np(v2);
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  v3 = (void *)*((_QWORD *)this + 8);
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 9) = 0;
  if (v3)
    free(v3);
  re::internal::AutoResetEvent::waitOne((re::internal::WorkerThread *)((char *)this + 392));
  *((_DWORD *)this + 20) = *((_DWORD *)this + 24);
  *((_DWORD *)this + 21) = 1;
  *((_QWORD *)this + 11) = 0;
  FreeFiberIndex = re::FiberJobManager::getFreeFiberIndex(*(re::FiberJobManager **)this);
  re::internal::WorkerThread::switchToCustomFiber(this, FreeFiberIndex);
  v6 = re::internal::WorkerThread::postFiberSwitch(this, v5);
  result = v8;
  if (v8)
  {
    if ((v9 & 1) != 0)
      return (*(uint64_t (**)(double))(*(_QWORD *)v8 + 40))(v6);
  }
  return result;
}

uint64_t re::WorkStealingQueue<re::Job *>::deinit(uint64_t result)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;

  if (*(_QWORD *)(result + 128))
  {
    v1 = result;
    v2 = *(uint64_t **)(result + 128);
    if (v2)
    {
      v3 = *v2;
      re::WorkStealingQueue<re::Job *>::CircularArray::~CircularArray(*(_QWORD **)(result + 128));
      result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v3 + 40))(v3, v2);
      atomic_store(0, (unint64_t *)(v1 + 128));
    }
  }
  return result;
}

void re::internal::WorkerThread::switchToCustomFiber(re::internal::WorkerThread *this, unsigned int a2)
{
  unsigned int v4;
  char *Fiber;
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;

  v4 = *((_DWORD *)this + 24);
  if (v4 == -1)
    Fiber = (char *)this + 24;
  else
    Fiber = (char *)re::FiberJobManager::getFiber(*(re::FiberJobManager **)this, v4);
  v6 = re::FiberJobManager::getFiber(*(re::FiberJobManager **)this, a2);
  *((_DWORD *)this + 24) = a2;
  *((_QWORD *)Fiber + 1) = v6;
  jump_fcontext();
  *v8 = v7;
  v8[1] = 0;
}

double re::internal::WorkerThread::postFiberSwitch(re::internal::WorkerThread *this, uint64_t a2)
{
  uint64_t v3;
  unint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  _DWORD *v7;
  unint64_t v8;
  char v9;
  unint64_t v10;
  unint64_t v11;
  char v12;
  double result;
  __n128 v14;

  switch(*((_DWORD *)this + 21))
  {
    case 1:
    case 5:
      goto LABEL_16;
    case 2:
      v3 = *((unsigned int *)this + 20);
      v4 = (unint64_t *)(*(_QWORD *)this + 384);
      v5 = *(_QWORD *)(*(_QWORD *)this + 344);
      v6 = atomic_load(v4);
      v7 = (_DWORD *)(v5 + (v3 << 7));
      *v7 = v6;
      v8 = __ldaxr(v4);
      if (v8 == v6)
      {
        if (!__stlxr(v6 & 0xFFFFFFFF00000000 | v3, v4))
        {
          v9 = 1;
          goto LABEL_9;
        }
      }
      else
      {
        __clrex();
      }
      v9 = 0;
LABEL_9:
      if ((v9 & 1) != 0)
        goto LABEL_16;
      break;
    case 3:
      v10 = *((_QWORD *)this + 11);
      v14.n128_u32[0] = *((_DWORD *)this + 20);
      v14.n128_u64[1] = v10;
      re::DynamicArray<re::RigNodeConstraint>::add((re::internal::WorkerThread *)((char *)this + 104), &v14);
      goto LABEL_16;
    case 4:
      re::FiberJobManager::addFiberToWaitList(*(os_unfair_lock_s **)this, *((_DWORD *)this + 20), *((_QWORD *)this + 11));
      goto LABEL_16;
    default:
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unknown fiber state.", "!\"Unreachable code\"", "postFiberSwitch", 237);
      _os_crash();
      __break(1u);
      JUMPOUT(0x225CFF708);
  }
  do
  {
    *v7 = v8;
    v11 = __ldaxr(v4);
    if (v11 == v8)
    {
      if (!__stlxr(v8 & 0xFFFFFFFF00000000 | v3, v4))
      {
        v12 = 1;
        goto LABEL_15;
      }
    }
    else
    {
      __clrex();
    }
    v12 = 0;
LABEL_15:
    v8 = v11;
  }
  while ((v12 & 1) == 0);
LABEL_16:
  *(_QWORD *)&result = 0xFFFFFFFFLL;
  *((_QWORD *)this + 10) = 0xFFFFFFFFLL;
  *((_QWORD *)this + 11) = 0;
  return result;
}

unint64_t re::FiberJobManager::getFiber(re::FiberJobManager *this, unsigned int a2)
{
  if (*((_QWORD *)this + 42) <= (unint64_t)a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *((_QWORD *)this + 43) + ((unint64_t)a2 << 7) + 64;
}

void re::internal::WorkerThread::switchToThreadFiber(re::internal::WorkerThread *this)
{
  unint64_t Fiber;
  uint64_t v3;
  _QWORD *v4;

  Fiber = re::FiberJobManager::getFiber(*(re::FiberJobManager **)this, *((_DWORD *)this + 24));
  *((_DWORD *)this + 24) = -1;
  *(_QWORD *)(Fiber + 8) = (char *)this + 24;
  jump_fcontext();
  *v4 = v3;
  v4[1] = 0;
}

void re::internal::WorkerThread::runAsync(unint64_t *a1, uint64_t a2, unsigned int a3, unsigned int *a4, char a5)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (a4)
    *a4 = a3;
  if ((a5 & 1) != 0)
  {
    if ((int)(a3 - 1) >= 0)
    {
      v8 = (unint64_t)(a3 - 1) << 6;
      do
      {
        *(_QWORD *)(a2 + v8 + 8) = a4;
        v14 = a2 + v8;
        re::WorkStealingQueue<re::Job *>::push(a1 + 24, &v14);
        v8 -= 64;
      }
      while (v8 != -64);
    }
  }
  else if (a3)
  {
    v9 = a3;
    do
    {
      *(_QWORD *)(a2 + 8) = a4;
      v14 = a2;
      re::WorkStealingQueue<re::Job *>::push(a1 + 24, &v14);
      a2 += 64;
      --v9;
    }
    while (v9);
  }
  v10 = *(_QWORD *)(*a1 + 72);
  if (v10)
  {
    v11 = *(uint64_t **)(*a1 + 80);
    v12 = 8 * v10;
    do
    {
      v13 = *v11++;
      re::internal::AutoResetEvent::set((re::internal::AutoResetEvent *)(v13 + 392));
      v12 -= 8;
    }
    while (v12);
  }
}

uint64_t re::WorkStealingQueue<re::Job *>::push(unint64_t *a1, _QWORD *a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  uint64_t result;

  v4 = a1[8];
  v5 = atomic_load(a1);
  v6 = (uint64_t *)a1[16];
  if (v4 - v5 > v6[1] - 1)
  {
    v6 = (uint64_t *)re::WorkStealingQueue<re::Job *>::CircularArray::grow(v6, v5, v4);
    atomic_store((unint64_t)v6, a1 + 16);
  }
  result = re::WorkStealingQueue<re::Job *>::CircularArray::put((uint64_t)v6, v4, a2);
  __dmb(0xBu);
  a1[8] = v4 + 1;
  return result;
}

uint64_t re::internal::WorkerThread::getWaitingFiber(re::internal::WorkerThread *this, unsigned int *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v2 = *((_QWORD *)this + 15);
  if (!v2)
    return 0;
  v3 = 0;
  v4 = 0;
  while (1)
  {
    if (*((_QWORD *)this + 15) <= v4)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v5 = *((_QWORD *)this + 17);
    if (!atomic_load(*(unsigned int **)(v5 + v3 + 8)))
      break;
    ++v4;
    v3 += 16;
    if (v2 == v4)
      return 0;
  }
  *a2 = *(_DWORD *)(v5 + v3);
  re::DynamicArray<re::BufferView>::removeStableAt((_QWORD *)this + 13, v4);
  return 2;
}

uint64_t re::internal::WorkerThread::getJob(re::internal::WorkerThread *this, re::Job **a2)
{
  uint64_t result;
  unint64_t v5;
  unsigned int v6;
  int v7;
  char v8;
  int v9;
  unint64_t *WorkerThread;
  int v11;
  uint64_t v12;

  if ((re::WorkStealingQueue<re::Job *>::pop((unint64_t *)this + 24, (uint64_t *)a2) & 1) != 0)
    return 2;
  v5 = *(_QWORD *)this;
  v6 = *(_DWORD *)(*(_QWORD *)this + 72);
  if (!v6)
  {
    v9 = 0;
    v8 = 0;
LABEL_12:
    result = re::WorkStealingQueue<re::Job *>::steal((unint64_t *)(v5 + 128), (uint64_t *)a2);
    if ((_DWORD)result != 2)
      return v8 & 1 | (v9 == 1) | ((_DWORD)result == 1);
    return result;
  }
  v7 = 0;
  v8 = 0;
  v9 = 0;
  while (1)
  {
    WorkerThread = (unint64_t *)re::FiberJobManager::getWorkerThread(*(re::FiberJobManager **)this, (v7 + *((_DWORD *)this + 96)) % v6);
    if (WorkerThread == (unint64_t *)this)
      goto LABEL_9;
    v11 = re::WorkStealingQueue<re::Job *>::steal(WorkerThread + 24, (uint64_t *)a2);
    v9 = v11;
    if (!v11)
      goto LABEL_9;
    if (v11 != 1)
      break;
    v8 = 1;
LABEL_9:
    if (v6 == ++v7)
    {
      v5 = *(_QWORD *)this;
      goto LABEL_12;
    }
  }
  if (v11 == 2)
  {
    *((_DWORD *)this + 96) = v7;
    return 2;
  }
  re::internal::assertLog((re::internal *)4, v12, "assertion failure: '%s' (%s:line %i) Unexpected work stealing result.", "!\"Unreachable code\"", "getJob", 434);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::WorkStealingQueue<re::Job *>::pop(unint64_t *a1, uint64_t *a2)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t result;
  unint64_t v8;

  v3 = a1[8];
  v4 = v3 - 1;
  v5 = a1[16];
  a1[8] = v3 - 1;
  __dmb(0xBu);
  v6 = *a1;
  if (*a1 <= v3 - 1)
  {
    *a2 = re::WorkStealingQueue<re::Job *>::CircularArray::get(v5, v3 - 1);
    if (v6 != v4)
      return 1;
    while (1)
    {
      v8 = __ldaxr(a1);
      if (v8 != v4)
        break;
      if (!__stlxr(v3, a1))
      {
        result = 1;
        goto LABEL_9;
      }
    }
    result = 0;
    __clrex();
  }
  else
  {
    result = 0;
  }
LABEL_9:
  a1[8] = v3;
  return result;
}

uint64_t re::FiberJobManager::getWorkerThread(re::FiberJobManager *this, unsigned int a2)
{
  if (*((_QWORD *)this + 9) <= (unint64_t)a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*((_QWORD *)this + 10) + 8 * a2);
}

uint64_t re::WorkStealingQueue<re::Job *>::steal(unint64_t *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v5;
  unint64_t v6;
  int v7;

  v2 = atomic_load(a1);
  __dmb(0xBu);
  v3 = atomic_load(a1 + 8);
  if (v2 >= v3)
    return 0;
  v5 = atomic_load(a1 + 16);
  *a2 = re::WorkStealingQueue<re::Job *>::CircularArray::get(v5, v2);
  while (1)
  {
    v6 = __ldaxr(a1);
    if (v6 != v2)
      break;
    if (!__stlxr(v2 + 1, a1))
    {
      v7 = 1;
      goto LABEL_8;
    }
  }
  v7 = 0;
  __clrex();
LABEL_8:
  if (v7)
    return 2;
  else
    return 1;
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::internal::WorkerThread::*)(void),re::internal::WorkerThread*>>(uint64_t *a1)
{
  std::__thread_specific_ptr<std::__thread_struct> *v2;
  const void *v3;
  uint64_t v4;
  void (*v5)(_QWORD *);
  _QWORD *v6;
  uint64_t *v8;

  v8 = a1;
  v2 = std::__thread_local_data();
  v3 = (const void *)*a1;
  *a1 = 0;
  pthread_setspecific(v2->__key_, v3);
  v4 = a1[2];
  v5 = (void (*)(_QWORD *))a1[1];
  v6 = (_QWORD *)(a1[3] + (v4 >> 1));
  if ((v4 & 1) != 0)
    v5 = *(void (**)(_QWORD *))(*v6 + v5);
  v5(v6);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::internal::WorkerThread::*)(void),re::internal::WorkerThread*>>::reset[abi:nn180100](&v8, 0);
  return 0;
}

uint64_t **std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::internal::WorkerThread::*)(void),re::internal::WorkerThread*>>::reset[abi:nn180100](uint64_t **result, uint64_t *a2)
{
  uint64_t *v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    std::unique_ptr<std::__thread_struct>::reset[abi:nn180100](v2, 0);
    JUMPOUT(0x2276933B8);
  }
  return result;
}

_QWORD *re::WorkStealingQueue<re::Job *>::CircularArray::~CircularArray(_QWORD *a1)
{
  re::WorkStealingQueue<re::Job *>::CircularArray::deinit(a1);
  if (*a1)
  {
    if (a1[1])
    {
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, a1[2]);
      a1[1] = 0;
      a1[2] = 0;
    }
    *a1 = 0;
  }
  return a1;
}

_QWORD *re::WorkStealingQueue<re::Job *>::CircularArray::deinit(_QWORD *result)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  v1 = *result;
  if (*result)
  {
    v2 = result;
    v3 = result + 1;
    if (result[1])
    {
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)v1 + 40))(*result, result[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v2 = 0;
    v4 = v2[3];
    if (v4)
    {
      re::WorkStealingQueue<re::Job *>::CircularArray::~CircularArray(v2[3]);
      result = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v1 + 40))(v1, v4);
    }
    v2[3] = 0;
  }
  return result;
}

uint64_t re::WorkStealingQueue<re::Job *>::CircularArray::grow(uint64_t *a1, unint64_t a2, unint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v10;

  v6 = *a1;
  v7 = 2 * a1[1];
  v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)*a1 + 32))(*a1, 32, 8);
  *(_OWORD *)v8 = 0u;
  *(_OWORD *)(v8 + 16) = 0u;
  re::FixedArray<unsigned long>::init<>((uint64_t *)v8, v6, v7);
  if (a2 < a3)
  {
    do
    {
      v10 = re::WorkStealingQueue<re::Job *>::CircularArray::get((uint64_t)a1, a2);
      re::WorkStealingQueue<re::Job *>::CircularArray::put(v8, a2++, &v10);
    }
    while (a3 != a2);
  }
  *(_QWORD *)(v8 + 24) = a1;
  return v8;
}

uint64_t re::WorkStealingQueue<re::Job *>::CircularArray::put(uint64_t result, uint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v4;

  v3 = *(_QWORD *)(result + 8);
  v4 = (v3 - 1) & a2;
  if (v3 <= v4)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(_QWORD *)(*(_QWORD *)(result + 16) + 8 * v4) = *a3;
  return result;
}

uint64_t re::WorkStealingQueue<re::Job *>::CircularArray::get(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = (v2 - 1) & a2;
  if (v2 <= v3)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v3);
}

void re::JobProfiler::~JobProfiler(re::JobProfiler *this)
{
  re::JobProfiler::deinit(this);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 20);
  re::FixedArray<re::internal::JobProfilerDataBuffer<re::internal::JobProfilerJobData>>::deinit((_QWORD *)this + 17);
  re::FixedArray<re::internal::JobProfilerDataBuffer<re::internal::JobProfilerFiberData>>::deinit((_QWORD *)this + 14);
  re::FixedArray<re::internal::JobProfilerDataBuffer<re::internal::JobProfilerJobData>>::deinit((_QWORD *)this + 11);
  re::FixedArray<re::internal::JobProfilerDataBuffer<re::internal::JobProfilerThreadData>>::deinit((_QWORD *)this + 8);
  re::StringID::destroyString((re::JobProfiler *)((char *)this + 8));
}

void re::JobProfiler::deinit(re::JobProfiler *this)
{
  uint64_t v2;
  int *v3;
  int *v4;
  unint64_t v5;
  unint64_t v6;
  re::StringID *v7;
  uint64_t v8;
  uint64_t v9;
  re::StringID *v10;
  uint64_t v11;
  re::StringID *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  int *v17;
  int *v18;
  unint64_t v19;
  unint64_t v20;
  re::StringID *v21;
  uint64_t v22;
  uint64_t v23;
  re::StringID *v24;
  uint64_t v25;
  re::StringID *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  int v40;
  uint64_t v41;

  if (*(_QWORD *)this)
  {
    v2 = *((_QWORD *)this + 9);
    if (v2)
    {
      v3 = (int *)*((_QWORD *)this + 10);
      v4 = &v3[12 * v2];
      do
      {
        v36 = *v3;
        v41 = 0;
        v38 = 0;
        v39 = 0;
        v37 = 0;
        v40 = 0;
        if (*((_QWORD *)v3 + 1))
        {
          v5 = *((_QWORD *)v3 + 3);
          v37 = *((_QWORD *)v3 + 1);
          re::DynamicArray<re::internal::JobProfilerThreadData>::setCapacity(&v37, v5);
          ++v40;
          v6 = *((_QWORD *)v3 + 3);
          if (v6 >= v39)
          {
            re::DynamicArray<re::internal::JobProfilerThreadData>::setCapacity(&v37, *((_QWORD *)v3 + 3));
            std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::JobProfilerThreadData *,re::internal::JobProfilerThreadData *,re::internal::JobProfilerThreadData *,0>(*((_QWORD *)v3 + 5), *((_QWORD *)v3 + 5) + 80 * v39, v41);
            if (v39 != v6)
            {
              v9 = *((_QWORD *)v3 + 5) + 80 * v39;
              v10 = (re::StringID *)(v41 + 80 * v39);
              v11 = 80 * v6 - 80 * v39;
              do
              {
                v12 = re::StringID::StringID(v10, (const StringID *)v9);
                v13 = *(_OWORD *)(v9 + 16);
                v14 = *(_OWORD *)(v9 + 32);
                v15 = *(_OWORD *)(v9 + 48);
                *(_OWORD *)((char *)v12 + 60) = *(_OWORD *)(v9 + 60);
                *((_OWORD *)v12 + 2) = v14;
                *((_OWORD *)v12 + 3) = v15;
                *((_OWORD *)v12 + 1) = v13;
                v9 += 80;
                v10 = (re::StringID *)((char *)v12 + 80);
                v11 -= 80;
              }
              while (v11);
            }
          }
          else
          {
            std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::JobProfilerThreadData *,re::internal::JobProfilerThreadData *,re::internal::JobProfilerThreadData *,0>(*((_QWORD *)v3 + 5), *((_QWORD *)v3 + 5) + 80 * v6, v41);
            if (v6 != v39)
            {
              v7 = (re::StringID *)(v41 + 80 * v6);
              v8 = 80 * v39 - 80 * v6;
              do
              {
                re::StringID::destroyString(v7);
                v7 = (re::StringID *)((char *)v7 + 80);
                v8 -= 80;
              }
              while (v8);
            }
          }
          v39 = v6;
        }
        re::internal::JobProfilerDataBuffer<re::internal::JobProfilerThreadData>::deinitValues((uint64_t)&v36);
        re::internal::JobProfilerDataBuffer<re::internal::JobProfilerThreadData>::deinitValues((uint64_t)&v36);
        re::DynamicArray<re::internal::JobProfilerThreadData>::deinit((uint64_t)&v37);
        v3 += 12;
      }
      while (v3 != v4);
    }
    v16 = *((_QWORD *)this + 15);
    if (v16)
    {
      v17 = (int *)*((_QWORD *)this + 16);
      v18 = &v17[12 * v16];
      do
      {
        v36 = *v17;
        v41 = 0;
        v38 = 0;
        v39 = 0;
        v37 = 0;
        v40 = 0;
        if (*((_QWORD *)v17 + 1))
        {
          v19 = *((_QWORD *)v17 + 3);
          v37 = *((_QWORD *)v17 + 1);
          re::DynamicArray<re::internal::JobProfilerFiberData>::setCapacity(&v37, v19);
          ++v40;
          v20 = *((_QWORD *)v17 + 3);
          if (v20 >= v39)
          {
            re::DynamicArray<re::internal::JobProfilerFiberData>::setCapacity(&v37, *((_QWORD *)v17 + 3));
            std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::JobProfilerFiberData *,re::internal::JobProfilerFiberData *,re::internal::JobProfilerFiberData *,0>(*((_QWORD *)v17 + 5), *((_QWORD *)v17 + 5) + 72 * v39, v41);
            if (v39 != v20)
            {
              v23 = *((_QWORD *)v17 + 5) + 72 * v39;
              v24 = (re::StringID *)(v41 + 72 * v39);
              v25 = 72 * v20 - 72 * v39;
              do
              {
                v26 = re::StringID::StringID(v24, (const StringID *)v23);
                v27 = *(_OWORD *)(v23 + 16);
                v28 = *(_OWORD *)(v23 + 32);
                v29 = *(_OWORD *)(v23 + 48);
                *((_DWORD *)v26 + 16) = *(_DWORD *)(v23 + 64);
                *((_OWORD *)v26 + 2) = v28;
                *((_OWORD *)v26 + 3) = v29;
                *((_OWORD *)v26 + 1) = v27;
                v23 += 72;
                v24 = (re::StringID *)((char *)v26 + 72);
                v25 -= 72;
              }
              while (v25);
            }
          }
          else
          {
            std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::JobProfilerFiberData *,re::internal::JobProfilerFiberData *,re::internal::JobProfilerFiberData *,0>(*((_QWORD *)v17 + 5), *((_QWORD *)v17 + 5) + 72 * v20, v41);
            if (v20 != v39)
            {
              v21 = (re::StringID *)(v41 + 72 * v20);
              v22 = 72 * v39 - 72 * v20;
              do
              {
                re::StringID::destroyString(v21);
                v21 = (re::StringID *)((char *)v21 + 72);
                v22 -= 72;
              }
              while (v22);
            }
          }
          v39 = v20;
        }
        re::internal::JobProfilerDataBuffer<re::internal::JobProfilerFiberData>::deinitValues((uint64_t)&v36);
        re::internal::JobProfilerDataBuffer<re::internal::JobProfilerFiberData>::deinitValues((uint64_t)&v36);
        re::DynamicArray<re::internal::JobProfilerFiberData>::deinit((uint64_t)&v37);
        v17 += 12;
      }
      while (v17 != v18);
    }
    v30 = *((_QWORD *)this + 18);
    if (v30)
    {
      v31 = 48 * v30;
      v32 = (uint64_t *)(*((_QWORD *)this + 19) + 8);
      do
      {
        v36 = *((_DWORD *)v32 - 2);
        re::DynamicArray<re::internal::JobProfilerJobData>::DynamicArray((uint64_t)&v37, v32);
        re::internal::JobProfilerDataBuffer<re::internal::JobProfilerJobData>::deinitValues((uint64_t)&v36);
        re::internal::JobProfilerDataBuffer<re::internal::JobProfilerJobData>::deinitValues((uint64_t)&v36);
        re::DynamicArray<re::internal::JobProfilerJobData>::deinit((uint64_t)&v37);
        v32 += 6;
        v31 -= 48;
      }
      while (v31);
    }
    v33 = *((_QWORD *)this + 12);
    if (v33)
    {
      v34 = 48 * v33;
      v35 = (uint64_t *)(*((_QWORD *)this + 13) + 8);
      do
      {
        v36 = *((_DWORD *)v35 - 2);
        re::DynamicArray<re::internal::JobProfilerJobData>::DynamicArray((uint64_t)&v37, v35);
        re::internal::JobProfilerDataBuffer<re::internal::JobProfilerJobData>::deinitValues((uint64_t)&v36);
        re::internal::JobProfilerDataBuffer<re::internal::JobProfilerJobData>::deinitValues((uint64_t)&v36);
        re::DynamicArray<re::internal::JobProfilerJobData>::deinit((uint64_t)&v37);
        v35 += 6;
        v34 -= 48;
      }
      while (v34);
    }
    re::FixedArray<re::internal::JobProfilerDataBuffer<re::internal::JobProfilerThreadData>>::deinit((_QWORD *)this + 8);
    re::FixedArray<re::internal::JobProfilerDataBuffer<re::internal::JobProfilerFiberData>>::deinit((_QWORD *)this + 14);
    re::FixedArray<re::internal::JobProfilerDataBuffer<re::internal::JobProfilerJobData>>::deinit((_QWORD *)this + 17);
    re::FixedArray<re::internal::JobProfilerDataBuffer<re::internal::JobProfilerJobData>>::deinit((_QWORD *)this + 11);
    re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 20);
    *(_QWORD *)this = 0;
  }
}

void re::internal::JobProfilerDataBuffer<re::internal::JobProfilerThreadData>::deinitValues(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  _OWORD v7[3];
  _OWORD v8[2];

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
  {
    v2 = *(_QWORD *)(a1 + 40);
    v3 = v2 + 80 * v1;
    do
    {
      re::StringID::StringID((re::StringID *)v7, (const StringID *)v2);
      v4 = *(_OWORD *)(v2 + 16);
      v5 = *(_OWORD *)(v2 + 32);
      v6 = *(_OWORD *)(v2 + 48);
      *(_OWORD *)((char *)v8 + 12) = *(_OWORD *)(v2 + 60);
      v7[2] = v5;
      v8[0] = v6;
      v7[1] = v4;
      re::StringID::destroyString((re::StringID *)v7);
      v2 += 80;
    }
    while (v2 != v3);
  }
}

void re::internal::JobProfilerDataBuffer<re::internal::JobProfilerFiberData>::deinitValues(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  _BYTE v7[16];
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  int v12;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
  {
    v2 = *(_QWORD *)(a1 + 40);
    v3 = v2 + 72 * v1;
    do
    {
      re::StringID::StringID((re::StringID *)v7, (const StringID *)v2);
      v4 = *(_OWORD *)(v2 + 16);
      v5 = *(_OWORD *)(v2 + 32);
      v6 = *(_OWORD *)(v2 + 48);
      v12 = *(_DWORD *)(v2 + 64);
      v10 = v5;
      v11 = v6;
      v8 = v4;
      v9 = 0;
      re::StringID::destroyString((re::StringID *)v7);
      v2 += 72;
    }
    while (v2 != v3);
  }
}

void re::internal::JobProfilerDataBuffer<re::internal::JobProfilerJobData>::deinitValues(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  re::StringID *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  _BYTE __dst[272];
  _OWORD v9[2];
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;

  v1 = *(_QWORD *)(a1 + 24);
  if (v1)
  {
    v2 = *(_QWORD *)(a1 + 40);
    v3 = v2 + 344 * v1;
    do
    {
      memcpy(__dst, (const void *)v2, sizeof(__dst));
      v4 = re::StringID::StringID((re::StringID *)v9, (const StringID *)(v2 + 272));
      v5 = *(_OWORD *)(v2 + 288);
      v6 = *(_OWORD *)(v2 + 304);
      v7 = *(_OWORD *)(v2 + 320);
      v13 = *(_QWORD *)(v2 + 336);
      v11 = *((_QWORD *)&v6 + 1);
      v12 = v7;
      v9[1] = v5;
      v10 = 0;
      re::StringID::destroyString(v4);
      v2 += 344;
    }
    while (v2 != v3);
  }
}

_QWORD *re::FixedArray<re::internal::JobProfilerDataBuffer<re::internal::JobProfilerThreadData>>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = result[2];
      v5 = v4 + 48 * v2;
      do
      {
        re::internal::JobProfilerDataBuffer<re::internal::JobProfilerThreadData>::deinitValues(v4);
        re::DynamicArray<re::internal::JobProfilerThreadData>::deinit(v4 + 8);
        v4 += 48;
      }
      while (v4 != v5);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

_QWORD *re::FixedArray<re::internal::JobProfilerDataBuffer<re::internal::JobProfilerFiberData>>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = result[2];
      v5 = v4 + 48 * v2;
      do
      {
        re::internal::JobProfilerDataBuffer<re::internal::JobProfilerFiberData>::deinitValues(v4);
        re::DynamicArray<re::internal::JobProfilerFiberData>::deinit(v4 + 8);
        v4 += 48;
      }
      while (v4 != v5);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

_QWORD *re::FixedArray<re::internal::JobProfilerDataBuffer<re::internal::JobProfilerJobData>>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = result[2];
      v5 = v4 + 48 * v2;
      do
      {
        re::internal::JobProfilerDataBuffer<re::internal::JobProfilerJobData>::deinitValues(v4);
        re::DynamicArray<re::internal::JobProfilerJobData>::deinit(v4 + 8);
        v4 += 48;
      }
      while (v4 != v5);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

_QWORD *re::DynamicArray<re::internal::JobProfilerThreadData>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _OWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _OWORD *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::internal::JobProfilerThreadData>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x50uLL))
        {
          v2 = 80 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 80, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 80 * v9;
        v11 = v7;
        do
        {
          re::StringID::StringID((re::StringID *)v11, (const StringID *)v8);
          v12 = *(_OWORD *)(v8 + 16);
          v13 = *(_OWORD *)(v8 + 32);
          v14 = *(_OWORD *)(v8 + 48);
          *(_OWORD *)((char *)v11 + 60) = *(_OWORD *)(v8 + 60);
          v11[2] = v13;
          v11[3] = v14;
          v11[1] = v12;
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 80;
          v11 += 5;
          v10 -= 80;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

__n128 std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::JobProfilerThreadData *,re::internal::JobProfilerThreadData *,re::internal::JobProfilerThreadData *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  __n128 result;
  __int128 v7;
  __int128 v8;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      re::StringID::operator=((unint64_t *)a3, (uint64_t *)v5);
      result = *(__n128 *)(v5 + 16);
      v7 = *(_OWORD *)(v5 + 32);
      v8 = *(_OWORD *)(v5 + 48);
      *(_OWORD *)(a3 + 60) = *(_OWORD *)(v5 + 60);
      *(_OWORD *)(a3 + 32) = v7;
      *(_OWORD *)(a3 + 48) = v8;
      *(__n128 *)(a3 + 16) = result;
      v5 += 80;
      a3 += 80;
    }
    while (v5 != a2);
  }
  return result;
}

_QWORD *re::DynamicArray<re::internal::JobProfilerJobData>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::internal::JobProfilerJobData>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x158uLL))
        {
          v2 = 344 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 344 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 344, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = v8 + 344 * v9;
        v11 = v7;
        do
        {
          memcpy(v11, (const void *)v8, 0x110uLL);
          re::StringID::StringID((re::StringID *)(v11 + 34), (const StringID *)(v8 + 272));
          v12 = *(_OWORD *)(v8 + 288);
          v13 = *(_OWORD *)(v8 + 304);
          v14 = *(_OWORD *)(v8 + 320);
          v11[42] = *(_QWORD *)(v8 + 336);
          *((_OWORD *)v11 + 19) = v13;
          *((_OWORD *)v11 + 20) = v14;
          *((_OWORD *)v11 + 18) = v12;
          re::StringID::destroyString((re::StringID *)(v8 + 272));
          v8 += 344;
          v11 += 43;
        }
        while (v8 != v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

__n128 std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::JobProfilerJobData *,re::internal::JobProfilerJobData *,re::internal::JobProfilerJobData *,0>(__n128 *__src, __n128 *a2, __n128 *__dst)
{
  __n128 *v5;
  __n128 result;
  __n128 v7;
  __n128 v8;

  if (__src != a2)
  {
    v5 = __src;
    do
    {
      memcpy(__dst, v5, 0x110uLL);
      re::StringID::operator=(__dst[17].n128_u64, (uint64_t *)&v5[17]);
      result = v5[18];
      v7 = v5[19];
      v8 = v5[20];
      __dst[21].n128_u64[0] = v5[21].n128_u64[0];
      __dst[19] = v7;
      __dst[20] = v8;
      __dst[18] = result;
      v5 = (__n128 *)((char *)v5 + 344);
      __dst = (__n128 *)((char *)__dst + 344);
    }
    while (v5 != a2);
  }
  return result;
}

_QWORD *re::DynamicArray<re::internal::JobProfilerFiberData>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  re::StringID *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  re::StringID *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::internal::JobProfilerFiberData>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x48uLL))
        {
          v2 = 72 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 72 * a2, 8);
          if (result)
          {
            v7 = (re::StringID *)result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 72, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 72 * v9;
        v11 = v7;
        do
        {
          re::StringID::StringID(v11, (const StringID *)v8);
          v12 = *(_OWORD *)(v8 + 16);
          v13 = *(_OWORD *)(v8 + 32);
          v14 = *(_OWORD *)(v8 + 48);
          *((_DWORD *)v11 + 16) = *(_DWORD *)(v8 + 64);
          *((_OWORD *)v11 + 2) = v13;
          *((_OWORD *)v11 + 3) = v14;
          *((_OWORD *)v11 + 1) = v12;
          re::StringID::destroyString((re::StringID *)v8);
          v8 += 72;
          v11 = (re::StringID *)((char *)v11 + 72);
          v10 -= 72;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

__n128 std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::JobProfilerFiberData *,re::internal::JobProfilerFiberData *,re::internal::JobProfilerFiberData *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  __n128 result;
  __int128 v7;
  __int128 v8;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      re::StringID::operator=((unint64_t *)a3, (uint64_t *)v5);
      result = *(__n128 *)(v5 + 16);
      v7 = *(_OWORD *)(v5 + 32);
      v8 = *(_OWORD *)(v5 + 48);
      *(_DWORD *)(a3 + 64) = *(_DWORD *)(v5 + 64);
      *(_OWORD *)(a3 + 32) = v7;
      *(_OWORD *)(a3 + 48) = v8;
      *(__n128 *)(a3 + 16) = result;
      v5 += 72;
      a3 += 72;
    }
    while (v5 != a2);
  }
  return result;
}

uint64_t re::DynamicArray<re::internal::JobProfilerJobData>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  re::StringID *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::internal::JobProfilerJobData>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    v6 = a2[2];
    if (v6 >= *(_QWORD *)(a1 + 16))
    {
      re::DynamicArray<re::internal::JobProfilerJobData>::setCapacity((_QWORD *)a1, a2[2]);
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::JobProfilerJobData *,re::internal::JobProfilerJobData *,re::internal::JobProfilerJobData *,0>((__n128 *)a2[4], (__n128 *)(a2[4] + 344 * *(_QWORD *)(a1 + 16)), *(__n128 **)(a1 + 32));
      v10 = *(_QWORD *)(a1 + 16);
      if (v10 != v6)
      {
        v11 = a2[4];
        v12 = v11 + 344 * v6;
        v13 = 344 * v10;
        v14 = v11 + v13;
        v15 = *(_QWORD *)(a1 + 32) + v13;
        do
        {
          memcpy((void *)v15, (const void *)v14, 0x110uLL);
          re::StringID::StringID((re::StringID *)(v15 + 272), (const StringID *)(v14 + 272));
          v16 = *(_OWORD *)(v14 + 288);
          v17 = *(_OWORD *)(v14 + 304);
          v18 = *(_OWORD *)(v14 + 320);
          *(_QWORD *)(v15 + 336) = *(_QWORD *)(v14 + 336);
          *(_OWORD *)(v15 + 304) = v17;
          *(_OWORD *)(v15 + 320) = v18;
          *(_OWORD *)(v15 + 288) = v16;
          v14 += 344;
          v15 += 344;
        }
        while (v14 != v12);
      }
    }
    else
    {
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::internal::JobProfilerJobData *,re::internal::JobProfilerJobData *,re::internal::JobProfilerJobData *,0>((__n128 *)a2[4], (__n128 *)(a2[4] + 344 * v6), *(__n128 **)(a1 + 32));
      v7 = *(_QWORD *)(a1 + 16);
      if (v6 != v7)
      {
        v8 = -344 * v6 + 344 * v7;
        v9 = (re::StringID *)(344 * v6 + *(_QWORD *)(a1 + 32) + 272);
        do
        {
          re::StringID::destroyString(v9);
          v9 = (re::StringID *)((char *)v9 + 344);
          v8 -= 344;
        }
        while (v8);
      }
    }
    *(_QWORD *)(a1 + 16) = v6;
  }
  return a1;
}

uint64_t re::DynamicArray<re::internal::JobProfilerThreadData>::deinit(uint64_t a1)
{
  uint64_t result;
  re::StringID *v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(re::StringID **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 80 * v4;
        do
        {
          re::StringID::destroyString(v3);
          v3 = (re::StringID *)((char *)v3 + 80);
          v5 -= 80;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(re::StringID **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, re::StringID *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::internal::JobProfilerJobData>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  re::StringID *v6;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 344 * v4;
        v6 = (re::StringID *)(v3 + 272);
        do
        {
          re::StringID::destroyString(v6);
          v6 = (re::StringID *)((char *)v6 + 344);
          v5 -= 344;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::internal::JobProfilerFiberData>::deinit(uint64_t a1)
{
  uint64_t result;
  re::StringID *v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(re::StringID **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 72 * v4;
        do
        {
          re::StringID::destroyString(v3);
          v3 = (re::StringID *)((char *)v3 + 72);
          v5 -= 72;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(re::StringID **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, re::StringID *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::internal::Fiber::initStack(re::internal::Fiber *this, uint64_t a2)
{
  unsigned __int8 v3;
  _QWORD *v4;
  uint64_t v5;
  size_t v6;
  uint64_t result;
  int v8;
  uint64_t v9;
  void *memptr;

  v4 = &re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
  if ((v3 & 1) == 0)
  {
    v9 = a2;
    v4 = (_QWORD *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
    a2 = v9;
    if (v8)
    {
      v4 = (_QWORD *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
      a2 = v9;
    }
  }
  v5 = v4[491];
  v6 = (a2 + v5 - 1) & -v5;
  *((_QWORD *)this + 6) = v6;
  memptr = 0;
  result = malloc_type_posix_memalign(&memptr, (v5 + 7) & 0xFFFFFFFFFFFFFFF8, v6, 0xC75C8B65uLL);
  *((_QWORD *)this + 5) = memptr;
  return result;
}

void `anonymous namespace'::fiberEntryPoint(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a2[1];
  *a2 = a1;
  a2[1] = 0;
  (*(void (**)(_QWORD))(v2 + 24))(*(_QWORD *)(v2 + 32));
  re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) Fiber ended without transferring control back to another fiber.", "!\"Unreachable code\"", "fiberEntryPoint", 169);
  _os_crash();
  __break(1u);
}

void DispatchJobManager::~DispatchJobManager(DispatchJobManager *this)
{
  JUMPOUT(0x2276933B8);
}

void DispatchJobManager::currentWorkerThreadIndex(DispatchJobManager *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Not Implemented", "!\"Unreachable code\"", "currentWorkerThreadIndex", 23);
  _os_crash();
  __break(1u);
}

void DispatchJobManager::run(dispatch_queue_t *this, re::Job *a2)
{
  unsigned int v5;

  DispatchJobManager::runAsync((uint64_t)this, (uint64_t)a2, 1u, &v5);
  while (atomic_load(&v5))
    dispatch_sync(this[1], &__block_literal_global_44);
}

void DispatchJobManager::runAsync(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int *a4)
{
  uint64_t v4;
  uint64_t v6;
  unsigned int **v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  _QWORD block[5];

  v4 = a2;
  if (a4)
  {
    *a4 = a3;
    if (!a3)
      return;
    v6 = a3;
    v7 = (unsigned int **)(a2 + 8);
    do
    {
      *v7 = a4;
      v7 += 8;
      --v6;
    }
    while (v6);
  }
  if (a3)
  {
    v8 = a3;
    v9 = MEMORY[0x24BDAC760];
    do
    {
      v10 = *(NSObject **)(a1 + 8);
      block[0] = v9;
      block[1] = 0x40000000;
      block[2] = ___ZN18DispatchJobManager8runAsyncEPN2re3JobEjPNSt3__16atomicIiEEb_block_invoke;
      block[3] = &__block_descriptor_tmp_35;
      block[4] = v4;
      dispatch_async(v10, block);
      v4 += 64;
      --v8;
    }
    while (v8);
  }
}

void DispatchJobManager::waitFor(uint64_t a1, unsigned int *a2)
{
  while (atomic_load(a2))
    dispatch_sync(*(dispatch_queue_t *)(a1 + 8), &__block_literal_global_44);
}

uint64_t ___ZN18DispatchJobManager8runAsyncEPN2re3JobEjPNSt3__16atomicIiEEb_block_invoke(uint64_t a1)
{
  uint64_t result;
  unsigned int *v3;
  unsigned int v4;

  result = (**(uint64_t (***)(void))(a1 + 32))();
  v3 = *(unsigned int **)(*(_QWORD *)(a1 + 32) + 8);
  if (v3)
  {
    do
      v4 = __ldxr(v3);
    while (__stlxr(v4 - 1, v3));
  }
  return result;
}

uint64_t DispatchJobManager::numberOfThreads(DispatchJobManager *this)
{
  return 4;
}

uint64_t DispatchJobManager::profiler(DispatchJobManager *this)
{
  return 0;
}

uint64_t DispatchJobManager::highPriorityAndQOSOptout(DispatchJobManager *this)
{
  return 0;
}

void re::internal::setThreadPriority(_opaque_pthread_t *this, _opaque_pthread_t *a2)
{
  int v2;
  re *v3;
  NSObject *v4;
  sched_param v5;
  uint8_t buf[4];
  int v7;
  uint64_t v8;

  v2 = (int)a2;
  v8 = *MEMORY[0x24BDAC8D0];
  *(_DWORD *)v5.__opaque = 0;
  v5.sched_priority = (int)a2;
  v3 = (re *)pthread_setschedparam(this, 2, &v5);
  if ((_DWORD)v3 == -1)
  {
    v4 = *re::foundationThreadingLogObjects(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      v7 = v2;
      _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEFAULT, "Failed to change thread to priority to %d", buf, 8u);
    }
  }
}

re::BackgroundTaskManager *re::BackgroundTaskManager::BackgroundTaskManager(re::BackgroundTaskManager *this)
{
  _anonymous_namespace_ *v2;
  _anonymous_namespace_ *v3;
  _anonymous_namespace_ *v4;

  *(_QWORD *)this = &off_24ED88F98;
  *((_DWORD *)this + 2) = 0;
  v2 = (_anonymous_namespace_ *)re::DataArray<re::BackgroundTask>::DataArray((uint64_t)this + 16, 100);
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  *((_QWORD *)this + 10) = 0;
  v3 = (_anonymous_namespace_ *)re::DynamicArray<float *>::setCapacity((_QWORD *)this + 10, 0x64uLL);
  ++*((_DWORD *)this + 26);
  *((_QWORD *)this + 20) = 0;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((_DWORD *)this + 38) = 0;
  v4 = (_anonymous_namespace_ *)re::DynamicArray<float *>::setCapacity((_QWORD *)this + 16, 0x64uLL);
  ++*((_DWORD *)this + 38);
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 23) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_QWORD *)this + 21) = 0;
  re::DynamicArray<float *>::setCapacity((_QWORD *)this + 21, 0x64uLL);
  ++*((_DWORD *)this + 48);
  return this;
}

void re::BackgroundTaskManager::~BackgroundTaskManager(re::BackgroundTaskManager *this)
{
  unint64_t v1;
  re::BackgroundTaskManager *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  dispatch_time_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  unint64_t v35;
  __int16 v36;
  unint64_t v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;

  v2 = this;
  v43 = *MEMORY[0x24BDAC8D0];
  re::BackgroundTaskManager::update(this);
  v3 = *((_QWORD *)v2 + 18);
  if (v3)
  {
    v4 = (uint64_t *)*((_QWORD *)v2 + 20);
    v5 = 8 * v3;
    do
    {
      v6 = *v4++;
      atomic_store(1u, (unsigned __int8 *)(v6 + 80));
      v5 -= 8;
    }
    while (v5);
  }
  v7 = atomic_load((unsigned int *)v2 + 2);
  if (v7 >= 1)
  {
    do
    {
      if (*((_QWORD *)v2 + 18))
      {
        v8 = **((_QWORD **)v2 + 20);
        v9 = dispatch_time(0, 8000000);
        dispatch_group_wait(*(dispatch_group_t *)(v8 + 208), v9);
        atomic_load((unsigned int *)(v8 + 72));
        v10 = *((_QWORD *)v2 + 18);
        if (v10)
        {
          v11 = (uint64_t *)*((_QWORD *)v2 + 20);
          v12 = 8 * v10;
          do
          {
            v13 = *v11++;
            atomic_store(1u, (unsigned __int8 *)(v13 + 80));
            v12 -= 8;
          }
          while (v12);
        }
      }
      re::BackgroundTaskManager::update(v2);
      v14 = atomic_load((unsigned int *)v2 + 2);
    }
    while (v14 > 0);
  }
  v15 = (_QWORD *)((char *)v2 + 128);
  v16 = *((_QWORD *)v2 + 21);
  if (v16)
  {
    if (*((_QWORD *)v2 + 25))
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 40))(v16);
    *((_QWORD *)v2 + 25) = 0;
    *((_QWORD *)v2 + 22) = 0;
    *((_QWORD *)v2 + 23) = 0;
    *((_QWORD *)v2 + 21) = 0;
    ++*((_DWORD *)v2 + 48);
  }
  if (*v15)
  {
    if (*((_QWORD *)v2 + 20))
      (*(void (**)(_QWORD))(*(_QWORD *)*v15 + 40))(*v15);
    *((_QWORD *)v2 + 20) = 0;
    *((_QWORD *)v2 + 17) = 0;
    *((_QWORD *)v2 + 18) = 0;
    *v15 = 0;
    ++*((_DWORD *)v2 + 38);
  }
  v17 = *((_QWORD *)v2 + 10);
  if (v17)
  {
    if (*((_QWORD *)v2 + 14))
      (*(void (**)(uint64_t))(*(_QWORD *)v17 + 40))(v17);
    *((_QWORD *)v2 + 14) = 0;
    *((_QWORD *)v2 + 11) = 0;
    *((_QWORD *)v2 + 12) = 0;
    *((_QWORD *)v2 + 10) = 0;
    ++*((_DWORD *)v2 + 26);
  }
  v18 = (_QWORD *)((char *)v2 + 16);
  if (!*((_DWORD *)v2 + 15))
  {
    if (*v18)
    {
      if (*((_QWORD *)v2 + 6))
        (*(void (**)(_QWORD))(*(_QWORD *)*v18 + 40))(*v18);
      *((_QWORD *)v2 + 6) = 0;
      *((_QWORD *)v2 + 3) = 0;
      *((_QWORD *)v2 + 4) = 0;
      *v18 = 0;
      ++*((_DWORD *)v2 + 10);
    }
    return;
  }
  v27 = (_QWORD *)((char *)v2 + 16);
  if (*((_DWORD *)v2 + 14))
  {
    LODWORD(v28) = 0;
    if (!*((_QWORD *)v2 + 4))
      goto LABEL_59;
    v19 = (_QWORD *)((char *)v2 + 16);
    if (!**(_DWORD **)(*((_QWORD *)v2 + 6) + 8))
    {
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v27);
      v19 = v27;
    }
  }
  else
  {
    LODWORD(v28) = -1;
    v19 = (_QWORD *)((char *)v2 + 16);
  }
  v27 = v19;
  v20 = (unsigned __int16)v28;
  if (v18 != v19 || (unsigned __int16)v28 != 0xFFFFLL || (v28 & 0xFFFF0000) != 0xFFFF0000)
  {
    v21 = WORD1(v28);
    do
    {
      v22 = v19[2];
      if (v22 <= v21)
        goto LABEL_58;
      re::DataArray<re::BackgroundTask>::destroy((uint64_t)v2 + 16, ((unint64_t)(*(_DWORD *)(*(_QWORD *)(v19[4] + 16 * v21 + 8) + 4 * v20) & 0xFFFFFF) << 32) | (v21 << 16) | v20);
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v27);
      v19 = v27;
      v20 = (unsigned __int16)v28;
      v21 = WORD1(v28);
    }
    while (v27 != v18 || (unsigned __int16)v28 != 0xFFFFLL || WORD1(v28) != 0xFFFFLL);
  }
  v23 = *((_QWORD *)v2 + 4);
  v21 = v23 - 1;
  if (v23 == 1)
    goto LABEL_49;
  v22 = 16 * v23 - 16;
  do
  {
    if (v23 <= v21)
    {
      v27 = 0;
      v42 = 0u;
      v40 = 0u;
      v41 = 0u;
      v38 = 0u;
      v39 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v30 = 136315906;
      v31 = "operator[]";
      v32 = 1024;
      v33 = 789;
      v34 = 2048;
      v35 = v21;
      v36 = 2048;
      v37 = v23;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_57:
      v27 = 0;
      v42 = 0u;
      v40 = 0u;
      v41 = 0u;
      v38 = 0u;
      v39 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v30 = 136315906;
      v31 = "removeAt";
      v32 = 1024;
      v33 = 931;
      v34 = 2048;
      v35 = v21;
      v36 = 2048;
      v37 = v1;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_58:
      v29 = 0;
      v42 = 0u;
      v40 = 0u;
      v41 = 0u;
      v38 = 0u;
      v39 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v30 = 136315906;
      v31 = "operator[]";
      v32 = 1024;
      v33 = 797;
      v34 = 2048;
      v35 = v21;
      v36 = 2048;
      v37 = v22;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_59:
      v29 = 0;
      v42 = 0u;
      v40 = 0u;
      v41 = 0u;
      v38 = 0u;
      v39 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v30 = 136315906;
      v31 = "operator[]";
      v32 = 1024;
      v33 = 797;
      v34 = 2048;
      v35 = 0;
      v36 = 2048;
      v37 = 0;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v24 = (_QWORD *)(*((_QWORD *)v2 + 6) + v22);
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)v2 + 2) + 40))(*((_QWORD *)v2 + 2), *v24);
    (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)v2 + 2) + 40))(*((_QWORD *)v2 + 2), v24[1]);
    v1 = *((_QWORD *)v2 + 4);
    if (v1 <= v21)
      goto LABEL_57;
    v23 = v1 - 1;
    if (v1 - 1 > v21)
    {
      *(_OWORD *)(*((_QWORD *)v2 + 6) + v22) = *(_OWORD *)(*((_QWORD *)v2 + 6) + 16 * v1 - 16);
      v23 = *((_QWORD *)v2 + 4) - 1;
    }
    *((_QWORD *)v2 + 4) = v23;
    ++*((_DWORD *)v2 + 10);
    v22 -= 16;
    --v21;
  }
  while (v21);
  *((_QWORD *)v2 + 8) = 0xFFFFFFFF00000000;
  if (!v23)
  {
    v27 = 0;
    v42 = 0u;
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    v2 = (re::BackgroundTaskManager *)MEMORY[0x24BDACB70];
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v30 = 136315906;
    v31 = "operator[]";
    v32 = 1024;
    v33 = 789;
    v34 = 2048;
    v35 = 0;
    v36 = 2048;
    v37 = 0;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_49:
    *((_QWORD *)v2 + 8) = 0xFFFFFFFF00000000;
  }
  v25 = (_QWORD *)*((_QWORD *)v2 + 6);
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)v2 + 2) + 40))(*((_QWORD *)v2 + 2), *v25);
  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)v2 + 2) + 40))(*((_QWORD *)v2 + 2), v25[1]);
  v26 = *((_QWORD *)v2 + 2);
  if (v26)
  {
    if (*((_QWORD *)v2 + 6))
      (*(void (**)(uint64_t))(*(_QWORD *)v26 + 40))(v26);
    *((_QWORD *)v2 + 6) = 0;
    v18[1] = 0;
    v18[2] = 0;
    *v18 = 0;
    ++*((_DWORD *)v2 + 10);
  }
  *((_DWORD *)v2 + 15) = 0;
}

{
  re::BackgroundTaskManager::~BackgroundTaskManager(this);
  JUMPOUT(0x2276933B8);
}

void re::BackgroundTaskManager::update(re::BackgroundTaskManager *this)
{
  unsigned int *v1;
  unint64_t v2;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unsigned __int8 v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  unint64_t v33;
  __int16 v34;
  unsigned int *v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  if ((int)*((_QWORD *)this + 23) >= 1)
  {
    v4 = *((_QWORD *)this + 23) + 1;
    do
    {
      v5 = (v4 - 2);
      v6 = *((_QWORD *)this + 23);
      if (v6 <= v5)
      {
        v27 = 0;
        v39 = 0u;
        v40 = 0u;
        v37 = 0u;
        v38 = 0u;
        v36 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v28 = 136315906;
        v29 = "operator[]";
        v30 = 1024;
        v31 = 789;
        v32 = 2048;
        v33 = (v4 - 2);
        v34 = 2048;
        v35 = (unsigned int *)v6;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_34:
        v27 = 0;
        v39 = 0u;
        v40 = 0u;
        v37 = 0u;
        v38 = 0u;
        v36 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v28 = 136315906;
        v29 = "removeStableAt";
        v30 = 1024;
        v31 = 969;
        v32 = 2048;
        v33 = v2;
        v34 = 2048;
        v35 = (unsigned int *)v5;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_35:
        v27 = 0;
        v39 = 0u;
        v40 = 0u;
        v37 = 0u;
        v38 = 0u;
        v36 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v28 = 136315906;
        v29 = "removeAt";
        v30 = 1024;
        v31 = 931;
        v32 = 2048;
        v33 = v5;
        v34 = 2048;
        v35 = v1;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v7 = *(_QWORD *)(*((_QWORD *)this + 25) + 8 * v5);
      v8 = atomic_load((unsigned __int8 *)(v7 + 81));
      if ((v8 & 1) != 0)
      {
        v1 = (unsigned int *)*((_QWORD *)this + 23);
        if ((unint64_t)v1 <= v5)
          goto LABEL_35;
        if ((unint64_t)v1 - 1 > v5)
          *(_QWORD *)(*((_QWORD *)this + 25) + 8 * v5) = *(_QWORD *)(*((_QWORD *)this + 25) + 8 * (_QWORD)v1 - 8);
        *((_QWORD *)this + 23) = (char *)v1 - 1;
        ++*((_DWORD *)this + 48);
        os_unfair_lock_lock((os_unfair_lock_t)this + 30);
        v9 = re::DataArray<re::BackgroundTask>::handle((uint64_t)this + 16, v7);
        re::DataArray<re::BackgroundTask>::destroy((uint64_t)this + 16, v9);
        os_unfair_lock_unlock((os_unfair_lock_t)this + 30);
      }
      --v4;
    }
    while (v4 > 1);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 31);
  v10 = *((_QWORD *)this + 12);
  if (v10)
  {
    v11 = (_QWORD *)*((_QWORD *)this + 14);
    v12 = 8 * v10;
    do
    {
      re::DynamicArray<re::RigDataValue *>::add((re::BackgroundTaskManager *)((char *)this + 128), v11++);
      v12 -= 8;
    }
    while (v12);
  }
  *((_QWORD *)this + 12) = 0;
  ++*((_DWORD *)this + 26);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 31);
  if (*((_QWORD *)this + 18))
  {
    v2 = 0;
    v13 = 0;
    v1 = (unsigned int *)((char *)this + 8);
    do
    {
      v26 = *(_QWORD *)(*((_QWORD *)this + 20) + 8 * v2);
      v14 = atomic_load((unsigned int *)(v26 + 72));
      v15 = v26;
      if (v14 == 1)
      {
        re::internal::AutoResetEvent::set((re::internal::AutoResetEvent *)(v26 + 88));
        goto LABEL_31;
      }
      v16 = *(_QWORD *)(v26 + 64);
      if (v16)
      {
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v16 + 48))(v16, v26);
        v17 = *(_QWORD **)(v15 + 64);
        *(_QWORD *)(v15 + 64) = 0;
        if (v17 == (_QWORD *)(v15 + 40))
        {
          v17 = (_QWORD *)(v15 + 40);
          v18 = 4;
          goto LABEL_22;
        }
        if (v17)
        {
          v18 = 5;
LABEL_22:
          (*(void (**)(void))(*v17 + 8 * v18))();
          goto LABEL_23;
        }
      }
      do
LABEL_23:
        v19 = __ldaxr(v1);
      while (__stlxr(v19 - 1, v1));
      v5 = *((_QWORD *)this + 18);
      if (v5 <= v2)
        goto LABEL_34;
      v20 = v5 - 1;
      if (v5 - 1 > v2)
      {
        v21 = *((_QWORD *)this + 20);
        v22 = v21 + 8 * v2;
        v23 = v21 + 8 * v5;
        if (v23 != v22 + 8)
        {
          memmove((void *)v22, (const void *)(v22 + 8), v23 - (v22 + 8));
          v20 = *((_QWORD *)this + 18) - 1;
        }
      }
      *((_QWORD *)this + 18) = v20;
      ++*((_DWORD *)this + 38);
      --v13;
      v24 = atomic_load((unsigned __int8 *)(v26 + 81));
      if ((v24 & 1) != 0)
      {
        os_unfair_lock_lock((os_unfair_lock_t)this + 30);
        v25 = re::DataArray<re::BackgroundTask>::handle((uint64_t)this + 16, v26);
        re::DataArray<re::BackgroundTask>::destroy((uint64_t)this + 16, v25);
        os_unfair_lock_unlock((os_unfair_lock_t)this + 30);
      }
      else
      {
        re::DynamicArray<re::RigDataValue *>::add((re::BackgroundTaskManager *)((char *)this + 168), &v26);
      }
LABEL_31:
      v2 = ++v13;
    }
    while (*((_QWORD *)this + 18) > (unint64_t)v13);
  }
}

uint64_t re::BackgroundTaskManager::tasks(re::BackgroundTaskManager *this)
{
  return *((_QWORD *)this + 20);
}

uint64_t re::BackgroundTaskManager::runAsync(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  __int128 *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v28;
  _BYTE v29[18];
  __int16 v30;
  _BYTE v31[18];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v10 = (unsigned int *)(a1 + 8);
  do
    v11 = __ldaxr(v10);
  while (__stlxr(v11 + 1, v10));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 120));
  v13 = *(_DWORD *)(a1 + 72);
  if ((v13 + 1) >> 24)
    v14 = 1;
  else
    v14 = v13 + 1;
  *(_DWORD *)(a1 + 72) = v14;
  v15 = *(unsigned __int16 *)(a1 + 68);
  v16 = *(unsigned __int16 *)(a1 + 70);
  if (v15 == 0xFFFF && (_DWORD)v16 == 0xFFFF)
  {
    if (*(_DWORD *)(a1 + 64) >= *(_DWORD *)(a1 + 60))
      re::DataArray<re::BackgroundTask>::allocBlock((_QWORD *)(a1 + 16));
    v16 = *(_QWORD *)(a1 + 32);
    v18 = (unsigned __int16)(v16 - 1);
    if (v16 <= v18)
      goto LABEL_31;
    v15 = *(unsigned int *)(a1 + 64);
    if (v15 >= 0x10000)
      goto LABEL_32;
    v20 = (_QWORD *)(*(_QWORD *)(a1 + 48) + 16 * v18);
    *(_DWORD *)(a1 + 64) = v15 + 1;
    *(_DWORD *)(v20[1] + 4 * v15) = *(_DWORD *)(a1 + 72);
    v18 = *v20 + 216 * v15;
    v16 = (v16 - 1);
  }
  else
  {
    v18 = *(_QWORD *)(a1 + 32);
    if (v18 <= v16)
    {
LABEL_30:
      v35 = 0u;
      v36 = 0u;
      v33 = 0u;
      v34 = 0u;
      v32 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v29 = 136315906;
      *(_QWORD *)&v29[4] = "operator[]";
      *(_WORD *)&v29[12] = 1024;
      *(_DWORD *)&v29[14] = 789;
      v30 = 2048;
      *(_QWORD *)v31 = v16;
      *(_WORD *)&v31[8] = 2048;
      *(_QWORD *)&v31[10] = v18;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_31:
      v28 = 0;
      v35 = 0u;
      v36 = 0u;
      v33 = 0u;
      v34 = 0u;
      v32 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v29 = 136315906;
      *(_QWORD *)&v29[4] = "operator[]";
      *(_WORD *)&v29[12] = 1024;
      *(_DWORD *)&v29[14] = 789;
      v30 = 2048;
      *(_QWORD *)v31 = v18;
      *(_WORD *)&v31[8] = 2048;
      *(_QWORD *)&v31[10] = v16;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_32:
      re::internal::assertLog((re::internal *)5, v12, "assertion failure: '%s' (%s:line %i) m_tailBlockLinearAllocationCount (%u) is too large for a 16-bit unsigned integer", "!overflow", "create", 601, v15, v28, *(_QWORD *)v29, *(_QWORD *)&v29[8]);
      _os_crash();
      __break(1u);
    }
    v19 = (_QWORD *)(*(_QWORD *)(a1 + 48) + 16 * v16);
    *(_DWORD *)(v19[1] + 4 * v15) = v14;
    v18 = *v19 + 216 * v15;
    *(_DWORD *)(a1 + 68) = *(_DWORD *)v18;
  }
  ++*(_DWORD *)(a1 + 56);
  std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100]((uint64_t)&v32, a3);
  std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100]((uint64_t)v29, a4);
  re::BackgroundTask::BackgroundTask(v18, a2, (uint64_t)&v32, (uint64_t)v29);
  v21 = *(_QWORD **)&v31[4];
  if (*(_BYTE **)&v31[4] == v29)
  {
    v22 = 4;
    v21 = v29;
  }
  else
  {
    if (!*(_QWORD *)&v31[4])
      goto LABEL_22;
    v22 = 5;
  }
  (*(void (**)(void))(*v21 + 8 * v22))();
LABEL_22:
  v23 = (__int128 *)*((_QWORD *)&v33 + 1);
  if (*((__int128 **)&v33 + 1) == &v32)
  {
    v24 = 4;
    v23 = &v32;
  }
  else
  {
    if (!*((_QWORD *)&v33 + 1))
      goto LABEL_27;
    v24 = 5;
  }
  (*(void (**)(void))(*(_QWORD *)v23 + 8 * v24))();
LABEL_27:
  v25 = *(_QWORD *)(a1 + 32);
  if (v25 <= (unsigned __int16)v16)
  {
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v32 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v29 = 136315906;
    *(_QWORD *)&v29[4] = "operator[]";
    *(_WORD *)&v29[12] = 1024;
    *(_DWORD *)&v29[14] = 797;
    v30 = 2048;
    *(_QWORD *)v31 = (unsigned __int16)v16;
    *(_WORD *)&v31[8] = 2048;
    *(_QWORD *)&v31[10] = v25;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_30;
  }
  *(_QWORD *)v29 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 16 * (unsigned __int16)v16) + 216 * (unsigned __int16)v15;
  v26 = *(_QWORD *)v29;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 120));
  atomic_store(1u, (unsigned int *)(v26 + 72));
  re::dispatch::Queue::global((re::dispatch::Queue *)a5, 0, &v32);
  re::dispatch::Group::async((id *)(v26 + 208), (NSObject **)&v32, (void *)v26, (void (__cdecl *)(void *))re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::__invoke);

  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 124));
  re::DynamicArray<re::RigDataValue *>::add((_anonymous_namespace_ *)(a1 + 80), v29);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 124));
  return v26;
}

void re::BackgroundTaskManager::release(uint64_t a1, uint64_t a2)
{
  atomic_store(1u, (unsigned __int8 *)(a2 + 81));
}

unint64_t re::DataArray<re::BackgroundTask>::handle(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t result;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    v3 = 0;
    v4 = 0;
    v5 = (_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    while (v4 != 0x10000)
    {
      v6 = a2 - *(v5 - 1);
      if (v6 >= -215)
      {
        v7 = 0x84BDA12F684BDA13 * (v6 >> 3);
        if (v7 < *(unsigned int *)(a1 + 44))
          goto LABEL_8;
      }
      ++v4;
      v5 += 2;
      v3 += 0x10000;
      if (v2 == v4)
        goto LABEL_7;
    }
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) blockIndex (%zu) is too large for a 16-bit unsigned integer", "!overflow", "handle", 692, 0x10000);
    _os_crash();
    __break(1u);
  }
  else
  {
LABEL_7:
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) element isn't in data array", "!\"Unreachable code\"", "handle", 707);
    _os_crash();
    __break(1u);
LABEL_8:
    if (v7 < 0x10000)
      return v3 & 0xFFFF0000 | ((unint64_t)(*(_DWORD *)(*v5 + 4 * v7) & 0xFFFFFF) << 32) | v7;
  }
  re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) arrayIndex (%zu) is too large for a 16-bit unsigned integer", "!overflow", "handle", 700, v7);
  result = _os_crash();
  __break(1u);
  return result;
}

void re::DataArray<re::BackgroundTask>::destroy(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v11;
  _DWORD *v12;

  v2 = WORD1(a2);
  v3 = *(_QWORD *)(a1 + 16);
  if (WORD1(a2) < v3)
  {
    v4 = a2;
    v6 = (unsigned __int16)(v3 - 1) == WORD1(a2) ? *(_DWORD *)(a1 + 48) : *(_DWORD *)(a1 + 44);
    if ((unsigned __int16)a2 < v6)
    {
      v7 = (unsigned __int16)a2;
      v8 = *(_QWORD *)(a1 + 32);
      v9 = *(_DWORD *)(*(_QWORD *)(v8 + 16 * WORD1(a2) + 8) + 4 * (unsigned __int16)a2);
      if (v9 && v9 == (HIDWORD(a2) & 0xFFFFFF))
      {
        v11 = *(_QWORD *)(v8 + 16 * WORD1(a2));
        if (v11)
        {
          re::BackgroundTask::~BackgroundTask((re::BackgroundTask *)(v11 + 216 * (unsigned __int16)a2));
          if (*(_QWORD *)(a1 + 16) <= v2)
          {
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * v2 + 8) + 4 * v7) = 0;
          *v12 = *(_DWORD *)(a1 + 52);
          *(_DWORD *)(a1 + 52) = v4;
          --*(_DWORD *)(a1 + 40);
        }
      }
    }
  }
}

_QWORD *re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::__invoke(_QWORD *result)
{
  unsigned int *v1;
  unsigned __int8 v2;
  uint64_t v3;
  unsigned int v4;
  int v5;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v1 = (unsigned int *)result;
  v8 = *MEMORY[0x24BDAC8D0];
  v2 = atomic_load((unsigned __int8 *)result + 80);
  if ((v2 & 1) != 0)
  {
    atomic_store(3u, (unsigned int *)result + 18);
    return result;
  }
  v5 = 0;
  v6[0] = &off_24ED88FF8;
  v6[1] = result;
  v6[2] = &v5;
  v7 = v6;
  re::runInLocalAutoreleasePool((uint64_t)v6);
  result = v7;
  if (v7 == v6)
  {
    v3 = 4;
    result = v6;
    goto LABEL_7;
  }
  if (v7)
  {
    v3 = 5;
LABEL_7:
    result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v3))();
  }
  if (v5)
  {
    v4 = 3;
  }
  else
  {
    atomic_store(0x3F800000u, v1 + 19);
    v4 = 2;
  }
  atomic_store(v4, v1 + 18);
  return result;
}

void std::__function::__func<re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::operator() const(void *)::{lambda(void)#1},std::allocator<re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::operator() const(void *)::{lambda(void)#1}>,void ()(void)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

__n128 std::__function::__func<re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::operator() const(void *)::{lambda(void)#1},std::allocator<re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::operator() const(void *)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24ED88FF8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::operator() const(void *)::{lambda(void)#1},std::allocator<re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::operator() const(void *)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED88FF8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::operator() const(void *)::{lambda(void)#1},std::allocator<re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::operator() const(void *)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32);
  if (v2)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    **(_DWORD **)(a1 + 16) = result;
  }
  else
  {
    v4 = std::__throw_bad_function_call[abi:nn180100]();
    return std::__function::__func<re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::operator() const(void *)::{lambda(void)#1},std::allocator<re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::operator() const(void *)::{lambda(void)#1}>,void ()(void)>::target(v4);
  }
  return result;
}

uint64_t std::__function::__func<re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::operator() const(void *)::{lambda(void)#1},std::allocator<re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::operator() const(void *)::{lambda(void)#1}>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::operator() const(void *)::{lambda(void)#1},std::allocator<re::BackgroundTaskManager::start(re::BackgroundTask *,qos_class_t)::$_0::operator() const(void *)::{lambda(void)#1}>,void ()(void)>::target_type()
{
}

uint64_t re::DataArray<re::BackgroundTask>::DataArray(uint64_t a1, int a2)
{
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 52) = 0x1FFFFFFFFLL;
  re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)a1, 0);
  ++*(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 44) = a2;
  re::DataArray<re::BackgroundTask>::allocBlock((_QWORD *)a1);
  return a1;
}

_anonymous_namespace_ *re::DataArray<re::BackgroundTask>::allocBlock(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _anonymous_namespace_ *result;
  uint64_t v8;
  _anonymous_namespace_ *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;

  v3 = 216 * *((unsigned int *)a1 + 11);
  v4 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, v3, 0);
  if (!v4)
  {
    re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.elements", "allocBlock", 520, v3, *(_QWORD *)(*a1 + 8));
    _os_crash();
    __break(1u);
    goto LABEL_16;
  }
  v6 = v4;
  v1 = 4 * *((unsigned int *)a1 + 11);
  result = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(*(_QWORD *)*a1 + 32))(*a1, v1, 0);
  if (!result)
  {
LABEL_16:
    re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) DataArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "block.allocationCounters", "allocBlock", 528, v1, *(_QWORD *)(*a1 + 8));
    result = (_anonymous_namespace_ *)_os_crash();
    __break(1u);
    return result;
  }
  v9 = result;
  v11 = a1[1];
  v10 = a1[2];
  if (v10 >= v11)
  {
    v12 = v10 + 1;
    if (v11 < v10 + 1)
    {
      if (*a1)
      {
        v13 = 2 * v11;
        if (!v11)
          v13 = 8;
        if (v13 <= v12)
          v14 = v12;
        else
          v14 = v13;
        result = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstraint>::setCapacity(a1, v14);
      }
      else
      {
        result = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstraint>::setCapacity(a1, v12);
        ++*((_DWORD *)a1 + 6);
      }
    }
    v10 = a1[2];
  }
  v15 = (uint64_t *)(a1[4] + 16 * v10);
  *v15 = v6;
  v15[1] = (uint64_t)v9;
  a1[2] = v10 + 1;
  ++*((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 12) = 0;
  return result;
}

void re::FiberJobManager::init(re::FiberJobManager *this, unsigned int a2, unsigned int a3, unint64_t a4, int a5, re::Allocator *a6, re::AlignedAllocator *a7)
{
  unsigned int v12;
  re::FiberJobManager *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t *v25;
  uint64_t v26;
  unint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  _DWORD *v30;
  unint64_t v31;
  unint64_t v32;
  int v33;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  _QWORD *v44;
  unint64_t v45;
  uint64_t v46;
  uint8_t buf[32];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;

  v12 = a2;
  v13 = this;
  v51 = *MEMORY[0x24BDAC8D0];
  if (!a2)
  {
    v14 = *re::foundationThreadingLogObjects(this);
    this = (re::FiberJobManager *)os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)this)
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = 0;
      _os_log_impl(&dword_224FE9000, v14, OS_LOG_TYPE_DEFAULT, "Thread count %d is too small, jobservice will create one thread", buf, 8u);
    }
    v12 = 1;
  }
  if (v12 >= a3)
  {
    v15 = *re::foundationThreadingLogObjects(this);
    this = (re::FiberJobManager *)os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    if ((this & 1) != 0)
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = a3;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v12 + 1;
      _os_log_impl(&dword_224FE9000, v15, OS_LOG_TYPE_DEFAULT, "Fiber count %d is too small, jobservice will create %d fibers", buf, 0xEu);
    }
    a3 = v12 + 1;
  }
  if (a4 <= 0x3FF)
  {
    v16 = *re::foundationThreadingLogObjects(this);
    this = (re::FiberJobManager *)os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
    if (!(_DWORD)this)
    {
      a4 = 1024;
      if (a6)
        goto LABEL_15;
      goto LABEL_14;
    }
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)&buf[4] = a4;
    *(_WORD *)&buf[12] = 2048;
    a4 = 1024;
    *(_QWORD *)&buf[14] = 1024;
    _os_log_impl(&dword_224FE9000, v16, OS_LOG_TYPE_DEFAULT, "Fiber stack size %zu is too small, jobservice will create fibers stasks of size %zu", buf, 0x16u);
  }
  if (!a6)
  {
LABEL_14:
    this = (re::FiberJobManager *)re::globalAllocators(this);
    a6 = (re::Allocator *)*((_QWORD *)this + 2);
  }
LABEL_15:
  *((_QWORD *)v13 + 1) = a6;
  if (!a7)
  {
    a7 = (re::AlignedAllocator *)re::globalAllocators(this)[4];
    a6 = (re::Allocator *)*((_QWORD *)v13 + 1);
  }
  *((_QWORD *)v13 + 2) = a7;
  atomic_store(1uLL, (unint64_t *)v13 + 16);
  atomic_store(1uLL, (unint64_t *)v13 + 24);
  v17 = (*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a6 + 32))(a6, 32, 8);
  *(_OWORD *)v17 = 0u;
  *(_OWORD *)(v17 + 16) = 0u;
  re::FixedArray<unsigned long>::init<>((uint64_t *)v17, (uint64_t)a6, 0x80uLL);
  *((_QWORD *)v13 + 32) = v17;
  v18 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)v13 + 1) + 32))(*((_QWORD *)v13 + 1), 224, 8);
  *(_QWORD *)v18 = 0;
  *(_QWORD *)(v18 + 8) = 0;
  *(_QWORD *)(v18 + 16) = &str_110;
  *(_DWORD *)(v18 + 24) = -1;
  *(_QWORD *)(v18 + 36) = 0;
  *(_QWORD *)(v18 + 28) = 0;
  *(_OWORD *)(v18 + 48) = 0u;
  *(_OWORD *)(v18 + 64) = 0u;
  *(_OWORD *)(v18 + 80) = 0u;
  *(_OWORD *)(v18 + 96) = 0u;
  *(_OWORD *)(v18 + 112) = 0u;
  *(_OWORD *)(v18 + 128) = 0u;
  *(_OWORD *)(v18 + 144) = 0u;
  *(_OWORD *)(v18 + 160) = 0u;
  *(_OWORD *)(v18 + 176) = 0u;
  *(_DWORD *)(v18 + 192) = 0;
  *(_QWORD *)(v18 + 196) = 0x7FFFFFFFLL;
  *(_QWORD *)(v18 + 208) = 0;
  *(_BYTE *)(v18 + 216) = 0;
  *(_DWORD *)(v18 + 220) = 0;
  *((_QWORD *)v13 + 3) = v18;
  v19 = *((_QWORD *)v13 + 1);
  *((_QWORD *)v13 + 41) = v19;
  *((_QWORD *)v13 + 42) = a3;
  if (a3)
  {
    v20 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)v19 + 32))(v19, (unint64_t)a3 << 7, 64);
    *((_QWORD *)v13 + 43) = v20;
    if (!v20)
      goto LABEL_57;
    v22 = a3 - 1;
    if (a3 != 1)
    {
      do
      {
        *(_DWORD *)v20 = -1;
        *(_OWORD *)(v20 + 64) = 0uLL;
        *(_OWORD *)(v20 + 80) = 0uLL;
        *(_OWORD *)(v20 + 96) = 0uLL;
        *(_QWORD *)(v20 + 112) = 0;
        v20 += 128;
        --v22;
      }
      while (v22);
    }
    *(_DWORD *)v20 = -1;
    *(_OWORD *)(v20 + 64) = 0u;
    *(_OWORD *)(v20 + 80) = 0u;
    *(_OWORD *)(v20 + 96) = 0u;
    *(_QWORD *)(v20 + 112) = 0;
    v23 = *((_QWORD *)v13 + 42);
    if (v23)
    {
      v24 = v23 << 7;
      v25 = (unint64_t *)(*((_QWORD *)v13 + 43) + 64);
      do
      {
        re::internal::Fiber::initStack((re::internal::Fiber *)v25, a4);
        v25[3] = (unint64_t)re::FiberJobManager::fiberFunction;
        v25[4] = (unint64_t)v13;
        v25 += 16;
        v24 -= 128;
      }
      while (v24);
    }
    v26 = a3 - 1;
    if ((int)(a3 - 1) >= 0)
    {
      v27 = (unint64_t *)((char *)v13 + 384);
      while (1)
      {
        v28 = *((_QWORD *)v13 + 43);
        v29 = atomic_load(v27);
        v30 = (_DWORD *)(v28 + (v26 << 7));
        *v30 = v29;
        v31 = __ldaxr(v27);
        if (v31 != v29)
          break;
        if (__stlxr(v29 & 0xFFFFFFFF00000000 | v26, v27))
          goto LABEL_30;
LABEL_36:
        if (v26-- <= 0)
          goto LABEL_38;
      }
      __clrex();
LABEL_30:
      while (1)
      {
        *v30 = v31;
        v32 = __ldaxr(v27);
        if (v32 != v31)
          break;
        if (__stlxr(v31 & 0xFFFFFFFF00000000 | v26, v27))
          goto LABEL_34;
        v33 = 1;
LABEL_35:
        v31 = v32;
        if (v33)
          goto LABEL_36;
      }
      __clrex();
LABEL_34:
      v33 = 0;
      goto LABEL_35;
    }
  }
LABEL_38:
  *((_QWORD *)v13 + 57) = *((_QWORD *)v13 + 1);
  re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)v13 + 57, a3);
  ++*((_DWORD *)v13 + 120);
  atomic_store(0, (unsigned __int8 *)v13 + 32);
  v35 = *((_QWORD *)v13 + 1);
  v36 = v12;
  *((_QWORD *)v13 + 5) = v35;
  *((_QWORD *)v13 + 6) = v12;
  v37 = 8 * v12;
  v38 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v35 + 32))(v35, v37, 8);
  *((_QWORD *)v13 + 7) = v38;
  if (!v38)
    goto LABEL_55;
  v40 = v38;
  if (v12 != 1)
  {
    bzero(v38, v37 - 8);
    v40 = (_QWORD *)((char *)v40 + v37 - 8);
  }
  *v40 = 0;
  v41 = *((_QWORD *)v13 + 1);
  *((_QWORD *)v13 + 8) = v41;
  *((_QWORD *)v13 + 9) = v12;
  v42 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v41 + 32))(v41, 8 * v12, 8);
  *((_QWORD *)v13 + 10) = v42;
  if (!v42)
    goto LABEL_56;
  v44 = v42;
  if (v12 != 1)
  {
    bzero(v42, v37 - 8);
    v44 = (_QWORD *)((char *)v44 + v37 - 8);
  }
  v45 = 0;
  *v44 = 0;
  *((_BYTE *)v13 + 320) = a5;
  do
  {
    v46 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)v13 + 2) + 32))(*((_QWORD *)v13 + 2), 512, 64);
    *(_QWORD *)v46 = 0;
    *(_QWORD *)(v46 + 8) = 0;
    *(_OWORD *)(v46 + 24) = 0u;
    *(_OWORD *)(v46 + 40) = 0u;
    *(_OWORD *)(v46 + 56) = 0u;
    *(_QWORD *)(v46 + 72) = 0;
    *(_QWORD *)(v46 + 80) = 0xFFFFFFFFLL;
    *(_QWORD *)(v46 + 88) = 0;
    *(_DWORD *)(v46 + 96) = -1;
    *(_QWORD *)(v46 + 136) = 0;
    *(_QWORD *)(v46 + 112) = 0;
    *(_QWORD *)(v46 + 120) = 0;
    *(_QWORD *)(v46 + 104) = 0;
    *(_DWORD *)(v46 + 128) = 0;
    *(_QWORD *)(v46 + 320) = 0;
    *(_DWORD *)(v46 + 384) = -1;
    *(_BYTE *)(v46 + 392) = 0;
    *(_QWORD *)(v46 + 400) = 850045863;
    *(_OWORD *)(v46 + 424) = 0u;
    *(_OWORD *)(v46 + 440) = 0u;
    *(_OWORD *)(v46 + 408) = 0u;
    *(_QWORD *)(v46 + 456) = 0;
    *(_QWORD *)(v46 + 464) = 1018212795;
    *(_OWORD *)(v46 + 472) = 0u;
    *(_OWORD *)(v46 + 488) = 0u;
    *(_QWORD *)(v46 + 504) = 0;
    if (*((_QWORD *)v13 + 9) <= v45)
    {
      v49 = 0uLL;
      v50 = 0uLL;
      v48 = 0uLL;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_53:
      v49 = 0u;
      v50 = 0u;
      v48 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_54:
      v49 = 0u;
      v50 = 0u;
      v48 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_55:
      re::internal::assertLog((re::internal *)4, v39, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
LABEL_56:
      re::internal::assertLog((re::internal *)4, v43, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
LABEL_57:
      re::internal::assertLog((re::internal *)4, v21, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
    }
    *(_QWORD *)(*((_QWORD *)v13 + 10) + 8 * v45) = v46;
    re::internal::WorkerThread::init(*(re::internal::WorkerThread **)(*((_QWORD *)v13 + 10) + 8 * v45), v13, a5, v45, *((re::AlignedAllocator **)v13 + 2));
    if (*((_QWORD *)v13 + 9) <= v45)
      goto LABEL_53;
    if (*((_QWORD *)v13 + 6) <= v45)
      goto LABEL_54;
    *(_QWORD *)(*((_QWORD *)v13 + 7) + 8 * v45) = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)v13 + 10) + 8 * v45) + 8);
    ++v45;
  }
  while (v36 != v45);
}

void re::FiberJobManager::~FiberJobManager(re::FiberJobManager *this)
{
  uint64_t *v2;
  uint64_t v3;
  unint64_t *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  re::internal::WorkerThread *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v2 = (uint64_t *)((char *)this + 8);
  if (*((_QWORD *)this + 1))
  {
    atomic_store(1u, (unsigned __int8 *)this + 32);
    v4 = (unint64_t *)((char *)this + 72);
    v3 = *((_QWORD *)this + 9);
    if (v3)
    {
      v5 = (uint64_t *)*((_QWORD *)this + 10);
      v6 = 8 * v3;
      do
      {
        v7 = *v5++;
        re::internal::AutoResetEvent::set((re::internal::AutoResetEvent *)(v7 + 392));
        v6 -= 8;
      }
      while (v6);
      v8 = *v4;
      if (*v4)
      {
        v9 = 0;
        while (*v4 > v9)
        {
          std::thread::join((std::thread *)(*(_QWORD *)(*((_QWORD *)this + 10) + 8 * v9++) + 8));
          if (v8 == v9)
          {
            v10 = 0;
            while (*v4 > v10)
            {
              v11 = *(re::internal::WorkerThread **)(*((_QWORD *)this + 10) + 8 * v10);
              v12 = *((_QWORD *)this + 2);
              re::internal::WorkerThread::~WorkerThread(v11);
              __dmb(0xBu);
              v13 = *(_QWORD *)(v12 + 88);
              if (v13)
                (*(void (**)(uint64_t, re::internal::WorkerThread *))(*(_QWORD *)v13 + 40))(v13, v11);
              else
                free(v11);
              if (v8 == ++v10)
                goto LABEL_15;
            }
LABEL_44:
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
        }
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_44;
      }
    }
LABEL_15:
    v14 = *((_QWORD *)this + 8);
    if (v14)
    {
      if (*v4)
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v14 + 40))(v14, *((_QWORD *)this + 10));
        *v4 = 0;
        *((_QWORD *)this + 10) = 0;
      }
      *((_QWORD *)this + 8) = 0;
    }
    v15 = *((_QWORD *)this + 5);
    if (v15)
    {
      if (*((_QWORD *)this + 6))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 40))(v15, *((_QWORD *)this + 7));
        *((_QWORD *)this + 6) = 0;
        *((_QWORD *)this + 7) = 0;
      }
      *((_QWORD *)this + 5) = 0;
    }
    v16 = *((_QWORD *)this + 57);
    if (v16)
    {
      if (*((_QWORD *)this + 61))
        (*(void (**)(uint64_t))(*(_QWORD *)v16 + 40))(v16);
      *((_QWORD *)this + 61) = 0;
      *((_QWORD *)this + 58) = 0;
      *((_QWORD *)this + 59) = 0;
      *((_QWORD *)this + 57) = 0;
      ++*((_DWORD *)this + 120);
    }
    atomic_store(0xFFFFFFFFuLL, (unint64_t *)this + 48);
    re::FixedArray<re::FiberJobManager::FiberNode>::deinit((_QWORD *)this + 41);
    re::JobProfiler::deinit(*((re::JobProfiler **)this + 3));
    v17 = *((_QWORD *)this + 3);
    if (v17)
    {
      v18 = *v2;
      re::JobProfiler::~JobProfiler(*((re::JobProfiler **)this + 3));
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v18 + 40))(v18, v17);
    }
    *((_QWORD *)this + 3) = 0;
    re::WorkStealingQueue<re::Job *>::deinit((uint64_t)this + 128);
    *v2 = 0;
    v2[1] = 0;
  }
  v19 = *((_QWORD *)this + 57);
  if (v19)
  {
    if (*((_QWORD *)this + 61))
      (*(void (**)(uint64_t))(*(_QWORD *)v19 + 40))(v19);
    *((_QWORD *)this + 61) = 0;
    *((_QWORD *)this + 58) = 0;
    *((_QWORD *)this + 59) = 0;
    *((_QWORD *)this + 57) = 0;
    ++*((_DWORD *)this + 120);
  }
  re::FixedArray<re::FiberJobManager::FiberNode>::deinit((_QWORD *)this + 41);
  re::WorkStealingQueue<re::Job *>::deinit((uint64_t)this + 128);
  v20 = *((_QWORD *)this + 8);
  if (v20)
  {
    if (*((_QWORD *)this + 9))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v20 + 40))(v20, *((_QWORD *)this + 10));
      *((_QWORD *)this + 9) = 0;
      *((_QWORD *)this + 10) = 0;
    }
    *((_QWORD *)this + 8) = 0;
  }
  v21 = *((_QWORD *)this + 5);
  if (v21)
  {
    if (*((_QWORD *)this + 6))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v21 + 40))(v21, *((_QWORD *)this + 7));
      *((_QWORD *)this + 6) = 0;
      *((_QWORD *)this + 7) = 0;
    }
    *((_QWORD *)this + 5) = 0;
  }
}

{
  re::FiberJobManager::~FiberJobManager(this);
  JUMPOUT(0x2276933ACLL);
}

uint64_t re::FiberJobManager::fiberFunction(os_unfair_lock_s *this, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  int WaitingFiber;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  int Job;
  re::Job *v15;
  unsigned int *v16;
  unsigned int v17;
  void *v18;
  NSObject *v19;
  void *v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t result;
  unsigned int v27[2];
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  unint64_t v32;
  __int16 v33;
  unint64_t v34;
  re::Job *v35[2];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;

  v3 = re::FiberJobManager::currentWorkerThread((re::FiberJobManager *)this);
  re::internal::WorkerThread::postFiberSwitch((re::internal::WorkerThread *)v3, v4);
  if ((this[8]._os_unfair_lock_opaque & 1) != 0)
    goto LABEL_30;
  while (1)
  {
    v27[0] = 0;
    WaitingFiber = re::internal::WorkerThread::getWaitingFiber((re::internal::WorkerThread *)v3, v27);
    if (WaitingFiber != 2)
      break;
LABEL_3:
    *(_DWORD *)(v3 + 80) = *(_DWORD *)(v3 + 96);
    *(_DWORD *)(v3 + 84) = 2;
    *(_QWORD *)(v3 + 88) = 0;
    re::internal::WorkerThread::switchToCustomFiber((re::internal::WorkerThread *)v3, v27[0]);
    v3 = re::FiberJobManager::currentWorkerThread((re::FiberJobManager *)this);
    re::internal::WorkerThread::postFiberSwitch((re::internal::WorkerThread *)v3, v6);
LABEL_26:
    if ((this[8]._os_unfair_lock_opaque & 1) != 0)
      goto LABEL_30;
  }
  v7 = WaitingFiber == 1;
  if (!os_unfair_lock_trylock(this + 112))
  {
    v7 = 1;
    goto LABEL_13;
  }
  v8 = *(_QWORD *)&this[118]._os_unfair_lock_opaque;
  if (!v8)
  {
LABEL_11:
    os_unfair_lock_unlock(this + 112);
LABEL_13:
    v35[0] = 0;
    Job = re::internal::WorkerThread::getJob((re::internal::WorkerThread *)v3, v35);
    if (Job == 2)
    {
      v15 = v35[0];
      *(_QWORD *)(re::FiberJobManager::getFiber(*(re::FiberJobManager **)v3, *(_DWORD *)(v3 + 96)) + 16) = v15;
      (*(void (**)(void))v35[0])();
      v16 = (unsigned int *)*((_QWORD *)v35[0] + 1);
      if (v16)
      {
        do
          v17 = __ldxr(v16);
        while (__stlxr(v17 - 1, v16));
      }
      else
      {
        v18 = (void *)*((_QWORD *)v35[0] + 2);
        if (v18)
        {
          v19 = v18;
          v20 = (void *)*((_QWORD *)v35[0] + 2);
          *((_QWORD *)v35[0] + 2) = 0;

          dispatch_semaphore_signal(v19);
        }
      }
      v21 = *(_QWORD *)&this[18]._os_unfair_lock_opaque;
      if (v21)
      {
        v22 = *(uint64_t **)&this[20]._os_unfair_lock_opaque;
        v23 = 8 * v21;
        do
        {
          v24 = *v22++;
          re::internal::AutoResetEvent::set((re::internal::AutoResetEvent *)(v24 + 392));
          v23 -= 8;
        }
        while (v23);
      }
      v3 = re::FiberJobManager::currentWorkerThread((re::FiberJobManager *)this);
      *(_QWORD *)(re::FiberJobManager::getFiber(*(re::FiberJobManager **)v3, *(_DWORD *)(v3 + 96)) + 16) = 0;
    }
    if (!v7 && (Job - 1) >= 2)
      re::internal::AutoResetEvent::waitOne((re::internal::AutoResetEvent *)(v3 + 392));
    goto LABEL_26;
  }
  v9 = 0;
  v10 = 0;
  while (1)
  {
    v11 = *(_QWORD *)&this[118]._os_unfair_lock_opaque;
    if (v11 <= v10)
      break;
    v12 = *(_QWORD *)&this[122]._os_unfair_lock_opaque;
    v13 = **(_DWORD **)(v12 + v9 + 8);
    if (v13 <= 0)
    {
      __dmb(9u);
      if (!v13)
      {
        v27[0] = *(_DWORD *)(v12 + v9);
        re::DynamicArray<re::BufferView>::removeStableAt(&this[114]._os_unfair_lock_opaque, v10);
        os_unfair_lock_unlock(this + 112);
        goto LABEL_3;
      }
    }
    ++v10;
    v9 += 16;
    if (v8 == v10)
      goto LABEL_11;
  }
  v40 = 0;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  *(_OWORD *)v35 = 0u;
  os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
  v27[1] = 136315906;
  v28 = "operator[]";
  v29 = 1024;
  v30 = 789;
  v31 = 2048;
  v32 = v10;
  v33 = 2048;
  v34 = v11;
  _os_log_send_and_compose_impl();
  _os_crash_msg();
  __break(1u);
LABEL_30:
  *(_DWORD *)(v3 + 80) = *(_DWORD *)(v3 + 96);
  *(_DWORD *)(v3 + 84) = 5;
  *(_QWORD *)(v3 + 88) = 0;
  re::internal::WorkerThread::switchToThreadFiber((re::internal::WorkerThread *)v3);
  re::internal::assertLog((re::internal *)4, v25, "assertion failure: '%s' (%s:line %i) Cannot resume dead fiber.", "!\"Unreachable code\"", "fiberFunction", 373);
  result = _os_crash();
  __break(1u);
  return result;
}

_QWORD *re::FixedArray<re::FiberJobManager::FiberNode>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = result[2] + 104;
      v5 = v2 << 7;
      do
      {
        *(_QWORD *)(v4 - 40) = 0;
        *(_QWORD *)(v4 - 16) = 0;
        *(_QWORD *)(v4 - 8) = 0;
        if (*(_QWORD *)v4)
        {
          free(*(void **)v4);
          *(_QWORD *)v4 = 0;
          *(_QWORD *)(v4 + 8) = 0;
        }
        v4 += 128;
        v5 -= 128;
      }
      while (v5);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

void re::FiberJobManager::run(re::FiberJobManager *this, id *a2)
{
  void **v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  id *v10;
  dispatch_semaphore_t dsema;

  dsema = dispatch_semaphore_create(0);

  v4 = a2 + 2;
  re::ObjCObject::operator=(a2 + 2, (id *)&dsema);
  os_unfair_lock_lock((os_unfair_lock_t)this + 22);
  v10 = a2;
  re::WorkStealingQueue<re::Job *>::push((unint64_t *)this + 16, &v10);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 22);
  v5 = *((_QWORD *)this + 9);
  if (v5)
  {
    v6 = (uint64_t *)*((_QWORD *)this + 10);
    v7 = 8 * v5;
    do
    {
      v8 = *v6++;
      re::internal::AutoResetEvent::set((re::internal::AutoResetEvent *)(v8 + 392));
      v7 -= 8;
    }
    while (v7);
  }
  dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
  v9 = *v4;
  *v4 = 0;

}

uint64_t re::FiberJobManager::currentWorkerThread(re::FiberJobManager *this)
{
  unsigned int v2;

  v2 = re::FiberJobManager::currentWorkerThreadIndex(this);
  if (*((_QWORD *)this + 9) <= (unint64_t)v2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(*((_QWORD *)this + 10) + 8 * v2);
}

unint64_t re::FiberJobManager::currentWorkerThreadIndex(re::FiberJobManager *this)
{
  pthread_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unsigned int v6;
  _opaque_pthread_t *v7;
  pthread_t v9;
  unint64_t v10;
  pthread_t v11;
  unint64_t v12;
  unint64_t result;
  _opaque_pthread_t *v14;

  v2 = pthread_self();
  v4 = *((_QWORD *)this + 6);
  if (!v4)
    goto LABEL_9;
  v5 = 0;
  v6 = 1;
  while (1)
  {
    v7 = *(_opaque_pthread_t **)(*((_QWORD *)this + 7) + 8 * v5);
    if (v7)
      break;
    if (!v2)
      goto LABEL_10;
LABEL_8:
    v5 = v6;
    if (v4 <= v6++)
      goto LABEL_9;
  }
  if (!v2 || v7 != v2)
    goto LABEL_8;
LABEL_10:
  while (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v3, "assertion failure: '%s' (%s:line %i) Trying to get the index of a non-worker thread", "isWorkerThread()", "currentWorkerThreadIndex", 383);
    _os_crash();
    __break(1u);
  }
  v9 = pthread_self();
  v10 = *((_QWORD *)this + 6);
  if (v10)
  {
    v11 = v9;
    v12 = 0;
    result = 0;
    do
    {
      v14 = *(_opaque_pthread_t **)(*((_QWORD *)this + 7) + 8 * v12);
      if (v14)
      {
        if (v11 && v14 == v11)
          return result;
      }
      else if (!v11)
      {
        return result;
      }
      v12 = (result + 1);
      result = v12;
    }
    while (v10 > v12);
  }
  return 0xFFFFFFFFLL;
}

void re::FiberJobManager::runAsync(re::FiberJobManager *a1, uint64_t a2, unsigned int a3, unsigned int *a4, char a5)
{
  unint64_t *v9;

  v9 = (unint64_t *)re::FiberJobManager::currentWorkerThread(a1);
  re::internal::WorkerThread::runAsync(v9, a2, a3, a4, a5);
}

double re::FiberJobManager::waitFor(re::FiberJobManager *a1, unsigned int *a2, int a3)
{
  uint64_t v7;
  re::internal::WorkerThread *v8;
  int v9;
  unsigned int FreeFiberIndex;
  uint64_t v11;
  double result;

  if (atomic_load(a2))
  {
    v7 = re::FiberJobManager::currentWorkerThread(a1);
    v8 = (re::internal::WorkerThread *)v7;
    if (a3)
      v9 = 3;
    else
      v9 = 4;
    *(_DWORD *)(v7 + 80) = *(_DWORD *)(v7 + 96);
    *(_DWORD *)(v7 + 84) = v9;
    *(_QWORD *)(v7 + 88) = a2;
    FreeFiberIndex = re::FiberJobManager::getFreeFiberIndex(a1);
    re::internal::WorkerThread::switchToCustomFiber(v8, FreeFiberIndex);
    if ((a3 & 1) == 0)
      v8 = (re::internal::WorkerThread *)re::FiberJobManager::currentWorkerThread(a1);
    return re::internal::WorkerThread::postFiberSwitch(v8, v11);
  }
  return result;
}

unint64_t re::FiberJobManager::getFreeFiberIndex(re::FiberJobManager *this)
{
  unint64_t *v1;
  uint64_t v2;
  unint64_t result;
  unint64_t v4;
  unint64_t v5;
  char v6;

  v1 = (unint64_t *)((char *)this + 384);
  v2 = *((_QWORD *)this + 43);
  result = atomic_load((unint64_t *)this + 48);
  if ((_DWORD)result == -1)
    return 0xFFFFFFFFLL;
  v4 = __ldaxr(v1);
  if (v4 != result)
  {
    __clrex();
    while (1)
    {
LABEL_6:
      if ((_DWORD)v4 == -1)
        return 0xFFFFFFFFLL;
      result = v4;
      v5 = __ldaxr(v1);
      if (v5 != v4)
        break;
      if (__stlxr((v4 & 0xFFFFFFFF00000000 | *(unsigned int *)(v2 + ((unint64_t)v4 << 7)))+ 0x100000000, v1))
      {
        goto LABEL_11;
      }
      v6 = 1;
LABEL_12:
      v4 = v5;
      if ((v6 & 1) != 0)
        return result;
    }
    __clrex();
LABEL_11:
    v6 = 0;
    goto LABEL_12;
  }
  if (__stlxr((result & 0xFFFFFFFF00000000 | *(unsigned int *)(v2 + ((unint64_t)result << 7)))+ 0x100000000, v1))
  {
    goto LABEL_6;
  }
  return result;
}

void re::FiberJobManager::addFiberToWaitList(os_unfair_lock_s *a1, unsigned __int32 a2, unint64_t a3)
{
  os_unfair_lock_s *v6;
  __n128 v7;

  v6 = a1 + 112;
  os_unfair_lock_lock(a1 + 112);
  v7.n128_u32[0] = a2;
  v7.n128_u64[1] = a3;
  re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)&a1[114], &v7);
  os_unfair_lock_unlock(v6);
}

void re::sharedJobServiceInit(re *a1, uint64_t a2, unsigned int a3, unint64_t a4, int a5, re::Allocator *a6, re::AlignedAllocator *a7)
{
  unsigned int v10;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;

  if ((_DWORD)a1 == 3)
  {
    v15 = re::globalAllocators(a1);
    v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v15[2] + 32))(v15[2], 16, 8);
    *(_QWORD *)v14 = &off_24ED88F18;
    *(_QWORD *)(v14 + 8) = dispatch_get_global_queue(0, 0);
    goto LABEL_7;
  }
  v10 = a2;
  if ((_DWORD)a1 == 2)
  {
    v16 = re::globalAllocators(a1);
    v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v16[2] + 32))(v16[2], 216, 8);
    *(_QWORD *)v14 = &off_24ED890E8;
    *(_QWORD *)(v14 + 8) = 1018212795;
    *(_OWORD *)(v14 + 16) = 0u;
    *(_OWORD *)(v14 + 32) = 0u;
    *(_QWORD *)(v14 + 48) = 0;
    *(_QWORD *)(v14 + 56) = 850045863;
    *(_QWORD *)(v14 + 160) = 0;
    *(_OWORD *)(v14 + 64) = 0u;
    *(_OWORD *)(v14 + 80) = 0u;
    *(_OWORD *)(v14 + 96) = 0u;
    *(_OWORD *)(v14 + 112) = 0u;
    *(_OWORD *)(v14 + 128) = 0u;
    *(_OWORD *)(v14 + 140) = 0u;
    *(_WORD *)(v14 + 168) = 1;
    *(_OWORD *)(v14 + 176) = 0u;
    *(_OWORD *)(v14 + 192) = 0u;
    *(_QWORD *)(v14 + 208) = 0;
    re::ThreadJobManager::init((re::ThreadJobManager *)v14, v10, a5, a6, a7);
    goto LABEL_7;
  }
  if ((_DWORD)a1 == 1)
  {
    v13 = re::globalAllocators(a1);
    v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v13[2] + 32))(v13[2], 512, 64);
    *(_QWORD *)(v14 + 256) = 0;
    *(_QWORD *)v14 = &off_24ED89078;
    *(_QWORD *)(v14 + 8) = 0;
    *(_QWORD *)(v14 + 16) = 0;
    *(_QWORD *)(v14 + 24) = 0;
    *(_OWORD *)(v14 + 40) = 0u;
    *(_OWORD *)(v14 + 56) = 0u;
    *(_OWORD *)(v14 + 72) = 0u;
    *(_DWORD *)(v14 + 88) = 0;
    *(_BYTE *)(v14 + 320) = 1;
    *(_QWORD *)(v14 + 336) = 0;
    *(_QWORD *)(v14 + 344) = 0;
    *(_QWORD *)(v14 + 328) = 0;
    atomic_store(0xFFFFFFFFuLL, (unint64_t *)(v14 + 384));
    *(_DWORD *)(v14 + 448) = 0;
    *(_QWORD *)(v14 + 488) = 0;
    *(_QWORD *)(v14 + 464) = 0;
    *(_QWORD *)(v14 + 472) = 0;
    *(_QWORD *)(v14 + 456) = 0;
    *(_DWORD *)(v14 + 480) = 0;
    re::FiberJobManager::init((re::FiberJobManager *)v14, v10, a3, a4, a5, a6, a7);
LABEL_7:
    g_jobService = v14;
    return;
  }
  g_jobService = 0;
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Must select job service type", "!\"Unreachable code\"", "sharedJobServiceInit", 580);
  _os_crash();
  __break(1u);
}

re *re::sharedJobServiceDeinit(re *this)
{
  void (***v1)(_QWORD);
  uint64_t v2;

  v1 = (void (***)(_QWORD))g_jobService;
  if (g_jobService)
  {
    v2 = re::globalAllocators(this)[2];
    (**v1)(v1);
    this = (re *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v2 + 40))(v2, v1);
  }
  g_jobService = 0;
  return this;
}

uint64_t re::FiberJobManager::numberOfThreads(re::FiberJobManager *this)
{
  return *((unsigned int *)this + 18);
}

uint64_t re::FiberJobManager::profiler(re::FiberJobManager *this)
{
  return *((_QWORD *)this + 3);
}

uint64_t re::FiberJobManager::highPriorityAndQOSOptout(re::FiberJobManager *this)
{
  return *((unsigned __int8 *)this + 320);
}

uint64_t *re::allocInfo_JobService(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_485);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_485))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254123288, 0);
    *(uint64_t *)((char *)&qword_254123298 + 6) = 0;
    qword_254123298 = 0;
    qword_2541232A8 = 0;
    qword_2541232B0 = 0xFFFFFFFFLL;
    qword_254123288 = (uint64_t)&off_24ED7DAA8;
    qword_2541232B8 = (uint64_t)"JobService";
    dword_2541232C0 = 0;
    unk_2541232C8 = 0u;
    unk_2541232D8 = 0u;
    unk_2541232E8 = 0u;
    qword_2541232F8 = 0;
    __cxa_guard_release(&_MergedGlobals_485);
  }
  return &qword_254123288;
}

void re::initInfo_JobService(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0xE9829092CC0B0;
  v5[1] = "JobService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_JobService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_JobService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"JobService", (uint64_t (*)(re::internal *))re::allocInfo_JobService, (re::IntrospectionBase *(*)(void))re::initInfo_JobService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::JobService>, this);
}

void re::internal::AutoResetEvent::set(re::internal::AutoResetEvent *this)
{
  unsigned __int8 v1;
  std::mutex *v3;

  v1 = atomic_load((unsigned __int8 *)this);
  if ((v1 & 1) == 0)
  {
    v3 = (std::mutex *)((char *)this + 8);
    std::mutex::lock((std::mutex *)((char *)this + 8));
    *(_BYTE *)this = 1;
    std::condition_variable::notify_one((std::condition_variable *)((char *)this + 72));
    std::mutex::unlock(v3);
  }
}

void re::internal::AutoResetEvent::waitOne(re::internal::AutoResetEvent *this)
{
  std::unique_lock<std::mutex>::mutex_type *m;
  _BOOL4 owns;
  std::unique_lock<std::mutex> v4;

  m = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 8);
  v4.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 8);
  v4.__owns_ = 1;
  std::mutex::lock((std::mutex *)((char *)this + 8));
  if ((*(_BYTE *)this & 1) != 0)
  {
    *(_BYTE *)this = 0;
    goto LABEL_6;
  }
  do
    std::condition_variable::wait((std::condition_variable *)((char *)this + 72), &v4);
  while ((*(_BYTE *)this & 1) == 0);
  owns = v4.__owns_;
  *(_BYTE *)this = 0;
  if (owns)
  {
    m = v4.__m_;
LABEL_6:
    std::mutex::unlock(m);
  }
}

void re::ThreadJobManager::threadFunction(re::ThreadJobManager *this)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  unsigned int *v5;
  unsigned int v6;
  std::unique_lock<std::mutex> v7;

  pthread_setname_np("Job Service worker");
  v2 = 0;
  while (1)
  {
    v7.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 56);
    v7.__owns_ = 1;
    std::mutex::lock((std::mutex *)((char *)this + 56));
    while (!*((_QWORD *)this + 17))
    {
      if (*((_BYTE *)this + 169))
        goto LABEL_7;
      std::condition_variable::wait((std::condition_variable *)((char *)this + 8), &v7);
    }
    if (*((_BYTE *)this + 169))
    {
LABEL_7:
      v4 = 0;
      goto LABEL_9;
    }
    v2 = re::Queue<re::internal::AssetLoadItem *>::dequeue((uint64_t)this + 120, v3);
    v4 = 1;
LABEL_9:
    if (v7.__owns_)
      std::mutex::unlock(v7.__m_);
    if (!v4)
      break;
    (*(void (**)(uint64_t))v2)(v2);
    v5 = *(unsigned int **)(v2 + 8);
    if (v5)
    {
      do
        v6 = __ldxr(v5);
      while (__stlxr(v6 - 1, v5));
    }
  }
}

void re::ThreadJobManager::init(re::ThreadJobManager *this, int a2, int a3, re::Allocator *a4, re::AlignedAllocator *a5)
{
  re::ThreadJobManager *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  std::__thread_struct *v14;
  _QWORD *v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  pthread_t v19;
  uint64_t v20;
  int v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  unint64_t v26;
  __int16 v27;
  unint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  v8 = this;
  v34 = *MEMORY[0x24BDAC8D0];
  if (!a4)
  {
    this = (re::ThreadJobManager *)re::globalAllocators(this);
    a4 = (re::Allocator *)*((_QWORD *)this + 2);
  }
  *((_QWORD *)v8 + 25) = a4;
  if (!a5)
  {
    a5 = (re::AlignedAllocator *)re::globalAllocators(this)[4];
    a4 = (re::Allocator *)*((_QWORD *)v8 + 25);
  }
  *((_QWORD *)v8 + 26) = a5;
  v9 = (a2 - 1);
  *((_QWORD *)v8 + 22) = a4;
  *((_QWORD *)v8 + 23) = v9;
  if (a2 != 1)
  {
    v10 = (_QWORD *)(*(uint64_t (**)(re::Allocator *, uint64_t, uint64_t))(*(_QWORD *)a4 + 32))(a4, 8 * v9, 8);
    *((_QWORD *)v8 + 24) = v10;
    if (v10)
    {
      v12 = v10;
      if ((_DWORD)v9 != 1)
      {
        bzero(v10, 8 * v9 - 8);
        v12 += v9 - 1;
      }
      v13 = 0;
      *v12 = 0;
      *((_BYTE *)v8 + 168) = a3;
      while (1)
      {
        v14 = (std::__thread_struct *)operator new();
        std::__thread_struct::__thread_struct(v14);
        v15 = (_QWORD *)operator new();
        *v15 = v14;
        v15[1] = re::ThreadJobManager::threadFunction;
        v15[2] = 0;
        v15[3] = v8;
        v16 = pthread_create(&v19, 0, (void *(__cdecl *)(void *))std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::ThreadJobManager::*)(void),re::ThreadJobManager*>>, v15);
        if (v16)
          goto LABEL_23;
        *(_QWORD *)&v29 = 0;
        std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::ThreadJobManager::*)(void),re::ThreadJobManager*>>::reset[abi:nn180100]((uint64_t **)&v29);
        v17 = *((_QWORD *)v8 + 23);
        if (v17 <= v13)
          break;
        v18 = *((_QWORD *)v8 + 24);
        if (*(_QWORD *)(v18 + 8 * v13))
          goto LABEL_24;
        *(_QWORD *)(v18 + 8 * v13) = v19;
        v19 = 0;
        std::thread::~thread((std::thread *)&v19);
        if (a3)
        {
          v17 = *((_QWORD *)v8 + 23);
          if (v17 <= v13)
            goto LABEL_21;
          re::internal::setThreadPriority(*(_opaque_pthread_t **)(*((_QWORD *)v8 + 24) + 8 * v13), (_opaque_pthread_t *)0x28);
        }
        if (v9 == ++v13)
          return;
      }
      v20 = 0;
      v32 = 0u;
      v33 = 0u;
      v30 = 0u;
      v31 = 0u;
      v29 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v21 = 136315906;
      v22 = "operator[]";
      v23 = 1024;
      v24 = 468;
      v25 = 2048;
      v26 = v13;
      v27 = 2048;
      v28 = v17;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_21:
      v20 = 0;
      v32 = 0u;
      v33 = 0u;
      v30 = 0u;
      v31 = 0u;
      v29 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v21 = 136315906;
      v22 = "operator[]";
      v23 = 1024;
      v24 = 468;
      v25 = 2048;
      v26 = v13;
      v27 = 2048;
      v28 = v17;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)4, v11, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    v16 = _os_crash();
    __break(1u);
LABEL_23:
    std::__throw_system_error(v16, "thread constructor failed");
LABEL_24:
    std::terminate();
  }
  *((_BYTE *)v8 + 168) = a3;
}

void re::ThreadJobManager::~ThreadJobManager(re::ThreadJobManager *this)
{
  std::mutex *v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v6;
  _QWORD *v7;

  v2 = (std::mutex *)((char *)this + 56);
  std::mutex::lock((std::mutex *)((char *)this + 56));
  *((_BYTE *)this + 169) = 1;
  std::condition_variable::notify_all((std::condition_variable *)((char *)this + 8));
  std::mutex::unlock(v2);
  if (*((_QWORD *)this + 23))
  {
    v3 = 0;
    v4 = 1;
    do
    {
      std::thread::join((std::thread *)(*((_QWORD *)this + 24) + 8 * v3));
      v3 = v4;
    }
    while (*((_QWORD *)this + 23) > (unint64_t)v4++);
  }
  re::FixedArray<std::thread>::deinit((_QWORD *)this + 22);
  v7 = (_QWORD *)((char *)this + 120);
  v6 = *((_QWORD *)this + 15);
  if (v6)
  {
    if (*((_QWORD *)this + 20))
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
    *((_QWORD *)this + 20) = 0;
    *(_OWORD *)v7 = 0u;
    *(_OWORD *)((char *)this + 136) = 0u;
    *((_DWORD *)this + 38) = 0;
  }
  re::FixedArray<std::thread>::deinit((_QWORD *)this + 22);
  if (*v7)
  {
    if (*((_QWORD *)this + 20))
      (*(void (**)(_QWORD))(*(_QWORD *)*v7 + 40))(*v7);
    *((_QWORD *)this + 20) = 0;
    *(_OWORD *)v7 = 0u;
    *(_OWORD *)((char *)this + 136) = 0u;
    *((_DWORD *)this + 38) = 0;
  }
  std::mutex::~mutex(v2);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 8));
}

{
  re::ThreadJobManager::~ThreadJobManager(this);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::FixedArray<std::thread>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  std::thread *v4;
  uint64_t v5;
  std::thread *v6;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = (std::thread *)result[2];
      v5 = 8 * v2;
      do
      {
        std::thread::~thread(v4);
        v4 = v6 + 1;
        v5 -= 8;
      }
      while (v5);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

void re::ThreadJobManager::currentWorkerThreadIndex(re::ThreadJobManager *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Not Implemented", "!\"Unreachable code\"", "currentWorkerThreadIndex", 90);
  _os_crash();
  __break(1u);
}

uint64_t re::ThreadJobManager::run(uint64_t a1, uint64_t (**a2)(_QWORD))
{
  return (*a2)(a2);
}

void re::ThreadJobManager::runAsync(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int *a4)
{
  uint64_t v5;
  uint64_t v7;
  unsigned int **v8;
  uint64_t v9;
  unint64_t v10;
  std::mutex *v11;
  _anonymous_namespace_ *v12;
  std::condition_variable *v13;
  uint64_t v14;

  v5 = a2;
  if (a4)
  {
    *a4 = a3;
    if (a3)
    {
      v7 = a3;
      v8 = (unsigned int **)(a2 + 8);
      do
      {
        *v8 = a4;
        v8 += 8;
        --v7;
      }
      while (v7);
    }
  }
  v9 = a3;
  v10 = *(_QWORD *)(a1 + 184);
  v11 = (std::mutex *)(a1 + 56);
  std::mutex::lock((std::mutex *)(a1 + 56));
  if (v10 <= a3)
  {
    if (a3)
    {
      do
      {
        v14 = v5;
        re::Queue<re::Job *>::enqueue((_anonymous_namespace_ *)(a1 + 120), &v14);
        v5 += 64;
        --v9;
      }
      while (v9);
    }
    std::condition_variable::notify_all((std::condition_variable *)(a1 + 8));
  }
  else if (a3)
  {
    v12 = (_anonymous_namespace_ *)(a1 + 120);
    v13 = (std::condition_variable *)(a1 + 8);
    do
    {
      v14 = v5;
      re::Queue<re::Job *>::enqueue(v12, &v14);
      std::condition_variable::notify_one(v13);
      v5 += 64;
      --v9;
    }
    while (v9);
  }
  std::mutex::unlock(v11);
}

_anonymous_namespace_ *re::Queue<re::Job *>::enqueue(_anonymous_namespace_ *result, _QWORD *a2)
{
  _anonymous_namespace_ *v3;
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;

  v3 = result;
  v5 = (_QWORD *)((char *)result + 16);
  v4 = *((_QWORD *)result + 2);
  v6 = v4 + 1;
  v7 = *((_QWORD *)result + 1);
  if (v4 + 1 >= v7)
  {
    if (v7 < v6)
    {
      if (*(_QWORD *)result)
      {
        v8 = 2 * v7;
        if (!v7)
          v8 = 8;
        if (v8 <= v6)
          v9 = v6;
        else
          v9 = v8;
        result = (_anonymous_namespace_ *)re::Queue<re::internal::AssetLoadItem *>::setCapacity(result, v9);
        v4 = *((_QWORD *)v3 + 2);
      }
      else
      {
        result = (_anonymous_namespace_ *)re::Queue<re::internal::AssetLoadItem *>::setCapacity(v3, v6);
        v4 = 0;
        *v5 = 0;
        v5[1] = 0;
        *((_DWORD *)v5 + 4) = 0;
      }
    }
    v7 = *((_QWORD *)v3 + 1);
    v6 = v4 + 1;
  }
  *(_QWORD *)(*((_QWORD *)v3 + 5) + 8 * ((*((_QWORD *)v3 + 3) + v4) % v7)) = *a2;
  *((_QWORD *)v3 + 2) = v6;
  ++*((_DWORD *)v3 + 8);
  return result;
}

uint64_t re::ThreadJobManager::waitFor(uint64_t result, unsigned int *a2)
{
  uint64_t v4;
  std::mutex *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;

  if (atomic_load(a2))
  {
    v4 = result;
    v5 = (std::mutex *)(result + 56);
    v6 = result + 120;
    do
    {
      std::mutex::lock(v5);
      if (*(_QWORD *)(v4 + 136))
      {
        v8 = re::Queue<re::internal::AssetLoadItem *>::dequeue(v6, v7);
        std::mutex::unlock(v5);
        if (v8)
        {
          result = (*(uint64_t (**)(uint64_t))v8)(v8);
          v9 = *(unsigned int **)(v8 + 8);
          if (v9)
          {
            do
              v10 = __ldxr(v9);
            while (__stlxr(v10 - 1, v9));
          }
          continue;
        }
      }
      else
      {
        std::mutex::unlock(v5);
      }
      result = usleep(1u);
    }
    while (atomic_load(a2));
  }
  return result;
}

uint64_t re::ThreadJobManager::numberOfThreads(re::ThreadJobManager *this)
{
  return (*((_DWORD *)this + 46) + 1);
}

uint64_t re::ThreadJobManager::profiler(re::ThreadJobManager *this)
{
  return 0;
}

uint64_t re::ThreadJobManager::highPriorityAndQOSOptout(re::ThreadJobManager *this)
{
  return *((unsigned __int8 *)this + 168);
}

uint64_t std::__thread_proxy[abi:nn180100]<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::ThreadJobManager::*)(void),re::ThreadJobManager*>>(uint64_t *a1)
{
  std::__thread_specific_ptr<std::__thread_struct> *v2;
  const void *v3;
  uint64_t v4;
  void (*v5)(_QWORD *);
  _QWORD *v6;
  uint64_t *v8;

  v8 = a1;
  v2 = std::__thread_local_data();
  v3 = (const void *)*a1;
  *a1 = 0;
  pthread_setspecific(v2->__key_, v3);
  v4 = a1[2];
  v5 = (void (*)(_QWORD *))a1[1];
  v6 = (_QWORD *)(a1[3] + (v4 >> 1));
  if ((v4 & 1) != 0)
    v5 = *(void (**)(_QWORD *))(*v6 + v5);
  v5(v6);
  std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::ThreadJobManager::*)(void),re::ThreadJobManager*>>::reset[abi:nn180100](&v8);
  return 0;
}

uint64_t **std::unique_ptr<std::tuple<std::unique_ptr<std::__thread_struct>,void (re::ThreadJobManager::*)(void),re::ThreadJobManager*>>::reset[abi:nn180100](uint64_t **result)
{
  uint64_t *v1;

  v1 = *result;
  *result = 0;
  if (v1)
  {
    std::unique_ptr<std::__thread_struct>::reset[abi:nn180100](v1, 0);
    JUMPOUT(0x2276933B8);
  }
  return result;
}

uint64_t *re::allocInfo_BackgroundTaskService(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_486);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_486))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254123308, 0);
    *(uint64_t *)((char *)&qword_254123318 + 6) = 0;
    qword_254123318 = 0;
    qword_254123328 = 0;
    qword_254123330 = 0xFFFFFFFFLL;
    qword_254123308 = (uint64_t)&off_24ED7DAA8;
    qword_254123338 = (uint64_t)"BackgroundTaskService";
    dword_254123340 = 0;
    unk_254123348 = 0u;
    unk_254123358 = 0u;
    unk_254123368 = 0u;
    qword_254123378 = 0;
    __cxa_guard_release(&_MergedGlobals_486);
  }
  return &qword_254123308;
}

void re::initInfo_BackgroundTaskService(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x2D7BF0572AA82684;
  v5[1] = "BackgroundTaskService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_BackgroundTaskService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_BackgroundTaskService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"BackgroundTaskService", (uint64_t (*)(re::internal *))re::allocInfo_BackgroundTaskService, (re::IntrospectionBase *(*)(void))re::initInfo_BackgroundTaskService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::BackgroundTaskService>, this);
}

uint64_t *re::allocInfo_SharedClockService(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_487);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_487))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254123398, 0);
    *(uint64_t *)((char *)&qword_2541233A8 + 6) = 0;
    qword_2541233A8 = 0;
    qword_2541233B8 = 0;
    qword_2541233C0 = 0xFFFFFFFFLL;
    qword_254123398 = (uint64_t)&off_24ED7DAA8;
    qword_2541233C8 = (uint64_t)"SharedClockService";
    dword_2541233D0 = 0;
    unk_2541233D8 = 0u;
    unk_2541233E8 = 0u;
    unk_2541233F8 = 0u;
    qword_254123408 = 0;
    __cxa_guard_release(&_MergedGlobals_487);
  }
  return &qword_254123398;
}

void re::initInfo_SharedClockService(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0xA811E48D3DB587D8;
  v5[1] = "SharedClockService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x1800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = re::internal::defaultRetain<re::SharedClockService>(void)::{lambda(void *)#1}::__invoke;
  *((_QWORD *)this + 12) = re::internal::defaultRelease<re::SharedClockService>(void)::{lambda(void *)#1}::__invoke;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_SharedClockService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_SharedClockService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"SharedClockService", (uint64_t (*)(re::internal *))re::allocInfo_SharedClockService, (re::IntrospectionBase *(*)(void))re::initInfo_SharedClockService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::SharedClockService>, this);
}

void re::SharedClockManager::TimeSyncClockStateDidChange(_anonymous_namespace_ *a1, uint64_t a2, int a3)
{
  NSObject *v5;
  int v6;
  _anonymous_namespace_ *v7;
  __int16 v8;
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v5 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    v6 = 134218240;
    v7 = a1;
    v8 = 1024;
    v9 = a3;
    _os_log_impl(&dword_224FE9000, v5, OS_LOG_TYPE_INFO, "TimeSyncClock %p lock state did change to %d", (uint8_t *)&v6, 0x12u);
  }

}

id `anonymous namespace'::SharedClockLog(_anonymous_namespace_ *this)
{
  if (qword_254123390 != -1)
    dispatch_once(&qword_254123390, &__block_literal_global_45);
  return (id)qword_254123388;
}

void re::SharedClockManager::TimeSyncClockMasterDidChange(re::SharedClockManager *this, void *a2, void *a3)
{
  NSObject *v4;
  int v5;
  re::SharedClockManager *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v4 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
  {
    v5 = 134217984;
    v6 = this;
    _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_INFO, "TimeSyncClock %p master did change", (uint8_t *)&v5, 0xCu);
  }

}

void re::SharedClockManager::TimeSyncClockGrandmasterIdentityDidChange(re::SharedClockManager *this, char *a2, unint64_t a3)
{
  NSObject *v6;
  const void *v7;
  re *HostTimeClock;
  OpaqueCMClock **v9;
  _anonymous_namespace_ *v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  _BYTE v14[24];
  void *v15;
  char *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v6 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)v14 = 134218240;
    *(_QWORD *)&v14[4] = this;
    *(_WORD *)&v14[12] = 2048;
    *(_QWORD *)&v14[14] = a3;
    _os_log_impl(&dword_224FE9000, v6, OS_LOG_TYPE_INFO, "TimeSyncClock %p grandmaster identity did change to %llu", v14, 0x16u);
  }

  atomic_store(a3, (unint64_t *)a2 + 26);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 26);
  v7 = (const void *)*((_QWORD *)a2 + 4);
  HostTimeClock = CMClockGetHostTimeClock();
  v10 = (_anonymous_namespace_ *)re::ManualCMClockCreateWithReference(HostTimeClock, (OpaqueCMClock *)(a2 + 32), v9);
  if ((_DWORD)v10)
  {
    v11 = (int)v10;
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v14 = 136315650;
      *(_QWORD *)&v14[4] = "changeGrandmasterID";
      *(_WORD *)&v14[12] = 1024;
      *(_DWORD *)&v14[14] = 237;
      *(_WORD *)&v14[18] = 1024;
      *(_DWORD *)&v14[20] = v11;
      _os_log_error_impl(&dword_224FE9000, v12, OS_LOG_TYPE_ERROR, "%s:%d error: %d", v14, 0x18u);
    }

  }
  CFRelease(v7);
  os_unfair_lock_unlock((os_unfair_lock_t)a2 + 26);
  re::SharedClockManager::update((os_unfair_lock_s *)a2);
  re::Event<re::NetworkSystem,re::ecs2::Entity *,re::TLEInfo *,re::NewUnboundTLEHandlerResult *>::raise((uint64_t)(a2 + 120), (uint64_t)a2);
  v13 = *((_QWORD *)a2 + 14);
  *(_QWORD *)v14 = MEMORY[0x24BDAC760];
  *(_QWORD *)&v14[8] = 3221225472;
  *(_QWORD *)&v14[16] = ___ZN2re18SharedClockManager19changeGrandmasterIDEy_block_invoke;
  v15 = &__block_descriptor_40_e5_v8__0l;
  v16 = a2;
  dispatch_async(v13, v14);
}

void re::SharedClockManager::TimeSyncClockGrandmasterIdentityAndLocalPortDidChange(re::SharedClockManager *this, void *a2, void *a3, int a4)
{
  NSObject *v7;
  int v8;
  re::SharedClockManager *v9;
  __int16 v10;
  void *v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v7 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    v8 = 134218496;
    v9 = this;
    v10 = 2048;
    v11 = a3;
    v12 = 1024;
    v13 = a4;
    _os_log_impl(&dword_224FE9000, v7, OS_LOG_TYPE_INFO, "TimeSyncClock %p grandmaster identity did change to %llu and local port to %d", (uint8_t *)&v8, 0x1Cu);
  }

}

void re::SharedClockManager::~SharedClockManager(re::SharedClockManager *this)
{
  uint64_t v2;
  uint64_t v3;

  re::SharedClockManager::setSession(this, 0);
  re::SharedClockManager::tearDownClocks(this);
  v2 = *((_QWORD *)this + 15);
  if (v2)
  {
    if (*((_QWORD *)this + 19))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 19) = 0;
    *((_QWORD *)this + 16) = 0;
    *((_QWORD *)this + 17) = 0;
    *((_QWORD *)this + 15) = 0;
    ++*((_DWORD *)this + 36);
  }
  if (*((_QWORD *)this + 6))
    RESyncRelease();
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)this + 240);
  v3 = *((_QWORD *)this + 27);
  if (v3)
  {

    *((_QWORD *)this + 27) = 0;
  }
  re::Event<re::Engine>::~Event((uint64_t *)this + 15);

  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)this + 64);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

void re::SharedClockManager::setSession(re::SharedClockManager *this, uint64_t a2)
{
  uint64_t v3;
  unint64_t v5;
  unint64_t v6;
  unint64_t *v7;
  uint64_t v8;
  _QWORD *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t *v14;

  v3 = *((_QWORD *)this + 5);
  if (v3 != a2)
  {
    if (v3)
    {
      if (RESyncNetSessionParticipantsCount())
      {
        v5 = 0;
        do
        {
          RESyncNetSessionGetParticipantAtIndex();
          re::SharedClockManager::participantDidLeave((uint64_t)this);
          ++v5;
        }
        while (v5 < RESyncNetSessionParticipantsCount());
      }
      os_unfair_lock_lock((os_unfair_lock_t)this + 26);
      v6 = *((_QWORD *)this + 11);
      v14 = 0;
      v13 = 0;
      if (v6)
      {
        if (v6 >> 61)
          abort();
        v7 = (unint64_t *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)&v14, v6);
        v13 = v7;
        v14 = &v7[v8];
        bzero(v7, 8 * v6);
        v6 = (unint64_t)&v7[v6];
      }
      else
      {
        v7 = 0;
      }
      v9 = (_QWORD *)*((_QWORD *)this + 10);
      if (v9)
      {
        v10 = v7;
        do
        {
          *v10++ = v9[2];
          v9 = (_QWORD *)*v9;
        }
        while (v9);
      }
      while (v7 != (unint64_t *)v6)
      {
        v11 = *v7++;
        re::SharedClockManager::peerDidLeave((int8x8_t *)this, v11);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)this + 26);
      if ((RESyncNetSessionIsInitialized() & 1) != 0)
        RESyncNetSessionRemoveObserver();
      RESyncRelease();
      if (v13)
        operator delete(v13);
    }
    *((_QWORD *)this + 5) = a2;
    if (!a2)
      goto LABEL_29;
    RESyncRetain();
    if (RESyncNetSessionIsInitialized())
    {
      if (!*((_QWORD *)this + 6))
        *((_QWORD *)this + 6) = RESyncNetSessionObserverCreate();
      RESyncNetSessionObserverOnParticipantJoin();
      RESyncNetSessionObserverOnParticipantLeave();
      RESyncNetSessionObserverOnReceiveData();
      RESyncNetSessionAddObserver();
      if (RESyncNetSessionParticipantsCount())
      {
        v12 = 0;
        do
        {
          RESyncNetSessionGetParticipantAtIndex();
          re::SharedClockManager::participantDidJoin((uint64_t)this);
          ++v12;
        }
        while (v12 < RESyncNetSessionParticipantsCount());
      }
    }
    if (!*((_QWORD *)this + 5) || (unint64_t)RESyncNetSessionParticipantsCount() <= 1)
LABEL_29:
      re::SharedClockManager::tearDownClocks(this);
  }
}

void re::SharedClockManager::tearDownClocks(re::SharedClockManager *this)
{
  const void *v2;
  const void *v3;

  if (*((_BYTE *)this + 232))
  {
    if (*((_QWORD *)this + 7))
    {
      TimeSyncClockDispose();
      *((_QWORD *)this + 7) = 0;
    }
    v2 = (const void *)*((_QWORD *)this + 4);
    if (v2)
    {
      CFRelease(v2);
      *((_QWORD *)this + 4) = 0;
    }
    v3 = (const void *)*((_QWORD *)this + 3);
    if (v3)
    {
      CFRelease(v3);
      *((_QWORD *)this + 3) = 0;
    }
    atomic_store(0, (unint64_t *)this + 26);
    re::Event<re::NetworkSystem,re::ecs2::Entity *,re::TLEInfo *,re::NewUnboundTLEHandlerResult *>::raise((uint64_t)this + 120, (uint64_t)this);
    *((_BYTE *)this + 232) = 0;
  }
}

void re::SharedClockManager::participantDidJoin(uint64_t a1)
{
  uint64_t IsLocalPeer;
  NSObject *v4;
  re *HostTimeClock;
  OpaqueCMClock **v6;
  _anonymous_namespace_ *v7;
  int v8;
  NSObject *v9;
  _anonymous_namespace_ *v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  OpaqueCMClock **v14;
  _anonymous_namespace_ *v15;
  int v16;
  NSObject *v17;
  NSObject *v18;
  const char *v19;
  const void *v20;
  const __CFData *v21;
  _anonymous_namespace_ *v22;
  NSObject *v23;
  uint64_t v24;
  unint64_t v25;
  const UInt8 *v26;
  unint64_t v27;
  _anonymous_namespace_ *v28;
  ifaddrs *v29;
  UInt8 *v30;
  char *v31;
  const UInt8 *v32;
  char *v33;
  sockaddr *ifa_addr;
  const char *ifa_name;
  const char *v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  char *v40;
  char *v41;
  uint64_t v42;
  NSObject *v43;
  unint64_t v44;
  _QWORD *v45;
  const __CFData *v46;
  unint64_t v47;
  const UInt8 *BytePtr;
  CFIndex Length;
  int v50;
  char *v51;
  ifaddrs *v52;
  uint8_t buf[4];
  const char *PeerID;
  __int16 v55;
  _WORD v56[17];

  *(_QWORD *)&v56[13] = *MEMORY[0x24BDAC8D0];
  RESyncParticipantGetPeerID();
  IsLocalPeer = RESyncNetSessionGetIsLocalPeer();
  if ((IsLocalPeer & 1) == 0)
  {
    if (atomic_load((unsigned int *)(a1 + 236)))
    {
      v4 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134217984;
        PeerID = (const char *)RESyncParticipantGetPeerID();
        _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_INFO, "Participant joined with peer ID %llu ", buf, 0xCu);
      }

      if (*(_BYTE *)(a1 + 232))
      {
LABEL_22:
        v20 = *(const void **)(a1 + 224);
        if (v20)
        {
          v21 = (const __CFData *)CFRetain(v20);
        }
        else
        {
          v52 = 0;
          v28 = (_anonymous_namespace_ *)getifaddrs(&v52);
          if ((v28 & 0x80000000) != 0)
          {
            v43 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
            {
              v50 = *__error();
              *(_DWORD *)buf = 67109120;
              LODWORD(PeerID) = v50;
              _os_log_error_impl(&dword_224FE9000, v43, OS_LOG_TYPE_ERROR, "SharedClockManager: unable to list network adapters(errno=%d).", buf, 8u);
            }

            goto LABEL_63;
          }
          v29 = v52;
          if (!v52)
          {
            MEMORY[0x227693B68](0);
LABEL_63:
            v44 = RESyncParticipantGetPeerID();
            v45 = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>((_QWORD *)(a1 + 240), v44);
            if (v45)
            {
              v46 = (const __CFData *)CFRetain((CFTypeRef)v45[3]);
              v47 = RESyncParticipantGetPeerID();
              BytePtr = CFDataGetBytePtr(v46);
              Length = CFDataGetLength(v46);
              re::SharedClockManager::didReceiveData(a1, v47, BytePtr, Length);
              CFRelease(v46);
            }
            return;
          }
          v30 = 0;
          v31 = 0;
          v32 = 0;
          v33 = 0;
          do
          {
            ifa_addr = v29->ifa_addr;
            if (ifa_addr)
            {
              ifa_name = v29->ifa_name;
              if ((!strcmp(ifa_name, "en0") || !strcmp(ifa_name, "awdl0"))
                && (v29->ifa_flags & 0xB) == 3
                && ifa_addr->sa_family == 2)
              {
                *(_DWORD *)&v56[1] = *(_DWORD *)&ifa_addr->sa_data[2];
                v36 = v29->ifa_name;
                *(_DWORD *)buf = 0;
                strcpy((char *)&PeerID, v36);
                if (v33 >= v31)
                {
                  v37 = (v30 - v32) >> 5;
                  v38 = v37 + 1;
                  if ((unint64_t)(v37 + 1) >> 59)
                    abort();
                  if ((v31 - (char *)v32) >> 4 > v38)
                    v38 = (v31 - (char *)v32) >> 4;
                  if ((unint64_t)(v31 - (char *)v32) >= 0x7FFFFFFFFFFFFFE0)
                    v39 = 0x7FFFFFFFFFFFFFFLL;
                  else
                    v39 = v38;
                  if (v39)
                  {
                    if (v39 >> 59)
                      std::__throw_bad_array_new_length[abi:nn180100]();
                    v40 = (char *)operator new(32 * v39);
                  }
                  else
                  {
                    v40 = 0;
                  }
                  v41 = &v40[32 * v37];
                  *(_DWORD *)v41 = 0;
                  strcpy(v41 + 4, (const char *)&PeerID);
                  *((_OWORD *)v41 + 1) = *(_OWORD *)&v56[1];
                  if (v30 == v32)
                  {
                    v32 = (const UInt8 *)v41;
                  }
                  else
                  {
                    v51 = v40;
                    v42 = 0;
                    do
                    {
                      *(_DWORD *)&v41[v42 - 32] = *(_DWORD *)&v30[v42 - 32];
                      strcpy(&v41[v42 - 28], (const char *)&v30[v42 - 28]);
                      *(_OWORD *)&v41[v42 - 16] = *(_OWORD *)&v30[v42 - 16];
                      v42 -= 32;
                    }
                    while (&v30[v42] != v32);
                    v30 = (UInt8 *)v32;
                    v32 = (const UInt8 *)&v41[v42];
                    v40 = v51;
                  }
                  v31 = &v40[32 * v39];
                  v33 = v41 + 32;
                  if (v30)
                    operator delete(v30);
                }
                else
                {
                  *(_DWORD *)v33 = 0;
                  strcpy(v33 + 4, (const char *)&PeerID);
                  *((_OWORD *)v33 + 1) = *(_OWORD *)&v56[1];
                  v33 += 32;
                }
                v30 = (UInt8 *)v33;
              }
            }
            v29 = v29->ifa_next;
          }
          while (v29);
          MEMORY[0x227693B68](v52);
          if (v30 == v32)
          {
            v21 = 0;
          }
          else
          {
            v21 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], v32, v30 - v32);
            v30 = (UInt8 *)v32;
          }
          if (v30)
            operator delete(v30);
        }
        if (v21)
        {
          RESyncParticipantGetPeerID();
          CFDataGetBytePtr(v21);
          CFDataGetLength(v21);
          v22 = (_anonymous_namespace_ *)RESyncNetSessionSendData();
          v23 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
          {
            v24 = RESyncParticipantGetPeerID();
            v25 = CFDataGetLength(v21);
            *(_DWORD *)buf = 134218240;
            PeerID = (const char *)v24;
            v55 = 2048;
            *(_QWORD *)v56 = v25 >> 5;
            _os_log_impl(&dword_224FE9000, v23, OS_LOG_TYPE_INFO, "Sent %llu %lu addresses:", buf, 0x16u);
          }

          v26 = CFDataGetBytePtr(v21);
          v27 = CFDataGetLength(v21);
          CFRelease(v21);
        }
        goto LABEL_63;
      }
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 104));
      HostTimeClock = CMClockGetHostTimeClock();
      v7 = (_anonymous_namespace_ *)re::ManualCMClockCreateWithReference(HostTimeClock, (OpaqueCMClock *)(a1 + 24), v6);
      if ((_DWORD)v7)
      {
        v8 = (int)v7;
        v9 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          PeerID = "setUpClocks";
          v55 = 1024;
          *(_DWORD *)v56 = 168;
          v56[2] = 1024;
          *(_DWORD *)&v56[3] = v8;
          _os_log_error_impl(&dword_224FE9000, v9, OS_LOG_TYPE_ERROR, "%s:%d error: %d", buf, 0x18u);
        }

      }
      v10 = (_anonymous_namespace_ *)TimeSyncAddgPTPServices();
      if ((_DWORD)v10)
      {
        v11 = TimeSyncSystemDomainClockIdentifier();
        v12 = MEMORY[0x227692CEC](v11);
        *(_QWORD *)(a1 + 56) = v12;
        if (v12)
        {
          v13 = CMClockGetHostTimeClock();
          v15 = (_anonymous_namespace_ *)re::ManualCMClockCreateWithReference(v13, (OpaqueCMClock *)(a1 + 32), v14);
          if ((_DWORD)v15)
          {
            v16 = (int)v15;
            v17 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315650;
              PeerID = "setUpClocks";
              v55 = 1024;
              *(_DWORD *)v56 = 176;
              v56[2] = 1024;
              *(_DWORD *)&v56[3] = v16;
              _os_log_error_impl(&dword_224FE9000, v17, OS_LOG_TYPE_ERROR, "%s:%d error: %d", buf, 0x18u);
            }

          }
          TimeSyncClockSetLockStateChangeCallback();
          TimeSyncClockSetMasterChangeCallback();
          TimeSyncClockSetgPTPGrandmasterChangeCallback();
          TimeSyncClockSetgPTPGrandmasterAndPortChangeCallback();
          TimeSyncClockSetgPTPLocalPortChangeCallback();
          atomic_store(TimeSyncClockGetgPTPGrandmasterIdentity(), (unint64_t *)(a1 + 208));
          goto LABEL_21;
        }
        v18 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
LABEL_20:

LABEL_21:
          os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 104));
          re::SharedClockManager::update((os_unfair_lock_s *)a1);
          atomic_load((unint64_t *)(a1 + 208));
          re::Event<re::NetworkSystem,re::ecs2::Entity *,re::TLEInfo *,re::NewUnboundTLEHandlerResult *>::raise(a1 + 120, a1);
          *(_BYTE *)(a1 + 232) = 1;
          goto LABEL_22;
        }
        *(_WORD *)buf = 0;
        v19 = "Failed to create time sync clock";
      }
      else
      {
        v18 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          goto LABEL_20;
        *(_WORD *)buf = 0;
        v19 = "Failed to add time sync services";
      }
      _os_log_error_impl(&dword_224FE9000, v18, OS_LOG_TYPE_ERROR, v19, buf, 2u);
      goto LABEL_20;
    }
  }
}

void re::SharedClockManager::update(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  _anonymous_namespace_ *ClockRateAndAnchors;
  int v4;
  NSObject *v5;
  re *v6;
  CMTime *v7;
  _anonymous_namespace_ *times;
  int v9;
  NSObject *v10;
  re *v11;
  CMTime *v12;
  CMTime v13;
  CMTime v14;
  uint64_t v15;
  uint64_t v16;
  CMTime v17;
  CMTime v18;
  int64_t value;
  uint64_t v20;
  uint64_t v21;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v2 = this + 26;
  os_unfair_lock_lock(this + 26);
  if (*(_QWORD *)&this[14]._os_unfair_lock_opaque)
  {
    v15 = 0;
    v20 = 0;
    v21 = 0;
    value = 0;
    ClockRateAndAnchors = (_anonymous_namespace_ *)TimeSyncClockGetClockRateAndAnchors();
    if ((_DWORD)ClockRateAndAnchors)
    {
      v4 = (int)ClockRateAndAnchors;
      v5 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        v23 = "update";
        v24 = 1024;
        v25 = 308;
        v26 = 1024;
        v27 = v4;
        _os_log_error_impl(&dword_224FE9000, v5, OS_LOG_TYPE_ERROR, "%s:%d error: %d", buf, 0x18u);
      }

    }
    else
    {
      v6 = *(re **)&this[8]._os_unfair_lock_opaque;
      CMTimeMake(&v18, value, 1000000000);
      CMClockMakeHostTimeFromSystemUnits(&v17, v20);
      re::ManualCMClockUpdateRateAndAnchor(v6, &v18, 1.0, &v17, v7);
    }
  }
  if (*(_QWORD *)&this[6]._os_unfair_lock_opaque)
  {
    v20 = 0;
    v21 = 0;
    times = (_anonymous_namespace_ *)mach_get_times();
    if ((_DWORD)times)
    {
      v9 = (int)times;
      v10 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        v23 = "update";
        v24 = 1024;
        v25 = 332;
        v26 = 1024;
        v27 = v9;
        _os_log_error_impl(&dword_224FE9000, v10, OS_LOG_TYPE_ERROR, "%s:%d error: %d", buf, 0x18u);
      }

    }
    else
    {
      v11 = *(re **)&this[6]._os_unfair_lock_opaque;
      CMTimeMake(&v14, v16 + 1000000000 * v15, 1000000000);
      CMClockMakeHostTimeFromSystemUnits(&v13, v20);
      re::ManualCMClockUpdateRateAndAnchor(v11, &v14, 1.0, &v13, v12);
    }
  }
  os_unfair_lock_unlock(v2);
}

uint64_t ___ZN2re18SharedClockManager19changeGrandmasterIDEy_block_invoke(uint64_t a1)
{
  uint64_t v1;
  _anonymous_namespace_ *v2;
  uint64_t *v3;
  NSObject *v4;
  _QWORD *i;
  NSObject *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t ParticipantAtIndex;
  __int128 v12;
  __int128 v13;
  int v14;
  uint8_t buf[4];
  uint64_t v16;
  char v17[46];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v1 = *(_QWORD *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(v1 + 104));
  v12 = 0u;
  v13 = 0u;
  v14 = 1065353216;
  v3 = *(uint64_t **)(v1 + 80);
  if (!v3)
    goto LABEL_13;
  do
  {
    if (*((_DWORD *)v3 + 6))
    {
      v4 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_224FE9000, v4, OS_LOG_TYPE_ERROR, "Non-IPv4 not yet supported", buf, 2u);
      }

    }
    else
    {
      inet_ntop(2, v3 + 5, v17, 0x10u);
      v2 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, char *, uint64_t))(**(_QWORD **)(v1 + 216) + 32))(*(_QWORD *)(v1 + 216), v17, 1500000);
      if ((v2 & 1) != 0)
        goto LABEL_8;
    }
    v2 = (_anonymous_namespace_ *)std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)&v12, (unint64_t *)v3 + 2, v3 + 2);
LABEL_8:
    v3 = (uint64_t *)*v3;
  }
  while (v3);
  for (i = (_QWORD *)v13; i; i = (_QWORD *)*i)
  {
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      v7 = i[2];
      *(_DWORD *)buf = 134217984;
      v16 = v7;
      _os_log_impl(&dword_224FE9000, v6, OS_LOG_TYPE_INFO, "Disconnecting from peer %llu after failing to ping", buf, 0xCu);
    }

    re::SharedClockManager::peerDidLeave((int8x8_t *)v1, i[2]);
  }
LABEL_13:
  os_unfair_lock_unlock((os_unfair_lock_t)(v1 + 104));
  if (*((_QWORD *)&v13 + 1) && *(_QWORD *)(v1 + 40) && RESyncNetSessionParticipantsCount())
  {
    v8 = 0;
    do
    {
      v9 = *(_QWORD *)(v1 + 40);
      ParticipantAtIndex = RESyncNetSessionGetParticipantAtIndex();
      re::SharedClockManager::participantDidJoin(v1, v9, ParticipantAtIndex);
      ++v8;
    }
    while (v8 < RESyncNetSessionParticipantsCount());
  }
  return std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)&v12);
}

void re::SharedClockManager::peerDidLeave(int8x8_t *this, unint64_t a2)
{
  int8x8_t *v4;
  const char *v5;
  const char *v6;
  CFStringRef v7;
  int v8;
  _anonymous_namespace_ *v9;
  int v10;
  NSObject *v11;
  _anonymous_namespace_ *v12;
  int v13;
  _anonymous_namespace_ *v14;
  int v15;
  int8x8_t *v16;
  int8x8_t v17;
  int8x8_t v18;
  unint64_t v19;
  uint8x8_t v20;
  int8x8_t *v21;
  int8x8_t *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  int v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v4 = this + 8;
  v5 = (const char *)std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>(&this[8], a2);
  if (v5)
  {
    if (!*(_QWORD *)&this[7])
      goto LABEL_16;
    v6 = v5;
    v7 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], v5 + 28, 0x8000100u);
    v8 = *((_DWORD *)v6 + 6);
    if (v8 == 2)
    {
      v12 = (_anonymous_namespace_ *)TimeSyncClockRemoveAWDLPort();
      if ((_DWORD)v12)
      {
        v13 = (int)v12;
        v11 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
LABEL_14:

          goto LABEL_15;
        }
        v26 = 136315650;
        v27 = "peerDidLeave";
        v28 = 1024;
        v29 = 513;
        v30 = 1024;
        v31 = v13;
LABEL_47:
        _os_log_error_impl(&dword_224FE9000, v11, OS_LOG_TYPE_ERROR, "%s:%d error: %d", (uint8_t *)&v26, 0x18u);
        goto LABEL_14;
      }
    }
    else
    {
      if (v8 != 1)
      {
        if (v8)
          goto LABEL_15;
        v9 = (_anonymous_namespace_ *)TimeSyncClockRemoveUDPv4EndToEndPort();
        if (!(_DWORD)v9)
          goto LABEL_15;
        v10 = (int)v9;
        v11 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          goto LABEL_14;
        v26 = 136315650;
        v27 = "peerDidLeave";
        v28 = 1024;
        v29 = 505;
        v30 = 1024;
        v31 = v10;
        goto LABEL_47;
      }
      v14 = (_anonymous_namespace_ *)TimeSyncClockRemoveUDPv6EndToEndPort();
      if ((_DWORD)v14)
      {
        v15 = (int)v14;
        v11 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          goto LABEL_14;
        v26 = 136315650;
        v27 = "peerDidLeave";
        v28 = 1024;
        v29 = 509;
        v30 = 1024;
        v31 = v15;
        goto LABEL_47;
      }
    }
LABEL_15:
    CFRelease(v7);
LABEL_16:
    v16 = (int8x8_t *)std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>(v4, a2);
    if (!v16)
      return;
    v17 = this[9];
    v18 = *v16;
    v19 = (unint64_t)v16[1];
    v20 = (uint8x8_t)vcnt_s8(v17);
    v20.i16[0] = vaddlv_u8(v20);
    if (v20.u32[0] > 1uLL)
    {
      if (v19 >= *(_QWORD *)&v17)
        v19 %= *(_QWORD *)&v17;
    }
    else
    {
      v19 &= *(_QWORD *)&v17 - 1;
    }
    v21 = *(int8x8_t **)(*(_QWORD *)v4 + 8 * v19);
    do
    {
      v22 = v21;
      v21 = (int8x8_t *)*v21;
    }
    while (v21 != v16);
    if (v22 == &this[10])
      goto LABEL_34;
    v23 = (unint64_t)v22[1];
    if (v20.u32[0] > 1uLL)
    {
      if (v23 >= *(_QWORD *)&v17)
        v23 %= *(_QWORD *)&v17;
    }
    else
    {
      v23 &= *(_QWORD *)&v17 - 1;
    }
    if (v23 != v19)
    {
LABEL_34:
      if (v18)
      {
        v24 = *(_QWORD *)(*(_QWORD *)&v18 + 8);
        if (v20.u32[0] > 1uLL)
        {
          v25 = *(_QWORD *)(*(_QWORD *)&v18 + 8);
          if (v24 >= *(_QWORD *)&v17)
            v25 = v24 % *(_QWORD *)&v17;
        }
        else
        {
          v25 = v24 & (*(_QWORD *)&v17 - 1);
        }
        if (v25 == v19)
          goto LABEL_38;
      }
      *(_QWORD *)(*(_QWORD *)v4 + 8 * v19) = 0;
      v18 = *v16;
    }
    if (!*(_QWORD *)&v18)
    {
LABEL_44:
      *v22 = v18;
      *v16 = 0;
      --*(_QWORD *)&this[11];
      operator delete(v16);
      return;
    }
    v24 = *(_QWORD *)(*(_QWORD *)&v18 + 8);
LABEL_38:
    if (v20.u32[0] > 1uLL)
    {
      if (v24 >= *(_QWORD *)&v17)
        v24 %= *(_QWORD *)&v17;
    }
    else
    {
      v24 &= *(_QWORD *)&v17 - 1;
    }
    if (v24 != v19)
    {
      *(_QWORD *)(*(_QWORD *)v4 + 8 * v24) = v22;
      v18 = *v16;
    }
    goto LABEL_44;
  }
}

void re::SharedClockManager::participantDidLeave(uint64_t a1)
{
  NSObject *v2;
  unint64_t v3;
  int v4;
  uint64_t PeerID;
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    v4 = 134217984;
    PeerID = RESyncParticipantGetPeerID();
    _os_log_impl(&dword_224FE9000, v2, OS_LOG_TYPE_INFO, "Participant left with peer ID %llu", (uint8_t *)&v4, 0xCu);
  }

  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 104));
  v3 = RESyncParticipantGetPeerID();
  re::SharedClockManager::peerDidLeave((int8x8_t *)a1, v3);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 104));
  if ((unint64_t)RESyncNetSessionParticipantsCount() <= 1)
  {
    if (*(_BYTE *)(a1 + 232))
      re::SharedClockManager::tearDownClocks((re::SharedClockManager *)a1);
  }
}

void ___ZN2re18SharedClockManager10setSessionEP16RESyncNetSession_block_invoke(uint64_t a1)
{
  re::SharedClockManager::participantDidJoin(*(_QWORD *)(a1 + 32));
}

void ___ZN2re18SharedClockManager10setSessionEP16RESyncNetSession_block_invoke_2(uint64_t a1)
{
  re::SharedClockManager::participantDidLeave(*(_QWORD *)(a1 + 32));
}

void ___ZN2re18SharedClockManager10setSessionEP16RESyncNetSession_block_invoke_3(uint64_t a1, uint64_t a2, unint64_t a3, const UInt8 *a4, unint64_t a5)
{
  re::SharedClockManager::didReceiveData(*(_QWORD *)(a1 + 32), a3, a4, a5);
}

void re::SharedClockManager::didReceiveData(uint64_t a1, unint64_t a2, const UInt8 *a3, unint64_t a4)
{
  unint64_t v4;
  CFIndex v8;
  unint64_t v9;
  NSObject *v10;
  void **v11;
  _QWORD *v12;
  uint64_t *v13;
  int8x8_t v14;
  uint64_t v15;
  unint64_t v16;
  uint8x8_t v17;
  uint64_t *v18;
  uint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _OWORD *v23;
  int v24;
  NSObject *v25;
  __int128 v26;
  CFDataRef v27;
  unint64_t v28;
  uint8x8_t v29;
  _QWORD *v30;
  _QWORD *v31;
  unint64_t v32;
  float v33;
  float v34;
  _BOOL8 v35;
  unint64_t v36;
  unint64_t v37;
  int8x8_t prime;
  void *v39;
  void *v40;
  uint64_t v41;
  _QWORD *v42;
  unint64_t v43;
  uint8x8_t v44;
  unint64_t v45;
  uint8x8_t v46;
  uint64_t v47;
  _QWORD *v48;
  unint64_t v49;
  _QWORD *v50;
  _QWORD *v51;
  uint64_t v52;
  unint64_t v53;
  void *v54;
  _QWORD v55[6];
  int v56;
  char v57[12];
  __int128 v58;
  uint8_t buf[4];
  unint64_t v60;
  __int16 v61;
  _WORD v62[17];

  v4 = a4;
  *(_QWORD *)&v62[13] = *MEMORY[0x24BDAC8D0];
  v8 = a4;
  v9 = (unint64_t)a4 >> 5;
  v10 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 134218240;
    v60 = v9;
    v61 = 2048;
    *(_QWORD *)v62 = a2;
    _os_log_impl(&dword_224FE9000, v10, OS_LOG_TYPE_INFO, "Received %lu addresses from %llu:", buf, 0x16u);
  }

  v11 = (void **)(a1 + 240);
  v12 = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>((_QWORD *)(a1 + 240), a2);
  if (v12)
  {
    CFRelease((CFTypeRef)v12[3]);
    v13 = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>((_QWORD *)(a1 + 240), a2);
    if (v13)
    {
      v14 = *(int8x8_t *)(a1 + 248);
      v15 = *v13;
      v16 = v13[1];
      v17 = (uint8x8_t)vcnt_s8(v14);
      v17.i16[0] = vaddlv_u8(v17);
      if (v17.u32[0] > 1uLL)
      {
        if (v16 >= *(_QWORD *)&v14)
          v16 %= *(_QWORD *)&v14;
      }
      else
      {
        v16 &= *(_QWORD *)&v14 - 1;
      }
      v18 = (uint64_t *)*((_QWORD *)*v11 + v16);
      do
      {
        v19 = v18;
        v18 = (uint64_t *)*v18;
      }
      while (v18 != v13);
      if (v19 == (uint64_t *)(a1 + 256))
        goto LABEL_22;
      v20 = v19[1];
      if (v17.u32[0] > 1uLL)
      {
        if (v20 >= *(_QWORD *)&v14)
          v20 %= *(_QWORD *)&v14;
      }
      else
      {
        v20 &= *(_QWORD *)&v14 - 1;
      }
      if (v20 != v16)
      {
LABEL_22:
        if (v15)
        {
          v21 = *(_QWORD *)(v15 + 8);
          if (v17.u32[0] > 1uLL)
          {
            v22 = *(_QWORD *)(v15 + 8);
            if (v21 >= *(_QWORD *)&v14)
              v22 = v21 % *(_QWORD *)&v14;
          }
          else
          {
            v22 = v21 & (*(_QWORD *)&v14 - 1);
          }
          if (v22 == v16)
            goto LABEL_26;
        }
        *((_QWORD *)*v11 + v16) = 0;
        v15 = *v13;
      }
      if (!v15)
      {
LABEL_32:
        *v19 = v15;
        *v13 = 0;
        --*(_QWORD *)(a1 + 264);
        operator delete(v13);
        goto LABEL_33;
      }
      v21 = *(_QWORD *)(v15 + 8);
LABEL_26:
      if (v17.u32[0] > 1uLL)
      {
        if (v21 >= *(_QWORD *)&v14)
          v21 %= *(_QWORD *)&v14;
      }
      else
      {
        v21 &= *(_QWORD *)&v14 - 1;
      }
      if (v21 != v16)
      {
        *((_QWORD *)*v11 + v21) = v19;
        v15 = *v13;
      }
      goto LABEL_32;
    }
  }
LABEL_33:
  if (*(_QWORD *)(a1 + 56))
  {
    if (v4 >= 0x20)
    {
      if (v9 <= 1)
        v9 = 1;
      v23 = a3 + 16;
      do
      {
        *(_DWORD *)buf = *((_DWORD *)v23 - 4);
        v24 = *(_DWORD *)buf;
        strcpy((char *)&v60, (const char *)v23 - 12);
        *(_OWORD *)&v62[1] = *v23;
        v25 = *(NSObject **)(a1 + 112);
        v55[0] = MEMORY[0x24BDAC760];
        v55[1] = 3321888768;
        v55[2] = ___ZN2re18SharedClockManager14didReceiveDataEP16RESyncNetSessionyPKvj_block_invoke;
        v55[3] = &__block_descriptor_80_a8_48c54_ZTSN2re18SharedClockManager23TimeSyncPeerInformationE_e5_v8__0l;
        v55[4] = a1;
        v55[5] = a2;
        v56 = v24;
        strcpy(v57, (const char *)&v60);
        v26 = *v23;
        v23 += 2;
        v58 = v26;
        dispatch_async(v25, v55);
        --v9;
      }
      while (v9);
    }
    return;
  }
  v27 = CFDataCreate((CFAllocatorRef)*MEMORY[0x24BDBD240], a3, v8);
  v28 = *(_QWORD *)(a1 + 248);
  if (v28)
  {
    v29 = (uint8x8_t)vcnt_s8((int8x8_t)v28);
    v29.i16[0] = vaddlv_u8(v29);
    if (v29.u32[0] > 1uLL)
    {
      v4 = a2;
      if (v28 <= a2)
        v4 = a2 % v28;
    }
    else
    {
      v4 = (v28 - 1) & a2;
    }
    v30 = (_QWORD *)*((_QWORD *)*v11 + v4);
    if (v30)
    {
      v31 = (_QWORD *)*v30;
      if (*v30)
      {
        do
        {
          v32 = v31[1];
          if (v32 == a2)
          {
            if (v31[2] == a2)
              goto LABEL_113;
          }
          else
          {
            if (v29.u32[0] > 1uLL)
            {
              if (v32 >= v28)
                v32 %= v28;
            }
            else
            {
              v32 &= v28 - 1;
            }
            if (v32 != v4)
              break;
          }
          v31 = (_QWORD *)*v31;
        }
        while (v31);
      }
    }
  }
  v31 = operator new(0x20uLL);
  *v31 = 0;
  v31[1] = a2;
  v31[2] = a2;
  v31[3] = 0;
  v33 = (float)(unint64_t)(*(_QWORD *)(a1 + 264) + 1);
  v34 = *(float *)(a1 + 272);
  if (!v28 || (float)(v34 * (float)v28) < v33)
  {
    v35 = 1;
    if (v28 >= 3)
      v35 = (v28 & (v28 - 1)) != 0;
    v36 = v35 | (2 * v28);
    v37 = vcvtps_u32_f32(v33 / v34);
    if (v36 <= v37)
      prime = (int8x8_t)v37;
    else
      prime = (int8x8_t)v36;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v28 = *(_QWORD *)(a1 + 248);
    }
    if (*(_QWORD *)&prime > v28)
      goto LABEL_69;
    if (*(_QWORD *)&prime < v28)
    {
      v45 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 264) / *(float *)(a1 + 272));
      if (v28 < 3 || (v46 = (uint8x8_t)vcnt_s8((int8x8_t)v28), v46.i16[0] = vaddlv_u8(v46), v46.u32[0] > 1uLL))
      {
        v45 = std::__next_prime(v45);
      }
      else
      {
        v47 = 1 << -(char)__clz(v45 - 1);
        if (v45 >= 2)
          v45 = v47;
      }
      if (*(_QWORD *)&prime <= v45)
        prime = (int8x8_t)v45;
      if (*(_QWORD *)&prime >= v28)
      {
        v28 = *(_QWORD *)(a1 + 248);
      }
      else
      {
        if (prime)
        {
LABEL_69:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v39 = operator new(8 * *(_QWORD *)&prime);
          v40 = *v11;
          *v11 = v39;
          if (v40)
            operator delete(v40);
          v41 = 0;
          *(int8x8_t *)(a1 + 248) = prime;
          do
            *((_QWORD *)*v11 + v41++) = 0;
          while (*(_QWORD *)&prime != v41);
          v42 = *(_QWORD **)(a1 + 256);
          if (v42)
          {
            v43 = v42[1];
            v44 = (uint8x8_t)vcnt_s8(prime);
            v44.i16[0] = vaddlv_u8(v44);
            if (v44.u32[0] > 1uLL)
            {
              if (v43 >= *(_QWORD *)&prime)
                v43 %= *(_QWORD *)&prime;
            }
            else
            {
              v43 &= *(_QWORD *)&prime - 1;
            }
            *((_QWORD *)*v11 + v43) = a1 + 256;
            v48 = (_QWORD *)*v42;
            if (*v42)
            {
              do
              {
                v49 = v48[1];
                if (v44.u32[0] > 1uLL)
                {
                  if (v49 >= *(_QWORD *)&prime)
                    v49 %= *(_QWORD *)&prime;
                }
                else
                {
                  v49 &= *(_QWORD *)&prime - 1;
                }
                if (v49 != v43)
                {
                  if (!*((_QWORD *)*v11 + v49))
                  {
                    *((_QWORD *)*v11 + v49) = v42;
                    goto LABEL_94;
                  }
                  *v42 = *v48;
                  *v48 = **((_QWORD **)*v11 + v49);
                  **((_QWORD **)*v11 + v49) = v48;
                  v48 = v42;
                }
                v49 = v43;
LABEL_94:
                v42 = v48;
                v48 = (_QWORD *)*v48;
                v43 = v49;
              }
              while (v48);
            }
          }
          v28 = (unint64_t)prime;
          goto LABEL_98;
        }
        v54 = *v11;
        *v11 = 0;
        if (v54)
          operator delete(v54);
        v28 = 0;
        *(_QWORD *)(a1 + 248) = 0;
      }
    }
LABEL_98:
    if ((v28 & (v28 - 1)) != 0)
    {
      if (v28 <= a2)
        v4 = a2 % v28;
      else
        v4 = a2;
    }
    else
    {
      v4 = (v28 - 1) & a2;
    }
  }
  v50 = *v11;
  v51 = (_QWORD *)*((_QWORD *)*v11 + v4);
  if (v51)
  {
    *v31 = *v51;
  }
  else
  {
    v52 = *(_QWORD *)(a1 + 256);
    *v31 = v52;
    *(_QWORD *)(a1 + 256) = v31;
    v50[v4] = a1 + 256;
    if (!v52)
      goto LABEL_112;
    v53 = *(_QWORD *)(v52 + 8);
    if ((v28 & (v28 - 1)) != 0)
    {
      if (v53 >= v28)
        v53 %= v28;
    }
    else
    {
      v53 &= v28 - 1;
    }
    v51 = (char *)*v11 + 8 * v53;
  }
  *v51 = v31;
LABEL_112:
  ++*(_QWORD *)(a1 + 264);
LABEL_113:
  v31[3] = v27;
}

void `anonymous namespace'::LogPeerInformationArray(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _DWORD *i;
  int v5;
  _anonymous_namespace_ *v6;
  NSObject *v7;
  uint8_t *v8;
  NSObject *v9;
  const char *v10;
  _anonymous_namespace_ *v11;
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  char *v15;
  char v16[4];
  uint64_t v17;
  __int16 v18;
  uint8_t *v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    v2 = a2;
    v3 = a1 + 4;
    for (i = (_DWORD *)(a1 + 16); ; i += 8)
    {
      v5 = *(i - 4);
      if (v5 == 1)
        break;
      if (!v5)
      {
        v6 = (_anonymous_namespace_ *)inet_ntop(2, i, (char *)buf, 0x10u);
        v7 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)v16 = 136315394;
          v17 = v3;
          v18 = 2080;
          v19 = buf;
          v8 = (uint8_t *)v16;
          v9 = v7;
          v10 = "   %s udpv4 %s";
          goto LABEL_9;
        }
        goto LABEL_10;
      }
LABEL_11:
      v3 += 32;
      if (!--v2)
        return;
    }
    v11 = (_anonymous_namespace_ *)inet_ntop(30, i, v16, 0x2Eu);
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136315394;
      v13 = v3;
      v14 = 2080;
      v15 = v16;
      v8 = buf;
      v9 = v7;
      v10 = "   %s udpv6 %s";
LABEL_9:
      _os_log_impl(&dword_224FE9000, v9, OS_LOG_TYPE_INFO, v10, v8, 0x16u);
    }
LABEL_10:

    goto LABEL_11;
  }
}

void ___ZN2re18SharedClockManager14didReceiveDataEP16RESyncNetSessionyPKvj_block_invoke(uint64_t a1)
{
  unint64_t v1;
  unint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _anonymous_namespace_ *v6;
  NSObject *v7;
  _anonymous_namespace_ *v8;
  char v9;
  NSObject *v10;
  _BOOL4 v11;
  CFStringRef v12;
  _anonymous_namespace_ *v13;
  NSObject *v14;
  unint64_t v15;
  uint8x8_t v16;
  void **v17;
  char *v18;
  unint64_t v19;
  float v20;
  float v21;
  _BOOL8 v22;
  unint64_t v23;
  unint64_t v24;
  int8x8_t prime;
  void *v26;
  _QWORD *v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  uint8x8_t v31;
  unint64_t v32;
  uint8x8_t v33;
  uint64_t v34;
  _QWORD *v35;
  unint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  unint64_t v39;
  _QWORD *v40;
  int v41;
  char v42[12];
  __int128 v43;
  uint8_t v44[4];
  uint8_t *v45;
  __int16 v46;
  _QWORD v47[2];
  uint8_t buf[4];
  unint64_t v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  v41 = *(_DWORD *)(a1 + 48);
  strcpy(v42, (const char *)(a1 + 52));
  v43 = *(_OWORD *)(a1 + 64);
  if (*(_QWORD *)(v4 + 56))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v4 + 104));
    v5 = (_QWORD *)(v4 + 64);
    v6 = (_anonymous_namespace_ *)std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>((_QWORD *)(v4 + 64), v3);
    if (v6)
    {
      v7 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134217984;
        v49 = v3;
        _os_log_impl(&dword_224FE9000, v7, OS_LOG_TYPE_INFO, "Already connected to peer %llu", buf, 0xCu);
      }
LABEL_8:

LABEL_9:
      os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 104));
      return;
    }
    if (v41)
    {
      v7 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_error_impl(&dword_224FE9000, v7, OS_LOG_TYPE_ERROR, "Non-IPv4 not yet supported", buf, 2u);
      }
      goto LABEL_8;
    }
    inet_ntop(2, &v43, (char *)buf, 0x10u);
    v8 = (_anonymous_namespace_ *)(*(uint64_t (**)(_QWORD, uint8_t *, uint64_t))(**(_QWORD **)(v4 + 216) + 32))(*(_QWORD *)(v4 + 216), buf, 1500000);
    v9 = (char)v8;
    v10 = objc_claimAutoreleasedReturnValue();
    v11 = os_log_type_enabled(v10, OS_LOG_TYPE_INFO);
    if ((v9 & 1) == 0)
    {
      if (v11)
      {
        *(_DWORD *)v44 = 136315138;
        v45 = buf;
        _os_log_impl(&dword_224FE9000, v10, OS_LOG_TYPE_INFO, "Failed to ping peer at %s", v44, 0xCu);
      }

      goto LABEL_9;
    }
    if (v11)
    {
      *(_DWORD *)v44 = 136315394;
      v45 = buf;
      v46 = 2080;
      v47[0] = v42;
      _os_log_impl(&dword_224FE9000, v10, OS_LOG_TYPE_INFO, "Successfully pinged peer at %s on %s", v44, 0x16u);
    }

    v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x24BDBD240], v42, 0x8000100u);
    v13 = (_anonymous_namespace_ *)TimeSyncClockAddUDPv4EndToEndPort();
    if ((_DWORD)v13)
    {
      v1 = (unint64_t)v13;
      v14 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v44 = 136315650;
        v45 = (uint8_t *)"attemptToReachPeerAtAddress";
        v46 = 1024;
        LODWORD(v47[0]) = 565;
        WORD2(v47[0]) = 1024;
        *(_DWORD *)((char *)v47 + 6) = v1;
        _os_log_error_impl(&dword_224FE9000, v14, OS_LOG_TYPE_ERROR, "%s:%d error: %d", v44, 0x18u);
      }

    }
    v15 = *(_QWORD *)(v4 + 72);
    if (v15)
    {
      v16 = (uint8x8_t)vcnt_s8((int8x8_t)v15);
      v16.i16[0] = vaddlv_u8(v16);
      if (v16.u32[0] > 1uLL)
      {
        v1 = v3;
        if (v15 <= v3)
          v1 = v3 % v15;
      }
      else
      {
        v1 = (v15 - 1) & v3;
      }
      v17 = *(void ***)(*v5 + 8 * v1);
      if (v17)
      {
        v18 = (char *)*v17;
        if (*v17)
        {
          do
          {
            v19 = *((_QWORD *)v18 + 1);
            if (v19 == v3)
            {
              if (*((_QWORD *)v18 + 2) == v3)
                goto LABEL_94;
            }
            else
            {
              if (v16.u32[0] > 1uLL)
              {
                if (v19 >= v15)
                  v19 %= v15;
              }
              else
              {
                v19 &= v15 - 1;
              }
              if (v19 != v1)
                break;
            }
            v18 = *(char **)v18;
          }
          while (v18);
        }
      }
    }
    v18 = (char *)operator new(0x38uLL);
    *(_QWORD *)v18 = 0;
    *((_QWORD *)v18 + 1) = v3;
    *((_QWORD *)v18 + 2) = v3;
    *(_OWORD *)(v18 + 24) = 0u;
    *(_OWORD *)(v18 + 40) = 0u;
    v20 = (float)(unint64_t)(*(_QWORD *)(v4 + 88) + 1);
    v21 = *(float *)(v4 + 96);
    if (v15 && (float)(v21 * (float)v15) >= v20)
    {
LABEL_84:
      v37 = (_QWORD *)*v5;
      v38 = *(_QWORD **)(*v5 + 8 * v1);
      if (v38)
      {
        *(_QWORD *)v18 = *v38;
      }
      else
      {
        *(_QWORD *)v18 = *(_QWORD *)(v4 + 80);
        *(_QWORD *)(v4 + 80) = v18;
        v37[v1] = v4 + 80;
        if (!*(_QWORD *)v18)
          goto LABEL_93;
        v39 = *(_QWORD *)(*(_QWORD *)v18 + 8);
        if ((v15 & (v15 - 1)) != 0)
        {
          if (v39 >= v15)
            v39 %= v15;
        }
        else
        {
          v39 &= v15 - 1;
        }
        v38 = (_QWORD *)(*v5 + 8 * v39);
      }
      *v38 = v18;
LABEL_93:
      ++*(_QWORD *)(v4 + 88);
LABEL_94:
      *((_DWORD *)v18 + 6) = v41;
      strcpy(v18 + 28, v42);
      *(_OWORD *)(v18 + 40) = v43;
      if (v12)
        CFRelease(v12);
      goto LABEL_9;
    }
    v22 = 1;
    if (v15 >= 3)
      v22 = (v15 & (v15 - 1)) != 0;
    v23 = v22 | (2 * v15);
    v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24)
      prime = (int8x8_t)v24;
    else
      prime = (int8x8_t)v23;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v15 = *(_QWORD *)(v4 + 72);
    }
    if (*(_QWORD *)&prime > v15)
      goto LABEL_50;
    if (*(_QWORD *)&prime < v15)
    {
      v32 = vcvtps_u32_f32((float)*(unint64_t *)(v4 + 88) / *(float *)(v4 + 96));
      if (v15 < 3 || (v33 = (uint8x8_t)vcnt_s8((int8x8_t)v15), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        v32 = std::__next_prime(v32);
      }
      else
      {
        v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2)
          v32 = v34;
      }
      if (*(_QWORD *)&prime <= v32)
        prime = (int8x8_t)v32;
      if (*(_QWORD *)&prime >= v15)
      {
        v15 = *(_QWORD *)(v4 + 72);
      }
      else
      {
        if (prime)
        {
LABEL_50:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v26 = operator new(8 * *(_QWORD *)&prime);
          v27 = (_QWORD *)*v5;
          *v5 = v26;
          if (v27)
            operator delete(v27);
          v28 = 0;
          *(int8x8_t *)(v4 + 72) = prime;
          do
            *(_QWORD *)(*v5 + 8 * v28++) = 0;
          while (*(_QWORD *)&prime != v28);
          v29 = *(_QWORD **)(v4 + 80);
          if (v29)
          {
            v30 = v29[1];
            v31 = (uint8x8_t)vcnt_s8(prime);
            v31.i16[0] = vaddlv_u8(v31);
            if (v31.u32[0] > 1uLL)
            {
              if (v30 >= *(_QWORD *)&prime)
                v30 %= *(_QWORD *)&prime;
            }
            else
            {
              v30 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*v5 + 8 * v30) = v4 + 80;
            v35 = (_QWORD *)*v29;
            if (*v29)
            {
              do
              {
                v36 = v35[1];
                if (v31.u32[0] > 1uLL)
                {
                  if (v36 >= *(_QWORD *)&prime)
                    v36 %= *(_QWORD *)&prime;
                }
                else
                {
                  v36 &= *(_QWORD *)&prime - 1;
                }
                if (v36 != v30)
                {
                  if (!*(_QWORD *)(*v5 + 8 * v36))
                  {
                    *(_QWORD *)(*v5 + 8 * v36) = v29;
                    goto LABEL_75;
                  }
                  *v29 = *v35;
                  *v35 = **(_QWORD **)(*v5 + 8 * v36);
                  **(_QWORD **)(*v5 + 8 * v36) = v35;
                  v35 = v29;
                }
                v36 = v30;
LABEL_75:
                v29 = v35;
                v35 = (_QWORD *)*v35;
                v30 = v36;
              }
              while (v35);
            }
          }
          v15 = (unint64_t)prime;
          goto LABEL_79;
        }
        v40 = (_QWORD *)*v5;
        *v5 = 0;
        if (v40)
          operator delete(v40);
        v15 = 0;
        *(_QWORD *)(v4 + 72) = 0;
      }
    }
LABEL_79:
    if ((v15 & (v15 - 1)) != 0)
    {
      if (v15 <= v3)
        v1 = v3 % v15;
      else
        v1 = v3;
    }
    else
    {
      v1 = (v15 - 1) & v3;
    }
    goto LABEL_84;
  }
}

__n128 __copy_helper_block_a8_48c54_ZTSN2re18SharedClockManager23TimeSyncPeerInformationE(__n128 *a1, __n128 *a2)
{
  __n128 result;

  a1[3].n128_u32[0] = a2[3].n128_u32[0];
  strcpy(&a1[3].n128_i8[4], &a2[3].n128_i8[4]);
  result = a2[4];
  a1[4] = result;
  return result;
}

void ___ZN12_GLOBAL__N_114SharedClockLogEv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.re", "SharedClock");
  v1 = (void *)qword_254123388;
  qword_254123388 = (uint64_t)v0;

}

id re::internal::defaultRetain<re::SharedClockService>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return (id)(a1 + 8);
}

void re::internal::defaultRelease<re::SharedClockService>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{

}

uint64_t *re::foundationTimingLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::foundationTimingLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Foundation.Timing");
  }
  return &re::foundationTimingLogObjects(void)::logObjects;
}

uint64_t *re::allocInfo_SimulationClock(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_488);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_488))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254123418, 0);
    *(uint64_t *)((char *)&qword_254123428 + 6) = 0;
    qword_254123428 = 0;
    qword_254123438 = 0;
    qword_254123440 = 0xFFFFFFFFLL;
    qword_254123418 = (uint64_t)&off_24ED7DAA8;
    qword_254123448 = (uint64_t)"SimulationClock";
    dword_254123450 = 0;
    unk_254123458 = 0u;
    unk_254123468 = 0u;
    unk_254123478 = 0u;
    qword_254123488 = 0;
    __cxa_guard_release(&_MergedGlobals_488);
  }
  return &qword_254123418;
}

void re::initInfo_SimulationClock(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x4256CCBB645C544ELL;
  v5[1] = "SimulationClock";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_SimulationClock(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_SimulationClock(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"SimulationClock", (uint64_t (*)(re::internal *))re::allocInfo_SimulationClock, (re::IntrospectionBase *(*)(void))re::initInfo_SimulationClock, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::SimulationClock>, this);
}

_anonymous_namespace_ *re::Scheduler::configure(_anonymous_namespace_ *a1, unint64_t a2)
{
  _anonymous_namespace_ *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  _BYTE *v19;
  uint64_t v20;
  _BYTE *v21;
  unint64_t v22;
  _BYTE *v23;
  uint64_t v24;
  _BYTE *v25;
  _BYTE *v26;
  uint64_t v27;
  _BYTE *v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t *v32;
  _anonymous_namespace_ *v33;
  uint64_t *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  BOOL v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  _anonymous_namespace_ *result;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t *v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t *v77;
  unint64_t v78;
  unint64_t v79;
  unsigned __int8 *v80;
  int v81;
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t *v86;
  unint64_t v87;
  unint64_t v88;
  _QWORD v89[2];
  _BYTE v90[28];
  __int16 v91;
  unint64_t v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  uint64_t v98;

  v3 = a1;
  v98 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1
        *(_QWORD *)v3))
  {
    re::FixedArray<re::StringID>::deinit((_QWORD *)v3 + 1);
    re::FixedArray<re::StringID>::deinit((_QWORD *)v3 + 4);
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v3 + 56);
    *((_QWORD *)v3 + 15) = 0;
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v3 + 128);
    *((_QWORD *)v3 + 24) = 0;
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v3 + 200);
    *((_QWORD *)v3 + 33) = 0;
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v3 + 272);
    *((_QWORD *)v3 + 42) = 0;
    re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)v3 + 344);
    *((_QWORD *)v3 + 51) = 0;
    re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::deinit((_QWORD *)v3 + 52);
    v5 = *((_QWORD *)v3 + 55);
    if (v5)
    {
      if (*((_QWORD *)v3 + 56))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)v3 + 57));
        *((_QWORD *)v3 + 56) = 0;
        *((_QWORD *)v3 + 57) = 0;
      }
      *((_QWORD *)v3 + 55) = 0;
    }
    v6 = *((_QWORD *)v3 + 58);
    if (v6)
    {
      if (*((_QWORD *)v3 + 59))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *((_QWORD *)v3 + 60));
        *((_QWORD *)v3 + 59) = 0;
        *((_QWORD *)v3 + 60) = 0;
      }
      *((_QWORD *)v3 + 58) = 0;
    }
    v7 = *((_QWORD *)v3 + 61);
    if (v7)
    {
      if (*((_QWORD *)v3 + 62))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, *((_QWORD *)v3 + 63));
        *((_QWORD *)v3 + 62) = 0;
        *((_QWORD *)v3 + 63) = 0;
      }
      *((_QWORD *)v3 + 61) = 0;
    }
    re::FixedArray<re::Function<void ()(float)>>::deinit((_QWORD *)v3 + 64);
    v8 = *((_QWORD *)v3 + 67);
    if (v8)
    {
      if (*((_QWORD *)v3 + 68))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *((_QWORD *)v3 + 69));
        *((_QWORD *)v3 + 68) = 0;
        *((_QWORD *)v3 + 69) = 0;
      }
      *((_QWORD *)v3 + 67) = 0;
    }
    v9 = *((_QWORD *)v3 + 70);
    if (v9)
    {
      if (*((_QWORD *)v3 + 71))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 40))(v9, *((_QWORD *)v3 + 72));
        *((_QWORD *)v3 + 71) = 0;
        *((_QWORD *)v3 + 72) = 0;
      }
      *((_QWORD *)v3 + 70) = 0;
    }
    v10 = *((_QWORD *)v3 + 73);
    if (v10)
    {
      if (*((_QWORD *)v3 + 74))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 40))(v10, *((_QWORD *)v3 + 75));
        *((_QWORD *)v3 + 74) = 0;
        *((_QWORD *)v3 + 75) = 0;
      }
      *((_QWORD *)v3 + 73) = 0;
    }
    v11 = *((_QWORD *)v3 + 76);
    if (v11)
    {
      if (*((_QWORD *)v3 + 77))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 40))(v11, *((_QWORD *)v3 + 78));
        *((_QWORD *)v3 + 77) = 0;
        *((_QWORD *)v3 + 78) = 0;
      }
      *((_QWORD *)v3 + 76) = 0;
    }
    re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::deinit((_QWORD *)v3 + 79);
    v12 = *((_QWORD *)v3 + 82);
    if (v12)
    {
      if (*((_QWORD *)v3 + 83))
      {
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 40))(v12, *((_QWORD *)v3 + 84));
        *((_QWORD *)v3 + 83) = 0;
        *((_QWORD *)v3 + 84) = 0;
      }
      *((_QWORD *)v3 + 82) = 0;
    }
    re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::deinit((_QWORD *)v3 + 85);
    v13 = *((_QWORD *)v3 + 88);
    if (v13)
    {
      if (*((_QWORD *)v3 + 92))
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
      *((_QWORD *)v3 + 92) = 0;
      *((_QWORD *)v3 + 89) = 0;
      *((_QWORD *)v3 + 90) = 0;
      *((_QWORD *)v3 + 88) = 0;
      ++*((_DWORD *)v3 + 182);
    }
    *((_QWORD *)v3 + 93) = 0;
    *((int32x2_t *)v3 + 94) = vdup_n_s32(0x7F7FFFFFu);
    re::Scheduler::ExecutionContext::deinit((_anonymous_namespace_ *)((char *)v3 + 760));
  }
  *(_QWORD *)v3 = v4;
  v14 = atomic_load((unsigned __int8 *)&qword_254123498);
  if ((v14 & 1) == 0)
    goto LABEL_162;
  while (1)
  {
    v86 = *(uint64_t **)(a2 + 32);
    v15 = *(_QWORD *)(a2 + 16);
    if (v15 <= 1)
      v16 = 1;
    else
      v16 = *(_QWORD *)(a2 + 16);
    v17 = *(_QWORD *)(a2 + 72);
    a2 = *(_QWORD *)(a2 + 56);
    v93 = 0uLL;
    *(_QWORD *)&v94 = 0;
    re::FixedArray<re::StringID>::init<>(&v93, v4, v16);
    re::FixedArray<float>::operator=((uint64_t *)v3 + 1, (uint64_t *)&v93);
    re::FixedArray<re::StringID>::deinit(&v93);
    re::FixedArray<re::StringID>::init<>((_QWORD *)v3 + 4, v4, a2);
    *((_QWORD *)v3 + 7) = v4;
    re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity((_QWORD *)v3 + 7, 0);
    *((_DWORD *)v3 + 18) += 2;
    if ((a2 & 0x3F) != 0)
      v18 = (a2 >> 6) + 1;
    else
      v18 = a2 >> 6;
    *((_QWORD *)v3 + 15) = a2;
    *(_QWORD *)&v93 = 0;
    re::DynamicOverflowArray<unsigned long long,5ul>::resize((_anonymous_namespace_ *)((char *)v3 + 56), v18, &v93);
    *((_QWORD *)v3 + 16) = v4;
    re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity((_QWORD *)v3 + 16, 0);
    *((_DWORD *)v3 + 36) += 2;
    *((_QWORD *)v3 + 24) = a2;
    *(_QWORD *)&v93 = 0;
    v85 = (uint64_t)v3 + 128;
    re::DynamicOverflowArray<unsigned long long,5ul>::resize((_anonymous_namespace_ *)((char *)v3 + 128), v18, &v93);
    *((_QWORD *)v3 + 25) = v4;
    re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity((_QWORD *)v3 + 25, 0);
    *((_DWORD *)v3 + 54) += 2;
    *((_QWORD *)v3 + 33) = a2;
    *(_QWORD *)&v93 = 0;
    re::DynamicOverflowArray<unsigned long long,5ul>::resize((_anonymous_namespace_ *)((char *)v3 + 200), v18, &v93);
    *((_QWORD *)v3 + 34) = v4;
    re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity((_QWORD *)v3 + 34, 0);
    *((_DWORD *)v3 + 72) += 2;
    *((_QWORD *)v3 + 42) = a2;
    *(_QWORD *)&v93 = 0;
    re::DynamicOverflowArray<unsigned long long,5ul>::resize((_anonymous_namespace_ *)((char *)v3 + 272), v18, &v93);
    *((_QWORD *)v3 + 43) = v4;
    re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity((_QWORD *)v3 + 43, 0);
    *((_DWORD *)v3 + 90) += 2;
    *((_QWORD *)v3 + 51) = a2;
    *(_QWORD *)&v93 = 0;
    v84 = (uint64_t)v3 + 344;
    v88 = v18;
    re::DynamicOverflowArray<unsigned long long,5ul>::resize((_anonymous_namespace_ *)((char *)v3 + 344), v18, &v93);
    re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::init<>((uint64_t)v3 + 416, v4, v16);
    *((_QWORD *)v3 + 55) = v4;
    *((_QWORD *)v3 + 56) = a2;
    if (!a2)
      goto LABEL_58;
    v19 = (_BYTE *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)v4 + 32))(v4, a2, 1);
    *((_QWORD *)v3 + 57) = v19;
    if (!v19)
    {
LABEL_158:
      re::internal::assertLog((re::internal *)4, v20, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
LABEL_159:
      re::internal::assertLog((re::internal *)4, v24, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
LABEL_160:
      re::internal::assertLog((re::internal *)4, v27, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      _os_crash();
      __break(1u);
      goto LABEL_161;
    }
    v21 = v19;
    v22 = a2 - 1;
    if (a2 != 1)
    {
      memset(v19, 1, a2 - 1);
      v21 += v22;
    }
    *v21 = 1;
    *((_QWORD *)v3 + 58) = v4;
    *((_QWORD *)v3 + 59) = a2;
    v23 = (_BYTE *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)v4 + 32))(v4, a2, 1);
    *((_QWORD *)v3 + 60) = v23;
    if (!v23)
      goto LABEL_159;
    v25 = v23;
    if (a2 != 1)
    {
      memset(v23, 1, a2 - 1);
      v25 += v22;
    }
    *v25 = 1;
    *((_QWORD *)v3 + 61) = v4;
    *((_QWORD *)v3 + 62) = a2;
    v26 = (_BYTE *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)v4 + 32))(v4, a2, 1);
    *((_QWORD *)v3 + 63) = v26;
    if (!v26)
      goto LABEL_160;
    v28 = v26;
    if (a2 == 1)
    {
      *v26 = 0;
      *((_QWORD *)v3 + 64) = v4;
      *((_QWORD *)v3 + 65) = 1;
    }
    else
    {
      bzero(v26, a2 - 1);
      v28[v22] = 0;
      *((_QWORD *)v3 + 64) = v4;
      *((_QWORD *)v3 + 65) = a2;
      if (a2 > 0x666666666666666)
      {
        re::internal::assertLog((re::internal *)6, v29, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 40, a2);
        _os_crash();
        __break(1u);
LABEL_58:
        *((_QWORD *)v3 + 58) = v4;
        *((_QWORD *)v3 + 59) = 0;
        *((_QWORD *)v3 + 61) = v4;
        *((_QWORD *)v3 + 62) = 0;
        *((_QWORD *)v3 + 64) = v4;
        *((_QWORD *)v3 + 65) = 0;
        goto LABEL_64;
      }
    }
    v30 = (uint64_t *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)v4 + 32))(v4, 40 * a2, 8);
    *((_QWORD *)v3 + 66) = v30;
    if (v30)
      break;
LABEL_161:
    re::internal::assertLog((re::internal *)4, v31, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
LABEL_162:
    if (__cxa_guard_acquire(&qword_254123498))
    {
      qword_2541234A8 = 0x32549179C460AFB4;
      unk_2541234B0 = "DefaultPhase";
      __cxa_guard_release(&qword_254123498);
    }
  }
  v32 = v30;
  if (a2 != 1)
  {
    do
    {
      v32[4] = 0;
      *(_OWORD *)v32 = 0u;
      *((_OWORD *)v32 + 1) = 0u;
      v30 = re::globalAllocators((re *)v30);
      v32[3] = v30[2];
      v32[4] = 0;
      v32 += 5;
      --v22;
    }
    while (v22);
  }
  v32[4] = 0;
  *(_OWORD *)v32 = 0u;
  *((_OWORD *)v32 + 1) = 0u;
  v32[3] = re::globalAllocators((re *)v30)[2];
  v32[4] = 0;
LABEL_64:
  v82 = v17;
  re::FixedArray<int>::init<>((uint64_t *)v3 + 67, v4, a2);
  re::FixedArray<double>::init<>((uint64_t *)v3 + 70, v4, a2);
  re::FixedArray<unsigned long>::init<>((uint64_t *)v3 + 73, v4, a2);
  re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::init<>((uint64_t)v3 + 632, v4, a2);
  re::FixedArray<double>::init<>((uint64_t *)v3 + 82, v4, a2);
  re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::init<>((uint64_t)v3 + 680, v4, v16);
  *((_QWORD *)v3 + 88) = v4;
  v33 = (_anonymous_namespace_ *)re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)v3 + 88, 0);
  ++*((_DWORD *)v3 + 182);
  *((_QWORD *)v3 + 93) = 0;
  *((int32x2_t *)v3 + 94) = vdup_n_s32(0x7F7FFFFFu);
  *(_QWORD *)&v95 = 0;
  *((_QWORD *)&v93 + 1) = 0;
  *(_QWORD *)&v94 = 0;
  DWORD2(v94) = 0;
  re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity(&v93, v16);
  ++DWORD2(v94);
  *(_QWORD *)v90 = 0;
  do
  {
    re::DynamicArray<unsigned long>::add(&v93, v90);
    ++*(_QWORD *)v90;
  }
  while (*(_QWORD *)v90 < v16);
  if (v15)
    v34 = v86;
  else
    v34 = &qword_2541234A8;
  v89[0] = v95;
  v89[1] = v94;
  memset(v90, 0, 24);
  re::FixedArray<unsigned long>::init<>((uint64_t *)v90, v4, v94);
  re::FixedArray<unsigned long>::copy(v90, (uint64_t)v89);
  re::FixedArray<unsigned long>::operator=((uint64_t *)v3 + 76, (uint64_t *)v90);
  if (*(_QWORD *)v90 && *(_QWORD *)&v90[8])
    (*(void (**)(void))(**(_QWORD **)v90 + 40))();
  if ((_QWORD)v93 && (_QWORD)v95)
    (*(void (**)(void))(*(_QWORD *)v93 + 40))();
  v35 = 0;
  v36 = 0;
  v37 = 32;
  v87 = v16;
  do
  {
    v38 = *((_QWORD *)v3 + 2);
    if (v38 <= v36)
    {
LABEL_145:
      v89[0] = 0;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v93 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v90 = 136315906;
      *(_QWORD *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 468;
      *(_WORD *)&v90[18] = 2048;
      *(_QWORD *)&v90[20] = v36;
      v91 = 2048;
      v92 = v38;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_146:
      v89[0] = 0;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v93 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v90 = 136315906;
      *(_QWORD *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 468;
      *(_WORD *)&v90[18] = 2048;
      *(_QWORD *)&v90[20] = v36;
      v91 = 2048;
      v92 = v38;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_147:
      v89[0] = 0;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v93 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v90 = 136315906;
      *(_QWORD *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 468;
      *(_WORD *)&v90[18] = 2048;
      *(_QWORD *)&v90[20] = v36;
      v91 = 2048;
      v92 = v38;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_148:
      v89[0] = 0;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v93 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v90 = 136315906;
      *(_QWORD *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 468;
      *(_WORD *)&v90[18] = 2048;
      *(_QWORD *)&v90[20] = v36;
      v91 = 2048;
      v92 = v38;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_149:
      v89[0] = 0;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v93 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v90 = 136315906;
      *(_QWORD *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 468;
      *(_WORD *)&v90[18] = 2048;
      *(_QWORD *)&v90[20] = v36;
      v91 = 2048;
      v92 = v38;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_150:
      v89[0] = 0;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v93 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v90 = 136315906;
      *(_QWORD *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 468;
      *(_WORD *)&v90[18] = 2048;
      *(_QWORD *)&v90[20] = v38;
      v91 = 2048;
      v92 = v36;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_151:
      v89[0] = 0;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v93 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v90 = 136315906;
      *(_QWORD *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 468;
      *(_WORD *)&v90[18] = 2048;
      *(_QWORD *)&v90[20] = v38;
      v91 = 2048;
      v92 = v36;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_152:
      v89[0] = 0;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v93 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v90 = 136315906;
      *(_QWORD *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 468;
      *(_WORD *)&v90[18] = 2048;
      *(_QWORD *)&v90[20] = v38;
      v91 = 2048;
      v92 = v36;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_153:
      v89[0] = 0;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v93 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v90 = 136315906;
      *(_QWORD *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 468;
      *(_WORD *)&v90[18] = 2048;
      *(_QWORD *)&v90[20] = v38;
      v91 = 2048;
      v92 = v36;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_154:
      v89[0] = 0;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v93 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v90 = 136315906;
      *(_QWORD *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 468;
      *(_WORD *)&v90[18] = 2048;
      *(_QWORD *)&v90[20] = v38;
      v91 = 2048;
      v92 = v36;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_155:
      v89[0] = 0;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v93 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v90 = 136315906;
      *(_QWORD *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 468;
      *(_WORD *)&v90[18] = 2048;
      *(_QWORD *)&v90[20] = v38;
      v91 = 2048;
      v92 = v36;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_156:
      v89[0] = 0;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v93 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v90 = 136315906;
      *(_QWORD *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 468;
      *(_WORD *)&v90[18] = 2048;
      *(_QWORD *)&v90[20] = v38;
      v91 = 2048;
      v92 = v36;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_157:
      v89[0] = 0;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v93 = 0u;
      v3 = (_anonymous_namespace_ *)MEMORY[0x24BDACB70];
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v90 = 136315906;
      *(_QWORD *)&v90[4] = "operator[]";
      *(_WORD *)&v90[12] = 1024;
      *(_DWORD *)&v90[14] = 468;
      *(_WORD *)&v90[18] = 2048;
      *(_QWORD *)&v90[20] = v38;
      v91 = 2048;
      v92 = v36;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_158;
    }
    re::StringID::operator=((unint64_t *)(*((_QWORD *)v3 + 3) + v35 * 8), &v34[v35]);
    v38 = *((_QWORD *)v3 + 53);
    if (v38 <= v36)
      goto LABEL_146;
    v39 = *((_QWORD *)v3 + 54);
    *(_QWORD *)(v39 + v37 - 32) = v4;
    v40 = v39 + v37 - 32;
    re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity((_QWORD *)v40, 0);
    *(_DWORD *)(v40 + 16) += 2;
    *(_QWORD *)(v40 + 64) = 0;
    v38 = *((_QWORD *)v3 + 53);
    if (v38 <= v36)
      goto LABEL_147;
    v41 = *((_QWORD *)v3 + 54);
    v42 = *(_QWORD *)(v41 + v37 + 32);
    *(_QWORD *)(v41 + v37 + 32) = a2;
    *(_QWORD *)&v93 = 0;
    re::DynamicOverflowArray<unsigned long long,5ul>::resize((_anonymous_namespace_ *)(v41 + v37 - 32), v88, &v93);
    if (a2 && v42 > a2)
    {
      v43 = *(_QWORD *)(v41 + v37 + 32) & 0x3FLL;
      if (v43)
      {
        v44 = v43 == 63;
        v45 = -1 << v43;
        if (v44)
          v46 = 63;
        else
          v46 = ~v45;
      }
      else
      {
        v46 = 63;
      }
      if ((*(_BYTE *)(v41 + v37 - 16) & 1) != 0)
        v47 = v41 + v37 - 8;
      else
        v47 = *(_QWORD *)(v41 + v37);
      v48 = v47 + 8 * *(_QWORD *)(v41 + v37 - 24);
      *(_QWORD *)(v48 - 8) &= v46;
    }
    v38 = *((_QWORD *)v3 + 86);
    if (v38 <= v36)
      goto LABEL_148;
    v49 = *((_QWORD *)v3 + 87);
    *(_QWORD *)(v49 + v37 - 32) = v4;
    v50 = v49 + v37 - 32;
    re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity((_QWORD *)v50, 0);
    *(_DWORD *)(v50 + 16) += 2;
    *(_QWORD *)(v50 + 64) = 0;
    v38 = *((_QWORD *)v3 + 86);
    if (v38 <= v36)
      goto LABEL_149;
    v51 = *((_QWORD *)v3 + 87);
    v52 = *(_QWORD *)(v51 + v37 + 32);
    *(_QWORD *)(v51 + v37 + 32) = a2;
    *(_QWORD *)&v93 = 0;
    result = re::DynamicOverflowArray<unsigned long long,5ul>::resize((_anonymous_namespace_ *)(v51 + v37 - 32), v88, &v93);
    if (a2 && v52 > a2)
    {
      v54 = *(_QWORD *)(v51 + v37 + 32) & 0x3FLL;
      if (v54)
      {
        v44 = v54 == 63;
        v55 = -1 << v54;
        if (v44)
          v56 = 63;
        else
          v56 = ~v55;
      }
      else
      {
        v56 = 63;
      }
      if ((*(_BYTE *)(v51 + v37 - 16) & 1) != 0)
        v57 = v51 + v37 - 8;
      else
        v57 = *(_QWORD *)(v51 + v37);
      v58 = v57 + 8 * *(_QWORD *)(v51 + v37 - 24);
      *(_QWORD *)(v58 - 8) &= v56;
    }
    ++v36;
    v37 += 72;
    v35 += 2;
    v59 = v87;
  }
  while (v87 != v36);
  if (a2)
  {
    v60 = 0;
    v61 = 0;
    v38 = 0;
    v62 = (unint64_t *)(v82 + 80);
    v63 = 32;
    v83 = v4;
    while (1)
    {
      v36 = *((_QWORD *)v3 + 5);
      if (v36 <= v38)
        goto LABEL_150;
      re::StringID::operator=((unint64_t *)(*((_QWORD *)v3 + 6) + v60), (uint64_t *)v62 - 10);
      if (*((_BYTE *)v62 - 64))
        re::DynamicBitset<unsigned long long,256ul>::setBit(v85, v38);
      else
        re::DynamicBitset<unsigned long long,64ul>::clearBit(v85, v38);
      if (*((_BYTE *)v62 - 56))
        re::DynamicBitset<unsigned long long,256ul>::setBit(v84, v38);
      else
        re::DynamicBitset<unsigned long long,64ul>::clearBit(v84, v38);
      v36 = *((_QWORD *)v3 + 65);
      if (v36 <= v38)
        goto LABEL_151;
      re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>(*((_QWORD *)v3 + 66) + v61, (uint64_t)(v62 - 5));
      v36 = *((_QWORD *)v3 + 68);
      if (v36 <= v38)
        goto LABEL_152;
      *(_DWORD *)(*((_QWORD *)v3 + 69) + 4 * v38) = *((_DWORD *)v62 - 12);
      v36 = *((_QWORD *)v3 + 59);
      if (v36 <= v38)
        goto LABEL_153;
      *(_BYTE *)(*((_QWORD *)v3 + 60) + v38) = *((_BYTE *)v62 - 51);
      v36 = *((_QWORD *)v3 + 62);
      if (v36 <= v38)
        goto LABEL_154;
      *(_BYTE *)(*((_QWORD *)v3 + 63) + v38) = *((_BYTE *)v62 - 44);
      v36 = *((_QWORD *)v3 + 74);
      if (v36 <= v38)
        goto LABEL_155;
      v64 = *v62;
      if (*v62 >= v59)
        v64 = 0;
      *(_QWORD *)(*((_QWORD *)v3 + 75) + 8 * v38) = v64;
      v36 = *((_QWORD *)v3 + 80);
      if (v36 <= v38)
        goto LABEL_156;
      v65 = *((_QWORD *)v3 + 81);
      *(_QWORD *)(v65 + v63 - 32) = v4;
      v66 = v65 + v63 - 32;
      re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity((_QWORD *)v66, 0);
      *(_DWORD *)(v66 + 16) += 2;
      *(_QWORD *)(v66 + 64) = 0;
      v36 = *((_QWORD *)v3 + 80);
      if (v36 <= v38)
        goto LABEL_157;
      v67 = *((_QWORD *)v3 + 81);
      v68 = *(_QWORD *)(v67 + v63 + 32);
      *(_QWORD *)(v67 + v63 + 32) = a2;
      *(_QWORD *)&v93 = 0;
      re::DynamicOverflowArray<unsigned long long,5ul>::resize((_anonymous_namespace_ *)(v67 + v63 - 32), v88, &v93);
      if (v68 > a2)
      {
        v69 = *(_QWORD *)(v67 + v63 + 32) & 0x3FLL;
        if (v69)
        {
          v44 = v69 == 63;
          v70 = -1 << v69;
          if (v44)
            v71 = 63;
          else
            v71 = ~v70;
        }
        else
        {
          v71 = 63;
        }
        if ((*(_BYTE *)(v67 + v63 - 16) & 1) != 0)
          v72 = v67 + v63 - 8;
        else
          v72 = *(_QWORD *)(v67 + v63);
        v73 = v72 + 8 * *(_QWORD *)(v67 + v63 - 24);
        *(_QWORD *)(v73 - 8) &= v71;
      }
      if (*((_BYTE *)v62 - 63))
        re::Scheduler::enqueueTaskWithDeadline(v3, v38, *((float *)v62 - 15));
      ++v38;
      v63 += 72;
      v62 += 16;
      v61 += 40;
      v60 += 16;
      v59 = v87;
      v4 = v83;
      if (a2 == v38)
      {
        v74 = 0;
        v36 = v82;
        while (1)
        {
          v75 = v82 + (v74 << 7);
          v76 = *(_QWORD *)(v75 + 104);
          if (v76)
            break;
LABEL_140:
          if (++v74 == a2)
          {
            v79 = 0;
            v80 = (unsigned __int8 *)(v82 + 28);
            do
            {
              v81 = *v80;
              v80 += 128;
              result = re::Scheduler::updateTaskSchedule(v3, v79++, v81);
            }
            while (a2 != v79);
            return result;
          }
        }
        v77 = *(uint64_t **)(v75 + 120);
        v38 = 8 * v76;
        while (1)
        {
          v4 = *v77;
          v78 = *((_QWORD *)v3 + 80);
          if (v78 <= *v77)
            break;
          re::DynamicBitset<unsigned long long,256ul>::setBit(*((_QWORD *)v3 + 81) + 72 * v4, v74);
          ++v77;
          v38 -= 8;
          if (!v38)
            goto LABEL_140;
        }
        v89[0] = 0;
        v96 = 0u;
        v97 = 0u;
        v94 = 0u;
        v95 = 0u;
        v93 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v90 = 136315906;
        *(_QWORD *)&v90[4] = "operator[]";
        *(_WORD *)&v90[12] = 1024;
        *(_DWORD *)&v90[14] = 468;
        *(_WORD *)&v90[18] = 2048;
        *(_QWORD *)&v90[20] = v4;
        v91 = 2048;
        v92 = v78;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_145;
      }
    }
  }
  return result;
}

uint64_t re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::init<>(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;

  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = a3;
  if (!a3)
    return result;
  if (a3 >= 0x38E38E38E38E38FLL)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 72, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v4 = result;
  result = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 72 * a3, 8);
  *(_QWORD *)(v4 + 16) = result;
  if (!result)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    result = _os_crash();
    __break(1u);
    return result;
  }
  v6 = a3 - 1;
  if (a3 != 1)
  {
    do
    {
      *(_QWORD *)result = 0;
      *(_QWORD *)(result + 8) = 0;
      *(_DWORD *)(result + 16) = 1;
      *(_QWORD *)(result + 24) = 0;
      *(_QWORD *)(result + 32) = 0;
      *(_QWORD *)(result + 64) = 0;
      result += 72;
      --v6;
    }
    while (v6);
  }
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 1;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_QWORD *)(result + 64) = 0;
  return result;
}

uint64_t re::FixedArray<re::StringID>::operator[](uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 8) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  return *(_QWORD *)(a1 + 16) + 16 * a2;
}

void re::Scheduler::enqueueTaskWithDeadline(re::Scheduler *this, unint64_t a2, float a3)
{
  unint64_t v3;
  int *v4;
  unint64_t v5;
  unint64_t FirstBitSet;
  re::Scheduler *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  float *v19;
  uint64_t v20;
  re *v21;
  NSObject *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  BOOL v27;
  unint64_t v28;
  unint64_t v29;
  re *isDebugLoggingEnabled;
  NSObject *v31;
  float v32;
  float v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  _QWORD v43[6];
  uint64_t v44;
  _BYTE v45[20];
  _BYTE v46[20];
  uint64_t v47;
  int v48;
  __int16 v49;
  __int16 v50;
  __int16 v51;
  uint8_t buf[32];
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;

  FirstBitSet = a2;
  v56 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 5) <= a2)
  {
    re::internal::assertLog((re::internal *)5, a2, "assertion failure: '%s' (%s:line %i) Invalid task handle: %zu", "task < m_taskNames.size()", "enqueueTaskWithDeadline", 300, a2);
    _os_crash();
    __break(1u);
    goto LABEL_58;
  }
  v8 = this;
  v4 = &v48;
  if (*((float *)this + 210) >= a3)
  {
    v3 = *((_QWORD *)this + 74);
    if (v3 <= a2)
    {
LABEL_60:
      v40 = 0;
      v54 = 0u;
      v55 = 0u;
      v53 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v45 = 136315906;
      *(_QWORD *)&v45[4] = "operator[]";
      *(_WORD *)&v45[12] = 1024;
      *(_DWORD *)&v45[14] = 468;
      *(_WORD *)&v45[18] = 2048;
      *(_QWORD *)v46 = FirstBitSet;
      *(_WORD *)&v46[8] = 2048;
      *(_QWORD *)&v46[10] = v3;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
      goto LABEL_61;
    }
    v9 = *(_QWORD *)(*((_QWORD *)this + 75) + 8 * a2);
    this = (re::Scheduler *)re::DynamicBitset<unsigned long long,256ul>::getBit((uint64_t)this + 128, a2);
    if (!(_DWORD)this)
      goto LABEL_18;
    v10 = *((_QWORD *)v8 + 106);
    if (v9 <= v10 && (v9 != v10 || *((_QWORD *)v8 + 107) >= FirstBitSet))
      goto LABEL_18;
    *(_QWORD *)v45 = 0;
    *(_QWORD *)&v45[8] = 0;
    *(_DWORD *)&v45[16] = 1;
    *(_QWORD *)&v46[4] = 0;
    *(_QWORD *)&v46[12] = 0;
    v11 = *((_QWORD *)v8 + 5);
    if ((v11 & 0x3F) != 0)
      v12 = (v11 >> 6) + 1;
    else
      v12 = v11 >> 6;
    v47 = *((_QWORD *)v8 + 5);
    *(_QWORD *)buf = 0;
    re::DynamicOverflowArray<unsigned long long,5ul>::resize((_anonymous_namespace_ *)v45, v12, buf);
    re::DynamicBitset<unsigned long long,256ul>::setBit((uint64_t)v45, FirstBitSet);
    re::Scheduler::resolveEnabledTaskSetDependencies((uint64_t)&v40, (uint64_t)v8, (uint64_t *)v45);
    v13 = v43;
    if ((v42 & 1) == 0)
      v13 = (unint64_t *)v43[1];
    v14 = v41;
    if ((v41 & 0x3FFFFFFFFFFFFFFLL) == 0)
      goto LABEL_49;
    v15 = 0;
    while (1)
    {
      v17 = *v13++;
      v16 = v17;
      if (v17)
        break;
      v15 -= 64;
      if (!--v14)
        goto LABEL_49;
    }
    v35 = __clz(__rbit64(v16));
    if (v35 + 1 == v15)
    {
LABEL_49:
      if (v40 && (v42 & 1) == 0)
        (*(void (**)(void))(*(_QWORD *)v40 + 40))();
      if (*(_QWORD *)v45)
      {
        if ((v45[16] & 1) == 0)
          (*(void (**)(void))(**(_QWORD **)v45 + 40))();
      }
      return;
    }
    FirstBitSet = v35 - v15;
    while (1)
    {
      v3 = *((_QWORD *)v8 + 74);
      if (v3 <= FirstBitSet)
        break;
      v3 = *(_QWORD *)(*((_QWORD *)v8 + 75) + 8 * FirstBitSet);
      v5 = *((_QWORD *)v8 + 96);
      if (v5 <= v3)
        goto LABEL_59;
      re::DynamicBitset<unsigned long long,256ul>::setBit(*((_QWORD *)v8 + 97) + 72 * v3, FirstBitSet);
      FirstBitSet = re::DynamicBitset<unsigned long long,64ul>::findFirstBitSet((uint64_t)&v40, FirstBitSet + 1);
      if (FirstBitSet == -1)
        goto LABEL_49;
    }
LABEL_58:
    v44 = 0;
    v54 = 0u;
    v55 = 0u;
    v53 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v48 = 136315906;
    *(_QWORD *)(v4 + 1) = "operator[]";
    v49 = 1024;
    *(int *)((char *)v4 + 14) = 468;
    v50 = 2048;
    *(_QWORD *)(v4 + 5) = FirstBitSet;
    v51 = 2048;
    *(_QWORD *)((char *)v4 + 30) = v3;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_59:
    v44 = 0;
    v54 = 0u;
    v55 = 0u;
    v53 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v48 = 136315906;
    *(_QWORD *)(v4 + 1) = "operator[]";
    v49 = 1024;
    *(int *)((char *)v4 + 14) = 468;
    v50 = 2048;
    *(_QWORD *)(v4 + 5) = v3;
    v51 = 2048;
    *(_QWORD *)((char *)v4 + 30) = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_60;
  }
LABEL_18:
  v18 = *((_QWORD *)v8 + 90);
  if (v18)
  {
    v19 = (float *)(*((_QWORD *)v8 + 92) + 8);
    v20 = 16 * v18;
    while (*((_QWORD *)v19 - 1) != FirstBitSet)
    {
      v19 += 4;
      v20 -= 16;
      if (!v20)
        goto LABEL_22;
    }
    if (!(_DWORD)isDebugLoggingEnabled)
      goto LABEL_37;
    if (*v19 <= a3)
      goto LABEL_37;
    v31 = *re::foundationTimingLogObjects(isDebugLoggingEnabled);
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
      goto LABEL_37;
    v37 = *((_QWORD *)v8 + 5);
    if (v37 > FirstBitSet)
    {
      v38 = *(_QWORD *)(*((_QWORD *)v8 + 6) + 16 * FirstBitSet + 8);
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v38;
      *(_WORD *)&buf[12] = 2048;
      *(double *)&buf[14] = a3;
      _os_log_debug_impl(&dword_224FE9000, v31, OS_LOG_TYPE_DEBUG, "Rescheduling task [%s] with deadline: %f", buf, 0x16u);
LABEL_37:
      v32 = fminf(*v19, a3);
      *v19 = v32;
      v33 = fminf(*((float *)v8 + 188), v32);
LABEL_42:
      *((float *)v8 + 188) = v33;
      return;
    }
LABEL_61:
    v40 = 0;
    v54 = 0u;
    v55 = 0u;
    v53 = 0u;
    memset(buf, 0, sizeof(buf));
    v39 = v37;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v45 = 136315906;
    *(_QWORD *)&v45[4] = "operator[]";
    *(_WORD *)&v45[12] = 1024;
    *(_DWORD *)&v45[14] = 468;
    *(_WORD *)&v45[18] = 2048;
    *(_QWORD *)v46 = FirstBitSet;
    *(_WORD *)&v46[8] = 2048;
    *(_QWORD *)&v46[10] = v39;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
LABEL_22:
  if ((_DWORD)v21)
  {
    v22 = *re::foundationTimingLogObjects(v21);
    v21 = (re *)os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)v21)
    {
      v36 = *(_QWORD *)(re::FixedArray<re::StringID>::operator[]((uint64_t)v8 + 32, FirstBitSet) + 8);
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v36;
      *(_WORD *)&buf[12] = 2048;
      *(double *)&buf[14] = a3;
      _os_log_debug_impl(&dword_224FE9000, v22, OS_LOG_TYPE_DEBUG, "Scheduling task [%s] with deadline: %f", buf, 0x16u);
    }
  }
  v23 = *((_QWORD *)v8 + 90);
  v24 = *((_QWORD *)v8 + 89);
  if (v23 >= v24)
  {
    v25 = v23 + 1;
    if (v24 < v23 + 1)
    {
      if (*((_QWORD *)v8 + 88))
      {
        v26 = 2 * v24;
        v27 = v24 == 0;
        v28 = 8;
        if (!v27)
          v28 = v26;
        if (v28 <= v25)
          v29 = v25;
        else
          v29 = v28;
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)v8 + 88, v29);
      }
      else
      {
        re::DynamicArray<re::RigNodeConstraint>::setCapacity((_QWORD *)v8 + 88, v25);
        ++*((_DWORD *)v8 + 182);
      }
    }
    v23 = *((_QWORD *)v8 + 90);
  }
  v34 = *((_QWORD *)v8 + 92) + 16 * v23;
  *(_QWORD *)v34 = FirstBitSet;
  *(float *)(v34 + 8) = a3;
  ++*((_QWORD *)v8 + 90);
  ++*((_DWORD *)v8 + 182);
  if (re::DynamicBitset<unsigned long long,256ul>::getBit((uint64_t)v8 + 128, FirstBitSet))
  {
    v33 = fminf(*((float *)v8 + 188), a3);
    goto LABEL_42;
  }
}

uint64_t re::Scheduler::ExecutionContext::deinit(re::Scheduler::ExecutionContext *this)
{
  uint64_t result;

  re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::deinit(this);
  re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::deinit((_QWORD *)this + 3);
  result = *((_QWORD *)this + 6);
  if (result)
  {
    if (*((_QWORD *)this + 7))
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 40))(result, *((_QWORD *)this + 8));
      *((_QWORD *)this + 7) = 0;
      *((_QWORD *)this + 8) = 0;
    }
    *((_QWORD *)this + 6) = 0;
  }
  *((_QWORD *)this + 9) = 0;
  *((_BYTE *)this + 84) = 0;
  return result;
}

void re::Scheduler::setEnabled(re::Scheduler *this, unint64_t a2, int a3)
{
  char v3;
  char *v6;

  v3 = a3;
  v6 = (char *)this + 128;
  if (re::DynamicBitset<unsigned long long,256ul>::getBit((uint64_t)this + 128, a2) != a3)
  {
    if ((v3 & 1) != 0)
    {
      re::DynamicBitset<unsigned long long,256ul>::setBit((uint64_t)v6, a2);
      re::Scheduler::recalculateNextScheduledDelta(this);
      if (re::DynamicBitset<unsigned long long,256ul>::getBit((uint64_t)this + 200, a2))
        re::Scheduler::recalculateNextUpdateIntervalUpdate(this, a2);
      if (re::DynamicBitset<unsigned long long,256ul>::getBit((uint64_t)this + 344, a2))
        re::Scheduler::resetTaskCurrentTime(this, a2);
    }
    else
    {
      re::DynamicBitset<unsigned long long,64ul>::clearBit((uint64_t)v6, a2);
      re::Scheduler::recalculateNextScheduledDelta(this);
    }
  }
}

uint64_t re::Scheduler::recalculateNextScheduledDelta(re::Scheduler *this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t FirstBitSet;
  unint64_t v14;
  float v15;
  uint64_t v16;
  uint64_t v17;
  float *v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  char v22;
  _QWORD v23[6];
  uint64_t v24;
  unint64_t v25;
  char v26;
  _QWORD v27[7];
  int v28;
  const char *v29;
  __int16 v30;
  int v31;
  __int16 v32;
  unint64_t v33;
  __int16 v34;
  unint64_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  re::DynamicOverflowArray<unsigned long long,5ul>::DynamicOverflowArray((uint64_t)&v24, (uint64_t *)this + 34);
  v27[5] = *((_QWORD *)this + 42);
  re::DynamicBitset<unsigned long long,256ul>::andWithBitSet((uint64_t)&v24, (uint64_t)this + 128);
  v2 = v27;
  if ((v26 & 1) == 0)
    v2 = (uint64_t *)v27[1];
  if (v25 >= 0xB)
  {
    v3 = 8 * v25;
    while (!*v2)
    {
      ++v2;
      v3 -= 8;
      if (!v3)
        goto LABEL_13;
    }
    goto LABEL_12;
  }
  if (v25)
  {
    v4 = 0;
    v5 = 8 * v25;
    do
    {
      v6 = *v2++;
      v4 |= v6;
      v5 -= 8;
    }
    while (v5);
    if (v4)
    {
LABEL_12:
      *((_DWORD *)this + 188) = 0;
      goto LABEL_32;
    }
  }
LABEL_13:
  *((_DWORD *)this + 188) = *((_DWORD *)this + 189);
  re::DynamicOverflowArray<unsigned long long,5ul>::DynamicOverflowArray((uint64_t)&v20, (uint64_t *)this + 25);
  v23[5] = *((_QWORD *)this + 33);
  re::DynamicBitset<unsigned long long,256ul>::andWithBitSet((uint64_t)&v20, (uint64_t)this + 128);
  v7 = (unint64_t *)v23[1];
  if ((v22 & 1) != 0)
    v7 = v23;
  v8 = v21;
  if ((v21 & 0x3FFFFFFFFFFFFFFLL) != 0)
  {
    v9 = 0;
    while (1)
    {
      v11 = *v7++;
      v10 = v11;
      if (v11)
        break;
      v9 -= 64;
      if (!--v8)
        goto LABEL_24;
    }
    v12 = __clz(__rbit64(v10));
    if (v12 + 1 != v9)
    {
      FirstBitSet = v12 - v9;
      v14 = *((_QWORD *)this + 71);
      do
      {
        if (v14 <= FirstBitSet)
        {
          v27[6] = 0;
          v39 = 0u;
          v40 = 0u;
          v37 = 0u;
          v38 = 0u;
          v36 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v28 = 136315906;
          v29 = "operator[]";
          v30 = 1024;
          v31 = 468;
          v32 = 2048;
          v33 = FirstBitSet;
          v34 = 2048;
          v35 = v14;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v15 = *(double *)(*((_QWORD *)this + 72) + 8 * FirstBitSet) - *((double *)this + 93);
        *((float *)this + 188) = fminf(*((float *)this + 188), v15);
        FirstBitSet = re::DynamicBitset<unsigned long long,64ul>::findFirstBitSet((uint64_t)&v20, FirstBitSet + 1);
      }
      while (FirstBitSet != -1);
    }
  }
LABEL_24:
  v16 = *((_QWORD *)this + 90);
  if (v16)
  {
    v17 = 16 * v16;
    v18 = (float *)(*((_QWORD *)this + 92) + 8);
    do
    {
      if (re::DynamicBitset<unsigned long long,256ul>::getBit((uint64_t)this + 128, *((_QWORD *)v18 - 1)))
        *((float *)this + 188) = fminf(*((float *)this + 188), *v18);
      v18 += 4;
      v17 -= 16;
    }
    while (v17);
  }
  if (v20 && (v22 & 1) == 0)
    (*(void (**)(void))(*(_QWORD *)v20 + 40))();
LABEL_32:
  result = v24;
  if (v24)
  {
    if ((v26 & 1) == 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v24 + 40))();
  }
  return result;
}

double re::Scheduler::recalculateNextUpdateIntervalUpdate(re::Scheduler *this, unint64_t a2)
{
  double v2;
  double v3;
  double v4;
  double result;

  if (*((_QWORD *)this + 68) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_8;
  }
  if (*((_QWORD *)this + 71) <= a2)
  {
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_9;
  }
  v2 = *((double *)this + 93);
  v3 = *(float *)(*((_QWORD *)this + 69) + 4 * a2);
  v4 = (floor(v2 / v3 + 0.001) + 1.0) * v3;
  if (v2 == 0.0)
    v4 = 0.0;
  *(double *)(*((_QWORD *)this + 72) + 8 * a2) = v4;
  if (*((_QWORD *)this + 83) <= a2)
  {
LABEL_9:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  result = *((double *)this + 93);
  *(double *)(*((_QWORD *)this + 84) + 8 * a2) = result;
  return result;
}

double re::Scheduler::resetTaskCurrentTime(re::Scheduler *this, unint64_t a2)
{
  double result;

  if (re::DynamicBitset<unsigned long long,256ul>::getBit((uint64_t)this + 200, a2))
    return re::Scheduler::recalculateNextUpdateIntervalUpdate(this, a2);
  if (*((_QWORD *)this + 83) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  result = *((double *)this + 93);
  *(double *)(*((_QWORD *)this + 84) + 8 * a2) = result;
  return result;
}

uint64_t re::Scheduler::setEnabled(uint64_t result, uint64_t a2, int a3)
{
  re::Scheduler *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v23;
  unint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t FirstBitSet;
  unint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  _QWORD v41[6];
  uint64_t v42;
  uint64_t v43;
  char v44;
  _QWORD v45[5];
  uint64_t v46;

  v4 = (re::Scheduler *)result;
  v5 = result + 128;
  v6 = *(_QWORD *)(a2 + 8);
  v7 = *(_QWORD *)(result + 136);
  if (v6 >= v7)
    v8 = *(_QWORD *)(result + 136);
  else
    v8 = *(_QWORD *)(a2 + 8);
  if (!a3)
  {
    if (v8)
    {
      v16 = 0;
      v17 = a2 + 24;
      if ((*(_BYTE *)(a2 + 16) & 1) == 0)
        v17 = *(_QWORD *)(a2 + 32);
      v18 = 1;
      do
      {
        v19 = result + 152;
        if ((*(_DWORD *)(result + 144) & 1) == 0)
          v19 = *(_QWORD *)(result + 160);
        if ((*(_QWORD *)(v19 + 8 * v16) & *(_QWORD *)(v17 + 8 * v16)) != 0)
          break;
        v18 = ++v16 < v8;
      }
      while (v8 != v16);
      if (v18)
      {
        re::DynamicBitset<unsigned long long,256ul>::subtractBitSet(result + 128, a2);
        return re::Scheduler::recalculateNextScheduledDelta(v4);
      }
    }
    return result;
  }
  if (v8)
  {
    v9 = 0;
    v10 = *(_QWORD *)(a2 + 32);
    if ((*(_BYTE *)(a2 + 16) & 1) != 0)
      v10 = a2 + 24;
    LOBYTE(v11) = 1;
    while (1)
    {
      v12 = result + 152;
      if ((*(_DWORD *)(result + 144) & 1) == 0)
        v12 = *(_QWORD *)(result + 160);
      v13 = *(_QWORD *)(v12 + 8 * v9);
      v14 = *(_QWORD *)(v10 + 8 * v9);
      if ((v14 & ~v13) != 0)
        goto LABEL_41;
      v11 = (v13 == v14) & v11;
      if (v8 == ++v9)
      {
        if (v7 < v6)
        {
          v15 = v11 ^ 1;
          goto LABEL_27;
        }
        if (v11)
          goto LABEL_41;
        return result;
      }
    }
  }
  if (v7 >= v6)
    goto LABEL_41;
  v15 = 0;
LABEL_27:
  v20 = a2 + 24;
  if ((*(_BYTE *)(a2 + 16) & 1) == 0)
    v20 = *(_QWORD *)(a2 + 32);
  if (*(_QWORD *)(v20 + 8 * v7))
    goto LABEL_41;
  v21 = v20 + 8;
  while (v6 - 1 != v7)
  {
    if (*(_QWORD *)(v21 + 8 * v7++))
      goto LABEL_37;
  }
  v7 = *(_QWORD *)(a2 + 8);
LABEL_37:
  v23 = v7 >= v6 ? v15 : 0;
  if ((v23 & 1) == 0)
  {
LABEL_41:
    re::DynamicOverflowArray<unsigned long long,5ul>::DynamicOverflowArray((uint64_t)&v42, (uint64_t *)(result + 200));
    v46 = *((_QWORD *)v4 + 33);
    re::DynamicBitset<unsigned long long,256ul>::andWithBitSet((uint64_t)&v42, a2);
    re::DynamicBitset<unsigned long long,256ul>::subtractBitSet((uint64_t)&v42, v5);
    re::DynamicBitset<unsigned long long,256ul>::orWithBitSet(v5, a2);
    re::Scheduler::recalculateNextScheduledDelta(v4);
    v24 = v45;
    if ((v44 & 1) == 0)
      v24 = (unint64_t *)v45[1];
    v25 = v43;
    if ((v43 & 0x3FFFFFFFFFFFFFFLL) != 0)
    {
      v26 = 0;
      while (1)
      {
        v28 = *v24++;
        v27 = v28;
        if (v28)
          break;
        v26 -= 64;
        if (!--v25)
          goto LABEL_51;
      }
      v29 = __clz(__rbit64(v27));
      if (v29 + 1 != v26)
      {
        FirstBitSet = v29 - v26;
        do
        {
          re::Scheduler::recalculateNextUpdateIntervalUpdate(v4, FirstBitSet);
          FirstBitSet = re::DynamicBitset<unsigned long long,64ul>::findFirstBitSet((uint64_t)&v42, FirstBitSet + 1);
        }
        while (FirstBitSet != -1);
      }
    }
LABEL_51:
    re::DynamicOverflowArray<unsigned long long,5ul>::DynamicOverflowArray((uint64_t)&v38, &v42);
    v41[5] = v46;
    re::DynamicBitset<unsigned long long,256ul>::andWithBitSet((uint64_t)&v38, (uint64_t)v4 + 344);
    v31 = v41;
    if ((v40 & 1) == 0)
      v31 = (unint64_t *)v41[1];
    v32 = v39;
    if ((v39 & 0x3FFFFFFFFFFFFFFLL) != 0)
    {
      v33 = 0;
      while (1)
      {
        v35 = *v31++;
        v34 = v35;
        if (v35)
          break;
        v33 -= 64;
        if (!--v32)
          goto LABEL_61;
      }
      v36 = __clz(__rbit64(v34));
      if (v36 + 1 != v33)
      {
        v37 = v36 - v33;
        do
        {
          re::Scheduler::resetTaskCurrentTime(v4, v37);
          v37 = re::DynamicBitset<unsigned long long,64ul>::findFirstBitSet((uint64_t)&v38, v37 + 1);
        }
        while (v37 != -1);
      }
    }
LABEL_61:
    if (v38 && (v40 & 1) == 0)
      (*(void (**)(void))(*(_QWORD *)v38 + 40))();
    result = v42;
    if (v42)
    {
      if ((v44 & 1) == 0)
        return (*(uint64_t (**)(void))(*(_QWORD *)v42 + 40))();
    }
  }
  return result;
}

uint64_t re::DynamicBitset<unsigned long long,256ul>::andWithBitSet(uint64_t result, uint64_t a2)
{
  unint64_t v2;
  uint64_t i;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a2 + 8);
  if (v2 >= *(_QWORD *)(result + 8))
    v2 = *(_QWORD *)(result + 8);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = *(_QWORD *)(a2 + 32);
      if ((*(_BYTE *)(a2 + 16) & 1) != 0)
        v4 = a2 + 24;
      v5 = result + 24;
      if ((*(_BYTE *)(result + 16) & 1) == 0)
        v5 = *(_QWORD *)(result + 32);
      *(_QWORD *)(v5 + 8 * i) &= *(_QWORD *)(v4 + 8 * i);
    }
  }
  return result;
}

uint64_t re::DynamicBitset<unsigned long long,256ul>::subtractBitSet(uint64_t result, uint64_t a2)
{
  unint64_t v2;
  uint64_t i;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a2 + 8);
  if (v2 >= *(_QWORD *)(result + 8))
    v2 = *(_QWORD *)(result + 8);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
    {
      v4 = *(_DWORD *)(result + 16);
      v5 = result + 24;
      if ((v4 & 1) == 0)
        v5 = *(_QWORD *)(result + 32);
      if ((*(_BYTE *)(a2 + 16) & 1) != 0)
        v6 = a2 + 24;
      else
        v6 = *(_QWORD *)(a2 + 32);
      v7 = result + 24;
      if ((v4 & 1) == 0)
        v7 = *(_QWORD *)(result + 32);
      *(_QWORD *)(v7 + 8 * i) ^= *(_QWORD *)(v6 + 8 * i) & *(_QWORD *)(v5 + 8 * i);
    }
  }
  return result;
}

re::Scheduler *re::Scheduler::updateTaskSchedule(re::Scheduler *this, unint64_t a2, int a3)
{
  unint64_t v4;
  re::Scheduler *v6;
  int v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;

  v4 = *((_QWORD *)this + 56);
  if (v4 <= a2)
    goto LABEL_39;
  v6 = this;
  if (*(unsigned __int8 *)(*((_QWORD *)this + 57) + a2) == a3)
    return this;
  v7 = 0;
  v8 = 0;
  switch(*(_BYTE *)(*((_QWORD *)this + 57) + a2))
  {
    case 1:
      goto LABEL_11;
    case 2:
      v8 = 0;
      v9 = (uint64_t)this + 200;
      v7 = 1;
      goto LABEL_10;
    case 3:
      v10 = (uint64_t)this + 272;
      goto LABEL_8;
    case 4:
      v7 = 0;
      v9 = (uint64_t)this + 56;
      goto LABEL_9;
    case 5:
      v10 = (uint64_t)this + 200;
LABEL_8:
      re::DynamicBitset<unsigned long long,64ul>::clearBit(v10, a2);
      v9 = (uint64_t)v6 + 56;
      v7 = 1;
LABEL_9:
      v8 = 1;
LABEL_10:
      this = (re::Scheduler *)re::DynamicBitset<unsigned long long,64ul>::clearBit(v9, a2);
      v4 = *((_QWORD *)v6 + 56);
LABEL_11:
      if (v4 <= a2)
        goto LABEL_40;
      *(_BYTE *)(*((_QWORD *)v6 + 57) + a2) = a3;
      switch(a3)
      {
        case 1:
          goto LABEL_14;
        case 2:
        case 5:
          re::Scheduler::recalculateNextUpdateIntervalUpdate(v6, a2);
          this = (re::Scheduler *)re::DynamicBitset<unsigned long long,256ul>::setBit((uint64_t)v6 + 200, a2);
          v7 = 1;
          if (a3 == 5)
            goto LABEL_17;
LABEL_14:
          if ((v8 & 1) == 0)
            goto LABEL_34;
          goto LABEL_18;
        case 3:
          re::DynamicBitset<unsigned long long,256ul>::setBit((uint64_t)v6 + 272, a2);
          v7 = 1;
          goto LABEL_17;
        case 4:
LABEL_17:
          re::DynamicBitset<unsigned long long,256ul>::setBit((uint64_t)v6 + 56, a2);
LABEL_18:
          v11 = *((_QWORD *)v6 + 53);
          if (v11)
          {
            v12 = *((_QWORD *)v6 + 54);
            v13 = v12 + 72 * v11;
            do
            {
              v14 = *(_DWORD *)(v12 + 16);
              if ((v14 & 1) != 0)
                v15 = (_QWORD *)(v12 + 24);
              else
                v15 = *(_QWORD **)(v12 + 32);
              v16 = *(_QWORD *)(v12 + 8);
              while (1)
              {
                v17 = v12 + 24;
                if ((v14 & 1) == 0)
                  v17 = *(_QWORD *)(v12 + 32);
                if (v15 == (_QWORD *)(v17 + 8 * v16))
                  break;
                *v15++ = 0;
                v14 = *(_DWORD *)(v12 + 16);
              }
              v12 += 72;
            }
            while (v12 != v13);
          }
          this = (re::Scheduler *)re::DynamicBitset<unsigned long long,64ul>::findFirstBitSet((uint64_t)v6 + 56, 0);
          if (this == (re::Scheduler *)-1)
            goto LABEL_34;
          v18 = (unint64_t)this;
          break;
        default:
          goto LABEL_42;
      }
      break;
    default:
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unexpected previous task schedule type.", "!\"Unreachable code\"", "updateTaskSchedule", 655);
      _os_crash();
      __break(1u);
LABEL_42:
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unexpected previous task schedule type.", "!\"Unreachable code\"", "updateTaskSchedule", 697);
      _os_crash();
      __break(1u);
      JUMPOUT(0x225D0B690);
  }
  do
  {
    if (*((_QWORD *)v6 + 74) <= v18)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_38:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_39:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_40:
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v19 = *(_QWORD *)(*((_QWORD *)v6 + 75) + 8 * v18);
    if (*((_QWORD *)v6 + 53) <= v19)
      goto LABEL_38;
    re::DynamicBitset<unsigned long long,256ul>::setBit(*((_QWORD *)v6 + 54) + 72 * v19, v18);
    this = (re::Scheduler *)re::DynamicBitset<unsigned long long,64ul>::findFirstBitSet((uint64_t)v6 + 56, v18 + 1);
    v18 = (unint64_t)this;
  }
  while (this != (re::Scheduler *)-1);
LABEL_34:
  if (v7)
    return (re::Scheduler *)re::Scheduler::recalculateNextScheduledDelta(v6);
  return this;
}

uint64_t re::Scheduler::setTaskUpdateInterval(re::Scheduler *this, unint64_t a2, float a3)
{
  uint64_t result;

  if (*((_QWORD *)this + 68) <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  *(float *)(*((_QWORD *)this + 69) + 4 * a2) = a3;
  result = re::DynamicBitset<unsigned long long,256ul>::getBit((uint64_t)this + 200, a2);
  if ((_DWORD)result)
  {
    re::Scheduler::recalculateNextUpdateIntervalUpdate(this, a2);
    return re::Scheduler::recalculateNextScheduledDelta(this);
  }
  return result;
}

uint64_t re::Scheduler::resolveEnabledTaskSetDependencies(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v6;
  unint64_t *v7;
  uint64_t v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t FirstBitSet;
  unint64_t v19;
  uint64_t result;
  BOOL v21;
  uint64_t v22;
  unint64_t v23;
  int v24;
  _QWORD v25[7];
  int v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  unint64_t v31;
  __int16 v32;
  unint64_t v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(re::DynamicOverflowArray<unsigned long long,5ul>::DynamicOverflowArray(a1, a3) + 64) = a3[8];
  re::DynamicOverflowArray<unsigned long long,5ul>::DynamicOverflowArray((uint64_t)&v22, a3);
  v25[5] = a3[8];
  while (1)
  {
    v6 = v23;
    v7 = (v24 & 1) != 0 ? v25 : (unint64_t *)v25[1];
    if (v23 < 0xB)
      break;
    v8 = 8 * v23;
    v9 = v7;
    while (!*v9)
    {
      ++v9;
      v8 -= 8;
      if (!v8)
        goto LABEL_24;
    }
LABEL_14:
    if ((v23 & 0x3FFFFFFFFFFFFFFLL) != 0)
    {
      v14 = 0;
      while (1)
      {
        v16 = *v7++;
        v15 = v16;
        if (v16)
          break;
        v14 -= 64;
        if (!--v6)
          goto LABEL_23;
      }
      v17 = __clz(__rbit64(v15));
      if (v17 + 1 != v14)
      {
        FirstBitSet = v17 - v14;
        do
        {
          v19 = *(_QWORD *)(a2 + 640);
          if (v19 <= FirstBitSet)
          {
            v25[6] = 0;
            v37 = 0u;
            v38 = 0u;
            v35 = 0u;
            v36 = 0u;
            v34 = 0u;
            os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
            v26 = 136315906;
            v27 = "operator[]";
            v28 = 1024;
            v29 = 476;
            v30 = 2048;
            v31 = FirstBitSet;
            v32 = 2048;
            v33 = v19;
            _os_log_send_and_compose_impl();
            _os_crash_msg();
            __break(1u);
          }
          re::DynamicBitset<unsigned long long,256ul>::orWithBitSet((uint64_t)&v22, *(_QWORD *)(a2 + 648) + 72 * FirstBitSet);
          FirstBitSet = re::DynamicBitset<unsigned long long,64ul>::findFirstBitSet((uint64_t)&v22, FirstBitSet + 1);
        }
        while (FirstBitSet != -1);
      }
    }
LABEL_23:
    re::DynamicBitset<unsigned long long,256ul>::andWithBitSet((uint64_t)&v22, a2 + 128);
    re::DynamicBitset<unsigned long long,256ul>::subtractBitSet((uint64_t)&v22, a1);
    re::DynamicBitset<unsigned long long,256ul>::orWithBitSet(a1, (uint64_t)&v22);
  }
  if (v23)
  {
    v10 = 0;
    v11 = 8 * v23;
    v12 = v7;
    do
    {
      v13 = *v12++;
      v10 |= v13;
      v11 -= 8;
    }
    while (v11);
    if (v10)
      goto LABEL_14;
  }
LABEL_24:
  result = v22;
  if (v22)
    v21 = (v24 & 1) == 0;
  else
    v21 = 0;
  if (v21)
    return (*(uint64_t (**)(void))(*(_QWORD *)v22 + 40))();
  return result;
}

uint64_t re::`anonymous namespace'::SchedulerUtil::isDebugLoggingEnabled(re::_anonymous_namespace_::SchedulerUtil *this)
{
  unsigned __int8 v1;
  const char *v3;
  char v4;
  char v5[2];

  v1 = atomic_load((unsigned __int8 *)&qword_2541234A0);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2541234A0))
  {
    re::Defaults::BOOLValue((re::Defaults *)"enableSchedulerLogging", v3, v5);
    if (v5[0])
      v4 = v5[1];
    else
      v4 = 0;
    _MergedGlobals_489 = v4;
    __cxa_guard_release(&qword_2541234A0);
  }
  return _MergedGlobals_489;
}

float re::Scheduler::nextScheduledDelta(re::Scheduler *this)
{
  unint64_t v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  int v6;
  int8x8_t *v7;
  char v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int8x8_t v13;
  uint8x8_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint8x8_t v21;
  uint8x8_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  float result;

  v1 = *((_QWORD *)this + 106);
  v2 = *((_QWORD *)this + 99);
  if (v1 >= v2)
    return *((float *)this + 188);
  v3 = *((_QWORD *)this + 100);
  v4 = v3 + 72 * v1;
  v5 = *((_QWORD *)this + 107) + 1;
  if (v5 >= *(_QWORD *)(v4 + 64))
  {
    v8 = 0;
  }
  else
  {
    v6 = *(_DWORD *)(v4 + 16);
    if ((v6 & 1) != 0)
      v7 = (int8x8_t *)(v4 + 24);
    else
      v7 = *(int8x8_t **)(v4 + 32);
    v9 = 0;
    v10 = *(_QWORD *)(v4 + 8);
    v11 = v4 + 24;
    while (1)
    {
      v12 = v4 + 24;
      if ((v6 & 1) == 0)
        v12 = *(_QWORD *)(v4 + 32);
      if (v7 == (int8x8_t *)(v12 + 8 * v10))
        break;
      v13 = *v7++;
      v14 = (uint8x8_t)vcnt_s8(v13);
      v14.i16[0] = vaddlv_u8(v14);
      v9 += v14.u32[0];
    }
    v15 = v5 >> 6;
    if (v5 >= 0x40)
    {
      if (v15 <= 1)
        v17 = 1;
      else
        v17 = v5 >> 6;
      if (v10 <= v17 - 1)
        goto LABEL_52;
      v18 = 0;
      v16 = 0;
      v19 = 8 * v17;
      do
      {
        v20 = v4 + 24;
        if ((v6 & 1) == 0)
          v20 = *(_QWORD *)(v4 + 32);
        v21 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v20 + v18));
        v21.i16[0] = vaddlv_u8(v21);
        v16 += v21.u32[0];
        v18 += 8;
      }
      while (v19 != v18);
    }
    else
    {
      v16 = 0;
    }
    if (v10 <= v15)
      goto LABEL_51;
    if ((v6 & 1) == 0)
      v11 = *(_QWORD *)(v4 + 32);
    v22 = (uint8x8_t)vcnt_s8((int8x8_t)(*(_QWORD *)(v11 + 8 * v15) & ~(-1 << v5)));
    v22.i16[0] = vaddlv_u8(v22);
    v8 = v9 != v22.u32[0] + v16;
  }
  v23 = v1 + 1;
  if (v1 + 1 < v2)
  {
    do
    {
      if (v2 <= v23)
      {
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_51:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_52:
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v24 = v3 + 72 * v23;
      v25 = *(_QWORD *)(v24 + 8);
      v26 = *(_DWORD *)(v24 + 16);
      if (v25 >= 0xB)
      {
        if ((v26 & 1) != 0)
          v27 = (uint64_t *)(v24 + 24);
        else
          v27 = *(uint64_t **)(v24 + 32);
        v29 = 8 * v25 - 8;
        do
        {
          v30 = *v27++;
          LOBYTE(v25) = v30 != 0;
          if (v30)
            v31 = 1;
          else
            v31 = v29 == 0;
          v29 -= 8;
        }
        while (!v31);
        goto LABEL_46;
      }
      if ((v26 & 1) != 0)
      {
        v28 = (uint64_t *)(v24 + 24);
        if (v25)
        {
LABEL_43:
          v32 = 0;
          v33 = 8 * v25;
          do
          {
            v34 = *v28++;
            v32 |= v34;
            v33 -= 8;
          }
          while (v33);
          v25 = v32 != 0;
        }
      }
      else
      {
        v28 = *(uint64_t **)(v24 + 32);
        if (v25)
          goto LABEL_43;
      }
LABEL_46:
      v8 |= v25;
    }
    while (++v23 != v2);
  }
  result = 0.0;
  if (!v8)
    return *((float *)this + 188);
  return result;
}

_QWORD *re::Scheduler::beginPhaseExecution(re::Scheduler *this, double a2, double a3)
{
  unint64_t FirstBitSet;
  unint64_t v4;
  int *v5;
  unint64_t v6;
  unint64_t v7;
  double v11;
  float v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  BOOL v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int *v29;
  uint64_t v30;
  unint64_t v31;
  re::_anonymous_namespace_::SchedulerUtil *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  re *isDebugLoggingEnabled;
  unint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  double v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  float v53;
  float v54;
  uint64_t Bit;
  re *v56;
  NSObject *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  __int128 v69;
  _QWORD *result;
  double v71;
  re::_anonymous_namespace_::SchedulerUtil *v72;
  uint64_t v73;
  double v74;
  int v75;
  re *v76;
  NSObject *v77;
  uint64_t v78;
  re *v79;
  double v80;
  double v81;
  unint64_t v82;
  uint64_t v83;
  __int16 v84;
  re *v85;
  NSObject *v86;
  float v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  double v91;
  unint64_t v92;
  uint64_t v93;
  _QWORD v94[2];
  char v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  uint64_t v100;
  __int128 v101;
  __int128 v102;
  uint64_t v103;
  _BYTE v104[20];
  _BYTE v105[20];
  uint64_t v106;
  _BYTE v107[18];
  __int16 v108;
  unint64_t v109;
  __int16 v110;
  _BYTE v111[10];
  uint64_t v112;
  _BYTE v113[18];
  __int16 v114;
  unint64_t v115;
  __int16 v116;
  _BYTE v117[10];
  uint64_t v118;
  int v119;
  const char *v120;
  __int16 v121;
  int v122;
  __int16 v123;
  unint64_t v124;
  __int16 v125;
  int *v126;
  uint8_t buf[32];
  __int128 v128;
  __int128 v129;
  __int128 v130;
  uint64_t v131;

  v131 = *MEMORY[0x24BDAC8D0];
  v11 = *((double *)this + 93) + a2;
  *((double *)this + 93) = v11;
  BYTE12(v101) = 0;
  v100 = 0;
  v98 = 0u;
  v99 = 0u;
  v96 = 0u;
  v97 = 0u;
  *(_QWORD *)&v102 = -1;
  *((_QWORD *)&v102 + 1) = -1;
  *(double *)&v101 = v11;
  v12 = a3;
  *((float *)&v101 + 2) = v12;
  v13 = (uint64_t *)((char *)this + 416);
  if (&v96 != (__int128 *)((char *)this + 416) && *v13)
  {
    re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::init<>((uint64_t)&v96, *v13, *((_QWORD *)this + 53));
    if (*((_QWORD *)&v96 + 1) != *((_QWORD *)this + 53))
    {
LABEL_192:
      re::internal::assertLog((re::internal *)4, v14, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
      _os_crash();
      __break(1u);
LABEL_193:
      v94[0] = 0;
      v129 = 0u;
      v130 = 0u;
      v128 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v104 = 136315906;
      *(_QWORD *)&v104[4] = "operator[]";
      *(_WORD *)&v104[12] = 1024;
      *(_DWORD *)&v104[14] = 468;
      *(_WORD *)&v104[18] = 2048;
      *(_QWORD *)v105 = FirstBitSet;
      *(_WORD *)&v105[8] = 2048;
      *(_QWORD *)&v105[10] = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_194:
      v94[0] = 0;
      v129 = 0u;
      v130 = 0u;
      v128 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v104 = 136315906;
      *(_QWORD *)&v104[4] = "operator[]";
      *(_WORD *)&v104[12] = 1024;
      *(_DWORD *)&v104[14] = 468;
      *(_WORD *)&v104[18] = 2048;
      *(_QWORD *)v105 = FirstBitSet;
      *(_WORD *)&v105[8] = 2048;
      *(_QWORD *)&v105[10] = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_195:
      *(_QWORD *)v104 = 0;
      v129 = 0u;
      v130 = 0u;
      v128 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v107 = 136315906;
      *(_QWORD *)&v107[4] = "operator[]";
      *(_WORD *)&v107[12] = 1024;
      *(_DWORD *)&v107[14] = 468;
      v108 = 2048;
      v109 = FirstBitSet;
      v110 = 2048;
      *(_QWORD *)v111 = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_196:
      v94[0] = 0;
      v129 = 0u;
      v130 = 0u;
      v128 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v104 = 136315906;
      *(_QWORD *)&v104[4] = "operator[]";
      *(_WORD *)&v104[12] = 1024;
      *(_DWORD *)&v104[14] = 468;
      *(_WORD *)&v104[18] = 2048;
      *(_QWORD *)v105 = FirstBitSet;
      *(_WORD *)&v105[8] = 2048;
      *(_QWORD *)&v105[10] = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_197:
      v94[0] = 0;
      v129 = 0u;
      v130 = 0u;
      v128 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v104 = 136315906;
      *(_QWORD *)&v104[4] = "operator[]";
      *(_WORD *)&v104[12] = 1024;
      *(_DWORD *)&v104[14] = 468;
      *(_WORD *)&v104[18] = 2048;
      *(_QWORD *)v105 = FirstBitSet;
      *(_WORD *)&v105[8] = 2048;
      *(_QWORD *)&v105[10] = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_198:
      v94[0] = 0;
      v129 = 0u;
      v130 = 0u;
      v128 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      *(_DWORD *)v104 = 136315906;
      *(_QWORD *)&v104[4] = "operator[]";
      *(_WORD *)&v104[12] = 1024;
      *(_DWORD *)&v104[14] = 468;
      *(_WORD *)&v104[18] = 2048;
      *(_QWORD *)v105 = FirstBitSet;
      *(_WORD *)&v105[8] = 2048;
      *(_QWORD *)&v105[10] = v6;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (*((_QWORD *)&v96 + 1))
    {
      v15 = (uint64_t *)*((_QWORD *)this + 54);
      v16 = v97;
      v17 = 72 * *((_QWORD *)&v96 + 1);
      do
      {
        if (v15 != (uint64_t *)v16)
        {
          v18 = *v15;
          if (*(_QWORD *)v16)
          {
            if (v18)
              re::DynamicOverflowArray<unsigned long long,5ul>::copy(v16, (uint64_t)v15);
            else
              *(_QWORD *)(v16 + 8) = 0;
            *(_DWORD *)(v16 + 16) += 2;
          }
          else if (v18)
          {
            v19 = v15[1];
            *(_QWORD *)v16 = v18;
            re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity((_QWORD *)v16, v19);
            *(_DWORD *)(v16 + 16) += 2;
            re::DynamicOverflowArray<unsigned long long,5ul>::copy(v16, (uint64_t)v15);
          }
          *(_QWORD *)(v16 + 64) = v15[8];
        }
        v15 += 9;
        v16 += 72;
        v17 -= 72;
      }
      while (v17);
    }
  }
  re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::init<>((uint64_t)&v97 + 8, *(_QWORD *)this, *((_QWORD *)this + 2));
  if ((_QWORD)v98)
  {
    v20 = *((_QWORD *)&v98 + 1);
    v21 = 72 * v98;
    do
    {
      v4 = *((_QWORD *)this + 5);
      v5 = *(int **)(v20 + 64);
      if ((v4 & 0x3F) != 0)
        v22 = (v4 >> 6) + 1;
      else
        v22 = v4 >> 6;
      *(_QWORD *)(v20 + 64) = v4;
      *(_QWORD *)buf = 0;
      re::DynamicOverflowArray<unsigned long long,5ul>::resize((_anonymous_namespace_ *)v20, v22, buf);
      if (v4)
        v23 = (unint64_t)v5 > v4;
      else
        v23 = 0;
      if (v23)
      {
        v24 = *(_QWORD *)(v20 + 64) & 0x3FLL;
        if (v24)
        {
          v25 = v24 == 63;
          v26 = -1 << v24;
          if (v25)
            v27 = 63;
          else
            v27 = ~v26;
        }
        else
        {
          v27 = 63;
        }
        if ((*(_BYTE *)(v20 + 16) & 1) != 0)
          v28 = v20 + 24;
        else
          v28 = *(_QWORD *)(v20 + 32);
        *(_QWORD *)(v28 + 8 * *(_QWORD *)(v20 + 8) - 8) &= v27;
      }
      v20 += 72;
      v21 -= 72;
    }
    while (v21);
  }
  v29 = (int *)*((_QWORD *)this + 86);
  if (v29)
  {
    v30 = 0;
    v31 = 0;
    FirstBitSet = (unint64_t)this + 128;
    while (1)
    {
      v4 = *((_QWORD *)&v96 + 1);
      if (*((_QWORD *)&v96 + 1) <= v31)
        break;
      v4 = *((_QWORD *)this + 86);
      if (v4 <= v31)
        goto LABEL_170;
      re::DynamicBitset<unsigned long long,256ul>::orWithBitSet(v97 + v30, *((_QWORD *)this + 87) + v30);
      v4 = *((_QWORD *)&v96 + 1);
      if (*((_QWORD *)&v96 + 1) <= v31)
        goto LABEL_171;
      re::DynamicBitset<unsigned long long,256ul>::andWithBitSet(v97 + v30, (uint64_t)this + 128);
      v4 = *((_QWORD *)this + 86);
      if (v4 <= v31)
        goto LABEL_172;
      re::DynamicBitset<unsigned long long,256ul>::subtractBitSet(*((_QWORD *)this + 87) + v30, (uint64_t)this + 128);
      ++v31;
      v30 += 72;
      if (v29 == (int *)v31)
        goto LABEL_43;
    }
    *(_QWORD *)v107 = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v113 = 136315906;
    *(_QWORD *)&v113[4] = "operator[]";
    *(_WORD *)&v113[12] = 1024;
    *(_DWORD *)&v113[14] = 468;
    v114 = 2048;
    v115 = v31;
    v116 = 2048;
    *(_QWORD *)v117 = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_170:
    *(_QWORD *)v107 = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v113 = 136315906;
    *(_QWORD *)&v113[4] = "operator[]";
    *(_WORD *)&v113[12] = 1024;
    *(_DWORD *)&v113[14] = 468;
    v114 = 2048;
    v115 = v31;
    v116 = 2048;
    *(_QWORD *)v117 = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_171:
    *(_QWORD *)v107 = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v113 = 136315906;
    *(_QWORD *)&v113[4] = "operator[]";
    *(_WORD *)&v113[12] = 1024;
    *(_DWORD *)&v113[14] = 468;
    v114 = 2048;
    v115 = v31;
    v116 = 2048;
    *(_QWORD *)v117 = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_172:
    *(_QWORD *)v107 = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v113 = 136315906;
    *(_QWORD *)&v113[4] = "operator[]";
    *(_WORD *)&v113[12] = 1024;
    *(_DWORD *)&v113[14] = 468;
    v114 = 2048;
    v115 = v31;
    v116 = 2048;
    *(_QWORD *)v117 = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_173;
  }
LABEL_43:
  *((_DWORD *)this + 189) = 2139095039;
  re::DynamicOverflowArray<unsigned long long,5ul>::DynamicOverflowArray((uint64_t)v113, (uint64_t *)this + 34);
  v118 = *((_QWORD *)this + 42);
  v32 = (re::_anonymous_namespace_::SchedulerUtil *)re::DynamicBitset<unsigned long long,256ul>::andWithBitSet((uint64_t)v113, (uint64_t)this + 128);
  v33 = *(uint64_t **)&v117[2];
  if ((v113[16] & 1) != 0)
    v33 = (uint64_t *)((char *)&v115 + 4);
  if (*(_QWORD *)&v113[8] < 0xBuLL)
  {
    if (!*(_QWORD *)&v113[8])
      goto LABEL_62;
    v35 = 0;
    v36 = 8 * *(_QWORD *)&v113[8];
    do
    {
      v37 = *v33++;
      v35 |= v37;
      v36 -= 8;
    }
    while (v36);
    if (!v35)
    {
LABEL_62:
      v38 = 2139095039;
      goto LABEL_63;
    }
  }
  else
  {
    v34 = 8 * *(_QWORD *)&v113[8];
    while (!*v33)
    {
      ++v33;
      v34 -= 8;
      if (!v34)
        goto LABEL_62;
    }
  }
  v38 = 0;
  if ((_DWORD)isDebugLoggingEnabled)
  {
    v40 = *(unint64_t **)&v117[2];
    if ((v113[16] & 1) != 0)
      v40 = (unint64_t *)((char *)&v115 + 4);
    v41 = *(_QWORD *)&v113[8];
    if ((*(_QWORD *)&v113[8] & 0x3FFFFFFFFFFFFFFLL) != 0)
    {
      v42 = 0;
      while (1)
      {
        v44 = *v40++;
        v43 = v44;
        if (v44)
          break;
        v42 -= 64;
        if (!--v41)
          goto LABEL_63;
      }
      v92 = __clz(__rbit64(v43));
      if (v92 + 1 != v42)
      {
        FirstBitSet = v92 - v42;
        v29 = &dword_224FE9000;
        do
        {
          v4 = *re::foundationTimingLogObjects(isDebugLoggingEnabled);
          if (os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_DEBUG))
          {
            v6 = *((_QWORD *)this + 5);
            if (v6 <= FirstBitSet)
              goto LABEL_195;
            v93 = *(_QWORD *)(*((_QWORD *)this + 6) + 16 * FirstBitSet + 8);
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v93;
            _os_log_debug_impl(&dword_224FE9000, (os_log_t)v4, OS_LOG_TYPE_DEBUG, "Scheduling continuous task [%s]", buf, 0xCu);
          }
          isDebugLoggingEnabled = (re *)re::DynamicBitset<unsigned long long,64ul>::findFirstBitSet((uint64_t)v113, FirstBitSet + 1);
          FirstBitSet = (unint64_t)isDebugLoggingEnabled;
        }
        while (isDebugLoggingEnabled != (re *)-1);
      }
    }
  }
LABEL_63:
  *((_DWORD *)this + 188) = v38;
  re::DynamicOverflowArray<unsigned long long,5ul>::DynamicOverflowArray((uint64_t)v107, (uint64_t *)this + 25);
  v112 = *((_QWORD *)this + 33);
  re::DynamicBitset<unsigned long long,256ul>::andWithBitSet((uint64_t)v107, (uint64_t)this + 128);
  v45 = *(unint64_t **)&v111[2];
  if ((v107[16] & 1) != 0)
    v45 = (unint64_t *)((char *)&v109 + 4);
  v46 = *(_QWORD *)&v107[8];
  if ((*(_QWORD *)&v107[8] & 0x3FFFFFFFFFFFFFFLL) != 0)
  {
    v47 = 0;
    v48 = v11 + a3;
    while (1)
    {
      v50 = *v45++;
      v49 = v50;
      if (v50)
        break;
      v47 -= 64;
      if (!--v46)
        goto LABEL_71;
    }
    v51 = __clz(__rbit64(v49));
    if (v51 + 1 != v47)
    {
      FirstBitSet = v51 - v47;
      v29 = (int *)&v99;
      v7 = *((_QWORD *)this + 71);
      v4 = 72;
      v5 = &dword_224FE9000;
      while (1)
      {
        if (v7 <= FirstBitSet)
          goto LABEL_179;
        v71 = *(double *)(*((_QWORD *)this + 72) + 8 * FirstBitSet);
        if (v71 <= v48)
          break;
LABEL_154:
        v87 = v71 - *((double *)this + 93);
        *((float *)this + 188) = fminf(*((float *)this + 188), v87);
        FirstBitSet = re::DynamicBitset<unsigned long long,64ul>::findFirstBitSet((uint64_t)v107, FirstBitSet + 1);
        if (FirstBitSet == -1)
          goto LABEL_71;
      }
      v6 = *((_QWORD *)this + 74);
      if (v6 <= FirstBitSet)
        goto LABEL_180;
      v6 = *(_QWORD *)(*((_QWORD *)this + 75) + 8 * FirstBitSet);
      v7 = *((_QWORD *)&v96 + 1);
      if (*((_QWORD *)&v96 + 1) <= v6)
        goto LABEL_181;
      re::DynamicBitset<unsigned long long,256ul>::setBit(v97 + 72 * v6, FirstBitSet);
      v7 = v98;
      if ((unint64_t)v98 <= v6)
        goto LABEL_182;
      v72 = (re::_anonymous_namespace_::SchedulerUtil *)re::DynamicBitset<unsigned long long,256ul>::setBit(*((_QWORD *)&v98 + 1) + 72 * v6, FirstBitSet);
      v6 = *((_QWORD *)this + 68);
      if (v6 <= FirstBitSet)
        goto LABEL_183;
      v6 = *((_QWORD *)this + 59);
      if (v6 <= FirstBitSet)
        goto LABEL_184;
      v74 = *(float *)(*((_QWORD *)this + 69) + 4 * FirstBitSet);
      v75 = *(unsigned __int8 *)(*((_QWORD *)this + 60) + FirstBitSet);
      switch(v75)
      {
        case 3:
          if ((_DWORD)v79)
          {
            v7 = *re::foundationTimingLogObjects(v79);
            if (os_log_type_enabled((os_log_t)v7, OS_LOG_TYPE_DEBUG))
            {
              v6 = *((_QWORD *)this + 5);
              if (v6 <= FirstBitSet)
                goto LABEL_197;
              v89 = *(_QWORD *)(*((_QWORD *)this + 6) + 16 * FirstBitSet + 8);
              *(_DWORD *)buf = 136315394;
              *(_QWORD *)&buf[4] = v89;
              *(_WORD *)&buf[12] = 2048;
              *(double *)&buf[14] = v74;
              _os_log_debug_impl(&dword_224FE9000, (os_log_t)v7, OS_LOG_TYPE_DEBUG, "Scheduling substep interval task [%s] with interval: %f", buf, 0x16u);
            }
          }
          v6 = *((_QWORD *)this + 71);
          if (v6 <= FirstBitSet)
            goto LABEL_186;
          v80 = *(double *)(*((_QWORD *)this + 72) + 8 * FirstBitSet);
          v6 = *((_QWORD *)&v99 + 1);
          if (!*((_QWORD *)&v99 + 1))
          {
            re::FixedArray<unsigned long>::init<>((uint64_t *)&v99, *(_QWORD *)this, *((_QWORD *)this + 5));
            v6 = *((_QWORD *)&v99 + 1);
          }
          if (v6 <= FirstBitSet)
            goto LABEL_188;
          v81 = floor(v48 / v74 + 0.001);
          v82 = (unint64_t)(v81 + 0.5 + 1.0) - (unint64_t)(v80 / v74 + 0.5);
          v83 = v100;
          *(_QWORD *)(v100 + 8 * FirstBitSet) = v82;
          v6 = *((_QWORD *)this + 62);
          if (v6 <= FirstBitSet)
            goto LABEL_189;
          v84 = *(unsigned __int8 *)(*((_QWORD *)this + 63) + FirstBitSet);
          if (*(_BYTE *)(*((_QWORD *)this + 63) + FirstBitSet))
          {
            v6 = *((_QWORD *)this + 83);
            if (v6 <= FirstBitSet)
              goto LABEL_191;
            if (*(double *)(*((_QWORD *)this + 84) + 8 * FirstBitSet) != 0.0 || (++v84, (v84 & 0x100) == 0))
            {
              v6 = *((_QWORD *)&v99 + 1);
              if (*((_QWORD *)&v99 + 1) <= FirstBitSet)
                goto LABEL_193;
              if (v82 > v84)
                *(_QWORD *)(v83 + 8 * FirstBitSet) = v84;
            }
          }
          v7 = *((_QWORD *)this + 71);
          if (v7 <= FirstBitSet)
            goto LABEL_190;
          v71 = (v81 + 1.0) * v74;
          break;
        case 2:
          v71 = (floor(v48 / v74 + 0.001) + 1.0) * v74;
          if ((_DWORD)v85)
          {
            v86 = *re::foundationTimingLogObjects(v85);
            if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
            {
              v6 = *((_QWORD *)this + 5);
              if (v6 <= FirstBitSet)
                goto LABEL_198;
              v90 = *(_QWORD *)(*((_QWORD *)this + 6) + 16 * FirstBitSet + 8);
              v91 = v71 - *((double *)this + 93);
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = v90;
              *(_WORD *)&buf[12] = 2048;
              *(double *)&buf[14] = v74;
              *(_WORD *)&buf[22] = 2048;
              *(double *)&buf[24] = v91;
              _os_log_debug_impl(&dword_224FE9000, v86, OS_LOG_TYPE_DEBUG, "Scheduling combined interval task [%s] with interval: %f (deadline: %f)", buf, 0x20u);
            }
          }
          v7 = *((_QWORD *)this + 71);
          if (v7 <= FirstBitSet)
            goto LABEL_187;
          break;
        case 1:
          if ((_DWORD)v76)
          {
            v77 = *re::foundationTimingLogObjects(v76);
            if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
            {
              v6 = *((_QWORD *)this + 5);
              if (v6 <= FirstBitSet)
                goto LABEL_196;
              v88 = *(_QWORD *)(*((_QWORD *)this + 6) + 16 * FirstBitSet + 8);
              *(_DWORD *)buf = 136315394;
              *(_QWORD *)&buf[4] = v88;
              *(_WORD *)&buf[12] = 2048;
              *(double *)&buf[14] = v74;
              _os_log_debug_impl(&dword_224FE9000, v77, OS_LOG_TYPE_DEBUG, "Scheduling continuous interval task [%s] with interval: %f", buf, 0x16u);
            }
          }
          v7 = *((_QWORD *)this + 71);
          if (v7 <= FirstBitSet)
            goto LABEL_185;
          v78 = *((_QWORD *)this + 72);
          v71 = *(double *)(v78 + 8 * FirstBitSet) + v74;
          goto LABEL_153;
        default:
          re::internal::assertLog((re::internal *)4, v73, "assertion failure: '%s' (%s:line %i) Unknown over schedule strategy.", "!\"Unreachable code\"", "beginPhaseExecution", 515);
          result = (_QWORD *)_os_crash();
          __break(1u);
          return result;
      }
      v78 = *((_QWORD *)this + 72);
LABEL_153:
      *(double *)(v78 + 8 * FirstBitSet) = v71;
      goto LABEL_154;
    }
  }
LABEL_71:
  if (*((_QWORD *)this + 90))
  {
    v7 = 0;
    v29 = &dword_224FE9000;
    v6 = 72;
    while (1)
    {
      v52 = *((_QWORD *)this + 92) + 16 * v7;
      FirstBitSet = *(_QWORD *)v52;
      v53 = *(float *)(v52 + 8);
      v4 = v52 + 8;
      v54 = v53 - a2;
      *(float *)v4 = v54;
      Bit = re::DynamicBitset<unsigned long long,256ul>::getBit((uint64_t)this + 128, FirstBitSet);
      if ((Bit & 1) == 0)
        goto LABEL_85;
      if (*(float *)v4 >= a3)
        break;
      if ((_DWORD)v56)
      {
        v57 = *re::foundationTimingLogObjects(v56);
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
        {
          v5 = (int *)*((_QWORD *)this + 5);
          if ((unint64_t)v5 <= FirstBitSet)
            goto LABEL_194;
          v63 = *(_QWORD *)(*((_QWORD *)this + 6) + 16 * FirstBitSet + 8);
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v63;
          _os_log_debug_impl(&dword_224FE9000, v57, OS_LOG_TYPE_DEBUG, "Scheduling enqueued task [%s]", buf, 0xCu);
        }
      }
      v4 = *((_QWORD *)this + 74);
      if (v4 <= FirstBitSet)
        goto LABEL_175;
      v4 = *(_QWORD *)(*((_QWORD *)this + 75) + 8 * FirstBitSet);
      v5 = (int *)*((_QWORD *)&v96 + 1);
      if (*((_QWORD *)&v96 + 1) <= v4)
        goto LABEL_176;
      re::DynamicBitset<unsigned long long,256ul>::setBit(v97 + 72 * v4, FirstBitSet);
      v5 = (int *)v98;
      if ((unint64_t)v98 <= v4)
        goto LABEL_177;
      re::DynamicBitset<unsigned long long,256ul>::setBit(*((_QWORD *)&v98 + 1) + 72 * v4, FirstBitSet);
      FirstBitSet = *((_QWORD *)this + 90);
      if (FirstBitSet <= v7)
        goto LABEL_178;
      v58 = FirstBitSet - 1;
      if (FirstBitSet - 1 > v7)
      {
        v59 = *((_QWORD *)this + 92);
        v60 = v59 + 16 * FirstBitSet;
        v61 = v59 + 16 * v7;
        v62 = *(_QWORD *)(v60 - 16);
        *(_DWORD *)(v61 + 8) = *(_DWORD *)(v60 - 8);
        *(_QWORD *)v61 = v62;
        v58 = *((_QWORD *)this + 90) - 1;
      }
      *((_QWORD *)this + 90) = v58;
      ++*((_DWORD *)this + 182);
LABEL_86:
      if (v7 >= *((_QWORD *)this + 90))
        goto LABEL_90;
    }
    *((float *)this + 188) = fminf(*((float *)this + 188), *(float *)v4);
LABEL_85:
    ++v7;
    goto LABEL_86;
  }
LABEL_90:
  *(_QWORD *)v104 = 0;
  *(_QWORD *)&v104[8] = 0;
  *(_DWORD *)&v104[16] = 1;
  *(_QWORD *)&v105[4] = 0;
  *(_QWORD *)&v105[12] = 0;
  v64 = *((_QWORD *)this + 5);
  if ((v64 & 0x3F) != 0)
    v65 = (v64 >> 6) + 1;
  else
    v65 = v64 >> 6;
  v106 = *((_QWORD *)this + 5);
  *(_QWORD *)buf = 0;
  re::DynamicOverflowArray<unsigned long long,5ul>::resize((_anonymous_namespace_ *)v104, v65, buf);
  if (*((_QWORD *)&v96 + 1))
  {
    v66 = v97;
    v67 = 72 * *((_QWORD *)&v96 + 1);
    do
    {
      re::DynamicBitset<unsigned long long,256ul>::orWithBitSet((uint64_t)v104, v66);
      v66 += 72;
      v67 -= 72;
    }
    while (v67);
  }
  re::Scheduler::resolveEnabledTaskSetDependencies((uint64_t)v94, (uint64_t)this, (uint64_t *)v104);
  re::DynamicBitset<unsigned long long,256ul>::subtractBitSet((uint64_t)v94, (uint64_t)v104);
  v68 = re::DynamicBitset<unsigned long long,64ul>::findFirstBitSet((uint64_t)v94, 0);
  if (v68 != -1)
  {
    FirstBitSet = v68;
    while (1)
    {
      v31 = *((_QWORD *)this + 74);
      if (v31 <= FirstBitSet)
        break;
      v31 = *(_QWORD *)(*((_QWORD *)this + 75) + 8 * FirstBitSet);
      v29 = (int *)*((_QWORD *)&v96 + 1);
      if (*((_QWORD *)&v96 + 1) <= v31)
        goto LABEL_174;
      re::DynamicBitset<unsigned long long,256ul>::setBit(v97 + 72 * v31, FirstBitSet);
      FirstBitSet = re::DynamicBitset<unsigned long long,64ul>::findFirstBitSet((uint64_t)v94, FirstBitSet + 1);
      if (FirstBitSet == -1)
        goto LABEL_101;
    }
LABEL_173:
    v103 = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v119 = 136315906;
    v120 = "operator[]";
    v121 = 1024;
    v122 = 468;
    v123 = 2048;
    v124 = FirstBitSet;
    v125 = 2048;
    v126 = (int *)v31;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_174:
    v103 = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v119 = 136315906;
    v120 = "operator[]";
    v121 = 1024;
    v122 = 468;
    v123 = 2048;
    v124 = v31;
    v125 = 2048;
    v126 = v29;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_175:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = FirstBitSet;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_176:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = v4;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_177:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = v4;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v5;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_178:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "removeAt";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 931;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = v7;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = FirstBitSet;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_179:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = FirstBitSet;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_180:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = FirstBitSet;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_181:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = v6;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_182:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = v6;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_183:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = FirstBitSet;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_184:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = FirstBitSet;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_185:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = FirstBitSet;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_186:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = FirstBitSet;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_187:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = FirstBitSet;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_188:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = FirstBitSet;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_189:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = FirstBitSet;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_190:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = FirstBitSet;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v7;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_191:
    v94[0] = 0;
    v129 = 0u;
    v130 = 0u;
    v128 = 0u;
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v104 = 136315906;
    *(_QWORD *)&v104[4] = "operator[]";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = 468;
    *(_WORD *)&v104[18] = 2048;
    *(_QWORD *)v105 = FirstBitSet;
    *(_WORD *)&v105[8] = 2048;
    *(_QWORD *)&v105[10] = v6;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_192;
  }
LABEL_101:
  re::Scheduler::ExecutionContext::deinit((re::Scheduler *)((char *)this + 760));
  re::FixedArray<float>::operator=((uint64_t *)this + 95, (uint64_t *)&v96);
  re::FixedArray<float>::operator=((uint64_t *)this + 98, (uint64_t *)&v97 + 1);
  re::FixedArray<unsigned long>::operator=((uint64_t *)this + 101, (uint64_t *)&v99);
  v69 = v102;
  *((_OWORD *)this + 52) = v101;
  *((_OWORD *)this + 53) = v69;
  if (v94[0] && (v95 & 1) == 0)
    (*(void (**)(void))(*(_QWORD *)v94[0] + 40))();
  if (*(_QWORD *)v104 && (v104[16] & 1) == 0)
    (*(void (**)(void))(**(_QWORD **)v104 + 40))();
  if (*(_QWORD *)v107 && (v107[16] & 1) == 0)
    (*(void (**)(void))(**(_QWORD **)v107 + 40))();
  if (*(_QWORD *)v113 && (v113[16] & 1) == 0)
    (*(void (**)(void))(**(_QWORD **)v113 + 40))();
  if ((_QWORD)v99)
  {
    if (*((_QWORD *)&v99 + 1))
    {
      (*(void (**)(void))(*(_QWORD *)v99 + 40))();
      *((_QWORD *)&v99 + 1) = 0;
      v100 = 0;
    }
    *(_QWORD *)&v99 = 0;
  }
  re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::deinit((_QWORD *)&v97 + 1);
  return re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::deinit(&v96);
}

unint64_t re::Scheduler::executePhase(re::Scheduler *this, unint64_t a2)
{
  uint64_t v3;
  unint64_t result;
  unint64_t v5;
  int v6;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  double v12;
  BOOL v13;
  float v14;
  uint64_t v15;
  double v16;
  uint64_t v17;
  double v18;
  float v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  *((_BYTE *)this + 844) = 1;
  *((_QWORD *)this + 106) = a2;
  if (*((_QWORD *)this + 96) <= a2)
    goto LABEL_42;
  v3 = *((_QWORD *)this + 97) + 72 * a2;
  result = re::DynamicBitset<unsigned long long,64ul>::findFirstBitSet(v3, 0);
  if (result != -1)
  {
    v5 = result;
    while (1)
    {
      *((_QWORD *)this + 107) = v5;
      if (*((_QWORD *)this + 56) <= v5)
        goto LABEL_34;
      v6 = *(unsigned __int8 *)(*((_QWORD *)this + 57) + v5);
      if (v6 == 5 || v6 == 2)
      {
        if (*((_QWORD *)this + 59) <= v5)
          goto LABEL_35;
        if (*(_BYTE *)(*((_QWORD *)this + 60) + v5) == 3)
          break;
      }
      if (*((_QWORD *)this + 83) <= v5)
        goto LABEL_36;
      v16 = *((double *)this + 104);
      v17 = *((_QWORD *)this + 84);
      v18 = *(double *)(v17 + 8 * v5);
      *(double *)(v17 + 8 * v5) = v16;
      if (*((_QWORD *)this + 65) <= v5)
        goto LABEL_37;
      v19 = v16 - v18;
      v20 = *((_QWORD *)this + 66);
      *(float *)&v21 = v19;
      (*(void (**)(_QWORD, __int128 *))(**(_QWORD **)(v20 + 40 * v5 + 32) + 16))(*(_QWORD *)(v20 + 40 * v5 + 32), &v21);
LABEL_31:
      result = re::DynamicBitset<unsigned long long,64ul>::findFirstBitSet(v3, v5 + 1);
      v5 = result;
      if (result == -1)
        goto LABEL_32;
    }
    if (*((_QWORD *)this + 68) > v5)
    {
      if (*((_QWORD *)this + 102) <= v5)
      {
LABEL_39:
        v24 = 0u;
        v25 = 0u;
        v22 = 0u;
        v23 = 0u;
        v21 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_40;
      }
      v8 = *((_QWORD *)this + 83);
      if (v8 <= v5)
      {
LABEL_40:
        v24 = 0u;
        v25 = 0u;
        v22 = 0u;
        v23 = 0u;
        v21 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
        goto LABEL_41;
      }
      v9 = *(_QWORD *)(*((_QWORD *)this + 103) + 8 * v5);
      if (!v9)
        goto LABEL_26;
      v10 = 0;
      v11 = *(float *)(*((_QWORD *)this + 69) + 4 * v5);
      v12 = *(double *)(*((_QWORD *)this + 84) + 8 * v5);
      while (*((_QWORD *)this + 65) > v5)
      {
        if (v10)
          v13 = 0;
        else
          v13 = v12 == 0.0;
        if (v13)
          v14 = 0.0;
        else
          v14 = v11;
        v15 = *((_QWORD *)this + 66);
        *(float *)&v21 = v14;
        (*(void (**)(_QWORD, __int128 *))(**(_QWORD **)(v15 + 40 * v5 + 32) + 16))(*(_QWORD *)(v15 + 40 * v5 + 32), &v21);
        if (v9 == ++v10)
        {
          v8 = *((_QWORD *)this + 83);
LABEL_26:
          if (v8 > v5)
          {
            *(_QWORD *)(*((_QWORD *)this + 84) + 8 * v5) = *((_QWORD *)this + 104);
            goto LABEL_31;
          }
LABEL_41:
          v24 = 0u;
          v25 = 0u;
          v22 = 0u;
          v23 = 0u;
          v21 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_42:
          v24 = 0u;
          v25 = 0u;
          v22 = 0u;
          v23 = 0u;
          v21 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
      }
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      v21 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_34:
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      v21 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_35:
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      v21 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_36:
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      v21 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
LABEL_37:
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      v21 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v24 = 0u;
    v25 = 0u;
    v22 = 0u;
    v23 = 0u;
    v21 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_39;
  }
LABEL_32:
  *((_BYTE *)this + 844) = 0;
  return result;
}

uint64_t re::DynamicOverflowArray<unsigned long long,5ul>::DynamicOverflowArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[1];
    *(_QWORD *)a1 = v3;
    re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity((_QWORD *)a1, v5);
    *(_DWORD *)(a1 + 16) += 2;
    re::DynamicOverflowArray<unsigned long long,5ul>::copy(a1, (uint64_t)a2);
  }
  return a1;
}

void *re::DynamicOverflowArray<unsigned long long,5ul>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  const void *v5;
  void *result;
  const void *v7;
  uint64_t v8;
  int v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;

  v4 = *(_QWORD *)(a2 + 8);
  if (v4 >= *(_QWORD *)(a1 + 8))
  {
    re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity((_QWORD *)a1, *(_QWORD *)(a2 + 8));
    if ((*(_BYTE *)(a2 + 16) & 1) != 0)
      v7 = (const void *)(a2 + 24);
    else
      v7 = *(const void **)(a2 + 32);
    v8 = *(_QWORD *)(a1 + 8);
    v9 = *(_DWORD *)(a1 + 16);
    if ((v9 & 1) != 0)
    {
      v10 = (void *)(a1 + 24);
      if (!v8)
      {
LABEL_18:
        if ((v9 & 1) != 0)
          v11 = a1 + 24;
        else
          v11 = *(_QWORD *)(a1 + 32);
        v12 = *(_QWORD *)(a1 + 8);
        v13 = (void *)(v11 + 8 * v12);
        if ((*(_DWORD *)(a2 + 16) & 1) != 0)
          v14 = a2 + 24;
        else
          v14 = *(_QWORD *)(a2 + 32);
        result = memcpy(v13, (const void *)(v14 + 8 * v12), 8 * v4 - 8 * v12);
        goto LABEL_25;
      }
    }
    else
    {
      v10 = *(void **)(a1 + 32);
      if (!v8)
        goto LABEL_18;
    }
    memmove(v10, v7, 8 * v8);
    v9 = *(_DWORD *)(a1 + 16);
    goto LABEL_18;
  }
  if ((*(_BYTE *)(a2 + 16) & 1) != 0)
    v5 = (const void *)(a2 + 24);
  else
    v5 = *(const void **)(a2 + 32);
  if ((*(_BYTE *)(a1 + 16) & 1) == 0)
  {
    result = *(void **)(a1 + 32);
    if (!v4)
      goto LABEL_25;
    goto LABEL_15;
  }
  result = (void *)(a1 + 24);
  if (v4)
LABEL_15:
    result = memmove(result, v5, 8 * v4);
LABEL_25:
  *(_QWORD *)(a1 + 8) = v4;
  return result;
}

re::ManualClock *re::ManualClock::ManualClock(re::ManualClock *this)
{
  const char *v2;
  _BYTE v4[4];
  float v5;

  *(_QWORD *)this = &off_24ED891C8;
  *((_BYTE *)this + 8) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0x7F80000000000000;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_DWORD *)this + 30) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 0;
  re::DynamicArray<re::EvaluationRegister>::setCapacity((_QWORD *)this + 5, 0);
  ++*((_DWORD *)this + 16);
  re::Defaults::floatValue((re::Defaults *)re::SimulationClock::kDefaultMaxDeltaTimeKey, v2, (uint64_t)v4);
  if (v4[0] && v5 > 0.0)
    *((float *)this + 9) = v5;
  return this;
}

uint64_t re::ManualClock::start(uint64_t this)
{
  *(_BYTE *)(this + 8) = 1;
  return this;
}

uint64_t re::ManualClock::stop(uint64_t this)
{
  *(_BYTE *)(this + 8) = 0;
  return this;
}

uint64_t re::ManualClock::reset(uint64_t this)
{
  *(_BYTE *)(this + 8) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 32) = 0;
  return this;
}

void re::ManualClock::resetDeltaTime(re::ManualClock *this, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ManualClock does not support resetDeltaTime.", "!\"Unreachable code\"", "resetDeltaTime", 39);
  _os_crash();
  __break(1u);
}

uint64_t re::ManualClock::update(uint64_t this, float a2, uint64_t a3)
{
  float v3;
  uint64_t v4;
  NSObject *v5;
  double v6;
  double v7;
  NSObject *v8;
  double v9;
  double v10;
  int buf;
  _BYTE buf_4[20];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (!*(_BYTE *)(this + 8))
    return this;
  v3 = a2;
  if (a2 < 0.0)
  {
    re::internal::assertLog((re::internal *)5, a3, "assertion failure: '%s' (%s:line %i) Negative time step: %g s", "deltaTime >= 0.0f", "update", 49, a2);
    _os_crash();
    __break(1u);
LABEL_14:
    re::internal::assertLog((re::internal *)5, a3, "assertion failure: '%s' (%s:line %i) Time step exceeds 10 years: %g s", "deltaTime < 10 * 365 * 24 * 3600.0f", "update", 50, v3);
    _os_crash();
    __break(1u);
  }
  if (a2 >= 315360000.0)
    goto LABEL_14;
  v4 = this;
  if (a2 > 3600.0)
  {
    v5 = *re::foundationTimingLogObjects((re *)this);
    this = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)this)
    {
      buf = 134217984;
      *(double *)buf_4 = v3;
      _os_log_impl(&dword_224FE9000, v5, OS_LOG_TYPE_DEFAULT, "Large time step: %g s", (uint8_t *)&buf, 0xCu);
    }
  }
  v6 = v3;
  v7 = *(double *)(v4 + 16) + v3;
  *(double *)(v4 + 16) = v7;
  if (*(float *)(v4 + 36) < v3)
  {
    v8 = *re::foundationTimingLogObjects((re *)this);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = *(float *)(v4 + 36);
      buf = 134218240;
      *(double *)buf_4 = v3;
      *(_WORD *)&buf_4[8] = 2048;
      *(double *)&buf_4[10] = v9;
      _os_log_impl(&dword_224FE9000, v8, OS_LOG_TYPE_DEFAULT, "Clamping time step %g s to %g s", (uint8_t *)&buf, 0x16u);
    }
    v3 = *(float *)(v4 + 36);
    v7 = *(double *)(v4 + 16);
    v6 = v3;
  }
  v10 = v6 + *(double *)(v4 + 24);
  *(double *)(v4 + 24) = v10;
  *(float *)(v4 + 32) = v3;
  *(_DWORD *)buf_4 = 0;
  buf = LODWORD(v3);
  *(double *)&buf_4[4] = v10;
  *(double *)&buf_4[12] = v7;
  return (*(uint64_t (**)(uint64_t, int *))(*(_QWORD *)v4 + 96))(v4, &buf);
}

void re::ManualClock::onTimeDidChange(uint64_t a1)
{
  re::Event<re::SimulationClock,re::SimulationClockEventArgs const&>::raise(a1 + 40, a1);
}

void re::Event<re::SimulationClock,re::SimulationClockEventArgs const&>::raise(uint64_t a1, uint64_t a2)
{
  int v3;
  unint64_t v5;

  v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(_QWORD *)(a1 + 16))
  {
    v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 32 * v5 + 24))(a2) == 1)
        re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStableAt((_QWORD *)a1, v5);
      else
        ++v5;
    }
    while (v5 < *(_QWORD *)(a1 + 16));
    v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
    re::Event<re::ecs2::SceneComponentCollection<re::ecs2::AnchorComponent>,re::Slice<re::ecs2::AnchorComponent*>>::doDeferredActions((_anonymous_namespace_ *)a1);
}

void re::ManualClock::~ManualClock(re::ManualClock *this)
{
  *(_QWORD *)this = &off_24ED891C8;
  re::Event<re::Engine>::~Event((uint64_t *)this + 5);
}

{
  *(_QWORD *)this = &off_24ED891C8;
  re::Event<re::Engine>::~Event((uint64_t *)this + 5);
  JUMPOUT(0x2276933B8);
}

uint64_t re::ManualClock::isRunning(re::ManualClock *this)
{
  return *((unsigned __int8 *)this + 8);
}

float re::ManualClock::deltaTime(re::ManualClock *this)
{
  return *((float *)this + 8);
}

float re::ManualClock::maxDeltaTime(re::ManualClock *this)
{
  return *((float *)this + 9);
}

float re::ManualClock::simulationTime(re::ManualClock *this)
{
  return *((double *)this + 3);
}

float re::ManualClock::totalTime(re::ManualClock *this)
{
  return *((double *)this + 2);
}

uint64_t re::ManualClock::timeDidChange(re::ManualClock *this)
{
  return (uint64_t)this + 40;
}

void re::DisplayLinkClock::update(re::DisplayLinkClock *this)
{
  double v2;
  double v3;
  float v4;
  double v5;
  double v6;
  _QWORD v7[3];

  v2 = CACurrentMediaTime();
  v3 = *((double *)this + 19);
  *((double *)this + 19) = v2;
  if (*((_BYTE *)this + 9))
  {
    v4 = v2 - v3;
    v5 = *((double *)this + 3);
    v6 = *((double *)this + 2) + v4;
    if (*((float *)this + 9) < v4)
      v4 = *((float *)this + 9);
    *((double *)this + 2) = v6;
    *((double *)this + 3) = v5 + v4;
    *((float *)this + 8) = v4;
    v7[0] = LODWORD(v4);
    *(double *)&v7[1] = v5 + v4;
    *(double *)&v7[2] = v6;
    (*(void (**)(re::DisplayLinkClock *, _QWORD *))(*(_QWORD *)this + 96))(this, v7);
  }
}

uint64_t re::DisplayLinkClock::DisplayLinkClock(uint64_t a1, id *a2)
{
  id v4;

  *(_QWORD *)a1 = &off_24ED89268;
  *(_WORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 36) = 0x427000007F800000;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_DWORD *)(a1 + 112) = 0;
  re::DynamicArray<re::EvaluationRegister>::setCapacity((_QWORD *)(a1 + 48), 0);
  ++*(_DWORD *)(a1 + 72);
  v4 = *a2;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 136) = v4;
  return a1;
}

void re::DisplayLinkClock::~DisplayLinkClock(re::DisplayLinkClock *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24ED89268;
  if (*((_BYTE *)this + 8))
  {
    v2 = (void *)*((_QWORD *)this + 18);
    if (v2)
    {
      objc_msgSend(v2, "invalidate");
      v3 = (void *)*((_QWORD *)this + 18);
      *((_QWORD *)this + 18) = 0;

    }
    *((_BYTE *)this + 8) = 0;
  }

  re::Event<re::Engine>::~Event((uint64_t *)this + 6);
}

{
  re::DisplayLinkClock::~DisplayLinkClock(this);
  JUMPOUT(0x2276933B8);
}

void re::DisplayLinkClock::init(re::DisplayLinkClock *this)
{
  const char *v2;
  _BYTE v3[4];
  float v4;

  if (!*((_BYTE *)this + 8))
  {
    re::DisplayLinkClock::initDisplayLink(this);
    *((_BYTE *)this + 8) = 1;
    re::Defaults::floatValue((re::Defaults *)re::SimulationClock::kDefaultMaxDeltaTimeKey, v2, (uint64_t)v3);
    if (v3[0])
    {
      if (v4 > 0.0)
        *((float *)this + 9) = v4;
    }
  }
}

void re::DisplayLinkClock::initDisplayLink(re::DisplayLinkClock *this)
{
  REDisplayLinkTarget *v2;
  char **v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  REDisplayLinkTarget *v8;

  v2 = -[REDisplayLinkTarget initWithClock:]([REDisplayLinkTarget alloc], "initWithClock:", this);
  v8 = v2;
  if (*((_QWORD *)this + 17) == MEMORY[0x24BDAC9B8])
    v3 = &selRef_update;
  else
    v3 = &selRef_updateOnQueue;
  objc_msgSend(MEMORY[0x24BDE5668], "displayLinkWithTarget:selector:", v2, *v3);
  v4 = objc_claimAutoreleasedReturnValue();
  v5 = (void *)*((_QWORD *)this + 18);
  *((_QWORD *)this + 18) = v4;

  objc_msgSend(*((id *)this + 18), "setPreferredFramesPerSecond:", llroundf(*((float *)this + 10)));
  v6 = (void *)*((_QWORD *)this + 18);
  objc_msgSend(MEMORY[0x24BDBCF18], "currentRunLoop");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "addToRunLoop:forMode:", v7, *MEMORY[0x24BDBCB80]);

}

CFTimeInterval *re::DisplayLinkClock::start(CFTimeInterval *this)
{
  CFTimeInterval *v1;

  if (!*((_BYTE *)this + 9))
  {
    v1 = this;
    re::DisplayLinkClock::init((re::DisplayLinkClock *)this);
    v1[19] = CACurrentMediaTime();
    this = (CFTimeInterval *)*((_QWORD *)v1 + 18);
    if (this)
      this = (CFTimeInterval *)-[CFTimeInterval setPaused:](this, "setPaused:", 0);
    *((_BYTE *)v1 + 9) = 1;
  }
  return this;
}

void re::DisplayLinkClock::resetDeltaTime(CFTimeInterval *this)
{
  this[19] = CACurrentMediaTime();
}

uint64_t re::DisplayLinkClock::stop(uint64_t this)
{
  uint64_t v1;

  if (*(_BYTE *)(this + 9))
  {
    v1 = this;
    this = *(_QWORD *)(this + 144);
    if (this)
      this = objc_msgSend((id)this, "setPaused:", 1);
    *(_BYTE *)(v1 + 9) = 0;
  }
  return this;
}

void re::DisplayLinkClock::reset(re::DisplayLinkClock *this)
{
  void *v2;

  if (*((_BYTE *)this + 9))
  {
    v2 = (void *)*((_QWORD *)this + 18);
    if (v2)
      objc_msgSend(v2, "setPaused:", 1);
    *((_BYTE *)this + 9) = 0;
  }
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((CFTimeInterval *)this + 19) = CACurrentMediaTime();
}

void re::DisplayLinkClock::onTimeDidChange(uint64_t a1)
{
  re::Event<re::SimulationClock,re::SimulationClockEventArgs const&>::raise(a1 + 48, a1);
}

uint64_t re::DisplayLinkClock::isRunning(re::DisplayLinkClock *this)
{
  return *((unsigned __int8 *)this + 9);
}

float re::DisplayLinkClock::deltaTime(re::DisplayLinkClock *this)
{
  return *((float *)this + 8);
}

float re::DisplayLinkClock::maxDeltaTime(re::DisplayLinkClock *this)
{
  return *((float *)this + 9);
}

float re::DisplayLinkClock::simulationTime(re::DisplayLinkClock *this)
{
  return *((double *)this + 3);
}

float re::DisplayLinkClock::totalTime(re::DisplayLinkClock *this)
{
  return *((double *)this + 2);
}

uint64_t re::DisplayLinkClock::timeDidChange(re::DisplayLinkClock *this)
{
  return (uint64_t)this + 48;
}

re::VariableStepTimer *re::VariableStepTimer::VariableStepTimer(re::VariableStepTimer *this)
{
  _anonymous_namespace_ *v2;

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = &off_24ED892F8;
  *((_BYTE *)this + 24) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 7) = 1065353216;
  *((_DWORD *)this + 16) = 2139095040;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((_QWORD *)this + 18) = 0;
  *((_DWORD *)this + 38) = 0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_DWORD *)this + 34) = 0;
  v2 = (_anonymous_namespace_ *)re::DynamicArray<re::EvaluationRegister>::setCapacity((_QWORD *)this + 9, 0);
  ++*((_DWORD *)this + 24);
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
  *((_QWORD *)this + 29) = 0;
  *((_DWORD *)this + 60) = 0;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_DWORD *)this + 56) = 0;
  re::DynamicArray<re::EvaluationRegister>::setCapacity((_QWORD *)this + 20, 0);
  ++*((_DWORD *)this + 46);
  return this;
}

void re::VariableStepTimer::~VariableStepTimer(re::VariableStepTimer *this)
{
  re::VariableStepTimer::setClock((uint64_t)this, 0);
  re::Event<re::Engine>::~Event((uint64_t *)this + 20);
  re::Event<re::Engine>::~Event((uint64_t *)this + 9);
}

{
  re::VariableStepTimer::~VariableStepTimer(this);
  JUMPOUT(0x2276933B8);
}

double re::VariableStepTimer::setClock(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  double result;
  _DWORD *v7;
  __int128 v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, _QWORD *);
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 8);
  if (v3 != a2)
  {
    if (v3)
    {
      v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 56))(v3);
      *(_QWORD *)&v8 = a1;
      *((_QWORD *)&v8 + 1) = re::VariableStepTimer::onClockDidChange;
      v9 = 0;
      v10 = re::Event<re::SimulationClock,re::SimulationClockEventArgs const&>::createSubscription<re::VariableStepTimer>(re::VariableStepTimer *,REEventHandlerResult (re::VariableStepTimer::*)(re::SimulationClock*,re::SimulationClockEventArgs const&))::{lambda(re::SimulationClock*,re::Event<re::SimulationClock,re::SimulationClockEventArgs const&>::Subscription const&,re::SimulationClockEventArgs const&)#1}::__invoke;
      re::Event<re::GeometricObjectBase>::removeSubscription(v5, &v8);
    }
    *(_QWORD *)(a1 + 8) = a2;
    if (a2)
    {
      v7 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 56))(a2);
      *(_QWORD *)&v8 = a1;
      *((_QWORD *)&v8 + 1) = re::VariableStepTimer::onClockDidChange;
      v9 = 0;
      v10 = re::Event<re::SimulationClock,re::SimulationClockEventArgs const&>::createSubscription<re::VariableStepTimer>(re::VariableStepTimer *,REEventHandlerResult (re::VariableStepTimer::*)(re::SimulationClock*,re::SimulationClockEventArgs const&))::{lambda(re::SimulationClock*,re::Event<re::SimulationClock,re::SimulationClockEventArgs const&>::Subscription const&,re::SimulationClockEventArgs const&)#1}::__invoke;
      return re::Event<re::NetworkSystem,re::ecs2::Component *>::addSubscription(v7, (uint64_t)&v8);
    }
  }
  return result;
}

uint64_t re::VariableStepTimer::onClockDidChange(uint64_t a1, uint64_t a2, float *a3)
{
  float v4;
  float v5;
  float v6;
  uint64_t v7;
  float v8;
  float v9;
  float v10;
  BOOL v11;
  float v12;

  if (*(_BYTE *)(a1 + 24))
  {
    v4 = *(float *)(a1 + 52) + (float)(*a3 * *(float *)(a1 + 56));
    *(float *)(a1 + 52) = v4;
    v5 = fabsf(v4);
    v6 = *(float *)(a1 + 60);
    if (v5 >= v6)
    {
      ++*(_QWORD *)(a1 + 16);
      v8 = *(float *)(a1 + 64);
      v9 = v5 - v8;
      v10 = -v8;
      if (v4 >= 0.0)
        v10 = *(float *)(a1 + 64);
      v11 = v5 <= v8;
      v12 = 0.0;
      if (!v11)
      {
        v12 = v9;
        v4 = v10;
      }
      *(float *)(a1 + 48) = v12;
      *(float *)(a1 + 40) = v4;
      *(_DWORD *)(a1 + 52) = 0;
      *(_DWORD *)(a1 + 44) = 0;
      *(double *)(a1 + 32) = *(double *)(a1 + 32) + v4;
      v7 = a1 + 160;
    }
    else
    {
      *(_DWORD *)(a1 + 40) = 0;
      *(_DWORD *)(a1 + 48) = 0;
      *(float *)(a1 + 44) = v6 - v5;
      v7 = a1 + 72;
    }
    re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::raise(v7, a1);
  }
  return 0;
}

uint64_t re::VariableStepTimer::start(uint64_t this)
{
  *(_BYTE *)(this + 24) = 1;
  return this;
}

uint64_t re::VariableStepTimer::stop(uint64_t this)
{
  *(_BYTE *)(this + 24) = 0;
  *(_QWORD *)(this + 40) = 0;
  *(_DWORD *)(this + 48) = 0;
  return this;
}

uint64_t re::VariableStepTimer::reset(uint64_t this)
{
  *(_BYTE *)(this + 24) = 0;
  *(_QWORD *)(this + 16) = 0;
  *(_QWORD *)(this + 40) = 0;
  *(_QWORD *)(this + 48) = 0;
  *(_QWORD *)(this + 32) = 0;
  return this;
}

void re::VariableStepTimer::onIdle(uint64_t a1)
{
  re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::raise(a1 + 72, a1);
}

void re::VariableStepTimer::onTimeDidChange(uint64_t a1)
{
  re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::raise(a1 + 160, a1);
}

void re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::raise(uint64_t a1, uint64_t a2)
{
  int v3;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t i;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  _OWORD v13[2];
  uint64_t v14;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unint64_t v20;
  __int16 v21;
  unint64_t v22;
  _OWORD v23[5];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v3 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = v3 + 1;
  if (*(_QWORD *)(a1 + 16))
  {
    v5 = 0;
    do
    {
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 32) + 32 * v5 + 24))(a2) == 1)
        re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStableAt((_QWORD *)a1, v5);
      else
        ++v5;
    }
    while (v5 < *(_QWORD *)(a1 + 16));
    v3 = *(_DWORD *)(a1 + 80) - 1;
  }
  *(_DWORD *)(a1 + 80) = v3;
  if (!v3)
  {
    v6 = *(_QWORD *)(a1 + 56);
    if (v6)
    {
      v7 = 0;
      for (i = 0; i != v6; ++i)
      {
        v9 = *(_QWORD *)(a1 + 56);
        if (v9 <= i)
        {
          memset(v23, 0, sizeof(v23));
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v15 = 136315906;
          v16 = "operator[]";
          v17 = 1024;
          v18 = 789;
          v19 = 2048;
          v20 = i;
          v21 = 2048;
          v22 = v9;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v10 = *(_QWORD *)(a1 + 72) + v7;
        v11 = *(_QWORD *)(v10 + 32);
        v12 = *(_OWORD *)(v10 + 16);
        v13[0] = *(_OWORD *)v10;
        v13[1] = v12;
        v14 = v11;
        if (LOBYTE(v13[0]))
        {
          re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf(a1, (_QWORD *)v13 + 1, (uint64_t)v23);
          if (!LOBYTE(v23[0]))
            re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)a1, (uint64_t)v13 + 8);
        }
        else
        {
          re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStable((_QWORD *)a1, (_QWORD *)v13 + 1);
        }
        v7 += 40;
      }
    }
  }
}

uint64_t re::VariableStepTimer::clock(re::VariableStepTimer *this)
{
  return *((_QWORD *)this + 1);
}

uint64_t re::VariableStepTimer::frameCount(re::VariableStepTimer *this)
{
  return *((_QWORD *)this + 2);
}

uint64_t re::VariableStepTimer::isRunning(re::VariableStepTimer *this)
{
  return *((unsigned __int8 *)this + 24);
}

double re::VariableStepTimer::time(re::VariableStepTimer *this)
{
  return *((double *)this + 4);
}

float re::VariableStepTimer::deltaTime(re::VariableStepTimer *this)
{
  return *((float *)this + 10);
}

uint64_t re::VariableStepTimer::accumulatedSteps(re::VariableStepTimer *this)
{
  return 1;
}

float re::VariableStepTimer::idleTime(re::VariableStepTimer *this)
{
  return *((float *)this + 11);
}

float re::VariableStepTimer::lostTime(re::VariableStepTimer *this)
{
  return *((float *)this + 12);
}

float re::VariableStepTimer::excessTime(re::VariableStepTimer *this)
{
  return *((float *)this + 13);
}

float re::VariableStepTimer::speed(re::VariableStepTimer *this)
{
  return *((float *)this + 14);
}

uint64_t re::VariableStepTimer::pendingSteps(re::VariableStepTimer *this)
{
  return 0;
}

uint64_t re::VariableStepTimer::idle(re::VariableStepTimer *this)
{
  return (uint64_t)this + 72;
}

uint64_t re::VariableStepTimer::timeDidChange(re::VariableStepTimer *this)
{
  return (uint64_t)this + 160;
}

uint64_t re::Event<re::SimulationClock,re::SimulationClockEventArgs const&>::createSubscription<re::VariableStepTimer>(re::VariableStepTimer *,REEventHandlerResult (re::VariableStepTimer::*)(re::SimulationClock*,re::SimulationClockEventArgs const&))::{lambda(re::SimulationClock*,re::Event<re::SimulationClock,re::SimulationClockEventArgs const&>::Subscription const&,re::SimulationClockEventArgs const&)#1}::__invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD *, uint64_t);
  uint64_t v4;
  _QWORD *v5;

  v3 = (uint64_t (*)(_QWORD *, uint64_t))a2[1];
  v4 = a2[2];
  v5 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v3 = *(uint64_t (**)(_QWORD *, uint64_t))(*v5 + v3);
  return v3(v5, a1);
}

id ManualClockLog(void)
{
  if (qword_2541234C0 != -1)
    dispatch_once(&qword_2541234C0, &__block_literal_global_46);
  return (id)_MergedGlobals_490;
}

void ___Z14ManualClockLogv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.re", "ManualClock");
  v1 = (void *)_MergedGlobals_490;
  _MergedGlobals_490 = (uint64_t)v0;

}

uint64_t re::ManualCMClockCreateWithReference(re *this, OpaqueCMClock *a2, OpaqueCMClock **a3)
{
  uint64_t result;
  uint64_t DerivedStorage;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;

  if (!this)
    return 4294954543;
  result = FigDerivedClockCreateWithGetTimeCallback();
  if (!(_DWORD)result)
  {
    CFRetain(this);
    DerivedStorage = FigDerivedClockGetDerivedStorage();
    result = 0;
    *(_DWORD *)DerivedStorage = 0;
    *(_QWORD *)(DerivedStorage + 8) = this;
    *(_QWORD *)(DerivedStorage + 16) = 0x3FF0000000000000;
    v6 = MEMORY[0x24BDC0D88];
    v7 = *MEMORY[0x24BDC0D88];
    *(_OWORD *)(DerivedStorage + 24) = *MEMORY[0x24BDC0D88];
    v8 = *(_QWORD *)(v6 + 16);
    *(_QWORD *)(DerivedStorage + 40) = v8;
    *(_OWORD *)(DerivedStorage + 48) = v7;
    *(_QWORD *)(DerivedStorage + 64) = v8;
  }
  return result;
}

void re::ManualCMClockUpdateRateAndAnchor(re *this, CMTime *a2, double a3, CMTime *a4, CMTime *a5)
{
  uint64_t DerivedStorage;
  __int128 v9;
  __int128 v10;
  CMTime v11;
  CMTime time1;
  CMTime v13;

  DerivedStorage = FigDerivedClockGetDerivedStorage();
  memset(&v13, 0, sizeof(v13));
  if (*(double *)(DerivedStorage + 16) != a3 || (time1 = *a2, v11 = v13, CMTimeCompare(&time1, &v11)))
  {
    os_unfair_lock_lock((os_unfair_lock_t)DerivedStorage);
    *(double *)(DerivedStorage + 16) = a3;
    v9 = *(_OWORD *)&a2->value;
    *(_QWORD *)(DerivedStorage + 40) = a2->epoch;
    *(_OWORD *)(DerivedStorage + 24) = v9;
    v10 = *(_OWORD *)&a4->value;
    *(_QWORD *)(DerivedStorage + 64) = a4->epoch;
    *(_OWORD *)(DerivedStorage + 48) = v10;
    os_unfair_lock_unlock((os_unfair_lock_t)DerivedStorage);
  }
}

CMTime *`anonymous namespace'::REManualCMClock_ConvertReferenceTimeToLocalTime@<X0>(uint64_t a1@<X0>, CMTime *a2@<X1>, CMTime *a3@<X8>)
{
  CMTime v6;
  CMTime v7;
  CMTime rhs;
  CMTime lhs;
  CMTime time;
  CMTime v11;

  memset(&v11, 0, sizeof(v11));
  lhs = *a2;
  rhs = *(CMTime *)(a1 + 48);
  CMTimeSubtract(&time, &lhs, &rhs);
  CMTimeMultiplyByFloat64(&v11, &time, *(Float64 *)(a1 + 16));
  v7 = *(CMTime *)(a1 + 24);
  v6 = v11;
  return CMTimeAdd(a3, &v7, &v6);
}

uint64_t re::ProxyAudioClockCreate(re *this, OpaqueCMClock **a2)
{
  CMClockRef HostTimeClock;
  uint64_t TimeCallback;
  uint64_t DerivedStorage;
  void *v6;
  __int128 v8;
  uint64_t v9;

  HostTimeClock = CMClockGetHostTimeClock();
  v8 = *MEMORY[0x24BDC0D40];
  v9 = *(_QWORD *)(MEMORY[0x24BDC0D40] + 16);
  TimeCallback = FigDerivedClockCreateWithGetTimeCallback();
  if (!(_DWORD)TimeCallback)
  {
    CFRetain(HostTimeClock);
    DerivedStorage = FigDerivedClockGetDerivedStorage();
    *(_DWORD *)DerivedStorage = 0;
    *(_QWORD *)(DerivedStorage + 8) = HostTimeClock;
    +[REProxyAudioClockManager sharedInstance](REProxyAudioClockManager, "sharedInstance", v8, v9);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "addClock:", *(_QWORD *)this);

  }
  return TimeCallback;
}

CFStringRef `anonymous namespace'::REManualCMClock_CopyDebugDesc(_anonymous_namespace_ *this, OpaqueCMClock *a2)
{
  uint64_t DerivedStorage;
  const __CFAllocator *v4;
  CFStringRef v5;
  const __CFAllocator *v6;
  CFStringRef v7;
  uint64_t v8;
  const __CFAllocator *v9;
  CFStringRef v10;
  CMTime v12;
  CMTime time;

  DerivedStorage = FigDerivedClockGetDerivedStorage();
  os_unfair_lock_lock((os_unfair_lock_t)DerivedStorage);
  v4 = CFGetAllocator(this);
  time = *(CMTime *)(DerivedStorage + 24);
  v5 = CMTimeCopyDescription(v4, &time);
  v6 = CFGetAllocator(this);
  v12 = *(CMTime *)(DerivedStorage + 48);
  v7 = CMTimeCopyDescription(v6, &v12);
  v8 = *(_QWORD *)(DerivedStorage + 16);
  os_unfair_lock_unlock((os_unfair_lock_t)DerivedStorage);
  v9 = CFGetAllocator(this);
  v10 = CFStringCreateWithFormat(v9, 0, CFSTR("REManualCMClock rate %0.2f, own anchor %@, reference anchor %@"), v8, v5, v7);
  CFRelease(v5);
  CFRelease(v7);
  return v10;
}

void `anonymous namespace'::REManualCMClock_Finalize(_anonymous_namespace_ *this, OpaqueCMClock *a2)
{
  uint64_t DerivedStorage;

  DerivedStorage = FigDerivedClockGetDerivedStorage();
  CFRelease(*(CFTypeRef *)(DerivedStorage + 8));
}

BOOL `anonymous namespace'::REManualCMClock_MightDrift(_anonymous_namespace_ *this, OpaqueCMClock *a2, OpaqueCMClock *a3)
{
  return this != a2;
}

double `anonymous namespace'::REManualCMClock_GetRate(_anonymous_namespace_ *this, OpaqueCMClock *a2)
{
  uint64_t DerivedStorage;
  double v3;

  DerivedStorage = FigDerivedClockGetDerivedStorage();
  os_unfair_lock_lock((os_unfair_lock_t)DerivedStorage);
  v3 = *(double *)(DerivedStorage + 16);
  os_unfair_lock_unlock((os_unfair_lock_t)DerivedStorage);
  return v3;
}

uint64_t `anonymous namespace'::REManualCMClock_GetAnchorTime(_anonymous_namespace_ *this, CMTime *a2, CMTime *a3, CMTime *a4)
{
  uint64_t DerivedStorage;
  CMTime v8;
  CMTime v9;

  DerivedStorage = FigDerivedClockGetDerivedStorage();
  memset(&v9, 0, sizeof(v9));
  CMClockGetTime(&v9, *(CMClockRef *)(DerivedStorage + 8));
  if (a2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)DerivedStorage);
    *a2 = v8;
    os_unfair_lock_unlock((os_unfair_lock_t)DerivedStorage);
  }
  if (a3)
    *a3 = v9;
  return 0;
}

void `anonymous namespace'::REProxyAudioClock_Finalize(_anonymous_namespace_ *this, OpaqueCMClock *a2)
{
  void *v3;
  uint64_t DerivedStorage;

  +[REProxyAudioClockManager sharedInstance](REProxyAudioClockManager, "sharedInstance");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "removeClock:", this);

  DerivedStorage = FigDerivedClockGetDerivedStorage();
  CFRelease(*(CFTypeRef *)(DerivedStorage + 8));
}

BOOL `anonymous namespace'::REProxyAudioClock_MightDrift(_anonymous_namespace_ *this, OpaqueCMClock *a2, OpaqueCMClock *a3)
{
  if (this == a2)
    return 0;
  return !FigDerivedClockVerifyCallbacksMatch() || !FigDerivedClockVerifyCallbacksMatch();
}

uint64_t *re::allocInfo_SimulationTimer(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_491);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_491))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2541234E0, 0);
    *(uint64_t *)((char *)&qword_2541234F0 + 6) = 0;
    qword_2541234F0 = 0;
    qword_254123500 = 0;
    qword_254123508 = 0xFFFFFFFFLL;
    qword_2541234E0 = (uint64_t)&off_24ED7DAA8;
    qword_254123510 = (uint64_t)"SimulationTimer";
    dword_254123518 = 0;
    unk_254123520 = 0u;
    unk_254123530 = 0u;
    unk_254123540 = 0u;
    qword_254123550 = 0;
    __cxa_guard_release(&_MergedGlobals_491);
  }
  return &qword_2541234E0;
}

void re::initInfo_SimulationTimer(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x4256CCBB6638AABCLL;
  v5[1] = "SimulationTimer";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_SimulationTimer(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_SimulationTimer(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"SimulationTimer", (uint64_t (*)(re::internal *))re::allocInfo_SimulationTimer, (re::IntrospectionBase *(*)(void))re::initInfo_SimulationTimer, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::SimulationTimer>, this);
}

void re::introspect_ClockOrTimebaseType(re *this, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  unsigned __int8 v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  unint64_t i;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t j;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned __int8 *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  re *v26;
  uint64_t *v27;
  re *v28;
  uint64_t *v29;
  re *v30;
  uint64_t *v31;
  re *v32;
  uint64_t *v33;
  re *v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  StringID v40;
  _QWORD v41[2];
  _QWORD v42[61];

  v2 = atomic_load((unsigned __int8 *)&qword_254123560);
  if ((v2 & 1) == 0)
  {
    v26 = (re *)__cxa_guard_acquire(&qword_254123560);
    if ((_DWORD)v26)
    {
      v27 = re::introspectionAllocator(v26);
      v28 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 24, 8);
      *(_DWORD *)v28 = 1;
      *((_QWORD *)v28 + 1) = 0;
      *((_QWORD *)v28 + 2) = "Timebase";
      qword_254123610 = (uint64_t)v28;
      v29 = re::introspectionAllocator(v28);
      v30 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v29 + 32))(v29, 24, 8);
      *(_DWORD *)v30 = 1;
      *((_QWORD *)v30 + 1) = 1;
      *((_QWORD *)v30 + 2) = "AudioClock";
      qword_254123618 = (uint64_t)v30;
      v31 = re::introspectionAllocator(v30);
      v32 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 24, 8);
      *(_DWORD *)v32 = 1;
      *((_QWORD *)v32 + 1) = 2;
      *((_QWORD *)v32 + 2) = "HostClock";
      qword_254123620 = (uint64_t)v32;
      v33 = re::introspectionAllocator(v32);
      v34 = (re *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v33 + 32))(v33, 24, 8);
      *(_DWORD *)v34 = 1;
      *((_QWORD *)v34 + 1) = 3;
      *((_QWORD *)v34 + 2) = "SharedClock";
      qword_254123628 = (uint64_t)v34;
      v35 = re::introspectionAllocator(v34);
      v36 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v35 + 32))(v35, 24, 8);
      *(_DWORD *)v36 = 1;
      *(_QWORD *)(v36 + 8) = 4;
      *(_QWORD *)(v36 + 16) = "CustomClock";
      qword_254123630 = v36;
      __cxa_guard_release(&qword_254123560);
    }
  }
  v3 = atomic_load((unsigned __int8 *)&qword_254123568);
  if ((v3 & 1) == 0 && __cxa_guard_acquire(&qword_254123568))
  {
    re::IntrospectionBasic::IntrospectionBasic((re::IntrospectionBasic *)&qword_254123690, "ClockOrTimebaseType", 4, 4, 1, 1);
    qword_254123690 = (uint64_t)&off_24ED7D9E8;
    qword_2541236D0 = (uint64_t)&re::introspect_ClockOrTimebaseType(BOOL)::enumTable;
    dword_2541236A0 = 9;
    __cxa_guard_release(&qword_254123568);
  }
  if ((_MergedGlobals_492 & 1) == 0)
  {
    _MergedGlobals_492 = 1;
    re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_254123690, a2);
    v38 = 0x5C6F678444E6A912;
    v39 = "ClockOrTimebaseType";
    v42[0] = 208862;
    v42[1] = "int";
    v4 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v42);
    if (v4)
    {
      v5 = *v4;
      re::StringID::destroyString((re::StringID *)v42);
      v6 = (unsigned int *)qword_2541236D0;
      v41[1] = v5;
      re::TypeBuilder::beginEnumType((uint64_t)v42, &v38, 1, 1, (uint64_t)v41);
      v8 = *v6;
      if ((_DWORD)v8)
      {
        for (i = 0; i < v8; ++i)
        {
          v10 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * i);
          if (*(_DWORD *)v10 == 1)
          {
            v11 = *(char **)(v10 + 16);
            if (v11)
            {
              v12 = *v11;
              if (*v11)
              {
                v13 = v11[1];
                if (v13)
                {
                  v14 = (unsigned __int8 *)(v11 + 2);
                  do
                  {
                    v12 = 31 * v12 + v13;
                    v15 = *v14++;
                    v13 = v15;
                  }
                  while (v15);
                }
              }
            }
            else
            {
              v12 = 0;
            }
            v16 = *(_QWORD *)(v10 + 8);
            *(_QWORD *)&v40.var0 = 2 * v12;
            v40.var1 = v11;
            re::TypeBuilder::addEnumConstant((re::TypeBuilder *)v42, v16, &v40);
            re::StringID::destroyString((re::StringID *)&v40);
            v8 = *v6;
          }
        }
        if (v8)
        {
          for (j = 0; j < v8; ++j)
          {
            v18 = *(_QWORD *)(*((_QWORD *)v6 + 1) + 8 * j);
            if (*(_DWORD *)v18 == 2)
            {
              v19 = *(char **)(v18 + 16);
              if (v19)
              {
                v20 = *v19;
                if (*v19)
                {
                  v21 = v19[1];
                  if (v21)
                  {
                    v22 = (unsigned __int8 *)(v19 + 2);
                    do
                    {
                      v20 = 31 * v20 + v21;
                      v23 = *v22++;
                      v21 = v23;
                    }
                    while (v23);
                  }
                }
              }
              else
              {
                v20 = 0;
              }
              v24 = *(_QWORD *)(v18 + 8);
              *(_QWORD *)&v40.var0 = 2 * v20;
              v40.var1 = v19;
              re::TypeBuilder::addEnumConstantRenaming((re::TypeBuilder *)v42, v24, &v40);
              re::StringID::destroyString((re::StringID *)&v40);
              v8 = *v6;
            }
          }
        }
      }
      re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)v42, v25);
      xmmword_2541236B0 = (__int128)v40;
      re::StringID::destroyString((re::StringID *)&v38);
    }
    else
    {
      re::StringID::destroyString((re::StringID *)v42);
      re::internal::assertLog((re::internal *)5, v37, "assertion failure: '%s' (%s:line %i) Failed to determine underlying type of enum %s.", "valueID.isValid()", "registerEnumType", 2796, "ClockOrTimebaseType", v38, v39);
      _os_crash();
      __break(1u);
    }
  }
}

__n128 re::internal::defaultConstruct<re::ClockOrTimebase>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  __n128 result;
  uint64_t v5;

  *(_DWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_BYTE *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 32) = 0x3FF0000000000000;
  v3 = MEMORY[0x24BDC0D88];
  result = *(__n128 *)MEMORY[0x24BDC0D88];
  *(_OWORD *)(a3 + 40) = *MEMORY[0x24BDC0D88];
  v5 = *(_QWORD *)(v3 + 16);
  *(_QWORD *)(a3 + 56) = v5;
  *(__n128 *)(a3 + 64) = result;
  *(_QWORD *)(a3 + 80) = v5;
  *(_QWORD *)(a3 + 88) = 0x3FF0000000000000;
  *(_QWORD *)(a3 + 112) = v5;
  *(__n128 *)(a3 + 96) = result;
  *(__n128 *)(a3 + 120) = result;
  *(_QWORD *)(a3 + 136) = v5;
  *(_BYTE *)(a3 + 144) = 0;
  *(_QWORD *)(a3 + 164) = v5;
  *(__n128 *)(a3 + 148) = result;
  return result;
}

__n128 re::internal::defaultConstructV2<re::ClockOrTimebase>(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  uint64_t v3;

  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0x3FF0000000000000;
  v1 = MEMORY[0x24BDC0D88];
  result = *(__n128 *)MEMORY[0x24BDC0D88];
  *(_OWORD *)(a1 + 40) = *MEMORY[0x24BDC0D88];
  v3 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(a1 + 56) = v3;
  *(__n128 *)(a1 + 64) = result;
  *(_QWORD *)(a1 + 80) = v3;
  *(_QWORD *)(a1 + 88) = 0x3FF0000000000000;
  *(_QWORD *)(a1 + 112) = v3;
  *(__n128 *)(a1 + 96) = result;
  *(__n128 *)(a1 + 120) = result;
  *(_QWORD *)(a1 + 136) = v3;
  *(_BYTE *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 164) = v3;
  *(__n128 *)(a1 + 148) = result;
  return result;
}

uint64_t *re::allocInfo_TimebaseTree(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_254123588);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_254123588))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254123800, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_254123810 = 0;
    qword_254123820 = 0;
    qword_254123828 = 0xFFFFFFFFLL;
    qword_254123800 = (uint64_t)&off_24ED7DAA8;
    qword_254123830 = (uint64_t)"TimebaseTree";
    dword_254123838 = 0;
    *(_OWORD *)(v3 + 64) = 0u;
    *(_OWORD *)(v3 + 80) = 0u;
    *(_OWORD *)(v3 + 96) = 0u;
    qword_254123870 = 0;
    __cxa_guard_release(&qword_254123588);
  }
  return &qword_254123800;
}

void re::initInfo_TimebaseTree(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  uint64_t v8;
  uint64_t *v9;
  const re::IntrospectionBase *v10;
  void *v11;
  uint64_t v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  void *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  void *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v26;
  __int128 v27;
  _QWORD v28[2];
  __int128 v29;

  v28[0] = 0x3DB5CEF367814FF8;
  v28[1] = "TimebaseTree";
  re::StringID::destroyString((re::StringID *)v28);
  *((_OWORD *)this + 2) = v29;
  v4 = atomic_load((unsigned __int8 *)&qword_254123590);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_254123590);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      re::IntrospectionInfo<re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>>::get((uint64_t)v6, v7);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "nodes";
      *(_QWORD *)(v8 + 16) = &qword_2541236D8;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_254123660 = v8;
      v9 = re::introspectionAllocator((re *)v8);
      v11 = re::introspect_uint64_t((re *)1, v10);
      v12 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 32))(v9, 72, 8);
      *(_DWORD *)v12 = 1;
      *(_QWORD *)(v12 + 8) = "masterID";
      *(_QWORD *)(v12 + 16) = v11;
      *(_QWORD *)(v12 + 24) = 0;
      *(_QWORD *)(v12 + 32) = 0x3000000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(_QWORD *)(v12 + 48) = 0;
      *(_QWORD *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_254123668 = v12;
      v13 = re::introspectionAllocator((re *)v12);
      v15 = re::introspect_uint64_t((re *)1, v14);
      v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
      *(_DWORD *)v16 = 1;
      *(_QWORD *)(v16 + 8) = "timeSyncClockGrandmasterID";
      *(_QWORD *)(v16 + 16) = v15;
      *(_QWORD *)(v16 + 24) = 0;
      *(_QWORD *)(v16 + 32) = 0x7000000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(_QWORD *)(v16 + 48) = 0;
      *(_QWORD *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_254123670 = v16;
      v17 = re::introspectionAllocator((re *)v16);
      v19 = re::introspect_double((re *)1, v18);
      v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
      *(_DWORD *)v20 = 1;
      *(_QWORD *)(v20 + 8) = "currentAbsoluteTime";
      *(_QWORD *)(v20 + 16) = v19;
      *(_QWORD *)(v20 + 24) = 0;
      *(_QWORD *)(v20 + 32) = 0x6800000004;
      *(_DWORD *)(v20 + 40) = 0;
      *(_QWORD *)(v20 + 48) = 0;
      *(_QWORD *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_254123678 = v20;
      v21 = re::introspectionAllocator((re *)v20);
      v22 = (uint64_t *)qword_2541235C0;
      if (!qword_2541235C0)
      {
        v22 = allocInfo_CMTime();
        qword_2541235C0 = (uint64_t)v22;
        initInfo_CMTime((re::IntrospectionBase *)v22);
      }
      v23 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v21 + 32))(v21, 72, 8);
      *(_DWORD *)v23 = 1;
      *(_QWORD *)(v23 + 8) = "masterAnchor";
      *(_QWORD *)(v23 + 16) = v22;
      *(_QWORD *)(v23 + 24) = 0;
      *(_QWORD *)(v23 + 32) = 0x3800000005;
      *(_DWORD *)(v23 + 40) = 0;
      *(_QWORD *)(v23 + 48) = 0;
      *(_QWORD *)(v23 + 56) = 0;
      *(_DWORD *)(v23 + 64) = 0;
      qword_254123680 = v23;
      v24 = re::introspectionAllocator((re *)v23);
      v25 = (uint64_t *)qword_2541235C0;
      if (!qword_2541235C0)
      {
        v25 = allocInfo_CMTime();
        qword_2541235C0 = (uint64_t)v25;
        initInfo_CMTime((re::IntrospectionBase *)v25);
      }
      v26 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v24 + 32))(v24, 72, 8);
      *(_DWORD *)v26 = 1;
      *(_QWORD *)(v26 + 8) = "ownTimeForSourceAnchor";
      *(_QWORD *)(v26 + 16) = v25;
      *(_QWORD *)(v26 + 24) = 0;
      *(_QWORD *)(v26 + 32) = 0x5000000006;
      *(_DWORD *)(v26 + 40) = 0;
      *(_QWORD *)(v26 + 48) = 0;
      *(_QWORD *)(v26 + 56) = 0;
      *(_DWORD *)(v26 + 64) = 0;
      qword_254123688 = v26;
      __cxa_guard_release(&qword_254123590);
    }
  }
  *((_QWORD *)this + 2) = 0x8000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 6;
  *((_QWORD *)this + 8) = &qword_254123660;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::TimebaseTree>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::TimebaseTree>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::TimebaseTree>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::TimebaseTree>;
  re::IntrospectionRegistry::add(this, v3);
  v27 = v29;
}

void re::IntrospectionInfo<re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>>::get(uint64_t a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  uint64_t *v3;
  _OWORD *v4;
  uint64_t *v5;
  unsigned __int8 v6;
  const re::IntrospectionBase *v7;
  unsigned __int8 v8;
  int v9;
  re::IntrospectionRegistry *v10;
  const re::IntrospectionBase *v11;
  const char *v12;
  __int128 v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  _anonymous_namespace_ *v20;
  uint64_t v21;
  uint64_t v22;
  re *v23;
  uint64_t *v24;
  const re::IntrospectionBase *v25;
  uint64_t v26;
  uint64_t *v27;
  const re::IntrospectionBase *v28;
  void *v29;
  uint64_t v30;
  uint64_t *v31;
  const re::IntrospectionBase *v32;
  void *v33;
  uint64_t v34;
  uint64_t *v35;
  const re::IntrospectionBase *v36;
  void *v37;
  uint64_t v38;
  uint64_t *v39;
  const re::IntrospectionBase *v40;
  void *v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t *v49;
  const re::IntrospectionBase *v50;
  void *v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t *v59;
  const re::IntrospectionBase *v60;
  void *v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69[2];
  __int128 v70;
  __int128 v71;
  __int128 v72;
  const char *v73;
  _QWORD v74[2];
  __int128 v75;
  __int128 v76;
  uint64_t *v77;

  v2 = atomic_load((unsigned __int8 *)&qword_2541235E8);
  if ((v2 & 1) == 0 && __cxa_guard_acquire(&qword_2541235E8))
  {
    re::IntrospectionHashTableBase::IntrospectionHashTableBase((re::IntrospectionHashTableBase *)&qword_2541236D8);
    qword_2541236D8 = (uint64_t)&off_24ED89670;
    __cxa_guard_release(&qword_2541235E8);
  }
  v3 = &qword_254123000;
  if ((byte_254123559 & 1) == 0)
  {
    v4 = re::introspect_uint64_t((re *)1, a2);
    v5 = (uint64_t *)qword_254123580;
    if (!qword_254123580)
    {
      v6 = atomic_load((unsigned __int8 *)&qword_254123570);
      if ((v6 & 1) == 0 && __cxa_guard_acquire(&qword_254123570))
      {
        ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254123788, 0);
        *(_QWORD *)(v22 + 22) = 0;
        qword_254123798 = 0;
        *(_QWORD *)&xmmword_2541237A8 = 0;
        *((_QWORD *)&xmmword_2541237A8 + 1) = 0xFFFFFFFFLL;
        qword_254123788 = (uint64_t)&off_24ED7DAA8;
        qword_2541237B8 = (uint64_t)"ClockOrTimebase";
        dword_2541237C0 = 0;
        xmmword_2541237C8 = 0u;
        *(_OWORD *)&qword_2541237D8 = 0u;
        xmmword_2541237E8 = 0u;
        qword_2541237F8 = 0;
        __cxa_guard_release(&qword_254123570);
      }
      qword_254123580 = (uint64_t)&qword_254123788;
      *(_QWORD *)&v76 = 0x3BDE3B02BE92815ELL;
      *((_QWORD *)&v76 + 1) = "ClockOrTimebase";
      re::StringID::destroyString((re::StringID *)&v76);
      xmmword_2541237A8 = v72;
      v8 = atomic_load((unsigned __int8 *)&qword_254123578);
      if ((v8 & 1) == 0)
      {
        v23 = (re *)__cxa_guard_acquire(&qword_254123578);
        if ((_DWORD)v23)
        {
          v24 = re::introspectionAllocator(v23);
          re::introspect_ClockOrTimebaseType((re *)v24, v25);
          v26 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v24 + 32))(v24, 72, 8);
          *(_DWORD *)v26 = 1;
          *(_QWORD *)(v26 + 8) = "type";
          *(_QWORD *)(v26 + 16) = &qword_254123690;
          *(_QWORD *)(v26 + 24) = 0;
          *(_QWORD *)(v26 + 32) = 1;
          *(_DWORD *)(v26 + 40) = 0;
          *(_QWORD *)(v26 + 48) = 0;
          *(_QWORD *)(v26 + 56) = 0;
          *(_DWORD *)(v26 + 64) = 0;
          qword_254123728 = v26;
          v27 = re::introspectionAllocator((re *)v26);
          v29 = re::introspect_uint64_t((re *)1, v28);
          v30 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v27 + 32))(v27, 72, 8);
          *(_DWORD *)v30 = 1;
          *(_QWORD *)(v30 + 8) = "identifier";
          *(_QWORD *)(v30 + 16) = v29;
          *(_QWORD *)(v30 + 24) = 0;
          *(_QWORD *)(v30 + 32) = 0x800000002;
          *(_DWORD *)(v30 + 40) = 0;
          *(_QWORD *)(v30 + 48) = 0;
          *(_QWORD *)(v30 + 56) = 0;
          *(_DWORD *)(v30 + 64) = 0;
          qword_254123730 = v30;
          v31 = re::introspectionAllocator((re *)v30);
          v33 = re::introspect_BOOL((re *)1, v32);
          v34 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v31 + 32))(v31, 72, 8);
          *(_DWORD *)v34 = 1;
          *(_QWORD *)(v34 + 8) = "locallyControlled";
          *(_QWORD *)(v34 + 16) = v33;
          *(_QWORD *)(v34 + 24) = 0;
          *(_QWORD *)(v34 + 32) = 0x1000000003;
          *(_DWORD *)(v34 + 40) = 0;
          *(_QWORD *)(v34 + 48) = 0;
          *(_QWORD *)(v34 + 56) = 0;
          *(_DWORD *)(v34 + 64) = 0;
          qword_254123738 = v34;
          v35 = re::introspectionAllocator((re *)v34);
          v37 = re::introspect_uint64_t((re *)1, v36);
          v38 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v35 + 32))(v35, 72, 8);
          *(_DWORD *)v38 = 1;
          *(_QWORD *)(v38 + 8) = "master";
          *(_QWORD *)(v38 + 16) = v37;
          *(_QWORD *)(v38 + 24) = 0;
          *(_QWORD *)(v38 + 32) = 0x1800000004;
          *(_DWORD *)(v38 + 40) = 0;
          *(_QWORD *)(v38 + 48) = 0;
          *(_QWORD *)(v38 + 56) = 0;
          *(_DWORD *)(v38 + 64) = 0;
          qword_254123740 = v38;
          v39 = re::introspectionAllocator((re *)v38);
          v41 = re::introspect_double((re *)1, v40);
          v42 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v39 + 32))(v39, 72, 8);
          *(_DWORD *)v42 = 1;
          *(_QWORD *)(v42 + 8) = "rate";
          *(_QWORD *)(v42 + 16) = v41;
          *(_QWORD *)(v42 + 24) = 0;
          *(_QWORD *)(v42 + 32) = 0x2000000005;
          *(_DWORD *)(v42 + 40) = 0;
          *(_QWORD *)(v42 + 48) = 0;
          *(_QWORD *)(v42 + 56) = 0;
          *(_DWORD *)(v42 + 64) = 0;
          qword_254123748 = v42;
          v43 = re::introspectionAllocator((re *)v42);
          v44 = (uint64_t *)qword_2541235C0;
          if (!qword_2541235C0)
          {
            v44 = allocInfo_CMTime();
            qword_2541235C0 = (uint64_t)v44;
            initInfo_CMTime((re::IntrospectionBase *)v44);
          }
          v45 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v43 + 32))(v43, 72, 8);
          *(_DWORD *)v45 = 1;
          *(_QWORD *)(v45 + 8) = "ownTime";
          *(_QWORD *)(v45 + 16) = v44;
          *(_QWORD *)(v45 + 24) = 0;
          *(_QWORD *)(v45 + 32) = 0x2800000006;
          *(_DWORD *)(v45 + 40) = 0;
          *(_QWORD *)(v45 + 48) = 0;
          *(_QWORD *)(v45 + 56) = 0;
          *(_DWORD *)(v45 + 64) = 0;
          qword_254123750 = v45;
          v46 = re::introspectionAllocator((re *)v45);
          v47 = (uint64_t *)qword_2541235C0;
          if (!qword_2541235C0)
          {
            v47 = allocInfo_CMTime();
            qword_2541235C0 = (uint64_t)v47;
            initInfo_CMTime((re::IntrospectionBase *)v47);
          }
          v48 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v46 + 32))(v46, 72, 8);
          *(_DWORD *)v48 = 1;
          *(_QWORD *)(v48 + 8) = "masterTime";
          *(_QWORD *)(v48 + 16) = v47;
          *(_QWORD *)(v48 + 24) = 0;
          *(_QWORD *)(v48 + 32) = 0x4000000007;
          *(_DWORD *)(v48 + 40) = 0;
          *(_QWORD *)(v48 + 48) = 0;
          *(_QWORD *)(v48 + 56) = 0;
          *(_DWORD *)(v48 + 64) = 0;
          qword_254123758 = v48;
          v49 = re::introspectionAllocator((re *)v48);
          v51 = re::introspect_double((re *)1, v50);
          v52 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v49 + 32))(v49, 72, 8);
          *(_DWORD *)v52 = 1;
          *(_QWORD *)(v52 + 8) = "rateToTOD";
          *(_QWORD *)(v52 + 16) = v51;
          *(_QWORD *)(v52 + 24) = 0;
          *(_QWORD *)(v52 + 32) = 0x5800000008;
          *(_DWORD *)(v52 + 40) = 0;
          *(_QWORD *)(v52 + 48) = 0;
          *(_QWORD *)(v52 + 56) = 0;
          *(_DWORD *)(v52 + 64) = 0;
          qword_254123760 = v52;
          v53 = re::introspectionAllocator((re *)v52);
          v54 = (uint64_t *)qword_2541235C0;
          if (!qword_2541235C0)
          {
            v54 = allocInfo_CMTime();
            qword_2541235C0 = (uint64_t)v54;
            initInfo_CMTime((re::IntrospectionBase *)v54);
          }
          v55 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v53 + 32))(v53, 72, 8);
          *(_DWORD *)v55 = 1;
          *(_QWORD *)(v55 + 8) = "ownTimeToTOD";
          *(_QWORD *)(v55 + 16) = v54;
          *(_QWORD *)(v55 + 24) = 0;
          *(_QWORD *)(v55 + 32) = 0x6000000009;
          *(_DWORD *)(v55 + 40) = 0;
          *(_QWORD *)(v55 + 48) = 0;
          *(_QWORD *)(v55 + 56) = 0;
          *(_DWORD *)(v55 + 64) = 0;
          qword_254123768 = v55;
          v56 = re::introspectionAllocator((re *)v55);
          v57 = (uint64_t *)qword_2541235C0;
          if (!qword_2541235C0)
          {
            v57 = allocInfo_CMTime();
            qword_2541235C0 = (uint64_t)v57;
            initInfo_CMTime((re::IntrospectionBase *)v57);
          }
          v58 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v56 + 32))(v56, 72, 8);
          *(_DWORD *)v58 = 1;
          *(_QWORD *)(v58 + 8) = "masterTimeToTOD";
          *(_QWORD *)(v58 + 16) = v57;
          *(_QWORD *)(v58 + 24) = 0;
          *(_QWORD *)(v58 + 32) = 0x780000000ALL;
          *(_DWORD *)(v58 + 40) = 0;
          *(_QWORD *)(v58 + 48) = 0;
          *(_QWORD *)(v58 + 56) = 0;
          *(_DWORD *)(v58 + 64) = 0;
          qword_254123770 = v58;
          v59 = re::introspectionAllocator((re *)v58);
          v61 = re::introspect_BOOL((re *)1, v60);
          v62 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v59 + 32))(v59, 72, 8);
          *(_DWORD *)v62 = 1;
          *(_QWORD *)(v62 + 8) = "ignoreClockSourceAnchor";
          *(_QWORD *)(v62 + 16) = v61;
          *(_QWORD *)(v62 + 24) = 0;
          *(_QWORD *)(v62 + 32) = 0x900000000BLL;
          *(_DWORD *)(v62 + 40) = 0;
          *(_QWORD *)(v62 + 48) = 0;
          *(_QWORD *)(v62 + 56) = 0;
          *(_DWORD *)(v62 + 64) = 0;
          qword_254123778 = v62;
          v63 = re::introspectionAllocator((re *)v62);
          v64 = (uint64_t *)qword_2541235C0;
          if (!qword_2541235C0)
          {
            v64 = allocInfo_CMTime();
            qword_2541235C0 = (uint64_t)v64;
            initInfo_CMTime((re::IntrospectionBase *)v64);
          }
          v65 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v63 + 32))(v63, 72, 8);
          *(_DWORD *)v65 = 1;
          *(_QWORD *)(v65 + 8) = "latestSeekTarget";
          *(_QWORD *)(v65 + 16) = v64;
          *(_QWORD *)(v65 + 24) = 0;
          *(_QWORD *)(v65 + 32) = 0x940000000CLL;
          *(_DWORD *)(v65 + 40) = 0;
          *(_QWORD *)(v65 + 48) = 0;
          *(_QWORD *)(v65 + 56) = 0;
          *(_DWORD *)(v65 + 64) = 0;
          qword_254123780 = v65;
          __cxa_guard_release(&qword_254123578);
          v3 = &qword_254123000;
        }
      }
      qword_254123798 = 0xB000000008;
      v5 = &qword_254123788;
      dword_2541237A0 = 8;
      word_2541237A4 = 1;
      dword_2541237C0 = 12;
      *(_QWORD *)&xmmword_2541237C8 = &qword_254123728;
      *((_QWORD *)&xmmword_2541237C8 + 1) = re::internal::defaultConstruct<re::ClockOrTimebase>;
      qword_2541237D8 = (uint64_t)re::internal::defaultDestruct<re::ClockOrTimebase>;
      unk_2541237E0 = 0;
      *(_QWORD *)&xmmword_2541237E8 = 0;
      *((_QWORD *)&xmmword_2541237E8 + 1) = re::internal::defaultConstructV2<re::ClockOrTimebase>;
      qword_2541237F8 = (uint64_t)re::internal::defaultDestructV2<re::ClockOrTimebase>;
      re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&qword_254123788, v7);
      v76 = v72;
    }
    if ((*((_BYTE *)v3 + 1369) & 1) == 0)
    {
      byte_254123559 = 1;
      v9 = *((_DWORD *)v5 + 6);
      ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2541236D8, 0);
      qword_2541236E8 = 0x3000000007;
      dword_2541236F0 = v9;
      word_2541236F4 = 0;
      *(_QWORD *)&xmmword_2541236F8 = 0;
      *((_QWORD *)&xmmword_2541236F8 + 1) = 0xFFFFFFFFLL;
      qword_254123708 = (uint64_t)v4;
      unk_254123710 = 0;
      qword_254123718 = (uint64_t)v5;
      unk_254123720 = 0;
      qword_2541236D8 = (uint64_t)&off_24ED89670;
      re::IntrospectionRegistry::add(v10, v11);
      re::getPrettyTypeName((re *)&qword_2541236D8, (const re::IntrospectionBase *)&v72);
      if ((BYTE8(v72) & 1) != 0)
        v12 = v73;
      else
        v12 = (char *)&v72 + 9;
      if ((_QWORD)v72 && (BYTE8(v72) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v72 + 40))();
      v13 = v4[2];
      v67 = *((_OWORD *)v5 + 2);
      v68 = v13;
      v14 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, v69);
      if (v14)
      {
        v15 = *v14;
        *((_QWORD *)&v66 + 1) = v15;
      }
      else
      {
        *(_QWORD *)&v72 = 0x449AD97C4B77BED4;
        *((_QWORD *)&v72 + 1) = "_CompareFunc";
        v16 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)&unk_25582A358, &v72);
        if (v16)
        {
          v17 = *v16;
          re::StringID::destroyString((re::StringID *)&v72);
        }
        else
        {
          re::StringID::destroyString((re::StringID *)&v72);
          *(_QWORD *)&v76 = 0x449AD97C4B77BED4;
          *((_QWORD *)&v76 + 1) = "_CompareFunc";
          v17 = *((_QWORD *)&v72 + 1);
          v18 = (void *)v72;
          re::StringID::destroyString((re::StringID *)&v76);
        }
        re::TypeInfo::TypeInfo((uint64_t)&v76, (uint64_t)&v72 + 8);
        if (!v18
          || (v19 = *v77,
              *(_QWORD *)&v72 = v17,
              *((_QWORD *)&v72 + 1) = v19,
              LODWORD(v73) = -1,
              (v20 = (_anonymous_namespace_ *)re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(v76 + 768, (uint64_t *)&v72)) == 0)|| !*(_QWORD *)v20)
        {
          v75 = v68;
          v74[0] = v18;
          v74[1] = v17;
        }
        v70 = v67;
        v71 = v68;
        re::TypeBuilder::beginDictionaryType((uint64_t)&v72, v69, 1, 0x30uLL, 8uLL, &v71, &v70);
        re::TypeBuilder::setConstructor((uint64_t)&v72, (uint64_t)re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke);
        re::TypeBuilder::setDestructor((uint64_t)&v72, (uint64_t)re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke);
        re::TypeBuilder::setDictionaryAccessors((uint64_t)&v72, (uint64_t)re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *)#1}::__invoke, (uint64_t)re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#3}::__invoke, (uint64_t)re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke);
        re::TypeBuilder::setDictionaryIterator((uint64_t)&v72, (void *(*)(void *, re::Allocator *))re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke, (BOOL (*)(void *))re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke, (const void *(*)(void *))re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#3}::__invoke, (void *(*)(void *))re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#4}::__invoke, (void (*)(void *, re::Allocator *))re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke);
        re::TypeBuilder::~TypeBuilder((re::TypeBuilder *)&v72, v21);
      }
      xmmword_2541236F8 = v66;
      re::StringID::destroyString((re::StringID *)v69);
    }
  }
}

__n128 re::internal::defaultConstruct<re::TimebaseTree>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  __n128 result;
  uint64_t v5;

  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_QWORD *)(a3 + 36) = 0x7FFFFFFFLL;
  *(_QWORD *)(a3 + 48) = 0;
  v3 = MEMORY[0x24BDC0D88];
  result = *(__n128 *)MEMORY[0x24BDC0D88];
  *(_OWORD *)(a3 + 56) = *MEMORY[0x24BDC0D88];
  v5 = *(_QWORD *)(v3 + 16);
  *(_QWORD *)(a3 + 72) = v5;
  *(__n128 *)(a3 + 80) = result;
  *(_QWORD *)(a3 + 104) = 0;
  *(_QWORD *)(a3 + 112) = 0;
  *(_QWORD *)(a3 + 96) = v5;
  *(_BYTE *)(a3 + 120) = 0;
  return result;
}

double re::internal::defaultDestruct<re::TimebaseTree>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(a3);
}

__n128 re::internal::defaultConstructV2<re::TimebaseTree>(uint64_t a1)
{
  uint64_t v1;
  __n128 result;
  uint64_t v3;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  *(_QWORD *)(a1 + 48) = 0;
  v1 = MEMORY[0x24BDC0D88];
  result = *(__n128 *)MEMORY[0x24BDC0D88];
  *(_OWORD *)(a1 + 56) = *MEMORY[0x24BDC0D88];
  v3 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(a1 + 72) = v3;
  *(__n128 *)(a1 + 80) = result;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 96) = v3;
  *(_BYTE *)(a1 + 120) = 0;
  return result;
}

uint64_t re::introspect_TimebaseTree(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"TimebaseTree", (uint64_t (*)(re::internal *))re::allocInfo_TimebaseTree, (re::IntrospectionBase *(*)(void))re::initInfo_TimebaseTree, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::TimebaseTree>, this);
}

uint64_t *re::allocInfo_TimebaseService(re *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  v1 = atomic_load((unsigned __int8 *)&qword_254123598);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_254123598))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254123878, 0);
    *(_QWORD *)(v3 + 22) = 0;
    qword_254123888 = 0;
    qword_254123898 = 0;
    qword_2541238A0 = 0xFFFFFFFFLL;
    qword_254123878 = (uint64_t)&off_24ED7DAA8;
    qword_2541238A8 = (uint64_t)"TimebaseService";
    dword_2541238B0 = 0;
    xmmword_2541238B8 = 0u;
    unk_2541238C8 = 0u;
    xmmword_2541238D8 = 0u;
    qword_2541238E8 = 0;
    __cxa_guard_release(&qword_254123598);
  }
  return &qword_254123878;
}

void re::initInfo_TimebaseService(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x483E17396C8F9B2ELL;
  v5[1] = "TimebaseService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x1800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = re::internal::defaultRetain<re::TimebaseService>(void)::{lambda(void *)#1}::__invoke;
  *((_QWORD *)this + 12) = re::internal::defaultRelease<re::TimebaseService>(void)::{lambda(void *)#1}::__invoke;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_TimebaseService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_TimebaseService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"TimebaseService", (uint64_t (*)(re::internal *))re::allocInfo_TimebaseService, (re::IntrospectionBase *(*)(void))re::initInfo_TimebaseService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::TimebaseService>, this);
}

id re::TimebaseLog(re *this)
{
  if (qword_2541235A8 != -1)
    dispatch_once(&qword_2541235A8, &__block_literal_global_47);
  return (id)qword_2541235A0;
}

void ___ZN2re11TimebaseLogEv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.re", "Timebase");
  v1 = (void *)qword_2541235A0;
  qword_2541235A0 = (uint64_t)v0;

}

uint64_t *allocInfo_CMTime(void)
{
  unsigned __int8 v0;
  uint64_t v2;

  v0 = atomic_load((unsigned __int8 *)&qword_2541235B0);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2541235B0))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2541238F0, 0);
    *(_QWORD *)(v2 + 22) = 0;
    qword_254123900 = 0;
    qword_254123910 = 0;
    qword_254123918 = 0xFFFFFFFFLL;
    qword_2541238F0 = (uint64_t)&off_24ED7DAA8;
    qword_254123920 = (uint64_t)"CMTime";
    dword_254123928 = 0;
    xmmword_254123930 = 0u;
    unk_254123940 = 0u;
    xmmword_254123950 = 0u;
    qword_254123960 = 0;
    __cxa_guard_release(&qword_2541235B0);
  }
  return &qword_2541238F0;
}

void initInfo_CMTime(re::IntrospectionBase *a1)
{
  const re::IntrospectionBase *v2;
  unsigned __int8 v3;
  re *v4;
  uint64_t *v5;
  const re::IntrospectionBase *v6;
  void *v7;
  uint64_t v8;
  uint64_t *v9;
  const re::IntrospectionBase *v10;
  void *v11;
  uint64_t v12;
  uint64_t *v13;
  const re::IntrospectionBase *v14;
  void *v15;
  uint64_t v16;
  uint64_t *v17;
  const re::IntrospectionBase *v18;
  void *v19;
  uint64_t v20;
  __int128 v21;
  _QWORD v22[2];
  __int128 v23;

  v22[0] = 3983742126;
  v22[1] = "CMTime";
  re::StringID::destroyString((re::StringID *)v22);
  *((_OWORD *)a1 + 2) = v23;
  v3 = atomic_load((unsigned __int8 *)&qword_2541235B8);
  if ((v3 & 1) == 0)
  {
    v4 = (re *)__cxa_guard_acquire(&qword_2541235B8);
    if ((_DWORD)v4)
    {
      v5 = re::introspectionAllocator(v4);
      v7 = re::introspect_int64_t((re *)1, v6);
      v8 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v5 + 32))(v5, 72, 8);
      *(_DWORD *)v8 = 1;
      *(_QWORD *)(v8 + 8) = "value";
      *(_QWORD *)(v8 + 16) = v7;
      *(_QWORD *)(v8 + 24) = 0;
      *(_QWORD *)(v8 + 32) = 1;
      *(_DWORD *)(v8 + 40) = 0;
      *(_QWORD *)(v8 + 48) = 0;
      *(_QWORD *)(v8 + 56) = 0;
      *(_DWORD *)(v8 + 64) = 0;
      qword_2541235F0 = v8;
      v9 = re::introspectionAllocator((re *)v8);
      v11 = re::introspect_int((re *)1, v10);
      v12 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v9 + 32))(v9, 72, 8);
      *(_DWORD *)v12 = 1;
      *(_QWORD *)(v12 + 8) = "timescale";
      *(_QWORD *)(v12 + 16) = v11;
      *(_QWORD *)(v12 + 24) = 0;
      *(_QWORD *)(v12 + 32) = 0x800000002;
      *(_DWORD *)(v12 + 40) = 0;
      *(_QWORD *)(v12 + 48) = 0;
      *(_QWORD *)(v12 + 56) = 0;
      *(_DWORD *)(v12 + 64) = 0;
      qword_2541235F8 = v12;
      v13 = re::introspectionAllocator((re *)v12);
      v15 = re::introspect_uint32_t((re *)1, v14);
      v16 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v13 + 32))(v13, 72, 8);
      *(_DWORD *)v16 = 1;
      *(_QWORD *)(v16 + 8) = "flags";
      *(_QWORD *)(v16 + 16) = v15;
      *(_QWORD *)(v16 + 24) = 0;
      *(_QWORD *)(v16 + 32) = 0xC00000003;
      *(_DWORD *)(v16 + 40) = 0;
      *(_QWORD *)(v16 + 48) = 0;
      *(_QWORD *)(v16 + 56) = 0;
      *(_DWORD *)(v16 + 64) = 0;
      qword_254123600 = v16;
      v17 = re::introspectionAllocator((re *)v16);
      v19 = re::introspect_int64_t((re *)1, v18);
      v20 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v17 + 32))(v17, 72, 8);
      *(_DWORD *)v20 = 1;
      *(_QWORD *)(v20 + 8) = "epoch";
      *(_QWORD *)(v20 + 16) = v19;
      *(_QWORD *)(v20 + 24) = 0;
      *(_QWORD *)(v20 + 32) = 0x1000000004;
      *(_DWORD *)(v20 + 40) = 0;
      *(_QWORD *)(v20 + 48) = 0;
      *(_QWORD *)(v20 + 56) = 0;
      *(_DWORD *)(v20 + 64) = 0;
      qword_254123608 = v20;
      __cxa_guard_release(&qword_2541235B8);
    }
  }
  *((_QWORD *)a1 + 2) = 0x1800000008;
  *((_DWORD *)a1 + 6) = 4;
  *((_WORD *)a1 + 14) = 1;
  *((_DWORD *)a1 + 14) = 4;
  *((_QWORD *)a1 + 8) = &qword_2541235F0;
  *((_QWORD *)a1 + 9) = re::internal::defaultConstruct<CMTime>;
  *((_QWORD *)a1 + 10) = re::internal::defaultDestruct<CMTime>;
  *((_QWORD *)a1 + 11) = 0;
  *((_QWORD *)a1 + 12) = 0;
  *((_QWORD *)a1 + 13) = re::internal::defaultConstructV2<CMTime>;
  *((_QWORD *)a1 + 14) = re::internal::defaultDestructV2<CMTime>;
  re::IntrospectionRegistry::add(a1, v2);
  v21 = v23;
}

uint64_t re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v6;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *a2;
  v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v6 + 200 * v4 + 16) != v2)
  {
    while (1)
    {
      LODWORD(v4) = *(_DWORD *)(v6 + 200 * v4 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v4 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v6 + 200 * v4 + 16) == v2)
        return v6 + 200 * v4 + 24;
    }
    return 0;
  }
  return v6 + 200 * v4 + 24;
}

uint64_t re::TimebaseTree::rootID(re::TimebaseTree *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  int v6;
  int v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;

  if (*((_DWORD *)this + 7))
  {
    v2 = *((unsigned int *)this + 8);
    v3 = *((_QWORD *)this + 2);
    v4 = 0;
    if ((_DWORD)v2)
    {
      v5 = (int *)(v3 + 8);
      while (1)
      {
        v6 = *v5;
        v5 += 50;
        if (v6 < 0)
          break;
        if (v2 == ++v4)
        {
          LODWORD(v4) = *((_DWORD *)this + 8);
          break;
        }
      }
    }
    v10 = *(_QWORD *)(v3 + 200 * v4 + 16);
    if (v10)
    {
      v7 = -1;
      while (++v7 < *((_DWORD *)this + 7))
      {
        result = re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this, &v10);
        if (result)
        {
          v9 = result;
          result = v10;
          v10 = *(_QWORD *)(v9 + 24);
          if (v10)
            continue;
        }
        return result;
      }
    }
  }
  return 0;
}

re *re::TimebaseService::CreateAudioClock(re::TimebaseService *this, OpaqueCMClock **a2)
{
  re *v2;
  int v3;
  NSObject *v4;
  re *result;
  NSObject *v6;
  re *HostTimeClock;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  HostTimeClock = 0;
  v2 = (re *)re::ProxyAudioClockCreate((re *)&HostTimeClock, a2);
  if ((_DWORD)v2)
  {
    v3 = (int)v2;
    re::TimebaseLog(v2);
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v9 = "CreateAudioClock";
      v10 = 1024;
      v11 = 156;
      v12 = 1024;
      v13 = v3;
      _os_log_error_impl(&dword_224FE9000, v4, OS_LOG_TYPE_ERROR, "%s:%d error: %d", buf, 0x18u);
    }

  }
  result = HostTimeClock;
  if (!HostTimeClock)
  {
    re::TimebaseLog(0);
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_224FE9000, v6, OS_LOG_TYPE_ERROR, "AudioClock is unavailable! Falling back to host clock.", buf, 2u);
    }

    HostTimeClock = CMClockGetHostTimeClock();
    CFRetain(HostTimeClock);
    return HostTimeClock;
  }
  return result;
}

uint64_t re::TimebaseManager::TimebaseManager(uint64_t a1, uint64_t a2)
{
  _anonymous_namespace_ *v4;
  float v5;
  const __CFAllocator *v6;
  OpaqueCMClock *HostTimeClock;
  __int128 v9;
  __int128 v10;
  char v11[8];
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = &off_24ED89590;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_DWORD *)(a1 + 24) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_DWORD *)(a1 + 64) = 1065353216;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 1065353216;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_DWORD *)(a1 + 144) = 1065353216;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 184) = 1065353216;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_DWORD *)(a1 + 224) = 1065353216;
  *(_QWORD *)(a1 + 240) = a2;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 308) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_QWORD *)(a1 + 324) = 0x7FFFFFFFLL;
  *(_BYTE *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 344) = 0;
  if (a2)
  {
    v4 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 64))(a2);
    *(_QWORD *)&v9 = a1;
    *((_QWORD *)&v9 + 1) = re::TimebaseManager::didChangeSharedClocks;
    *(_QWORD *)&v10 = 0;
    *((_QWORD *)&v10 + 1) = re::Event<re::SharedClockService,OpaqueCMClock *,OpaqueCMClock *,unsigned long long>::createSubscription<re::TimebaseManager>(re::TimebaseManager *,REEventHandlerResult (re::TimebaseManager::*)(re::SharedClockService*,OpaqueCMClock *,OpaqueCMClock *,unsigned long long))::{lambda(re::SharedClockService*,re::Event<re::SharedClockService,OpaqueCMClock *,OpaqueCMClock *,unsigned long long>::Subscription const&,OpaqueCMClock *&&,OpaqueCMClock *&,unsigned long long &&)#1}::__invoke;
    re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf((uint64_t)v4, &v9, (uint64_t)v11);
    if (!v11[0])
    {
      if (*((_DWORD *)v4 + 20))
      {
        v11[0] = 1;
        v12 = v9;
        v13 = v10;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::add((uint64_t)v4 + 40, (uint64_t)v11);
      }
      else
      {
        re::DynamicArray<re::EvaluationRegister>::add(v4, (uint64_t)&v9);
      }
    }
    v5 = *(float *)(a1 + 64);
  }
  else
  {
    v5 = 1.0;
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>(a1 + 32, vcvtps_u32_f32(64.0 / v5));
  std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>(a1 + 72, vcvtps_u32_f32(64.0 / *(float *)(a1 + 104)));
  std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>(a1 + 112, vcvtps_u32_f32(64.0 / *(float *)(a1 + 144)));
  std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>(a1 + 152, vcvtps_u32_f32(64.0 / *(float *)(a1 + 184)));
  std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>(a1 + 192, vcvtps_u32_f32(64.0 / *(float *)(a1 + 224)));
  v6 = (const __CFAllocator *)*MEMORY[0x24BDBD240];
  HostTimeClock = CMClockGetHostTimeClock();
  CMTimebaseCreateWithSourceClock(v6, HostTimeClock, (CMTimebaseRef *)(a1 + 232));
  return a1;
}

uint64_t re::TimebaseManager::didChangeSharedClocks(uint64_t a1, uint64_t a2, const void *a3, const void *a4, uint64_t a5)
{
  uint64_t v9;
  OpaqueCMClock **v10;
  CMClockOrTimebaseRef v11;
  CFTypeRef v12;
  CMClockOrTimebaseRef v13;
  CFTypeRef v14;
  const void *v15;
  unint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  CFTypeRef v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint8x8_t v25;
  void **v26;
  char *v27;
  unint64_t v28;
  float v29;
  float v30;
  _BOOL8 v31;
  unint64_t v32;
  unint64_t v33;
  size_t v34;
  uint64_t v35;
  _QWORD *v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  _QWORD *i;
  _QWORD *j;
  unint64_t v53;
  uint64_t v54;
  uint64_t **v55;
  CFTypeID v56;
  CMClockOrTimebaseRef v57;
  CMClockOrTimebaseRef v58;
  BOOL v59;
  CFTypeRef v60;
  float *v61;
  uint64_t **k;
  OpaqueCMClock *v64;
  uint64_t **m;
  OpaqueCMClock *v66;
  _QWORD *v68;
  _QWORD *v69;
  _QWORD *v70;
  uint64_t *v71;
  CFTypeRef cf;
  __int128 v73;
  __int128 v74;
  int v75;
  __int128 v76;
  __int128 v77;
  int v78;
  os_unfair_lock_t v79;
  char v80;

  v79 = (os_unfair_lock_t)(a1 + 24);
  v80 = 1;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  v11 = *(CMClockOrTimebaseRef *)(a1 + 272);
  if (a3)
    v12 = CFRetain(a3);
  else
    v12 = 0;
  *(_QWORD *)(a1 + 272) = v12;
  v13 = *(CMClockOrTimebaseRef *)(a1 + 264);
  if (a4)
    v14 = CFRetain(a4);
  else
    v14 = 0;
  *(_QWORD *)(a1 + 264) = v14;
  v15 = *(const void **)(a1 + 280);
  if (!v15)
  {
    re::TimebaseManager::updatePrimarySharedClock((re::TimebaseManager *)a1, v9, v10);
    v15 = *(const void **)(a1 + 280);
  }
  re::TimebaseManager::updatePrimarySharedClock((re::TimebaseManager *)a1, v9, v10);
  v16 = a1 + 72;
  v17 = std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::find<void const*>((_QWORD *)(a1 + 72), (unint64_t)v15);
  if (!v17)
    goto LABEL_69;
  v71 = (uint64_t *)(a1 + 72);
  cf = v15;
  v70 = v17;
  v18 = v17[3];
  *(_QWORD *)&v73 = v18;
  if (std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>((_QWORD *)(a1 + 112), v18))
  {
    v19 = CFRetain(*(CFTypeRef *)(a1 + 280));
    std::__hash_table<std::__hash_value_type<unsigned long long,void const*>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void const*>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void const*>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void const*>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(a1 + 112, v18, &v73)[3] = v19;
    CFRelease(cf);
  }
  v20 = *(_QWORD *)(a1 + 280);
  v21 = 0x9DDFEA08EB382D69 * (((8 * v20) + 8) ^ HIDWORD(v20));
  v22 = 0x9DDFEA08EB382D69 * (HIDWORD(v20) ^ (v21 >> 47) ^ v21);
  v23 = 0x9DDFEA08EB382D69 * (v22 ^ (v22 >> 47));
  v24 = *(_QWORD *)(a1 + 80);
  if (v24)
  {
    v25 = (uint8x8_t)vcnt_s8((int8x8_t)v24);
    v25.i16[0] = vaddlv_u8(v25);
    if (v25.u32[0] > 1uLL)
    {
      v16 = 0x9DDFEA08EB382D69 * (v22 ^ (v22 >> 47));
      if (v23 >= v24)
        v16 = v23 % v24;
    }
    else
    {
      v16 = v23 & (v24 - 1);
    }
    v26 = *(void ***)(*v71 + 8 * v16);
    if (v26)
    {
      v27 = (char *)*v26;
      if (*v26)
      {
        do
        {
          v28 = *((_QWORD *)v27 + 1);
          if (v28 == v23)
          {
            if (*((_QWORD *)v27 + 2) == v20)
            {
              v68 = (_QWORD *)(a1 + 72);
              v15 = cf;
              goto LABEL_52;
            }
          }
          else
          {
            if (v25.u32[0] > 1uLL)
            {
              if (v28 >= v24)
                v28 %= v24;
            }
            else
            {
              v28 &= v24 - 1;
            }
            if (v28 != v16)
              break;
          }
          v27 = *(char **)v27;
        }
        while (v27);
      }
    }
  }
  v27 = (char *)operator new(0x48uLL);
  v69 = (_QWORD *)(a1 + 88);
  *((_QWORD *)&v76 + 1) = a1 + 88;
  *(_QWORD *)v27 = 0;
  *((_QWORD *)v27 + 1) = v23;
  *((_QWORD *)v27 + 2) = v20;
  *(_OWORD *)(v27 + 56) = 0u;
  *(_OWORD *)(v27 + 24) = 0u;
  *(_OWORD *)(v27 + 40) = 0u;
  *((_DWORD *)v27 + 16) = 1065353216;
  LOBYTE(v77) = 1;
  v29 = (float)(unint64_t)(*(_QWORD *)(a1 + 96) + 1);
  v30 = *(float *)(a1 + 104);
  v68 = (_QWORD *)(a1 + 72);
  if (!v24 || (float)(v30 * (float)v24) < v29)
  {
    v31 = v24 < 3 || (v24 & (v24 - 1)) != 0;
    v32 = v31 | (2 * v24);
    v33 = vcvtps_u32_f32(v29 / v30);
    if (v32 <= v33)
      v34 = v33;
    else
      v34 = v32;
    std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>((uint64_t)v71, v34);
    v24 = *(_QWORD *)(a1 + 80);
    if ((v24 & (v24 - 1)) != 0)
    {
      if (v23 >= v24)
        v16 = v23 % v24;
      else
        v16 = v23;
    }
    else
    {
      v16 = (v24 - 1) & v23;
    }
  }
  v35 = *v71;
  v36 = *(_QWORD **)(*v71 + 8 * v16);
  if (v36)
  {
    *(_QWORD *)v27 = *v36;
    v15 = cf;
  }
  else
  {
    *(_QWORD *)v27 = *v69;
    *v69 = v27;
    *(_QWORD *)(v35 + 8 * v16) = v69;
    v15 = cf;
    if (!*(_QWORD *)v27)
      goto LABEL_51;
    v37 = *(_QWORD *)(*(_QWORD *)v27 + 8);
    if ((v24 & (v24 - 1)) != 0)
    {
      if (v37 >= v24)
        v37 %= v24;
    }
    else
    {
      v37 &= v24 - 1;
    }
    v36 = (_QWORD *)(*v71 + 8 * v37);
  }
  *v36 = v27;
LABEL_51:
  *(_QWORD *)&v76 = 0;
  ++*(_QWORD *)(a1 + 96);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,void *>>>>::reset[abi:nn180100]((uint64_t)&v76);
LABEL_52:
  v38 = *((_QWORD *)v27 + 4);
  *((_QWORD *)v27 + 3) = v70[3];
  *((_QWORD *)v27 + 4) = 0;
  v39 = v70[4];
  v70[4] = 0;
  v40 = (void *)*((_QWORD *)v27 + 4);
  *((_QWORD *)v27 + 4) = v39;
  if (v40)
    operator delete(v40);
  v41 = (void *)v70[4];
  v70[4] = v38;
  if (v41)
    operator delete(v41);
  v42 = *((_QWORD *)v27 + 6);
  v43 = *((_QWORD *)v27 + 5);
  v44 = v70[6];
  *((_QWORD *)v27 + 5) = v70[5];
  v70[5] = v43;
  *((_QWORD *)v27 + 6) = v44;
  v70[6] = v42;
  v45 = *((_QWORD *)v27 + 7);
  *((_QWORD *)v27 + 7) = v70[7];
  v70[7] = v45;
  v46 = *((_DWORD *)v27 + 16);
  *((_DWORD *)v27 + 16) = *((_DWORD *)v70 + 16);
  *((_DWORD *)v70 + 16) = v46;
  if (*((_QWORD *)v27 + 7))
  {
    v47 = *((_QWORD *)v27 + 5);
    v48 = *(_QWORD *)(*((_QWORD *)v27 + 6) + 8);
    if ((v47 & (v47 - 1)) != 0)
    {
      if (v48 >= v47)
        v48 %= v47;
    }
    else
    {
      v48 &= v47 - 1;
    }
    *(_QWORD *)(*((_QWORD *)v27 + 4) + 8 * v48) = v27 + 48;
  }
  if (v45)
  {
    v49 = v70[5];
    v50 = *(_QWORD *)(v70[6] + 8);
    if ((v49 & (v49 - 1)) != 0)
    {
      if (v50 >= v49)
        v50 %= v49;
    }
    else
    {
      v50 &= v49 - 1;
    }
    *(_QWORD *)(v70[4] + 8 * v50) = v70 + 6;
  }
  std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::__erase_unique<void const*>(v68, (unint64_t)v15);
LABEL_69:
  for (i = *(_QWORD **)(a1 + 88); i; i = (_QWORD *)*i)
  {
    for (j = (_QWORD *)i[6]; j; j = (_QWORD *)*j)
    {
      v53 = j[2];
      *(_QWORD *)(v53 + 112) = a5;
      v54 = re::HashTable<re::ecs2::Entity const*,re::SharedPtr<re::ecs2::CAMeshCodirectionalGroup>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::tryGet(a1 + 288, v53);
      if (v54)
        (*(void (**)(void))(*(_QWORD *)v54 + 16))();
    }
  }
  v76 = 0u;
  v77 = 0u;
  v78 = 1065353216;
  v73 = 0u;
  v74 = 0u;
  v75 = 1065353216;
  v55 = *(uint64_t ***)(a1 + 128);
  if (v55)
  {
    while (1)
    {
      v56 = CFGetTypeID(v55[3]);
      if (v56 == CMTimebaseGetTypeID())
        break;
LABEL_92:
      v55 = (uint64_t **)*v55;
      if (!v55)
        goto LABEL_93;
    }
    v57 = CMTimebaseCopySource((CMTimebaseRef)v55[3]);
    v58 = v57;
    if (*(_QWORD *)(a1 + 264)
      && (v57 != v11 ? (v59 = v57 == v13) : (v59 = 1),
          v59 || re::TimebaseManager::matchesAudioClock((re::TimebaseManager *)a1, v57)))
    {
      v60 = CFRetain(v55[3]);
      v61 = (float *)&v73;
    }
    else
    {
      if (v58 != v11 && v58 != v13)
        goto LABEL_91;
      v60 = CFRetain(v55[3]);
      v61 = (float *)&v76;
    }
    std::__hash_table<OpaqueCMTimebase *,std::hash<OpaqueCMTimebase *>,std::equal_to<OpaqueCMTimebase *>,std::allocator<OpaqueCMTimebase *>>::__emplace_unique_key_args<OpaqueCMTimebase *,OpaqueCMTimebase *>(v61, (unint64_t)v60, (uint64_t)v60);
LABEL_91:
    CFRelease(v58);
    goto LABEL_92;
  }
LABEL_93:
  if (v13)
    CFRelease(v13);
  if (v11)
    CFRelease(v11);
  if (v15)
    CFRelease(v15);
  std::unique_lock<re::UnfairLock>::unlock((uint64_t)&v79);
  for (k = (uint64_t **)v77; k; k = (uint64_t **)*k)
  {
    v64 = *(OpaqueCMClock **)(a1 + 272);
    if (!v64)
      v64 = *(OpaqueCMClock **)(a1 + 280);
    CMTimebaseSetSourceClock((CMTimebaseRef)k[2], v64);
    CFRelease(k[2]);
  }
  for (m = (uint64_t **)v74; m; m = (uint64_t **)*m)
  {
    v66 = *(OpaqueCMClock **)(a1 + 264);
    if (!v66)
      v66 = *(OpaqueCMClock **)(a1 + 280);
    CMTimebaseSetSourceClock((CMTimebaseRef)m[2], v66);
    CFRelease(m[2]);
  }
  re::TimebaseManager::_beforeFrameUpdate((os_unfair_lock_s *)a1);
  re::TimebaseManager::_afterFrameUpdate((os_unfair_lock_s *)a1);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)&v73);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)&v76);
  if (v80)
    os_unfair_lock_unlock(v79);
  return 0;
}

void re::TimebaseManager::~TimebaseManager(re::TimebaseManager *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  re::TimebaseManager **v7;
  __int128 v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  uint64_t **i;
  uint64_t **j;
  uint64_t **k;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  _QWORD *v22;
  _QWORD *v23;
  void *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  _BYTE v28[8];
  __int128 v29;
  __int128 v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 30);
  if (v2)
  {
    v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 64))(v2);
    if (*(_QWORD *)(v3 + 16))
    {
      v4 = v3;
      v5 = 0;
      v6 = v3 + 40;
      do
      {
        v7 = (re::TimebaseManager **)(*(_QWORD *)(v4 + 32) + 32 * v5);
        if (*v7 == this)
        {
          if (!*(_DWORD *)(v4 + 80))
          {
            re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStableAt((_QWORD *)v4, v5);
            continue;
          }
          v28[0] = 0;
          v8 = *((_OWORD *)v7 + 1);
          v29 = *(_OWORD *)v7;
          v30 = v8;
          re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::add(v6, (uint64_t)v28);
        }
        ++v5;
      }
      while (v5 < *(_QWORD *)(v4 + 16));
    }
  }
  v9 = (const void *)*((_QWORD *)this + 34);
  if (v9)
    CFRelease(v9);
  v10 = (const void *)*((_QWORD *)this + 33);
  if (v10)
    CFRelease(v10);
  v11 = (const void *)*((_QWORD *)this + 35);
  if (v11)
    CFRelease(v11);
  v12 = (const void *)*((_QWORD *)this + 32);
  if (v12)
    CFRelease(v12);
  for (i = (uint64_t **)*((_QWORD *)this + 6); i; i = (uint64_t **)*i)
    re::TimebaseManager::cleanUpLeafLocallyControlledTimebase(this, (OpaqueCMTimebase *)i[2]);
  for (j = (uint64_t **)*((_QWORD *)this + 16); j; j = (uint64_t **)*j)
    CFRelease(j[3]);
  for (k = (uint64_t **)*((_QWORD *)this + 21); k; k = (uint64_t **)*k)
    CFRelease(k[3]);
  CFRelease(*((CFTypeRef *)this + 29));
  re::HashTable<unsigned long long,void({block_pointer} {__strong})(unsigned long long,REAudioPlaybackState,REAudioPlaybackState),re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 36);
  v16 = (_QWORD *)*((_QWORD *)this + 26);
  if (v16)
  {
    do
    {
      v17 = (_QWORD *)*v16;
      operator delete(v16);
      v16 = v17;
    }
    while (v17);
  }
  v18 = (void *)*((_QWORD *)this + 24);
  *((_QWORD *)this + 24) = 0;
  if (v18)
    operator delete(v18);
  v19 = (_QWORD *)*((_QWORD *)this + 21);
  if (v19)
  {
    do
    {
      v20 = (_QWORD *)*v19;
      operator delete(v19);
      v19 = v20;
    }
    while (v20);
  }
  v21 = (void *)*((_QWORD *)this + 19);
  *((_QWORD *)this + 19) = 0;
  if (v21)
    operator delete(v21);
  v22 = (_QWORD *)*((_QWORD *)this + 16);
  if (v22)
  {
    do
    {
      v23 = (_QWORD *)*v22;
      operator delete(v22);
      v22 = v23;
    }
    while (v23);
  }
  v24 = (void *)*((_QWORD *)this + 14);
  *((_QWORD *)this + 14) = 0;
  if (v24)
    operator delete(v24);
  v25 = (_QWORD *)*((_QWORD *)this + 11);
  if (v25)
  {
    do
    {
      v26 = (_QWORD *)*v25;
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)(v25 + 4));
      operator delete(v25);
      v25 = v26;
    }
    while (v26);
  }
  v27 = (void *)*((_QWORD *)this + 9);
  *((_QWORD *)this + 9) = 0;
  if (v27)
    operator delete(v27);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)this + 32);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::TimebaseManager::~TimebaseManager(this);
  JUMPOUT(0x2276933B8);
}

void re::TimebaseManager::cleanUpLeafLocallyControlledTimebase(re::TimebaseManager *this, OpaqueCMTimebase *a2)
{
  __CFNotificationCenter *LocalCenter;
  __CFNotificationCenter *v5;
  __CFNotificationCenter *v6;

  LocalCenter = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(LocalCenter, this, (CFNotificationName)*MEMORY[0x24BDC0DB0], a2);
  v5 = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(v5, this, (CFNotificationName)*MEMORY[0x24BDC0DA0], a2);
  v6 = CFNotificationCenterGetLocalCenter();
  CFNotificationCenterRemoveObserver(v6, this, (CFNotificationName)*MEMORY[0x24BDC0DA8], a2);
}

re *re::TimebaseManager::audioClock(re::TimebaseManager *this, OpaqueCMClock **a2)
{
  re *result;

  result = (re *)*((_QWORD *)this + 32);
  if (!result)
  {
    result = re::TimebaseService::CreateAudioClock(0, a2);
    *((_QWORD *)this + 32) = result;
  }
  return result;
}

CMClockRef re::TimebaseManager::hostClock(re::TimebaseManager *this)
{
  CMClockRef result;

  result = (CMClockRef)*((_QWORD *)this + 31);
  if (!result)
  {
    result = CMClockGetHostTimeClock();
    *((_QWORD *)this + 31) = result;
  }
  return result;
}

void re::TimebaseManager::updatePrimarySharedClock(re::TimebaseManager *this, uint64_t a2, OpaqueCMClock **a3)
{
  const void *v4;
  re *HostTimeClock;
  re *v6;
  int v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v4 = (const void *)*((_QWORD *)this + 33);
  if (v4 || (v4 = (const void *)*((_QWORD *)this + 34)) != 0)
  {
    *((_QWORD *)this + 35) = CFRetain(v4);
  }
  else
  {
    HostTimeClock = (re *)*((_QWORD *)this + 31);
    if (!HostTimeClock)
    {
      HostTimeClock = CMClockGetHostTimeClock();
      *((_QWORD *)this + 31) = HostTimeClock;
    }
    v6 = (re *)re::ManualCMClockCreateWithReference(HostTimeClock, (re::TimebaseManager *)((char *)this + 280), a3);
    if ((_DWORD)v6)
    {
      v7 = (int)v6;
      re::TimebaseLog(v6);
      v8 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v9 = 136315650;
        v10 = "updatePrimarySharedClock";
        v11 = 1024;
        v12 = 280;
        v13 = 1024;
        v14 = v7;
        _os_log_error_impl(&dword_224FE9000, v8, OS_LOG_TYPE_ERROR, "%s:%d error: %d", (uint8_t *)&v9, 0x18u);
      }

    }
  }
}

BOOL re::TimebaseManager::matchesAudioClock(re::TimebaseManager *this, CMClockOrTimebaseRef clockOrTimebase1)
{
  re *AudioClock;
  _BOOL8 v5;
  void *v6;
  const void *v7;

  AudioClock = (re *)*((_QWORD *)this + 32);
  if (!AudioClock)
  {
    AudioClock = re::TimebaseService::CreateAudioClock(this, 0);
    *((_QWORD *)this + 32) = AudioClock;
  }
  if (!CMSyncMightDrift(clockOrTimebase1, AudioClock))
    return 1;
  if (*((_BYTE *)this + 336))
    return 0;
  +[REProxyAudioClockManager sharedInstance](REProxyAudioClockManager, "sharedInstance");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = (const void *)objc_msgSend(v6, "copyAudioClock");

  if (!v7)
    return 0;
  v5 = CMSyncMightDrift(clockOrTimebase1, v7) == 0;
  CFRelease(v7);
  return v5;
}

void std::unique_lock<re::UnfairLock>::unlock(uint64_t a1)
{
  os_unfair_lock_s *v2;

  if (*(_BYTE *)(a1 + 8))
  {
    os_unfair_lock_unlock(*(os_unfair_lock_t *)a1);
    *(_BYTE *)(a1 + 8) = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    re::TimebaseManager::_beforeFrameUpdate(v2);
  }
}

void re::TimebaseManager::_beforeFrameUpdate(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  uint64_t **v3;
  CMTime *v4;
  CFTypeID v5;
  uint64_t v6;
  OpaqueCMClock **v7;
  uint64_t *v8;
  uint64_t *v9;
  const void *v10;
  re *RelativeRateAndAnchorTime;
  int v12;
  NSObject *v13;
  uint64_t *i;
  uint64_t v15;
  NSObject *v16;
  const void *v17;
  re *v18;
  int v19;
  NSObject *v20;
  uint64_t *j;
  uint64_t v22;
  uint64_t v23;
  const void *v24;
  NSObject *v25;
  const void *v26;
  double Seconds;
  double v28;
  __int128 v29;
  uint64_t v30;
  CMTime v31;
  CMTime v32;
  CMTime v33;
  CMTime rhs;
  CMTime lhs;
  CMTime v36;
  CMTime v37;
  CMTime v38;
  CMTime time;
  CMTime v40;
  CMTime outRelativeToClockOrTimebaseAnchorTime;
  Float64 v42;
  Float64 outRelativeRate;
  CMTime outOfClockOrTimebaseAnchorTime;
  CMTime v45;
  CMTime v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  v2 = this + 6;
  os_unfair_lock_lock(this + 6);
  v3 = *(uint64_t ***)&this[22]._os_unfair_lock_opaque;
  if (v3)
  {
    v4 = (CMTime *)MEMORY[0x24BDC0D88];
    do
    {
      v5 = CFGetTypeID(v3[2]);
      if (v5 == CMClockGetTypeID())
      {
        v8 = v3[2];
        v9 = *(uint64_t **)&this[70]._os_unfair_lock_opaque;
        if (!v9)
        {
          re::TimebaseManager::updatePrimarySharedClock((re::TimebaseManager *)this, v6, v7);
          v9 = *(uint64_t **)&this[70]._os_unfair_lock_opaque;
        }
        if (v8 == v9)
        {
          memset(&outOfClockOrTimebaseAnchorTime, 0, sizeof(outOfClockOrTimebaseAnchorTime));
          CMSyncGetTime(&outOfClockOrTimebaseAnchorTime, v3[2]);
          for (i = v3[6]; i; i = (uint64_t *)*i)
          {
            v15 = re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(i[2], (unint64_t)v3[3]);
            if (v15)
            {
              *(CMTime *)(v15 + 40) = outOfClockOrTimebaseAnchorTime;
            }
            else
            {
              re::TimebaseLog(0);
              v16 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
              {
                LOWORD(outRelativeToClockOrTimebaseAnchorTime.value) = 0;
                _os_log_error_impl(&dword_224FE9000, v16, OS_LOG_TYPE_ERROR, "Didn't find expected shared clock in TimebaseTree during beforeFrameUpdate", (uint8_t *)&outRelativeToClockOrTimebaseAnchorTime, 2u);
              }

            }
          }
        }
        else
        {
          v42 = 0.0;
          outRelativeRate = 0.0;
          v10 = *(const void **)&this[66]._os_unfair_lock_opaque;
          if (v10)
          {
            RelativeRateAndAnchorTime = (re *)CMSyncGetRelativeRateAndAnchorTime(v3[2], v10, &outRelativeRate, &outOfClockOrTimebaseAnchorTime, &outRelativeToClockOrTimebaseAnchorTime);
            if ((_DWORD)RelativeRateAndAnchorTime)
            {
              v12 = (int)RelativeRateAndAnchorTime;
              re::TimebaseLog(RelativeRateAndAnchorTime);
              v13 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              {
                LODWORD(v46.value) = 136315650;
                *(CMTimeValue *)((char *)&v46.value + 4) = (CMTimeValue)"_beforeFrameUpdate";
                LOWORD(v46.flags) = 1024;
                *(CMTimeFlags *)((char *)&v46.flags + 2) = 467;
                WORD1(v46.epoch) = 1024;
                HIDWORD(v46.epoch) = v12;
                _os_log_error_impl(&dword_224FE9000, v13, OS_LOG_TYPE_ERROR, "%s:%d error: %d", (uint8_t *)&v46, 0x18u);
              }

            }
          }
          else
          {
            outRelativeRate = 1.0;
            outOfClockOrTimebaseAnchorTime = *v4;
            outRelativeToClockOrTimebaseAnchorTime = outOfClockOrTimebaseAnchorTime;
          }
          v17 = *(const void **)&this[68]._os_unfair_lock_opaque;
          if (v17)
          {
            v18 = (re *)CMSyncGetRelativeRateAndAnchorTime(v3[2], v17, &v42, &v46, &v40);
            if ((_DWORD)v18)
            {
              v19 = (int)v18;
              re::TimebaseLog(v18);
              v20 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
              {
                LODWORD(v45.value) = 136315650;
                *(CMTimeValue *)((char *)&v45.value + 4) = (CMTimeValue)"_beforeFrameUpdate";
                LOWORD(v45.flags) = 1024;
                *(CMTimeFlags *)((char *)&v45.flags + 2) = 477;
                WORD1(v45.epoch) = 1024;
                HIDWORD(v45.epoch) = v19;
                _os_log_error_impl(&dword_224FE9000, v20, OS_LOG_TYPE_ERROR, "%s:%d error: %d", (uint8_t *)&v45, 0x18u);
              }

            }
          }
          else
          {
            v42 = 1.0;
            v46 = *v4;
            v40 = v46;
          }
          for (j = v3[6]; j; j = (uint64_t *)*j)
          {
            v22 = re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(j[2], (unint64_t)v3[3]);
            if (v22)
            {
              v23 = v22;
              *(CFAbsoluteTime *)(j[2] + 104) = CFAbsoluteTimeGetCurrent();
              v24 = *(const void **)&this[68]._os_unfair_lock_opaque;
              if (v24)
              {
                time = *(CMTime *)(v23 + 96);
                CMSyncConvertTime(&v45, &time, v3[2], v24);
              }
              else
              {
                v45 = *v4;
              }
              v26 = *(const void **)&this[66]._os_unfair_lock_opaque;
              if (v26)
              {
                v37 = *(CMTime *)(v23 + 40);
                CMSyncConvertTime(&v38, &v37, v3[2], v26);
              }
              else
              {
                v38 = *v4;
              }
              lhs = v45;
              rhs = *(CMTime *)(v23 + 120);
              CMTimeSubtract(&v36, &lhs, &rhs);
              Seconds = CMTimeGetSeconds(&v36);
              v32 = v38;
              v31 = *(CMTime *)(v23 + 64);
              CMTimeSubtract(&v33, &v32, &v31);
              v28 = CMTimeGetSeconds(&v33);
              if (qword_2541235D0 != -1)
                dispatch_once(&qword_2541235D0, &__block_literal_global_40_0);
              if (fabs(Seconds) > *(double *)&qword_2541235C8 || fabs(v28) > *(double *)&qword_2541235C8)
              {
                *(Float64 *)(v23 + 32) = outRelativeRate;
                *(CMTime *)(v23 + 40) = outOfClockOrTimebaseAnchorTime;
                *(CMTime *)(v23 + 64) = outRelativeToClockOrTimebaseAnchorTime;
                *(Float64 *)(v23 + 88) = v42;
                *(CMTime *)(v23 + 96) = v46;
                v29 = *(_OWORD *)&v40.value;
                *(_QWORD *)(v23 + 136) = v40.epoch;
                *(_OWORD *)(v23 + 120) = v29;
                v30 = re::HashTable<re::ecs2::Entity const*,re::SharedPtr<re::ecs2::CAMeshCodirectionalGroup>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::tryGet((uint64_t)&this[72], j[2]);
                if (v30)
                  (*(void (**)(void))(*(_QWORD *)v30 + 16))();
              }
            }
            else
            {
              re::TimebaseLog(0);
              v25 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              {
                LOWORD(v45.value) = 0;
                _os_log_error_impl(&dword_224FE9000, v25, OS_LOG_TYPE_ERROR, "Didn't find expected clock in TimebaseTree during beforeFrameUpdate", (uint8_t *)&v45, 2u);
              }

            }
          }
        }
      }
      v3 = (uint64_t **)*v3;
    }
    while (v3);
  }
  os_unfair_lock_unlock(v2);
}

void re::TimebaseManager::_afterFrameUpdate(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  OpaqueCMClock **v3;
  OpaqueCMClock **v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  OpaqueCMClock **v8;
  OpaqueCMClock *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  re *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  int v18;
  CFTypeRef v19;
  uint64_t v20;
  int *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  OpaqueCMTimebase *value;
  OpaqueCMTimebase *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  int v33;
  BOOL v34;
  BOOL v35;
  re *v36;
  int v37;
  NSObject *v38;
  NSObject *v39;
  unint64_t v40;
  OpaqueCMTimebase *ClockOrTimebaseForID;
  int v42;
  NSObject *v43;
  CMClockOrTimebaseRef v44;
  const void *v45;
  re *v46;
  int v47;
  NSObject *v48;
  unsigned __int8 v49;
  unsigned __int8 v50;
  re *v51;
  uint64_t *v52;
  int v53;
  double Current;
  unsigned __int8 *v55;
  uint64_t i;
  uint64_t *v57;
  int v58;
  CMTimeScale *p_timescale;
  CMTimeScale **v60;
  CMTimeScale *v61;
  CMTimeScale **v62;
  double v63;
  CMTimeScale **v64;
  CMTimeScale **v65;
  re *AudioClock;
  re *v67;
  NSObject *v68;
  CMTimeValue v69;
  Float64 Seconds;
  Float64 v71;
  CFTypeID v72;
  OpaqueCMTimebase *v73;
  CFTypeID v74;
  re *v75;
  int v76;
  NSObject *v77;
  NSObject *v78;
  re *v79;
  int v80;
  double v81;
  CMTime *v82;
  _QWORD *v83;
  _QWORD *v84;
  __int128 *v85;
  __int128 v86;
  re *v87;
  int v88;
  NSObject *v89;
  __int128 v90;
  re *v91;
  int v92;
  NSObject *v93;
  re *v94;
  int v95;
  NSObject *v96;
  CMTime *v97;
  NSObject *v98;
  re *v99;
  int v100;
  uint64_t v101;
  re *v102;
  int v103;
  NSObject *v104;
  NSObject *v105;
  int v106;
  int v107;
  NSObject *v108;
  const char *v109;
  CMTimeValue v110;
  uint32_t v111;
  uint64_t v112;
  _QWORD *v113;
  _QWORD *v114;
  CFTypeID v115;
  OpaqueCMTimebase *v116;
  re *v117;
  OSStatus v118;
  NSObject *v119;
  int v120;
  int v121;
  uint64_t **j;
  _QWORD *v123;
  _QWORD *v124;
  uint64_t v125;
  uint64_t k;
  _QWORD *v127;
  _QWORD *v128;
  int8x8_t v129;
  unint64_t v130;
  uint8x8_t v131;
  uint64_t v132;
  _QWORD *v133;
  _QWORD *v134;
  unint64_t v135;
  uint64_t v136;
  unint64_t v137;
  unint64_t v138;
  os_unfair_lock_s *v139;
  char v140;
  os_unfair_lock_s *v141;
  OpaqueCMClock *v142;
  uint64_t v143;
  uint64_t v144;
  re::TimebaseManager *v145;
  uint64_t v146;
  os_unfair_lock_s *v147;
  const __CFAllocator *allocator;
  uint64_t *v149;
  os_unfair_lock_s *v150;
  CMTime v151;
  CMTime v152;
  CMTime v153;
  CMTime v154;
  CMTime v155;
  CMTime v156;
  CMTime v157;
  CMTime v158;
  CMTime v159;
  CMTime v160;
  CMTime v161;
  CMTime time2;
  CMTime time1;
  CMTime v164;
  CMTime v165;
  CMTime __p;
  CMTime immediateSourceTime;
  CMTime timebaseTime;
  CMTime rhs;
  CMTime lhs;
  CMTime v171;
  CMTime time;
  unint64_t v173;
  unint64_t v174;
  _OWORD v175[2];
  int v176;
  _BYTE v177[12];
  __int16 v178;
  int v179;
  __int16 v180;
  int v181;
  CMTime timebaseOut;
  OpaqueCMTimebase *v183;
  __int16 v184;
  uint64_t v185;
  __int16 v186;
  const void *v187;
  __int16 v188;
  Float64 v189;
  __int16 v190;
  Float64 v191;
  CMTime buf[4];
  CMTime v193;
  uint64_t v194;

  v194 = *MEMORY[0x24BDAC8D0];
  v2 = this + 6;
  os_unfair_lock_lock(this + 6);
  v145 = (re::TimebaseManager *)this;
  if (*(_QWORD *)&this[54]._os_unfair_lock_opaque)
  {
    memset(v175, 0, sizeof(v175));
    v176 = 1065353216;
    v5 = *(uint64_t **)&this[52]._os_unfair_lock_opaque;
    v139 = v2;
    if (v5)
    {
      v140 = 0;
      v141 = this + 66;
      v147 = this + 68;
      v150 = this + 38;
      allocator = (const __CFAllocator *)*MEMORY[0x24BDBD240];
      while (1)
      {
        if (!*(_QWORD *)&v141->_os_unfair_lock_opaque
          || (v6 = *((_QWORD *)v145 + 30)) == 0
          || (v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 56))(v6),
              v8 = (OpaqueCMClock **)v141,
              v7 != *(_QWORD *)(v5[2] + 112)))
        {
          v8 = (OpaqueCMClock **)v147;
        }
        v9 = *v8;
        if (!*v8)
        {
          v9 = (OpaqueCMClock *)*((_QWORD *)v145 + 35);
          if (!v9)
          {
            re::TimebaseManager::updatePrimarySharedClock(v145, (uint64_t)v3, v4);
            v9 = (OpaqueCMClock *)*((_QWORD *)v145 + 35);
          }
        }
        v10 = v5[2];
        if (*(_BYTE *)(v10 + 120) == 2)
        {
          v11 = re::TimebaseTree::rootID((re::TimebaseTree *)v5[2]);
          v12 = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>(v150, v11);
          if (v9)
          {
            if (v11)
            {
              if (v12)
              {
                v13 = (re *)v12[3];
                if (v13 != v9)
                {
                  v14 = v5[2];
                  timebaseOut.value = v11;
                  v15 = *(unsigned int *)(v14 + 32);
                  if ((_DWORD)v15)
                  {
                    v16 = 0;
                    v17 = (int *)(*(_QWORD *)(v14 + 16) + 8);
                    while (1)
                    {
                      v18 = *v17;
                      v17 += 50;
                      if (v18 < 0)
                        break;
                      if (v15 == ++v16)
                      {
                        LODWORD(v16) = *(_DWORD *)(v14 + 32);
                        break;
                      }
                    }
                  }
                  else
                  {
                    LODWORD(v16) = 0;
                  }
                  if ((_DWORD)v15 != (_DWORD)v16)
                  {
                    v112 = v16;
                    do
                    {
                      v113 = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>(v150, *(_QWORD *)(*(_QWORD *)(v14 + 16) + 200 * v112 + 16));
                      if (v113)
                      {
                        v114 = v113;
                        v115 = CFGetTypeID((CFTypeRef)v113[3]);
                        if (v115 == CMTimebaseGetTypeID())
                        {
                          v116 = (OpaqueCMTimebase *)v114[3];
                          v117 = (re *)CMTimebaseCopySource(v116);
                          if (v117 == v13)
                          {
                            v118 = CMTimebaseSetSourceClock(v116, v9);
                            v117 = v13;
                            if (v118)
                            {
                              re::TimebaseLog(v13);
                              v119 = objc_claimAutoreleasedReturnValue();
                              if (os_log_type_enabled(v119, OS_LOG_TYPE_ERROR))
                              {
                                LODWORD(buf[0].value) = 136315650;
                                *(CMTimeValue *)((char *)&buf[0].value + 4) = (CMTimeValue)"changeSharedClock";
                                LOWORD(buf[0].flags) = 1024;
                                *(CMTimeFlags *)((char *)&buf[0].flags + 2) = 881;
                                WORD1(buf[0].epoch) = 1024;
                                HIDWORD(buf[0].epoch) = v118;
                                _os_log_error_impl(&dword_224FE9000, v119, OS_LOG_TYPE_ERROR, "%s:%d error: %d", (uint8_t *)buf, 0x18u);
                              }

                              v117 = v13;
                            }
                          }
                          CFRelease(v117);
                        }
                      }
                      if (*(_DWORD *)(v14 + 32) <= (v16 + 1))
                        v120 = v16 + 1;
                      else
                        v120 = *(_DWORD *)(v14 + 32);
                      while (1)
                      {
                        v112 = (v16 + 1);
                        if (v120 - 1 == (_DWORD)v16)
                          break;
                        LODWORD(v16) = v16 + 1;
                        v121 = v112;
                        if ((*(_DWORD *)(*(_QWORD *)(v14 + 16) + 200 * v112 + 8) & 0x80000000) != 0)
                          goto LABEL_203;
                      }
                      v121 = v120;
LABEL_203:
                      LODWORD(v16) = v121;
                    }
                    while ((_DWORD)v15 != v121);
                  }
                  v19 = CFRetain(v9);
                  *((_QWORD *)std::__hash_table<std::__hash_value_type<unsigned long long,re::TimebaseManager::ExternallyControlledTimebase>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::TimebaseManager::ExternallyControlledTimebase>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::TimebaseManager::ExternallyControlledTimebase>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::TimebaseManager::ExternallyControlledTimebase>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)v150, v11, &timebaseOut)+ 3) = v19;
                  CFRelease(v13);
                  v140 = 1;
                }
              }
            }
          }
          v10 = v5[2];
        }
        v146 = *(unsigned int *)(v10 + 32);
        v20 = 0;
        if ((_DWORD)v146)
        {
          v21 = (int *)(*(_QWORD *)(v10 + 16) + 8);
          while (1)
          {
            v22 = *v21;
            v21 += 50;
            if (v22 < 0)
              break;
            if (v146 == ++v20)
            {
              LODWORD(v20) = *(_DWORD *)(v10 + 32);
              break;
            }
          }
        }
        if ((_DWORD)v146 != (_DWORD)v20)
          break;
LABEL_31:
        v5 = (uint64_t *)*v5;
        if (!v5)
          goto LABEL_215;
      }
      v23 = v20;
      v149 = v5;
      v142 = v9;
      while (1)
      {
        v24 = *(_QWORD *)(v10 + 16) + 200 * v23;
        v174 = 0;
        v25 = *(_QWORD *)(v24 + 16);
        v173 = v25;
        if (v25)
          break;
LABEL_171:
        if (*(_DWORD *)(v10 + 32) <= (v20 + 1))
          v106 = v20 + 1;
        else
          v106 = *(_DWORD *)(v10 + 32);
        while (1)
        {
          v23 = (v20 + 1);
          if (v106 - 1 == (_DWORD)v20)
            break;
          LODWORD(v20) = v20 + 1;
          v107 = v23;
          if ((*(_DWORD *)(*(_QWORD *)(v10 + 16) + 200 * v23 + 8) & 0x80000000) != 0)
            goto LABEL_178;
        }
        v107 = v106;
LABEL_178:
        LODWORD(v20) = v107;
        if ((_DWORD)v146 == v107)
          goto LABEL_31;
      }
      v26 = 0;
      value = 0;
      while (1)
      {
        v28 = value;
        v29 = v26;
        if (std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(v175, &v174))
        {
          goto LABEL_171;
        }
        v30 = v5[2];
        v31 = re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v30, v25);
        if (!v31)
        {
          re::TimebaseLog(0);
          v105 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
            goto LABEL_170;
          LOWORD(buf[0].value) = 0;
          v108 = v105;
          v109 = "Failed to find expected ID";
LABEL_185:
          v111 = 2;
LABEL_186:
          _os_log_error_impl(&dword_224FE9000, v108, OS_LOG_TYPE_ERROR, v109, (uint8_t *)buf, v111);
          goto LABEL_170;
        }
        v26 = v31;
        v32 = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>(v150, v25);
        if (!v32)
          break;
        value = (OpaqueCMTimebase *)*((_QWORD *)v32 + 3);
LABEL_65:
        *((_BYTE *)v32 + 56) = 1;
        if (!*(_QWORD *)(v26 + 24) && *(_QWORD *)(v5[2] + 48))
        {
          v44 = CMTimebaseCopySource(value);
          if (!v44)
          {
            re::TimebaseLog(0);
            v105 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf[0].value) = 0;
              v108 = v105;
              v109 = "root timebase with external source does not have valid source";
              goto LABEL_185;
            }
LABEL_170:

            goto LABEL_171;
          }
          v45 = v44;
          memset(&v193, 0, sizeof(v193));
          time = *(CMTime *)(v5[2] + 80);
          CMSyncConvertTime(&v193, &time, value, v44);
          if ((v193.flags & 1) != 0)
          {
            lhs = v193;
            rhs = *(CMTime *)(v5[2] + 56);
            CMTimeSubtract(&v171, &lhs, &rhs);
            if (fabs(CMTimeGetSeconds(&v171)) <= 0.001)
              goto LABEL_108;
          }
          timebaseTime = *(CMTime *)(v5[2] + 80);
          immediateSourceTime = *(CMTime *)(v5[2] + 56);
          v46 = (re *)CMTimebaseSetRateAndAnchorTime(value, 1.0, &timebaseTime, &immediateSourceTime);
          if ((_DWORD)v46)
          {
            v47 = (int)v46;
            re::TimebaseLog(v46);
            v48 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf[0].value) = 136315650;
              *(CMTimeValue *)((char *)&buf[0].value + 4) = (CMTimeValue)"_afterFrameUpdate";
              LOWORD(buf[0].flags) = 1024;
              *(CMTimeFlags *)((char *)&buf[0].flags + 2) = 699;
              WORD1(buf[0].epoch) = 1024;
              HIDWORD(buf[0].epoch) = v47;
              _os_log_error_impl(&dword_224FE9000, v48, OS_LOG_TYPE_ERROR, "%s:%d error: %d", (uint8_t *)buf, 0x18u);
            }

            v5 = v149;
          }
          snprintf((char *)buf, 0x64uLL, "re-anchoring tree %p with root ID %llu", (const void *)v5[2], *(_QWORD *)(v26 + 8));
          std::string::basic_string[abi:nn180100]<0>(&__p, (char *)buf);
          v49 = atomic_load((unsigned __int8 *)&qword_2541235D8);
          if ((v49 & 1) == 0 && __cxa_guard_acquire(&qword_2541235D8))
          {
            xmmword_254123638 = 0u;
            *(_OWORD *)&qword_254123648 = 0u;
            dword_254123658 = 1065353216;
            __cxa_guard_release(&qword_2541235D8);
          }
          v50 = atomic_load((unsigned __int8 *)&qword_2541235E0);
          if ((v50 & 1) == 0 && __cxa_guard_acquire(&qword_2541235E0))
          {
            dword_25412355C = 0;
            __cxa_guard_release(&qword_2541235E0);
          }
          os_unfair_lock_lock((os_unfair_lock_t)&dword_25412355C);
          v52 = re::foundationTimingLogObjects(v51);
          v53 = 0;
          if (os_log_type_enabled((os_log_t)*v52, OS_LOG_TYPE_DEFAULT))
          {
            Current = CFAbsoluteTimeGetCurrent();
            v55 = std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::find<std::string>(&xmmword_254123638, (unsigned __int8 *)&__p);
            if (v55 && Current - *((double *)v55 + 5) < 2.0)
            {
              v53 = 0;
            }
            else
            {
              timebaseOut.value = (CMTimeValue)&__p;
              *((double *)std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&xmmword_254123638, (unsigned __int8 *)&__p, (uint64_t)&std::piecewise_construct, (__int128 **)&timebaseOut)+ 5) = Current;
              if (qword_254123650 == 100)
              {
                *(_QWORD *)&timebaseOut.timescale = 0;
                timebaseOut.epoch = 0;
                timebaseOut.value = (CMTimeValue)&timebaseOut.timescale;
                for (i = qword_254123648; i; i = *(_QWORD *)i)
                {
                  *(_QWORD *)v177 = i + 40;
                  v57 = std::__tree<std::__value_type<double,std::string>,std::__map_value_compare<double,std::__value_type<double,std::string>,std::less<double>,true>,std::allocator<std::__value_type<double,std::string>>>::__emplace_unique_key_args<double,std::piecewise_construct_t const&,std::tuple<double const&>,std::tuple<>>((uint64_t **)&timebaseOut, (double *)(i + 40), (uint64_t)&std::piecewise_construct, (uint64_t **)v177);
                  std::string::operator=((std::string *)(v57 + 5), (const std::string *)(i + 16));
                }
                std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::clear((uint64_t)&xmmword_254123638);
                v9 = v142;
                if (&timebaseOut.timescale != (CMTimeScale *)timebaseOut.value)
                {
                  v58 = 10;
                  p_timescale = &timebaseOut.timescale;
                  do
                  {
                    v60 = *(CMTimeScale ***)p_timescale;
                    v61 = p_timescale;
                    if (*(_QWORD *)p_timescale)
                    {
                      do
                      {
                        v62 = v60;
                        v60 = (CMTimeScale **)v60[1];
                      }
                      while (v60);
                    }
                    else
                    {
                      do
                      {
                        v62 = (CMTimeScale **)*((_QWORD *)v61 + 2);
                        v34 = *v62 == v61;
                        v61 = (CMTimeScale *)v62;
                      }
                      while (v34);
                    }
                    v63 = *((double *)v62 + 4);
                    if (Current - v63 >= 2.0)
                      break;
                    *(_QWORD *)v177 = v62 + 5;
                    *((double *)std::__hash_table<std::__hash_value_type<std::string,double>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,double>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,double>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,double>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&xmmword_254123638, (unsigned __int8 *)v62 + 40, (uint64_t)&std::piecewise_construct, (__int128 **)v177)+ 5) = v63;
                    v64 = *(CMTimeScale ***)p_timescale;
                    if (*(_QWORD *)p_timescale)
                    {
                      do
                      {
                        v65 = v64;
                        v64 = (CMTimeScale **)v64[1];
                      }
                      while (v64);
                    }
                    else
                    {
                      do
                      {
                        v65 = (CMTimeScale **)*((_QWORD *)p_timescale + 2);
                        v34 = *v65 == p_timescale;
                        p_timescale = (CMTimeScale *)v65;
                      }
                      while (v34);
                    }
                    if (!--v58)
                      break;
                    p_timescale = (CMTimeScale *)v65;
                  }
                  while (v65 != (CMTimeScale **)timebaseOut.value);
                }
                std::__tree<std::__value_type<double,std::string>,std::__map_value_compare<double,std::__value_type<double,std::string>,std::less<double>,true>,std::allocator<std::__value_type<double,std::string>>>::destroy((uint64_t)&timebaseOut, *(char **)&timebaseOut.timescale);
                v53 = 1;
                v5 = v149;
              }
              else
              {
                v53 = 1;
              }
            }
          }
          os_unfair_lock_unlock((os_unfair_lock_t)&dword_25412355C);
          if (SHIBYTE(__p.epoch) < 0)
          {
            operator delete((void *)__p.value);
            if (!v53)
            {
LABEL_108:
              CFRelease(v45);
              goto LABEL_109;
            }
          }
          else if (!v53)
          {
            goto LABEL_108;
          }
          v68 = (id)*re::foundationTimingLogObjects(v67);
          if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
          {
            v69 = v149[2];
            v143 = *(_QWORD *)(v26 + 8);
            v144 = *(_QWORD *)(v69 + 48);
            v165 = *(CMTime *)(v69 + 80);
            Seconds = CMTimeGetSeconds(&v165);
            v164 = *(CMTime *)(v149[2] + 56);
            v71 = CMTimeGetSeconds(&v164);
            LODWORD(timebaseOut.value) = 134219520;
            *(CMTimeValue *)((char *)&timebaseOut.value + 4) = v69;
            LOWORD(timebaseOut.flags) = 2048;
            *(_QWORD *)((char *)&timebaseOut.flags + 2) = v143;
            HIWORD(timebaseOut.epoch) = 2048;
            v183 = value;
            v184 = 2048;
            v185 = v144;
            v186 = 2048;
            v187 = v45;
            v188 = 2048;
            v189 = Seconds;
            v9 = v142;
            v190 = 2048;
            v191 = v71;
            _os_log_impl(&dword_224FE9000, v68, OS_LOG_TYPE_DEFAULT, "re-anchoring tree %p with root ID %llu (timebase %p) to source %llu (timebase %p) ownTime=%0.2f, sourceTime=%0.2f", (uint8_t *)&timebaseOut, 0x48u);
          }

          v5 = v149;
          goto LABEL_108;
        }
LABEL_109:
        if (!v28)
          goto LABEL_147;
        v72 = CFGetTypeID(v28);
        if (v72 != CMTimebaseGetTypeID())
          goto LABEL_147;
        v73 = (OpaqueCMTimebase *)CMTimebaseCopySource(v28);
        CFRelease(v73);
        if (v73 != value)
        {
          v74 = CFGetTypeID(value);
          if (v74 == CMTimebaseGetTypeID())
          {
            v75 = (re *)CMTimebaseSetSourceTimebase(v28, value);
            if ((_DWORD)v75)
            {
              v76 = (int)v75;
              re::TimebaseLog(v75);
              v77 = objc_claimAutoreleasedReturnValue();
              if (!os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
              {
LABEL_118:

                goto LABEL_119;
              }
              LODWORD(buf[0].value) = 136315650;
              *(CMTimeValue *)((char *)&buf[0].value + 4) = (CMTimeValue)"_afterFrameUpdate";
              LOWORD(buf[0].flags) = 1024;
              *(CMTimeFlags *)((char *)&buf[0].flags + 2) = 728;
              WORD1(buf[0].epoch) = 1024;
              HIDWORD(buf[0].epoch) = v76;
              v78 = v77;
LABEL_162:
              _os_log_error_impl(&dword_224FE9000, v78, OS_LOG_TYPE_ERROR, "%s:%d error: %d", (uint8_t *)buf, 0x18u);
              goto LABEL_118;
            }
          }
          else
          {
            v79 = (re *)CMTimebaseSetSourceClock(v28, value);
            if ((_DWORD)v79)
            {
              v80 = (int)v79;
              re::TimebaseLog(v79);
              v77 = objc_claimAutoreleasedReturnValue();
              if (!os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
                goto LABEL_118;
              LODWORD(buf[0].value) = 136315650;
              *(CMTimeValue *)((char *)&buf[0].value + 4) = (CMTimeValue)"_afterFrameUpdate";
              LOWORD(buf[0].flags) = 1024;
              *(CMTimeFlags *)((char *)&buf[0].flags + 2) = 731;
              WORD1(buf[0].epoch) = 1024;
              HIDWORD(buf[0].epoch) = v80;
              v78 = v77;
              goto LABEL_162;
            }
          }
        }
LABEL_119:
        if (value == *(OpaqueCMTimebase **)&v147->_os_unfair_lock_opaque)
        {
          v81 = *(double *)(v29 + 88);
          buf[0] = *(CMTime *)(v29 + 96);
          v82 = (CMTime *)(v29 + 120);
        }
        else
        {
          v81 = *(double *)(v29 + 32);
          buf[0] = *(CMTime *)(v29 + 40);
          v82 = (CMTime *)(v29 + 64);
        }
        timebaseOut = *v82;
        v83 = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>(v150, *(_QWORD *)(v29 + 8));
        v84 = v83;
        if (!*(_BYTE *)(v29 + 144) || !*(_DWORD *)v26)
        {
          if (v81 == 0.0)
          {
            if (CMTimebaseGetRate(v28) != 0.0)
            {
              v91 = (re *)CMTimebaseSetRate(v28, 0.0);
              if ((_DWORD)v91)
              {
                v92 = (int)v91;
                re::TimebaseLog(v91);
                v93 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
                {
                  LODWORD(v193.value) = 136315650;
                  *(CMTimeValue *)((char *)&v193.value + 4) = (CMTimeValue)"_afterFrameUpdate";
                  LOWORD(v193.flags) = 1024;
                  *(CMTimeFlags *)((char *)&v193.flags + 2) = 784;
                  WORD1(v193.epoch) = 1024;
                  HIDWORD(v193.epoch) = v92;
                  _os_log_error_impl(&dword_224FE9000, v93, OS_LOG_TYPE_ERROR, "%s:%d error: %d", (uint8_t *)&v193, 0x18u);
                }

                v5 = v149;
              }
            }
            CMTimebaseGetTime(&v159, v28);
            v158 = buf[0];
            if (CMTimeCompare(&v159, &v158))
            {
              v157 = buf[0];
              v94 = (re *)CMTimebaseSetTime(v28, &v157);
              if ((_DWORD)v94)
              {
                v95 = (int)v94;
                re::TimebaseLog(v94);
                v96 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
                {
                  LODWORD(v193.value) = 136315650;
                  *(CMTimeValue *)((char *)&v193.value + 4) = (CMTimeValue)"_afterFrameUpdate";
                  LOWORD(v193.flags) = 1024;
                  *(CMTimeFlags *)((char *)&v193.flags + 2) = 788;
                  WORD1(v193.epoch) = 1024;
                  HIDWORD(v193.epoch) = v95;
                  v97 = &v193;
                  v98 = v96;
                  goto LABEL_164;
                }
                goto LABEL_144;
              }
            }
          }
          else
          {
            memset(&v193, 0, sizeof(v193));
            v156 = buf[0];
            CMSyncConvertTime(&v193, &v156, v28, value);
            memset(&__p, 0, sizeof(__p));
            v155 = v193;
            v154 = timebaseOut;
            CMTimeSubtract(&__p, &v155, &v154);
            if (CMTimebaseGetRate(v28) != v81 || (v153 = __p, fabs(CMTimeGetSeconds(&v153)) > 0.001))
            {
              v152 = buf[0];
              v151 = timebaseOut;
              v99 = (re *)CMTimebaseSetRateAndAnchorTime(v28, v81, &v152, &v151);
              if ((_DWORD)v99)
              {
                v100 = (int)v99;
                re::TimebaseLog(v99);
                v96 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)v177 = 136315650;
                  *(_QWORD *)&v177[4] = "_afterFrameUpdate";
                  v178 = 1024;
                  v179 = 811;
                  v180 = 1024;
                  v181 = v100;
                  v97 = (CMTime *)v177;
                  v98 = v96;
LABEL_164:
                  _os_log_error_impl(&dword_224FE9000, v98, OS_LOG_TYPE_ERROR, "%s:%d error: %d", (uint8_t *)v97, 0x18u);
                }
LABEL_144:

              }
            }
          }
          if (v84)
          {
            v101 = MEMORY[0x24BDC0D40];
            *((_OWORD *)v84 + 2) = *MEMORY[0x24BDC0D40];
            v84[6] = *(_QWORD *)(v101 + 16);
          }
          goto LABEL_147;
        }
        time1 = *(CMTime *)(v29 + 148);
        time2 = *(CMTime *)(v83 + 4);
        if (CMTimeCompare(&time1, &time2))
        {
          v86 = *(_OWORD *)(v29 + 148);
          v85 = (__int128 *)(v29 + 148);
          *(_OWORD *)&v161.value = v86;
          v161.epoch = *((_QWORD *)v85 + 2);
          CMSyncGetTime(&v160, value);
          v87 = (re *)CMTimebaseSetRateAndAnchorTime(v28, v81, &v161, &v160);
          if ((_DWORD)v87)
          {
            v88 = (int)v87;
            re::TimebaseLog(v87);
            v89 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v193.value) = 136315650;
              *(CMTimeValue *)((char *)&v193.value + 4) = (CMTimeValue)"_afterFrameUpdate";
              LOWORD(v193.flags) = 1024;
              *(CMTimeFlags *)((char *)&v193.flags + 2) = 762;
              WORD1(v193.epoch) = 1024;
              HIDWORD(v193.epoch) = v88;
              _os_log_error_impl(&dword_224FE9000, v89, OS_LOG_TYPE_ERROR, "%s:%d error: %d", (uint8_t *)&v193, 0x18u);
            }

          }
          v90 = *v85;
          v84[6] = *((_QWORD *)v85 + 2);
          *((_OWORD *)v84 + 2) = v90;
        }
        else if (CMTimebaseGetRate(v28) != v81)
        {
          v102 = (re *)CMTimebaseSetRate(v28, v81);
          if ((_DWORD)v102)
          {
            v103 = (int)v102;
            re::TimebaseLog(v102);
            v104 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v193.value) = 136315650;
              *(CMTimeValue *)((char *)&v193.value + 4) = (CMTimeValue)"_afterFrameUpdate";
              LOWORD(v193.flags) = 1024;
              *(CMTimeFlags *)((char *)&v193.flags + 2) = 778;
              WORD1(v193.epoch) = 1024;
              HIDWORD(v193.epoch) = v103;
              _os_log_error_impl(&dword_224FE9000, v104, OS_LOG_TYPE_ERROR, "%s:%d error: %d", (uint8_t *)&v193, 0x18u);
            }

          }
        }
LABEL_147:
        if (v174)
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)v175, &v174, &v174);
        v174 = v173;
        v25 = *(_QWORD *)(v26 + 24);
        v173 = v25;
        if (!v25)
          goto LABEL_171;
      }
      v33 = *(_DWORD *)v26;
      if (*(_DWORD *)v26)
      {
        v34 = v33 != 3 && *(_BYTE *)(v30 + 120) == 2;
        v35 = v34;
        if (v33 != 4 && !v35 && !*(_QWORD *)(v30 + 48))
        {
          if (v33 == 1)
          {
            AudioClock = (re *)*((_QWORD *)v145 + 32);
            if (!AudioClock)
            {
              AudioClock = re::TimebaseService::CreateAudioClock(0, v3);
              *((_QWORD *)v145 + 32) = AudioClock;
            }
          }
          else if (v33 == 3)
          {
            AudioClock = v9;
          }
          else
          {
            AudioClock = (re *)*((_QWORD *)v145 + 31);
            if (!AudioClock)
            {
              AudioClock = CMClockGetHostTimeClock();
              *((_QWORD *)v145 + 31) = AudioClock;
            }
          }
          value = (OpaqueCMTimebase *)CFRetain(AudioClock);
          goto LABEL_64;
        }
      }
      timebaseOut.value = 0;
      if (*(_QWORD *)(v26 + 24) || (v40 = *(_QWORD *)(v30 + 48)) == 0)
      {
        v36 = (re *)CMTimebaseCreateWithSourceClock(allocator, v9, (CMTimebaseRef *)&timebaseOut);
        if (!(_DWORD)v36)
        {
LABEL_61:
          value = (OpaqueCMTimebase *)timebaseOut.value;
          re::TimebaseLog(v36);
          v43 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
          {
            LODWORD(buf[0].value) = 134217984;
            *(CMTimeValue *)((char *)&buf[0].value + 4) = v25;
            _os_log_debug_impl(&dword_224FE9000, v43, OS_LOG_TYPE_DEBUG, "Creating externally controlled timebase with ID %llu", (uint8_t *)buf, 0xCu);
          }

          v5 = v149;
LABEL_64:
          v32 = std::__hash_table<std::__hash_value_type<unsigned long long,re::TimebaseManager::ExternallyControlledTimebase>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::TimebaseManager::ExternallyControlledTimebase>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::TimebaseManager::ExternallyControlledTimebase>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::TimebaseManager::ExternallyControlledTimebase>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)v150, v25, &v173);
          *((_QWORD *)v32 + 3) = value;
          goto LABEL_65;
        }
        v37 = (int)v36;
        re::TimebaseLog(v36);
        v38 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
LABEL_60:

          goto LABEL_61;
        }
        LODWORD(buf[0].value) = 136315650;
        *(CMTimeValue *)((char *)&buf[0].value + 4) = (CMTimeValue)"_afterFrameUpdate";
        LOWORD(buf[0].flags) = 1024;
        *(CMTimeFlags *)((char *)&buf[0].flags + 2) = 647;
        WORD1(buf[0].epoch) = 1024;
        HIDWORD(buf[0].epoch) = v37;
        v39 = v38;
      }
      else
      {
        ClockOrTimebaseForID = (OpaqueCMTimebase *)re::TimebaseManager::findClockOrTimebaseForID(v145, v40);
        if (!ClockOrTimebaseForID)
        {
          re::TimebaseLog(0);
          v105 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
            goto LABEL_170;
          v110 = *(_QWORD *)(v5[2] + 48);
          LODWORD(buf[0].value) = 134217984;
          *(CMTimeValue *)((char *)&buf[0].value + 4) = v110;
          v108 = v105;
          v109 = "Could not find manual timebase with ID %llu";
          v111 = 12;
          goto LABEL_186;
        }
        v36 = (re *)CMTimebaseCreateWithSourceTimebase(allocator, ClockOrTimebaseForID, (CMTimebaseRef *)&timebaseOut);
        if (!(_DWORD)v36)
          goto LABEL_61;
        v42 = (int)v36;
        re::TimebaseLog(v36);
        v38 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          goto LABEL_60;
        LODWORD(buf[0].value) = 136315650;
        *(CMTimeValue *)((char *)&buf[0].value + 4) = (CMTimeValue)"_afterFrameUpdate";
        LOWORD(buf[0].flags) = 1024;
        *(CMTimeFlags *)((char *)&buf[0].flags + 2) = 642;
        WORD1(buf[0].epoch) = 1024;
        HIDWORD(buf[0].epoch) = v42;
        v39 = v38;
      }
      _os_log_error_impl(&dword_224FE9000, v39, OS_LOG_TYPE_ERROR, "%s:%d error: %d", (uint8_t *)buf, 0x18u);
      goto LABEL_60;
    }
    v140 = 0;
LABEL_215:
    v127 = (_QWORD *)*((_QWORD *)v145 + 21);
    if (v127)
    {
      while ((v140 & 1) != 0 || *((_BYTE *)v127 + 56))
      {
        *((_BYTE *)v127 + 56) = 0;
        v128 = (_QWORD *)*v127;
LABEL_219:
        v127 = v128;
        if (!v128)
          goto LABEL_249;
      }
      CFRelease((CFTypeRef)v127[3]);
      v129 = *(int8x8_t *)((char *)v145 + 160);
      v130 = v127[1];
      v131 = (uint8x8_t)vcnt_s8(v129);
      v131.i16[0] = vaddlv_u8(v131);
      if (v131.u32[0] > 1uLL)
      {
        if (v130 >= *(_QWORD *)&v129)
          v130 %= *(_QWORD *)&v129;
      }
      else
      {
        v130 &= *(_QWORD *)&v129 - 1;
      }
      v128 = (_QWORD *)*v127;
      v132 = *((_QWORD *)v145 + 19);
      v133 = *(_QWORD **)(v132 + 8 * v130);
      do
      {
        v134 = v133;
        v133 = (_QWORD *)*v133;
      }
      while (v133 != v127);
      if (v134 == (_QWORD *)((char *)v145 + 168))
        goto LABEL_253;
      v135 = v134[1];
      if (v131.u32[0] > 1uLL)
      {
        if (v135 >= *(_QWORD *)&v129)
          v135 %= *(_QWORD *)&v129;
      }
      else
      {
        v135 &= *(_QWORD *)&v129 - 1;
      }
      v136 = *v127;
      if (v135 != v130)
      {
LABEL_253:
        if (v128)
        {
          v137 = v128[1];
          if (v131.u32[0] > 1uLL)
          {
            v138 = v128[1];
            if (v137 >= *(_QWORD *)&v129)
              v138 = v137 % *(_QWORD *)&v129;
          }
          else
          {
            v138 = v137 & (*(_QWORD *)&v129 - 1);
          }
          v136 = *v127;
          if (v138 == v130)
            goto LABEL_242;
        }
        *(_QWORD *)(v132 + 8 * v130) = 0;
        v136 = *v127;
      }
      if (!v136)
      {
LABEL_248:
        *v134 = v136;
        *v127 = 0;
        --*((_QWORD *)v145 + 22);
        operator delete(v127);
        goto LABEL_219;
      }
      v137 = *(_QWORD *)(v136 + 8);
LABEL_242:
      if (v131.u32[0] > 1uLL)
      {
        if (v137 >= *(_QWORD *)&v129)
          v137 %= *(_QWORD *)&v129;
      }
      else
      {
        v137 &= *(_QWORD *)&v129 - 1;
      }
      if (v137 != v130)
      {
        *(_QWORD *)(*((_QWORD *)v145 + 19) + 8 * v137) = v134;
        v136 = *v127;
      }
      goto LABEL_248;
    }
LABEL_249:
    std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)v175);
    v2 = v139;
  }
  else
  {
    for (j = *(uint64_t ***)&this[42]._os_unfair_lock_opaque; j; j = (uint64_t **)*j)
      CFRelease(j[3]);
    if (*((_QWORD *)v145 + 22))
    {
      v123 = (_QWORD *)*((_QWORD *)v145 + 21);
      if (v123)
      {
        do
        {
          v124 = (_QWORD *)*v123;
          operator delete(v123);
          v123 = v124;
        }
        while (v124);
      }
      *((_QWORD *)v145 + 21) = 0;
      v125 = *((_QWORD *)v145 + 20);
      if (v125)
      {
        for (k = 0; k != v125; ++k)
          *(_QWORD *)(*((_QWORD *)v145 + 19) + 8 * k) = 0;
      }
      *((_QWORD *)v145 + 22) = 0;
    }
  }
  os_unfair_lock_unlock(v2);
}

void re::TimebaseManager::setTreeDidChangeCallback(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t i;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int *v35;
  int v36;
  uint64_t v37;
  void *v38;
  id aBlock;

  aBlock = a3;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  v5 = *(_QWORD *)(a1 + 288);
  if (!aBlock)
  {
    if (v5)
    {
      v12 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
      v13 = (v12 ^ (v12 >> 31)) % *(unsigned int *)(a1 + 312);
      v14 = *(_QWORD *)(a1 + 296);
      v15 = *(unsigned int *)(v14 + 4 * v13);
      if ((_DWORD)v15 != 0x7FFFFFFF)
      {
        v16 = *(_QWORD *)(a1 + 304);
        v17 = v16 + 32 * v15;
        if (*(_QWORD *)(v17 + 16) == a2)
        {
          *(_DWORD *)(v14 + 4 * v13) = *(_DWORD *)(v17 + 8) & 0x7FFFFFFF;
LABEL_33:
          v32 = *(_QWORD *)(a1 + 304);
          v33 = v32 + 32 * v15;
          v36 = *(_DWORD *)(v33 + 8);
          v35 = (int *)(v33 + 8);
          v34 = v36;
          if (v36 < 0)
          {
            *v35 = v34 & 0x7FFFFFFF;

            v32 = *(_QWORD *)(a1 + 304);
            v34 = *(_DWORD *)(v32 + 32 * v15 + 8);
          }
          *(_DWORD *)(v32 + 32 * v15 + 8) = *(_DWORD *)(a1 + 324) | v34 & 0x80000000;
          *(_DWORD *)(a1 + 324) = v15;
          v26 = *(_DWORD *)(a1 + 316) - 1;
          goto LABEL_22;
        }
        while (1)
        {
          v18 = v15;
          v19 = *(_DWORD *)(v16 + 32 * v15 + 8);
          v15 = v19 & 0x7FFFFFFF;
          if ((v19 & 0x7FFFFFFF) == 0x7FFFFFFF)
            break;
          v20 = v16 + 32 * v15;
          if (*(_QWORD *)(v20 + 16) == a2)
          {
            *(_DWORD *)(v16 + 32 * v18 + 8) = *(_DWORD *)(v16 + 32 * v18 + 8) & 0x80000000 | *(_DWORD *)(v20 + 8) & 0x7FFFFFFF;
            goto LABEL_33;
          }
        }
      }
    }
    goto LABEL_38;
  }
  v6 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  v7 = v6 ^ (v6 >> 31);
  if (!v5)
  {
    LODWORD(v9) = 0;
    goto LABEL_16;
  }
  v8 = *(unsigned int *)(*(_QWORD *)(a1 + 296) + 4 * (v7 % *(unsigned int *)(a1 + 312)));
  if ((_DWORD)v8 != 0x7FFFFFFF)
  {
    v27 = *(_QWORD *)(a1 + 304);
    if (*(_QWORD *)(v27 + 32 * v8 + 16) == a2)
    {
LABEL_26:
      v28 = _Block_copy(aBlock);
      if (*(_QWORD *)(a1 + 288))
      {
        v29 = *(_QWORD *)(a1 + 304);
        for (i = *(unsigned int *)(*(_QWORD *)(a1 + 296) + 4 * (v7 % *(unsigned int *)(a1 + 312)));
              ;
              i = *(_DWORD *)(v29 + 32 * i + 8) & 0x7FFFFFFF)
        {
          v31 = 0x7FFFFFFF;
          if ((_DWORD)i == 0x7FFFFFFF)
            break;
          if (*(_QWORD *)(v29 + 32 * i + 16) == a2)
          {
            v31 = i;
            break;
          }
        }
      }
      else
      {
        v29 = *(_QWORD *)(a1 + 304);
        v31 = 0x7FFFFFFF;
      }
      v37 = v29 + 32 * v31;
      v38 = *(void **)(v37 + 24);
      *(_QWORD *)(v37 + 24) = v28;

      goto LABEL_38;
    }
    while (1)
    {
      v8 = *(_DWORD *)(v27 + 32 * v8 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v8 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v27 + 32 * v8 + 16) == a2)
        goto LABEL_26;
    }
  }
  v9 = v7 % *(unsigned int *)(a1 + 312);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 296) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_16:
    v21 = *(unsigned int *)(a1 + 324);
    if ((_DWORD)v21 == 0x7FFFFFFF)
    {
      v21 = *(unsigned int *)(a1 + 320);
      v22 = v21;
      if ((_DWORD)v21 == *(_DWORD *)(a1 + 312))
      {
        re::HashTable<re::TimebaseTree *,void({block_pointer} {__strong})(re::TimebaseTree *),re::Hash<re::TimebaseTree *>,re::EqualTo<re::TimebaseTree *>,true,false>::setCapacity(a1 + 288, 2 * *(_DWORD *)(a1 + 316));
        LODWORD(v9) = v7 % *(unsigned int *)(a1 + 312);
        v22 = *(_DWORD *)(a1 + 320);
      }
      *(_DWORD *)(a1 + 320) = v22 + 1;
      v23 = *(_QWORD *)(a1 + 304);
      v24 = *(_DWORD *)(v23 + 32 * v21 + 8);
    }
    else
    {
      v23 = *(_QWORD *)(a1 + 304);
      v24 = *(_DWORD *)(v23 + 32 * v21 + 8);
      *(_DWORD *)(a1 + 324) = v24 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v23 + 32 * v21 + 8) = v24 | 0x80000000;
    *(_DWORD *)(*(_QWORD *)(a1 + 304) + 32 * v21 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 304) + 32 * v21 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 296) + 4 * v9);
    *(_QWORD *)(*(_QWORD *)(a1 + 304) + 32 * v21) = v7;
    *(_QWORD *)(*(_QWORD *)(a1 + 304) + 32 * v21 + 16) = a2;
    v25 = *(_QWORD *)(a1 + 304) + 32 * v21;
    *(_QWORD *)(v25 + 24) = _Block_copy(aBlock);
    *(_DWORD *)(*(_QWORD *)(a1 + 296) + 4 * v9) = v21;
    v26 = *(_DWORD *)(a1 + 316) + 1;
LABEL_22:
    *(_DWORD *)(a1 + 316) = v26;
    ++*(_DWORD *)(a1 + 328);
    goto LABEL_38;
  }
  v11 = *(_QWORD *)(a1 + 304);
  while (*(_QWORD *)(v11 + 32 * v10 + 16) != a2)
  {
    v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_16;
  }
LABEL_38:
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 24));

}

void re::TimebaseManager::beforeFrameUpdate(re::TimebaseManager *this, float a2)
{
  OpaqueCMTimebase *v4;
  CMTime rhs;
  CMTime lhs;
  CMTime time;
  _BYTE v8[16];

  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v8, 2516, (uint64_t)this);
  if (a2 > 0.0)
  {
    v4 = (OpaqueCMTimebase *)*((_QWORD *)this + 29);
    CMTimebaseGetTime(&lhs, v4);
    CMTimeMake(&rhs, (unint64_t)(a2 * 18000.0 + 0.5), 18000);
    CMTimeAdd(&time, &lhs, &rhs);
    CMTimebaseSetTime(v4, &time);
  }
  re::TimebaseManager::_beforeFrameUpdate((os_unfair_lock_s *)this);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v8);
}

uint64_t re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  v3 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v3 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v5 + 200 * v3 + 16) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 200 * v3 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v3 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v5 + 200 * v3 + 16) == a2)
        return v5 + 200 * v3 + 24;
    }
    return 0;
  }
  return v5 + 200 * v3 + 24;
}

void re::TimebaseManager::afterFrameUpdate(os_unfair_lock_s *this)
{
  _BYTE v2[16];

  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v2, 2518, (uint64_t)this);
  re::TimebaseManager::_afterFrameUpdate(this);
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v2);
}

_QWORD *re::TimebaseManager::findClockOrTimebaseForID(re::TimebaseManager *this, unint64_t a2)
{
  _QWORD *result;

  result = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>((_QWORD *)this + 19, a2);
  if (result)
    return (_QWORD *)result[3];
  result = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>((_QWORD *)this + 14, a2);
  if (result)
    return (_QWORD *)result[3];
  return result;
}

uint64_t re::TimebaseManager::clockOrTimebaseTypeFromRef(re::TimebaseManager *this, CFTypeRef cf)
{
  CFTypeID v4;
  CMClockRef HostTimeClock;
  uint64_t v7;
  OpaqueCMClock **v8;
  const void *v9;
  const void *v10;
  const void *v11;

  v4 = CFGetTypeID(cf);
  if (v4 == CMTimebaseGetTypeID())
    return 0;
  HostTimeClock = (CMClockRef)*((_QWORD *)this + 31);
  if (!HostTimeClock)
  {
    HostTimeClock = CMClockGetHostTimeClock();
    *((_QWORD *)this + 31) = HostTimeClock;
  }
  if (CFEqual(HostTimeClock, cf))
    return 2;
  v9 = (const void *)*((_QWORD *)this + 33);
  if (v9 && !CMSyncMightDrift(v9, cf))
    return 3;
  v10 = (const void *)*((_QWORD *)this + 34);
  if (v10)
  {
    if (!CMSyncMightDrift(v10, cf))
      return 3;
  }
  v11 = (const void *)*((_QWORD *)this + 35);
  if (!v11)
  {
    re::TimebaseManager::updatePrimarySharedClock(this, v7, v8);
    v11 = (const void *)*((_QWORD *)this + 35);
  }
  if (!CMSyncMightDrift(v11, cf))
    return 3;
  if (re::TimebaseManager::matchesAudioClock(this, cf))
    return 1;
  return 4;
}

unint64_t re::TimebaseManager::addLocallyControlledTimebaseToTree(os_unfair_lock_s *this, OpaqueCMTimebase *a2, re::TimebaseTree *a3, int a4)
{
  unint64_t RelativeRateAndAnchorTime;
  CMClockOrTimebaseRef v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint8x8_t v18;
  void **v19;
  char *v20;
  unint64_t v21;
  float v22;
  float v23;
  _BOOL8 v24;
  unint64_t v25;
  unint64_t v26;
  size_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t i;
  _QWORD *v35;
  _QWORD *v36;
  _OWORD *v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  _QWORD *v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  __CFNotificationCenter *LocalCenter;
  __CFNotificationCenter *v48;
  __CFNotificationCenter *v49;
  uint64_t v50;
  OpaqueCMClock **v51;
  int v52;
  _QWORD *v53;
  re *v54;
  NSObject *v55;
  CMClockOrTimebaseRef v56;
  re *v57;
  int v58;
  NSObject *v59;
  int v60;
  re *v61;
  NSObject *v62;
  re::TimebaseTree *v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  re::TimebaseTree *v70;
  uint64_t v71;
  unsigned __int8 *v72;
  unsigned __int8 *v73;
  NSObject *v74;
  os_unfair_lock_s *lock;
  const __CFString *v77;
  const __CFString *v78;
  const __CFString *name;
  os_unfair_lock_s *v80;
  os_unfair_lock_s *v82;
  unint64_t v83;
  OpaqueCMTimebase *cf2;
  char v85;
  os_unfair_lock_s *v86;
  CMTime v87;
  CMTime v88;
  CMTime v89;
  Float64 v90;
  CMTime outRelativeToClockOrTimebaseAnchorTime;
  Float64 outRelativeRate;
  unint64_t v93;
  re::TimebaseTree *v94;
  CMTime outOfClockOrTimebaseAnchorTime;
  CMTime v96;
  __int128 v97;
  CMTime v98;
  CMTime v99;
  Float64 v100;
  CMTime v101;
  CMTime v102;
  char v103;
  CMTime v104;
  uint64_t v105;

  v105 = *MEMORY[0x24BDAC8D0];
  v94 = a3;
  lock = this + 6;
  os_unfair_lock_lock(this + 6);
  if (a2)
  {
    v7 = 0;
    v85 = 0;
    v8 = 0;
    v86 = this + 18;
    v83 = 0;
    v82 = this + 8;
    v78 = (const __CFString *)*MEMORY[0x24BDC0DA0];
    name = (const __CFString *)*MEMORY[0x24BDC0DB0];
    v77 = (const __CFString *)*MEMORY[0x24BDC0DA8];
    v80 = this + 22;
    cf2 = a2;
    v9 = (unint64_t)a2;
    while (1)
    {
      v93 = 0;
      v10 = std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::find<void const*>(v86, v9);
      if (v10)
      {
        v11 = v10;
        v12 = v10[3];
        v93 = v12;
        RelativeRateAndAnchorTime = std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::find<void const*>(v10 + 4, (unint64_t)v94) != 0;
        if (!v8)
          goto LABEL_71;
        goto LABEL_56;
      }
      v13 = arc4random();
      v93 = arc4random() | (unint64_t)(v13 << 32);
      *(_OWORD *)&v96.timescale = 0u;
      v97 = 0u;
      LODWORD(v98.value) = 1065353216;
      v96.value = v93;
      std::__hash_table<std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::__unordered_map_hasher<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::hash<re::TimebaseTree *>,std::equal_to<re::TimebaseTree *>,true>,std::__unordered_map_equal<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::equal_to<re::TimebaseTree *>,std::hash<re::TimebaseTree *>,true>,std::allocator<std::__hash_value_type<re::TimebaseTree *,unsigned long long>>>::__emplace_unique_key_args<re::TimebaseTree *,std::piecewise_construct_t const&,std::tuple<re::TimebaseTree * const&>,std::tuple<>>((uint64_t)&v96.timescale, (unint64_t)v94, &v94)[3] = 1;
      CFRetain((CFTypeRef)v9);
      v14 = 0x9DDFEA08EB382D69 * (((8 * v9) + 8) ^ HIDWORD(v9));
      v15 = 0x9DDFEA08EB382D69 * (HIDWORD(v9) ^ (v14 >> 47) ^ v14);
      v16 = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
      v17 = *(_QWORD *)&this[20]._os_unfair_lock_opaque;
      if (v17)
      {
        v18 = (uint8x8_t)vcnt_s8((int8x8_t)v17);
        v18.i16[0] = vaddlv_u8(v18);
        if (v18.u32[0] > 1uLL)
        {
          RelativeRateAndAnchorTime = 0x9DDFEA08EB382D69 * (v15 ^ (v15 >> 47));
          if (v16 >= v17)
            RelativeRateAndAnchorTime = v16 % v17;
        }
        else
        {
          RelativeRateAndAnchorTime = (v17 - 1) & v16;
        }
        v19 = *(void ***)(*(_QWORD *)&v86->_os_unfair_lock_opaque + 8 * RelativeRateAndAnchorTime);
        if (v19)
        {
          v20 = (char *)*v19;
          if (*v19)
          {
            do
            {
              v21 = *((_QWORD *)v20 + 1);
              if (v21 == v16)
              {
                if (*((_QWORD *)v20 + 2) == v9)
                  goto LABEL_44;
              }
              else
              {
                if (v18.u32[0] > 1uLL)
                {
                  if (v21 >= v17)
                    v21 %= v17;
                }
                else
                {
                  v21 &= v17 - 1;
                }
                if (v21 != RelativeRateAndAnchorTime)
                  break;
              }
              v20 = *(char **)v20;
            }
            while (v20);
          }
        }
      }
      v20 = (char *)operator new(0x48uLL);
      *(_QWORD *)&outOfClockOrTimebaseAnchorTime.timescale = this + 22;
      *(_QWORD *)v20 = 0;
      *((_QWORD *)v20 + 1) = v16;
      *((_QWORD *)v20 + 2) = v9;
      *(_OWORD *)(v20 + 56) = 0u;
      *(_OWORD *)(v20 + 24) = 0u;
      *(_OWORD *)(v20 + 40) = 0u;
      *((_DWORD *)v20 + 16) = 1065353216;
      LOBYTE(outOfClockOrTimebaseAnchorTime.epoch) = 1;
      v22 = (float)(unint64_t)(*(_QWORD *)&this[24]._os_unfair_lock_opaque + 1);
      v23 = *(float *)&this[26]._os_unfair_lock_opaque;
      if (!v17 || (float)(v23 * (float)v17) < v22)
      {
        v24 = (v17 & (v17 - 1)) != 0;
        if (v17 < 3)
          v24 = 1;
        v25 = v24 | (2 * v17);
        v26 = vcvtps_u32_f32(v22 / v23);
        if (v25 <= v26)
          v27 = v26;
        else
          v27 = v25;
        std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>((uint64_t)v86, v27);
        v17 = *(_QWORD *)&this[20]._os_unfair_lock_opaque;
        if ((v17 & (v17 - 1)) != 0)
        {
          if (v16 >= v17)
            RelativeRateAndAnchorTime = v16 % v17;
          else
            RelativeRateAndAnchorTime = v16;
        }
        else
        {
          RelativeRateAndAnchorTime = (v17 - 1) & v16;
        }
      }
      v28 = *(_QWORD *)&v86->_os_unfair_lock_opaque;
      v29 = *(_QWORD **)(*(_QWORD *)&v86->_os_unfair_lock_opaque + 8 * RelativeRateAndAnchorTime);
      if (v29)
        break;
      *(_QWORD *)v20 = *(_QWORD *)&v80->_os_unfair_lock_opaque;
      *(_QWORD *)&v80->_os_unfair_lock_opaque = v20;
      *(_QWORD *)(v28 + 8 * RelativeRateAndAnchorTime) = v80;
      if (*(_QWORD *)v20)
      {
        v30 = *(_QWORD *)(*(_QWORD *)v20 + 8);
        if ((v17 & (v17 - 1)) != 0)
        {
          if (v30 >= v17)
            v30 %= v17;
        }
        else
        {
          v30 &= v17 - 1;
        }
        v29 = (_QWORD *)(*(_QWORD *)&v86->_os_unfair_lock_opaque + 8 * v30);
        goto LABEL_42;
      }
LABEL_43:
      outOfClockOrTimebaseAnchorTime.value = 0;
      ++*(_QWORD *)&this[24]._os_unfair_lock_opaque;
      std::unique_ptr<std::__hash_node<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,void *>>>>::reset[abi:nn180100]((uint64_t)&outOfClockOrTimebaseAnchorTime);
LABEL_44:
      *((_QWORD *)v20 + 3) = v96.value;
      if (v20 + 24 != (char *)&v96)
      {
        v31 = v20 + 32;
        *((_DWORD *)v20 + 16) = v98.value;
        v32 = (_QWORD *)v97;
        v33 = *((_QWORD *)v20 + 5);
        if (!v33)
          goto LABEL_51;
        for (i = 0; i != v33; ++i)
          *(_QWORD *)(*v31 + 8 * i) = 0;
        v35 = (_QWORD *)*((_QWORD *)v20 + 6);
        *((_QWORD *)v20 + 6) = 0;
        *((_QWORD *)v20 + 7) = 0;
        if (v35)
        {
          while (v32)
          {
            v35[2] = v32[2];
            v35[3] = v32[3];
            v36 = (_QWORD *)*v35;
            std::__hash_table<std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::__unordered_map_hasher<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::hash<re::TimebaseTree *>,std::equal_to<re::TimebaseTree *>,true>,std::__unordered_map_equal<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::equal_to<re::TimebaseTree *>,std::hash<re::TimebaseTree *>,true>,std::allocator<std::__hash_value_type<re::TimebaseTree *,unsigned long long>>>::__node_insert_multi((uint64_t)v31, v35);
            v32 = (_QWORD *)*v32;
            v35 = v36;
            if (!v36)
              goto LABEL_51;
          }
          do
          {
            v41 = (_QWORD *)*v35;
            operator delete(v35);
            v35 = v41;
          }
          while (v41);
        }
        else
        {
LABEL_51:
          while (v32)
          {
            v37 = operator new(0x20uLL);
            *(_QWORD *)v37 = 0;
            v37[1] = *((_OWORD *)v32 + 1);
            v38 = *((_QWORD *)v37 + 2);
            v39 = HIDWORD(v38);
            v40 = 0x9DDFEA08EB382D69 * (((8 * v38) + 8) ^ HIDWORD(v38));
            *((_QWORD *)v37 + 1) = 0x9DDFEA08EB382D69
                                 * ((0x9DDFEA08EB382D69 * (v39 ^ (v40 >> 47) ^ v40)) ^ ((0x9DDFEA08EB382D69
                                                                                         * (v39 ^ (v40 >> 47) ^ v40)) >> 47));
            std::__hash_table<std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::__unordered_map_hasher<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::hash<re::TimebaseTree *>,std::equal_to<re::TimebaseTree *>,true>,std::__unordered_map_equal<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::equal_to<re::TimebaseTree *>,std::hash<re::TimebaseTree *>,true>,std::allocator<std::__hash_value_type<re::TimebaseTree *,unsigned long long>>>::__node_insert_multi((uint64_t)v31, v37);
            v32 = (_QWORD *)*v32;
          }
        }
      }
      v12 = v93;
      std::__hash_table<std::__hash_value_type<unsigned long long,void const*>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void const*>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void const*>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void const*>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)&this[28], v93, &v93)[3] = v9;
      v11 = std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::find<void const*>(v86, v9);
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)&v96.timescale);
      RelativeRateAndAnchorTime = 0;
      if (!v8)
        goto LABEL_71;
LABEL_56:
      if (!*(_QWORD *)v94)
      {
        v43 = *((_QWORD *)v94 + 2);
LABEL_68:
        if (!*(_QWORD *)(v43 + 0x63FFFFFF68))
          goto LABEL_69;
        goto LABEL_71;
      }
      v42 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v8 ^ (v8 >> 30))) >> 27));
      v43 = *((_QWORD *)v94 + 2);
      v44 = *(unsigned int *)(*((_QWORD *)v94 + 1) + 4 * ((v42 ^ (v42 >> 31)) % *((unsigned int *)v94 + 6)));
      if ((_DWORD)v44 == 0x7FFFFFFF)
        goto LABEL_68;
      v45 = v44;
      if (*(_QWORD *)(v43 + 200 * v44 + 16) == v8)
      {
        if (!*(_QWORD *)(v43 + 200 * v44 + 48))
          goto LABEL_70;
      }
      else
      {
        do
          LODWORD(v45) = *(_DWORD *)(v43 + 200 * v45 + 8) & 0x7FFFFFFF;
        while ((_DWORD)v45 != 0x7FFFFFFF && *(_QWORD *)(v43 + 200 * v45 + 16) != v8);
        if (!*(_QWORD *)(v43 + 200 * v45 + 48))
        {
          while (1)
          {
            v44 = *(_DWORD *)(v43 + 200 * v44 + 8) & 0x7FFFFFFF;
            if (v44 == 0x7FFFFFFF)
              break;
            if (*(_QWORD *)(v43 + 200 * v44 + 16) == v8)
              goto LABEL_70;
          }
LABEL_69:
          LODWORD(v44) = 0x7FFFFFFF;
LABEL_70:
          *(_QWORD *)(v43 + 200 * v44 + 48) = v12;
        }
      }
LABEL_71:
      v46 = CFEqual((CFTypeRef)v9, cf2);
      if (v46)
      {
        v83 = v93;
        if (!std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::find<void const*>(v82, v9))
        {
          std::__hash_table<void const*,std::hash<void const*>,std::equal_to<void const*>,std::allocator<void const*>>::__emplace_unique_key_args<void const*,void const* const&>((uint64_t)v82, v9, v9);
          LocalCenter = CFNotificationCenterGetLocalCenter();
          CFNotificationCenterAddObserver(LocalCenter, this, (CFNotificationCallback)re::TimebaseManager::LeafTimebaseNeedsUpdating, name, (const void *)v9, CFNotificationSuspensionBehaviorDrop);
          v48 = CFNotificationCenterGetLocalCenter();
          CFNotificationCenterAddObserver(v48, this, (CFNotificationCallback)re::TimebaseManager::LeafTimebaseNeedsUpdating, v78, (const void *)v9, CFNotificationSuspensionBehaviorDrop);
          v49 = CFNotificationCenterGetLocalCenter();
          CFNotificationCenterAddObserver(v49, this, (CFNotificationCallback)re::TimebaseManager::LeafMasterDidChange, v77, (const void *)v9, CFNotificationSuspensionBehaviorDrop);
        }
      }
      v52 = re::TimebaseManager::clockOrTimebaseTypeFromRef((re::TimebaseManager *)this, (CFTypeRef)v9);
      if ((v85 & (v7 != 0)) == 1)
      {
        CFRelease(v7);
        v85 = 0;
      }
      if (v52 == 3)
      {
        v7 = 0;
        if ((RelativeRateAndAnchorTime & 1) == 0)
          goto LABEL_86;
      }
      else if (v52)
      {
        v7 = *(CMClockOrTimebaseRef *)&this[70]._os_unfair_lock_opaque;
        if (v7)
        {
          if ((RelativeRateAndAnchorTime & 1) == 0)
            goto LABEL_86;
        }
        else
        {
          re::TimebaseManager::updatePrimarySharedClock((re::TimebaseManager *)this, v50, v51);
          v7 = *(CMClockOrTimebaseRef *)&this[70]._os_unfair_lock_opaque;
          if ((RelativeRateAndAnchorTime & 1) == 0)
          {
LABEL_86:
            outRelativeRate = 1.0;
            outOfClockOrTimebaseAnchorTime = *(CMTime *)*(_QWORD *)&MEMORY[0x24BDC0D88];
            outRelativeToClockOrTimebaseAnchorTime = outOfClockOrTimebaseAnchorTime;
            v89 = *(CMTime *)*(_QWORD *)&MEMORY[0x24BDC0D88];
            v90 = 1.0;
            v88 = *(CMTime *)*(_QWORD *)&MEMORY[0x24BDC0D88];
            if (v7)
            {
              RelativeRateAndAnchorTime = CMSyncGetRelativeRateAndAnchorTime((CMClockOrTimebaseRef)v9, v7, &outRelativeRate, &outOfClockOrTimebaseAnchorTime, &outRelativeToClockOrTimebaseAnchorTime);
              if (CMSyncGetRelativeRate((CMClockOrTimebaseRef)v9, v7) == 0.0
                || (_DWORD)RelativeRateAndAnchorTime == -12755)
              {
                CMSyncGetTime(&v96, (CMClockOrTimebaseRef)v9);
                outOfClockOrTimebaseAnchorTime = v96;
                outRelativeToClockOrTimebaseAnchorTime = *(CMTime *)*(_QWORD *)&MEMORY[0x24BDC0D88];
              }
              else if ((_DWORD)RelativeRateAndAnchorTime)
              {
                re::TimebaseLog(v54);
                v55 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
                {
                  LODWORD(v96.value) = 67109120;
                  HIDWORD(v96.value) = RelativeRateAndAnchorTime;
                  _os_log_error_impl(&dword_224FE9000, v55, OS_LOG_TYPE_ERROR, "Failed to calculate relative rate and anchor: %d", (uint8_t *)&v96, 8u);
                }

              }
              v56 = *(CMClockOrTimebaseRef *)&this[68]._os_unfair_lock_opaque;
              if (v7 == *(CMClockOrTimebaseRef *)&this[66]._os_unfair_lock_opaque && v56)
              {
                v57 = (re *)CMSyncGetRelativeRateAndAnchorTime((CMClockOrTimebaseRef)v9, v56, &v90, &v89, &v88);
                if ((_DWORD)v57)
                {
                  v58 = (int)v57;
                  re::TimebaseLog(v57);
                  v59 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
                  {
                    LODWORD(v96.value) = 136315650;
                    *(CMTimeValue *)((char *)&v96.value + 4) = (CMTimeValue)"addLocallyControlledTimebaseToTree";
                    LOWORD(v96.flags) = 1024;
                    *(CMTimeFlags *)((char *)&v96.flags + 2) = 1038;
                    WORD1(v96.epoch) = 1024;
                    HIDWORD(v96.epoch) = v58;
                    _os_log_error_impl(&dword_224FE9000, v59, OS_LOG_TYPE_ERROR, "%s:%d error: %d", (uint8_t *)&v96, 0x18u);
                  }

                }
              }
              else if (v7 == v56)
              {
                v90 = outRelativeRate;
                v89 = outOfClockOrTimebaseAnchorTime;
                v88 = outRelativeToClockOrTimebaseAnchorTime;
                outRelativeRate = 1.0;
                outOfClockOrTimebaseAnchorTime = *(CMTime *)*(_QWORD *)&MEMORY[0x24BDC0D88];
                outRelativeToClockOrTimebaseAnchorTime = outOfClockOrTimebaseAnchorTime;
              }
            }
            v87 = *(CMTime *)*(_QWORD *)&MEMORY[0x24BDC0D88];
            if (v46)
              v60 = a4;
            else
              v60 = 0;
            if (v60 == 1)
            {
              if (CMTimebaseGetEffectiveRate(cf2) == 0.0)
              {
                CMTimebaseGetTime(&v87, cf2);
              }
              else
              {
                re::TimebaseLog(v61);
                v62 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(v96.value) = 0;
                  _os_log_error_impl(&dword_224FE9000, v62, OS_LOG_TYPE_ERROR, "new locally-controlled timebase has non-zero rate so initial seek target is undefined", (uint8_t *)&v96, 2u);
                }

              }
            }
            v63 = v94;
            LODWORD(v96.value) = v52;
            *(_QWORD *)&v96.timescale = v93;
            LOBYTE(v96.epoch) = 1;
            *(_QWORD *)&v97 = 0;
            v98 = outOfClockOrTimebaseAnchorTime;
            v99 = outRelativeToClockOrTimebaseAnchorTime;
            *((Float64 *)&v97 + 1) = outRelativeRate;
            v100 = v90;
            v101 = v89;
            v102 = v88;
            v103 = v60;
            v104 = v87;
            v64 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v93 ^ (v93 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v93 ^ (v93 >> 30))) >> 27));
            v65 = v64 ^ (v64 >> 31);
            if (*(_QWORD *)v94)
            {
              v66 = v65 % *((unsigned int *)v94 + 6);
              v67 = *(unsigned int *)(*((_QWORD *)v94 + 1) + 4 * v66);
              if ((_DWORD)v67 != 0x7FFFFFFF)
              {
                v68 = *((_QWORD *)v94 + 2);
                while (*(_QWORD *)(v68 + 200 * v67 + 16) != v93)
                {
                  LODWORD(v67) = *(_DWORD *)(v68 + 200 * v67 + 8) & 0x7FFFFFFF;
                  if ((_DWORD)v67 == 0x7FFFFFFF)
                    goto LABEL_118;
                }
                goto LABEL_119;
              }
            }
            else
            {
              LODWORD(v66) = 0;
            }
LABEL_118:
            re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove((uint64_t)v94, v66, v65, &v93, (__int128 *)&v96.value);
            ++*((_DWORD *)v63 + 10);
LABEL_119:
            std::__hash_table<std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::__unordered_map_hasher<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::hash<re::TimebaseTree *>,std::equal_to<re::TimebaseTree *>,true>,std::__unordered_map_equal<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::equal_to<re::TimebaseTree *>,std::hash<re::TimebaseTree *>,true>,std::allocator<std::__hash_value_type<re::TimebaseTree *,unsigned long long>>>::__emplace_unique_key_args<re::TimebaseTree *,std::piecewise_construct_t const&,std::tuple<re::TimebaseTree * const&>,std::tuple<>>((uint64_t)(v11 + 4), (unint64_t)v63, &v94)[3] = 1;
            goto LABEL_120;
          }
        }
      }
      else
      {
        v7 = CMTimebaseCopySource((CMTimebaseRef)v9);
        v85 = 1;
        if ((RelativeRateAndAnchorTime & 1) == 0)
          goto LABEL_86;
      }
      v53 = std::__hash_table<std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::__unordered_map_hasher<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::hash<re::TimebaseTree *>,std::equal_to<re::TimebaseTree *>,true>,std::__unordered_map_equal<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::equal_to<re::TimebaseTree *>,std::hash<re::TimebaseTree *>,true>,std::allocator<std::__hash_value_type<re::TimebaseTree *,unsigned long long>>>::__emplace_unique_key_args<re::TimebaseTree *,std::piecewise_construct_t const&,std::tuple<re::TimebaseTree * const&>,std::tuple<>>((uint64_t)(v11 + 4), (unint64_t)v94, &v94);
      ++v53[3];
LABEL_120:
      v8 = v93;
      v9 = (unint64_t)v7;
      if (!v7)
        goto LABEL_123;
    }
    *(_QWORD *)v20 = *v29;
LABEL_42:
    *v29 = v20;
    goto LABEL_43;
  }
  v83 = 0;
LABEL_123:
  v69 = *(_QWORD *)&this[60]._os_unfair_lock_opaque;
  if (v69)
    v69 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v69 + 56))(v69);
  v70 = v94;
  *((_QWORD *)v94 + 14) = v69;
  v71 = re::HashTable<re::ecs2::Entity const*,re::SharedPtr<re::ecs2::CAMeshCodirectionalGroup>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::tryGet((uint64_t)&this[72], (unint64_t)v70);
  if (v71)
    (*(void (**)(void))(*(_QWORD *)v71 + 16))();
  v72 = (unsigned __int8 *)re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)v70, v83);
  v73 = v72;
  if (!v72 || v72[144] != a4)
  {
    re::TimebaseLog((re *)v72);
    v74 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v96.value) = 134218496;
      *(CMTimeValue *)((char *)&v96.value + 4) = v83;
      LOWORD(v96.flags) = 2048;
      *(_QWORD *)((char *)&v96.flags + 2) = v73;
      HIWORD(v96.epoch) = 1024;
      LODWORD(v97) = a4;
      _os_log_error_impl(&dword_224FE9000, v74, OS_LOG_TYPE_ERROR, "timebase %llu node %p has unexpected prioritizeContinuity state (expected %d)", (uint8_t *)&v96, 0x1Cu);
    }

  }
  os_unfair_lock_unlock(lock);
  return v83;
}

void re::TimebaseManager::LeafTimebaseNeedsUpdating(re::TimebaseManager *this, os_unfair_lock_s *a2, const __CFString *a3, __CFString *a4, CFDictionaryRef theDict, const __CFDictionary *a6)
{
  const __CFDictionary *Value;
  NSObject *v9;
  CMTimeFlags flags;
  char v11;
  const __CFString *v12;
  unint64_t *p_os_unfair_lock_opaque;
  const __CFString *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  OpaqueCMClock **v18;
  int v19;
  OSStatus RelativeRateAndAnchorTime;
  CMTime *Time;
  NSObject *v22;
  const __CFString *v23;
  re *v24;
  int v25;
  NSObject *v26;
  _QWORD *i;
  uint64_t v28;
  uint64_t v29;
  unint64_t v31;
  unint64_t v32;
  __int128 v33;
  uint64_t v34;
  NSObject *v35;
  NSObject *v36;
  char v37;
  CMTimeEpoch epoch;
  CMTime v40;
  CMTime v41;
  CMTime v42;
  Float64 v43;
  CMTime outRelativeToClockOrTimebaseAnchorTime;
  CMTime outOfClockOrTimebaseAnchorTime;
  Float64 outRelativeRate;
  CMTimeValue v47;
  CMTimeScale timescale;
  CMTime v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x24BDC0D98]);
  if (Value)
  {
    memset(&v40, 0, sizeof(v40));
    CMTimeMakeFromDictionary(&v40, Value);
  }
  else
  {
    re::TimebaseLog(0);
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      LOWORD(outOfClockOrTimebaseAnchorTime.value) = 0;
      _os_log_error_impl(&dword_224FE9000, v9, OS_LOG_TYPE_ERROR, "leaf timebase update does not have event time", (uint8_t *)&outOfClockOrTimebaseAnchorTime, 2u);
    }

    v40 = *(CMTime *)*(_QWORD *)&MEMORY[0x24BDC0D40];
  }
  v47 = v40.value;
  flags = v40.flags;
  timescale = v40.timescale;
  epoch = v40.epoch;
  os_unfair_lock_lock(a2 + 6);
  if (a4)
  {
    v11 = 0;
    v12 = (const __CFString *)*MEMORY[0x24BDC0DB0];
    p_os_unfair_lock_opaque = (unint64_t *)&a2[86]._os_unfair_lock_opaque;
    while (1)
    {
      v14 = a4;
      v15 = std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::find<void const*>(&a2[18]._os_unfair_lock_opaque, (unint64_t)a4);
      if (!v15)
        break;
      v16 = v15;
      v19 = re::TimebaseManager::clockOrTimebaseTypeFromRef((re::TimebaseManager *)a2, a4);
      if ((v11 & 1) != 0)
        CFRelease(a4);
      if (v19)
      {
        if (v19 == 3)
          goto LABEL_53;
        a4 = *(__CFString **)&a2[70]._os_unfair_lock_opaque;
        if (a4)
        {
          v37 = 0;
        }
        else
        {
          re::TimebaseManager::updatePrimarySharedClock((re::TimebaseManager *)a2, v17, v18);
          v37 = 0;
          a4 = *(__CFString **)&a2[70]._os_unfair_lock_opaque;
        }
      }
      else
      {
        a4 = (__CFString *)CMTimebaseCopySource((CMTimebaseRef)a4);
        v37 = 1;
      }
      outRelativeRate = 1.0;
      outOfClockOrTimebaseAnchorTime = *(CMTime *)*(_QWORD *)&MEMORY[0x24BDC0D88];
      outRelativeToClockOrTimebaseAnchorTime = outOfClockOrTimebaseAnchorTime;
      v42 = *(CMTime *)*(_QWORD *)&MEMORY[0x24BDC0D88];
      v43 = 1.0;
      v41 = *(CMTime *)*(_QWORD *)&MEMORY[0x24BDC0D88];
      RelativeRateAndAnchorTime = CMSyncGetRelativeRateAndAnchorTime(v14, a4, &outRelativeRate, &outOfClockOrTimebaseAnchorTime, &outRelativeToClockOrTimebaseAnchorTime);
      if (CMSyncGetRelativeRate(v14, a4) == 0.0 || RelativeRateAndAnchorTime)
      {
        outRelativeRate = 0.0;
        Time = CMSyncGetTime(&v49, v14);
        outOfClockOrTimebaseAnchorTime = v49;
        outRelativeToClockOrTimebaseAnchorTime = *(CMTime *)*(_QWORD *)&MEMORY[0x24BDC0D88];
        if (RelativeRateAndAnchorTime != -12755)
        {
          if (RelativeRateAndAnchorTime)
          {
            re::TimebaseLog((re *)Time);
            v22 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v49.value) = 67109120;
              HIDWORD(v49.value) = RelativeRateAndAnchorTime;
              _os_log_error_impl(&dword_224FE9000, v22, OS_LOG_TYPE_ERROR, "Failed to calculate relative rate and anchor: %d", (uint8_t *)&v49, 8u);
            }

          }
        }
      }
      v23 = *(const __CFString **)&a2[68]._os_unfair_lock_opaque;
      if (a4 == *(__CFString **)&a2[66]._os_unfair_lock_opaque && v23)
      {
        v24 = (re *)CMSyncGetRelativeRateAndAnchorTime(v14, v23, &v43, &v42, &v41);
        if ((_DWORD)v24)
        {
          v25 = (int)v24;
          re::TimebaseLog(v24);
          v26 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            LODWORD(v49.value) = 136315650;
            *(CMTimeValue *)((char *)&v49.value + 4) = (CMTimeValue)"updateEffectiveRateOrAnchorThroughTimebase";
            LOWORD(v49.flags) = 1024;
            *(CMTimeFlags *)((char *)&v49.flags + 2) = 1268;
            WORD1(v49.epoch) = 1024;
            HIDWORD(v49.epoch) = v25;
            _os_log_error_impl(&dword_224FE9000, v26, OS_LOG_TYPE_ERROR, "%s:%d error: %d", (uint8_t *)&v49, 0x18u);
          }

        }
      }
      else if (a4 == v23)
      {
        v43 = outRelativeRate;
        v42 = outOfClockOrTimebaseAnchorTime;
        v41 = outRelativeToClockOrTimebaseAnchorTime;
        outRelativeRate = 1.0;
        outOfClockOrTimebaseAnchorTime = *(CMTime *)*(_QWORD *)&MEMORY[0x24BDC0D88];
        outRelativeToClockOrTimebaseAnchorTime = outOfClockOrTimebaseAnchorTime;
      }
      for (i = (_QWORD *)v16[6]; i; i = (_QWORD *)*i)
      {
        v28 = re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(i[2], v16[3]);
        if (v28)
        {
          v29 = v28;
          if (CFStringCompare(a3, v12, 0) == kCFCompareEqualTo && *(_BYTE *)(v29 + 144) && (flags & 1) != 0)
          {
            *(_QWORD *)(v29 + 148) = v47;
            *(_DWORD *)(v29 + 156) = timescale;
            *(_DWORD *)(v29 + 160) = flags;
            *(_QWORD *)(v29 + 164) = epoch;
            do
            {
              v31 = __ldaxr(p_os_unfair_lock_opaque);
              v32 = v31 + 1;
            }
            while (__stlxr(v32, p_os_unfair_lock_opaque));
            *(_QWORD *)(v29 + 164) = v32;
          }
          *(Float64 *)(v29 + 32) = outRelativeRate;
          *(CMTime *)(v29 + 40) = outOfClockOrTimebaseAnchorTime;
          *(CMTime *)(v29 + 64) = outRelativeToClockOrTimebaseAnchorTime;
          *(Float64 *)(v29 + 88) = v43;
          *(CMTime *)(v29 + 96) = v42;
          v33 = *(_OWORD *)&v41.value;
          *(_QWORD *)(v29 + 136) = v41.epoch;
          *(_OWORD *)(v29 + 120) = v33;
          v34 = re::HashTable<re::ecs2::Entity const*,re::SharedPtr<re::ecs2::CAMeshCodirectionalGroup>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::tryGet((uint64_t)&a2[72], i[2]);
          if (v34)
            (*(void (**)(void))(*(_QWORD *)v34 + 16))();
        }
        else
        {
          re::TimebaseLog(0);
          v35 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            LOWORD(v49.value) = 0;
            _os_log_error_impl(&dword_224FE9000, v35, OS_LOG_TYPE_ERROR, "Trying to update unknown struct in tree", (uint8_t *)&v49, 2u);
          }

        }
      }
      v11 = v37;
      if (!a4)
        goto LABEL_53;
    }
    re::TimebaseLog(0);
    v36 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      LOWORD(outOfClockOrTimebaseAnchorTime.value) = 0;
      _os_log_error_impl(&dword_224FE9000, v36, OS_LOG_TYPE_ERROR, "Trying to update unknown clock or timebase", (uint8_t *)&outOfClockOrTimebaseAnchorTime, 2u);
    }

  }
LABEL_53:
  os_unfair_lock_unlock(a2 + 6);
}

void re::TimebaseManager::LeafMasterDidChange(re::TimebaseManager *this, os_unfair_lock_s *a2, void *a3, __CFString *a4, const void *a5, const __CFDictionary *a6)
{
  unint64_t v6;
  os_unfair_lock_s *v9;
  float *v10;
  float *v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint8x8_t v18;
  _QWORD *v19;
  _QWORD *i;
  unint64_t v21;
  _QWORD *v22;
  float v23;
  _BOOL8 v24;
  unint64_t v25;
  unint64_t v26;
  size_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  uint64_t **j;
  NSObject *v32;
  __int128 v33;
  __int128 v34;
  float v35;
  os_unfair_lock_t lock;
  char v37;

  v9 = a2 + 6;
  lock = a2 + 6;
  v37 = 1;
  os_unfair_lock_lock(a2 + 6);
  v10 = (float *)std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::find<void const*>(&a2[18]._os_unfair_lock_opaque, (unint64_t)a4);
  if (!v10)
  {
    re::TimebaseLog(0);
    v32 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v33) = 0;
      _os_log_error_impl(&dword_224FE9000, v32, OS_LOG_TYPE_ERROR, "Received update for unknown timebase", (uint8_t *)&v33, 2u);
    }

    goto LABEL_50;
  }
  v11 = v10;
  v33 = 0u;
  v34 = 0u;
  v35 = v10[16];
  std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>((uint64_t)&v33, *((_QWORD *)v10 + 5));
  v12 = (_QWORD *)*((_QWORD *)v11 + 6);
  if (v12)
  {
    v13 = *((_QWORD *)&v33 + 1);
    do
    {
      v14 = v12[2];
      v15 = 0x9DDFEA08EB382D69 * (((8 * v14) + 8) ^ HIDWORD(v14));
      v16 = 0x9DDFEA08EB382D69 * (HIDWORD(v14) ^ (v15 >> 47) ^ v15);
      v17 = 0x9DDFEA08EB382D69 * (v16 ^ (v16 >> 47));
      if (v13)
      {
        v18 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
        v18.i16[0] = vaddlv_u8(v18);
        if (v18.u32[0] > 1uLL)
        {
          v6 = 0x9DDFEA08EB382D69 * (v16 ^ (v16 >> 47));
          if (v17 >= v13)
            v6 = v17 % v13;
        }
        else
        {
          v6 = v17 & (v13 - 1);
        }
        v19 = *(_QWORD **)(v33 + 8 * v6);
        if (v19)
        {
          for (i = (_QWORD *)*v19; i; i = (_QWORD *)*i)
          {
            v21 = i[1];
            if (v21 == v17)
            {
              if (i[2] == v14)
                goto LABEL_42;
            }
            else
            {
              if (v18.u32[0] > 1uLL)
              {
                if (v21 >= v13)
                  v21 %= v13;
              }
              else
              {
                v21 &= v13 - 1;
              }
              if (v21 != v6)
                break;
            }
          }
        }
      }
      v22 = operator new(0x20uLL);
      *v22 = 0;
      v22[1] = v17;
      *((_OWORD *)v22 + 1) = *((_OWORD *)v12 + 1);
      v23 = (float)(unint64_t)(*((_QWORD *)&v34 + 1) + 1);
      if (!v13 || (float)(v35 * (float)v13) < v23)
      {
        v24 = (v13 & (v13 - 1)) != 0;
        if (v13 < 3)
          v24 = 1;
        v25 = v24 | (2 * v13);
        v26 = vcvtps_u32_f32(v23 / v35);
        if (v25 <= v26)
          v27 = v26;
        else
          v27 = v25;
        std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>((uint64_t)&v33, v27);
        v13 = *((_QWORD *)&v33 + 1);
        if ((*((_QWORD *)&v33 + 1) & (*((_QWORD *)&v33 + 1) - 1)) != 0)
        {
          if (v17 >= *((_QWORD *)&v33 + 1))
            v6 = v17 % *((_QWORD *)&v33 + 1);
          else
            v6 = v17;
        }
        else
        {
          v6 = (*((_QWORD *)&v33 + 1) - 1) & v17;
        }
      }
      v28 = v33;
      v29 = *(_QWORD **)(v33 + 8 * v6);
      if (v29)
      {
        *v22 = *v29;
      }
      else
      {
        *v22 = v34;
        *(_QWORD *)&v34 = v22;
        *(_QWORD *)(v28 + 8 * v6) = &v34;
        if (!*v22)
          goto LABEL_41;
        v30 = *(_QWORD *)(*v22 + 8);
        if ((v13 & (v13 - 1)) != 0)
        {
          if (v30 >= v13)
            v30 %= v13;
        }
        else
        {
          v30 &= v13 - 1;
        }
        v29 = (_QWORD *)(v33 + 8 * v30);
      }
      *v29 = v22;
LABEL_41:
      ++*((_QWORD *)&v34 + 1);
LABEL_42:
      v12 = (_QWORD *)*v12;
    }
    while (v12);
  }
  std::unique_lock<re::UnfairLock>::unlock((uint64_t)&lock);
  for (j = (uint64_t **)v34; j; j = (uint64_t **)*j)
  {
    re::TimebaseManager::removeLocallyControlledTimebaseFromTree(a2, (OpaqueCMTimebase *)a4, (re::TimebaseTree *)j[2], 0);
    re::TimebaseManager::addLocallyControlledTimebaseToTree((re::TimebaseManager *)a2, (OpaqueCMTimebase *)a4, (re::TimebaseTree *)j[2], 0);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)&v33);
  if (v37)
  {
    v9 = lock;
LABEL_50:
    os_unfair_lock_unlock(v9);
  }
}

void re::TimebaseManager::removeLocallyControlledTimebaseFromTree(os_unfair_lock_s *this, OpaqueCMTimebase *a2, re::TimebaseTree *a3, int a4)
{
  unint64_t v7;
  OpaqueCMTimebase *v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  int8x8_t v17;
  unint64_t v18;
  uint8x8_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  int v26;
  os_unfair_lock_s *v27;
  int8x8_t v28;
  unint64_t v29;
  uint8x8_t v30;
  uint64_t v31;
  os_unfair_lock_s *v32;
  os_unfair_lock_s *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  os_unfair_lock_s *v37;
  int8x8_t v38;
  unint64_t v39;
  uint8x8_t v40;
  uint64_t v41;
  os_unfair_lock_s *v42;
  os_unfair_lock_s *v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  _QWORD *v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  int *v59;
  int v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  os_unfair_lock_s *lock;
  os_unfair_lock_s *v65;
  OpaqueCMTimebase *v67;
  os_unfair_lock_s *v68;
  re::TimebaseTree *v69;

  v69 = a3;
  lock = this + 6;
  os_unfair_lock_lock(this + 6);
  v67 = a2;
  if (a2)
  {
    v7 = 0;
    v68 = this + 28;
    v65 = this + 8;
    v8 = a2;
    while (1)
    {
      v9 = v7;
      v10 = std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::find<void const*>(&this[18]._os_unfair_lock_opaque, (unint64_t)v8);
      if (!v10)
        goto LABEL_118;
      v11 = v10;
      v12 = v10 + 4;
      if (!std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::find<void const*>(v10 + 4, (unint64_t)a3))goto LABEL_118;
      v7 = v11[3];
      v13 = std::__hash_table<std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::__unordered_map_hasher<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::hash<re::TimebaseTree *>,std::equal_to<re::TimebaseTree *>,true>,std::__unordered_map_equal<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::equal_to<re::TimebaseTree *>,std::hash<re::TimebaseTree *>,true>,std::allocator<std::__hash_value_type<re::TimebaseTree *,unsigned long long>>>::__emplace_unique_key_args<re::TimebaseTree *,std::piecewise_construct_t const&,std::tuple<re::TimebaseTree * const&>,std::tuple<>>((uint64_t)v12, (unint64_t)a3, &v69);
      v14 = v13[3];
      v15 = v14 - 1;
      v13[3] = v14 - 1;
      if (v14 != 1)
        goto LABEL_98;
      v16 = std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::find<void const*>(v12, (unint64_t)a3);
      if (v16)
        break;
LABEL_35:
      v26 = a4;
      if (v8 != v67)
        v26 = 1;
      if (!v11[7] && v26)
      {
        std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::__erase_unique<void const*>(&this[18]._os_unfair_lock_opaque, (unint64_t)v8);
        v27 = (os_unfair_lock_s *)std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>(v68, v7);
        if (v27)
        {
          v28 = *(int8x8_t *)&this[30]._os_unfair_lock_opaque;
          v29 = *(_QWORD *)&v27[2]._os_unfair_lock_opaque;
          v30 = (uint8x8_t)vcnt_s8(v28);
          v30.i16[0] = vaddlv_u8(v30);
          if (v30.u32[0] > 1uLL)
          {
            if (v29 >= *(_QWORD *)&v28)
              v29 %= *(_QWORD *)&v28;
          }
          else
          {
            v29 &= *(_QWORD *)&v28 - 1;
          }
          v31 = *(_QWORD *)&v27->_os_unfair_lock_opaque;
          v32 = *(os_unfair_lock_s **)(*(_QWORD *)&v68->_os_unfair_lock_opaque + 8 * v29);
          do
          {
            v33 = v32;
            v32 = *(os_unfair_lock_s **)&v32->_os_unfair_lock_opaque;
          }
          while (v32 != v27);
          if (v33 == &this[32])
            goto LABEL_57;
          v34 = *(_QWORD *)&v33[2]._os_unfair_lock_opaque;
          if (v30.u32[0] > 1uLL)
          {
            if (v34 >= *(_QWORD *)&v28)
              v34 %= *(_QWORD *)&v28;
          }
          else
          {
            v34 &= *(_QWORD *)&v28 - 1;
          }
          if (v34 == v29)
          {
LABEL_59:
            if (v31)
            {
              v35 = *(_QWORD *)(v31 + 8);
              goto LABEL_61;
            }
          }
          else
          {
LABEL_57:
            if (!v31)
              goto LABEL_58;
            v35 = *(_QWORD *)(v31 + 8);
            if (v30.u32[0] > 1uLL)
            {
              v36 = *(_QWORD *)(v31 + 8);
              if (v35 >= *(_QWORD *)&v28)
                v36 = v35 % *(_QWORD *)&v28;
            }
            else
            {
              v36 = v35 & (*(_QWORD *)&v28 - 1);
            }
            if (v36 != v29)
            {
LABEL_58:
              *(_QWORD *)(*(_QWORD *)&v68->_os_unfair_lock_opaque + 8 * v29) = 0;
              v31 = *(_QWORD *)&v27->_os_unfair_lock_opaque;
              goto LABEL_59;
            }
LABEL_61:
            if (v30.u32[0] > 1uLL)
            {
              if (v35 >= *(_QWORD *)&v28)
                v35 %= *(_QWORD *)&v28;
            }
            else
            {
              v35 &= *(_QWORD *)&v28 - 1;
            }
            if (v35 != v29)
            {
              *(_QWORD *)(*(_QWORD *)&v68->_os_unfair_lock_opaque + 8 * v35) = v33;
              v31 = *(_QWORD *)&v27->_os_unfair_lock_opaque;
            }
          }
          *(_QWORD *)&v33->_os_unfair_lock_opaque = v31;
          *(_QWORD *)&v27->_os_unfair_lock_opaque = 0;
          --*(_QWORD *)&this[34]._os_unfair_lock_opaque;
          operator delete(v27);
        }
        v37 = (os_unfair_lock_s *)std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::find<void const*>(v65, (unint64_t)v8);
        if (v37)
        {
          v38 = *(int8x8_t *)&this[10]._os_unfair_lock_opaque;
          v39 = *(_QWORD *)&v37[2]._os_unfair_lock_opaque;
          v40 = (uint8x8_t)vcnt_s8(v38);
          v40.i16[0] = vaddlv_u8(v40);
          if (v40.u32[0] > 1uLL)
          {
            if (v39 >= *(_QWORD *)&v38)
              v39 %= *(_QWORD *)&v38;
          }
          else
          {
            v39 &= *(_QWORD *)&v38 - 1;
          }
          v41 = *(_QWORD *)&v37->_os_unfair_lock_opaque;
          v42 = *(os_unfair_lock_s **)(*(_QWORD *)&v65->_os_unfair_lock_opaque + 8 * v39);
          do
          {
            v43 = v42;
            v42 = *(os_unfair_lock_s **)&v42->_os_unfair_lock_opaque;
          }
          while (v42 != v37);
          if (v43 == &this[12])
            goto LABEL_86;
          v44 = *(_QWORD *)&v43[2]._os_unfair_lock_opaque;
          if (v40.u32[0] > 1uLL)
          {
            if (v44 >= *(_QWORD *)&v38)
              v44 %= *(_QWORD *)&v38;
          }
          else
          {
            v44 &= *(_QWORD *)&v38 - 1;
          }
          if (v44 == v39)
          {
LABEL_88:
            if (v41)
            {
              v45 = *(_QWORD *)(v41 + 8);
              goto LABEL_90;
            }
          }
          else
          {
LABEL_86:
            if (!v41)
              goto LABEL_87;
            v45 = *(_QWORD *)(v41 + 8);
            if (v40.u32[0] > 1uLL)
            {
              v46 = *(_QWORD *)(v41 + 8);
              if (v45 >= *(_QWORD *)&v38)
                v46 = v45 % *(_QWORD *)&v38;
            }
            else
            {
              v46 = v45 & (*(_QWORD *)&v38 - 1);
            }
            if (v46 != v39)
            {
LABEL_87:
              *(_QWORD *)(*(_QWORD *)&v65->_os_unfair_lock_opaque + 8 * v39) = 0;
              v41 = *(_QWORD *)&v37->_os_unfair_lock_opaque;
              goto LABEL_88;
            }
LABEL_90:
            if (v40.u32[0] > 1uLL)
            {
              if (v45 >= *(_QWORD *)&v38)
                v45 %= *(_QWORD *)&v38;
            }
            else
            {
              v45 &= *(_QWORD *)&v38 - 1;
            }
            if (v45 != v39)
            {
              *(_QWORD *)(*(_QWORD *)&v65->_os_unfair_lock_opaque + 8 * v45) = v43;
              v41 = *(_QWORD *)&v37->_os_unfair_lock_opaque;
            }
          }
          *(_QWORD *)&v43->_os_unfair_lock_opaque = v41;
          *(_QWORD *)&v37->_os_unfair_lock_opaque = 0;
          --*(_QWORD *)&this[14]._os_unfair_lock_opaque;
          operator delete(v37);
          re::TimebaseManager::cleanUpLeafLocallyControlledTimebase((re::TimebaseManager *)this, v8);
        }
        CFRelease(v8);
      }
LABEL_98:
      v47 = re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)a3, v7);
      if (v47
        && (v48 = *(_QWORD *)(v47 + 24)) != 0
        && (v49 = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>(v68, v48)) != 0)
      {
        v8 = (OpaqueCMTimebase *)v49[3];
        if (!v15)
          goto LABEL_104;
      }
      else
      {
        v8 = 0;
        if (!v15)
        {
LABEL_104:
          if (*(_QWORD *)a3)
          {
            v50 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v7 ^ (v7 >> 30))) >> 27));
            v51 = (v50 ^ (v50 >> 31)) % *((unsigned int *)a3 + 6);
            v52 = *((_QWORD *)a3 + 1);
            v53 = *(unsigned int *)(v52 + 4 * v51);
            if ((_DWORD)v53 != 0x7FFFFFFF)
            {
              v54 = *((_QWORD *)a3 + 2);
              if (*(_QWORD *)(v54 + 200 * v53 + 16) == v7)
              {
                *(_DWORD *)(v52 + 4 * v51) = *(_DWORD *)(v54 + 200 * v53 + 8) & 0x7FFFFFFF;
LABEL_111:
                v56 = *((_QWORD *)a3 + 2);
                v57 = v56 + 200 * v53;
                v60 = *(_DWORD *)(v57 + 8);
                v59 = (int *)(v57 + 8);
                v58 = v60;
                if (v60 < 0)
                {
                  *v59 = v58 & 0x7FFFFFFF;
                  v56 = *((_QWORD *)a3 + 2);
                  v58 = *(_DWORD *)(v56 + 200 * v53 + 8);
                }
                v61 = *((_DWORD *)a3 + 10);
                *(_DWORD *)(v56 + 200 * v53 + 8) = *((_DWORD *)a3 + 9) | v58 & 0x80000000;
                --*((_DWORD *)a3 + 7);
                *((_DWORD *)a3 + 9) = v53;
                *((_DWORD *)a3 + 10) = v61 + 1;
              }
              else
              {
                while (1)
                {
                  v55 = v53;
                  v53 = *(_DWORD *)(v54 + 200 * v53 + 8) & 0x7FFFFFFF;
                  if (v53 == 0x7FFFFFFF)
                    break;
                  if (*(_QWORD *)(v54 + 200 * v53 + 16) == v7)
                  {
                    *(_DWORD *)(v54 + 200 * v55 + 8) = *(_DWORD *)(v54 + 200 * v55 + 8) & 0x80000000 | *(_DWORD *)(v54 + 200 * v53 + 8) & 0x7FFFFFFF;
                    goto LABEL_111;
                  }
                }
              }
            }
          }
          if (v9)
          {
            v62 = re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)a3, v9);
            if (v62)
              *(_QWORD *)(v62 + 24) = 0;
          }
        }
      }
      if (!v8)
        goto LABEL_118;
    }
    v17 = (int8x8_t)v11[5];
    v18 = v16[1];
    v19 = (uint8x8_t)vcnt_s8(v17);
    v19.i16[0] = vaddlv_u8(v19);
    if (v19.u32[0] > 1uLL)
    {
      if (v18 >= *(_QWORD *)&v17)
        v18 %= *(_QWORD *)&v17;
    }
    else
    {
      v18 &= *(_QWORD *)&v17 - 1;
    }
    v20 = *v16;
    v21 = *(uint64_t **)(*v12 + 8 * v18);
    do
    {
      v22 = v21;
      v21 = (uint64_t *)*v21;
    }
    while (v21 != v16);
    if (v22 == v11 + 6)
      goto LABEL_24;
    v23 = v22[1];
    if (v19.u32[0] > 1uLL)
    {
      if (v23 >= *(_QWORD *)&v17)
        v23 %= *(_QWORD *)&v17;
    }
    else
    {
      v23 &= *(_QWORD *)&v17 - 1;
    }
    if (v23 != v18)
    {
LABEL_24:
      if (v20)
      {
        v24 = *(_QWORD *)(v20 + 8);
        if (v19.u32[0] > 1uLL)
        {
          v25 = *(_QWORD *)(v20 + 8);
          if (v24 >= *(_QWORD *)&v17)
            v25 = v24 % *(_QWORD *)&v17;
        }
        else
        {
          v25 = v24 & (*(_QWORD *)&v17 - 1);
        }
        if (v25 == v18)
          goto LABEL_28;
      }
      *(_QWORD *)(*v12 + 8 * v18) = 0;
      v20 = *v16;
    }
    if (!v20)
    {
LABEL_34:
      *v22 = v20;
      *v16 = 0;
      --v11[7];
      operator delete(v16);
      goto LABEL_35;
    }
    v24 = *(_QWORD *)(v20 + 8);
LABEL_28:
    if (v19.u32[0] > 1uLL)
    {
      if (v24 >= *(_QWORD *)&v17)
        v24 %= *(_QWORD *)&v17;
    }
    else
    {
      v24 &= *(_QWORD *)&v17 - 1;
    }
    if (v24 != v18)
    {
      *(_QWORD *)(*v12 + 8 * v24) = v22;
      v20 = *v16;
    }
    goto LABEL_34;
  }
LABEL_118:
  v63 = re::HashTable<re::ecs2::Entity const*,re::SharedPtr<re::ecs2::CAMeshCodirectionalGroup>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::tryGet((uint64_t)&this[72], (unint64_t)a3);
  if (v63)
    (*(void (**)(void))(*(_QWORD *)v63 + 16))();
  os_unfair_lock_unlock(lock);
}

void re::TimebaseManager::removeLocallyControlledTimebaseFromTree(os_unfair_lock_s *this, OpaqueCMTimebase *a2, re::TimebaseTree *a3)
{
  re::TimebaseManager::removeLocallyControlledTimebaseFromTree(this, a2, a3, 1);
}

uint64_t re::TimebaseManager::addExternallyControlledTree(os_unfair_lock_s *this, unint64_t a2)
{
  unint64_t v2;
  os_unfair_lock_s *v5;
  os_unfair_lock_s *v6;
  uint64_t v7;
  unint64_t v9;
  _QWORD *ClockOrTimebaseForID;
  CFTypeID v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint8x8_t v16;
  _QWORD *v17;
  _QWORD *i;
  unint64_t v19;
  _QWORD *v20;
  float v21;
  float v22;
  _BOOL8 v23;
  unint64_t v24;
  unint64_t v25;
  size_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  unint64_t v30;
  os_unfair_lock_s *v31;
  char v32;

  v5 = this + 6;
  v31 = this + 6;
  v32 = 1;
  os_unfair_lock_lock(this + 6);
  v6 = this + 48;
  if (std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::find<void const*>(&this[48]._os_unfair_lock_opaque, a2)|| (v9 = *(_QWORD *)(a2 + 48)) != 0&& ((ClockOrTimebaseForID = re::TimebaseManager::findClockOrTimebaseForID((re::TimebaseManager *)this, v9)) == 0|| (v11 = CFGetTypeID(ClockOrTimebaseForID), v11 != CMTimebaseGetTypeID())))
  {
    v7 = 0;
    goto LABEL_3;
  }
  v12 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  v13 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v12 >> 47) ^ v12);
  v14 = 0x9DDFEA08EB382D69 * (v13 ^ (v13 >> 47));
  v15 = *(_QWORD *)&this[50]._os_unfair_lock_opaque;
  if (v15)
  {
    v16 = (uint8x8_t)vcnt_s8((int8x8_t)v15);
    v16.i16[0] = vaddlv_u8(v16);
    if (v16.u32[0] > 1uLL)
    {
      v2 = 0x9DDFEA08EB382D69 * (v13 ^ (v13 >> 47));
      if (v14 >= v15)
        v2 = v14 % v15;
    }
    else
    {
      v2 = (v15 - 1) & v14;
    }
    v17 = *(_QWORD **)(*(_QWORD *)&v6->_os_unfair_lock_opaque + 8 * v2);
    if (v17)
    {
      for (i = (_QWORD *)*v17; i; i = (_QWORD *)*i)
      {
        v19 = i[1];
        if (v19 == v14)
        {
          if (i[2] == a2)
            goto LABEL_47;
        }
        else
        {
          if (v16.u32[0] > 1uLL)
          {
            if (v19 >= v15)
              v19 %= v15;
          }
          else
          {
            v19 &= v15 - 1;
          }
          if (v19 != v2)
            break;
        }
      }
    }
  }
  v20 = operator new(0x18uLL);
  v20[1] = v14;
  v20[2] = a2;
  v21 = (float)(unint64_t)(*(_QWORD *)&this[54]._os_unfair_lock_opaque + 1);
  v22 = *(float *)&this[56]._os_unfair_lock_opaque;
  if (!v15 || (float)(v22 * (float)v15) < v21)
  {
    v23 = 1;
    if (v15 >= 3)
      v23 = (v15 & (v15 - 1)) != 0;
    v24 = v23 | (2 * v15);
    v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25)
      v26 = v25;
    else
      v26 = v24;
    std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>((uint64_t)&this[48], v26);
    v15 = *(_QWORD *)&this[50]._os_unfair_lock_opaque;
    if ((v15 & (v15 - 1)) != 0)
    {
      if (v14 >= v15)
        v2 = v14 % v15;
      else
        v2 = v14;
    }
    else
    {
      v2 = (v15 - 1) & v14;
    }
  }
  v27 = *(_QWORD *)&v6->_os_unfair_lock_opaque;
  v28 = *(_QWORD **)(*(_QWORD *)&v6->_os_unfair_lock_opaque + 8 * v2);
  if (v28)
  {
    *v20 = *v28;
  }
  else
  {
    v29 = *(_QWORD *)&this[52]._os_unfair_lock_opaque;
    *v20 = v29;
    *(_QWORD *)&this[52]._os_unfair_lock_opaque = v20;
    *(_QWORD *)(v27 + 8 * v2) = this + 52;
    if (!v29)
      goto LABEL_46;
    v30 = *(_QWORD *)(v29 + 8);
    if ((v15 & (v15 - 1)) != 0)
    {
      if (v30 >= v15)
        v30 %= v15;
    }
    else
    {
      v30 &= v15 - 1;
    }
    v28 = (_QWORD *)(*(_QWORD *)&v6->_os_unfair_lock_opaque + 8 * v30);
  }
  *v28 = v20;
LABEL_46:
  ++*(_QWORD *)&this[54]._os_unfair_lock_opaque;
LABEL_47:
  std::unique_lock<re::UnfairLock>::unlock((uint64_t)&v31);
  re::TimebaseManager::_afterFrameUpdate(this);
  if (!v32)
    return 1;
  v7 = 1;
  v5 = v31;
LABEL_3:
  os_unfair_lock_unlock(v5);
  return v7;
}

void re::TimebaseManager::removeTimebaseTree(os_unfair_lock_s *this, re::TimebaseTree *a2)
{
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  _QWORD *v10;
  int8x8_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint8x8_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  unsigned int v21;
  unsigned int v22;
  os_unfair_lock_s *v23;
  os_unfair_lock_s *v24;
  int8x8_t v25;
  uint64_t v26;
  unint64_t v27;
  uint8x8_t v28;
  os_unfair_lock_s *v29;
  os_unfair_lock_s *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t **i;
  __int128 v35;
  __int128 v36;
  int v37;
  os_unfair_lock_t lock;
  char v39;

  lock = this + 6;
  v39 = 1;
  os_unfair_lock_lock(this + 6);
  v35 = 0u;
  v36 = 0u;
  v37 = 1065353216;
  v4 = *((unsigned int *)a2 + 8);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*((_QWORD *)a2 + 2) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 50;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *((_DWORD *)a2 + 8);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 == (_DWORD)v5)
    goto LABEL_34;
  v8 = v5;
  v9 = *((_DWORD *)a2 + 8);
  do
  {
    v10 = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>(&this[28]._os_unfair_lock_opaque, *(_QWORD *)(*((_QWORD *)a2 + 2) + 200 * v8 + 16));
    if (!v10)
      goto LABEL_26;
    v11 = *(int8x8_t *)&this[10]._os_unfair_lock_opaque;
    if (!*(_QWORD *)&v11)
      goto LABEL_26;
    v12 = v10[3];
    v13 = 0x9DDFEA08EB382D69 * (((8 * v12) + 8) ^ HIDWORD(v12));
    v14 = 0x9DDFEA08EB382D69 * (HIDWORD(v12) ^ (v13 >> 47) ^ v13);
    v15 = 0x9DDFEA08EB382D69 * (v14 ^ (v14 >> 47));
    v16 = (uint8x8_t)vcnt_s8(v11);
    v16.i16[0] = vaddlv_u8(v16);
    if (v16.u32[0] > 1uLL)
    {
      v17 = v15;
      if (v15 >= *(_QWORD *)&v11)
        v17 = v15 % *(_QWORD *)&v11;
    }
    else
    {
      v17 = v15 & (*(_QWORD *)&v11 - 1);
    }
    v18 = *(_QWORD **)(*(_QWORD *)&this[8]._os_unfair_lock_opaque + 8 * v17);
    if (!v18)
      goto LABEL_26;
    v19 = (_QWORD *)*v18;
    if (!v19)
      goto LABEL_26;
    while (1)
    {
      v20 = v19[1];
      if (v15 == v20)
        break;
      if (v16.u32[0] > 1uLL)
      {
        if (v20 >= *(_QWORD *)&v11)
          v20 %= *(_QWORD *)&v11;
      }
      else
      {
        v20 &= *(_QWORD *)&v11 - 1;
      }
      if (v20 != v17)
        goto LABEL_26;
LABEL_25:
      v19 = (_QWORD *)*v19;
      if (!v19)
        goto LABEL_26;
    }
    if (v19[2] != v12)
      goto LABEL_25;
    std::__hash_table<void const*,std::hash<void const*>,std::equal_to<void const*>,std::allocator<void const*>>::__emplace_unique_key_args<void const*,void const* const&>((uint64_t)&v35, v12, v12);
    v9 = *((_DWORD *)a2 + 8);
LABEL_26:
    if (v9 <= (int)v5 + 1)
      v21 = v5 + 1;
    else
      v21 = v9;
    while (1)
    {
      v8 = (v5 + 1);
      if (v21 - 1 == (_DWORD)v5)
        break;
      LODWORD(v5) = v5 + 1;
      v22 = v8;
      if ((*(_DWORD *)(*((_QWORD *)a2 + 2) + 200 * v8 + 8) & 0x80000000) != 0)
        goto LABEL_33;
    }
    v22 = v21;
LABEL_33:
    LODWORD(v5) = v22;
  }
  while ((_DWORD)v4 != v22);
LABEL_34:
  v23 = this + 48;
  v24 = (os_unfair_lock_s *)std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::find<void const*>(&this[48]._os_unfair_lock_opaque, (unint64_t)a2);
  if (v24)
  {
    v25 = *(int8x8_t *)&this[50]._os_unfair_lock_opaque;
    v26 = *(_QWORD *)&v24->_os_unfair_lock_opaque;
    v27 = *(_QWORD *)&v24[2]._os_unfair_lock_opaque;
    v28 = (uint8x8_t)vcnt_s8(v25);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      if (v27 >= *(_QWORD *)&v25)
        v27 %= *(_QWORD *)&v25;
    }
    else
    {
      v27 &= *(_QWORD *)&v25 - 1;
    }
    v29 = *(os_unfair_lock_s **)(*(_QWORD *)&v23->_os_unfair_lock_opaque + 8 * v27);
    do
    {
      v30 = v29;
      v29 = *(os_unfair_lock_s **)&v29->_os_unfair_lock_opaque;
    }
    while (v29 != v24);
    if (v30 == &this[52])
      goto LABEL_52;
    v31 = *(_QWORD *)&v30[2]._os_unfair_lock_opaque;
    if (v28.u32[0] > 1uLL)
    {
      if (v31 >= *(_QWORD *)&v25)
        v31 %= *(_QWORD *)&v25;
    }
    else
    {
      v31 &= *(_QWORD *)&v25 - 1;
    }
    if (v31 == v27)
    {
LABEL_54:
      if (v26)
      {
        v32 = *(_QWORD *)(v26 + 8);
        goto LABEL_56;
      }
    }
    else
    {
LABEL_52:
      if (!v26)
        goto LABEL_53;
      v32 = *(_QWORD *)(v26 + 8);
      if (v28.u32[0] > 1uLL)
      {
        v33 = *(_QWORD *)(v26 + 8);
        if (v32 >= *(_QWORD *)&v25)
          v33 = v32 % *(_QWORD *)&v25;
      }
      else
      {
        v33 = v32 & (*(_QWORD *)&v25 - 1);
      }
      if (v33 != v27)
      {
LABEL_53:
        *(_QWORD *)(*(_QWORD *)&v23->_os_unfair_lock_opaque + 8 * v27) = 0;
        v26 = *(_QWORD *)&v24->_os_unfair_lock_opaque;
        goto LABEL_54;
      }
LABEL_56:
      if (v28.u32[0] > 1uLL)
      {
        if (v32 >= *(_QWORD *)&v25)
          v32 %= *(_QWORD *)&v25;
      }
      else
      {
        v32 &= *(_QWORD *)&v25 - 1;
      }
      if (v32 != v27)
      {
        *(_QWORD *)(*(_QWORD *)&v23->_os_unfair_lock_opaque + 8 * v32) = v30;
        v26 = *(_QWORD *)&v24->_os_unfair_lock_opaque;
      }
    }
    *(_QWORD *)&v30->_os_unfair_lock_opaque = v26;
    *(_QWORD *)&v24->_os_unfair_lock_opaque = 0;
    --*(_QWORD *)&this[54]._os_unfair_lock_opaque;
    operator delete(v24);
  }
  std::unique_lock<re::UnfairLock>::unlock((uint64_t)&lock);
  for (i = (uint64_t **)v36; i; i = (uint64_t **)*i)
    re::TimebaseManager::removeLocallyControlledTimebaseFromTree(this, (OpaqueCMTimebase *)i[2], a2, 1);
  re::TimebaseManager::_afterFrameUpdate(this);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)&v35);
  if (v39)
    os_unfair_lock_unlock(lock);
}

_QWORD *re::TimebaseManager::copyReadOnlyClockOrTimebaseForID(os_unfair_lock_s *this, unint64_t a2)
{
  os_unfair_lock_s *v4;
  _QWORD *ClockOrTimebaseForID;
  CFTypeID v6;
  re *OnlyTimebase;
  int v8;
  NSObject *v9;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v4 = this + 6;
  os_unfair_lock_lock(this + 6);
  ClockOrTimebaseForID = re::TimebaseManager::findClockOrTimebaseForID((re::TimebaseManager *)this, a2);
  os_unfair_lock_unlock(v4);
  if (ClockOrTimebaseForID)
  {
    v6 = CFGetTypeID(ClockOrTimebaseForID);
    if (v6 == CMTimebaseGetTypeID())
    {
      OnlyTimebase = (re *)CMTimebaseCreateReadOnlyTimebase();
      if ((_DWORD)OnlyTimebase)
      {
        v8 = (int)OnlyTimebase;
        re::TimebaseLog(OnlyTimebase);
        v9 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v12 = "copyReadOnlyClockOrTimebaseForID";
          v13 = 1024;
          v14 = 1403;
          v15 = 1024;
          v16 = v8;
          _os_log_error_impl(&dword_224FE9000, v9, OS_LOG_TYPE_ERROR, "%s:%d error: %d", buf, 0x18u);
        }

      }
      return 0;
    }
    else
    {
      CFRetain(ClockOrTimebaseForID);
    }
  }
  return ClockOrTimebaseForID;
}

_QWORD *re::TimebaseManager::copyClockOrTimebaseForID(os_unfair_lock_s *this, unint64_t a2)
{
  os_unfair_lock_s *v4;
  _QWORD *ClockOrTimebaseForID;

  v4 = this + 6;
  os_unfair_lock_lock(this + 6);
  ClockOrTimebaseForID = re::TimebaseManager::findClockOrTimebaseForID((re::TimebaseManager *)this, a2);
  os_unfair_lock_unlock(v4);
  if (ClockOrTimebaseForID)
    CFRetain(ClockOrTimebaseForID);
  return ClockOrTimebaseForID;
}

BOOL re::TimebaseManager::isLocallyControlledClockOrTimebase(os_unfair_lock_s *this, unint64_t a2)
{
  os_unfair_lock_s *v4;
  _BOOL8 v5;

  v4 = this + 6;
  os_unfair_lock_lock(this + 6);
  v5 = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>(&this[28]._os_unfair_lock_opaque, a2) != 0;
  os_unfair_lock_unlock(v4);
  return v5;
}

void re::TimebaseManager::latestSeekTargetForTimebase(os_unfair_lock_s *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  os_unfair_lock_s *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  int8x8_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint8x8_t v15;
  unint64_t v16;
  _QWORD *v17;
  _QWORD *i;
  unint64_t v19;
  NSObject *v20;
  uint64_t v21;
  _QWORD *v22;
  const char *v23;
  int v24;
  unint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v6 = this + 6;
  os_unfair_lock_lock(this + 6);
  v7 = std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>(&this[38]._os_unfair_lock_opaque, a2);
  if (v7)
  {
    *(_OWORD *)a3 = *((_OWORD *)v7 + 2);
    v8 = v7[6];
  }
  else
  {
    v9 = (uint64_t)std::__hash_table<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,PhaseShapeAndMesh>>>::find<unsigned long long>(&this[28]._os_unfair_lock_opaque, a2);
    if (v9)
    {
      v10 = *(int8x8_t *)&this[20]._os_unfair_lock_opaque;
      if (v10)
      {
        v11 = *(_QWORD *)(v9 + 24);
        v12 = 0x9DDFEA08EB382D69 * (((8 * v11) + 8) ^ HIDWORD(v11));
        v13 = 0x9DDFEA08EB382D69 * (HIDWORD(v11) ^ (v12 >> 47) ^ v12);
        v14 = 0x9DDFEA08EB382D69 * (v13 ^ (v13 >> 47));
        v15 = (uint8x8_t)vcnt_s8(v10);
        v15.i16[0] = vaddlv_u8(v15);
        if (v15.u32[0] > 1uLL)
        {
          v16 = v14;
          if (v14 >= *(_QWORD *)&v10)
            v16 = v14 % *(_QWORD *)&v10;
        }
        else
        {
          v16 = v14 & (*(_QWORD *)&v10 - 1);
        }
        v17 = *(_QWORD **)(*(_QWORD *)&this[18]._os_unfair_lock_opaque + 8 * v16);
        if (v17)
        {
          for (i = (_QWORD *)*v17; i; i = (_QWORD *)*i)
          {
            v19 = i[1];
            if (v14 == v19)
            {
              if (i[2] == v11)
              {
                v22 = i + 6;
                while (1)
                {
                  v22 = (_QWORD *)*v22;
                  if (!v22)
                    break;
                  v9 = re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v22[2], a2);
                  if (v9)
                  {
                    if (!*(_BYTE *)(v9 + 144))
                      goto LABEL_22;
                    *(_OWORD *)a3 = *(_OWORD *)(v9 + 148);
                    v8 = *(_QWORD *)(v9 + 164);
                    goto LABEL_23;
                  }
                }
                re::TimebaseLog((re *)v9);
                v20 = objc_claimAutoreleasedReturnValue();
                if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
                  goto LABEL_21;
                v24 = 134217984;
                v25 = a2;
                v23 = "retrieving seek target for unused timebase %llu";
LABEL_29:
                _os_log_error_impl(&dword_224FE9000, v20, OS_LOG_TYPE_ERROR, v23, (uint8_t *)&v24, 0xCu);
                goto LABEL_21;
              }
            }
            else
            {
              if (v15.u32[0] > 1uLL)
              {
                if (v19 >= *(_QWORD *)&v10)
                  v19 %= *(_QWORD *)&v10;
              }
              else
              {
                v19 &= *(_QWORD *)&v10 - 1;
              }
              if (v19 != v16)
                break;
            }
          }
        }
      }
      re::TimebaseLog((re *)v9);
      v20 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        v24 = 134217984;
        v25 = a2;
        v23 = "retrieving seek target for un-referenced timebase %llu";
        goto LABEL_29;
      }
LABEL_21:

    }
LABEL_22:
    v21 = MEMORY[0x24BDC0D40];
    *(_OWORD *)a3 = *MEMORY[0x24BDC0D40];
    v8 = *(_QWORD *)(v21 + 16);
  }
LABEL_23:
  *(_QWORD *)(a3 + 16) = v8;
  os_unfair_lock_unlock(v6);
}

uint64_t re::TimebaseManager::engineTimebase(re::TimebaseManager *this)
{
  return (uint64_t)this + 232;
}

void ___ZL34AlignmentDifferenceUpdateThresholdv_block_invoke()
{
  void *v0;
  uint64_t v1;

  objc_msgSend(MEMORY[0x24BDBCF50], "standardUserDefaults");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "doubleForKey:", CFSTR("clockSyncUpdateThreshold"));
  qword_2541235C8 = v1;

  if (*(double *)&qword_2541235C8 == 0.0)
    qword_2541235C8 = 0x3F847AE147AE147BLL;
}

void std::__hash_table<std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::__unordered_map_hasher<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::hash<re::TimebaseTree *>,std::equal_to<re::TimebaseTree *>,true>,std::__unordered_map_equal<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::equal_to<re::TimebaseTree *>,std::hash<re::TimebaseTree *>,true>,std::allocator<std::__hash_value_type<re::TimebaseTree *,unsigned long long>>>::__node_insert_multi(uint64_t a1, _QWORD *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  float v9;
  float v10;
  _BOOL8 v11;
  unint64_t v12;
  unint64_t v13;
  int8x8_t prime;
  void *v15;
  void *v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  uint8x8_t v20;
  unint64_t v21;
  uint8x8_t v22;
  uint64_t v23;
  _QWORD *i;
  unint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  uint8x8_t v28;
  unint64_t v29;
  _QWORD *v30;
  int v31;
  _QWORD *v32;
  unint64_t v33;
  unint64_t v34;
  _BOOL4 v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  void *v39;

  v4 = a2[2];
  v5 = HIDWORD(v4);
  v6 = 0x9DDFEA08EB382D69 * (((8 * v4) + 8) ^ HIDWORD(v4));
  v7 = 0x9DDFEA08EB382D69
     * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
  a2[1] = v7;
  v8 = *(_QWORD *)(a1 + 8);
  v9 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v10 = *(float *)(a1 + 32);
  if (!v8 || (float)(v10 * (float)v8) < v9)
  {
    v11 = 1;
    if (v8 >= 3)
      v11 = (v8 & (v8 - 1)) != 0;
    v12 = v11 | (2 * v8);
    v13 = vcvtps_u32_f32(v9 / v10);
    if (v12 <= v13)
      prime = (int8x8_t)v13;
    else
      prime = (int8x8_t)v12;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v8 = *(_QWORD *)(a1 + 8);
    }
    if (*(_QWORD *)&prime > v8)
      goto LABEL_92;
    if (*(_QWORD *)&prime >= v8)
      goto LABEL_43;
    v21 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v8 < 3 || (v22 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v22.i16[0] = vaddlv_u8(v22), v22.u32[0] > 1uLL))
    {
      v21 = std::__next_prime(v21);
    }
    else
    {
      v23 = 1 << -(char)__clz(v21 - 1);
      if (v21 >= 2)
        v21 = v23;
    }
    if (*(_QWORD *)&prime <= v21)
      prime = (int8x8_t)v21;
    if (*(_QWORD *)&prime >= v8)
    {
      v8 = *(_QWORD *)(a1 + 8);
      goto LABEL_43;
    }
    if (prime)
    {
LABEL_92:
      if (*(_QWORD *)&prime >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v15 = operator new(8 * *(_QWORD *)&prime);
      v16 = *(void **)a1;
      *(_QWORD *)a1 = v15;
      if (v16)
        operator delete(v16);
      v17 = 0;
      *(int8x8_t *)(a1 + 8) = prime;
      do
        *(_QWORD *)(*(_QWORD *)a1 + 8 * v17++) = 0;
      while (*(_QWORD *)&prime != v17);
      v18 = *(_QWORD **)(a1 + 16);
      if (v18)
      {
        v19 = v18[1];
        v20 = (uint8x8_t)vcnt_s8(prime);
        v20.i16[0] = vaddlv_u8(v20);
        if (v20.u32[0] > 1uLL)
        {
          if (v19 >= *(_QWORD *)&prime)
            v19 %= *(_QWORD *)&prime;
        }
        else
        {
          v19 &= *(_QWORD *)&prime - 1;
        }
        *(_QWORD *)(*(_QWORD *)a1 + 8 * v19) = a1 + 16;
        for (i = (_QWORD *)*v18; *v18; i = (_QWORD *)*v18)
        {
          v25 = i[1];
          if (v20.u32[0] > 1uLL)
          {
            if (v25 >= *(_QWORD *)&prime)
              v25 %= *(_QWORD *)&prime;
          }
          else
          {
            v25 &= *(_QWORD *)&prime - 1;
          }
          if (v25 == v19)
          {
            v18 = i;
          }
          else
          {
            v26 = i;
            if (*(_QWORD *)(*(_QWORD *)a1 + 8 * v25))
            {
              do
              {
                v27 = v26;
                v26 = (_QWORD *)*v26;
              }
              while (v26 && i[2] == v26[2]);
              *v18 = v26;
              *v27 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v25);
              **(_QWORD **)(*(_QWORD *)a1 + 8 * v25) = i;
            }
            else
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = v18;
              v18 = i;
              v19 = v25;
            }
          }
        }
      }
      v8 = (unint64_t)prime;
    }
    else
    {
      v39 = *(void **)a1;
      *(_QWORD *)a1 = 0;
      if (v39)
        operator delete(v39);
      v8 = 0;
      *(_QWORD *)(a1 + 8) = 0;
    }
  }
LABEL_43:
  v28 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
  v28.i16[0] = vaddlv_u8(v28);
  if (v28.u32[0] > 1uLL)
  {
    v29 = v7;
    if (v8 <= v7)
      v29 = v7 % v8;
  }
  else
  {
    v29 = (v8 - 1) & v7;
  }
  v30 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v29);
  if (v30)
  {
    v31 = 0;
    do
    {
      v32 = v30;
      v30 = (_QWORD *)*v30;
      if (!v30)
        break;
      v33 = v30[1];
      if (v28.u32[0] > 1uLL)
      {
        v34 = v30[1];
        if (v33 >= v8)
          v34 = v33 % v8;
      }
      else
      {
        v34 = v33 & (v8 - 1);
      }
      if (v34 != v29)
        break;
      v35 = v33 == v7 && v30[2] == a2[2];
      v36 = v31 & !v35;
      v31 |= v35;
    }
    while (v36 != 1);
  }
  else
  {
    v32 = 0;
  }
  v37 = a2[1];
  if (v28.u32[0] > 1uLL)
  {
    if (v37 >= v8)
      v37 %= v8;
  }
  else
  {
    v37 &= v8 - 1;
  }
  if (!v32)
  {
    *a2 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = a2;
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v37) = a1 + 16;
    if (!*a2)
      goto LABEL_79;
    v38 = *(_QWORD *)(*a2 + 8);
    if (v28.u32[0] > 1uLL)
    {
      if (v38 >= v8)
        v38 %= v8;
    }
    else
    {
      v38 &= v8 - 1;
    }
LABEL_78:
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v38) = a2;
    goto LABEL_79;
  }
  *a2 = *v32;
  *v32 = a2;
  if (*a2)
  {
    v38 = *(_QWORD *)(*a2 + 8);
    if (v28.u32[0] > 1uLL)
    {
      if (v38 >= v8)
        v38 %= v8;
    }
    else
    {
      v38 &= v8 - 1;
    }
    if (v38 != v37)
      goto LABEL_78;
  }
LABEL_79:
  ++*(_QWORD *)(a1 + 24);
}

_QWORD *re::IntrospectionHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::~IntrospectionHashTable(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_24ED202D8;
  v2 = a1 + 6;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 8);
  re::SerializedReference<re::IntrospectionBase const*>::reset(v2);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  return a1;
}

void re::IntrospectionHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::~IntrospectionHashTable(_QWORD *a1)
{
  _QWORD *v2;

  *a1 = &off_24ED202D8;
  v2 = a1 + 6;
  re::SerializedReference<re::IntrospectionBase const*>::reset(a1 + 8);
  re::SerializedReference<re::IntrospectionBase const*>::reset(v2);
  *a1 = &off_24ED426B8;
  objc_destructInstance(a1 + 1);
  JUMPOUT(0x2276933B8);
}

double re::IntrospectionHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::construct(uint64_t a1, uint64_t a2)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_DWORD *)(a2 + 36) = 0x7FFFFFFF;
  return result;
}

double re::IntrospectionHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::destroy(uint64_t a1, uint64_t *a2)
{
  return re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(a2);
}

void re::IntrospectionHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4)
{
  signed int v7;

  re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(a2);
  if (a4 <= 3)
    v7 = 3;
  else
    v7 = a4;
  re::HashTable<re::CachedStandardVertexFetchFunctionKey,re::SharedPtr<re::CachedVertexFetchFunction>,re::Hash<re::CachedStandardVertexFetchFunctionKey>,re::EqualTo<re::CachedStandardVertexFetchFunctionKey>,true,false>::init((uint64_t)a2, a3, v7);
}

void re::IntrospectionHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, uint64_t a2, unsigned int a3)
{
  re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a2, a3);
}

uint64_t re::IntrospectionHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::size(uint64_t a1, uint64_t a2)
{
  return *(unsigned int *)(a2 + 28);
}

void re::IntrospectionHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(uint64_t a1, uint64_t a2)
{
  re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a2);
}

re::IntrospectionBase *re::IntrospectionHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addElement(uint64_t a1, re *a2, int a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  re::IntrospectionBase *v12;
  __int128 v14[2];
  _BYTE v15[32];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _OWORD v19[4];

  *(_OWORD *)&v15[16] = 0u;
  memset(v19, 0, sizeof(v19));
  v17 = 0u;
  v18 = 0u;
  v16 = 0u;
  memset(v14, 0, sizeof(v14));
  *(_OWORD *)v15 = 0x3FF0000000000000uLL;
  *(_OWORD *)&v15[8] = *MEMORY[0x24BDC0D88];
  *(_QWORD *)&v15[24] = *(_QWORD *)(MEMORY[0x24BDC0D88] + 16);
  v8 = *(_QWORD *)(MEMORY[0x24BDC0D88] + 16);
  v16 = *MEMORY[0x24BDC0D88];
  *(_QWORD *)&v17 = v8;
  *((_QWORD *)&v17 + 1) = 0x3FF0000000000000;
  v9 = *MEMORY[0x24BDC0D88];
  *(_QWORD *)&v19[0] = *(_QWORD *)(MEMORY[0x24BDC0D88] + 16);
  v18 = v9;
  v10 = *MEMORY[0x24BDC0D88];
  *((_QWORD *)&v19[1] + 1) = *(_QWORD *)(MEMORY[0x24BDC0D88] + 16);
  *(_OWORD *)((char *)v19 + 8) = v10;
  v11 = *MEMORY[0x24BDC0D88];
  *(_QWORD *)((char *)&v19[3] + 4) = *(_QWORD *)(MEMORY[0x24BDC0D88] + 16);
  *(_OWORD *)((char *)&v19[2] + 4) = v11;
  v12 = (re::IntrospectionBase *)re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace(a4, a5, v14);
  re::introspectionInitElement(a2, a3, *(re::Allocator **)(a1 + 64), v12);
  return v12;
}

uint64_t re::IntrospectionHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::iterate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int v8;
  uint64_t result;
  uint64_t v10;
  int v11;
  int v12;

  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    v7 = (int *)(*(_QWORD *)(a2 + 16) + 8);
    while (1)
    {
      v8 = *v7;
      v7 += 50;
      if (v8 < 0)
        break;
      if (v5 == ++v6)
      {
        LODWORD(v6) = *(_DWORD *)(a2 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if ((_DWORD)v5 == (_DWORD)v6)
    return 1;
  v10 = v6;
  do
  {
    result = std::function<BOOL ()(void const*,void *)>::operator()(a3, *(_QWORD *)(a2 + 16) + 200 * v10 + 16, *(_QWORD *)(a2 + 16) + 200 * v10 + 24);
    if (!(_DWORD)result)
      break;
    v11 = *(_DWORD *)(a2 + 32) <= (v6 + 1) ? v6 + 1 : *(_DWORD *)(a2 + 32);
    while (1)
    {
      v10 = (v6 + 1);
      if (v11 - 1 == (_DWORD)v6)
        break;
      LODWORD(v6) = v6 + 1;
      v12 = v10;
      if ((*(_DWORD *)(*(_QWORD *)(a2 + 16) + 200 * v10 + 8) & 0x80000000) != 0)
        goto LABEL_18;
    }
    v12 = v11;
LABEL_18:
    LODWORD(v6) = v12;
  }
  while ((_DWORD)v5 != v12);
  return result;
}

void re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  signed int v13;
  _BYTE v14[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v14, 0, 36);
      *(_QWORD *)&v14[36] = 0x7FFFFFFFLL;
      re::HashTable<re::CachedStandardVertexFetchFunctionKey,re::SharedPtr<re::CachedVertexFetchFunction>,re::Hash<re::CachedStandardVertexFetchFunctionKey>,re::EqualTo<re::CachedStandardVertexFetchFunctionKey>,true,false>::init((uint64_t)v14, v4, a2);
      v5 = *(_OWORD *)v14;
      *(_OWORD *)v14 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v14[16];
      v7 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)&v14[16] = v7;
      *(_QWORD *)(a1 + 16) = v6;
      v9 = *(_OWORD *)&v14[24];
      *(_OWORD *)&v14[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v14[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = v7 + 16;
        do
        {
          if ((*(_DWORD *)(v12 - 8) & 0x80000000) != 0)
            re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(_QWORD *)(v12 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v12 - 16), v12, v12 + 8);
          ++v11;
          v12 += 200;
        }
        while (v11 < v10);
      }
      re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v14);
    }
  }
  else
  {
    if (a2)
      v13 = a2;
    else
      v13 = 3;
  }
}

uint64_t re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, __int128 *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 200 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 200 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  v13 = 200 * v9;
  *(_DWORD *)(v11 + v13 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v13 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + v13 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v13) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v13 + 16) = *a4;
  v14 = *(_QWORD *)(a1 + 16) + v13;
  v16 = *a5;
  v15 = a5[1];
  *(_OWORD *)(v14 + 56) = a5[2];
  v18 = a5[5];
  v17 = a5[6];
  v19 = a5[4];
  *(_OWORD *)(v14 + 72) = a5[3];
  *(_OWORD *)(v14 + 88) = v19;
  *(_OWORD *)(v14 + 104) = v18;
  *(_OWORD *)(v14 + 120) = v17;
  v21 = a5[9];
  v20 = a5[10];
  v22 = a5[8];
  *(_OWORD *)(v14 + 136) = a5[7];
  *(_OWORD *)(v14 + 152) = v22;
  *(_OWORD *)(v14 + 168) = v21;
  *(_OWORD *)(v14 + 184) = v20;
  *(_OWORD *)(v14 + 24) = v16;
  *(_OWORD *)(v14 + 40) = v15;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_2260EB7B0, 4 * v2);
    v3 = *(_DWORD *)(a1 + 32);
    if (v3)
    {
      v4 = 0;
      v5 = 200 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 200;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

uint64_t re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace(uint64_t a1, uint64_t *a2, __int128 *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  unsigned int v22;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v22 = re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v21 = *(_QWORD *)(a1 + 16) + 200 * v22;
    return v21 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 200 * v10 + 16) != v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 200 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + 200 * v10;
  v13 = *a3;
  v14 = a3[1];
  *(_OWORD *)(v12 + 56) = a3[2];
  *(_OWORD *)(v12 + 40) = v14;
  *(_OWORD *)(v12 + 24) = v13;
  v15 = a3[3];
  v16 = a3[4];
  v17 = a3[5];
  *(_OWORD *)(v12 + 120) = a3[6];
  *(_OWORD *)(v12 + 104) = v17;
  *(_OWORD *)(v12 + 88) = v16;
  *(_OWORD *)(v12 + 72) = v15;
  v18 = a3[7];
  v19 = a3[8];
  v20 = a3[9];
  *(_OWORD *)(v12 + 180) = *(__int128 *)((char *)a3 + 156);
  *(_OWORD *)(v12 + 168) = v20;
  *(_OWORD *)(v12 + 152) = v19;
  *(_OWORD *)(v12 + 136) = v18;
  ++*(_DWORD *)(a1 + 40);
  v21 = *(_QWORD *)(a1 + 16) + 200 * v10;
  return v21 + 24;
}

void re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
  re::HashTable<re::CachedStandardVertexFetchFunctionKey,re::SharedPtr<re::CachedVertexFetchFunction>,re::Hash<re::CachedStandardVertexFetchFunctionKey>,re::EqualTo<re::CachedStandardVertexFetchFunctionKey>,true,false>::init(a1, a3, 3);
}

double re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#2}::__invoke(uint64_t *a1)
{
  re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(a1);
  return re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(a1);
}

uint64_t re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return *(unsigned int *)(a1 + 28);
}

void re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *)#1}::__invoke(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (*a1 == a3)
  {
    re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear((uint64_t)a1);
  }
  else
  {
    re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(a1);
    re::HashTable<re::CachedStandardVertexFetchFunctionKey,re::SharedPtr<re::CachedVertexFetchFunction>,re::Hash<re::CachedStandardVertexFetchFunctionKey>,re::EqualTo<re::CachedStandardVertexFetchFunctionKey>,true,false>::init((uint64_t)a1, a3, 3);
  }
}

uint64_t re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::TypeInfo const&,re::Allocator *,void *)#3}::__invoke(uint64_t a1, _QWORD **a2, re::Allocator *a3, uint64_t *a4)
{
  __int128 *Instance;
  uint64_t v9;
  _BYTE v11[32];
  _BYTE v12[8];
  _BYTE v13[32];

  re::TypeRegistry::typeInfo(*a2, a2[2][10], v12);
  re::TypeInfo::TypeInfo((uint64_t)v11, (uint64_t)v13);
  Instance = (__int128 *)re::TypeInfo::createInstance((re::TypeInfo *)v11, a3, 0);
  v9 = re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addOrReplace(a1, a4, Instance);
  re::TypeRegistry::typeInfo(*a2, a2[2][10], v12);
  re::TypeInfo::TypeInfo((uint64_t)v11, (uint64_t)v13);
  re::TypeInfo::releaseInstance((re::TypeInfo *)v11, Instance, a3, 0);
  return v9;
}

uint64_t re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,void const*)#1}::__invoke(uint64_t a1, unint64_t *a2)
{
  return re::HashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1, *a2);
}

uint64_t re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 40, 8);
  *(_QWORD *)result = a1;
  *(_DWORD *)(result + 8) = *(_DWORD *)(a1 + 40);
  *(_BYTE *)(result + 16) = 0;
  return result;
}

uint64_t re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#2}::__invoke(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int *v6;
  int v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  uint64_t result;

  v2 = *a1;
  if (*((_DWORD *)a1 + 2) == *(_DWORD *)(*a1 + 40))
  {
    v3 = *(unsigned int *)(v2 + 32);
    if (*((_BYTE *)a1 + 16))
    {
      v4 = *((_DWORD *)a1 + 8);
      if (v4 == (_DWORD)v3)
      {
        LODWORD(v5) = *(_DWORD *)(v2 + 32);
      }
      else
      {
        v8 = a1[3];
        v9 = *(_DWORD *)(v8 + 32);
        v10 = v4 + 1;
        do
        {
          LODWORD(v5) = v10;
          *((_DWORD *)a1 + 8) = v10;
          if (v10 >= v9)
            break;
          v11 = *(_DWORD *)(*(_QWORD *)(v8 + 16) + 200 * v10++ + 8);
        }
        while ((v11 & 0x80000000) == 0);
      }
    }
    else
    {
      v5 = 0;
      if ((_DWORD)v3)
      {
        v6 = (int *)(*(_QWORD *)(v2 + 16) + 8);
        while (1)
        {
          v7 = *v6;
          v6 += 50;
          if (v7 < 0)
            break;
          if (v3 == ++v5)
          {
            LODWORD(v5) = *(_DWORD *)(v2 + 32);
            break;
          }
        }
      }
      *((_BYTE *)a1 + 16) = 1;
      a1[3] = v2;
      a1[4] = v5;
      LODWORD(v3) = *(_DWORD *)(v2 + 32);
    }
    return (_DWORD)v5 != (_DWORD)v3;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) HashTable entries may not be added or removed during iteration.", "iter->originalVersion == iter->hashTable->version()", "operator()", 583);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#3}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(*(_QWORD *)a1 + 40))
    return *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16) + 200 * *(unsigned int *)(a1 + 32) + 16;
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) HashTable entries may not be added or removed during iteration.", "iter->originalVersion == iter->hashTable->version()", "operator()", 598);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *)#4}::__invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(_DWORD *)(a1 + 8) == *(_DWORD *)(*(_QWORD *)a1 + 40))
    return *(_QWORD *)(*(_QWORD *)(a1 + 24) + 16) + 200 * *(unsigned int *)(a1 + 32) + 24;
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) HashTable entries may not be added or removed during iteration.", "iter->originalVersion == iter->hashTable->version()", "operator()", 607);
  result = _os_crash();
  __break(1u);
  return result;
}

uint64_t re::TypeBuilderHelper::registerHashTable<unsigned long long,re::ClockOrTimebase,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>(re::TypeRegistry *,re::StringID const&,re::TypeID const&,re::TypeID const&)::{lambda(void *,re::Allocator *)#2}::__invoke(_DWORD *a1, uint64_t a2)
{
  uint64_t result;

  if (a1[2] == *(_DWORD *)(*(_QWORD *)a1 + 40))
    return (*(uint64_t (**)(uint64_t, _DWORD *))(*(_QWORD *)a2 + 40))(a2, a1);
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) HashTable entries may not be added or removed during iteration.", "iter->originalVersion == iter->hashTable->version()", "operator()", 616);
  result = _os_crash();
  __break(1u);
  return result;
}

id re::internal::defaultRetain<re::TimebaseService>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return (id)(a1 + 8);
}

void re::internal::defaultRelease<re::TimebaseService>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{

}

uint64_t re::Event<re::SharedClockService,OpaqueCMClock *,OpaqueCMClock *,unsigned long long>::createSubscription<re::TimebaseManager>(re::TimebaseManager *,REEventHandlerResult (re::TimebaseManager::*)(re::SharedClockService*,OpaqueCMClock *,OpaqueCMClock *,unsigned long long))::{lambda(re::SharedClockService*,re::Event<re::SharedClockService,OpaqueCMClock *,OpaqueCMClock *,unsigned long long>::Subscription const&,OpaqueCMClock *&&,OpaqueCMClock *&,unsigned long long &&)#1}::__invoke(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t (*v6)(_QWORD *, uint64_t, _QWORD, _QWORD, _QWORD);
  uint64_t v7;
  _QWORD *v8;

  v6 = (uint64_t (*)(_QWORD *, uint64_t, _QWORD, _QWORD, _QWORD))a2[1];
  v7 = a2[2];
  v8 = (_QWORD *)(*a2 + (v7 >> 1));
  if ((v7 & 1) != 0)
    v6 = *(uint64_t (**)(_QWORD *, uint64_t, _QWORD, _QWORD, _QWORD))(*v8 + v6);
  return v6(v8, a1, *a3, *a4, *a5);
}

_QWORD *std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::find<void const*>(_QWORD *a1, unint64_t a2)
{
  int8x8_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *result;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v3 >> 47) ^ v3);
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = v5;
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = (*(_QWORD *)&v2 - 1) & v5;
  }
  v8 = *(_QWORD **)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  result = (_QWORD *)*v8;
  if (*v8)
  {
    do
    {
      v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == a2)
          return result;
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(_QWORD *)&v2)
            v10 %= *(_QWORD *)&v2;
        }
        else
        {
          v10 &= *(_QWORD *)&v2 - 1;
        }
        if (v10 != v7)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,void const*>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void const*>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void const*>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void const*>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD **v9;
  _QWORD *i;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = *v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = a2;
  i[2] = *a3;
  i[3] = 0;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2)
        v3 = a2 % v7;
      else
        v3 = a2;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *i = *v19;
LABEL_38:
    *v19 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v20 = *(_QWORD *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)v1 + 32);
    operator delete(v1);
  }
}

void std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::__erase_unique<void const*>(_QWORD *a1, unint64_t a2)
{
  _QWORD *v3;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD v13[2];
  char v14;

  v3 = std::__hash_table<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>>>::find<void const*>(a1, a2);
  if (v3)
  {
    v4 = (int8x8_t)a1[1];
    v5 = v3[1];
    v6 = (uint8x8_t)vcnt_s8(v4);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      if (v5 >= *(_QWORD *)&v4)
        v5 %= *(_QWORD *)&v4;
    }
    else
    {
      v5 &= *(_QWORD *)&v4 - 1;
    }
    v7 = *(_QWORD **)(*a1 + 8 * v5);
    do
    {
      v8 = v7;
      v7 = (_QWORD *)*v7;
    }
    while (v7 != v3);
    if (v8 == a1 + 2)
      goto LABEL_19;
    v9 = v8[1];
    if (v6.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v4)
        v9 %= *(_QWORD *)&v4;
    }
    else
    {
      v9 &= *(_QWORD *)&v4 - 1;
    }
    if (v9 != v5)
    {
LABEL_19:
      if (!*v3)
        goto LABEL_20;
      v10 = *(_QWORD *)(*v3 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(_QWORD *)&v4)
          v10 %= *(_QWORD *)&v4;
      }
      else
      {
        v10 &= *(_QWORD *)&v4 - 1;
      }
      if (v10 != v5)
LABEL_20:
        *(_QWORD *)(*a1 + 8 * v5) = 0;
    }
    v11 = *v3;
    if (*v3)
    {
      v12 = *(_QWORD *)(v11 + 8);
      if (v6.u32[0] > 1uLL)
      {
        if (v12 >= *(_QWORD *)&v4)
          v12 %= *(_QWORD *)&v4;
      }
      else
      {
        v12 &= *(_QWORD *)&v4 - 1;
      }
      if (v12 != v5)
      {
        *(_QWORD *)(*a1 + 8 * v12) = v8;
        v11 = *v3;
      }
    }
    *v8 = v11;
    *v3 = 0;
    --a1[3];
    v13[0] = v3;
    v13[1] = a1 + 2;
    v14 = 1;
    std::unique_ptr<std::__hash_node<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void const*,re::TimebaseManager::ClockOrTimebaseRefCount>,void *>>>>::reset[abi:nn180100]((uint64_t)v13);
  }
}

void std::__hash_table<OpaqueCMTimebase *,std::hash<OpaqueCMTimebase *>,std::equal_to<OpaqueCMTimebase *>,std::allocator<OpaqueCMTimebase *>>::__emplace_unique_key_args<OpaqueCMTimebase *,OpaqueCMTimebase *>(float *a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD *v11;
  _QWORD *i;
  unint64_t v13;
  _QWORD *v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  int8x8_t prime;
  void *v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;
  uint8x8_t v26;
  unint64_t v27;
  uint8x8_t v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  unint64_t v34;
  _QWORD *v35;

  v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *((_QWORD *)a1 + 1);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
    v11 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      for (i = (_QWORD *)*v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == a2)
            return;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3)
            break;
        }
      }
    }
  }
  v14 = operator new(0x18uLL);
  *v14 = 0;
  v14[1] = v8;
  v14[2] = a3;
  v15 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v16 = a1[8];
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    v17 = 1;
    if (v9 >= 3)
      v17 = (v9 & (v9 - 1)) != 0;
    v18 = v17 | (2 * v9);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      prime = (int8x8_t)v19;
    else
      prime = (int8x8_t)v18;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v9 = *((_QWORD *)a1 + 1);
    }
    if (*(_QWORD *)&prime > v9)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v9)
    {
      v27 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v9 < 3 || (v28 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
      {
        v27 = std::__next_prime(v27);
      }
      else
      {
        v29 = 1 << -(char)__clz(v27 - 1);
        if (v27 >= 2)
          v27 = v29;
      }
      if (*(_QWORD *)&prime <= v27)
        prime = (int8x8_t)v27;
      if (*(_QWORD *)&prime >= v9)
      {
        v9 = *((_QWORD *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v21 = operator new(8 * *(_QWORD *)&prime);
          v22 = *(_QWORD **)a1;
          *(_QWORD *)a1 = v21;
          if (v22)
            operator delete(v22);
          v23 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v23++) = 0;
          while (*(_QWORD *)&prime != v23);
          v24 = (_QWORD *)*((_QWORD *)a1 + 2);
          if (v24)
          {
            v25 = v24[1];
            v26 = (uint8x8_t)vcnt_s8(prime);
            v26.i16[0] = vaddlv_u8(v26);
            if (v26.u32[0] > 1uLL)
            {
              if (v25 >= *(_QWORD *)&prime)
                v25 %= *(_QWORD *)&prime;
            }
            else
            {
              v25 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v25) = a1 + 4;
            v30 = (_QWORD *)*v24;
            if (*v24)
            {
              do
              {
                v31 = v30[1];
                if (v26.u32[0] > 1uLL)
                {
                  if (v31 >= *(_QWORD *)&prime)
                    v31 %= *(_QWORD *)&prime;
                }
                else
                {
                  v31 &= *(_QWORD *)&prime - 1;
                }
                if (v31 != v25)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v31))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v31) = v24;
                    goto LABEL_55;
                  }
                  *v24 = *v30;
                  *v30 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v31);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v31) = v30;
                  v30 = v24;
                }
                v31 = v25;
LABEL_55:
                v24 = v30;
                v30 = (_QWORD *)*v30;
                v25 = v31;
              }
              while (v30);
            }
          }
          v9 = (unint64_t)prime;
          goto LABEL_59;
        }
        v35 = *(_QWORD **)a1;
        *(_QWORD *)a1 = 0;
        if (v35)
          operator delete(v35);
        v9 = 0;
        *((_QWORD *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v32 = *(_QWORD **)a1;
  v33 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v33)
  {
    *v14 = *v33;
LABEL_72:
    *v33 = v14;
    goto LABEL_73;
  }
  *v14 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v14;
  v32[v3] = a1 + 4;
  if (*v14)
  {
    v34 = *(_QWORD *)(*v14 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v34 >= v9)
        v34 %= v9;
    }
    else
    {
      v34 &= v9 - 1;
    }
    v33 = (_QWORD *)(*(_QWORD *)a1 + 8 * v34);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
}

void re::HashTable<re::TimebaseTree *,void({block_pointer} {__strong})(re::TimebaseTree *),re::Hash<re::TimebaseTree *>,re::EqualTo<re::TimebaseTree *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  signed int v22;
  _BYTE v23[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v23, 0, 36);
      *(_QWORD *)&v23[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphNode>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v23, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v23;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v23[8];
      *(_OWORD *)v23 = v5;
      *(_QWORD *)&v23[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v23[24];
      *(_OWORD *)&v23[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v23[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = v6 + 16;
        do
        {
          if ((*(_DWORD *)(v13 - 8) & 0x80000000) != 0)
          {
            v14 = *(_QWORD *)(v13 - 16);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashTable<re::TimebaseTree *,void({block_pointer} {__strong})(re::TimebaseTree *),re::Hash<re::TimebaseTree *>,re::EqualTo<re::TimebaseTree *>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 32 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17) = v14;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 16) = *(_QWORD *)v13;
            v21 = *(_QWORD *)(a1 + 16) + 32 * v17;
            *(_QWORD *)(v21 + 24) = _Block_copy(*(const void **)(v13 + 8));
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 32;
          --v10;
        }
        while (v10);
      }
      re::HashTable<unsigned long long,void({block_pointer} {__strong})(unsigned long long,REAudioPlaybackState,REAudioPlaybackState),re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v23);
    }
  }
  else
  {
    if (a2)
      v22 = a2;
    else
      v22 = 3;
  }
}

char *std::__hash_table<std::__hash_value_type<unsigned long long,re::TimebaseManager::ExternallyControlledTimebase>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::TimebaseManager::ExternallyControlledTimebase>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::TimebaseManager::ExternallyControlledTimebase>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::TimebaseManager::ExternallyControlledTimebase>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  char *v10;
  unint64_t v11;
  _OWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = (char *)*v9;
      if (*v9)
      {
        do
        {
          v11 = *((_QWORD *)v10 + 1);
          if (v11 == a2)
          {
            if (*((_QWORD *)v10 + 2) == a2)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = *(char **)v10;
        }
        while (v10);
      }
    }
  }
  v10 = (char *)operator new(0x40uLL);
  *(_QWORD *)v10 = 0;
  *((_QWORD *)v10 + 1) = a2;
  *((_QWORD *)v10 + 2) = *a3;
  *(_OWORD *)(v10 + 40) = 0u;
  *(_OWORD *)(v10 + 24) = 0u;
  v12 = (_OWORD *)MEMORY[0x24BDC0D88];
  *((_QWORD *)v10 + 6) = *(_QWORD *)(MEMORY[0x24BDC0D88] + 16);
  *((_QWORD *)v10 + 7) = 0;
  *((_OWORD *)v10 + 2) = *v12;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    v15 = 1;
    if (v7 >= 3)
      v15 = (v7 & (v7 - 1)) != 0;
    v16 = v15 | (2 * v7);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>(a1, v18);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2)
        v3 = a2 % v7;
      else
        v3 = a2;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v20)
  {
    *(_QWORD *)v10 = *v20;
LABEL_38:
    *v20 = v10;
    goto LABEL_39;
  }
  *(_QWORD *)v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v19 + 8 * v3) = a1 + 16;
  if (*(_QWORD *)v10)
  {
    v21 = *(_QWORD *)(*(_QWORD *)v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v21 >= v7)
        v21 %= v7;
    }
    else
    {
      v21 &= v7 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

_QWORD *std::__hash_table<std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::__unordered_map_hasher<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::hash<re::TimebaseTree *>,std::equal_to<re::TimebaseTree *>,true>,std::__unordered_map_equal<re::TimebaseTree *,std::__hash_value_type<re::TimebaseTree *,unsigned long long>,std::equal_to<re::TimebaseTree *>,std::hash<re::TimebaseTree *>,true>,std::allocator<std::__hash_value_type<re::TimebaseTree *,unsigned long long>>>::__emplace_unique_key_args<re::TimebaseTree *,std::piecewise_construct_t const&,std::tuple<re::TimebaseTree * const&>,std::tuple<>>(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD **v11;
  _QWORD *i;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
    v11 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      for (i = *v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == a2)
            return i;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v8;
  i[2] = *a3;
  i[3] = 0;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    v16 = 1;
    if (v9 >= 3)
      v16 = (v9 & (v9 - 1)) != 0;
    v17 = v16 | (2 * v9);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>(a1, v19);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *i = *v21;
LABEL_38:
    *v21 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v20 + 8 * v3) = a1 + 16;
  if (*i)
  {
    v22 = *(_QWORD *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9)
        v22 %= v9;
    }
    else
    {
      v22 &= v9 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void std::__hash_table<void const*,std::hash<void const*>,std::equal_to<void const*>,std::allocator<void const*>>::__emplace_unique_key_args<void const*,void const* const&>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  _QWORD *v11;
  _QWORD *i;
  unint64_t v13;
  _QWORD *v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;

  v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
    v11 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      for (i = (_QWORD *)*v11; i; i = (_QWORD *)*i)
      {
        v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == a2)
            return;
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9)
              v13 %= v9;
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v3)
            break;
        }
      }
    }
  }
  v14 = operator new(0x18uLL);
  *v14 = 0;
  v14[1] = v8;
  v14[2] = a3;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    v17 = 1;
    if (v9 >= 3)
      v17 = (v9 & (v9 - 1)) != 0;
    v18 = v17 | (2 * v9);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>(a1, v20);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v21 = *(_QWORD *)a1;
  v22 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v22)
  {
    *v14 = *v22;
LABEL_38:
    *v22 = v14;
    goto LABEL_39;
  }
  *v14 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v14;
  *(_QWORD *)(v21 + 8 * v3) = a1 + 16;
  if (*v14)
  {
    v23 = *(_QWORD *)(*v14 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v23 >= v9)
        v23 %= v9;
    }
    else
    {
      v23 &= v9 - 1;
    }
    v22 = (_QWORD *)(*(_QWORD *)a1 + 8 * v23);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
}

void re::TraceDelta::sort(re::TraceDelta *this)
{
  uint64_t v1;
  int64_t v2;
  __n128 *v3;
  uint64_t v4;
  char v5;

  v1 = *((_QWORD *)this + 6);
  v2 = *((_QWORD *)this + 4);
  if (v2 <= 0)
  {
    std::__stable_sort<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>(*((_QWORD *)this + 6), (__n128 *)(v1 + (v2 << 6)), (uint64_t)&v5, v2, 0, 0);
  }
  else
  {
    v3 = (__n128 *)std::get_temporary_buffer[abi:nn180100]<re::TraceEntry>(*((_QWORD *)this + 4));
    std::__stable_sort<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>(v1, (__n128 *)(v1 + (v2 << 6)), (uint64_t)&v5, v2, v3, v4);
    if (v3)
      operator delete(v3);
  }
}

_QWORD *re::TraceDelta::reduce(_QWORD *this)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  __int128 v11;
  __int16 v12;
  _QWORD v13[5];

  v1 = this[4];
  if (v1)
  {
    v2 = this;
    v3 = this + 2;
    v4 = this[6];
    if (v1 == 1)
    {
      v5 = this[6];
    }
    else
    {
      v6 = v4 + 64;
      do
      {
        if (*(_BYTE *)(v4 + 16))
        {
          if (*(_QWORD *)v4 == *(_QWORD *)v6 && *(_QWORD *)(v4 + 8) == *(_QWORD *)(v6 + 8))
          {
            re::TraceDelta::merge((uint64_t)this, v4, v6);
            *(_WORD *)(v4 + 16) = v12;
            *(_OWORD *)v4 = v11;
            re::DynamicArray<re::internal::DeferredUnregister *>::operator=(v4 + 24, (uint64_t)v13);
            this = (_QWORD *)v13[0];
            if (v13[0] && v13[4])
              this = (_QWORD *)(*(uint64_t (**)(void))(*(_QWORD *)v13[0] + 40))();
          }
          else
          {
            if (v6 - 64 != v4)
            {
              v8 = *(_OWORD *)v6;
              *(_WORD *)(v4 + 80) = *(_WORD *)(v6 + 16);
              *(_OWORD *)(v4 + 64) = v8;
              this = (_QWORD *)re::DynamicArray<re::internal::DeferredUnregister *>::operator=(v4 + 88, v6 + 24);
            }
            v4 += 64;
          }
        }
        else
        {
          v9 = *(_OWORD *)v6;
          *(_WORD *)(v4 + 16) = *(_WORD *)(v6 + 16);
          *(_OWORD *)v4 = v9;
          this = (_QWORD *)re::DynamicArray<re::internal::DeferredUnregister *>::operator=(v4 + 24, v6 + 24);
        }
        v6 += 64;
        v5 = v2[6];
      }
      while (v6 != v5 + (v2[4] << 6));
    }
    if (*(_BYTE *)(v4 + 16))
      v10 = 0;
    else
      v10 = -1;
    return re::DynamicArray<re::TraceEntry>::resize(v3, ((v4 + (v10 << 6) - v5) >> 6) + 1);
  }
  return this;
}

void re::TraceDelta::merge(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __asm { BR              X10 }
}

uint64_t sub_225D1A8D4()
{
  uint64_t v0;
  uint64_t v1;

  *(_OWORD *)v0 = *(_OWORD *)v1;
  *(_WORD *)(v0 + 16) = *(_WORD *)(v1 + 16);
  return re::DynamicArray<BOOL>::DynamicArray(v0 + 24, (uint64_t *)(v1 + 24));
}

_QWORD *re::DynamicArray<re::TraceEntry>::resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = result;
  v4 = result[2];
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
    v8 = a2 << 6;
    v9 = a2;
    do
    {
      v10 = v3[4];
      v11 = v10 + v8;
      result = *(_QWORD **)(v10 + v8 + 24);
      if (result)
      {
        if (*(_QWORD *)(v11 + 56))
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 40))(result);
        *(_QWORD *)(v11 + 56) = 0;
        *(_QWORD *)(v10 + v8 + 32) = 0;
        *(_QWORD *)(v10 + v8 + 40) = 0;
        *(_QWORD *)(v10 + v8 + 24) = 0;
        ++*(_DWORD *)(v10 + v8 + 48);
        v4 = v3[2];
      }
      ++v9;
      v8 += 64;
    }
    while (v9 < v4);
  }
  else
  {
    if (result[1] < a2)
    {
      result = re::DynamicArray<re::TraceEntry>::setCapacity(result, a2);
      v4 = v3[2];
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = v4 << 6;
      do
      {
        v7 = v3[4] + v6;
        *(_QWORD *)(v7 + 56) = 0;
        *(_QWORD *)(v7 + 32) = 0;
        *(_QWORD *)(v7 + 40) = 0;
        *(_QWORD *)(v7 + 24) = 0;
        *(_DWORD *)(v7 + 48) = 0;
        *(_QWORD *)v7 = 0;
        *(_QWORD *)(v7 + 8) = 0;
        *(_WORD *)(v7 + 16) = 0;
        v6 += 64;
        --v5;
      }
      while (v5);
    }
  }
  v3[2] = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::TraceDelta::merge(re::TraceDelta *this, const re::TraceDelta *a2)
{
  uint64_t v3;
  _anonymous_namespace_ *v4;
  uint64_t v5;
  __n128 *v6;
  uint64_t v7;
  unint64_t v8;
  __n128 *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  _BOOL4 v16;
  __n128 v17;
  _BOOL4 v18;
  _BOOL4 v19;
  __n128 v21;
  char v22;
  re::TraceDelta *v23;
  uint64_t v24;
  _QWORD v25[2];
  uint64_t v26;
  int v27;
  __n128 *v28;

  v3 = *((_QWORD *)this + 3);
  v4 = (re::TraceDelta *)((char *)this + 16);
  v5 = *((_QWORD *)this + 4);
  v25[0] = *((_QWORD *)this + 2);
  v25[1] = v3;
  v26 = v5;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  v6 = (__n128 *)*((_QWORD *)this + 6);
  v28 = v6;
  *((_QWORD *)this + 6) = 0;
  ++*((_DWORD *)this + 10);
  v27 = 1;
  v7 = *((_QWORD *)a2 + 6);
  *((_QWORD *)this + 1) = *((_QWORD *)a2 + 1);
  v8 = *((_QWORD *)a2 + 4) + v5;
  if (v8)
    this = (re::TraceDelta *)re::DynamicArray<re::TraceEntry>::setCapacity((_QWORD *)this + 2, v8);
  v9 = v6;
  while (1)
  {
    v10 = *((_QWORD *)a2 + 6) + (*((_QWORD *)a2 + 4) << 6);
    if (v9 == &v6[4 * v5])
      break;
    if (v7 == v10)
      goto LABEL_14;
    if (!v9[1].n128_u8[0]
      || ((v11 = v9->n128_u64[0],
           v12 = v9->n128_u64[1],
           v13 = *(_QWORD *)v7,
           v14 = *(_QWORD *)(v7 + 8),
           v9->n128_u64[0] == *(_QWORD *)v7)
        ? (v15 = v12 == v14)
        : (v15 = 0),
          v15))
    {
      re::TraceDelta::merge((uint64_t)this, (uint64_t)v9, v7);
      if (v22)
        v17 = re::DynamicArray<re::TraceEntry>::add(v4, &v21);
      this = v23;
      if (v23 && v24)
        this = (re::TraceDelta *)(*(uint64_t (**)(__n128))(*(_QWORD *)v23 + 40))(v17);
      v9 += 4;
      goto LABEL_23;
    }
    v16 = v12 < v14;
    if (v11 != v13)
      v16 = v11 < v13;
    if (v16)
    {
LABEL_14:
      re::DynamicArray<re::TraceEntry>::add(v4, v9);
      v9 += 4;
      goto LABEL_24;
    }
    v18 = v14 < v12;
    if (v11 == v13)
      v19 = v18;
    else
      v19 = v13 < v11;
    if (v19)
      goto LABEL_16;
LABEL_24:
    v6 = v28;
    v5 = v26;
  }
  if (v7 != v10)
  {
LABEL_16:
    this = (re::TraceDelta *)re::DynamicArray<re::TraceEntry>::add(v4, (__int128 *)v7);
LABEL_23:
    v7 += 64;
    goto LABEL_24;
  }
  return re::DynamicArray<re::TraceEntry>::deinit((uint64_t)v25);
}

uint64_t re::TraceDelta::indexOf@<X0>(uint64_t this@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  unint64_t v8;
  char *v9;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  _BOOL4 v13;
  BOOL v14;
  _BOOL4 v15;

  v4 = *(_QWORD *)(this + 32);
  if (!v4)
    goto LABEL_13;
  v5 = *(char **)(this + 48);
  v6 = &v5[64 * v4];
  v7 = v5;
  do
  {
    v8 = v4 >> 1;
    v9 = &v7[64 * (v4 >> 1)];
    v11 = *(_QWORD *)v9;
    v12 = *((_QWORD *)v9 + 1);
    v10 = v9 + 64;
    v13 = v12 < a3;
    v14 = v11 == a2;
    v15 = v11 < a2;
    if (v14)
      v15 = v13;
    v4 += ~(v4 >> 1);
    if (v15)
      v7 = v10;
    else
      v4 = v8;
  }
  while (v4);
  if (v7 != v6 && *(_QWORD *)v7 == a2 && *((_QWORD *)v7 + 1) == a3)
  {
    *(_BYTE *)a4 = 1;
    *(_QWORD *)(a4 + 8) = (v7 - v5) >> 6;
  }
  else
  {
LABEL_13:
    *(_BYTE *)a4 = 0;
  }
  return this;
}

void *std::get_temporary_buffer[abi:nn180100]<re::TraceEntry>(uint64_t a1)
{
  unint64_t v1;
  const std::nothrow_t *v2;
  void *result;
  BOOL v4;

  if (a1 < 1)
    return 0;
  if (a1 >= 0x1FFFFFFFFFFFFFFLL)
    v1 = 0x1FFFFFFFFFFFFFFLL;
  else
    v1 = a1;
  v2 = (const std::nothrow_t *)MEMORY[0x24BEDB6B8];
  while (1)
  {
    result = operator new(v1 << 6, v2);
    if (result)
      break;
    v4 = v1 > 1;
    v1 >>= 1;
    if (!v4)
      return 0;
  }
  return result;
}

uint64_t std::__stable_sort<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>(uint64_t result, __n128 *a2, uint64_t a3, unint64_t a4, __n128 *a5, uint64_t a6)
{
  uint64_t v7;
  unint64_t v8;
  BOOL v9;
  _BOOL4 v10;
  uint64_t v15;
  __n128 *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  __n128 *v20;
  __int128 *v21;

  v21 = (__int128 *)result;
  if (a4 >= 2)
  {
    v7 = result;
    if (a4 == 2)
    {
      v8 = a2[-4].n128_u64[0];
      v20 = a2 - 4;
      v9 = v8 == *(_QWORD *)result;
      v10 = v8 < *(_QWORD *)result;
      if (v9)
        v10 = a2[-4].n128_u64[1] < *(_QWORD *)(result + 8);
      if (v10)
        return std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<re::TraceEntry *&,re::TraceEntry *&>(&v21, (__int128 **)&v20);
    }
    else if ((uint64_t)a4 <= 0)
    {
      return std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>(result, (uint64_t)a2);
    }
    else
    {
      v15 = a4 >> 1;
      v16 = (__n128 *)(result + (a4 >> 1 << 6));
      v17 = a4 >> 1;
      if ((uint64_t)a4 <= a6)
      {
        std::__stable_sort_move<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>((__n128 *)result, v16, a3, v17, a5);
        std::__stable_sort_move<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>((__n128 *)(v7 + (a4 >> 1 << 6)), a2, a3, a4 - v15, &a5[4 * v15]);
        v19 = a4;
        result = std::__merge_move_assign[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *,re::TraceEntry *,re::TraceEntry *>((uint64_t)a5, (uint64_t)&a5[4 * v15], (__int128 *)&a5[4 * v15], (__int128 *)&a5[4 * a4], v7);
        if (a5)
          return std::__destruct_n::__process[abi:nn180100]<re::TraceEntry>((uint64_t)&v19, (uint64_t)a5);
      }
      else
      {
        std::__stable_sort<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>(result, v16, a3, v17, a5, a6);
        v18 = a4 - v15;
        std::__stable_sort<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>(v16, a2, a3, v18, a5, a6);
        return std::__inplace_merge<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>(v7, (__int128 *)v16, (__int128 *)a2, a3, v15, v18, (uint64_t)a5, a6);
      }
    }
  }
  return result;
}

uint64_t std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<re::TraceEntry *&,re::TraceEntry *&>(__int128 **a1, __int128 **a2)
{
  __int128 *v2;
  __int128 *v3;
  uint64_t v4;
  __int128 v5;
  uint64_t result;
  __int128 v7;
  __int16 v8;
  _QWORD v9[3];
  int v10;
  uint64_t v11;

  v2 = *a1;
  v3 = *a2;
  v8 = *((_WORD *)*a1 + 8);
  v7 = **a1;
  v9[0] = *((_QWORD *)*a1 + 3);
  *((_QWORD *)v2 + 3) = 0;
  v4 = *((_QWORD *)v2 + 5);
  v9[1] = *((_QWORD *)v2 + 4);
  *((_QWORD *)v2 + 4) = 0;
  v9[2] = v4;
  *((_QWORD *)v2 + 5) = 0;
  v11 = *((_QWORD *)v2 + 7);
  *((_QWORD *)v2 + 7) = 0;
  ++*((_DWORD *)v2 + 12);
  v10 = 1;
  v5 = *v3;
  *((_WORD *)v2 + 8) = *((_WORD *)v3 + 8);
  *v2 = v5;
  re::DynamicArray<re::internal::DeferredUnregister *>::operator=((uint64_t)v2 + 24, (uint64_t)v3 + 24);
  *v3 = v7;
  *((_WORD *)v3 + 8) = v8;
  re::DynamicArray<re::internal::DeferredUnregister *>::operator=((uint64_t)v3 + 24, (uint64_t)v9);
  result = v9[0];
  if (v9[0])
  {
    if (v11)
      return (*(uint64_t (**)(void))(*(_QWORD *)v9[0] + 40))();
  }
  return result;
}

uint64_t std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  _BOOL4 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  BOOL v17;
  uint64_t v18;
  __int128 v19;
  __int16 v20;
  uint64_t v21;
  __int128 v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  if (result != a2)
  {
    v25 = v2;
    v26 = v3;
    v5 = result;
    v6 = result + 64;
    if (result + 64 != a2)
    {
      v7 = 0;
      v8 = result;
      do
      {
        v9 = v6;
        v10 = *(_QWORD *)(v8 + 64);
        v11 = v10 == *(_QWORD *)v8;
        v12 = v10 < *(_QWORD *)v8;
        if (v11)
          v12 = *(_QWORD *)(v8 + 72) < *(_QWORD *)(v8 + 8);
        if (v12)
        {
          v19 = *(_OWORD *)v9;
          v20 = *(_WORD *)(v9 + 16);
          v21 = *(_QWORD *)(v8 + 88);
          v22 = *(_OWORD *)(v8 + 96);
          *(_QWORD *)(v8 + 88) = 0;
          *(_QWORD *)(v8 + 96) = 0;
          *(_QWORD *)(v8 + 104) = 0;
          v24 = *(_QWORD *)(v8 + 120);
          *(_QWORD *)(v8 + 120) = 0;
          ++*(_DWORD *)(v8 + 112);
          v13 = v7;
          v23 = 1;
          while (1)
          {
            v14 = v5 + v13;
            *(_OWORD *)(v14 + 64) = *(_OWORD *)(v5 + v13);
            *(_WORD *)(v14 + 80) = *(_WORD *)(v5 + v13 + 16);
            v15 = v5 + v13 + 24;
            re::DynamicArray<re::internal::DeferredUnregister *>::operator=(v5 + v13 + 88, v15);
            if (!v13)
              break;
            v16 = *(_QWORD *)(v14 - 64);
            v17 = (unint64_t)v19 < v16;
            if ((_QWORD)v19 == v16)
              v17 = *((_QWORD *)&v19 + 1) < *(_QWORD *)(v14 - 56);
            v13 -= 64;
            if (!v17)
            {
              v18 = v5 + v13 + 64;
              goto LABEL_14;
            }
          }
          v18 = v5;
LABEL_14:
          *(_OWORD *)v18 = v19;
          *(_WORD *)(v18 + 16) = v20;
          re::DynamicArray<re::internal::DeferredUnregister *>::operator=(v15, (uint64_t)&v21);
          result = v21;
          if (v21)
          {
            if (v24)
              result = (*(uint64_t (**)(void))(*(_QWORD *)v21 + 40))();
          }
        }
        v6 = v9 + 64;
        v7 += 64;
        v8 = v9;
      }
      while (v9 + 64 != a2);
    }
  }
  return result;
}

__n128 std::__stable_sort_move<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>(__n128 *a1, __n128 *a2, uint64_t a3, unint64_t a4, __n128 *a5)
{
  __n128 *v8;
  __n128 result;
  __n128 *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  __n128 *v14;
  __n128 *v15;
  unint64_t v16;
  _BOOL4 v17;
  BOOL v18;
  _BOOL4 v19;
  unint64_t *v20;
  __n128 v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  __n128 *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  __n128 *v32;
  uint64_t v33;
  __n128 *v34;
  __n128 *v35;
  __n128 *v36;
  unint64_t v37;
  _BOOL4 v38;
  __n128 *v39;
  uint64_t v40;
  unint64_t v41;
  _BOOL4 v42;
  __n128 v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  __n128 v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unsigned __int16 v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  __n128 *v56;
  unint64_t *v57;
  __n128 *v58;
  __n128 *v59;
  _BOOL4 v60;
  unint64_t *v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  __n128 *v69;
  unint64_t *v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t *v75;
  __n128 *v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;

  if (a4)
  {
    v8 = a1;
    if (a4 == 2)
    {
      v16 = a2[-4].n128_u64[0];
      v15 = a2 - 4;
      v17 = a2[-4].n128_u64[1] < a1->n128_u64[1];
      v18 = v16 == a1->n128_u64[0];
      v19 = v16 < a1->n128_u64[0];
      if (!v18)
        v17 = v19;
      v20 = &a5[1].n128_u64[1];
      if (v17)
      {
        v21 = *v15;
        a5[1].n128_u16[0] = a2[-3].n128_u16[0];
        *a5 = v21;
        a5[3].n128_u64[1] = 0;
        a5[2].n128_u64[0] = 0;
        a5[2].n128_u64[1] = 0;
        *v20 = 0;
        a5[3].n128_u32[0] = 0;
        v22 = a2[-2].n128_u64[0];
        a5[1].n128_u64[1] = a2[-3].n128_u64[1];
        a5[2].n128_u64[0] = v22;
        a2[-3].n128_u64[1] = 0;
        a2[-2].n128_u64[0] = 0;
        v23 = a5[2].n128_u64[1];
        a5[2].n128_u64[1] = a2[-2].n128_u64[1];
        a2[-2].n128_u64[1] = v23;
        v24 = a5[3].n128_u64[1];
        a5[3].n128_u64[1] = a2[-1].n128_u64[1];
        a2[-1].n128_u64[1] = v24;
        ++a2[-1].n128_u32[0];
        ++a5[3].n128_u32[0];
        result = *a1;
        LOWORD(v24) = a1[1].n128_u16[0];
        a5[7].n128_u32[0] = 0;
        v25 = a5 + 7;
        a5[5].n128_u16[0] = v24;
        a5[4] = result;
        a5[7].n128_u64[1] = 0;
        a5[6].n128_u64[0] = 0;
        a5[6].n128_u64[1] = 0;
        a5[5].n128_u64[1] = 0;
        v26 = a1[2].n128_u64[0];
        a5[5].n128_u64[1] = a1[1].n128_u64[1];
        a5[6].n128_u64[0] = v26;
        a1[1].n128_u64[1] = 0;
        a1[2].n128_u64[0] = 0;
        v27 = a5[6].n128_u64[1];
        a5[6].n128_u64[1] = a1[2].n128_u64[1];
        a1[2].n128_u64[1] = v27;
        v28 = a5[7].n128_u64[1];
        a5[7].n128_u64[1] = a1[3].n128_u64[1];
        a1[3].n128_u64[1] = v28;
        v14 = a1 + 3;
      }
      else
      {
        v47 = *a1;
        a5[1].n128_u16[0] = a1[1].n128_u16[0];
        *a5 = v47;
        a5[3].n128_u64[1] = 0;
        a5[2].n128_u64[0] = 0;
        a5[2].n128_u64[1] = 0;
        *v20 = 0;
        a5[3].n128_u32[0] = 0;
        v48 = a1[2].n128_u64[0];
        a5[1].n128_u64[1] = a1[1].n128_u64[1];
        a5[2].n128_u64[0] = v48;
        a1[1].n128_u64[1] = 0;
        a1[2].n128_u64[0] = 0;
        v49 = a5[2].n128_u64[1];
        a5[2].n128_u64[1] = a1[2].n128_u64[1];
        a1[2].n128_u64[1] = v49;
        v50 = a5[3].n128_u64[1];
        a5[3].n128_u64[1] = a1[3].n128_u64[1];
        a1[3].n128_u64[1] = v50;
        ++a1[3].n128_u32[0];
        ++a5[3].n128_u32[0];
        result = *v15;
        v51 = a2[-3].n128_u16[0];
        a5[7].n128_u32[0] = 0;
        v25 = a5 + 7;
        a5[5].n128_u16[0] = v51;
        a5[4] = result;
        a5[7].n128_u64[1] = 0;
        a5[6].n128_u64[0] = 0;
        a5[6].n128_u64[1] = 0;
        a5[5].n128_u64[1] = 0;
        v52 = a2[-2].n128_u64[0];
        a5[5].n128_u64[1] = a2[-3].n128_u64[1];
        a5[6].n128_u64[0] = v52;
        a2[-3].n128_u64[1] = 0;
        a2[-2].n128_u64[0] = 0;
        v53 = a5[6].n128_u64[1];
        a5[6].n128_u64[1] = a2[-2].n128_u64[1];
        a2[-2].n128_u64[1] = v53;
        v54 = a5[7].n128_u64[1];
        a5[7].n128_u64[1] = a2[-1].n128_u64[1];
        a2[-1].n128_u64[1] = v54;
        v14 = a2 - 1;
      }
      v10 = v25;
      goto LABEL_29;
    }
    if (a4 == 1)
    {
      result = *a1;
      a5[1].n128_u16[0] = a1[1].n128_u16[0];
      *a5 = result;
      a5[3].n128_u32[0] = 0;
      v10 = a5 + 3;
      a5[3].n128_u64[1] = 0;
      a5[2].n128_u64[0] = 0;
      a5[2].n128_u64[1] = 0;
      a5[1].n128_u64[1] = 0;
      v11 = a1[2].n128_u64[0];
      a5[1].n128_u64[1] = a1[1].n128_u64[1];
      a5[2].n128_u64[0] = v11;
      a1[1].n128_u64[1] = 0;
      a1[2].n128_u64[0] = 0;
      v12 = a5[2].n128_u64[1];
      a5[2].n128_u64[1] = a1[2].n128_u64[1];
      a1[2].n128_u64[1] = v12;
      v13 = a5[3].n128_u64[1];
      a5[3].n128_u64[1] = a1[3].n128_u64[1];
      a1[3].n128_u64[1] = v13;
      v14 = a1 + 3;
LABEL_29:
      ++v14->n128_u32[0];
      ++v10->n128_u32[0];
      return result;
    }
    if ((uint64_t)a4 > 8)
    {
      v56 = &a1[4 * (a4 >> 1)];
      std::__stable_sort<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>(a1, v56, a3, a4 >> 1, a5, a4 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>(&v8[4 * (a4 >> 1)], a2, a3, a4 - (a4 >> 1), &a5[4 * (a4 >> 1)], a4 - (a4 >> 1));
      v57 = &a5[3].n128_u64[1];
      v58 = &v8[4 * (a4 >> 1)];
      while (v58 != a2)
      {
        v59 = (__n128 *)(v57 - 7);
        v60 = v58->n128_u64[1] < v8->n128_u64[1];
        if (v58->n128_u64[0] != v8->n128_u64[0])
          v60 = v58->n128_u64[0] < v8->n128_u64[0];
        v61 = v57 - 4;
        if (v60)
        {
          result = *v58;
          *((_WORD *)v57 - 20) = v58[1].n128_u16[0];
          *v59 = result;
          *v57 = 0;
          *(v57 - 3) = 0;
          *(v57 - 2) = 0;
          *v61 = 0;
          *((_DWORD *)v57 - 2) = 0;
          v62 = v58[2].n128_u64[0];
          *(v57 - 4) = v58[1].n128_u64[1];
          *(v57 - 3) = v62;
          v58[1].n128_u64[1] = 0;
          v58[2].n128_u64[0] = 0;
          v63 = *(v57 - 2);
          *(v57 - 2) = v58[2].n128_u64[1];
          v58[2].n128_u64[1] = v63;
          v64 = *v57;
          *v57 = v58[3].n128_u64[1];
          v58[3].n128_u64[1] = v64;
          ++v58[3].n128_u32[0];
          v58 += 4;
        }
        else
        {
          result = *v8;
          *((_WORD *)v57 - 20) = v8[1].n128_u16[0];
          *v59 = result;
          *v57 = 0;
          *(v57 - 3) = 0;
          *(v57 - 2) = 0;
          *v61 = 0;
          *((_DWORD *)v57 - 2) = 0;
          v65 = v8[2].n128_u64[0];
          *(v57 - 4) = v8[1].n128_u64[1];
          *(v57 - 3) = v65;
          v8[1].n128_u64[1] = 0;
          v8[2].n128_u64[0] = 0;
          v66 = *(v57 - 2);
          *(v57 - 2) = v8[2].n128_u64[1];
          v8[2].n128_u64[1] = v66;
          v67 = *v57;
          *v57 = v8[3].n128_u64[1];
          v8[3].n128_u64[1] = v67;
          ++v8[3].n128_u32[0];
          v8 += 4;
        }
        ++*((_DWORD *)v57 - 2);
        v57 += 8;
        if (v8 == v56)
        {
          if (v58 != a2)
          {
            v68 = 0;
            do
            {
              v69 = &v58[v68 / 0x10];
              v70 = &v57[v68 / 8];
              result = v58[v68 / 0x10];
              *((_WORD *)v70 - 20) = v58[v68 / 0x10 + 1].n128_u16[0];
              *(__n128 *)(v70 - 7) = result;
              *v70 = 0;
              *(v70 - 3) = 0;
              *(v70 - 2) = 0;
              *(v70 - 4) = 0;
              *((_DWORD *)v70 - 2) = 0;
              v71 = v58[v68 / 0x10 + 2].n128_u64[0];
              *(v70 - 4) = v58[v68 / 0x10 + 1].n128_u64[1];
              *(v70 - 3) = v71;
              v69[1].n128_u64[1] = 0;
              v69[2].n128_u64[0] = 0;
              v72 = v57[v68 / 8 - 2];
              *(v70 - 2) = v58[v68 / 0x10 + 2].n128_u64[1];
              v69[2].n128_u64[1] = v72;
              v73 = v57[v68 / 8];
              *v70 = v58[v68 / 0x10 + 3].n128_u64[1];
              v69[3].n128_u64[1] = v73;
              v69[3].n128_u32[0] = v58[v68 / 0x10 + 3].n128_u32[0] + 1;
              *((_DWORD *)v70 - 2) = LODWORD(v57[v68 / 8 - 1]) + 1;
              v68 += 64;
            }
            while (&v69[4] != a2);
          }
          return result;
        }
      }
      if (v8 != v56)
      {
        v74 = 0;
        do
        {
          v75 = &v57[v74 / 8];
          v76 = &v8[v74 / 0x10];
          result = v8[v74 / 0x10];
          *((_WORD *)v75 - 20) = v8[v74 / 0x10 + 1].n128_u16[0];
          *(__n128 *)(v75 - 7) = result;
          *v75 = 0;
          *(v75 - 3) = 0;
          *(v75 - 2) = 0;
          *(v75 - 4) = 0;
          *((_DWORD *)v75 - 2) = 0;
          v77 = v8[v74 / 0x10 + 2].n128_u64[0];
          *(v75 - 4) = v8[v74 / 0x10 + 1].n128_u64[1];
          *(v75 - 3) = v77;
          v76[1].n128_u64[1] = 0;
          v76[2].n128_u64[0] = 0;
          v78 = v57[v74 / 8 - 2];
          *(v75 - 2) = v8[v74 / 0x10 + 2].n128_u64[1];
          v76[2].n128_u64[1] = v78;
          v79 = v57[v74 / 8];
          *v75 = v8[v74 / 0x10 + 3].n128_u64[1];
          v76[3].n128_u64[1] = v79;
          v76[3].n128_u32[0] = v8[v74 / 0x10 + 3].n128_u32[0] + 1;
          *((_DWORD *)v75 - 2) = LODWORD(v57[v74 / 8 - 1]) + 1;
          v74 += 64;
        }
        while (&v76[4] != v56);
      }
    }
    else if (a1 != a2)
    {
      result = *a1;
      a5[1].n128_u16[0] = a1[1].n128_u16[0];
      *a5 = result;
      a5[3].n128_u64[1] = 0;
      a5[2].n128_u64[0] = 0;
      a5[2].n128_u64[1] = 0;
      a5[1].n128_u64[1] = 0;
      a5[3].n128_u32[0] = 0;
      v29 = a1[2].n128_u64[0];
      a5[1].n128_u64[1] = a1[1].n128_u64[1];
      a5[2].n128_u64[0] = v29;
      a1[1].n128_u64[1] = 0;
      a1[2].n128_u64[0] = 0;
      v30 = a5[2].n128_u64[1];
      a5[2].n128_u64[1] = a1[2].n128_u64[1];
      a1[2].n128_u64[1] = v30;
      v31 = a5[3].n128_u64[1];
      a5[3].n128_u64[1] = a1[3].n128_u64[1];
      a1[3].n128_u64[1] = v31;
      ++a1[3].n128_u32[0];
      ++a5[3].n128_u32[0];
      v32 = a1 + 4;
      if (&a1[4] != a2)
      {
        v33 = 0;
        v34 = a5;
        do
        {
          v35 = v32;
          v36 = v34 + 4;
          v37 = v8[4].n128_u64[0];
          v18 = v37 == v34->n128_u64[0];
          v38 = v37 < v34->n128_u64[0];
          if (v18)
            v38 = v8[4].n128_u64[1] < v34->n128_u64[1];
          if (v38)
          {
            *v36 = *v34;
            v34[5].n128_u16[0] = v34[1].n128_u16[0];
            v34[5].n128_u64[1] = v34[1].n128_u64[1];
            v34[6] = v34[2];
            v34[1].n128_u64[1] = 0;
            v34[2].n128_u64[0] = 0;
            v34[2].n128_u64[1] = 0;
            v34[7].n128_u64[1] = v34[3].n128_u64[1];
            v34[3].n128_u64[1] = 0;
            ++v34[3].n128_u32[0];
            v39 = a5;
            v34[7].n128_u32[0] = 1;
            if (v34 != a5)
            {
              v40 = v33;
              while (1)
              {
                v39 = (__n128 *)((char *)a5 + v40);
                v41 = *(unint64_t *)((char *)a5[-4].n128_u64 + v40);
                v18 = v35->n128_u64[0] == v41;
                v42 = v35->n128_u64[0] < v41;
                if (v18)
                  v42 = v8[4].n128_u64[1] < *(_QWORD *)((char *)&a5[-3] + v40 - 8);
                if (!v42)
                  break;
                *v39 = *(__n128 *)((char *)a5 + v40 - 64);
                v39[1].n128_u16[0] = *(unsigned __int16 *)((char *)a5[-3].n128_u16 + v40);
                re::DynamicArray<re::internal::DeferredUnregister *>::operator=((uint64_t)&v39[1].n128_i64[1], (uint64_t)&v39[-3].n128_i64[1]);
                v40 -= 64;
                if (!v40)
                {
                  v39 = a5;
                  break;
                }
              }
            }
            v43 = *v35;
            v39[1].n128_u16[0] = v35[1].n128_u16[0];
            *v39 = v43;
            re::DynamicArray<re::internal::DeferredUnregister *>::operator=((uint64_t)&v39[1].n128_i64[1], (uint64_t)&v8[5].n128_i64[1]);
          }
          else
          {
            result = *v35;
            v34[5].n128_u16[0] = v35[1].n128_u16[0];
            *v36 = result;
            v34[7].n128_u64[1] = 0;
            v34[6].n128_u64[0] = 0;
            v34[6].n128_u64[1] = 0;
            v34[5].n128_u64[1] = 0;
            v34[7].n128_u32[0] = 0;
            v44 = v8[6].n128_u64[0];
            v34[5].n128_u64[1] = v8[5].n128_u64[1];
            v34[6].n128_u64[0] = v44;
            v8[5].n128_u64[1] = 0;
            v8[6].n128_u64[0] = 0;
            v45 = v34[6].n128_i64[1];
            v34[6].n128_u64[1] = v8[6].n128_u64[1];
            v8[6].n128_u64[1] = v45;
            v46 = v34[7].n128_i64[1];
            v34[7].n128_u64[1] = v8[7].n128_u64[1];
            v8[7].n128_u64[1] = v46;
            ++v8[7].n128_u32[0];
            ++v34[7].n128_u32[0];
          }
          v32 = v35 + 4;
          v33 += 64;
          v34 = v36;
          v8 = v35;
        }
        while (&v35[4] != a2);
      }
    }
  }
  return result;
}

uint64_t std::__merge_move_assign[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *,re::TraceEntry *,re::TraceEntry *>(uint64_t result, uint64_t a2, __int128 *a3, __int128 *a4, uint64_t a5)
{
  uint64_t v9;
  _BOOL4 v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;

  if (result == a2)
  {
LABEL_12:
    while (a3 != a4)
    {
      v14 = *a3;
      *(_WORD *)(a5 + 16) = *((_WORD *)a3 + 8);
      *(_OWORD *)a5 = v14;
      result = re::DynamicArray<re::internal::DeferredUnregister *>::operator=(a5 + 24, (uint64_t)a3 + 24);
      a3 += 4;
      a5 += 64;
    }
  }
  else
  {
    v9 = result;
    while (a3 != a4)
    {
      v10 = *(_QWORD *)a3 < *(_QWORD *)v9;
      if (*(_QWORD *)a3 == *(_QWORD *)v9)
        v10 = *((_QWORD *)a3 + 1) < *(_QWORD *)(v9 + 8);
      v11 = a5 + 24;
      if (v10)
      {
        v12 = *a3;
        *(_WORD *)(a5 + 16) = *((_WORD *)a3 + 8);
        *(_OWORD *)a5 = v12;
        result = re::DynamicArray<re::internal::DeferredUnregister *>::operator=(v11, (uint64_t)a3 + 24);
        a3 += 4;
      }
      else
      {
        v13 = *(_OWORD *)v9;
        *(_WORD *)(a5 + 16) = *(_WORD *)(v9 + 16);
        *(_OWORD *)a5 = v13;
        result = re::DynamicArray<re::internal::DeferredUnregister *>::operator=(v11, v9 + 24);
        v9 += 64;
      }
      a5 += 64;
      if (v9 == a2)
        goto LABEL_12;
    }
    if (v9 != a2)
    {
      v15 = 0;
      do
      {
        v16 = a5 + v15;
        v17 = v9 + v15;
        v18 = *(_OWORD *)(v9 + v15);
        *(_WORD *)(v16 + 16) = *(_WORD *)(v9 + v15 + 16);
        *(_OWORD *)v16 = v18;
        result = re::DynamicArray<re::internal::DeferredUnregister *>::operator=(a5 + v15 + 24, v9 + v15 + 24);
        v15 += 64;
      }
      while (v17 + 64 != a2);
    }
  }
  return result;
}

uint64_t std::__inplace_merge<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>(uint64_t result, __int128 *a2, __int128 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  __int128 *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  __int128 *v16;
  unint64_t v17;
  BOOL v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 *v23;
  __int128 *v24;
  unint64_t v25;
  int64x2_t v26;
  unint64_t v27;
  int64x2_t *v28;
  __int128 *v29;
  int64x2_t v30;
  int32x2_t v31;
  __int8 v32;
  uint64_t v33;
  unint64_t v34;
  int64x2_t v35;
  unint64_t v36;
  int64x2_t *v37;
  __int128 *i8;
  int64x2_t v39;
  int32x2_t v40;
  __int8 v41;
  __int128 *v42;
  uint64_t v43;
  uint64_t v44;
  __int128 *v45;
  __int128 *v46;
  __int128 *v47;
  __int128 *v48;
  uint64_t v49;
  __int128 *v50;
  __int128 *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  __int128 *v59;
  uint64_t v60;
  __int128 *v61;
  __int128 v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  __int128 *v66;
  unint64_t v67;
  unint64_t v68;
  _BOOL4 v69;
  uint64_t v70;
  BOOL v71;
  __int128 *v72;
  __int128 v73;
  __int16 v74;
  __int128 *v75;
  uint64_t v76;
  __int128 *v77;
  uint64_t v78;
  uint64_t v79;
  __int128 v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  __int128 *v86;
  _BOOL4 v87;
  uint64_t v88;
  __int128 v89;
  __int128 v90;
  unint64_t v91;
  __int128 *v92;
  __int128 v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  __int128 v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  __int128 *v101;
  __int128 *v102;
  __int128 *v103;
  __int128 *v104;

  v101 = a2;
  if (!a6)
    return result;
  v9 = a6;
  v11 = a2;
  v12 = result;
  while (a5 > a8 && v9 > a8)
  {
    if (!a5)
      return result;
    v13 = 0;
    v14 = *(_QWORD *)v11;
    v15 = -a5;
    while (1)
    {
      v16 = (__int128 *)(v12 + v13);
      v17 = *(_QWORD *)(v12 + v13);
      v71 = v14 == v17;
      v18 = v14 < v17;
      if (v71)
        v18 = *((_QWORD *)v11 + 1) < *(_QWORD *)(v12 + v13 + 8);
      if (v18)
        break;
      v13 += 64;
      if (__CFADD__(v15++, 1))
        return result;
    }
    v102 = (__int128 *)(v12 + v13);
    v20 = -v15;
    v100 = a7;
    if (-v15 >= v9)
    {
      if (v15 == -1)
        return std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<re::TraceEntry *&,re::TraceEntry *&>(&v102, &v101);
      if (v15 > 0)
        v20 = 1 - v15;
      v33 = v20 >> 1;
      v24 = (__int128 *)(v12 + (v20 >> 1 << 6) + v13);
      v23 = a3;
      if (a3 != v11)
      {
        v34 = ((char *)a3 - (char *)v11) >> 6;
        v35 = (int64x2_t)*v24;
        v23 = v11;
        do
        {
          v36 = v34 >> 1;
          v37 = (int64x2_t *)&v23[4 * (v34 >> 1)];
          v39 = *v37;
          i8 = (__int128 *)v37[4].i8;
          v40 = vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)v35, (uint64x2_t)v39));
          if ((vmovn_s64(vceqq_s64(v39, v35)).u32[0] & 1) != 0)
            v41 = v40.i8[4];
          else
            v41 = v40.i8[0];
          v34 += ~(v34 >> 1);
          if ((v41 & 1) != 0)
            v23 = i8;
          else
            v34 = v36;
        }
        while (v34);
      }
      v22 = ((char *)v23 - (char *)v11) >> 6;
    }
    else
    {
      if (v9 >= 0)
        v21 = v9;
      else
        v21 = v9 + 1;
      v22 = v21 >> 1;
      v23 = &v11[4 * (v21 >> 1)];
      v24 = v11;
      if (v16 != v11)
      {
        v25 = ((uint64_t)v11 - v12 - v13) >> 6;
        v26 = (int64x2_t)*v23;
        v24 = (__int128 *)(v12 + v13);
        do
        {
          v27 = v25 >> 1;
          v28 = (int64x2_t *)&v24[4 * (v25 >> 1)];
          v30 = *v28;
          v29 = (__int128 *)v28[4].i8;
          v31 = vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)v30, (uint64x2_t)v26));
          if ((vmovn_s64(vceqq_s64(v26, v30)).u32[0] & 1) != 0)
            v32 = v31.i8[4];
          else
            v32 = v31.i8[0];
          v25 += ~(v25 >> 1);
          if ((v32 & 1) != 0)
            v25 = v27;
          else
            v24 = v29;
        }
        while (v25);
      }
      v33 = ((uint64_t)v24 - v12 - v13) >> 6;
    }
    v42 = v23;
    if (v24 != v11)
    {
      v42 = v24;
      if (v11 != v23)
      {
        v43 = v33;
        v98 = v22;
        v99 = a4;
        v44 = a8;
        v45 = a3;
        v103 = v11;
        v104 = v24;
        while (1)
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<re::TraceEntry *&,re::TraceEntry *&>(&v104, &v103);
          v42 = v104 + 4;
          v46 = v103 + 4;
          v103 = v46;
          v104 += 4;
          if (v46 == v23)
            break;
          if (v42 == v11)
            v11 = v46;
        }
        if (v42 != v11)
        {
          do
          {
            v103 = v11;
            while (1)
            {
              std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<re::TraceEntry *&,re::TraceEntry *&>(&v104, &v103);
              v47 = v104 + 4;
              v48 = v103 + 4;
              v103 = v48;
              v104 += 4;
              if (v48 == v23)
                break;
              if (v47 == v11)
                v11 = v48;
            }
          }
          while (v47 != v11);
        }
        a3 = v45;
        a8 = v44;
        v22 = v98;
        a4 = v99;
        v33 = v43;
      }
    }
    a5 = -(v33 + v15);
    v49 = v9 - v22;
    if (v33 + v22 >= v9 - (v33 + v22) - v15)
    {
      v54 = a4;
      v55 = v33;
      v56 = v22;
      v57 = a8;
      result = std::__inplace_merge<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>(v42, v23, a3);
      a4 = v54;
      a8 = v57;
      v23 = v24;
      a7 = v100;
      v49 = v56;
      a5 = v55;
      a3 = v42;
    }
    else
    {
      v50 = v24;
      v51 = a3;
      v52 = a4;
      a7 = v100;
      v53 = a8;
      result = std::__inplace_merge<std::_ClassicAlgPolicy,std::__less<void,void> &,re::TraceEntry *>(v16, v50, v42);
      a4 = v52;
      a8 = v53;
      a3 = v51;
      v102 = v42;
      v16 = v42;
    }
    v101 = v23;
    v9 = v49;
    v11 = v23;
    v12 = (uint64_t)v16;
    if (!v49)
      return result;
  }
  if (a5 <= v9)
  {
    if ((__int128 *)v12 != v11)
    {
      v76 = 0;
      v77 = 0;
      do
      {
        v78 = a7 + v76;
        v79 = v12 + v76;
        v80 = *(_OWORD *)(v12 + v76);
        *(_WORD *)(v78 + 16) = *(_WORD *)(v12 + v76 + 16);
        *(_QWORD *)(v78 + 56) = 0;
        *(_QWORD *)(v78 + 32) = 0;
        *(_QWORD *)(v78 + 40) = 0;
        *(_QWORD *)(v78 + 24) = 0;
        *(_DWORD *)(v78 + 48) = 0;
        *(_OWORD *)v78 = v80;
        *(_QWORD *)(v78 + 24) = *(_QWORD *)(v12 + v76 + 24);
        *(_QWORD *)(v79 + 24) = 0;
        *(_QWORD *)(v78 + 32) = *(_QWORD *)(v12 + v76 + 32);
        *(_QWORD *)(v79 + 32) = 0;
        v81 = *(_QWORD *)(a7 + v76 + 40);
        *(_QWORD *)(v78 + 40) = *(_QWORD *)(v12 + v76 + 40);
        *(_QWORD *)(v79 + 40) = v81;
        v82 = *(_QWORD *)(a7 + v76 + 56);
        *(_QWORD *)(v78 + 56) = *(_QWORD *)(v12 + v76 + 56);
        *(_QWORD *)(v79 + 56) = v82;
        *(_DWORD *)(v79 + 48) = *(_DWORD *)(v12 + v76 + 48) + 1;
        *(_DWORD *)(v78 + 48) = *(_DWORD *)(a7 + v76 + 48) + 1;
        v77 = (__int128 *)((char *)v77 + 1);
        v76 += 64;
      }
      while ((__int128 *)(v79 + 64) != v11);
      v104 = v77;
      if (v76)
      {
        v83 = a7 + v76;
        v84 = a7 + v76 - 64;
        v85 = a7;
        while (v11 != a3)
        {
          v86 = a3;
          v87 = *(_QWORD *)v11 < *(_QWORD *)v85;
          if (*(_QWORD *)v11 == *(_QWORD *)v85)
            v87 = *((_QWORD *)v11 + 1) < *(_QWORD *)(v85 + 8);
          v88 = v12 + 24;
          if (v87)
          {
            v89 = *v11;
            *(_WORD *)(v12 + 16) = *((_WORD *)v11 + 8);
            *(_OWORD *)v12 = v89;
            result = re::DynamicArray<re::internal::DeferredUnregister *>::operator=(v88, (uint64_t)v11 + 24);
            v11 += 4;
          }
          else
          {
            v90 = *(_OWORD *)v85;
            *(_WORD *)(v12 + 16) = *(_WORD *)(v85 + 16);
            *(_OWORD *)v12 = v90;
            result = re::DynamicArray<re::internal::DeferredUnregister *>::operator=(v88, v85 + 24);
            v85 += 64;
          }
          v12 += 64;
          a3 = v86;
          if (v83 == v85)
            goto LABEL_101;
        }
        if (v83 != v85)
        {
          v94 = 0;
          do
          {
            v95 = v12 + v94;
            v96 = v85 + v94;
            v97 = *(_OWORD *)(v85 + v94);
            *(_WORD *)(v95 + 16) = *(_WORD *)(v85 + v94 + 16);
            *(_OWORD *)v95 = v97;
            result = re::DynamicArray<re::internal::DeferredUnregister *>::operator=(v12 + v94 + 24, v85 + v94 + 24);
            v94 += 64;
          }
          while (v84 != v96);
        }
      }
      goto LABEL_101;
    }
  }
  else if (v11 != a3)
  {
    v58 = 0;
    v59 = 0;
    do
    {
      v60 = a7 + v58 * 16;
      v61 = &v11[v58];
      v62 = v11[v58];
      *(_WORD *)(v60 + 16) = v11[v58 + 1];
      *(_QWORD *)(v60 + 56) = 0;
      *(_QWORD *)(v60 + 32) = 0;
      *(_QWORD *)(v60 + 40) = 0;
      *(_QWORD *)(v60 + 24) = 0;
      *(_DWORD *)(v60 + 48) = 0;
      *(_OWORD *)v60 = v62;
      *(_QWORD *)(v60 + 24) = *((_QWORD *)&v11[v58 + 1] + 1);
      *((_QWORD *)v61 + 3) = 0;
      *(_QWORD *)(v60 + 32) = *(_QWORD *)&v11[v58 + 2];
      *((_QWORD *)v61 + 4) = 0;
      v63 = *(_QWORD *)(a7 + v58 * 16 + 40);
      *(_QWORD *)(v60 + 40) = *((_QWORD *)&v11[v58 + 2] + 1);
      *((_QWORD *)v61 + 5) = v63;
      v64 = *(_QWORD *)(a7 + v58 * 16 + 56);
      *(_QWORD *)(v60 + 56) = *((_QWORD *)&v11[v58 + 3] + 1);
      *((_QWORD *)v61 + 7) = v64;
      *((_DWORD *)v61 + 12) = LODWORD(v11[v58 + 3]) + 1;
      *(_DWORD *)(v60 + 48) = *(_DWORD *)(a7 + v58 * 16 + 48) + 1;
      v59 = (__int128 *)((char *)v59 + 1);
      v58 += 4;
    }
    while (v61 + 4 != a3);
    v104 = v59;
    if (v58 * 16)
    {
      v65 = a7 + v58 * 16;
      v66 = a3 - 4;
      while (v11 != (__int128 *)v12)
      {
        v67 = *(_QWORD *)(v65 - 64);
        v68 = *((_QWORD *)v11 - 8);
        v71 = v67 == v68;
        v69 = v67 < v68;
        if (v71)
          v69 = *(_QWORD *)(v65 - 56) < *((_QWORD *)v11 - 7);
        v70 = (uint64_t)v66 + 24;
        v71 = !v69;
        if (v69)
          v72 = v11 - 4;
        else
          v72 = (__int128 *)(v65 - 64);
        v73 = *v72;
        v74 = *((_WORD *)v72 + 8);
        if (v71)
          v75 = (__int128 *)v65;
        else
          v75 = v11;
        if (v71)
          v65 -= 64;
        else
          v11 -= 4;
        *((_WORD *)v66 + 8) = v74;
        *v66 = v73;
        v66 -= 4;
        result = re::DynamicArray<re::internal::DeferredUnregister *>::operator=(v70, (uint64_t)v75 - 40);
        if (v65 == a7)
          goto LABEL_101;
      }
      v91 = 0;
      do
      {
        v92 = &v66[v91 / 0x10];
        v93 = *(_OWORD *)(v65 + v91 - 64);
        *((_WORD *)v92 + 8) = *(_WORD *)(v65 + v91 - 48);
        *v92 = v93;
        result = re::DynamicArray<re::internal::DeferredUnregister *>::operator=((uint64_t)&v66[v91 / 0x10 + 1] + 8, v65 + v91 - 40);
        v91 -= 64;
      }
      while (v65 + v91 != a7);
    }
    goto LABEL_101;
  }
  v104 = 0;
LABEL_101:
  if (a7)
    return std::__destruct_n::__process[abi:nn180100]<re::TraceEntry>((uint64_t)&v104, a7);
  return result;
}

uint64_t std::__destruct_n::__process[abi:nn180100]<re::TraceEntry>(uint64_t result, uint64_t a2)
{
  unint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  _QWORD *v5;

  v2 = *(_QWORD *)result;
  if (*(_QWORD *)result)
  {
    v3 = (unint64_t *)result;
    v4 = 0;
    v5 = (_QWORD *)(a2 + 56);
    do
    {
      result = *(v5 - 4);
      if (result)
      {
        if (*v5)
          result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
        *v5 = 0;
        *(v5 - 3) = 0;
        *(v5 - 2) = 0;
        *(v5 - 4) = 0;
        ++*((_DWORD *)v5 - 2);
        v2 = *v3;
      }
      ++v4;
      v5 += 8;
    }
    while (v4 < v2);
  }
  return result;
}

re::TraceServer *re::TraceServer::TraceServer(re::TraceServer *this)
{
  char *v2;
  char *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *secure_tcp;
  re::TraceFramer *v7;
  NSObject *v8;
  NSObject *options;
  re *v10;
  NSObject *v11;
  _BOOL8 v12;
  uint64_t *v13;
  uint64_t v14;
  const char *v15;
  re *v16;
  char v17;
  NSObject *v18;
  int v19;
  _DWORD v21[2];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  *((_BYTE *)this + 32) = 0;
  v2 = (char *)this + 32;
  *((_QWORD *)this + 10) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 18) = 0;
  *((_BYTE *)this + 88) = 0;
  *((_BYTE *)this + 96) = 0;
  v3 = (char *)this + 96;
  *((_QWORD *)this + 18) = 0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_DWORD *)this + 34) = 0;
  *((_WORD *)this + 76) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 46) = 0;
  *(_QWORD *)this = &off_24ED89710;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 56) = 0;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 30) = 0;
  *((_QWORD *)this + 32) = 850045863;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *((_QWORD *)this + 39) = 0;
  *((_QWORD *)this + 40) = 1018212795;
  *((_QWORD *)this + 50) = 0;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *((_DWORD *)this + 98) = 0;
  v4 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v5 = dispatch_queue_attr_make_with_qos_class(v4, QOS_CLASS_USER_INTERACTIVE, 0);
  *((_QWORD *)this + 31) = dispatch_queue_create("trace server", v5);
  dispatch_release(v5);
  secure_tcp = nw_parameters_create_secure_tcp((nw_parameters_configure_protocol_block_t)*MEMORY[0x24BDE0880], (nw_parameters_configure_protocol_block_t)*MEMORY[0x24BDE0870]);
  *((_QWORD *)this + 1) = secure_tcp;
  v7 = (re::TraceFramer *)nw_parameters_copy_default_protocol_stack(secure_tcp);
  v8 = re::TraceFramer::definition(v7);
  options = nw_framer_create_options(v8);
  nw_protocol_stack_prepend_application_protocol((nw_protocol_stack_t)v7, options);
  nw_release(options);
  nw_release(v7);
  v11 = *re::traceLogObjects(v10);
  v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  if (v12)
  {
    LOWORD(v21[0]) = 0;
    _os_log_impl(&dword_224FE9000, v11, OS_LOG_TYPE_DEFAULT, "TraceServer: Construct", (uint8_t *)v21, 2u);
  }
  *((_BYTE *)this + 32) = 3;
  *((_BYTE *)this + 96) = 4;
  v13 = re::globalAllocators((re *)v12);
  v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v13[2] + 32))(v13[2], 56, 8);
  *(_QWORD *)v14 = v2;
  *(_QWORD *)(v14 + 8) = v3;
  *(_QWORD *)(v14 + 48) = 0;
  *(_QWORD *)(v14 + 24) = 0;
  *(_QWORD *)(v14 + 32) = 0;
  *(_QWORD *)(v14 + 16) = 0;
  *(_DWORD *)(v14 + 40) = 0;
  *((_QWORD *)this + 3) = v14;
  re::Defaults::BOOLValue((re::Defaults *)"trace.enableTraceFromInit", v15, (char *)v21);
  if (LOBYTE(v21[0]))
    v17 = BYTE1(v21[0]);
  else
    v17 = 0;
  *((_BYTE *)this + 153) = v17;
  v18 = *re::traceLogObjects(v16);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    v19 = *((unsigned __int8 *)this + 153);
    v21[0] = 67109120;
    v21[1] = v19;
    _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "TraceServer: Collect trace data from initialzation: %d", (uint8_t *)v21, 8u);
  }
  return this;
}

void re::TraceServer::~TraceServer(re::TraceServer *this)
{
  NSObject *v2;
  uint64_t v3;
  nw_connection_t **v4;
  uint64_t v5;
  nw_connection_t *v6;
  re *v7;
  uint64_t v8;
  void *v9;
  re *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD block[5];
  std::unique_lock<std::mutex> __lk;

  *(_QWORD *)this = &off_24ED89710;
  re::TraceServer::stopListening(this);
  __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 256);
  __lk.__owns_ = 1;
  std::mutex::lock((std::mutex *)this + 4);
  v2 = *((_QWORD *)this + 31);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 0x40000000;
  block[2] = ___ZN2re11TraceServerD2Ev_block_invoke;
  block[3] = &__block_descriptor_tmp_36;
  block[4] = this;
  dispatch_async(v2, block);
  std::condition_variable::wait((std::condition_variable *)((char *)this + 320), &__lk);
  v3 = *((_QWORD *)this + 27);
  if (v3)
  {
    v4 = (nw_connection_t **)*((_QWORD *)this + 29);
    v5 = 8 * v3;
    do
    {
      v6 = *v4++;
      nw_connection_set_state_changed_handler(*v6, 0);
      nw_connection_force_cancel(*v6);
      v8 = re::globalAllocators(v7)[2];
      re::TraceServer::NetworkClient::~NetworkClient((re::TraceServer::NetworkClient *)v6);
      (*(void (**)(uint64_t, nw_connection_t *))(*(_QWORD *)v8 + 40))(v8, v6);
      v5 -= 8;
    }
    while (v5);
  }
  *((_QWORD *)this + 27) = 0;
  ++*((_DWORD *)this + 56);
  v9 = (void *)*((_QWORD *)this + 1);
  if (v9)
  {
    nw_release(v9);
    *((_QWORD *)this + 1) = 0;
  }
  dispatch_release(*((dispatch_object_t *)this + 31));
  *((_QWORD *)this + 31) = 0;
  v11 = *((_QWORD *)this + 3);
  if (v11)
  {
    v12 = re::globalAllocators(v10)[2];
    v13 = *(_QWORD *)(v11 + 16);
    *(_QWORD *)(v11 + 32) = 0;
    v14 = *(_DWORD *)(v11 + 40) + 1;
    *(_DWORD *)(v11 + 40) = v14;
    if (v13)
    {
      if (*(_QWORD *)(v11 + 48))
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
        v14 = *(_DWORD *)(v11 + 40);
      }
      *(_QWORD *)(v11 + 48) = 0;
      *(_QWORD *)(v11 + 24) = 0;
      *(_QWORD *)(v11 + 32) = 0;
      *(_QWORD *)(v11 + 16) = 0;
      *(_DWORD *)(v11 + 40) = v14 + 1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v12 + 40))(v12, v11);
    *((_QWORD *)this + 3) = 0;
  }
  if (__lk.__owns_)
    std::mutex::unlock(__lk.__m_);
  re::DynamicArray<re::SceneCompatibilityVariant>::deinit((uint64_t)this + 368);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 320));
  std::mutex::~mutex((std::mutex *)this + 4);
  v15 = *((_QWORD *)this + 25);
  if (v15)
  {
    if (*((_QWORD *)this + 29))
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
    *((_QWORD *)this + 29) = 0;
    *((_QWORD *)this + 26) = 0;
    *((_QWORD *)this + 27) = 0;
    *((_QWORD *)this + 25) = 0;
    ++*((_DWORD *)this + 56);
  }
  v16 = *((_QWORD *)this + 20);
  if (v16)
  {
    v17 = *((_QWORD *)this + 24);
    if (v17)
    {
      v18 = *((_QWORD *)this + 22);
      if (v18)
      {
        v19 = 56 * v18;
        v20 = v17 + 16;
        do
        {
          re::DynamicArray<re::TraceEntry>::deinit(v20);
          v20 += 56;
          v19 -= 56;
        }
        while (v19);
        v16 = *((_QWORD *)this + 20);
        v17 = *((_QWORD *)this + 24);
      }
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v16 + 40))(v16, v17);
    }
    *((_QWORD *)this + 24) = 0;
    *((_QWORD *)this + 21) = 0;
    *((_QWORD *)this + 22) = 0;
    *((_QWORD *)this + 20) = 0;
    ++*((_DWORD *)this + 46);
  }
  re::DynamicArray<re::TraceEntry>::deinit((uint64_t)this + 112);
  re::DynamicArray<re::TraceEntry>::deinit((uint64_t)this + 48);
}

{
  re::TraceServer::~TraceServer(this);
  JUMPOUT(0x2276933B8);
}

void ___ZN2re11TraceServerD2Ev_block_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  std::mutex::lock((std::mutex *)(v1 + 256));
  std::condition_variable::notify_all((std::condition_variable *)(v1 + 320));
  std::mutex::unlock((std::mutex *)(v1 + 256));
}

void re::TraceServer::startListening(nw_parameters_t *this, const char *a2)
{
  NSObject *v4;
  NSObject *v5;
  nw_parameters_t v6;
  NSObject *v7;
  _QWORD v8[6];
  uint8_t buf[4];
  const char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v4 = *re::traceLogObjects((re *)this);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    v10 = a2;
    _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEFAULT, "TraceServer: start listening on port %s", buf, 0xCu);
  }
  ((void (*)(nw_parameters_t *))(*this)[5].isa)(this);
  v5 = nw_listener_create_with_port(a2, this[1]);
  this[2] = v5;
  nw_listener_set_queue(v5, this[31]);
  nw_listener_set_state_changed_handler(this[2], &__block_literal_global_48);
  v6 = this[31];
  v7 = this[2];
  v8[0] = MEMORY[0x24BDAC760];
  v8[1] = 0x40000000;
  v8[2] = ___ZN2re11TraceServer14startListeningEPKc_block_invoke_5;
  v8[3] = &__block_descriptor_tmp_7_2;
  v8[4] = this;
  v8[5] = v6;
  nw_listener_set_new_connection_handler(v7, v8);
  nw_listener_start(this[2]);
}

void ___ZN2re11TraceServer14startListeningEPKc_block_invoke(re *a1, int a2)
{
  NSObject *v3;
  _DWORD v4[2];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  v3 = *re::traceLogObjects(a1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 67109120;
    v4[1] = a2;
    _os_log_impl(&dword_224FE9000, v3, OS_LOG_TYPE_DEFAULT, "TraceServer: listener state changed to %d\n", (uint8_t *)v4, 8u);
  }
}

void ___ZN2re11TraceServer14startListeningEPKc_block_invoke_5(uint64_t a1, NSObject *a2)
{
  _QWORD *specific;
  _QWORD *v5;
  NSObject *v6;
  char *v7;
  char *v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  char *v12;
  __int16 v13;
  char *v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (specific)
  {
    v5 = specific;
    re::TraceServer::addConnection(*(re::TraceServer **)(a1 + 32), a2);
    v6 = nw_connection_copy_endpoint(a2);
    v7 = nw_endpoint_copy_address_string(v6);
    v8 = nw_endpoint_copy_port_string(v6);
    v9 = *re::traceLogObjects((re *)v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = v5[27];
      v11 = 136315650;
      v12 = v7;
      v13 = 2080;
      v14 = v8;
      v15 = 2048;
      v16 = v10;
      _os_log_impl(&dword_224FE9000, v9, OS_LOG_TYPE_DEFAULT, "TraceServer: new client connection from %s port %s (count=%zu)", (uint8_t *)&v11, 0x20u);
    }
    free(v7);
    free(v8);
    nw_release(v6);
  }
}

void re::TraceServer::addConnection(re::TraceServer *this, NSObject *a2)
{
  uint64_t *v4;
  uint64_t v5;
  _anonymous_namespace_ *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  NSObject *v14;
  _QWORD v15[6];

  v4 = re::globalAllocators(this);
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4[2] + 32))(v4[2], 160, 8);
  *(_QWORD *)v5 = a2;
  *(_BYTE *)(v5 + 8) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_DWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 56) = 0u;
  *(_OWORD *)(v5 + 72) = 0u;
  *(_OWORD *)(v5 + 88) = 0u;
  *(_OWORD *)(v5 + 100) = 0u;
  *(_QWORD *)(v5 + 116) = 0x7FFFFFFFLL;
  *(_BYTE *)(v5 + 128) = 1;
  *(_DWORD *)(v5 + 132) = 0;
  *(_DWORD *)(v5 + 136) = 0;
  *(_QWORD *)(v5 + 144) = 0;
  *(_DWORD *)(v5 + 152) = 0;
  v6 = (_anonymous_namespace_ *)nw_retain(*(void **)v5);
  *(_BYTE *)(v5 + 8) = 2;
  v7 = *((_QWORD *)this + 26);
  v8 = *((_QWORD *)this + 27);
  if (v8 >= v7)
  {
    v9 = v8 + 1;
    if (v7 < v8 + 1)
    {
      if (*((_QWORD *)this + 25))
      {
        v10 = 2 * v7;
        v11 = v7 == 0;
        v12 = 8;
        if (!v11)
          v12 = v10;
        if (v12 <= v9)
          v13 = v9;
        else
          v13 = v12;
        re::DynamicArray<float *>::setCapacity((_QWORD *)this + 25, v13);
      }
      else
      {
        re::DynamicArray<float *>::setCapacity((_QWORD *)this + 25, v9);
        ++*((_DWORD *)this + 56);
      }
    }
    v8 = *((_QWORD *)this + 27);
  }
  *(_QWORD *)(*((_QWORD *)this + 29) + 8 * v8) = v5;
  *((_QWORD *)this + 27) = v8 + 1;
  ++*((_DWORD *)this + 56);
  v14 = *((_QWORD *)this + 31);
  nw_connection_set_queue(a2, v14);
  v15[0] = MEMORY[0x24BDAC760];
  v15[1] = 0x40000000;
  v15[2] = ___ZN2re11TraceServer13addConnectionEP13nw_connection_block_invoke;
  v15[3] = &__block_descriptor_tmp_13_1;
  v15[4] = v14;
  v15[5] = a2;
  nw_connection_set_state_changed_handler(a2, v15);
  nw_connection_start(a2);
}

void re::TraceServer::stopListening(re::TraceServer *this)
{
  NSObject *v2;

  v2 = *((_QWORD *)this + 2);
  if (v2)
  {
    nw_listener_cancel(v2);
    nw_release(*((void **)this + 2));
    *((_QWORD *)this + 2) = 0;
  }
}

void re::TraceServer::send(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  NSObject *v3;
  _QWORD block[7];

  v2 = *a2;
  *a2 = 0;
  v3 = *(NSObject **)(a1 + 248);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 0x40000000;
  block[2] = ___ZN2re11TraceServer4sendENSt3__110unique_ptrINS_10TraceDeltaENS_9REDeleterIS3_EEEE_block_invoke;
  block[3] = &__block_descriptor_tmp_8_2;
  block[4] = a1;
  block[5] = v2;
  block[6] = v3;
  dispatch_async(v3, block);
}

{
  uint64_t v2;
  NSObject *v3;
  _QWORD v4[6];

  v2 = *a2;
  *a2 = 0;
  v3 = *(NSObject **)(a1 + 248);
  v4[0] = MEMORY[0x24BDAC760];
  v4[1] = 0x40000000;
  v4[2] = ___ZN2re11TraceServer4sendENSt3__110unique_ptrINS_14TransferReportENS_9REDeleterIS3_EEEE_block_invoke;
  v4[3] = &__block_descriptor_tmp_9_1;
  v4[4] = v2;
  v4[5] = v3;
  dispatch_async(v3, v4);
}

void re::`anonymous namespace'::validateTraceDelta(unint64_t **this, const re::TraceDelta *a2)
{
  re *v3;
  unint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  NSObject *v20;
  unint64_t *v21;
  uint8_t buf[4];
  _BYTE v23[18];
  __int16 v24;
  unint64_t v25;
  __int16 v26;
  int v27;
  __int16 v28;
  unint64_t v29;
  __int16 v30;
  unint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  if ((_DWORD)v3)
  {
    v4 = this[4];
    if (v4)
    {
      v5 = 0;
      v6 = 0;
      v7 = 0;
      v8 = this[6];
      v9 = (_QWORD)v4 << 6;
      do
      {
        if (*((_BYTE *)v8 + 16) != 3 && !v8[5])
        {
          v10 = *re::traceLogObjects(v3);
          v3 = (re *)os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
          if ((_DWORD)v3)
          {
            v16 = this[1];
            v17 = *v8;
            v18 = v8[1];
            v19 = *((unsigned __int8 *)v8 + 16);
            *(_DWORD *)buf = 134218752;
            *(_QWORD *)v23 = v16;
            *(_WORD *)&v23[8] = 2048;
            *(_QWORD *)&v23[10] = v17;
            v24 = 2048;
            v25 = v18;
            v26 = 1024;
            v27 = v19;
            _os_log_error_impl(&dword_224FE9000, v10, OS_LOG_TYPE_ERROR, "Missing entry payload in non-removal trace: timestamp: %f, id=%llu, child=%llu, mode=%d", buf, 0x26u);
          }
          ++v5;
        }
        if (*v8 <= v6)
        {
          if (*v8 != v6 || v8[1] <= v7)
          {
            v11 = *re::traceLogObjects(v3);
            v3 = (re *)os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
            if ((_DWORD)v3)
            {
              v12 = this[1];
              v13 = *v8;
              v14 = v8[1];
              v15 = *((unsigned __int8 *)v8 + 16);
              *(_DWORD *)buf = 134219264;
              *(_QWORD *)v23 = v12;
              *(_WORD *)&v23[8] = 2048;
              *(_QWORD *)&v23[10] = v13;
              v24 = 2048;
              v25 = v14;
              v26 = 1024;
              v27 = v15;
              v28 = 2048;
              v29 = v6;
              v30 = 2048;
              v31 = v7;
              _os_log_error_impl(&dword_224FE9000, v11, OS_LOG_TYPE_ERROR, "Detected non-sorted entry: timestamp: %f, id=%llu, child=%llu, mode=%d, prevId=%llu, prevChild=%llu", buf, 0x3Au);
            }
            ++v5;
            v6 = *v8;
          }
        }
        else
        {
          v6 = *v8;
        }
        v7 = v8[1];
        v8 += 8;
        v9 -= 64;
      }
      while (v9);
      if (v5 > 0)
      {
        v20 = *re::traceLogObjects(v3);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          v21 = this[1];
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)v23 = v5;
          *(_WORD *)&v23[4] = 2048;
          *(_QWORD *)&v23[6] = v21;
          _os_log_error_impl(&dword_224FE9000, v20, OS_LOG_TYPE_ERROR, "%d errors found at timestamp: %f", buf, 0x12u);
        }
      }
    }
  }
}

void re::`anonymous namespace'::validateSnapshot(unint64_t **this, const re::TraceDelta *a2)
{
  re *v3;
  NSObject *v4;
  unint64_t *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  int v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t v25;
  int v26;
  NSObject *v27;
  int v28;
  unint64_t *v29;
  uint8_t buf[4];
  _BYTE v31[18];
  __int16 v32;
  unint64_t v33;
  __int16 v34;
  int v35;
  __int16 v36;
  unint64_t v37;
  __int16 v38;
  unint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  if ((_DWORD)v3)
  {
    if (*(_BYTE *)this != 3)
    {
      v4 = *re::traceLogObjects(v3);
      v3 = (re *)os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
      if ((_DWORD)v3)
      {
        v28 = *(unsigned __int8 *)this;
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)v31 = v28;
        _os_log_error_impl(&dword_224FE9000, v4, OS_LOG_TYPE_ERROR, "Invalid type for initial snapshot: %d", buf, 8u);
      }
    }
    v5 = this[4];
    if (v5)
    {
      v6 = 0;
      v7 = 0;
      v8 = 0;
      v9 = this[6];
      v10 = (_QWORD)v5 << 6;
      do
      {
        if (*((_BYTE *)v9 + 16) != 1)
        {
          v11 = *re::traceLogObjects(v3);
          v3 = (re *)os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
          if ((_DWORD)v3)
          {
            v14 = this[1];
            v15 = *v9;
            v16 = v9[1];
            v17 = *((unsigned __int8 *)v9 + 16);
            v18 = v9[5];
            *(_DWORD *)buf = 134219008;
            *(_QWORD *)v31 = v14;
            *(_WORD *)&v31[8] = 2048;
            *(_QWORD *)&v31[10] = v15;
            v32 = 2048;
            v33 = v16;
            v34 = 1024;
            v35 = v17;
            v36 = 2048;
            v37 = v18;
            _os_log_error_impl(&dword_224FE9000, v11, OS_LOG_TYPE_ERROR, "Unexpected mode in initial snapshot: timestamp: %f, id=%llu, child=%llu, mode=%d, data=%zu", buf, 0x30u);
          }
          ++v6;
        }
        if (!v9[5])
        {
          v12 = *re::traceLogObjects(v3);
          v3 = (re *)os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
          if ((_DWORD)v3)
          {
            v19 = this[1];
            v20 = *v9;
            v21 = v9[1];
            v22 = *((unsigned __int8 *)v9 + 16);
            *(_DWORD *)buf = 134218752;
            *(_QWORD *)v31 = v19;
            *(_WORD *)&v31[8] = 2048;
            *(_QWORD *)&v31[10] = v20;
            v32 = 2048;
            v33 = v21;
            v34 = 1024;
            v35 = v22;
            _os_log_error_impl(&dword_224FE9000, v12, OS_LOG_TYPE_ERROR, "Missing snapshot payload in non-removal trace: timestamp: %f, id=%llu, child=%llu, mode=%d", buf, 0x26u);
          }
          ++v6;
        }
        if (*v9 <= v8)
        {
          if (*v9 != v8 || v9[1] <= v7)
          {
            v13 = *re::traceLogObjects(v3);
            v3 = (re *)os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
            if ((_DWORD)v3)
            {
              v23 = this[1];
              v24 = *v9;
              v25 = v9[1];
              v26 = *((unsigned __int8 *)v9 + 16);
              *(_DWORD *)buf = 134219264;
              *(_QWORD *)v31 = v23;
              *(_WORD *)&v31[8] = 2048;
              *(_QWORD *)&v31[10] = v24;
              v32 = 2048;
              v33 = v25;
              v34 = 1024;
              v35 = v26;
              v36 = 2048;
              v37 = v8;
              v38 = 2048;
              v39 = v7;
              _os_log_error_impl(&dword_224FE9000, v13, OS_LOG_TYPE_ERROR, "Detected non-sorted entry in snapshot: timestamp: %f, id=%llu, child=%llu, mode=%d, prevId=%llu, prevChild=%llu", buf, 0x3Au);
            }
            ++v6;
            v8 = *v9;
          }
        }
        else
        {
          v8 = *v9;
        }
        v7 = v9[1];
        v9 += 8;
        v10 -= 64;
      }
      while (v10);
      if (v6 > 0)
      {
        v27 = *re::traceLogObjects(v3);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          v29 = this[1];
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)v31 = v6;
          *(_WORD *)&v31[4] = 2048;
          *(_QWORD *)&v31[6] = v29;
          _os_log_error_impl(&dword_224FE9000, v27, OS_LOG_TYPE_ERROR, "%d errors found in snapshot at timestamp: %f", buf, 0x12u);
        }
      }
    }
  }
}

uint64_t re::DynamicArray<re::TraceDelta>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  _OWORD *v11;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(_QWORD *)a1)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        re::DynamicArray<re::TraceDelta>::setCapacity((_QWORD *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::TraceDelta>::setCapacity((_QWORD *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    v5 = *(_QWORD *)(a1 + 16);
  }
  v11 = (_OWORD *)(*(_QWORD *)(a1 + 32) + 56 * v5);
  *v11 = *(_OWORD *)a2;
  result = re::DynamicArray<re::TraceEntry>::DynamicArray((uint64_t)(v11 + 1), (uint64_t *)(a2 + 16));
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::TraceServer::trySendInitialDeltas(re::TraceServer *this, NSObject **a2)
{
  double v4;
  double v5;
  const re::TraceDelta *v6;
  const re::TraceDelta *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  _BYTE v17[48];

  if (*((_BYTE *)a2 + 128)
    && (*(unsigned int (**)(re::TraceServer *))(*(_QWORD *)this + 80))(this)
    && (*(unsigned int (**)(re::TraceServer *))(*(_QWORD *)this + 88))(this))
  {
    v4 = *((double *)this + 13);
    v5 = *((double *)this + 5);
    if (v4 >= v5)
      v6 = (re::TraceServer *)((char *)this + 32);
    else
      v6 = (re::TraceServer *)((char *)this + 96);
    if (v4 >= v5)
      v7 = (re::TraceServer *)((char *)this + 96);
    else
      v7 = (re::TraceServer *)((char *)this + 32);
    if (v4 >= v5)
      v8 = (char *)this + 104;
    else
      v8 = (char *)this + 40;
    re::TraceServer::send(this, v6, *a2);
    re::TraceServer::send(this, v7, *a2);
    a2[18] = *(NSObject **)v8;
    if (*((_BYTE *)this + 153))
    {
      v9 = *((_QWORD *)this + 22);
      if (v9)
      {
        v10 = 56 * v9;
        v11 = (uint64_t *)(*((_QWORD *)this + 24) + 16);
        do
        {
          v16 = *((_OWORD *)v11 - 1);
          re::DynamicArray<re::TraceEntry>::DynamicArray((uint64_t)v17, v11);
          re::TraceServer::send(this, (const re::TraceDelta *)&v16, *a2);
          re::TraceDelta::merge((re::TraceServer *)((char *)this + 32), (const re::TraceDelta *)&v16);
          re::DynamicArray<re::TraceEntry>::deinit((uint64_t)v17);
          v11 += 7;
          v10 -= 56;
        }
        while (v10);
        v12 = *((_QWORD *)this + 22);
        v13 = *((_QWORD *)this + 24);
        *((_BYTE *)this + 153) = 0;
        *((_QWORD *)this + 22) = 0;
        if (v12)
        {
          v14 = 56 * v12;
          v15 = v13 + 16;
          do
          {
            re::DynamicArray<re::TraceEntry>::deinit(v15);
            v15 += 56;
            v14 -= 56;
          }
          while (v14);
        }
      }
      else
      {
        *((_BYTE *)this + 153) = 0;
        *((_QWORD *)this + 22) = 0;
      }
      ++*((_DWORD *)this + 46);
    }
    *((_BYTE *)a2 + 128) = 0;
  }
}

void re::TraceServer::send(re::TraceServer *this, const re::TraceDelta *a2, NSObject *a3)
{
  NSObject *v6;
  NSObject *v7;
  uint8_t **v8;
  uint8_t *v9;
  uint8_t buf[8];
  __int128 v11;
  _BYTE v12[24];

  if (*((double *)a2 + 1) == 0.0)
  {
    v7 = *re::traceLogObjects(this);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl(&dword_224FE9000, v7, OS_LOG_TYPE_ERROR, "Sending a trace frame with timestamp=0.0. This is unexpected!", buf, 2u);
    }
  }
  *(_QWORD *)buf = &off_24ED7DDF0;
  v11 = 0u;
  memset(v12, 0, sizeof(v12));
  re::zerocopy::DispatchWriteStream::clear((re::zerocopy::DispatchWriteStream *)buf);
  *(int64x2_t *)&v12[8] = vdupq_n_s64(0x1000uLL);
  *((_QWORD *)&v11 + 1) = dispatch_data_create_alloc();
  v8 = &v9;
  v9 = buf;
  re::TraceDeltaWriter::writeDelta((re::zerocopy ***)&v8, a2);
  re::zerocopy::DispatchWriteStream::mergeTail((re::zerocopy::DispatchWriteStream *)buf);
  v6 = v11;
  *(_QWORD *)&v11 = 0;
  re::zerocopy::DispatchWriteStream::clear((re::zerocopy::DispatchWriteStream *)buf);
  *(_QWORD *)buf = &off_24ED7DDF0;
  re::zerocopy::DispatchWriteStream::clear((re::zerocopy::DispatchWriteStream *)buf);
  *(_QWORD *)buf = 2;
  *(_QWORD *)&v11 = v6;
  re::TraceServer::send(this, buf, a3);
  dispatch_release(v6);
}

void re::TraceServer::send(_QWORD *a1, unsigned __int8 *a2, NSObject *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  re::TraceFramer *v10;
  NSObject *v11;
  _QWORD completion[6];
  char v13;

  v5 = a1[27];
  if (v5)
  {
    v6 = a1[29];
    v7 = 8 * v5;
    while (**(NSObject ***)v6 != a3)
    {
      v6 += 8;
      v7 -= 8;
      if (!v7)
        goto LABEL_8;
    }
    if (*a2 == 2)
      ++*(_DWORD *)(*(_QWORD *)v6 + 132);
  }
LABEL_8:
  v8 = a1[31];
  v9 = *a2;
  v10 = (re::TraceFramer *)nw_content_context_create("re-trace");
  re::TraceFramer::setMessageType(v10, *a2);
  v11 = *((_QWORD *)a2 + 1);
  completion[0] = MEMORY[0x24BDAC760];
  completion[1] = 0x40000000;
  completion[2] = ___ZN2re11TraceServer4sendERKNS_12TraceMessageEP13nw_connection_block_invoke;
  completion[3] = &__block_descriptor_tmp_17_0;
  v13 = v9;
  completion[4] = v8;
  completion[5] = a3;
  nw_connection_send(a3, v11, (nw_content_context_t)v10, 1, completion);
  nw_release(v10);
}

void re::TraceServer::send(_QWORD *a1, uint64_t a2, NSObject *a3)
{
  NSObject *v6;
  re::zerocopy **v7;
  uint64_t *v8;
  uint64_t v9;
  __int128 v10;
  _BYTE v11[24];

  v9 = (uint64_t)&off_24ED7DDF0;
  v10 = 0u;
  memset(v11, 0, sizeof(v11));
  re::zerocopy::DispatchWriteStream::clear((re::zerocopy::DispatchWriteStream *)&v9);
  *(int64x2_t *)&v11[8] = vdupq_n_s64(0x1000uLL);
  *((_QWORD *)&v10 + 1) = dispatch_data_create_alloc();
  v7 = (re::zerocopy **)&v8;
  v8 = &v9;
  re::TransferReportWriter::write(&v7, a2);
  re::zerocopy::DispatchWriteStream::mergeTail((re::zerocopy::DispatchWriteStream *)&v9);
  v6 = v10;
  *(_QWORD *)&v10 = 0;
  re::zerocopy::DispatchWriteStream::clear((re::zerocopy::DispatchWriteStream *)&v9);
  v9 = (uint64_t)&off_24ED7DDF0;
  re::zerocopy::DispatchWriteStream::clear((re::zerocopy::DispatchWriteStream *)&v9);
  v9 = 3;
  *(_QWORD *)&v10 = v6;
  re::TraceServer::send(a1, (unsigned __int8 *)&v9, a3);
  dispatch_release(v6);
}

BOOL re::TraceServer::addClientFromConnectedSocket(re::TraceServer *this, int a2)
{
  uint64_t v4;
  NSObject *v5;
  _QWORD block[6];
  int v8;

  v4 = nw_connection_create_with_connected_socket_and_parameters();
  if (v4)
  {
    v5 = *((_QWORD *)this + 31);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 0x40000000;
    block[2] = ___ZN2re11TraceServer28addClientFromConnectedSocketEi_block_invoke;
    block[3] = &__block_descriptor_tmp_10_1;
    block[4] = v4;
    block[5] = v5;
    v8 = a2;
    dispatch_async(v5, block);
  }
  return v4 != 0;
}

void ___ZN2re11TraceServer28addClientFromConnectedSocketEi_block_invoke(uint64_t a1)
{
  NSObject *v2;
  re::TraceServer *specific;
  re::TraceServer *v4;
  re *v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  _DWORD v9[2];
  __int16 v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v2 = *(NSObject **)(a1 + 32);
  if (specific)
  {
    v4 = specific;
    re::TraceServer::addConnection(specific, v2);
    v6 = *re::traceLogObjects(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_DWORD *)(a1 + 48);
      v8 = *((_QWORD *)v4 + 27);
      v9[0] = 67109376;
      v9[1] = v7;
      v10 = 2048;
      v11 = v8;
      _os_log_impl(&dword_224FE9000, v6, OS_LOG_TYPE_DEFAULT, "TraceServer: new client connection from fd://%d (count=%zu)", (uint8_t *)v9, 0x12u);
    }
  }
  nw_release(v2);
}

void re::TraceServer::addDirectClient(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  _QWORD v3[6];

  v2 = *(NSObject **)(a1 + 248);
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 0x40000000;
  v3[2] = ___ZN2re11TraceServer15addDirectClientEPNS_17TraceDirectClientE_block_invoke;
  v3[3] = &__block_descriptor_tmp_11_2;
  v3[4] = v2;
  v3[5] = a2;
  dispatch_async(v2, v3);
}

void ___ZN2re11TraceServer15addDirectClientEPNS_17TraceDirectClientE_block_invoke(uint64_t a1)
{
  re *specific;
  _BYTE *v3;
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  NSObject *v13;
  const char *v14;
  uint8_t *v15;
  __int16 v16;
  __int16 v17;

  if (!specific)
    return;
  v3 = *(_BYTE **)(a1 + 40);
  if (!v3)
  {
    v13 = *re::traceLogObjects(specific);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      return;
    v17 = 0;
    v15 = (uint8_t *)&v17;
    goto LABEL_26;
  }
  v4 = *((_QWORD *)specific + 3);
  v5 = *(_QWORD **)(v4 + 48);
  v6 = *(_QWORD *)(v4 + 32);
  v7 = v5;
  if (v6)
  {
    v8 = 8 * v6;
    v7 = *(_QWORD **)(v4 + 48);
    while ((_BYTE *)*v7 != v3)
    {
      ++v7;
      v8 -= 8;
      if (!v8)
      {
        v7 = &v5[v6];
        break;
      }
    }
  }
  if (v6 != v7 - v5)
  {
    v13 = *re::traceLogObjects(specific);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      return;
    v16 = 0;
    v14 = "TraceServer: error adding TraceDirectClient. The client has already been added";
    v15 = (uint8_t *)&v16;
LABEL_26:
    _os_log_error_impl(&dword_224FE9000, v13, OS_LOG_TYPE_ERROR, v14, v15, 2u);
    return;
  }
  v9 = *(_QWORD *)(v4 + 24);
  if (v6 >= v9)
  {
    v10 = v6 + 1;
    if (v9 < v6 + 1)
    {
      if (*(_QWORD *)(v4 + 16))
      {
        v11 = 2 * v9;
        if (!v9)
          v11 = 8;
        if (v11 <= v10)
          v12 = v10;
        else
          v12 = v11;
        re::DynamicArray<float *>::setCapacity((_QWORD *)(v4 + 16), v12);
      }
      else
      {
        re::DynamicArray<float *>::setCapacity((_QWORD *)(v4 + 16), v10);
        ++*(_DWORD *)(v4 + 40);
      }
    }
    v6 = *(_QWORD *)(v4 + 32);
    v5 = *(_QWORD **)(v4 + 48);
  }
  v5[v6] = v3;
  *(_QWORD *)(v4 + 32) = v6 + 1;
  ++*(_DWORD *)(v4 + 40);
  v3[8] = 1;
  re::TraceDirectServer::trySendInitialDeltas((_QWORD *)v4, v3);
}

void re::TraceServer::removeDirectClient(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  _QWORD v3[6];

  v2 = *(NSObject **)(a1 + 248);
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 0x40000000;
  v3[2] = ___ZN2re11TraceServer18removeDirectClientEPNS_17TraceDirectClientE_block_invoke;
  v3[3] = &__block_descriptor_tmp_12_0;
  v3[4] = v2;
  v3[5] = a2;
  dispatch_async(v2, v3);
}

_QWORD *re::TraceServer::tryClearDeltas(re::TraceServer *this)
{
  _QWORD *result;

  result = (_QWORD *)(*(uint64_t (**)(re::TraceServer *))(*(_QWORD *)this + 72))(this);
  if (!result)
  {
    *((_QWORD *)this + 5) = 0;
    re::DynamicArray<re::TraceEntry>::clear((_QWORD *)this + 6);
    atomic_store(0, (unsigned __int8 *)this + 152);
    *((_QWORD *)this + 13) = 0;
    re::DynamicArray<re::TraceEntry>::clear((_QWORD *)this + 14);
    atomic_store(0, (unsigned __int8 *)this + 88);
    return re::DynamicArray<re::SceneCompatibilityVariant>::clear((_QWORD *)this + 46);
  }
  return result;
}

unint64_t re::TraceServer::numTraceDeltaClients(re::TraceServer *this)
{
  unint64_t v1;

  v1 = atomic_load((unint64_t *)this + 30);
  return *(_QWORD *)(*((_QWORD *)this + 3) + 32) + v1;
}

uint64_t re::TraceServer::hasMetadata(re::TraceServer *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)this + 88);
  return v1 & 1;
}

uint64_t re::TraceServer::hasInitialSnapshot(re::TraceServer *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)this + 152);
  return v1 & 1;
}

void ___ZN2re11TraceServer13addConnectionEP13nw_connection_block_invoke(uint64_t a1, int a2)
{
  re::TraceServer *specific;
  NSObject *v5;
  uint64_t v6;
  _QWORD v7[6];

  if (specific)
  {
    if (a2 == 3)
    {
      v5 = *(NSObject **)(a1 + 40);
      v6 = *((_QWORD *)specific + 31);
      v7[0] = MEMORY[0x24BDAC760];
      v7[1] = 0x40000000;
      v7[2] = ___ZN2re11TraceServer15scheduleReceiveEPS0_P13nw_connection_block_invoke;
      v7[3] = &__block_descriptor_tmp_15_2;
      v7[4] = v6;
      v7[5] = v5;
      nw_connection_receive_message(v5, v7);
    }
    else if ((a2 & 0xFFFFFFFE) == 4)
    {
      re::TraceServer::removeConnection(specific, *(nw_connection_t *)(a1 + 40));
    }
  }
}

_QWORD *re::TraceServer::removeConnection(re::TraceServer *this, nw_connection_t connection)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  re::TraceServer::NetworkClient *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  re *v11;
  uint64_t v12;
  re *v13;
  unint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  uint8_t buf[16];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v3 = *((_QWORD *)this + 27);
  if (v3)
  {
    v4 = 0;
    v5 = 0;
    v6 = -v3;
    while (1)
    {
      v7 = *(re::TraceServer::NetworkClient **)(*((_QWORD *)this + 29) + v5);
      if (*(nw_connection_t *)v7 == connection)
        break;
      v5 += 8;
      if (v6 == --v4)
        return re::TraceServer::tryClearDeltas(this);
    }
    v8 = -v4;
    if ((*((_BYTE *)v7 + 152) & 1) != 0)
    {
      v9 = (unint64_t *)((char *)this + 240);
      do
        v10 = __ldaxr(v9);
      while (__stlxr(v10 - 1, v9));
    }
    nw_connection_cancel(connection);
    v12 = re::globalAllocators(v11)[2];
    re::TraceServer::NetworkClient::~NetworkClient(v7);
    v13 = (re *)(*(uint64_t (**)(uint64_t, re::TraceServer::NetworkClient *))(*(_QWORD *)v12 + 40))(v12, v7);
    v14 = *((_QWORD *)this + 27);
    if (v14 <= v8)
    {
      v22 = 0u;
      v23 = 0u;
      v20 = 0u;
      v21 = 0u;
      *(_OWORD *)buf = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v15 = v14 - 1;
    if (v14 - 1 > v8 && 8 * v14 - 8 != v5)
    {
      v13 = (re *)memmove((void *)(*((_QWORD *)this + 29) + v5), (const void *)(*((_QWORD *)this + 29) + v5 + 8), 8 * v14 - v5 - 8);
      v15 = *((_QWORD *)this + 27) - 1;
    }
    *((_QWORD *)this + 27) = v15;
    ++*((_DWORD *)this + 56);
    v16 = *re::traceLogObjects(v13);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = *((_QWORD *)this + 27);
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v17;
      _os_log_impl(&dword_224FE9000, v16, OS_LOG_TYPE_DEFAULT, "TraceServer: removed client connection (count=%zu)", buf, 0xCu);
    }
  }
  return re::TraceServer::tryClearDeltas(this);
}

void ___ZN2re11TraceServer15scheduleReceiveEPS0_P13nw_connection_block_invoke(uint64_t a1, uint64_t a2, re::TraceFramer *a3, char a4, uint64_t a5)
{
  char *specific;
  char *v11;
  re *v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  NSObject ***v17;
  NSObject **v18;
  uint64_t v19;
  int v20;
  int v21;
  unint64_t *v22;
  unint64_t v23;
  re *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  unint64_t *v31;
  unint64_t v32;
  NSObject *v33;
  _QWORD *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  NSObject *v38;
  char *v39;
  NSObject *v40;
  uint64_t v41;
  unint64_t v42;
  _QWORD *v43;
  char v44;
  NSObject *v45;
  uint64_t v46;
  char v47;
  unsigned __int8 v48;
  _QWORD v49[2];
  uint64_t v50;
  int v51;
  _QWORD *v52;
  NSObject v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 *v66;
  __int128 v67;
  uint64_t v68;
  uint64_t v69;
  _BYTE v70[12];
  __int16 v71;
  uint64_t v72;
  _QWORD buf[24];
  char v74;
  int v75;
  uint64_t v76;

  v76 = *MEMORY[0x24BDAC8D0];
  if (!specific)
    return;
  v11 = specific;
  if (a2)
  {
    if (a3)
    {
      re::TraceFramer::messageType(a3, &v47);
      if (v47)
      {
        v13 = *((_QWORD *)v11 + 27);
        if (v13)
        {
          v14 = *(NSObject **)(a1 + 40);
          v15 = v48;
          v16 = 8 * v13;
          v17 = (NSObject ***)*((_QWORD *)v11 + 29);
          while (1)
          {
            v18 = *v17;
            if (**v17 == v14)
              break;
            ++v17;
            v16 -= 8;
            if (!v16)
              goto LABEL_58;
          }
          if (v48 != 4)
          {
            if (v48 != 1)
            {
              v30 = *re::traceLogObjects(v12);
              if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(buf[0]) = 67109120;
                HIDWORD(buf[0]) = v15;
                _os_log_impl(&dword_224FE9000, v30, OS_LOG_TYPE_DEFAULT, "TraceServer received unexpected TraceMessageType: %hhu", (uint8_t *)buf, 8u);
              }
              goto LABEL_58;
            }
            v53.isa = (Class)&off_24ED7DC58;
            v66 = &v54;
            v67 = xmmword_226147220;
            v54 = 0u;
            v55 = 0u;
            v56 = 0u;
            v57 = 0u;
            v58 = 0u;
            v59 = 0u;
            v60 = 0u;
            v61 = 0u;
            v62 = 0u;
            v63 = 0u;
            v64 = 0u;
            v65 = 0u;
            v68 = 0;
            v69 = 0;
            dispatch_data_apply_f();
            re::OPackReader::OPackReader((uint64_t)buf, (uint64_t)&v53);
            if (re::OPackReader::next((re::OPackReader *)buf, v19) && v74 == 6)
            {
              v20 = *((_DWORD *)v18 + 38);
              v21 = v75 & 1;
              *((_DWORD *)v18 + 38) = v75;
              if ((v20 & 1) != 0 || !v21)
              {
                if ((v20 & 1) != 0 && !v21)
                {
                  v31 = (unint64_t *)(v11 + 240);
                  do
                    v32 = __ldaxr(v31);
                  while (__stlxr(v32 - 1, v31));
                }
              }
              else
              {
                v22 = (unint64_t *)(v11 + 240);
                do
                  v23 = __ldaxr(v22);
                while (__stlxr(v23 + 1, v22));
                re::TraceServer::trySendInitialDeltas((re::TraceServer *)v11, v18);
              }
            }
            goto LABEL_57;
          }
          v53.isa = (Class)&off_24ED7DC58;
          v66 = &v54;
          v67 = xmmword_226147220;
          v54 = 0u;
          v55 = 0u;
          v56 = 0u;
          v57 = 0u;
          v58 = 0u;
          v59 = 0u;
          v60 = 0u;
          v61 = 0u;
          v62 = 0u;
          v63 = 0u;
          v64 = 0u;
          v65 = 0u;
          v68 = 0;
          v69 = 0;
          dispatch_data_apply_f();
          re::OPackReader::OPackReader((uint64_t)buf, (uint64_t)&v53);
          v52 = 0;
          v49[1] = 0;
          v50 = 0;
          v49[0] = 0;
          v51 = 0;
          *(_QWORD *)v70 = buf;
          v24 = (re *)re::TraceTargetAppInfoReader::read((re::OPackReader **)v70, (_anonymous_namespace_ *)v49);
          if ((_DWORD)v24)
          {
            v25 = v50;
            v26 = atomic_load((unint64_t *)v11 + 30);
            v27 = *((_QWORD *)v11 + 48);
            if (v26)
            {
              if (v27 != v50)
              {
LABEL_34:
                v33 = *re::traceLogObjects(v24);
                if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)v70 = 0;
                  _os_log_error_impl(&dword_224FE9000, v33, OS_LOG_TYPE_ERROR, "TraceServer is already capturing with different app-mode configuration, stopping the connection", v70, 2u);
                }
                re::TraceServer::removeConnection((re::TraceServer *)v11, v14);
                goto LABEL_56;
              }
              if (v50)
              {
                v28 = (uint64_t)(v52 + 1);
                v29 = *((_QWORD *)v11 + 50) + 8;
                while (1)
                {
                  v24 = (re *)re::DynamicString::operator!=(v29, v28);
                  if ((_DWORD)v24)
                    goto LABEL_34;
                  v28 += 40;
                  v29 += 40;
                  if (!--v25)
                    goto LABEL_56;
                }
              }
LABEL_38:
              if (v50)
              {
                v34 = v52;
                v35 = 40 * v50;
                do
                {
                  v36 = v34[2];
                  if ((v36 & 1) != 0)
                    v37 = v36 >> 1;
                  else
                    v37 = v36 >> 1;
                  if (v37 && *v34)
                  {
                    v38 = *re::traceLogObjects(v24);
                    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
                    {
                      if ((v34[2] & 1) != 0)
                        v39 = (char *)v34[3];
                      else
                        v39 = (char *)v34 + 17;
                      v41 = *v34;
                      *(_DWORD *)v70 = 136315394;
                      *(_QWORD *)&v70[4] = v39;
                      v71 = 2048;
                      v72 = v41;
                      _os_log_impl(&dword_224FE9000, v38, OS_LOG_TYPE_DEFAULT, "TraceServer received App mode request: %s, %llu", v70, 0x16u);
                    }
                    v42 = *((_QWORD *)v11 + 48);
                    if (v42 >= *((_QWORD *)v11 + 47))
                    {
                      re::DynamicArray<re::TraceTargetAppInfo>::growCapacity((_QWORD *)v11 + 46, v42 + 1);
                      v42 = *((_QWORD *)v11 + 48);
                    }
                    v43 = (_QWORD *)(*((_QWORD *)v11 + 50) + 40 * v42);
                    *v43 = *v34;
                    v24 = re::DynamicString::DynamicString((re::DynamicString *)(v43 + 1), (const re::DynamicString *)(v34 + 1));
                    ++*((_QWORD *)v11 + 48);
                    ++*((_DWORD *)v11 + 98);
                  }
                  else
                  {
                    v40 = *re::traceLogObjects(v24);
                    v24 = (re *)os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT);
                    if ((_DWORD)v24)
                    {
                      *(_WORD *)v70 = 0;
                      _os_log_impl(&dword_224FE9000, v40, OS_LOG_TYPE_DEFAULT, "TraceServer received App mode request with incorrect bundleID or peerID", v70, 2u);
                    }
                  }
                  v34 += 5;
                  v35 -= 40;
                }
                while (v35);
              }
              goto LABEL_56;
            }
            if (!v27)
              goto LABEL_38;
          }
LABEL_56:
          re::DynamicArray<re::SceneCompatibilityVariant>::deinit((uint64_t)v49);
LABEL_57:
          re::OPackReader::~OPackReader((re::OPackReader *)buf);
          re::zerocopy::DispatchReadStream::~DispatchReadStream(&v53);
        }
      }
    }
  }
LABEL_58:
  if (a2)
    v44 = 0;
  else
    v44 = a4;
  if ((v44 & 1) == 0 && !a5)
  {
    v45 = *(NSObject **)(a1 + 40);
    v46 = *((_QWORD *)v11 + 31);
    buf[0] = MEMORY[0x24BDAC760];
    buf[1] = 0x40000000;
    buf[2] = ___ZN2re11TraceServer15scheduleReceiveEPS0_P13nw_connection_block_invoke;
    buf[3] = &__block_descriptor_tmp_15_2;
    buf[4] = v46;
    buf[5] = v45;
    nw_connection_receive_message(v45, buf);
  }
}

void re::TraceServer::NetworkClient::~NetworkClient(re::TraceServer::NetworkClient *this)
{
  char *v2;

  v2 = (char *)this + 24;
  nw_release(*(void **)this);
  *(_QWORD *)this = 0;
  re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::deinit((uint64_t *)this + 10);
  re::DynamicArray<re::TraceEntry>::deinit((uint64_t)v2);
}

_QWORD *re::TraceDirectServer::trySendInitialDeltas(_QWORD *result, _BYTE *a2)
{
  _QWORD *v3;

  if (*(_QWORD *)(result[1] + 32))
  {
    v3 = result;
    if (*(_QWORD *)(*result + 32))
    {
      if (a2[8])
      {
        (*(void (**)(_BYTE *))(*(_QWORD *)a2 + 16))(a2);
        result = (_QWORD *)(*(uint64_t (**)(_BYTE *, _QWORD))(*(_QWORD *)a2 + 16))(a2, *v3);
        a2[8] = 0;
      }
    }
  }
  return result;
}

uint64_t re::TraceServer::isTraceFromInitEnabled(re::TraceServer *this)
{
  return *((unsigned __int8 *)this + 153);
}

uint64_t re::TraceServer::targetApps(re::TraceServer *this)
{
  return *((_QWORD *)this + 50);
}

uint64_t re::DynamicArray<re::TraceEntry>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::TraceEntry>::copy((_QWORD *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::TraceEntry>::clear((_QWORD *)a1);
      }
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::TraceEntry>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::TraceEntry>::copy((_QWORD *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

__int128 *re::DynamicArray<re::TraceEntry>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  __int128 *result;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  __int128 v13;
  uint64_t v14;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::TraceEntry>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::TraceEntry *,re::TraceEntry *,re::TraceEntry *,0>(*(__int128 **)(a2 + 32), (__int128 *)(*(_QWORD *)(a2 + 32) + (a1[2] << 6)), a1[4]);
    v9 = a1[2];
    if (v9 != v4)
    {
      v10 = (v4 << 6) - (v9 << 6);
      v11 = (v9 << 6) | 0x18;
      v12 = (uint64_t *)(*(_QWORD *)(a2 + 32) + v11);
      result = (__int128 *)(a1[4] + v11);
      do
      {
        v13 = *(_OWORD *)(v12 - 3);
        *((_WORD *)result - 4) = *((_WORD *)v12 - 4);
        *(__int128 *)((char *)result - 24) = v13;
        v14 = re::DynamicArray<BOOL>::DynamicArray((uint64_t)result, v12);
        v12 += 8;
        result = (__int128 *)(v14 + 64);
        v10 -= 64;
      }
      while (v10);
    }
  }
  else
  {
    result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::TraceEntry *,re::TraceEntry *,re::TraceEntry *,0>(*(__int128 **)(a2 + 32), (__int128 *)(*(_QWORD *)(a2 + 32) + (v4 << 6)), a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      v7 = (v6 << 6) - (v4 << 6);
      v8 = (_QWORD *)(a1[4] + (v4 << 6) + 56);
      do
      {
        result = (__int128 *)*(v8 - 4);
        if (result)
        {
          if (*v8)
            result = (__int128 *)(*(uint64_t (**)(__int128 *))(*(_QWORD *)result + 40))(result);
          *v8 = 0;
          *(v8 - 3) = 0;
          *(v8 - 2) = 0;
          *(v8 - 4) = 0;
          ++*((_DWORD *)v8 - 2);
        }
        v8 += 8;
        v7 -= 64;
      }
      while (v7);
    }
  }
  a1[2] = v4;
  return result;
}

__int128 *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::TraceEntry *,re::TraceEntry *,re::TraceEntry *,0>(__int128 *a1, __int128 *a2, uint64_t a3)
{
  __int128 *v4;
  __int128 *v5;
  __int128 v6;

  v4 = a1;
  if (a1 == a2)
    return a1;
  v5 = a2;
  do
  {
    v6 = *v4;
    *(_WORD *)(a3 + 16) = *((_WORD *)v4 + 8);
    *(_OWORD *)a3 = v6;
    re::DynamicArray<BOOL>::operator=(a3 + 24, (uint64_t *)v4 + 3);
    a3 += 64;
    v4 += 4;
  }
  while (v4 != v5);
  return v5;
}

uint64_t re::`anonymous namespace'::enableTraceValidation(re::_anonymous_namespace_ *this)
{
  unsigned __int8 v1;
  uint64_t v3;
  const char *v4;

  v1 = atomic_load((unsigned __int8 *)&qword_254123970);
  if ((v1 & 1) == 0)
  {
    v3 = __cxa_guard_acquire(&qword_254123970);
    if ((_DWORD)v3)
    {
      __cxa_guard_release(&qword_254123970);
    }
  }
  return _MergedGlobals_493;
}

BOOL re::`anonymous namespace'::enableTraceValidation(void)::$_0::operator()(uint64_t a1, const char *a2)
{
  re *v2;
  unsigned __int8 v3;
  NSObject *v4;
  _DWORD v6[2];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  re::Defaults::BOOLValue((re::Defaults *)"trace.validateTraces", a2, (char *)v6);
  if (LOBYTE(v6[0]))
    v3 = BYTE1(v6[0]);
  else
    v3 = 0;
  v4 = *re::traceLogObjects(v2);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = v3;
    _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEFAULT, "ValidateSnapshot enabled: %d", (uint8_t *)v6, 8u);
  }
  return v3 != 0;
}

uint64_t re::DynamicArray<re::TraceEntry>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::TraceEntry>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::TraceEntry>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

_QWORD *re::DynamicArray<re::TraceDelta>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::TraceDelta>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x38uLL))
        {
          v2 = 56 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 56 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 56, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = v8 + 56 * v9;
        v11 = v7;
        do
        {
          *(_OWORD *)v11 = *(_OWORD *)v8;
          v11[6] = 0;
          v11[3] = 0;
          v11[4] = 0;
          v11[2] = 0;
          *((_DWORD *)v11 + 10) = 0;
          v12 = *(_QWORD *)(v8 + 16);
          v13 = *(_QWORD *)(v8 + 24);
          v14 = v8 + 16;
          v11[2] = v12;
          v11[3] = v13;
          *(_QWORD *)v14 = 0;
          *(_QWORD *)(v14 + 8) = 0;
          v15 = v11[4];
          v11[4] = *(_QWORD *)(v14 + 16);
          *(_QWORD *)(v14 + 16) = v15;
          v16 = v11[6];
          v11[6] = *(_QWORD *)(v14 + 32);
          *(_QWORD *)(v14 + 32) = v16;
          ++*(_DWORD *)(v14 + 24);
          ++*((_DWORD *)v11 + 10);
          re::DynamicArray<re::TraceEntry>::deinit(v14);
          v8 = v14 + 40;
          v11 += 7;
        }
        while (v8 != v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::TraceTargetAppInfo>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::TraceTargetAppInfo>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::TraceTargetAppInfo>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::TraceTargetAppInfo>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  __int128 v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::TraceTargetAppInfo>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          v2 = 40 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_20;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = (_QWORD *)(v8 + 16);
        v11 = 40 * v9;
        v12 = 0uLL;
        v13 = v7;
        do
        {
          *v13 = *(v10 - 2);
          *(_OWORD *)(v13 + 1) = v12;
          *(_OWORD *)(v13 + 3) = v12;
          v13[1] = *(v10 - 1);
          *(v10 - 1) = 0;
          v13[4] = v10[2];
          v10[2] = 0;
          v14 = v13[2];
          v15 = v13[3];
          v16 = v10[1];
          v13[2] = *v10;
          v13[3] = v16;
          *v10 = v14;
          v10[1] = v15;
          v17 = *(v10 - 1);
          if (v17)
          {
            if ((v14 & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v17 + 40))(v17, v10[1]);
              v12 = 0uLL;
            }
            *(_OWORD *)(v10 - 1) = v12;
            *(_OWORD *)(v10 + 1) = v12;
          }
          v10 += 5;
          v13 += 5;
          v11 -= 40;
        }
        while (v11);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

re::TraceHistory *re::TraceHistory::TraceHistory(re::TraceHistory *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  re::TracePersistenceMemory *v5;

  *(_QWORD *)this = 0x3E800000000;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = &re::s_nullDelegate;
  v2 = operator new();
  *(_QWORD *)(v2 + 48) = 0;
  *(_OWORD *)(v2 + 8) = 0u;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_DWORD *)(v2 + 40) = 0;
  *((_QWORD *)this + 1) = v2;
  *(_BYTE *)v2 = 2;
  v3 = operator new();
  *(_QWORD *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 8) = 0u;
  *(_OWORD *)(v3 + 24) = 0u;
  *(_DWORD *)(v3 + 40) = 0;
  *((_QWORD *)this + 2) = v3;
  *(_BYTE *)v3 = 3;
  v4 = operator new();
  *(_QWORD *)(v4 + 48) = 0;
  *(_OWORD *)(v4 + 8) = 0u;
  *(_OWORD *)(v4 + 24) = 0u;
  *(_DWORD *)(v4 + 40) = 0;
  *((_QWORD *)this + 3) = v4;
  *(_BYTE *)v4 = 4;
  v5 = (re::TracePersistenceMemory *)operator new();
  re::TracePersistenceMemory::TracePersistenceMemory(v5);
  re::TraceHistory::setPersistence((uint64_t)this, (uint64_t)v5);
  return this;
}

uint64_t re::TraceHistory::setPersistence(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  result = *(_QWORD *)(a1 + 32);
  if (result != a2)
  {
    if (result)
      (*(void (**)(uint64_t))(*(_QWORD *)result + 8))(result);
    *(_QWORD *)(a1 + 32) = a2;
    v5 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(v5 + 8) = 0;
    re::DynamicArray<re::TraceEntry>::clear((_QWORD *)(v5 + 16));
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 32) + 64))(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 24));
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 24))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 24));
    v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 32) + 88))(*(_QWORD *)(a1 + 32));
    return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**(_QWORD **)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), v6, v7);
  }
  return result;
}

void re::TraceHistory::~TraceHistory(re::TraceHistory *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    re::DynamicArray<re::TraceEntry>::deinit(v2 + 16);
    MEMORY[0x2276933B8](v2, 0x1020C4094B8BC74);
  }
  *((_QWORD *)this + 1) = 0;
  v3 = *((_QWORD *)this + 2);
  if (v3)
  {
    re::DynamicArray<re::TraceEntry>::deinit(v3 + 16);
    MEMORY[0x2276933B8](v3, 0x1020C4094B8BC74);
  }
  *((_QWORD *)this + 2) = 0;
  v4 = *((_QWORD *)this + 3);
  if (v4)
  {
    re::DynamicArray<re::TraceEntry>::deinit(v4 + 16);
    MEMORY[0x2276933B8](v4, 0x1020C4094B8BC74);
  }
  *((_QWORD *)this + 3) = 0;
  v5 = *((_QWORD *)this + 4);
  if (v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 8))(v5);
  *((_QWORD *)this + 4) = 0;
}

re::TraceDelta **re::TraceHistory::addData(re::TraceDelta **this, const re::TraceDelta *a2)
{
  int v2;

  v2 = *(unsigned __int8 *)a2;
  if ((v2 - 1) < 2)
    return (re::TraceDelta **)re::TraceHistory::addDelta(this, a2);
  if (v2 == 4)
    return (re::TraceDelta **)re::TraceHistory::addMetadata(this, a2);
  if (v2 == 3)
    return (re::TraceDelta **)re::TraceHistory::addSnapshot((re::TraceHistory *)this, a2);
  return this;
}

uint64_t re::TraceHistory::addSnapshot(re::TraceHistory *this, const re::TraceDelta *a2)
{
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  (*(void (**)(_QWORD, const re::TraceDelta *, _QWORD))(**((_QWORD **)this + 4) + 40))(*((_QWORD *)this + 4), a2, 0);
  v4 = (_OWORD *)*((_QWORD *)this + 2);
  *v4 = *(_OWORD *)a2;
  re::DynamicArray<re::TraceEntry>::operator=((uint64_t)(v4 + 1), (uint64_t *)a2 + 2);
  v5 = *((_QWORD *)this + 1);
  *(_QWORD *)(v5 + 8) = 0;
  re::DynamicArray<re::TraceEntry>::clear((_QWORD *)(v5 + 16));
  *(_DWORD *)this = 0;
  v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 4) + 88))(*((_QWORD *)this + 4));
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(**((_QWORD **)this + 5) + 16))(*((_QWORD *)this + 5), v6, v7);
}

uint64_t re::TraceHistory::addDelta(re::TraceDelta **this, const re::TraceDelta *a2)
{
  int v3;
  int v4;
  re::TraceDelta *v5;
  uint64_t v6;
  uint64_t v7;

  re::TraceDelta::merge(this[1], a2);
  v3 = *((_DWORD *)this + 1);
  v4 = *(_DWORD *)this + 1;
  *(_DWORD *)this = v4;
  if (v4 >= v3)
  {
    re::TraceDelta::merge(this[2], this[1]);
    v5 = this[1];
    *((_QWORD *)v5 + 1) = 0;
    re::DynamicArray<re::TraceEntry>::clear((_QWORD *)v5 + 2);
    *(_DWORD *)this = 0;
  }
  (*(void (**)(void))(*(_QWORD *)this[4] + 40))();
  v6 = (*(uint64_t (**)(re::TraceDelta *))(*(_QWORD *)this[4] + 88))(this[4]);
  return (*(uint64_t (**)(re::TraceDelta *, uint64_t, uint64_t))(*(_QWORD *)this[5] + 16))(this[5], v6, v7);
}

uint64_t re::TraceHistory::addMetadata(re::TraceDelta **this, const re::TraceDelta *a2)
{
  re::TraceDelta::merge(this[3], a2);
  (*(void (**)(re::TraceDelta *, re::TraceDelta *))(*(_QWORD *)this[4] + 32))(this[4], this[3]);
  return (*(uint64_t (**)(re::TraceDelta *, re::TraceDelta *))(*(_QWORD *)this[5] + 24))(this[5], this[3]);
}

uint64_t re::TraceHistory::clear(re::TraceHistory *this)
{
  uint64_t v2;
  uint64_t v3;
  re::TracePersistenceMemory *v4;

  *(_DWORD *)this = 0;
  v2 = *((_QWORD *)this + 1);
  *(_QWORD *)(v2 + 8) = 0;
  re::DynamicArray<re::TraceEntry>::clear((_QWORD *)(v2 + 16));
  v3 = *((_QWORD *)this + 2);
  *(_QWORD *)(v3 + 8) = 0;
  re::DynamicArray<re::TraceEntry>::clear((_QWORD *)(v3 + 16));
  v4 = (re::TracePersistenceMemory *)operator new();
  re::TracePersistenceMemory::TracePersistenceMemory(v4);
  return re::TraceHistory::setPersistence((uint64_t)this, (uint64_t)v4);
}

void re::TraceHistoryDelegateNone::~TraceHistoryDelegateNone(re::TraceHistoryDelegateNone *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t *re::traceLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::traceLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "Trace");
  }
  return &re::traceLogObjects(void)::logObjects;
}

uint64_t re::TraceDeltaWriter::writeDelta(re::zerocopy ***this, const re::TraceDelta *a2)
{
  re::zerocopy **v4;
  re::zerocopy **v5;
  re::zerocopy **v6;
  re::zerocopy **v7;
  char v9;
  char v10;
  char v11;
  char v12;

  v4 = *this;
  v9 = -29;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v9, (char *)1);
  v5 = *this;
  v10 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v10, (char *)1);
  re::OPackWriter::writeInteger(*this, *(unsigned __int8 *)a2);
  v6 = *this;
  v11 = 9;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v11, (char *)1);
  re::OPackWriter::writeFloat64(*this, *((double *)a2 + 1));
  v7 = *this;
  v12 = 10;
  re::zerocopy::writeAll(*v7, (re::zerocopy::WriteStream *)&v12, (char *)1);
  return re::TraceDeltaWriter::writeEntries(this, (uint64_t)a2 + 16);
}

uint64_t re::TraceDeltaWriter::writeEntries(re::zerocopy ***a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  re::zerocopy **v8;
  char v9;

  result = re::OPackWriter::writeArrayBegin(*a1, *(_QWORD *)(a2 + 16));
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(_QWORD *)(a2 + 32);
    v7 = v5 << 6;
    do
    {
      result = re::TraceDeltaWriter::writeEntry(a1, v6);
      v6 += 64;
      v7 -= 64;
    }
    while (v7);
    if (*(_QWORD *)(a2 + 16) >= 0xFuLL)
    {
      v8 = *a1;
      v9 = 3;
      return re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v9, (char *)1);
    }
  }
  return result;
}

uint64_t re::TraceDeltaWriter::writeEntry(re::zerocopy ***a1, uint64_t a2)
{
  re::zerocopy **v4;
  re::zerocopy **v5;
  re::zerocopy **v6;
  re::zerocopy **v7;
  re::zerocopy **v8;
  re::zerocopy **v9;
  char v11;
  char v12;
  char v13;
  char v14;
  char v15;
  char v16;

  v4 = *a1;
  v11 = -27;
  re::zerocopy::writeAll(*v4, (re::zerocopy::WriteStream *)&v11, (char *)1);
  v5 = *a1;
  v12 = 8;
  re::zerocopy::writeAll(*v5, (re::zerocopy::WriteStream *)&v12, (char *)1);
  re::OPackWriter::writeInteger(*a1, *(_QWORD *)a2);
  v6 = *a1;
  v13 = 9;
  re::zerocopy::writeAll(*v6, (re::zerocopy::WriteStream *)&v13, (char *)1);
  re::OPackWriter::writeInteger(*a1, *(_QWORD *)(a2 + 8));
  v7 = *a1;
  v14 = 10;
  re::zerocopy::writeAll(*v7, (re::zerocopy::WriteStream *)&v14, (char *)1);
  re::OPackWriter::writeInteger(*a1, *(unsigned __int8 *)(a2 + 16));
  v8 = *a1;
  v15 = 11;
  re::zerocopy::writeAll(*v8, (re::zerocopy::WriteStream *)&v15, (char *)1);
  re::OPackWriter::writeInteger(*a1, *(unsigned __int8 *)(a2 + 17));
  v9 = *a1;
  v16 = 12;
  re::zerocopy::writeAll(*v9, (re::zerocopy::WriteStream *)&v16, (char *)1);
  return re::OPackWriter::writeData(*a1, *(re::zerocopy::WriteStream **)(a2 + 56), *(_QWORD *)(a2 + 40));
}

uint64_t re::TraceDeltaReader::read(re::OPackReader **this, re::TraceDelta *a2)
{
  re::OPackReader *v4;
  uint64_t result;
  uint64_t v6;
  re::OPackReader *v7;
  uint64_t v8;
  int v9;
  re::OPackReader *v10;
  re::OPackReader *v11;
  uint64_t v12;
  __n128 v13;
  re::OPackReader *v14;
  __n128 v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;

  v4 = *this;
  result = re::OPackReader::next(*this, (uint64_t)a2);
  if ((_DWORD)result)
  {
    if (*((_BYTE *)v4 + 196) == 13)
    {
      v7 = *this;
      if (re::OPackReader::next(*this, v6))
      {
        while (*((_BYTE *)v7 + 196) == 6)
        {
          v9 = *((unsigned __int8 *)v7 + 224);
          if (v9 == 2)
          {
            v11 = *this;
            result = re::OPackReader::next(*this, v8);
            if (!(_DWORD)result)
              return result;
            if (*((_BYTE *)v11 + 196) != 12)
              return 0;
            while (re::OPackReader::next(*this, v12) && *((_BYTE *)*this + 184) != 3)
            {
              v21 = 0;
              v18 = 0;
              v19 = 0;
              v17 = 0;
              v20 = 0;
              v15 = 0uLL;
              v16 = 0;
              v13 = re::DynamicArray<re::TraceEntry>::add((re::TraceDelta *)((char *)a2 + 16), &v15);
              if (v17)
              {
                if (v21)
                  (*(void (**)(__n128))(*(_QWORD *)v17 + 40))(v13);
              }
              *((_BYTE *)*this + 2) = 1;
              if ((re::TraceDeltaReader::read(this, *((_QWORD *)a2 + 6) + (*((_QWORD *)a2 + 4) << 6) - 64) & 1) == 0)
                return 0;
            }
          }
          else if (v9 == 1)
          {
            v14 = *this;
            result = re::OPackReader::next(*this, v8);
            if (!(_DWORD)result)
              return result;
            if (*((_BYTE *)v14 + 196) != 8)
              return 0;
            *((_QWORD *)a2 + 1) = *((_QWORD *)v14 + 28);
          }
          else if (!*((_BYTE *)v7 + 224))
          {
            v10 = *this;
            result = re::OPackReader::next(*this, v8);
            if (!(_DWORD)result)
              return result;
            if (*((_BYTE *)v10 + 196) != 6)
              return 0;
            *(_BYTE *)a2 = *((_QWORD *)v10 + 28);
          }
          v7 = *this;
          if ((re::OPackReader::next(*this, v8) & 1) == 0)
            return *((unsigned __int8 *)*this + 184) == 5;
        }
      }
      return *((unsigned __int8 *)*this + 184) == 5;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t re::TraceDeltaReader::read(re::OPackReader **a1, uint64_t a2)
{
  re::OPackReader *v4;
  uint64_t result;
  uint64_t v6;
  re::OPackReader *v7;
  uint64_t v8;
  re::OPackReader *v9;
  uint64_t v10;
  re::OPackReader *v11;
  re::OPackReader *v12;
  re::OPackReader *v13;
  re::OPackReader *v14;

  v4 = *a1;
  result = re::OPackReader::next(*a1, a2);
  if ((_DWORD)result)
  {
    if (*((_BYTE *)v4 + 196) == 13)
    {
      v7 = *a1;
      if (re::OPackReader::next(*a1, v6))
      {
        do
        {
          if (*((_BYTE *)v7 + 196) != 6)
            break;
          switch(*((_BYTE *)v7 + 224))
          {
            case 0:
              v9 = *a1;
              result = re::OPackReader::next(*a1, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v9 + 196) != 6)
                return 0;
              *(_QWORD *)a2 = *((_QWORD *)v9 + 28);
              break;
            case 1:
              v11 = *a1;
              result = re::OPackReader::next(*a1, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v11 + 196) != 6)
                return 0;
              *(_QWORD *)(a2 + 8) = *((_QWORD *)v11 + 28);
              break;
            case 2:
              v12 = *a1;
              result = re::OPackReader::next(*a1, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v12 + 196) != 6)
                return 0;
              *(_BYTE *)(a2 + 16) = *((_QWORD *)v12 + 28);
              break;
            case 3:
              v13 = *a1;
              result = re::OPackReader::next(*a1, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v13 + 196) != 6)
                return 0;
              *(_BYTE *)(a2 + 17) = *((_QWORD *)v13 + 28);
              break;
            case 4:
              v14 = *a1;
              result = re::OPackReader::next(*a1, v8);
              if (!(_DWORD)result)
                return result;
              if (*((_BYTE *)v14 + 196) != 11)
                return 0;
              re::DynamicArray<unsigned char>::resizeUninitialized((_QWORD *)(a2 + 24), *((_QWORD *)*a1 + 27));
              memcpy(*(void **)(a2 + 56), *((const void **)*a1 + 26), *((_QWORD *)*a1 + 27));
              break;
            default:
              return 0;
          }
          v7 = *a1;
        }
        while ((re::OPackReader::next(*a1, v10) & 1) != 0);
      }
      return *((unsigned __int8 *)*a1 + 184) == 5;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t re::TraceTargetAppInfoWriter::write(re::zerocopy ***a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  re::zerocopy **v9;
  re::zerocopy **v10;
  uint64_t v11;
  re::zerocopy **v12;
  unint64_t v13;
  re::zerocopy::WriteStream *v14;
  unint64_t v15;
  re::zerocopy **v16;
  char v17;
  char v18;
  char v19;
  char v20;

  result = re::OPackWriter::writeArrayBegin(*a1, *(_QWORD *)(a2 + 16));
  v5 = *(_QWORD *)(a2 + 16);
  if (v5)
  {
    v6 = *(_QWORD *)(a2 + 32);
    v7 = v6 + 40 * v5;
    v8 = v6 + 17;
    do
    {
      v9 = *a1;
      v18 = -30;
      re::zerocopy::writeAll(*v9, (re::zerocopy::WriteStream *)&v18, (char *)1);
      v10 = *a1;
      v19 = 8;
      re::zerocopy::writeAll(*v10, (re::zerocopy::WriteStream *)&v19, (char *)1);
      v11 = v8 - 17;
      re::OPackWriter::writeInteger(*a1, *(_QWORD *)(v8 - 17));
      v12 = *a1;
      v20 = 9;
      re::zerocopy::writeAll(*v12, (re::zerocopy::WriteStream *)&v20, (char *)1);
      v13 = *(_QWORD *)(v8 - 1);
      v14 = (re::zerocopy::WriteStream *)v8;
      if ((v13 & 1) != 0)
      {
        v14 = *(re::zerocopy::WriteStream **)(v8 + 7);
        v15 = v13 >> 1;
      }
      else
      {
        v15 = v13 >> 1;
      }
      result = re::OPackWriter::writeString(*a1, v14, v15);
      v8 += 40;
    }
    while (v11 + 40 != v7);
    if (*(_QWORD *)(a2 + 16) >= 0xFuLL)
    {
      v16 = *a1;
      v17 = 3;
      return re::zerocopy::writeAll(*v16, (re::zerocopy::WriteStream *)&v17, (char *)1);
    }
  }
  return result;
}

BOOL re::TraceTargetAppInfoReader::read(re::OPackReader **a1, _anonymous_namespace_ *a2)
{
  re::OPackReader *v4;
  uint64_t v5;
  uint64_t v6;
  re::OPackReader *v7;
  int v8;
  _BOOL8 v9;
  uint64_t v10;
  double v11;
  re::OPackReader *v12;
  uint64_t v13;
  re::OPackReader *v14;
  uint64_t v15;
  re::OPackReader *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  re::OPackReader *v20;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v4 = *a1;
  if (!re::OPackReader::next(*a1, (uint64_t)a2) || *((_BYTE *)v4 + 196) != 12)
    return 0;
  v6 = re::OPackReader::next(*a1, v5);
  v7 = *a1;
  if (!(_DWORD)v6)
    return *((_BYTE *)v7 + 184) == 3;
  while (1)
  {
    v8 = *((unsigned __int8 *)v7 + 184);
    v9 = v8 == 3;
    if (v8 == 3)
      return v9;
    v24 = 0;
    v22 = 0u;
    v23 = 0u;
    re::DynamicString::setCapacity((_QWORD *)&v22 + 1, 0);
    v11 = re::DynamicArray<re::TraceTargetAppInfo>::add(a2, &v22);
    if (*((_QWORD *)&v22 + 1) && (v23 & 1) != 0)
      (*(void (**)(double))(**((_QWORD **)&v22 + 1) + 40))(v11);
    v12 = *a1;
    *((_BYTE *)v12 + 2) = 1;
    if (!re::OPackReader::next(v12, v10) || *((_BYTE *)v12 + 196) != 13)
      return v9;
    v14 = *a1;
    if (re::OPackReader::next(*a1, v13))
    {
      while (*((_BYTE *)v14 + 196) == 6)
      {
        if (*((_BYTE *)v14 + 224) == 1)
        {
          v20 = *a1;
          if (!re::OPackReader::next(*a1, v15) || *((_BYTE *)v20 + 196) != 10)
            return 0;
          re::DynamicString::assign((re::DynamicString *)(*((_QWORD *)a2 + 4) + 40 * *((_QWORD *)a2 + 2) - 32), *((const char **)*a1 + 26), *((_QWORD *)*a1 + 27));
        }
        else
        {
          if (*((_BYTE *)v14 + 224))
            return 0;
          v16 = *a1;
          v17 = *((_QWORD *)a2 + 4);
          v18 = *((_QWORD *)a2 + 2);
          if (!re::OPackReader::next(*a1, v15) || *((_BYTE *)v16 + 196) != 6)
            return 0;
          *(_QWORD *)(v17 + 40 * v18 - 40) = *((_QWORD *)v16 + 28);
        }
        v14 = *a1;
        if ((re::OPackReader::next(*a1, v19) & 1) == 0)
          break;
      }
    }
    v6 = re::OPackReader::next(*a1, v15);
    v7 = *a1;
    if ((v6 & 1) == 0)
      return *((_BYTE *)v7 + 184) == 3;
  }
}

double re::DynamicArray<re::TraceTargetAppInfo>::add(_anonymous_namespace_ *this, _QWORD *a2)
{
  unint64_t v4;
  uint64_t v5;
  double result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::TraceTargetAppInfo>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 40 * v4;
  *(_QWORD *)v5 = *a2;
  result = 0.0;
  *(_OWORD *)(v5 + 8) = 0u;
  *(_OWORD *)(v5 + 24) = 0u;
  *(_QWORD *)(v5 + 32) = a2[4];
  v7 = a2[2];
  *(_QWORD *)(v5 + 8) = a2[1];
  a2[1] = 0;
  v8 = a2[3];
  a2[4] = 0;
  v10 = *(_QWORD *)(v5 + 16);
  v9 = *(_QWORD *)(v5 + 24);
  *(_QWORD *)(v5 + 16) = v7;
  *(_QWORD *)(v5 + 24) = v8;
  a2[2] = v10;
  a2[3] = v9;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

char *re::TraceResolverDefault::resolveChild(re::TraceResolverDefault *this, uint64_t a2)
{
  char *v2;

  v2 = (char *)this + 8;
  snprintf((char *)this + 8, 0x40uLL, "%llu", a2);
  return v2;
}

char *re::TraceResolverDefault::resolveId(re::TraceResolverDefault *this, uint64_t a2)
{
  char *v2;

  v2 = (char *)this + 8;
  snprintf((char *)this + 8, 0x40uLL, "%llu", a2);
  return v2;
}

uint64_t re::TraceDump::dump(re::zerocopy **this, const re::TraceDelta *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;

  result = re::zerocopy::writeAll(*this, (re::zerocopy::WriteStream *)"delta\n", (char *)6);
  v5 = *((_QWORD *)a2 + 4);
  if (v5)
  {
    v6 = (uint64_t *)*((_QWORD *)a2 + 6);
    v7 = v5 << 6;
    do
    {
      result = re::TraceDump::dump((uint64_t)this, v6);
      v6 += 8;
      v7 -= 64;
    }
    while (v7);
  }
  return result;
}

uint64_t re::TraceDump::dump(uint64_t a1, uint64_t *a2)
{
  if (a2[1])
    return re::TraceDump::dumpChild(a1, a2);
  else
    return re::TraceDump::dumpParent(a1, (uint64_t)a2);
}

uint64_t re::TraceDump::dumpChild(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  unint64_t v9;
  char *v10;
  char *v11;

  v4 = *a2;
  if (*a2 != *(_QWORD *)(a1 + 88))
  {
    *(_QWORD *)(a1 + 88) = v4;
    re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)"  +-- ", (char *)6);
    v5 = (char *)(*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(a1 + 8) + 8))(*(_QWORD *)(a1 + 8), v4);
    v6 = (char *)strlen(v5);
    re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)v5, v6);
    re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)"\n", (char *)1);
  }
  re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)"    +-- ", (char *)8);
  v7 = (char *)(***(uint64_t (****)(_QWORD, uint64_t))(a1 + 8))(*(_QWORD *)(a1 + 8), a2[1]);
  v8 = (char *)strlen(v7);
  re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)v7, v8);
  re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)" ", (char *)1);
  v9 = *((char *)a2 + 16);
  if (v9 > 3)
    v10 = "???";
  else
    v10 = (char *)*((_QWORD *)&off_24ED899C8 + v9);
  v11 = (char *)strlen(v10);
  re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)v10, v11);
  if (*(_BYTE *)(a1 + 97) && a2[5])
  {
    re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)" ", (char *)1);
    re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)a2[7], (char *)a2[5]);
  }
  return re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)"\n", (char *)1);
}

uint64_t re::TraceDump::dumpParent(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  unint64_t v6;
  char *v7;
  char *v8;

  *(_QWORD *)(a1 + 88) = *(_QWORD *)a2;
  re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)"  +-- ", (char *)6);
  v4 = (char *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 8))(*(_QWORD *)(a1 + 8), *(_QWORD *)a2);
  v5 = (char *)strlen(v4);
  re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)v4, v5);
  re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)" ", (char *)1);
  v6 = *(char *)(a2 + 16);
  if (v6 > 3)
    v7 = "???";
  else
    v7 = (char *)*((_QWORD *)&off_24ED899C8 + v6);
  v8 = (char *)strlen(v7);
  re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)v7, v8);
  if (*(_BYTE *)(a1 + 96) && *(_QWORD *)(a2 + 40))
  {
    re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)" ", (char *)1);
    re::zerocopy::writeAll(*(re::zerocopy **)a1, *(re::zerocopy::WriteStream **)(a2 + 56), *(char **)(a2 + 40));
  }
  return re::zerocopy::writeAll(*(re::zerocopy **)a1, (re::zerocopy::WriteStream *)"\n", (char *)1);
}

uint64_t *re::allocInfo_TraceService(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_494);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_494))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_254123980, 0);
    *(uint64_t *)((char *)&qword_254123990 + 6) = 0;
    qword_254123990 = 0;
    qword_2541239A0 = 0;
    qword_2541239A8 = 0xFFFFFFFFLL;
    qword_254123980 = (uint64_t)&off_24ED7DAA8;
    qword_2541239B0 = (uint64_t)"TraceService";
    dword_2541239B8 = 0;
    unk_2541239C0 = 0u;
    unk_2541239D0 = 0u;
    unk_2541239E0 = 0u;
    qword_2541239F0 = 0;
    __cxa_guard_release(&_MergedGlobals_494);
  }
  return &qword_254123980;
}

void re::initInfo_TraceService(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x3DE7F4E91F7F73A0;
  v5[1] = "TraceService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_TraceService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_TraceService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"TraceService", (uint64_t (*)(re::internal *))re::allocInfo_TraceService, (re::IntrospectionBase *(*)(void))re::initInfo_TraceService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::TraceService>, this);
}

id re::TraceFramer::definition(re::TraceFramer *this)
{
  unsigned __int8 v1;
  id *v2;
  re::TraceFramer *v4;

  v2 = (id *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
  if ((v1 & 1) == 0)
  {
    v2 = (id *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
    if ((_DWORD)v4)
    {
      re::TraceFramer::create(v4);
      re::TraceFramer::definition(void)::definition = objc_claimAutoreleasedReturnValue();
      v2 = (id *)&re::mtl::introspect_SamplerMinMagFilter(BOOL)::info;
    }
  }
  return v2[498];
}

nw_protocol_definition_t re::TraceFramer::create(re::TraceFramer *this)
{
  void *v1;
  nw_protocol_definition_t definition;
  _QWORD v4[4];
  id v5;
  id v6;

  v4[0] = MEMORY[0x24BDAC760];
  v4[1] = 3221225472;
  v4[2] = ___ZN2re11TraceFramer6createEv_block_invoke_7;
  v4[3] = &unk_24ED89AD8;
  v5 = &__block_literal_global_49;
  v6 = &__block_literal_global_5_2;
  v1 = _Block_copy(v4);
  definition = nw_framer_create_definition("re-trace-header", 0, v1);

  return definition;
}

uint64_t ___ZN2re11TraceFramer6createEv_block_invoke(uint64_t a1, void *a2)
{
  NSObject *v2;
  uint64_t v3;
  NSObject *v4;
  _BOOL4 v5;
  uint8_t temp_buffer[8];

  v2 = a2;
  *(_QWORD *)temp_buffer = 0;
  v3 = 8;
  if (nw_framer_parse_input(v2, 8uLL, 8uLL, temp_buffer, &__block_literal_global_2))
  {
    v3 = 8;
    while (1)
    {
      v4 = nw_framer_message_create(v2);
      nw_framer_message_set_value(v4, "type", (void *)temp_buffer[4], 0);
      v5 = nw_framer_deliver_input_no_copy(v2, bswap32(*(unsigned int *)temp_buffer), v4, 1);

      if (!v5)
        break;
      *(_QWORD *)temp_buffer = 0;
      if (!nw_framer_parse_input(v2, 8uLL, 8uLL, temp_buffer, &__block_literal_global_2))
        goto LABEL_7;
    }
    v3 = 0;
  }
LABEL_7:

  return v3;
}

uint64_t ___ZN2re11TraceFramer6createEv_block_invoke_2(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (a3 < 8 || a2 == 0)
    return 0;
  else
    return 8;
}

void ___ZN2re11TraceFramer6createEv_block_invoke_3(uint64_t a1, void *a2, NSObject *a3, size_t a4)
{
  NSObject *v6;
  _BOOL8 v7;
  NSObject *v8;
  unsigned int v9;
  char v10;
  _QWORD access_value[5];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v6 = a2;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  access_value[0] = MEMORY[0x24BDAC760];
  access_value[1] = 3221225472;
  access_value[2] = ___ZN2re11TraceFramer6createEv_block_invoke_4;
  access_value[3] = &unk_24ED89AB0;
  access_value[4] = &v12;
  v7 = nw_framer_message_access_value(a3, "type", access_value);
  if (v7)
  {
    v9 = bswap32(a4);
    v10 = *((_BYTE *)v13 + 24);
    nw_framer_write_output(v6, (const uint8_t *)&v9, 8uLL);
    nw_framer_write_output_no_copy(v6, a4);
  }
  else
  {
    v8 = *re::traceLogObjects((re *)v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v9) = 0;
      _os_log_error_impl(&dword_224FE9000, v8, OS_LOG_TYPE_ERROR, "TraceFramer: Could not access TraceMessageType of output message.", (uint8_t *)&v9, 2u);
    }
  }
  _Block_object_dispose(&v12, 8);

}

uint64_t ___ZN2re11TraceFramer6createEv_block_invoke_4(uint64_t a1, char a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
  return 1;
}

uint64_t ___ZN2re11TraceFramer6createEv_block_invoke_7(uint64_t a1, void *a2)
{
  void *v3;
  NSObject *v4;

  v3 = *(void **)(a1 + 32);
  v4 = a2;
  nw_framer_set_input_handler(v4, v3);
  nw_framer_set_output_handler(v4, *(nw_framer_output_handler_t *)(a1 + 40));

  return 1;
}

void re::TraceFramer::setMessageType(re::TraceFramer *a1, unsigned int a2)
{
  NSObject *v4;
  NSObject *message;

  re::TraceFramer::definition(a1);
  v4 = objc_claimAutoreleasedReturnValue();
  message = nw_framer_protocol_create_message(v4);

  nw_framer_message_set_value(message, "type", (void *)a2, &__block_literal_global_11_0);
  nw_content_context_set_metadata_for_protocol((nw_content_context_t)a1, message);

}

void re::TraceFramer::messageType(re::TraceFramer *this@<X0>, _BYTE *a2@<X8>)
{
  NSObject *v5;
  NSObject *v6;
  _BOOL8 is_framer_message;
  _BOOL8 v8;
  uint64_t *v9;
  NSObject *v10;
  const char *v11;
  uint8_t v12[8];
  _QWORD access_value[5];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;

  v14 = 0;
  v15 = &v14;
  v16 = 0x2020000000;
  v17 = 0;
  re::TraceFramer::definition(this);
  v5 = objc_claimAutoreleasedReturnValue();
  v6 = nw_content_context_copy_protocol_metadata((nw_content_context_t)this, v5);

  if (!v6 || !(is_framer_message = nw_protocol_metadata_is_framer_message(v6)))
  {
    v10 = *re::traceLogObjects((re *)is_framer_message);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v12 = 0;
      v11 = "TraceFramer: Could not get framer message from context.";
      goto LABEL_11;
    }
LABEL_6:
    *a2 = 0;
    goto LABEL_7;
  }
  access_value[0] = MEMORY[0x24BDAC760];
  access_value[1] = 3221225472;
  access_value[2] = ___ZN2re11TraceFramer11messageTypeEPv_block_invoke;
  access_value[3] = &unk_24ED89AB0;
  access_value[4] = &v14;
  v8 = nw_framer_message_access_value(v6, "type", access_value);
  if (!v8)
  {
    v10 = *re::traceLogObjects((re *)v8);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v12 = 0;
      v11 = "TraceFramer: Could not get TraceMessageType from the framer message.";
LABEL_11:
      _os_log_error_impl(&dword_224FE9000, v10, OS_LOG_TYPE_ERROR, v11, v12, 2u);
      goto LABEL_6;
    }
    goto LABEL_6;
  }
  v9 = v15;
  *a2 = 1;
  a2[1] = *((_BYTE *)v9 + 24);
LABEL_7:

  _Block_object_dispose(&v14, 8);
}

uint64_t ___ZN2re11TraceFramer11messageTypeEPv_block_invoke(uint64_t a1, char a2)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
  return 1;
}

NSObject **re::TraceClient::TraceClient(NSObject **a1, dispatch_queue_t target)
{
  NSObject *v3;

  v3 = dispatch_queue_create_with_target_V2("trace client", 0, target);
  *a1 = v3;
  a1[1] = 0;
  *((_DWORD *)a1 + 4) = 0;
  a1[3] = 0;
  a1[4] = 0;
  *((_DWORD *)a1 + 10) = 1;
  a1[7] = 0;
  a1[8] = 0;
  a1[6] = 0;
  *((_DWORD *)a1 + 18) = 0;
  a1[10] = 0;
  a1[11] = &re::s_nullClientDelegate;
  re::TraceClient::initParameters((re::TraceClient *)a1);
  return a1;
}

void re::TraceClient::initParameters(re::TraceClient *this)
{
  nw_parameters_t v2;
  void *v3;
  NSObject *options;
  re::TraceFramer *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *stack;

  v2 = nw_parameters_create();
  v3 = (void *)*((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v2;

  stack = nw_parameters_copy_default_protocol_stack(*((nw_parameters_t *)this + 3));
  options = nw_tcp_create_options();
  nw_protocol_stack_set_transport_protocol(stack, options);

  re::TraceFramer::definition(v5);
  v6 = objc_claimAutoreleasedReturnValue();
  v7 = nw_framer_create_options(v6);

  nw_protocol_stack_prepend_application_protocol(stack, v7);
}

void re::TraceClient::~TraceClient(re::TraceClient *this)
{
  re::TraceClient::forceCancel(this);
  re::DynamicArray<re::SceneCompatibilityVariant>::deinit((uint64_t)this + 48);

}

void re::TraceClient::forceCancel(re::TraceClient *this)
{
  NSObject *v2;

  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    if (*((_DWORD *)this + 4) != 5)
    {
      nw_connection_force_cancel(v2);
      v2 = *((_QWORD *)this + 1);
    }
    *((_QWORD *)this + 1) = 0;

  }
}

void re::TraceClient::addTargetApp(re::TraceClient *this, const char *a2, uint64_t a3)
{
  _anonymous_namespace_ *v4;
  double v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  char v9;

  if (a2 && a3)
  {
    v4 = (re::TraceClient *)((char *)this + 48);
    v7 = a3;
    v5 = re::DynamicArray<re::TraceTargetAppInfo>::add(v4, &v7);
    if (v8)
    {
      if ((v9 & 1) != 0)
        (*(void (**)(double))(*(_QWORD *)v8 + 40))(v5);
    }
  }
  else
  {
    v6 = *re::traceLogObjects(this);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v7) = 0;
      _os_log_error_impl(&dword_224FE9000, v6, OS_LOG_TYPE_ERROR, "TraceClient: Invalid app bundleID or peerID", (uint8_t *)&v7, 2u);
    }
  }
}

void re::TraceClient::connect(nw_parameters_t *this, const char *a2, const char *a3)
{
  nw_endpoint_t host;
  nw_parameters_t v7;
  nw_connection_t v8;
  nw_parameters_t v9;

  re::TraceClient::disconnect((re::TraceClient *)this);
  re::TraceClient::forceCancel((re::TraceClient *)this);
  host = nw_endpoint_create_host(a2, a3);
  v7 = this[4];
  this[4] = host;

  v8 = nw_connection_create(this[4], this[3]);
  v9 = this[1];
  this[1] = v8;

  re::TraceClient::startConnection((id *)this);
}

NSObject *re::TraceClient::disconnect(re::TraceClient *this)
{
  NSObject *result;

  result = *((_QWORD *)this + 1);
  if (result)
  {
    if (*((_DWORD *)this + 4) != 5)
    {
      nw_connection_send(result, 0, (nw_content_context_t)*MEMORY[0x24BDE0860], 1, (nw_connection_send_completion_t)*MEMORY[0x24BDE0840]);
      nw_connection_cancel(*((nw_connection_t *)this + 1));
      return re::DynamicArray<re::SceneCompatibilityVariant>::clear((_QWORD *)this + 6);
    }
  }
  return result;
}

void re::TraceClient::startConnection(id *this)
{
  id v2;
  id v3;
  NSObject *v4;
  id v5;
  id v6;
  _QWORD v7[4];
  id v8;
  id v9;

  v2 = *this;
  v3 = this[1];
  nw_connection_set_queue((nw_connection_t)this[1], (dispatch_queue_t)*this);
  v4 = this[1];
  v7[0] = MEMORY[0x24BDAC760];
  v7[1] = 3221225472;
  v7[2] = ___ZN2re11TraceClient15startConnectionEv_block_invoke;
  v7[3] = &unk_24ED89B40;
  v8 = v2;
  v9 = v3;
  v5 = v3;
  v6 = v2;
  nw_connection_set_state_changed_handler(v4, v7);
  nw_connection_start((nw_connection_t)this[1]);

}

void re::TraceClient::connectWithFileHandle(re::TraceClient *this)
{
  uint64_t v2;
  void *v3;

  re::TraceClient::disconnect(this);
  re::TraceClient::forceCancel(this);
  v2 = nw_connection_create_with_connected_socket_and_parameters();
  v3 = (void *)*((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = v2;

  re::TraceClient::startConnection((id *)this);
}

void ___ZN2re11TraceClient15startConnectionEv_block_invoke(uint64_t a1, int a2)
{
  re *specific;
  re *v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  re::TraceClient *v9;
  NSObject *v10;
  re::TraceFramer *v11;
  uint64_t v12;
  NSObject *v13;
  re::TraceFramer *v14;
  NSObject *v15;
  NSObject *v16;
  void *v17;
  re::zerocopy **v18;
  re::zerocopy *v19;
  _BYTE buf[24];
  _OWORD v21[2];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (specific)
  {
    v5 = specific;
    if (*((_QWORD *)specific + 1) == *(_QWORD *)(a1 + 40))
    {
      v6 = *re::traceLogObjects(specific);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = v6;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = nw_connection_state_to_string();
        _os_log_impl(&dword_224FE9000, v7, OS_LOG_TYPE_DEFAULT, "TraceClient connection state = %s", buf, 0xCu);

      }
      v8 = *((_DWORD *)v5 + 4);
      *((_DWORD *)v5 + 4) = a2;
      switch(a2)
      {
        case 1:
          goto LABEL_17;
        case 3:
          (*(void (**)(_QWORD))(**((_QWORD **)v5 + 11) + 16))(*((_QWORD *)v5 + 11));
          if (!*((_QWORD *)v5 + 8))
            goto LABEL_10;
          if (*((_QWORD *)v5 + 1) && *((_DWORD *)v5 + 4) != 5)
          {
            *(_QWORD *)buf = &off_24ED7DDF0;
            *(_OWORD *)&buf[8] = 0u;
            memset(v21, 0, 24);
            re::zerocopy::DispatchWriteStream::clear((re::zerocopy::DispatchWriteStream *)buf);
            *(int64x2_t *)((char *)v21 + 8) = vdupq_n_s64(0x1000uLL);
            *(_QWORD *)&buf[16] = dispatch_data_create_alloc();
            v18 = &v19;
            v19 = (re::zerocopy *)buf;
            re::TraceTargetAppInfoWriter::write(&v18, (uint64_t)v5 + 48);
            re::zerocopy::DispatchWriteStream::mergeTail((re::zerocopy::DispatchWriteStream *)buf);
            v10 = *(NSObject **)&buf[8];
            *(_QWORD *)&buf[8] = 0;
            re::zerocopy::DispatchWriteStream::clear((re::zerocopy::DispatchWriteStream *)buf);
            *(_QWORD *)buf = &off_24ED7DDF0;
            re::zerocopy::DispatchWriteStream::clear((re::zerocopy::DispatchWriteStream *)buf);
            v11 = (re::TraceFramer *)nw_content_context_create("re-trace");
            re::TraceFramer::setMessageType(v11, 4u);
            nw_connection_send(*((nw_connection_t *)v5 + 1), v10, (nw_content_context_t)v11, 1, &__block_literal_global_4_3);

LABEL_10:
            if (*((_QWORD *)v5 + 1))
            {
              if (*((_DWORD *)v5 + 4) != 5)
              {
                v12 = *((unsigned int *)v5 + 10);
                *(_QWORD *)buf = &off_24ED7DDF0;
                *(_OWORD *)&buf[8] = 0u;
                memset(v21, 0, 24);
                re::zerocopy::DispatchWriteStream::clear((re::zerocopy::DispatchWriteStream *)buf);
                *(int64x2_t *)((char *)v21 + 8) = vdupq_n_s64(0x20uLL);
                *(_QWORD *)&buf[16] = dispatch_data_create_alloc();
                v19 = (re::zerocopy *)buf;
                re::OPackWriter::writeInteger(&v19, v12);
                re::zerocopy::DispatchWriteStream::mergeTail((re::zerocopy::DispatchWriteStream *)buf);
                v13 = *(NSObject **)&buf[8];
                *(_QWORD *)&buf[8] = 0;
                re::zerocopy::DispatchWriteStream::clear((re::zerocopy::DispatchWriteStream *)buf);
                *(_QWORD *)buf = &off_24ED7DDF0;
                re::zerocopy::DispatchWriteStream::clear((re::zerocopy::DispatchWriteStream *)buf);
                v14 = (re::TraceFramer *)nw_content_context_create("re-trace");
                re::TraceFramer::setMessageType(v14, 1u);
                nw_connection_send(*((nw_connection_t *)v5 + 1), v13, (nw_content_context_t)v14, 1, &__block_literal_global_50);

              }
            }
          }
          re::TraceClient::scheduleReceive((id *)v5, v9);
          break;
        case 4:
          (*(void (**)(_QWORD))(**((_QWORD **)v5 + 11) + 40))(*((_QWORD *)v5 + 11));
LABEL_17:
          re::TraceClient::disconnect(v5);
          return;
        case 5:
          if (v8 != 4)
            (*(void (**)(_QWORD))(**((_QWORD **)v5 + 11) + 40))(*((_QWORD *)v5 + 11));
          v17 = (void *)*((_QWORD *)v5 + 1);
          *((_QWORD *)v5 + 1) = 0;

          return;
        default:
          return;
      }
    }
  }
  else
  {
    v15 = *re::traceLogObjects(0);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = v15;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = nw_connection_state_to_string();
      _os_log_impl(&dword_224FE9000, v16, OS_LOG_TYPE_DEFAULT, "TraceClient: connection state changed (%s) for detached connection", buf, 0xCu);

    }
  }
}

void re::TraceClient::scheduleReceive(id *this, re::TraceClient *a2)
{
  id v3;
  NSObject *v4;
  id v5;
  _QWORD completion[4];
  id v7;

  v3 = *this;
  v4 = this[1];
  completion[0] = MEMORY[0x24BDAC760];
  completion[1] = 3221225472;
  completion[2] = ___ZN2re11TraceClient15scheduleReceiveEPS0__block_invoke;
  completion[3] = &unk_24ED89B68;
  v7 = v3;
  v5 = v3;
  nw_connection_receive_message(v4, completion);

}

void ___ZN2re11TraceClient15scheduleReceiveEPS0__block_invoke(uint64_t a1, void *a2, void *a3, int a4, void *a5)
{
  id v9;
  re::TraceFramer *v10;
  id v11;
  re::TraceClient *specific;
  re::TraceClient *v13;
  re::TraceClient *v14;
  int v15;
  _anonymous_namespace_ *v16;
  _anonymous_namespace_ *v17;
  NSObject *v18;
  _BYTE v19[2];
  _OWORD v20[3];
  _QWORD v21[3];
  re::OPackReader *v22;
  NSObject v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 *v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  _DWORD buf[94];
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v9 = a2;
  v10 = a3;
  v11 = a5;
  if (specific)
  {
    v14 = specific;
    if (v9 && v10)
    {
      re::TraceFramer::messageType(v10, v19);
      if (v19[0])
      {
        v15 = v19[1];
        v16 = (_anonymous_namespace_ *)v9;
        v17 = v16;
        if (v15 == 3)
        {
          LODWORD(v21[0]) = 0;
          memset(v20, 0, sizeof(v20));
          *(_QWORD *)((char *)v21 + 4) = 0x7FFFFFFFLL;
          v23.isa = (Class)&off_24ED7DC58;
          v36 = &v24;
          v37 = xmmword_226147220;
          v24 = 0u;
          v25 = 0u;
          v26 = 0u;
          v27 = 0u;
          v28 = 0u;
          v29 = 0u;
          v30 = 0u;
          v31 = 0u;
          v32 = 0u;
          v33 = 0u;
          v34 = 0u;
          v35 = 0u;
          v38 = 0;
          v39 = 0;
          dispatch_data_apply_f();
          re::OPackReader::OPackReader((uint64_t)buf, (uint64_t)&v23);
          v22 = (re::OPackReader *)buf;
          if (re::TransferReportReader::read(&v22, v20))
            (*(void (**)(_QWORD *, _OWORD *))(**((_QWORD **)v14 + 11) + 32))(*((_QWORD **)v14 + 11), v20);
          re::OPackReader::~OPackReader((re::OPackReader *)buf);
          re::zerocopy::DispatchReadStream::~DispatchReadStream(&v23);
          re::HashTable<unsigned long,re::SessionTransferReport,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::deinit((uint64_t *)&v20[1]);
        }
        else if (v15 == 2)
        {
          LOBYTE(v20[0]) = 0;
          v21[0] = 0;
          memset((char *)v20 + 8, 0, 36);
          v23.isa = (Class)&off_24ED7DC58;
          v36 = &v24;
          v37 = xmmword_226147220;
          v24 = 0u;
          v25 = 0u;
          v26 = 0u;
          v27 = 0u;
          v28 = 0u;
          v29 = 0u;
          v30 = 0u;
          v31 = 0u;
          v32 = 0u;
          v33 = 0u;
          v34 = 0u;
          v35 = 0u;
          v38 = 0;
          v39 = 0;
          dispatch_data_apply_f();
          re::OPackReader::OPackReader((uint64_t)buf, (uint64_t)&v23);
          v22 = (re::OPackReader *)buf;
          if (re::TraceDeltaReader::read(&v22, (re::TraceDelta *)v20))
            (*(void (**)(_QWORD *, _OWORD *))(**((_QWORD **)v14 + 11) + 24))(*((_QWORD **)v14 + 11), v20);
          re::OPackReader::~OPackReader((re::OPackReader *)buf);
          re::zerocopy::DispatchReadStream::~DispatchReadStream(&v23);
          re::DynamicArray<re::TraceEntry>::deinit((uint64_t)&v20[1]);
        }
        else
        {
          v18 = *re::traceLogObjects(v16);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            buf[0] = 67109120;
            buf[1] = v15;
            _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "TraceClient received unexpected TraceMessageType: %hhu", (uint8_t *)buf, 8u);
          }
        }

      }
      goto LABEL_19;
    }
    if (v9 || !a4)
    {
LABEL_19:
      re::TraceClient::scheduleReceive(v14, v13);
      goto LABEL_20;
    }
    re::TraceClient::disconnect(specific);
  }
LABEL_20:

}

void re::TraceClientDelegateNone::~TraceClientDelegateNone(re::TraceClientDelegateNone *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::TraceClientDelegateNone::clientConnected(re::TraceClientDelegateNone *this)
{
  return puts(" Connected");
}

FILE *re::TraceClientDelegateNone::clientLoadedDelta(uint64_t a1)
{
  FILE *v1;
  const re::TraceDelta *v2;
  FILE *result;
  re::zerocopy *v4[2];
  _QWORD v5[10];
  __int16 v6;
  void (**v7)(re::zerocopy::FileWriteStream *__hidden);
  FILE *v8;
  char v9;
  uint64_t v10;

  MEMORY[0x24BDAC7A8](a1);
  v10 = *MEMORY[0x24BDAC8D0];
  v1 = (FILE *)*MEMORY[0x24BDAC8E8];
  v7 = &off_24ED7DCB0;
  v8 = v1;
  v9 = 0;
  v4[0] = (re::zerocopy *)&v7;
  v4[1] = (re::zerocopy *)v5;
  v5[0] = off_24ED89990;
  v5[9] = 0;
  v6 = 257;
  re::TraceDump::dump(v4, v2);
  v7 = &off_24ED7DCB0;
  result = v8;
  if (v8)
  {
    if (v9)
      return (FILE *)fclose(v8);
  }
  return result;
}

uint64_t re::TracePersistenceUtils::copyAll(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  int v10;
  re *v11;
  char v12;
  uint64_t v13;
  _BYTE *v14;
  _BYTE *v15;
  uint64_t v16;
  NSObject *v17;
  unsigned int v19;
  _BYTE v21[40];
  int v22;
  uint64_t v23;
  _BYTE v24[40];
  int v25;
  uint64_t v26;
  _BYTE v27[40];
  int v28;
  uint64_t v29;
  uint8_t buf[4];
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v27[0] = 0;
  v29 = 0;
  memset(&v27[8], 0, 32);
  v28 = 0;
  v5 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a2 + 64))(a2, v27);
  v6 = v5;
  if ((_DWORD)v5)
  {
    v19 = v5;
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 72))(a1);
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 32))(a1, v27);
    (*(void (**)(uint64_t))(*(_QWORD *)a2 + 88))(a2);
    v8 = v7;
    v9 = 0;
    while (1)
    {
      v24[0] = 0;
      v26 = 0;
      memset(&v24[8], 0, 32);
      v25 = 0;
      v10 = (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *))(*(_QWORD *)a2 + 48))(a2, v9, v24);
      v21[0] = 0;
      v23 = 0;
      memset(&v21[8], 0, 32);
      v22 = 0;
      v11 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, _BYTE *))(*(_QWORD *)a2 + 56))(a2, v9, v21);
      v12 = (char)v11;
      if (!v10)
        break;
      v13 = *(_QWORD *)(a3 + 32);
      if (v13)
        (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v13 + 16))(v13, v24);
      if ((v12 & 1) != 0)
        goto LABEL_9;
      v14 = 0;
      v15 = v24;
LABEL_15:
      (*(void (**)(uint64_t, _BYTE *, _BYTE *))(*(_QWORD *)a1 + 40))(a1, v15, v14);
LABEL_16:
      re::DynamicArray<re::TraceEntry>::deinit((uint64_t)&v21[16]);
      re::DynamicArray<re::TraceEntry>::deinit((uint64_t)&v24[16]);
      if (++v9 > v8)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
        v6 = v19;
        goto LABEL_20;
      }
    }
    if (!(_DWORD)v11)
    {
      v17 = *re::traceLogObjects(v11);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        v31 = v9;
        _os_log_impl(&dword_224FE9000, v17, OS_LOG_TYPE_DEFAULT, "Frame %zu contains neither snapshot nor delta. Skipping", buf, 0xCu);
      }
      goto LABEL_16;
    }
LABEL_9:
    v16 = *(_QWORD *)(a3 + 32);
    if (v16)
      (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v16 + 16))(v16, v21);
    if (v10)
      v15 = v24;
    else
      v15 = 0;
    v14 = v21;
    goto LABEL_15;
  }
LABEL_20:
  re::DynamicArray<re::TraceEntry>::deinit((uint64_t)&v27[16]);
  return v6;
}

void re::TracePersistenceSqlite::~TracePersistenceSqlite(sqlite3_stmt **this)
{
  *this = (sqlite3_stmt *)&off_24ED89C60;
  if (this[2])
  {
    sqlite3_finalize(this[3]);
    this[3] = 0;
    sqlite3_finalize(this[4]);
    this[4] = 0;
    sqlite3_finalize(this[5]);
    this[5] = 0;
    sqlite3_finalize(this[6]);
    this[6] = 0;
    sqlite3_close(this[2]);
    this[2] = 0;
  }
}

{
  re::TracePersistenceSqlite::~TracePersistenceSqlite(this);
  JUMPOUT(0x2276933B8);
}

BOOL re::TracePersistenceSqlite::createStatements(sqlite3 **this)
{
  return !sqlite3_prepare_v2(this[2], "REPLACE INTO rk_frames (id, time, snapshot, delta) VALUES (?1, ?2, ?3, ?4)", -1, this + 3, 0)&& !sqlite3_prepare_v2(this[2], "SELECT time, snapshot FROM rk_frames WHERE id = ?1", -1, this + 4, 0)&& !sqlite3_prepare_v2(this[2], "SELECT time, delta FROM rk_frames WHERE id = ?1", -1, this + 5, 0)&& sqlite3_prepare_v2(this[2], "SELECT MAX(id) FROM rk_frames WHERE id <= ?1 AND snapshot IS NOT NULL", -1, this + 6, 0) == 0;
}

BOOL re::TracePersistenceSqlite::createFile(sqlite3 **this, const char *filename)
{
  _BOOL8 result;

  if (sqlite3_open_v2(filename, this + 2, 6, 0))
    return 0;
  result = re::TracePersistenceSqlite::createTables(this);
  if (result)
  {
    result = re::TracePersistenceSqlite::createStatements(this);
    if (result)
    {
      (*((void (**)(sqlite3 **))*this + 9))(this);
      return 1;
    }
  }
  return result;
}

BOOL re::TracePersistenceSqlite::createTables(sqlite3 **this)
{
  return !sqlite3_exec(this[2], "CREATE TABLE IF NOT EXISTS rk_frames (id INT PRIMARY KEY,  time REAL NOT NULL,  delta BLOB,  snapshot BLOB)", 0, 0, 0)&& sqlite3_exec(this[2], "PRAGMA user_version = 1", 0, 0, 0) == 0;
}

uint64_t re::TracePersistenceSqlite::beginBatch(sqlite3 **this)
{
  return sqlite3_exec(this[2], "BEGIN EXCLUSIVE TRANSACTION", 0, 0, 0);
}

uint64_t re::TracePersistenceSqlite::endBatch(sqlite3 **this)
{
  return sqlite3_exec(this[2], "COMMIT TRANSACTION", 0, 0, 0);
}

uint64_t re::TracePersistenceSqlite::add(sqlite3_stmt **this, const re::TraceDelta *a2, const re::TraceDelta *a3, int a4)
{
  const re::TraceDelta *v5;
  double v8;
  sqlite3_stmt *v9;
  int v10;
  sqlite3_stmt *v11;
  _QWORD v13[5];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17[2];
  uint64_t v18;
  void *v19;
  char v20[8];
  uint64_t v21;
  uint64_t v22;
  int n[4];
  void *v24;

  v5 = a3;
  if (a2)
  {
    if (v14 && v18)
      (*(void (**)(void))(*(_QWORD *)v14 + 40))();
    if (!v5)
    {
      LOBYTE(v14) = 1;
      v19 = 0;
      v16 = 0;
      *(_QWORD *)v17 = 0;
      v5 = a2;
      v15 = 0;
LABEL_11:
      v8 = *((double *)v5 + 1);
      LOBYTE(v5) = v20[0] == 0;
      goto LABEL_12;
    }
LABEL_8:
    if (v13[0] && v13[4])
      (*(void (**)(void))(*(_QWORD *)v13[0] + 40))();
    goto LABEL_11;
  }
  v20[0] = 1;
  v24 = 0;
  v22 = 0;
  *(_QWORD *)n = 0;
  v21 = 0;
  if (a3)
    goto LABEL_8;
  LOBYTE(v14) = 1;
  v19 = 0;
  v16 = 0;
  *(_QWORD *)v17 = 0;
  v8 = 0.0;
  v15 = 0;
LABEL_12:
  sqlite3_bind_int(this[3], 1, a4);
  sqlite3_bind_double(this[3], 2, v8);
  v9 = this[3];
  if ((v5 & 1) != 0)
    sqlite3_bind_null(v9, 3);
  else
    sqlite3_bind_blob(v9, 3, v24, n[0], 0);
  v10 = v14;
  v11 = this[3];
  if ((_BYTE)v14)
    sqlite3_bind_blob(v11, 4, v19, v17[0], 0);
  else
    sqlite3_bind_null(v11, 4);
  sqlite3_step(this[3]);
  sqlite3_reset(this[3]);
  sqlite3_bind_null(this[3], 3);
  sqlite3_bind_null(this[3], 4);
  if (v10 && v15 && v19)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  if ((v5 & 1) == 0 && v21 && v24)
    (*(void (**)(void))(*(_QWORD *)v21 + 40))();
  return 1;
}

uint64_t re::`anonymous namespace'::toOpack(re::_anonymous_namespace_ *this, const re::TraceDelta *a2)
{
  re::zerocopy **v5;
  _QWORD *v6;
  _QWORD v7[2];

  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *(_QWORD *)this = 0;
  *((_DWORD *)this + 6) = 0;
  re::DynamicArray<BOOL>::setCapacity(this, 0x1000uLL);
  v7[0] = &off_24ED7DD00;
  v7[1] = this;
  v6 = v7;
  v5 = (re::zerocopy **)&v6;
  return re::TraceDeltaWriter::writeDelta(&v5, a2);
}

uint64_t re::TracePersistenceSqlite::saveMetadata(sqlite3_stmt **this, const re::TraceDelta *a2)
{
  return re::TracePersistenceSqlite::add(this, a2, 0, -1);
}

uint64_t re::TracePersistenceSqlite::saveFrame(re::TracePersistenceSqlite *this, const re::TraceDelta *a2, const re::TraceDelta *a3)
{
  uint64_t result;

  result = re::TracePersistenceSqlite::add((sqlite3_stmt **)this, a2, a3, *((_DWORD *)this + 2));
  ++*((_DWORD *)this + 2);
  return result;
}

uint64_t re::TracePersistenceSqlite::loadSnapshotFromRow(sqlite3_stmt **this, int a2, re::TraceDelta *a3)
{
  uint64_t v6;
  uint64_t v7;
  _BYTE v9[8];
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  sqlite3_reset(this[4]);
  sqlite3_bind_int(this[4], 1, a2);
  if (sqlite3_step(this[4]) != 100)
    return 0;
  sqlite3_column_blob(this[4], 1);
  if (sqlite3_column_bytes(this[4], 1) < 1)
    return 0;
  if (!v9[0])
    return 0;
  v6 = v12;
  if (v10 && v6)
    (*(void (**)(void))(*(_QWORD *)v10 + 40))();
  return v7;
}

uint64_t re::`anonymous namespace'::fromOpack(uint64_t a1, uint64_t a2, re::TraceDelta *a3)
{
  uint64_t v4;
  re::OPackReader *v6;
  _QWORD v7[4];
  _BYTE v8[376];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  v7[0] = &off_24ED7DDA8;
  v7[1] = a2;
  v7[2] = a2;
  v7[3] = a2 + a1;
  re::OPackReader::OPackReader((uint64_t)v8, (uint64_t)v7);
  v6 = (re::OPackReader *)v8;
  v4 = re::TraceDeltaReader::read(&v6, a3);
  re::OPackReader::~OPackReader((re::OPackReader *)v8);
  return v4;
}

uint64_t re::TracePersistenceSqlite::loadDelta(sqlite3_stmt **this, int a2, re::TraceDelta *a3)
{
  uint64_t v6;
  uint64_t v7;
  _BYTE v9[8];
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  sqlite3_reset(this[5]);
  sqlite3_bind_int(this[5], 1, a2);
  if (sqlite3_step(this[5]) != 100)
    return 0;
  sqlite3_column_blob(this[5], 1);
  if (sqlite3_column_bytes(this[5], 1) < 1)
    return 0;
  if (!v9[0])
    return 0;
  v6 = v12;
  if (v10 && v6)
    (*(void (**)(void))(*(_QWORD *)v10 + 40))();
  return v7;
}

uint64_t re::TracePersistenceSqlite::loadMetadata(sqlite3_stmt **this, re::TraceDelta *a2)
{
  return re::TracePersistenceSqlite::loadSnapshotFromRow(this, -1, a2);
}

uint64_t re::TracePersistenceSqlite::truncate(sqlite3 **this)
{
  uint64_t result;

  result = sqlite3_exec(this[2], "DELETE FROM rk_frames", 0, 0, 0);
  *((_DWORD *)this + 2) = 0;
  return result;
}

uint64_t re::TracePersistenceSqlite::findSnapshot(sqlite3_stmt **this, int a2)
{
  sqlite3_reset(this[6]);
  sqlite3_bind_int(this[6], 1, a2);
  if (sqlite3_step(this[6]) == 100)
    return sqlite3_column_int(this[6], 0);
  else
    return -1;
}

uint64_t re::TracePersistenceSqlite::range(re::TracePersistenceSqlite *this)
{
  return 0;
}

uint64_t re::`anonymous namespace'::performCompression(uint64_t a1)
{
  compression_stream_operation v1;
  compression_stream_operation v2;
  size_t v3;
  size_t v4;
  const uint8_t *v5;
  const uint8_t *v6;
  uint64_t v7;
  uint64_t v8;
  compression_status v9;
  size_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t result;
  compression_stream stream;
  uint64_t v15;
  __int128 v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE __src[32768];
  int v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  unint64_t v26;
  __int16 v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  MEMORY[0x24BDAC7A8](a1);
  v2 = v1;
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v34 = *MEMORY[0x24BDAC8D0];
  v18 = 0;
  v16 = 0uLL;
  v15 = 0;
  v17 = 0;
  re::DynamicArray<BOOL>::setCapacity(&v15, 0x8000uLL);
  memset(&stream, 0, sizeof(stream));
  compression_stream_init(&stream, v2, COMPRESSION_LZFSE);
  stream.src_ptr = v6;
  stream.src_size = v4;
  while (1)
  {
    stream.dst_ptr = __src;
    stream.dst_size = 0x8000;
    v9 = compression_stream_process(&stream, 1);
    if (v9 > COMPRESSION_STATUS_END)
      break;
    v10 = stream.dst_ptr - __src;
    v11 = *((_QWORD *)&v16 + 1);
    re::DynamicArray<BOOL>::resize((uint64_t)&v15, stream.dst_ptr - __src + *((_QWORD *)&v16 + 1));
    v12 = *((_QWORD *)&v16 + 1);
    if (*((_QWORD *)&v16 + 1) <= v11)
    {
      v19 = 0;
      v32 = 0u;
      v33 = 0u;
      v30 = 0u;
      v31 = 0u;
      v29 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v21 = 136315906;
      v22 = "operator[]";
      v23 = 1024;
      v24 = 789;
      v25 = 2048;
      v26 = v11;
      v27 = 2048;
      v28 = v12;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    memcpy((void *)(v18 + v11), __src, v10);
    if (v9)
    {
      result = compression_stream_destroy(&stream);
LABEL_7:
      *(_QWORD *)(v8 + 8) = v15;
      *(_OWORD *)(v8 + 16) = v16;
      *(_QWORD *)(v8 + 40) = v18;
      *(_DWORD *)(v8 + 32) = 1;
      *(_BYTE *)v8 = 1;
      return result;
    }
  }
  result = compression_stream_destroy(&stream);
  if (v9 != COMPRESSION_STATUS_ERROR)
    goto LABEL_7;
  result = v15;
  *(_BYTE *)v8 = 0;
  if (result && v18)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
  return result;
}

re::TracePersistenceMemory *re::TracePersistenceMemory::TracePersistenceMemory(re::TracePersistenceMemory *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_24ED89CF8;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  re::DynamicArray<re::TracePersistenceMemory::Entry>::setCapacity((_QWORD *)this + 1, 0x400uLL);
  v2 = operator new();
  *(_QWORD *)(v2 + 48) = 0;
  *(_OWORD *)(v2 + 8) = 0u;
  *(_OWORD *)(v2 + 24) = 0u;
  *(_DWORD *)(v2 + 40) = 0;
  *((_QWORD *)this + 6) = v2;
  *(_BYTE *)v2 = 4;
  (*(void (**)(re::TracePersistenceMemory *))(*(_QWORD *)this + 72))(this);
  return this;
}

_QWORD *re::DynamicArray<re::TracePersistenceMemory::Entry>::setCapacity(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::TracePersistenceMemory::Entry>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 57)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 128, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = a2 << 7;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, a2 << 7, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = v8 + (v9 << 7);
        v11 = v7;
        do
        {
          *(_BYTE *)v11 = *(_BYTE *)v8;
          *(_OWORD *)(v11 + 1) = *(_OWORD *)(v8 + 8);
          v11[7] = 0;
          v11[4] = 0;
          v11[5] = 0;
          v11[3] = 0;
          *((_DWORD *)v11 + 12) = 0;
          v12 = v8 + 24;
          v13 = *(_QWORD *)(v8 + 32);
          v11[3] = *(_QWORD *)(v8 + 24);
          *(_QWORD *)(v8 + 24) = 0;
          v11[4] = v13;
          *(_QWORD *)(v8 + 32) = 0;
          v14 = v11[5];
          v11[5] = *(_QWORD *)(v8 + 40);
          *(_QWORD *)(v8 + 40) = v14;
          v15 = v11[7];
          v11[7] = *(_QWORD *)(v8 + 56);
          *(_QWORD *)(v8 + 56) = v15;
          ++*(_DWORD *)(v8 + 48);
          ++*((_DWORD *)v11 + 12);
          *((_BYTE *)v11 + 64) = *(_BYTE *)(v8 + 64);
          *(_OWORD *)(v11 + 9) = *(_OWORD *)(v8 + 72);
          v11[15] = 0;
          v11[12] = 0;
          v11[13] = 0;
          v11[11] = 0;
          *((_DWORD *)v11 + 28) = 0;
          v16 = *(_QWORD *)(v8 + 88);
          v17 = *(_QWORD *)(v8 + 96);
          v18 = v8 + 88;
          v11[11] = v16;
          v11[12] = v17;
          *(_QWORD *)v18 = 0;
          *(_QWORD *)(v18 + 8) = 0;
          v19 = v11[13];
          v11[13] = *(_QWORD *)(v18 + 16);
          *(_QWORD *)(v18 + 16) = v19;
          v20 = v11[15];
          v11[15] = *(_QWORD *)(v18 + 32);
          *(_QWORD *)(v18 + 32) = v20;
          ++*(_DWORD *)(v18 + 24);
          ++*((_DWORD *)v11 + 28);
          re::DynamicArray<re::TraceEntry>::deinit(v18);
          re::DynamicArray<re::TraceEntry>::deinit(v12);
          v8 = v18 + 40;
          v11 += 16;
        }
        while (v8 != v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::TracePersistenceMemory::~TracePersistenceMemory(re::TracePersistenceMemory *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)this = &off_24ED89CF8;
  v2 = *((_QWORD *)this + 6);
  if (v2)
  {
    re::DynamicArray<re::TraceEntry>::deinit(v2 + 16);
    MEMORY[0x2276933B8](v2, 0x1020C4094B8BC74);
  }
  v3 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 6) = 0;
  if (v3)
  {
    v4 = *((_QWORD *)this + 5);
    if (v4)
    {
      v5 = *((_QWORD *)this + 3);
      if (v5)
      {
        v6 = v5 << 7;
        v7 = v4 + 88;
        do
        {
          re::DynamicArray<re::TraceEntry>::deinit(v7);
          re::DynamicArray<re::TraceEntry>::deinit(v7 - 64);
          v7 += 128;
          v6 -= 128;
        }
        while (v6);
        v3 = *((_QWORD *)this + 1);
        v4 = *((_QWORD *)this + 5);
      }
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 40))(v3, v4);
    }
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)this + 2) = 0;
    *((_QWORD *)this + 3) = 0;
    *((_QWORD *)this + 1) = 0;
    ++*((_DWORD *)this + 8);
  }
}

{
  re::TracePersistenceMemory::~TracePersistenceMemory(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::TracePersistenceMemory::saveMetadata(re::TracePersistenceMemory *this, const re::TraceDelta *a2)
{
  _OWORD *v2;

  v2 = (_OWORD *)*((_QWORD *)this + 6);
  *v2 = *(_OWORD *)a2;
  return re::DynamicArray<re::TraceEntry>::operator=((uint64_t)(v2 + 1), (uint64_t *)a2 + 2);
}

uint64_t re::TracePersistenceMemory::saveFrame(re::TracePersistenceMemory *this, const re::TraceDelta *a2, const re::TraceDelta *a3)
{
  re::TracePersistenceMemory *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  BOOL v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v18;
  _BYTE v19[24];
  __int128 v20;
  int v21;
  uint64_t v22;
  BOOL v23;
  _BYTE v24[24];
  __int128 v25;
  int v26;
  uint64_t v27;

  v4 = this;
  v18 = a2 != 0;
  if (a2)
  {
    *(_OWORD *)v19 = *(_OWORD *)a2;
    this = (re::TracePersistenceMemory *)re::DynamicArray<re::TraceEntry>::DynamicArray((uint64_t)&v19[16], (uint64_t *)a2 + 2);
  }
  else
  {
    v19[0] = 0;
    v22 = 0;
    *(_OWORD *)&v19[8] = 0u;
    v20 = 0u;
    v21 = 0;
  }
  v23 = a3 != 0;
  if (a3)
  {
    *(_OWORD *)v24 = *(_OWORD *)a3;
    this = (re::TracePersistenceMemory *)re::DynamicArray<re::TraceEntry>::DynamicArray((uint64_t)&v24[16], (uint64_t *)a3 + 2);
  }
  else
  {
    v24[0] = 0;
    v27 = 0;
    *(_OWORD *)&v24[8] = 0u;
    v25 = 0u;
    v26 = 0;
  }
  v5 = *((_QWORD *)v4 + 2);
  v6 = *((_QWORD *)v4 + 3);
  if (v6 >= v5)
  {
    v7 = v6 + 1;
    if (v5 < v6 + 1)
    {
      if (*((_QWORD *)v4 + 1))
      {
        v8 = 2 * v5;
        v9 = v5 == 0;
        v10 = 8;
        if (!v9)
          v10 = v8;
        if (v10 <= v7)
          v11 = v7;
        else
          v11 = v10;
        re::DynamicArray<re::TracePersistenceMemory::Entry>::setCapacity((_QWORD *)v4 + 1, v11);
      }
      else
      {
        re::DynamicArray<re::TracePersistenceMemory::Entry>::setCapacity((_QWORD *)v4 + 1, v7);
        ++*((_DWORD *)v4 + 8);
      }
    }
    v6 = *((_QWORD *)v4 + 3);
  }
  v12 = *((_QWORD *)v4 + 5) + (v6 << 7);
  *(_BYTE *)v12 = v18;
  *(_OWORD *)(v12 + 8) = *(_OWORD *)v19;
  *(_QWORD *)(v12 + 56) = 0;
  *(_DWORD *)(v12 + 48) = 0;
  *(_QWORD *)(v12 + 32) = 0;
  *(_QWORD *)(v12 + 40) = 0;
  *(_QWORD *)(v12 + 24) = 0;
  *(_QWORD *)(v12 + 24) = *(_QWORD *)&v19[16];
  *(_QWORD *)&v19[16] = 0;
  *(_QWORD *)(v12 + 32) = v20;
  *(_QWORD *)&v20 = 0;
  v13 = *(_QWORD *)(v12 + 40);
  *(_QWORD *)(v12 + 40) = *((_QWORD *)&v20 + 1);
  *((_QWORD *)&v20 + 1) = v13;
  v14 = *(_QWORD *)(v12 + 56);
  *(_QWORD *)(v12 + 56) = v22;
  v22 = v14;
  ++v21;
  ++*(_DWORD *)(v12 + 48);
  *(_BYTE *)(v12 + 64) = v23;
  *(_OWORD *)(v12 + 72) = *(_OWORD *)v24;
  *(_QWORD *)(v12 + 120) = 0;
  *(_QWORD *)(v12 + 96) = 0;
  *(_QWORD *)(v12 + 104) = 0;
  *(_QWORD *)(v12 + 88) = 0;
  *(_DWORD *)(v12 + 112) = 0;
  *(_QWORD *)(v12 + 88) = *(_QWORD *)&v24[16];
  *(_QWORD *)&v24[16] = 0;
  *(_QWORD *)(v12 + 96) = v25;
  *(_QWORD *)&v25 = 0;
  v15 = *(_QWORD *)(v12 + 104);
  *(_QWORD *)(v12 + 104) = *((_QWORD *)&v25 + 1);
  *((_QWORD *)&v25 + 1) = v15;
  v16 = *(_QWORD *)(v12 + 120);
  *(_QWORD *)(v12 + 120) = v27;
  v27 = v16;
  ++v26;
  ++*(_DWORD *)(v12 + 112);
  ++*((_QWORD *)v4 + 3);
  ++*((_DWORD *)v4 + 8);
  re::DynamicArray<re::TraceEntry>::deinit((uint64_t)&v24[16]);
  return re::DynamicArray<re::TraceEntry>::deinit((uint64_t)&v19[16]);
}

uint64_t re::TracePersistenceMemory::loadSnapshot(re::TracePersistenceMemory *this, unint64_t a2, re::TraceDelta *a3)
{
  uint64_t v3;
  uint64_t v4;

  if (*((_QWORD *)this + 3) <= a2)
    return 0;
  v3 = *((_QWORD *)this + 5);
  if (!*(_BYTE *)(v3 + (a2 << 7)))
    return 0;
  v4 = v3 + (a2 << 7);
  *(_OWORD *)a3 = *(_OWORD *)(v4 + 8);
  re::DynamicArray<re::TraceEntry>::operator=((uint64_t)a3 + 16, (uint64_t *)(v4 + 24));
  return 1;
}

uint64_t re::TracePersistenceMemory::loadDelta(re::TracePersistenceMemory *this, unint64_t a2, re::TraceDelta *a3)
{
  uint64_t v3;

  if (*((_QWORD *)this + 3) <= a2)
    return 0;
  v3 = *((_QWORD *)this + 5) + (a2 << 7);
  if (!*(_BYTE *)(v3 + 64))
    return 0;
  *(_OWORD *)a3 = *(_OWORD *)(v3 + 72);
  re::DynamicArray<re::TraceEntry>::operator=((uint64_t)a3 + 16, (uint64_t *)(v3 + 88));
  return 1;
}

uint64_t re::TracePersistenceMemory::loadMetadata(re::TracePersistenceMemory *this, re::TraceDelta *a2)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 6);
  *(_OWORD *)a2 = *(_OWORD *)v2;
  re::DynamicArray<re::TraceEntry>::operator=((uint64_t)a2 + 16, (uint64_t *)(v2 + 16));
  return 1;
}

uint64_t re::TracePersistenceMemory::truncate(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = this;
  v2 = *(_QWORD *)(this + 24);
  *(_QWORD *)(this + 24) = 0;
  if (v2)
  {
    v3 = v2 << 7;
    v4 = *(_QWORD *)(this + 40) + 88;
    do
    {
      re::DynamicArray<re::TraceEntry>::deinit(v4);
      this = re::DynamicArray<re::TraceEntry>::deinit(v4 - 64);
      v4 += 128;
      v3 -= 128;
    }
    while (v3);
  }
  ++*(_DWORD *)(v1 + 32);
  return this;
}

uint64_t re::TracePersistenceMemory::findSnapshot(re::TracePersistenceMemory *this, int a2)
{
  unint64_t v2;
  unsigned int v3;
  uint64_t v4;

  v2 = *((_QWORD *)this + 3);
  v3 = v2 - 1;
  if ((int)v2 - 1 >= a2)
    v3 = a2;
  if ((v3 & 0x80000000) != 0)
    return 0;
  while (1)
  {
    v4 = v3;
    if (v2 <= v3)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (*(_BYTE *)(*((_QWORD *)this + 5) + ((unint64_t)v3 << 7)))
      break;
    --v3;
    if ((int)v4 < 1)
      return 0;
  }
  return v4;
}

uint64_t re::TracePersistenceMemory::range(re::TracePersistenceMemory *this)
{
  return 0;
}

void re::TraceDirectCollector::~TraceDirectCollector(re::TraceDirectCollector *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_24ED89D80;
  v2 = *((_QWORD *)this + 9);
  if (v2)
  {
    (*(void (**)(uint64_t, re::TraceDirectCollector *))(*(_QWORD *)v2 + 64))(v2, this);
    *((_QWORD *)this + 9) = 0;
  }
  re::TraceHistory::~TraceHistory((re::TraceDirectCollector *)((char *)this + 80));
  re::TracePersistenceSqlite::~TracePersistenceSqlite((sqlite3_stmt **)this + 2);
}

{
  re::TraceDirectCollector::~TraceDirectCollector(this);
  JUMPOUT(0x2276933B8);
}

void re::TraceDirectCollector::startCollecting(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  uint8_t v6[16];

  if (a2)
  {
    v4 = a1[9];
    if (v4)
    {
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v4 + 64))(v4, a1);
      a1[9] = 0;
    }
    re::TraceHistory::clear((re::TraceHistory *)(a1 + 10));
    a1[9] = a2;
    (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)a2 + 56))(a2, a1);
  }
  else
  {
    v5 = *re::traceLogObjects((re *)a1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v6 = 0;
      _os_log_error_impl(&dword_224FE9000, v5, OS_LOG_TYPE_ERROR, "Invalid argument to TraceDirectCollector. traceService is nullptr", v6, 2u);
    }
  }
}

uint64_t re::TraceDirectCollector::saveToFile(re::TraceDirectCollector *this, const char *a2)
{
  _BOOL8 File;
  uint64_t v5;
  char v6;
  re *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  const char *v12;
  NSObject *v13;
  void (**v15)(re::TracePersistenceSqlite *__hidden);
  int v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  const char *v23;
  _QWORD v24[3];
  uint64_t v25;
  re *v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v15 = &off_24ED89C60;
  v16 = 0;
  v17 = 0u;
  v18 = 0u;
  v19 = 0;
  File = re::TracePersistenceSqlite::createFile((sqlite3 **)&v15, a2);
  if (!File)
  {
    v11 = *re::traceLogObjects((re *)File);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
LABEL_12:
      v9 = 1;
      goto LABEL_13;
    }
    *(_DWORD *)buf = 136315138;
    v21 = a2;
    v12 = "Unable to open '%s'\n";
    v13 = v11;
LABEL_15:
    _os_log_error_impl(&dword_224FE9000, v13, OS_LOG_TYPE_ERROR, v12, buf, 0xCu);
    goto LABEL_12;
  }
  v5 = *((_QWORD *)this + 14);
  memset(v24, 0, sizeof(v24));
  v25 = re::globalAllocators((re *)File)[2];
  v26 = 0;
  v6 = re::TracePersistenceUtils::copyAll((uint64_t)&v15, v5, (uint64_t)v24);
  v7 = v26;
  if (v26)
  {
    v7 = (re *)(**(uint64_t (***)(re *))v26)(v26);
    if (v26 != (re *)v24)
      v7 = (re *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v25 + 40))(v25);
    v26 = 0;
  }
  v8 = *re::traceLogObjects(v7);
  if ((v6 & 1) == 0)
  {
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      goto LABEL_12;
    *(_DWORD *)buf = 136315138;
    v21 = a2;
    v12 = "Failed to write '%s'\n";
    v13 = v8;
    goto LABEL_15;
  }
  v9 = 0;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 14) + 88))(*((_QWORD *)this + 14));
    *(_DWORD *)buf = 134218242;
    v21 = (const char *)(v10 + 1);
    v22 = 2080;
    v23 = a2;
    _os_log_impl(&dword_224FE9000, v8, OS_LOG_TYPE_DEFAULT, "Saved %zu frames to '%s'\n", buf, 0x16u);
    v9 = 0;
  }
LABEL_13:
  re::TracePersistenceSqlite::~TracePersistenceSqlite((sqlite3_stmt **)&v15);
  return v9;
}

re::TraceDelta **re::TraceDirectCollector::clientLoadedDelta(re::TraceDelta **this, const re::TraceDelta *a2)
{
  const re::TraceDelta *v2;
  re::TraceDelta **v3;
  int v4;
  sqlite3_stmt **v5;
  int v6;

  v2 = a2;
  v3 = this;
  if (!*((_BYTE *)this + 9))
    return re::TraceHistory::addData(this + 10, a2);
  v4 = *(unsigned __int8 *)a2;
  if ((v4 - 1) < 2)
  {
    v5 = this + 2;
    v6 = *((_DWORD *)v3 + 6);
    a2 = 0;
    goto LABEL_8;
  }
  if (v4 == 4)
    return (re::TraceDelta **)re::TracePersistenceSqlite::add(this + 2, a2, 0, -1);
  if (v4 == 3)
  {
    v5 = this + 2;
    v6 = *((_DWORD *)v3 + 6);
    v2 = 0;
LABEL_8:
    this = (re::TraceDelta **)re::TracePersistenceSqlite::add(v5, a2, v2, v6);
    ++*((_DWORD *)v3 + 6);
  }
  return this;
}

void re::xpc::Connection::makeWithListenerEndpoint(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  id v3;

  v3 = (id)objc_msgSend(objc_alloc(MEMORY[0x24BDD1988]), "initWithListenerEndpoint:", *a1);
  *a2 = v3;

}

void re::xpc::Connection::setExportedInterface(id *a1, uint64_t *a2)
{
  uint64_t v2;
  id v3;

  v2 = *a2;
  v3 = *a1;
  objc_msgSend(v3, "setExportedInterface:", v2);

}

void re::xpc::Connection::setExportedObject(id *this, const re::ObjCObject *a2)
{
  uint64_t v2;
  id v3;

  v2 = *(_QWORD *)a2;
  v3 = *this;
  objc_msgSend(v3, "setExportedObject:", v2);

}

void re::xpc::Connection::setRemoteObjectInterface(id *a1, uint64_t *a2)
{
  uint64_t v2;
  id v3;

  v2 = *a2;
  v3 = *a1;
  objc_msgSend(v3, "setRemoteObjectInterface:", v2);

}

void re::xpc::Connection::remoteObjectProxy(id *this@<X0>, _QWORD *a2@<X8>)
{
  id v3;

  objc_msgSend(*this, "remoteObjectProxy");
  v3 = (id)objc_claimAutoreleasedReturnValue();
  *a2 = v3;

}

void re::xpc::Connection::remoteObjectProxyWithErrorHandler(id *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  id v4;

  objc_msgSend(*a1, "remoteObjectProxyWithErrorHandler:", a2);
  v4 = (id)objc_claimAutoreleasedReturnValue();
  *a3 = v4;

}

void re::xpc::Connection::syncRemoteObjectProxy(id *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  id v4;

  objc_msgSend(*a1, "synchronousRemoteObjectProxyWithErrorHandler:", a2);
  v4 = (id)objc_claimAutoreleasedReturnValue();
  *a3 = v4;

}

void re::xpc::Connection::setQueue(id *this, const re::dispatch::Queue *a2)
{
  uint64_t v2;
  id v3;

  v2 = *(_QWORD *)a2;
  v3 = *this;
  objc_msgSend(v3, "_setQueue:", v2);

}

void re::xpc::Listener::makeAnonymous(_QWORD *a1@<X8>)
{
  id v3;

  objc_msgSend(MEMORY[0x24BDD1998], "anonymousListener");
  v3 = (id)objc_claimAutoreleasedReturnValue();
  *a1 = v3;

}

void re::xpc::Listener::setDelegate(id *a1, uint64_t *a2)
{
  uint64_t v2;
  id v3;

  v2 = *a2;
  v3 = *a1;
  objc_msgSend(v3, "setDelegate:", v2);

}

void re::xpc::Listener::endpoint(id *this@<X0>, _QWORD *a2@<X8>)
{
  id v3;

  objc_msgSend(*this, "endpoint");
  v3 = (id)objc_claimAutoreleasedReturnValue();
  *a2 = v3;

}

void OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::~FVarLevel(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  v2 = (void *)*((_QWORD *)this + 24);
  if (v2)
  {
    *((_QWORD *)this + 25) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 21);
  if (v3)
  {
    *((_QWORD *)this + 22) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 18);
  if (v4)
  {
    *((_QWORD *)this + 19) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 15);
  if (v5)
  {
    *((_QWORD *)this + 16) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 12);
  if (v6)
  {
    *((_QWORD *)this + 13) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 9);
  if (v7)
  {
    *((_QWORD *)this + 10) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 6);
  if (v8)
  {
    *((_QWORD *)this + 7) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 3);
  if (v9)
  {
    *((_QWORD *)this + 4) = v9;
    operator delete(v9);
  }
}

void OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::resizeComponents(std::vector<int> *this)
{
  std::vector<int>::pointer begin;
  std::vector<int>::pointer v3;
  unint64_t v4;
  char *v5;
  unint64_t v6;
  __int16 v7;
  char v8;

  std::vector<unsigned int>::resize(this + 1, (int)((uint64_t)(*((_QWORD *)this->__begin_ + 7) - *((_QWORD *)this->__begin_ + 6)) >> 2));
  begin = this[2].__begin_;
  v8 = 0;
  v3 = this->__begin_;
  v4 = this->__begin_[1];
  v5 = (char *)((char *)this[2].__end_ - (char *)begin);
  if (v4 <= (unint64_t)v5)
  {
    if (v4 < (unint64_t)v5)
      this[2].__end_ = (std::vector<int>::pointer)((char *)begin + v4);
  }
  else
  {
    std::vector<OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::ETag>::__append(&this[2].__begin_, v4 - (_QWORD)v5, &v8);
    v3 = this->__begin_;
  }
  std::vector<unsigned short>::resize((uint64_t)&this[3], v3[2]);
  std::vector<unsigned int>::resize(this + 4, this->__begin_[2]);
  v6 = (int)((uint64_t)(*((_QWORD *)this->__begin_ + 37) - *((_QWORD *)this->__begin_ + 36)) >> 2);
  v7 = 0;
  std::vector<unsigned short>::resize((uint64_t)&this[5], v6, &v7);
}

void std::vector<unsigned short>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 2 * a2;
  }
  else
  {
    std::vector<unsigned short>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<unsigned short>::resize(uint64_t a1, unint64_t a2, _WORD *a3)
{
  unint64_t v3;

  v3 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1;
  if (a2 <= v3)
  {
    if (a2 < v3)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 2 * a2;
  }
  else
  {
    std::vector<unsigned short>::__append((void **)a1, a2 - v3, a3);
  }
}

void std::vector<OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::CreaseEndPair>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 4 * a2;
  }
  else
  {
    std::vector<OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::CreaseEndPair>::__append((void **)a1, a2 - v2);
  }
}

void OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::completeTopologyFromFaceValues(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *this, int a2)
{
  unsigned int v3;
  unsigned int v4;
  int v5;
  _BOOL4 v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int32 *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int32 *v20;
  uint64_t v21;
  int *v22;
  unsigned __int16 *v23;
  uint64_t v24;
  uint64_t v25;
  __int32 *v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  int *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  int *v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  int v63;
  uint64_t v64;
  char v65;
  char v66;
  uint64_t v67;
  __int32 *v68;
  int v69;
  _WORD *v70;
  __int32 v71;
  __int32 *v72;
  __int32 *v73;
  __int32 *v74;
  uint64_t v75;
  uint64_t v76;
  _BOOL4 v77;
  _WORD *v78;
  __int16 *v79;
  __int16 v80;
  uint64_t v81;
  uint64_t v82;
  unint64_t v83;
  unint64_t v84;
  char *v85;
  char *v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  size_t v90;
  char *v91;
  char *v92;
  char *v93;
  char *v94;
  char v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  uint64_t v105;
  uint64_t v106;
  _DWORD *v107;
  uint64_t v108;
  uint64_t v109;
  unsigned __int16 *v110;
  int *v111;
  unsigned __int16 *v112;
  uint64_t v113;
  int v114;
  __int16 v115;
  char v116;
  BOOL v117;
  char v118;
  unsigned __int16 *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  unint64_t v124;
  uint64_t v125;
  int *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  int v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  char v136;
  _WORD *v137;
  uint64_t v138;
  uint64_t v139;
  char v140;
  _WORD *v141;
  uint64_t v142;
  uint64_t v143;
  unsigned __int16 *v144;
  int v145;
  uint64_t v146;
  char v147;
  int v148;
  char v149;
  _BYTE *v150;
  uint64_t v151;
  int v152;
  _BOOL4 v153;
  unsigned int v154;
  int v155;
  int v156;
  unsigned int v157;
  int v158;
  _BOOL4 v159;
  char v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  int v164;
  __int16 v165;
  BOOL v166;
  _BOOL4 v167;
  unsigned int v168;
  _QWORD *v170;
  int v171;
  __int16 *v172;
  char v173;
  uint64_t v174;
  uint64_t v175;
  char *v176;
  char *v177;
  void *v178;
  int v179;
  int v180;
  _BYTE v181[160];
  void *__p;
  __int16 *v183;
  int v184;
  int v185;
  _BYTE v186[32];
  void *v187;
  __int32 *__s;
  int v189;
  int v190;
  _BYTE v191[64];
  void *v192;
  __int32 *v193;
  int v194;
  int v195;
  uint64_t v196;
  __int32 *v197;
  uint64_t v198;

  v198 = *MEMORY[0x24BDAC8D0];
  v3 = *((unsigned __int16 *)this + 4);
  v4 = v3 >> 2;
  v5 = (v3 >> 2) & 7;
  if (v5)
    v6 = (v3 & 3) != 2;
  else
    v6 = 0;
  v167 = v6;
  *((_BYTE *)this + 12) = v5 == 5;
  v171 = v5;
  v168 = v5 - 3;
  v7 = v5 == 3;
  *((_BYTE *)this + 13) = (v4 & 6) == 4;
  *((_BYTE *)this + 14) = (v4 & 6) == 2;
  v8 = *(_QWORD *)this;
  v9 = *(unsigned int *)(*(_QWORD *)this + 8);
  v177 = 0;
  if ((v4 & 6) == 4)
    v7 = 1;
  v176 = 0;
  v166 = v7;
  if ((_DWORD)v9)
  {
    if ((v9 & 0x80000000) != 0)
      goto LABEL_240;
    v176 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>((uint64_t)&v177, v9);
    v177 = &v176[2 * v10];
    bzero(v176, 2 * v9);
    v8 = *(_QWORD *)this;
  }
  v11 = (int)((uint64_t)(*(_QWORD *)(v8 + 296) - *(_QWORD *)(v8 + 288)) >> 2);
  LOWORD(v178) = 0;
  v170 = (_QWORD *)((char *)this + 120);
  std::vector<unsigned short>::resize((uint64_t)this + 120, v11, &v178);
  v12 = *(_QWORD *)this;
  v13 = *(unsigned int *)(*(_QWORD *)this + 20);
  v193 = (__int32 *)&v196;
  v194 = v13;
  v195 = 16;
  v197 = 0;
  if (v13 <= 0x10)
  {
    v14 = (__int32 *)v191;
    v187 = 0;
    __s = (__int32 *)v191;
    v189 = v13;
    v190 = 16;
    v192 = 0;
    v172 = (__int16 *)v186;
    __p = 0;
    v183 = (__int16 *)v186;
    v184 = v13;
    v185 = 16;
    v178 = v181;
    v179 = v13;
    v180 = 16;
  }
  else
  {
    v197 = (__int32 *)operator new(4 * v13);
    v193 = v197;
    v195 = v13;
    __s = (__int32 *)v191;
    v189 = v13;
    v190 = 16;
    v192 = 0;
    v192 = operator new(4 * v13);
    v187 = 0;
    __s = (__int32 *)v192;
    v190 = v13;
    v183 = (__int16 *)v186;
    v184 = v13;
    v185 = 16;
    v187 = operator new(2 * v13);
    __p = 0;
    v183 = (__int16 *)v187;
    v185 = v13;
    v178 = v181;
    v179 = v13;
    v180 = 16;
    __p = operator new(10 * v13);
    v178 = __p;
    v180 = v13;
    v14 = __s;
    v172 = v183;
    v12 = *(_QWORD *)this;
  }
  if (*(int *)(v12 + 8) >= 1)
  {
    v15 = 0;
    v16 = 0;
    while (1)
    {
      v17 = (2 * v15) | 1;
      v18 = *(_QWORD *)(v12 + 264);
      v19 = *(unsigned int *)(v18 + 8 * v15);
      v20 = v193;
      if ((int)v19 >= 1)
      {
        v21 = *(int *)(v18 + 4 * v17);
        v22 = (int *)(*(_QWORD *)(v12 + 288) + 4 * v21);
        v23 = (unsigned __int16 *)(*(_QWORD *)(v12 + 312) + 2 * v21);
        v24 = *(_QWORD *)(v12 + 24);
        v25 = *((_QWORD *)this + 3);
        v26 = v193;
        v27 = v19;
        do
        {
          v28 = *v22++;
          v29 = *(_DWORD *)(v24 + 8 * v28 + 4);
          LODWORD(v28) = *v23++;
          *v26++ = *(_DWORD *)(v25 + 4 * (v29 + (int)v28));
          --v27;
        }
        while (v27);
      }
      v30 = *(_QWORD *)(v12 + 336);
      v31 = *(int *)(v30 + 4 * v17);
      v32 = (int *)(*(_QWORD *)(v12 + 360) + 4 * v31);
      v33 = *(unsigned int *)(v30 + 8 * v15);
      v34 = *(unsigned __int16 *)(*(_QWORD *)(v12 + 432) + 2 * v15);
      if ((v34 & 1) != 0)
      {
        if ((int)v19 >= 1 && (int)v33 >= 1)
        {
          v42 = 0;
          v43 = *(_QWORD *)(v12 + 384) + 2 * v31;
          do
          {
            v44 = v32[v42];
            v45 = *(_QWORD **)this;
            v46 = *(_QWORD *)(*(_QWORD *)this + 144);
            v47 = *(unsigned int *)(v46 + 8 * (_DWORD)v44);
            if ((int)v47 >= 2)
            {
              v48 = 0;
              v49 = 0;
              v50 = *(int *)(v46 + 8 * v44 + 4);
              v51 = (int *)(v45[15] + 8 * (_DWORD)v44);
              while (v47 != v48)
              {
                v52 = *(int *)(v45[21] + 4 * v50 + 4 * v48);
                v53 = 2 * v52;
                v54 = v45[3];
                v55 = *(int *)(v54 + 8 * v52 + 4);
                v56 = v45[6] + 4 * v55;
                v57 = *(_DWORD *)(v54 + 4 * v53);
                v58 = *(unsigned __int16 *)(v45[24] + 2 * v50 + 2 * v48);
                v59 = *((_QWORD *)this + 3) + 4 * v55;
                v60 = *v51;
                if (*(_WORD *)(v43 + 2 * v42) == ((_DWORD)v60 != *(_DWORD *)(v56 + 4 * v58)))
                  v61 = *(unsigned __int16 *)(v45[24] + 2 * v50 + 2 * v48);
                else
                  v61 = v58 + 1;
                if (v61 == v57)
                  v62 = 0;
                else
                  v62 = v61;
                v63 = *(_DWORD *)(v59 + 4 * v62);
                if (v48)
                {
                  ++v48;
                  if (v63 != v49)
                  {
                    *(_WORD *)&v176[2 * v60] = 1;
                    *(_WORD *)&v176[2 * v51[1]] = 1;
                    v64 = *((_QWORD *)this + 6);
                    v65 = *(_BYTE *)(v64 + v44) & 0xFD | (2 * (v15 == v60));
                    *(_BYTE *)(v64 + v44) = v65;
                    v66 = v65 & 0xFB | (4 * (v15 == v51[1])) | 1;
                    *(_BYTE *)(v64 + v44) = v66;
                    *(_BYTE *)(v64 + v44) = v66 & 0xF7 | (8 * *((_BYTE *)this + 13));
                    break;
                  }
                }
                else
                {
                  v48 = 1;
                  v49 = v63;
                }
              }
            }
            ++v42;
          }
          while (v42 != v33);
        }
      }
      else if ((int)v19 > (v34 & 4) >> 2)
      {
        v35 = (v34 >> 2) & 1;
        do
        {
          if (v35)
            v36 = v35;
          else
            v36 = v19;
          if (v20[v35] != v20[v36 - 1])
          {
            v37 = v32[v35];
            v38 = *(_QWORD *)(*(_QWORD *)this + 120) + 8 * v37;
            v39 = *(unsigned int *)v38;
            *(_WORD *)&v176[2 * (int)v39] = 1;
            *(_WORD *)&v176[2 * *(int *)(v38 + 4)] = 1;
            v40 = *((_QWORD *)this + 6);
            LOBYTE(v39) = *(_BYTE *)(v40 + v37) & 0xFD | (2 * (v15 == v39));
            *(_BYTE *)(v40 + v37) = v39;
            LOBYTE(v38) = v39 & 0xFB | (4 * (v15 == *(_DWORD *)(v38 + 4))) | 1;
            *(_BYTE *)(v40 + v37) = v38;
            *(_BYTE *)(v40 + v37) = v38 & 0xF7 | (8 * *((_BYTE *)this + 13));
          }
          ++v35;
        }
        while (v19 != v35);
      }
      v173 = v34;
      if ((v34 & 4) != 0 && !*(_WORD *)&v176[2 * v15])
      {
        if (*((_BYTE *)this + 13))
        {
          if ((int)v19 < 1)
            goto LABEL_73;
          *(_WORD *)&v176[2 * v15] = 1;
          if ((v34 & 1) != 0)
          {
            if ((int)v33 >= 1)
            {
              do
              {
                v82 = *v32++;
                v81 = v82;
                if ((*(_BYTE *)(*(_QWORD *)(*(_QWORD *)this + 240) + v82) & 2) != 0)
                  *(_BYTE *)(*((_QWORD *)this + 6) + v81) |= 8u;
                --v33;
              }
              while (v33);
            }
          }
          else
          {
            *(_BYTE *)(*((_QWORD *)this + 6) + *v32) |= 8u;
            v76 = v32[(int)v33 - 1];
            *(_BYTE *)(*((_QWORD *)this + 6) + v76) |= 8u;
          }
        }
        else
        {
          v77 = v167;
          if ((_DWORD)v19 != 1)
            v77 = 0;
          if (v77)
          {
            *(_WORD *)&v176[2 * v15] = 1;
LABEL_73:
            *v14 = *v20;
            *v172 = 0;
            goto LABEL_74;
          }
        }
      }
      *v14 = *v20;
      *v172 = 0;
      if ((int)v19 > 1)
      {
        v67 = v19 - 1;
        v68 = v20 + 1;
        v69 = 1;
        v70 = v172 + 1;
        while (1)
        {
          v71 = *v68;
          if (*v68 == *(v68 - 1))
          {
            *v70 = *(v70 - 1);
          }
          else
          {
            *v70 = v69;
            if (v69 == 2)
            {
              if (*v14 == v71)
              {
LABEL_56:
                v72 = &v14[v69];
                v73 = wmemchr(v14, v71, v69);
                if (v73)
                  v74 = v73;
                else
                  v74 = &v14[v69];
                v75 = (char *)v74 - (char *)v14;
                if (v69 == v75 >> 2)
                {
                  ++v69;
                  *v72 = *v68;
                }
                else
                {
                  *v70 = (unint64_t)v75 >> 2;
                }
                goto LABEL_63;
              }
              v14[2] = v71;
              v69 = 3;
            }
            else
            {
              if (v69 != 1)
                goto LABEL_56;
              v14[1] = v71;
              v69 = 2;
            }
          }
LABEL_63:
          ++v68;
          ++v70;
          if (!--v67)
            goto LABEL_75;
        }
      }
LABEL_74:
      v69 = 1;
LABEL_75:
      if ((v173 & 1) != 0 && !*(_WORD *)&v176[2 * v15])
        *(_WORD *)&v176[2 * v15] = v69 > 1;
      *(_WORD *)(*((_QWORD *)this + 9) + 2 * v15) = v69;
      *(_DWORD *)(*((_QWORD *)this + 12) + 4 * v15) = v16;
      v12 = *(_QWORD *)this;
      if (v69 >= 2 && (int)v19 >= 1)
      {
        v78 = (_WORD *)(*v170 + 2 * *(int *)(*(_QWORD *)(v12 + 264) + 4 * ((2 * v15) | 1)));
        v79 = v172;
        do
        {
          v80 = *v79++;
          *v78++ = v80;
          --v19;
        }
        while (v19);
      }
      v16 += v69;
      if (++v15 >= *(int *)(v12 + 8))
        goto LABEL_90;
    }
  }
  v16 = 0;
LABEL_90:
  v83 = v16;
  std::vector<unsigned int>::resize((std::vector<int> *)this + 6, v16);
  v84 = *((_QWORD *)this + 21);
  v85 = (char *)*((_QWORD *)this + 22);
  v86 = &v85[-v84];
  if (v83 > (unint64_t)&v85[-v84])
  {
    v87 = *((_QWORD *)this + 23);
    if (v87 - (uint64_t)v85 >= v83 - (unint64_t)&v85[-v84])
    {
      bzero(*((void **)this + 22), v83 - (_QWORD)&v85[-v84]);
      *((_QWORD *)this + 22) = v83 + v84;
      goto LABEL_108;
    }
    if ((v83 & 0x80000000) == 0)
    {
      v88 = v87 - v84;
      v89 = 2 * v88;
      if (2 * v88 <= v83)
        v89 = v83;
      if (v88 >= 0x3FFFFFFFFFFFFFFFLL)
        v90 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v90 = v89;
      v91 = (char *)operator new(v90);
      bzero(&v86[(_QWORD)v91], v83 - (_QWORD)&v85[-v84]);
      v92 = &v91[v83];
      v93 = &v91[v90];
      if (v85 == (char *)v84)
      {
        v91 = &v86[(_QWORD)v91];
      }
      else
      {
        v94 = &v85[~v84];
        do
        {
          v95 = *--v85;
          (v94--)[(_QWORD)v91] = v95;
        }
        while (v85 != (char *)v84);
        v85 = (char *)v84;
      }
      *((_QWORD *)this + 21) = v91;
      *((_QWORD *)this + 22) = v92;
      *((_QWORD *)this + 23) = v93;
      if (v85)
        operator delete(v85);
      goto LABEL_108;
    }
LABEL_240:
    abort();
  }
  if (v83 < (unint64_t)&v85[-v84])
    *((_QWORD *)this + 22) = v84 + v83;
LABEL_108:
  if (!*((_BYTE *)this + 13))
    std::vector<OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::CreaseEndPair>::resize((uint64_t)this + 192, v83);
  v96 = *(_QWORD *)this;
  if (*(int *)(*(_QWORD *)this + 8) >= 1)
  {
    v97 = 0;
    while (1)
    {
      v98 = (2 * v97) | 1;
      v99 = *(_QWORD *)(v96 + 264);
      v100 = *(int *)(v99 + 4 * v98);
      v101 = *(_QWORD *)(v96 + 288);
      v102 = *(unsigned int *)(v99 + 8 * v97);
      v103 = *(_QWORD *)(v96 + 312);
      v104 = (int)v102 < 1
           ? 0
           : *(_DWORD *)(*((_QWORD *)this + 3)
                       + 4
                       * (*(_DWORD *)(*(_QWORD *)(v96 + 24) + 8 * *(int *)(v101 + 4 * v100) + 4)
                        + *(unsigned __int16 *)(v103 + 2 * v100)));
      v105 = *(unsigned __int16 *)(*((_QWORD *)this + 9) + 2 * v97);
      v106 = *((_QWORD *)this + 12);
      v107 = (_DWORD *)(*((_QWORD *)this + 18) + 4 * *(int *)(v106 + 4 * v97));
      *v107 = v104;
      if (*(_WORD *)&v176[2 * v97])
        break;
LABEL_234:
      if (++v97 >= *(int *)(v96 + 8))
        goto LABEL_237;
    }
    if (v105 >= 2 && (int)v102 >= 2)
    {
      v108 = *(int *)(v99 + 4 * v98);
      v109 = v102 - 1;
      v110 = (unsigned __int16 *)(v103 + 2 * v100 + 2);
      v111 = (int *)(v101 + 4 * v100 + 4);
      v112 = (unsigned __int16 *)(*v170 + 2 * v108 + 2);
      v113 = 1;
      do
      {
        v114 = *v112++;
        if (v113 == v114)
          v107[v113++] = *(_DWORD *)(*((_QWORD *)this + 3)
                                   + 4 * (*(_DWORD *)(*(_QWORD *)(v96 + 24) + 8 * *v111 + 4) + *v110));
        ++v110;
        ++v111;
        --v109;
      }
      while (v109);
    }
    v174 = *((_QWORD *)this + 21);
    v175 = *(int *)(v106 + 4 * v97);
    v115 = *(_WORD *)(*(_QWORD *)(v96 + 432) + 2 * v97);
    v116 = 1;
    if (*((_BYTE *)this + 13) || ((v115 & 0x10) == 0 ? (v117 = (v115 & 1) == 0) : (v117 = 0), !v117))
    {
LABEL_137:
      v119 = (unsigned __int16 *)v178;
      bzero(v178, 10 * v105);
      v96 = *(_QWORD *)this;
      v120 = 2 * (int)v97;
      v121 = *(unsigned __int16 *)(*((_QWORD *)this + 9) + v120);
      if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)this + 432) + v120) & 1) != 0)
      {
        if (*(_WORD *)(*((_QWORD *)this + 9) + 2 * (int)v97))
        {
          v137 = v119 + 2;
          do
          {
            *(v137 - 2) = 0;
            *v137 = 1;
            v137 += 5;
            --v121;
          }
          while (v121);
        }
        goto LABEL_183;
      }
      v122 = *(_QWORD *)(v96 + 360);
      v123 = *(_QWORD *)(v96 + 336);
      v124 = (8 * ((unint64_t)(2 * (int)v97) >> 1)) | 4;
      v125 = *(int *)(v123 + v124);
      v126 = (int *)(v122 + 4 * v125);
      v127 = 8 * (int)v97;
      v128 = *(unsigned int *)(v123 + v127);
      v129 = *(_QWORD *)(v96 + 264);
      v130 = *(int *)(v129 + v124);
      v131 = *(unsigned int *)(v129 + v127);
      if ((_DWORD)v121 == 1 && (int)v128 <= (int)v131)
      {
        *(_DWORD *)v119 = 0;
        if ((int)v128 > 0)
        {
          v132 = 0;
          v133 = 0;
          v134 = *((_QWORD *)this + 6);
          do
          {
            v135 = v126[v133];
            if ((*(_BYTE *)(v134 + v135) & 1) != 0)
            {
              if (v132)
              {
                v119[2] = 1;
                break;
              }
              *v119 = v131;
              v119[1] = v133;
              v132 = (unsigned __int16)v131;
            }
            else
            {
              v136 = *(_BYTE *)(*(_QWORD *)(v96 + 240) + v135);
              if ((v136 & 4) != 0)
              {
                ++v119[4];
              }
              else if ((v136 & 8) != 0)
              {
                ++v119[3];
              }
            }
            ++v133;
          }
          while (v128 != v133);
        }
        *v119 = v131;
        goto LABEL_183;
      }
      v138 = *((_QWORD *)this + 15) + 2 * v130;
      *(_DWORD *)v119 = 1;
      if ((int)v128 <= (int)v131 && !*(_WORD *)(v138 + 2 * ((int)v131 - 1)))
      {
        v139 = *v126;
        if ((*(_BYTE *)(*((_QWORD *)this + 6) + v139) & 1) != 0)
        {
          v141 = v119 + 2;
          goto LABEL_166;
        }
        v140 = *(_BYTE *)(*(_QWORD *)(v96 + 240) + v139);
        if ((v140 & 4) != 0)
        {
          v141 = v119 + 4;
          goto LABEL_166;
        }
        if ((v140 & 8) != 0)
        {
          v141 = v119 + 3;
LABEL_166:
          ++*v141;
        }
      }
      if ((int)v131 >= 2)
      {
        v142 = 0;
        v143 = v122 + 4 * v125 + 4;
        do
        {
          v144 = (unsigned __int16 *)(v138 + 2 * v142);
          v145 = v144[1];
          if (v145 == *v144)
          {
            v146 = *(int *)(v143 + 4 * v142);
            if ((*(_BYTE *)(*((_QWORD *)this + 6) + v146) & 1) != 0)
            {
              ++v119[5 * v144[1] + 2];
            }
            else
            {
              v147 = *(_BYTE *)(*(_QWORD *)(v96 + 240) + v146);
              if ((v147 & 4) != 0)
              {
                ++v119[5 * v144[1] + 4];
              }
              else if ((v147 & 8) != 0)
              {
                ++v119[5 * v144[1] + 3];
              }
            }
          }
          else
          {
            if (v119[5 * v144[1]])
            {
              ++v119[5 * v144[1] + 2];
              v145 = v144[1];
            }
            v119[5 * v145 + 1] = v142 + 1;
          }
          ++v119[5 * v144[1]];
          ++v142;
        }
        while (v131 - 1 != v142);
      }
      if (!*(_WORD *)(v138 + 2 * ((int)v131 - 1)) && (int)v128 <= (int)v131)
        --v119[2];
LABEL_183:
      if ((v116 & 1) == 0 && (_DWORD)v105 == 2 && *((_BYTE *)this + 14))
      {
        v116 = v119[4] || v119[9] || v119[2] || v119[7] != 0;
        if (v171 == 3)
        {
          v148 = *v119;
          if (v148 != 1)
            LOBYTE(v148) = v119[5] == 1;
          v116 |= v148;
        }
        if ((v119[3] != 0) != (v119[8] != 0))
          v149 = 48;
        else
          v149 = 8;
      }
      else
      {
        if (!(_DWORD)v105)
          goto LABEL_234;
        v149 = 8;
      }
      v150 = (_BYTE *)(v174 + v175);
      v151 = 2;
      while (1)
      {
        *v150 = 1;
        if (v119[2])
        {
          *v150 = 5;
          goto LABEL_202;
        }
        if ((v116 & 1) != 0 || v119[4])
          break;
        v158 = *v119;
        v153 = v158 == 1;
        v159 = v158 == 1 && v171 != 0;
        v156 = 3;
        if (v158 == a2)
          v154 = 1;
        else
          v154 = 3;
        if (v159)
          goto LABEL_209;
        v155 = 0;
LABEL_210:
        if (v153)
          v154 = v156;
        *v150 = v154;
        v157 = v154 | ((v119[4] != 0) << 6);
        *v150 = v157;
        if (v119[4])
        {
          LOBYTE(v157) = v157 | ((*v119 - v119[4] > 1) << 7);
          *v150 = v157;
          if ((v155 & 1) == 0)
            goto LABEL_226;
        }
        else
        {
          if (!v155)
          {
            v157 = v157 & 0xFFFFFF7F | (((v154 >> 1) & 1) << 7);
            *v150 = v157;
LABEL_226:
            if (v119[3] | v115 & 0x20)
              v160 = 16;
            else
              v160 = v149;
            *v150 = v160 | v157;
            if (!*((_BYTE *)this + 13))
            {
              v161 = *(int *)(*((_QWORD *)this + 12) + 4 * v97);
              v162 = *((_QWORD *)this + 24);
              v163 = v162 + 4 * v161;
              v164 = v119[1];
              *(_WORD *)(v163 + v151 - 2) = v164;
              v165 = *v119 + v164;
              if (v151 == 2 && v164)
                *(_WORD *)(v162 + 4 * v161 + 2) = v165 + ~(_WORD)v102;
              else
                *(_WORD *)(v163 + v151) = v165 - 1;
            }
            goto LABEL_202;
          }
          *v150 = v157 | ((*v119 > 1u) << 7);
        }
LABEL_202:
        v151 += 4;
        ++v150;
        v119 += 5;
        if (!--v105)
        {
          v96 = *(_QWORD *)this;
          goto LABEL_234;
        }
      }
      v152 = *v119;
      v153 = v152 == 1;
      if (v152 == a2)
        v154 = 1;
      else
        v154 = 3;
LABEL_209:
      v155 = 1;
      v156 = 1;
      goto LABEL_210;
    }
    if (*((_BYTE *)this + 14))
    {
      v116 = v105 > 2;
      v118 = !v166;
      if (v105 > 2)
        v118 = 1;
      if ((v118 & 1) != 0)
        goto LABEL_137;
      if ((_DWORD)v105 != 1)
      {
        v116 = 0;
        goto LABEL_137;
      }
    }
    else
    {
      v116 = 0;
      if (v168 > 2 || (_DWORD)v105 != 1)
        goto LABEL_137;
    }
    v116 = (v115 & 4) == 0;
    goto LABEL_137;
  }
LABEL_237:
  operator delete(__p);
  operator delete(v187);
  operator delete(v192);
  operator delete(v197);
  if (v176)
    operator delete(v176);
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(_QWORD *this, int a2, unsigned int a3, int *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  unsigned int v20;

  v4 = *(int *)(*(_QWORD *)(*this + 264) + 8 * a2 + 4);
  v5 = *(_QWORD *)(*this + 288) + 4 * v4;
  v6 = *(_QWORD *)(*this + 312) + 2 * v4;
  v7 = (unsigned __int16 *)(this[24] + 4 * *(int *)(this[12] + 4 * a2) + 4 * a3);
  v8 = *v7;
  v9 = *(int *)(v5 + 4 * v8);
  v10 = v7[1];
  v11 = *(_QWORD *)(*this + 24);
  v12 = *(_DWORD *)(v11 + 8 * v9);
  v13 = *(int *)(v11 + 4 * (int)((2 * v9) | 1));
  v14 = this[3];
  v15 = *(int *)(v5 + 4 * v10);
  v16 = *(_DWORD *)(v11 + 8 * v15);
  v17 = v14 + 4 * *(int *)(v11 + 4 * (int)((2 * v15) | 1));
  v18 = *(unsigned __int16 *)(v6 + 2 * v8);
  v19 = *(unsigned __int16 *)(v6 + 2 * v10);
  if (!v19)
    v19 = v16;
  if (v12 - 1 == v18)
    v20 = 0;
  else
    v20 = v18 + 1;
  *a4 = *(_DWORD *)(v14 + 4 * v13 + 4 * v20);
  a4[1] = *(_DWORD *)(v17 + 4 * (v19 - 1));
  return this;
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::initializeFaceValuesFromVertexFaceSiblings(_QWORD *this)
{
  uint64_t v1;
  int *v2;
  unint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  unsigned __int16 *v15;
  unsigned __int16 *v16;
  int v17;
  int v18;
  int v19;

  v1 = *this;
  v2 = *(int **)(*this + 48);
  v3 = *(_QWORD *)(*this + 56) - (_QWORD)v2;
  if ((int)(v3 >> 2) >= 1)
  {
    v4 = this[12];
    v5 = (_DWORD *)this[3];
    v6 = (v3 >> 2);
    do
    {
      v7 = *v2++;
      *v5++ = *(_DWORD *)(v4 + 4 * v7);
      --v6;
    }
    while (v6);
  }
  v8 = *(_DWORD *)(v1 + 8);
  if (v8 >= 1)
  {
    v9 = 0;
    v10 = this[9];
    do
    {
      if (*(unsigned __int16 *)(v10 + 2 * v9) >= 2u)
      {
        v11 = (unsigned int *)(*(_QWORD *)(v1 + 264) + 8 * v9);
        v12 = *v11;
        if ((int)v12 >= 1)
        {
          v13 = (int)v11[1];
          v14 = (int *)(*(_QWORD *)(v1 + 288) + 4 * v13);
          v15 = (unsigned __int16 *)(*(_QWORD *)(v1 + 312) + 2 * v13);
          v16 = (unsigned __int16 *)(this[15] + 2 * v13);
          do
          {
            v18 = *v16++;
            v17 = v18;
            if (v18)
            {
              v19 = *(_DWORD *)(*(_QWORD *)(v1 + 24) + 8 * *v14 + 4) + *v15;
              *(_DWORD *)(this[3] + 4 * v19) += v17;
            }
            ++v15;
            ++v14;
            --v12;
          }
          while (v12);
          v8 = *(_DWORD *)(v1 + 8);
        }
      }
      ++v9;
    }
    while (v9 < v8);
  }
  return this;
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues(_QWORD *this, int a2, int a3, int *a4)
{
  uint64_t v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;

  v4 = *this;
  v5 = (int *)(*(_QWORD *)(*this + 120) + 8 * a2);
  v6 = *v5;
  if (*(unsigned __int16 *)(this[9] + 2 * v5[1]) + *(unsigned __int16 *)(this[9] + 2 * v6) < 3)
  {
    if (*(int *)(v4 + 12) < 1)
    {
      v19 = this[12];
      v20 = this[18];
      *a4 = *(_DWORD *)(v20 + 4 * *(int *)(v19 + 4 * v6));
      v18 = *(_DWORD *)(v20 + 4 * *(int *)(v19 + 4 * v5[1]));
    }
    else
    {
      v17 = this[12];
      *a4 = *(_DWORD *)(v17 + 4 * v6);
      v18 = *(_DWORD *)(v17 + 4 * v5[1]);
    }
    a4[1] = v18;
  }
  else
  {
    v7 = *(int *)(*(_QWORD *)(v4 + 144) + ((8 * a2) | 4));
    v8 = *(int *)(*(_QWORD *)(v4 + 168) + 4 * v7 + 4 * a3);
    v9 = *(unsigned __int16 *)(*(_QWORD *)(v4 + 192) + 2 * v7 + 2 * a3);
    v10 = *(_QWORD *)(v4 + 24);
    v11 = *(_DWORD *)(v10 + 8 * v8);
    v12 = (2 * v8) | 1;
    v13 = this[3] + 4 * *(int *)(v10 + 4 * v12);
    v14 = *(_DWORD *)(v13 + 4 * v9);
    *a4 = v14;
    if ((int)v9 + 1 < v11)
      v15 = v9 + 1;
    else
      v15 = 0;
    v16 = *(_DWORD *)(v13 + 4 * v15);
    a4[1] = v16;
    if (*v5 != *(_DWORD *)(*(_QWORD *)(v4 + 48) + 4 * *(int *)(v10 + 4 * v12) + 4 * v9))
    {
      *a4 = v16;
      a4[1] = v14;
    }
  }
  return this;
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexEdgeValues(_QWORD *this, int a2, int *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  int *v8;
  unsigned __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __int16 v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  unsigned __int16 *v21;
  int *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  int v45;
  unsigned int v46;
  unsigned int v47;

  v3 = *this;
  v4 = *(_QWORD *)(*this + 336);
  v5 = *(unsigned int *)(v4 + 8 * a2);
  if ((int)v5 >= 1)
  {
    v6 = (8 * ((unint64_t)(2 * a2) >> 1)) | 4;
    v7 = *(int *)(v4 + v6);
    v8 = (int *)(*(_QWORD *)(v3 + 360) + 4 * v7);
    v9 = (unsigned __int16 *)(*(_QWORD *)(v3 + 384) + 2 * v7);
    v10 = *(int *)(*(_QWORD *)(v3 + 264) + v6);
    v11 = *(_QWORD *)(v3 + 288) + 4 * v10;
    v12 = *(_QWORD *)(v3 + 312) + 2 * v10;
    v13 = *(_WORD *)(*(_QWORD *)(v3 + 432) + 2 * a2);
    v14 = *(_DWORD *)(v3 + 12);
    v15 = *(_QWORD *)(v3 + 120);
    v16 = (v5 - 1);
    v17 = v16 - 1;
    v18 = this[9];
    v19 = v16;
    v20 = (int *)v11;
    v21 = (unsigned __int16 *)v12;
    v22 = a3;
    do
    {
      v24 = *v8++;
      v23 = v24;
      v25 = v15 + 8 * v24;
      LODWORD(v24) = *v9++;
      v26 = *(int *)(v25 + 4 * ((_DWORD)v24 == 0));
      if (*(_WORD *)(v18 + 2 * v26) == 1)
      {
        v27 = (int *)(this[12] + 4 * v26);
        if (!v14)
          v27 = (int *)(this[18] + 4 * *v27);
        v28 = *v27;
      }
      else if ((v13 & 1) != 0)
      {
        v34 = *(int *)(*(_QWORD *)(v3 + 144) + 4 * ((2 * v23) | 1));
        v35 = *(int *)(*(_QWORD *)(v3 + 168) + 4 * v34);
        v36 = *(unsigned __int16 *)(*(_QWORD *)(v3 + 192) + 2 * v34);
        v37 = *(_QWORD *)(v3 + 24);
        v38 = *(int *)(v37 + 8 * v35 + 4);
        v39 = *(_QWORD *)(v3 + 48) + 4 * v38;
        v40 = this[3] + 4 * v38;
        if ((_DWORD)v26 == *(_DWORD *)(v39 + 4 * v36))
        {
          v28 = *(_DWORD *)(v40 + 4 * v36);
        }
        else
        {
          if (*(_DWORD *)(v37 + 8 * (_DWORD)v35) - 1 == (_DWORD)v36)
            v47 = 0;
          else
            v47 = v36 + 1;
          v28 = *(_DWORD *)(v40 + 4 * v47);
        }
      }
      else
      {
        if ((v13 & 4) != 0 && !v19)
        {
          v29 = *(int *)(v11 + 4 * v17);
          v30 = *(_QWORD *)(v3 + 24);
          v31 = *(_DWORD *)(v30 + 8 * v29);
          v32 = this[3] + 4 * *(int *)(v30 + 4 * (int)((2 * v29) | 1));
          v33 = *(unsigned __int16 *)(v12 + 2 * v17);
          if (!*(_WORD *)(v12 + 2 * v17))
            v33 = v31;
          a3[v16] = *(_DWORD *)(v32 + 4 * (v33 - 1));
          goto LABEL_24;
        }
        v41 = *v20;
        v42 = *(_QWORD *)(v3 + 24);
        v43 = *(_DWORD *)(v42 + 8 * v41);
        v44 = this[3] + 4 * *(int *)(v42 + 4 * (int)((2 * v41) | 1));
        v45 = *v21;
        if (v43 - 1 == v45)
          v46 = 0;
        else
          v46 = v45 + 1;
        v28 = *(_DWORD *)(v44 + 4 * v46);
      }
      *v22 = v28;
LABEL_24:
      ++v22;
      ++v21;
      ++v20;
      --v19;
      --v5;
    }
    while (v5);
  }
  return this;
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getFaceValueTags(_QWORD *result, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int *v11;
  int v12;

  v3 = *(_QWORD *)(*result + 24);
  v4 = *(unsigned int *)(v3 + 8 * a2);
  if ((int)v4 >= 1)
  {
    v5 = 0;
    v6 = *(int *)(v3 + 8 * a2 + 4);
    v7 = result[3] + 4 * v6;
    v8 = *(_QWORD *)(*result + 48) + 4 * v6;
    do
    {
      v9 = *(_DWORD *)(v7 + 4 * v5);
      if (*(int *)(*result + 12) <= 0)
      {
        v10 = *(int *)(result[12] + 4 * *(int *)(v8 + 4 * v5));
        v9 = v10 - 1;
        v11 = (int *)(result[18] + 4 * v10);
        do
        {
          v12 = *v11++;
          ++v9;
        }
        while (v12 != *(_DWORD *)(v7 + 4 * v5));
      }
      *(_BYTE *)(a3 + v5++) = *(_BYTE *)(result[21] + v9);
    }
    while (v5 != v4);
  }
  return result;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getFaceCompositeValueTag(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *this, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  int *v13;
  int v14;

  v2 = *(_QWORD *)this;
  v3 = *(_QWORD *)(*(_QWORD *)this + 24);
  v4 = *(unsigned int *)(v3 + 8 * a2);
  if ((int)v4 < 1)
    return 0;
  v5 = 0;
  LODWORD(v6) = 0;
  v7 = *(int *)(v3 + 8 * a2 + 4);
  v8 = *((_QWORD *)this + 3) + 4 * v7;
  v9 = *(_QWORD *)(v2 + 48) + 4 * v7;
  v10 = *(_DWORD *)(v2 + 12);
  do
  {
    v11 = *(_DWORD *)(v8 + 4 * v5);
    if (v10 <= 0)
    {
      v12 = *(int *)(*((_QWORD *)this + 12) + 4 * *(int *)(v9 + 4 * v5));
      v11 = v12 - 1;
      v13 = (int *)(*((_QWORD *)this + 18) + 4 * v12);
      do
      {
        v14 = *v13++;
        ++v11;
      }
      while (v14 != *(_DWORD *)(v8 + 4 * v5));
    }
    v6 = *(unsigned __int8 *)(*((_QWORD *)this + 21) + v11) | v6;
    ++v5;
  }
  while (v5 != v4);
  return v6;
}

void std::vector<unsigned short>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  __int16 v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 1)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 2 * a2);
      v7 += 2 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 1);
    if (v10 < 0)
      abort();
    v11 = v9 >> 1;
    v12 = v5 - v8;
    if (v12 > v10)
      v10 = v12;
    if (v12 >= 0x7FFFFFFFFFFFFFFELL)
      v13 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[2 * v11];
    v16 = &v14[2 * v13];
    bzero(v15, 2 * a2);
    v17 = &v15[2 * a2];
    while (v7 != v8)
    {
      v18 = *((_WORD *)v7 - 1);
      v7 -= 2;
      *((_WORD *)v15 - 1) = v18;
      v15 -= 2;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(2 * a2);
}

void std::vector<OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::ETag>::__append(_QWORD *a1, unint64_t a2, _BYTE *a3)
{
  unint64_t v4;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  unint64_t v9;
  unint64_t v10;
  size_t v11;
  void *v12;
  _BYTE *v13;
  char *v14;
  char *v15;
  _BYTE *v16;
  _BYTE *v17;
  char v18;

  v4 = a2;
  v7 = (_BYTE *)a1[1];
  v6 = a1[2];
  if (v6 - (uint64_t)v7 >= a2)
  {
    if (a2)
    {
      v13 = &v7[a2];
      do
      {
        *v7++ = *a3;
        --v4;
      }
      while (v4);
      v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = &v7[-*a1];
    v9 = (unint64_t)&v8[a2];
    if ((uint64_t)&v8[a2] < 0)
      abort();
    v10 = v6 - *a1;
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
      v12 = operator new(v11);
    else
      v12 = 0;
    v14 = &v8[(_QWORD)v12];
    v15 = &v8[(_QWORD)v12 + v4];
    v16 = &v8[(_QWORD)v12];
    do
    {
      *v16++ = *a3;
      --v4;
    }
    while (v4);
    v17 = (_BYTE *)*a1;
    if (v7 != (_BYTE *)*a1)
    {
      do
      {
        v18 = *--v7;
        *--v14 = v18;
      }
      while (v7 != v17);
      v7 = (_BYTE *)*a1;
    }
    *a1 = v14;
    a1[1] = v15;
    a1[2] = (char *)v12 + v11;
    if (v7)
      operator delete(v7);
  }
}

void std::vector<unsigned short>::__append(void **a1, unint64_t a2, _WORD *a3)
{
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  _WORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  _WORD *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *i;
  __int16 v25;

  v8 = a1[2];
  v6 = (uint64_t)(a1 + 2);
  v7 = v8;
  v9 = *(_WORD **)(v6 - 8);
  if (a2 <= (v8 - (_BYTE *)v9) >> 1)
  {
    if (a2)
    {
      v16 = 2 * a2;
      v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 2;
      }
      while (v16);
      v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    v10 = (char *)v9 - (_BYTE *)*a1;
    v11 = a2 + (v10 >> 1);
    if (v11 < 0)
      abort();
    v12 = v10 >> 1;
    v13 = v7 - (_BYTE *)*a1;
    if (v13 > v11)
      v11 = v13;
    if (v13 >= 0x7FFFFFFFFFFFFFFELL)
      v14 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v14 = v11;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v6, v14);
    else
      v15 = 0;
    v18 = &v15[2 * v12];
    v19 = &v18[2 * a2];
    v20 = 2 * a2;
    v21 = v18;
    do
    {
      *(_WORD *)v21 = *a3;
      v21 += 2;
      v20 -= 2;
    }
    while (v20);
    v22 = &v15[2 * v14];
    v23 = (char *)*a1;
    for (i = (char *)a1[1]; i != v23; i -= 2)
    {
      v25 = *((_WORD *)i - 1);
      *((_WORD *)v18 - 1) = v25;
      v18 -= 2;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
      operator delete(v23);
  }
}

void std::vector<OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::CreaseEndPair>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  int v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 2);
    if (v9 >> 62)
      abort();
    v10 = v8 >> 2;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 1 > v9)
      v9 = v11 >> 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL)
      v12 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[4 * v10];
    v15 = &v13[4 * v12];
    bzero(v14, 4 * a2);
    v16 = &v14[4 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_DWORD *)v17 - 1);
        v17 -= 4;
        *((_DWORD *)v14 - 1) = v19;
        v14 -= 4;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void OpenSubdiv::v3_1_1::Sdc::staticTraitsTable(OpenSubdiv::v3_1_1::Sdc *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0)
  {
    {
      OpenSubdiv::v3_1_1::Sdc::staticTraitsTable(void)::staticTraitsTable = (uint64_t)"bilinear";
      *(_OWORD *)algn_25582AFB0 = xmmword_22619CD90;
      qword_25582AFC0 = (uint64_t)"catmark";
      xmmword_25582AFC8 = xmmword_22619CDA0;
      qword_25582AFD8 = (uint64_t)"loop";
      unk_25582AFE0 = xmmword_22619CDB0;
    }
  }
}

uint64_t OpenSubdiv::v3_1_1::Far::StencilTable::StencilTable(uint64_t a1, int a2, uint64_t *a3, _QWORD *a4, _QWORD *a5, _QWORD *a6, int a7, unint64_t a8)
{
  *(_QWORD *)a1 = &off_24ED89DD0;
  *(_DWORD *)(a1 + 8) = a2;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
    0,
    0);
  return a1;
}

void OpenSubdiv::v3_1_1::Far::`anonymous namespace'::copyStencilData(int a1, int a2, unint64_t a3, uint64_t *a4, std::vector<int> *this, _QWORD *a6, std::vector<int> *a7, _QWORD *a8, std::vector<int> *a9, _QWORD *a10, _QWORD *a11, _QWORD *a12, _QWORD *a13, _QWORD *a14, _QWORD *a15, _QWORD *a16, _QWORD *a17, _QWORD *a18, _QWORD *a19, _QWORD *a20,_QWORD *a21)
{
  unint64_t v24;
  uint64_t v25;
  std::vector<int>::size_type v26;
  std::vector<int>::size_type v27;
  int v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int8 v33;
  _QWORD *v35;
  _QWORD *v36;
  std::vector<int> *v39;

  v33 = a2;
  if (a2)
    v24 = 0;
  else
    v24 = a3;
  std::vector<unsigned int>::resize(this, (a4[1] - *a4) >> 2);
  v35 = a6;
  v39 = a7;
  std::vector<unsigned int>::resize(a7, (uint64_t)(a6[1] - *a6) >> 2);
  v36 = a8;
  std::vector<unsigned int>::resize(a9, (uint64_t)(a8[1] - *a8) >> 2);
  std::vector<float>::resize((uint64_t)a11, (uint64_t)(a10[1] - *a10) >> 2);
  if (a13)
    std::vector<float>::resize((uint64_t)a13, (uint64_t)(a12[1] - *a12) >> 2);
  if (a15)
    std::vector<float>::resize((uint64_t)a15, (uint64_t)(a14[1] - *a14) >> 2);
  if (a17)
    std::vector<float>::resize((uint64_t)a17, (uint64_t)(a16[1] - *a16) >> 2);
  if (a19)
    std::vector<float>::resize((uint64_t)a19, (uint64_t)(a18[1] - *a18) >> 2);
  if (a21)
    std::vector<float>::resize((uint64_t)a21, (uint64_t)(a20[1] - *a20) >> 2);
  v25 = *a4;
  if (v24 >= (a4[1] - *a4) >> 2)
  {
    v27 = 0;
    v26 = 0;
  }
  else
  {
    v26 = 0;
    v27 = 0;
    v28 = 0;
    do
    {
      if ((((_DWORD)v24 == a1) & v33) != 0)
        v29 = a3;
      else
        v29 = v24;
      v30 = *(int *)(*v35 + 4 * v29);
      v31 = *(int *)(v25 + 4 * v29);
      this->__begin_[v27] = v28;
      v39->__begin_[v27] = v30;
      memcpy(&a9->__begin_[v28], (const void *)(*v36 + 4 * v31), 4 * v30);
      memcpy((void *)(*a11 + 4 * v28), (const void *)(*a10 + 4 * v31), 4 * v30);
      if (a13 && *a13 != a13[1])
        memcpy((void *)(*a13 + 4 * v28), (const void *)(*a12 + 4 * v31), 4 * v30);
      if (a15 && *a15 != a15[1])
        memcpy((void *)(*a15 + 4 * v28), (const void *)(*a14 + 4 * v31), 4 * v30);
      if (a17 && *a17 != a17[1])
        memcpy((void *)(*a17 + 4 * v28), (const void *)(*a16 + 4 * v31), 4 * v30);
      if (a19 && *a19 != a19[1])
        memcpy((void *)(*a19 + 4 * v28), (const void *)(*a18 + 4 * v31), 4 * v30);
      if (a21 && *a21 != a21[1])
        memcpy((void *)(*a21 + 4 * v28), (const void *)(*a20 + 4 * v31), 4 * v30);
      v28 += v30;
      ++v27;
      v26 += v30;
      v24 = v29 + 1;
      v25 = *a4;
    }
    while (v29 + 1 < (a4[1] - *a4) >> 2);
  }
  std::vector<unsigned int>::resize(this, v27);
  std::vector<unsigned int>::resize(v39, v27);
  std::vector<unsigned int>::resize(a9, v26);
  if (a13 && *a13 != a13[1])
    std::vector<float>::resize((uint64_t)a13, v26);
  if (a15 && *a15 != a15[1])
    std::vector<float>::resize((uint64_t)a15, v26);
  if (a17 && *a17 != a17[1])
    std::vector<float>::resize((uint64_t)a17, v26);
  if (a19 && *a19 != a19[1])
    std::vector<float>::resize((uint64_t)a19, v26);
  if (a21)
  {
    if (*a21 != a21[1])
      std::vector<float>::resize((uint64_t)a21, v26);
  }
}

void OpenSubdiv::v3_1_1::Far::StencilTable::~StencilTable(OpenSubdiv::v3_1_1::Far::StencilTable *this)
{
  OpenSubdiv::v3_1_1::Far::StencilTable::~StencilTable(this);
  JUMPOUT(0x2276933B8);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  *(_QWORD *)this = &off_24ED89DD0;
  v2 = (void *)*((_QWORD *)this + 11);
  if (v2)
  {
    *((_QWORD *)this + 12) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 8);
  if (v3)
  {
    *((_QWORD *)this + 9) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 5);
  if (v4)
  {
    *((_QWORD *)this + 6) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 2);
  if (v5)
  {
    *((_QWORD *)this + 3) = v5;
    operator delete(v5);
  }
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 4 * a2;
  }
  else
  {
    std::vector<float>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<float>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  int v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 2);
    if (v10 >> 62)
      abort();
    v11 = v9 >> 2;
    v12 = v5 - v8;
    if (v12 >> 1 > v10)
      v10 = v12 >> 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
      v13 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[4 * v11];
    v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void OpenSubdiv::v3_1_1::Far::internal::StencilBuilder::~StencilBuilder(OpenSubdiv::v3_1_1::Far::internal::WeightTable **this)
{
  OpenSubdiv::v3_1_1::Far::internal::WeightTable *v1;

  v1 = *this;
  if (v1)
  {
    OpenSubdiv::v3_1_1::Far::internal::WeightTable::~WeightTable(v1);
    MEMORY[0x2276933B8]();
  }
}

void OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>(uint64_t a1, int a2, int a3, _QWORD *a4, float a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (*(_DWORD *)(a1 + 248) <= a2)
  {
    v9 = *(int *)(*(_QWORD *)(a1 + 216) + 4 * a2);
    if ((int)v9 >= 1)
    {
      v10 = *(int *)(*(_QWORD *)(a1 + 192) + 4 * a2);
      v11 = v10 + v9;
      do
      {
        OpenSubdiv::v3_1_1::Far::internal::WeightTable::merge<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>(a1, *(_DWORD *)(*(_QWORD *)(a1 + 24) + 4 * v10), a3, *(_DWORD *)(a1 + 244), *(_DWORD *)(a1 + 240), a4, *(float *)(a4[6] + 4 * v10), a5);
        ++v10;
      }
      while (v10 < v11);
    }
  }
  else
  {
    OpenSubdiv::v3_1_1::Far::internal::WeightTable::merge<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>(a1, a2, a3, *(_DWORD *)(a1 + 244), *(_DWORD *)(a1 + 240), a4, a5, 1.0);
  }
}

void OpenSubdiv::v3_1_1::Far::internal::StencilBuilder::Index::AddWithWeight(_QWORD ***a1, unsigned int **a2, float a3)
{
  uint64_t v3;
  int *v6;
  float *v7;

  if (a3 != 0.0)
  {
    v3 = **a2;
    if ((int)v3 >= 1)
    {
      v6 = (int *)a2[1];
      v7 = (float *)a2[2];
      do
      {
        if (*v7 != 0.0)
          OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)**a1, *v6, *((_DWORD *)a1 + 2), **a1, *v7 * a3);
        ++v6;
        ++v7;
        --v3;
      }
      while (v3);
    }
  }
}

OpenSubdiv::v3_1_1::Far::internal::WeightTable *OpenSubdiv::v3_1_1::Far::internal::WeightTable::WeightTable(OpenSubdiv::v3_1_1::Far::internal::WeightTable *this, int a2, int a3, char a4)
{
  void **v7;
  std::vector<int> *v8;
  int v9;
  std::vector<int> *v10;
  std::vector<int>::size_type v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;

  *((_OWORD *)this + 3) = 0u;
  v7 = (void **)((char *)this + 48);
  *((_OWORD *)this + 12) = 0u;
  v8 = (std::vector<int> *)((char *)this + 192);
  *((_QWORD *)this + 30) = 0;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  v9 = 2 * a2;
  if (a2 >= 2621440)
    v9 = 5242880;
  v10 = (std::vector<int> *)((char *)this + 24);
  *((_OWORD *)this + 8) = 0uLL;
  *((_OWORD *)this + 9) = 0uLL;
  *((_OWORD *)this + 6) = 0uLL;
  *((_OWORD *)this + 7) = 0uLL;
  *((_OWORD *)this + 4) = 0uLL;
  *((_OWORD *)this + 5) = 0uLL;
  *((_OWORD *)this + 1) = 0uLL;
  *((_OWORD *)this + 2) = 0uLL;
  *(_OWORD *)this = 0uLL;
  *((_DWORD *)this + 62) = a2;
  if (v9 <= a2)
    v9 = a2;
  v11 = v9;
  *((_BYTE *)this + 252) = a4;
  std::vector<int>::reserve((std::vector<int> *)this, v9);
  std::vector<int>::reserve(v10, v11);
  std::vector<float>::reserve(v7, v11);
  if (a3)
  {
    std::vector<unsigned int>::resize(v10, a2);
    std::vector<float>::resize((uint64_t)v7, a2);
    std::vector<unsigned int>::resize((std::vector<int> *)this, a2);
    std::vector<unsigned int>::resize(v8, a2);
    std::vector<unsigned int>::resize((std::vector<int> *)this + 9, a2);
    v12 = *((_QWORD *)this + 3);
    if (a2 >= 1)
    {
      v13 = 0;
      v14 = *((_QWORD *)this + 24);
      v15 = *((_QWORD *)this + 27);
      v16 = *(_QWORD *)this;
      v17 = *((_QWORD *)this + 6);
      do
      {
        *(_DWORD *)(v14 + 4 * v13) = v13;
        *(_DWORD *)(v15 + 4 * v13) = 1;
        *(_DWORD *)(v16 + 4 * v13) = v13;
        *(_DWORD *)(v12 + 4 * v13) = v13;
        *(_DWORD *)(v17 + 4 * v13++) = 1065353216;
      }
      while (a2 != v13);
    }
    v18 = (unint64_t)(*((_QWORD *)this + 4) - v12) >> 2;
    *((_DWORD *)this + 60) = v18;
    *((_DWORD *)this + 61) = v18 - 1;
  }
  return this;
}

void std::vector<int>::reserve(std::vector<int> *this, std::vector<int>::size_type __n)
{
  std::__compressed_pair<int *> *p_end_cap;
  int *value;
  int64_t v5;
  char *v6;
  int *v7;
  uint64_t v8;
  int *v9;
  std::vector<int>::pointer begin;
  int *end;
  int *v12;
  int v13;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (__n > value - this->__begin_)
  {
    if (__n >> 62)
      abort();
    v5 = (char *)this->__end_ - (char *)this->__begin_;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)p_end_cap, __n);
    v7 = (int *)&v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    v9 = (int *)&v6[4 * v8];
    begin = this->__begin_;
    end = this->__end_;
    v12 = v7;
    if (end != this->__begin_)
    {
      v12 = v7;
      do
      {
        v13 = *--end;
        *--v12 = v13;
      }
      while (end != begin);
    }
    this->__begin_ = v12;
    this->__end_ = v7;
    this->__end_cap_.__value_ = v9;
    if (begin)
      operator delete(begin);
  }
}

void OpenSubdiv::v3_1_1::Far::internal::WeightTable::~WeightTable(OpenSubdiv::v3_1_1::Far::internal::WeightTable *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;

  v2 = (void *)*((_QWORD *)this + 27);
  if (v2)
  {
    *((_QWORD *)this + 28) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 24);
  if (v3)
  {
    *((_QWORD *)this + 25) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 21);
  if (v4)
  {
    *((_QWORD *)this + 22) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 18);
  if (v5)
  {
    *((_QWORD *)this + 19) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 15);
  if (v6)
  {
    *((_QWORD *)this + 16) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 12);
  if (v7)
  {
    *((_QWORD *)this + 13) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 9);
  if (v8)
  {
    *((_QWORD *)this + 10) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 6);
  if (v9)
  {
    *((_QWORD *)this + 7) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 3);
  if (v10)
  {
    *((_QWORD *)this + 4) = v10;
    operator delete(v10);
  }
  v11 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v11;
    operator delete(v11);
  }
}

float OpenSubdiv::v3_1_1::Far::internal::WeightTable::merge<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>(uint64_t a1, int a2, int a3, int a4, int a5, _QWORD *a6, float a7, float a8)
{
  uint64_t v8;
  float result;
  uint64_t v10;

  if (*(_BYTE *)(a1 + 252)
    && *(_QWORD *)a1 != *(_QWORD *)(a1 + 8)
    && a4 < a5
    && *(_DWORD *)(*(_QWORD *)a1 + 4 * a4) == a3)
  {
    v8 = a4;
    while (*(_DWORD *)(*(_QWORD *)(a1 + 24) + 4 * v8) != a2)
    {
      if (a5 == ++v8)
        goto LABEL_8;
    }
    v10 = a6[6];
    result = (float)(a7 * a8) + *(float *)(v10 + 4 * v8);
    *(float *)(v10 + 4 * v8) = result;
  }
  else
  {
LABEL_8:
    OpenSubdiv::v3_1_1::Far::internal::WeightTable::add<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>(a1, a2, a3, a6, a7 * a8);
  }
  return result;
}

void OpenSubdiv::v3_1_1::Far::internal::WeightTable::add<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>(uint64_t a1, int a2, int a3, _QWORD *a4, float a5)
{
  int *v10;
  uint64_t v11;
  uint64_t v12;
  std::vector<int> *v13;
  uint64_t v14;
  std::vector<int>::size_type v15;
  uint64_t v16;
  unint64_t v17;
  _DWORD *v18;
  int *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  int *v26;
  char *v27;
  int v28;
  unint64_t v29;
  char *v30;
  _DWORD *v31;
  char *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  char *v38;
  char *v39;
  int v40;
  unint64_t v41;
  float *v42;
  float *v43;
  float *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  float *v50;
  char *v51;
  int v52;

  v10 = *(int **)(a1 + 8);
  if (*(int **)a1 == v10 || *(v10 - 1) != a3)
  {
    v14 = *(_QWORD *)(a1 + 192);
    v13 = (std::vector<int> *)(a1 + 192);
    if ((int)((unint64_t)(*(_QWORD *)(a1 + 200) - v14) >> 2) <= a3)
    {
      v15 = a3 + 1;
      std::vector<unsigned int>::resize(v13, v15);
      std::vector<unsigned int>::resize((std::vector<int> *)(a1 + 216), v15);
      v14 = *(_QWORD *)(a1 + 192);
      v10 = *(int **)(a1 + 8);
    }
    v16 = (*(_QWORD *)(a1 + 32) - *(_QWORD *)(a1 + 24)) >> 2;
    v12 = a3;
    *(_DWORD *)(v14 + 4 * a3) = v16;
    v11 = *(_QWORD *)(a1 + 216);
    *(_DWORD *)(v11 + 4 * a3) = 0;
    *(_DWORD *)(a1 + 244) = v16;
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 216);
    v12 = a3;
  }
  v17 = *(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 240);
  ++*(_DWORD *)(v11 + 4 * v12);
  if ((unint64_t)v10 >= v17)
  {
    v19 = *(int **)a1;
    v20 = ((uint64_t)v10 - *(_QWORD *)a1) >> 2;
    v21 = v20 + 1;
    if ((unint64_t)(v20 + 1) >> 62)
      goto LABEL_56;
    v22 = v17 - (_QWORD)v19;
    v23 = (uint64_t)(v17 - (_QWORD)v19) >> 1;
    if (v23 > v21)
      v21 = v23;
    if (v22 >= 0x7FFFFFFFFFFFFFFCLL)
      v24 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v24 = v21;
    if (v24)
    {
      v25 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(a1 + 16, v24);
      v19 = *(int **)a1;
      v10 = *(int **)(a1 + 8);
    }
    else
    {
      v25 = 0;
    }
    v26 = (int *)&v25[4 * v20];
    v27 = &v25[4 * v24];
    *v26 = a3;
    v18 = v26 + 1;
    while (v10 != v19)
    {
      v28 = *--v10;
      *--v26 = v28;
    }
    *(_QWORD *)a1 = v26;
    *(_QWORD *)(a1 + 8) = v18;
    *(_QWORD *)(a1 + 16) = v27;
    if (v19)
      operator delete(v19);
  }
  else
  {
    *v10 = a3;
    v18 = v10 + 1;
  }
  v29 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 8) = v18;
  v30 = *(char **)(a1 + 32);
  if ((unint64_t)v30 >= v29)
  {
    v32 = *(char **)(a1 + 24);
    v33 = (v30 - v32) >> 2;
    v34 = v33 + 1;
    if ((unint64_t)(v33 + 1) >> 62)
      goto LABEL_56;
    v35 = v29 - (_QWORD)v32;
    if (v35 >> 1 > v34)
      v34 = v35 >> 1;
    if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFFCLL)
      v36 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v36 = v34;
    if (v36)
    {
      v37 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(a1 + 40, v36);
      v32 = *(char **)(a1 + 24);
      v30 = *(char **)(a1 + 32);
    }
    else
    {
      v37 = 0;
    }
    v38 = &v37[4 * v33];
    v39 = &v37[4 * v36];
    *(_DWORD *)v38 = a2;
    v31 = v38 + 4;
    while (v30 != v32)
    {
      v40 = *((_DWORD *)v30 - 1);
      v30 -= 4;
      *((_DWORD *)v38 - 1) = v40;
      v38 -= 4;
    }
    *(_QWORD *)(a1 + 24) = v38;
    *(_QWORD *)(a1 + 32) = v31;
    *(_QWORD *)(a1 + 40) = v39;
    if (v32)
      operator delete(v32);
  }
  else
  {
    *(_DWORD *)v30 = a2;
    v31 = v30 + 4;
  }
  *(_QWORD *)(a1 + 32) = v31;
  v41 = a4[8];
  v42 = (float *)a4[7];
  if ((unint64_t)v42 < v41)
  {
    *v42 = a5;
    v43 = v42 + 1;
    goto LABEL_55;
  }
  v44 = (float *)a4[6];
  v45 = v42 - v44;
  v46 = v45 + 1;
  if ((unint64_t)(v45 + 1) >> 62)
LABEL_56:
    abort();
  v47 = v41 - (_QWORD)v44;
  if (v47 >> 1 > v46)
    v46 = v47 >> 1;
  if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL)
    v48 = 0x3FFFFFFFFFFFFFFFLL;
  else
    v48 = v46;
  if (v48)
  {
    v49 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)(a4 + 8), v48);
    v44 = (float *)a4[6];
    v42 = (float *)a4[7];
  }
  else
  {
    v49 = 0;
  }
  v50 = (float *)&v49[4 * v45];
  v51 = &v49[4 * v48];
  *v50 = a5;
  v43 = v50 + 1;
  while (v42 != v44)
  {
    v52 = *((_DWORD *)v42-- - 1);
    *((_DWORD *)v50-- - 1) = v52;
  }
  a4[6] = v50;
  a4[7] = v43;
  a4[8] = v51;
  if (v44)
    operator delete(v44);
LABEL_55:
  a4[7] = v43;
}

uint64_t OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::BuilderContext(uint64_t a1, int *a2, uint64_t a3, uint64_t a4)
{
  std::vector<int> *v5;
  uint64_t v6;
  const void *v7;
  char *v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  OpenSubdiv::v3_1_1::Far::PtexIndices::initializePtexIndices((OpenSubdiv::v3_1_1::Sdc *)(a1 + 32), a2);
  *(_QWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_BYTE *)(a1 + 24) = 1;
  if ((*(_BYTE *)(a1 + 9) & 0x10) != 0)
  {
    v5 = (std::vector<int> *)(a1 + 144);
    v6 = *(int *)(a1 + 12);
    if ((_DWORD)v6 == -1)
    {
      std::vector<unsigned int>::resize(v5, (int)((uint64_t)(*(_QWORD *)(**(_QWORD **)(*(_QWORD *)a1 + 40) + 464)- *(_QWORD *)(**(_QWORD **)(*(_QWORD *)a1 + 40) + 456)) >> 3));
      v10 = *(_QWORD *)(a1 + 144);
      v11 = *(_QWORD *)(a1 + 152) - v10;
      if ((int)(v11 >> 2) >= 1)
      {
        v12 = 0;
        v13 = (v11 >> 2);
        do
        {
          *(_DWORD *)(v10 + 4 * v12) = v12;
          ++v12;
        }
        while (v13 != v12);
      }
    }
    else
    {
      if ((_DWORD)v6)
      {
        if ((v6 & 0x80000000) != 0)
          abort();
        v7 = *(const void **)(a1 + 16);
        std::vector<float>::__vallocate[abi:nn180100](v5, *(int *)(a1 + 12));
        v9 = (_QWORD *)(a1 + 152);
        v8 = *(char **)(a1 + 152);
        memmove(v8, v7, 4 * v6);
      }
      else
      {
        v8 = 0;
        v9 = (_QWORD *)(a1 + 152);
      }
      *v9 = &v8[4 * v6];
    }
  }
  return a1;
}

OpenSubdiv::v3_1_1::Vtr::internal::Level *OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GatherRegularPatchPoints(_QWORD *a1, uint64_t a2, int a3, int a4, int a5, unsigned int a6)
{
  OpenSubdiv::v3_1_1::Vtr::internal::Level *result;
  _QWORD *v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int32x4_t v21;
  int v22[16];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  result = *(OpenSubdiv::v3_1_1::Vtr::internal::Level **)(*(_QWORD *)(*a1 + 40) + 8 * a4);
  if ((a6 & 0x80000000) != 0)
  {
    v10 = a1 + 12;
    v11 = -1;
  }
  else
  {
    v10 = (_QWORD *)(a1[15] + 24 * a6);
    v11 = *(_DWORD *)(a1[18] + 4 * a6);
  }
  v12 = *(_DWORD *)(*v10 + 4 * a4);
  if (!a5)
    goto LABEL_8;
  v13 = OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GatherRegularPatchPoints(int *,OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::PatchTuple const&,int,int)const::boundaryEdgeMaskToType[a5];
  v14 = OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GatherRegularPatchPoints(int *,OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::PatchTuple const&,int,int)const::boundaryEdgeMaskToFeature[a5];
  switch(v13)
  {
    case 2:
      v15 = (char *)&OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GatherRegularPatchPoints(int *,OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::PatchTuple const&,int,int)const::permuteCorner
          + 64 * v14;
      result = (OpenSubdiv::v3_1_1::Vtr::internal::Level *)OpenSubdiv::v3_1_1::Vtr::internal::Level::gatherQuadRegularCornerPatchPoints(result, a3, v22, v14, v11);
      goto LABEL_11;
    case 1:
      v15 = (char *)&OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GatherRegularPatchPoints(int *,OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::PatchTuple const&,int,int)const::permuteBoundary
          + 64 * v14;
      result = (OpenSubdiv::v3_1_1::Vtr::internal::Level *)OpenSubdiv::v3_1_1::Vtr::internal::Level::gatherQuadRegularBoundaryPatchPoints(result, a3, v22, v14, v11);
LABEL_11:
      v16 = 0;
      v17 = v22[0];
      do
      {
        v18 = *(unsigned int *)&v15[v16];
        v19 = v17;
        if ((v18 & 0x80000000) == 0)
          v19 = v22[v18];
        *(_DWORD *)(a2 + v16) = v19 + v12;
        v16 += 4;
      }
      while (v16 != 64);
      return result;
    case 0:
LABEL_8:
      result = (OpenSubdiv::v3_1_1::Vtr::internal::Level *)OpenSubdiv::v3_1_1::Vtr::internal::Level::gatherQuadRegularInteriorPatchPoints(result, a3, v22, 0, v11);
      v15 = (char *)&OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GatherRegularPatchPoints(int *,OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::PatchTuple const&,int,int)const::permuteRegular;
      goto LABEL_11;
  }
  if (v12)
  {
    v20 = 0;
    v21 = vdupq_n_s32(v12);
    do
    {
      *(int32x4_t *)(a2 + v20 * 4) = vaddq_s32(*(int32x4_t *)&v22[v20], v21);
      v20 += 4;
    }
    while (v20 != 16);
  }
  return result;
}

BOOL OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::IsPatchRegular(OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext *this, int a2, int a3, unsigned int a4)
{
  OpenSubdiv::v3_1_1::Vtr::internal::Level *v7;
  uint64_t v8;
  unsigned int v9;
  __int16 FaceCompositeVTag;
  char v11;
  BOOL v12;
  char v13;
  unsigned int v14;
  uint64_t v15;
  __int16 v16;
  int v17;
  int16x8_t v18;
  unsigned __int32 v19;
  _BOOL8 result;
  char v22;
  _QWORD *v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  int16x4_t v29;
  uint8x8_t v30;
  int v31;
  int v32;
  int v33;
  int v35;
  int v36;
  __int16 v37;
  int8x8_t v38[2];

  v38[1] = *(int8x8_t *)MEMORY[0x24BDAC8D0];
  v7 = *(OpenSubdiv::v3_1_1::Vtr::internal::Level **)(*(_QWORD *)(*(_QWORD *)this + 40) + 8 * a2);
  if ((a4 & 0x80000000) != 0)
  {
    v9 = -1;
  }
  else
  {
    v8 = *(int *)(*((_QWORD *)this + 18) + 4 * a4);
    if ((OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getFaceCompositeValueTag(*(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*((_QWORD *)v7 + 57) + 8 * v8), a3) & 1) != 0)v9 = v8;
    else
      v9 = -1;
  }
  FaceCompositeVTag = OpenSubdiv::v3_1_1::Vtr::internal::Level::getFaceCompositeVTag(v7, a3, v9);
  v11 = FaceCompositeVTag;
  v12 = (FaceCompositeVTag & 2) == 0;
  v13 = v12 | FaceCompositeVTag;
  if ((*((_WORD *)this + 4) & 8) == 0 || (FaceCompositeVTag & 0x1010) == 0)
    goto LABEL_26;
  v14 = (FaceCompositeVTag & 0x4001) != 0x4000;
  if ((FaceCompositeVTag & 0x5001) == 0x5000)
  {
    OpenSubdiv::v3_1_1::Vtr::internal::Level::getFaceVTags(v7, a3, v38, v9);
    v15 = 0;
    v37 = 0;
    v36 = 0;
    while (1)
    {
      v16 = v38[0].i16[v15];
      if ((v16 & 0x4000) != 0)
      {
        v17 = (v16 & 0x2000) != 0 ? 2 : 1;
        if (v17 != (unsigned __int16)v36)
          break;
      }
      if (++v15 == 4)
      {
        v14 = 1;
        goto LABEL_18;
      }
    }
    v14 = 0;
  }
LABEL_18:
  v13 = v14 != 0;
  if (a2 <= 1 && (v11 & 2) != 0)
  {
    OpenSubdiv::v3_1_1::Vtr::internal::Level::getFaceVTags(v7, a3, v38, v9);
    v18 = vdupq_n_s16(v14);
    v19 = vmovn_s16(v18).u32[0];
    *(int8x8_t *)v18.i8 = vbic_s8(*(int8x8_t *)v18.i8, (int8x8_t)vceq_s16((int16x4_t)vand_s8(v38[0], (int8x8_t)vdup_n_s16(0x782u)), (int16x4_t)0x82008200820082));
    if (vmovn_s16(v18).u32[0] == v19 && v14 != 0)
      return 1;
  }
  else
  {
LABEL_26:
    if ((v13 & 1) != 0)
      return 1;
  }
  result = 0;
  if (*((_BYTE *)this + 24))
    v22 = v12;
  else
    v22 = 1;
  if ((v22 & 1) == 0 && (v11 & 4) != 0 && (v11 & 1) == 0)
  {
    v24 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)this + 40) + 8 * a2);
    if ((v9 & 0x80000000) != 0)
    {
      v26 = -1;
    }
    else
    {
      v25 = *(int *)(*((_QWORD *)this + 18) + 4 * v9);
      if ((OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getFaceCompositeValueTag(*(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(v24[57] + 8 * v25), a3) & 1) != 0)v26 = v25;
      else
        v26 = -1;
    }
    if (*(_DWORD *)(v24[3] + 8 * a3) != 4)
      return 0;
    OpenSubdiv::v3_1_1::Vtr::internal::Level::getFaceVTags(v24, a3, v38, v26);
    v27 = (*((_WORD *)this + 4) & 8) != 0 ? 6016 : 1924;
    v28 = (*((_WORD *)this + 4) & 8) != 0 ? 4608 : 516;
    v29 = (int16x4_t)vand_s8((int8x8_t)vceq_s16((int16x4_t)vand_s8((int8x8_t)vdup_n_s16(v27), v38[0]), vdup_n_s16(v28)), (int8x8_t)0x8000400020001);
    v29.i32[0] = vaddv_s16(v29) & 0xF;
    v30 = (uint8x8_t)vcnt_s8((int8x8_t)v29);
    v30.i16[0] = vaddlv_u8(v30);
    v31 = (v38[0].u16[0] >> 1) & 1;
    v32 = (v38[0].u16[1] >> 1) & 1;
    v33 = (v38[0].u16[2] >> 1) & 1;
    if (v30.i32[0] != 3 || v32 + v31 + v33 + ((v38[0].u16[3] >> 1) & 1) != 1)
      return 0;
    if (a2 <= 1)
    {
      if (v31)
      {
        v35 = v38[0].i16[2] & 0x780;
      }
      else if (v32)
      {
        v35 = v38[0].i16[3] & 0x780;
      }
      else if (v33)
      {
        v35 = v38[0].i16[0] & 0x780;
      }
      else
      {
        v35 = v38[0].i16[1] & 0x780;
      }
      return v35 == 128;
    }
    return 1;
  }
  return result;
}

uint64_t OpenSubdiv::v3_1_1::Far::`anonymous namespace'::identifyManifoldCornerSpan(_QWORD *a1, int a2, int a3, int a4, uint64_t a5, unsigned int a6)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t result;
  int v20;
  uint64_t v21;
  int v22;

  if ((a6 & 0x80000000) != 0)
    v6 = 0;
  else
    v6 = *(_QWORD *)(a1[57] + 8 * a6);
  v7 = 1;
  v8 = *(int *)(a1[3] + 4 * ((2 * a2) | 1));
  v9 = *(int *)(a1[6] + 4 * v8 + 4 * a3);
  v10 = 2 * v9;
  v11 = a1[42];
  v12 = a1[45] + 4 * *(int *)(v11 + 8 * v9 + 4);
  v13 = *(unsigned int *)(v11 + 4 * v10);
  if ((int)v13 < 1)
  {
LABEL_8:
    LODWORD(v14) = -1;
  }
  else
  {
    v14 = 0;
    v15 = *(_DWORD *)(a1[9] + 4 * v8 + 4 * a3);
    while (*(_DWORD *)(v12 + 4 * v14) != v15)
    {
      if (v13 == ++v14)
        goto LABEL_8;
    }
  }
  v16 = ((int)v14 + 1) % (int)v13;
  *(_DWORD *)(a5 + 2) = 0;
  *(_WORD *)a5 = 1;
  v17 = a1[30];
  v18 = v14;
  while (1)
  {
    result = *(int *)(v12 + 4 * v18);
    v20 = *(unsigned __int8 *)(v17 + result);
    if (v6)
    {
      result = *(unsigned __int8 *)(*(_QWORD *)(v6 + 48) + result);
      if ((result & 1) != 0)
        v20 |= 6u;
    }
    if ((v20 & a4) != 0)
      break;
    *(_WORD *)a5 = ++v7;
    v18 = ((int)v13 - 1 + v18) % (int)v13;
    if (v18 == v16)
    {
      v18 = ((int)v14 + 1) % (int)v13;
      goto LABEL_16;
    }
  }
  do
  {
LABEL_16:
    v21 = *(int *)(v12 + 4 * v16);
    v22 = *(unsigned __int8 *)(v17 + v21);
    if (v6)
    {
      result = v22 | 6u;
      if ((*(_BYTE *)(*(_QWORD *)(v6 + 48) + v21) & 1) != 0)
        v22 |= 6u;
    }
    if ((v22 & a4) != 0)
      break;
    *(_WORD *)a5 = ++v7;
    v16 = (v16 + 1) % (int)v13;
  }
  while (v16 != (_DWORD)v14);
  *(_WORD *)(a5 + 2) = v18;
  return result;
}

uint64_t OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GetRegularPatchBoundaryMask(OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext *this, int a2, int a3, unsigned int a4)
{
  _QWORD *v6;
  uint64_t v7;
  unsigned int v8;
  __int16 v9;
  unsigned __int32 v10;
  int8x8_t v11;
  int8x8_t v12;
  int32x2_t v13;
  int8x16_t v15;
  int v16;
  int8x8_t v17[2];

  v17[1] = *(int8x8_t *)MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)this + 40) + 8 * a2);
  if ((a4 & 0x80000000) != 0)
  {
    v8 = -1;
  }
  else
  {
    v7 = *(int *)(*((_QWORD *)this + 18) + 4 * a4);
    if ((OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getFaceCompositeValueTag(*(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(v6[57] + 8 * v7), a3) & 1) != 0)v8 = v7;
    else
      v8 = -1;
  }
  OpenSubdiv::v3_1_1::Vtr::internal::Level::getFaceVTags(v6, a3, v17, v8);
  v9 = v17[0].i16[0] | v17[0].i16[2] | ((v17[0].i32[0] | v17[0].i32[1]) >> 16);
  if ((v9 & 0x1000) == 0)
    goto LABEL_9;
  if ((*((_WORD *)this + 4) & 8) != 0)
  {
    v11 = vand_s8((int8x8_t)vshl_u16((uint16x4_t)v17[0], (uint16x4_t)0xFFF7FFF6FFF5FFF4), (int8x8_t)0x8000400020001);
    LOWORD(v10) = v11.i16[0] | v11.i16[2] | ((v11.i32[0] | v11.i32[1]) >> 16);
  }
  else
  {
    if ((v9 & 4) == 0)
    {
LABEL_9:
      LOWORD(v10) = 0;
      goto LABEL_12;
    }
    v12.i32[0] = v17[0].u16[1];
    v12.i32[1] = v17[0].u16[0];
    v13 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vand_s8(v12, (int8x8_t)0xFFFF0000FFFFLL), (uint32x2_t)0xFFFFFFFEFFFFFFFFLL), (int8x8_t)0x100000002);
    v10 = vorr_s8((int8x8_t)v13, (int8x8_t)vdup_lane_s32(v13, 1)).u32[0] | v17[0].i8[4] & 4 | (2 * v17[0].u16[3]) & 8;
  }
LABEL_12:
  v10 = (unsigned __int16)v10;
  if ((v9 & 1) != 0)
  {
    v15 = vbicq_s8(vbslq_s8((int8x16_t)vmovl_s16(vceqz_s16((int16x4_t)vand_s8(v17[0], (int8x8_t)0x10001000100010))), (int8x16_t)xmmword_22611E0A0, (int8x16_t)xmmword_22619CE00), (int8x16_t)vmovl_s16(vceqz_s16((int16x4_t)vand_s8(v17[0], (int8x8_t)0x1000100010001))));
    *(int8x8_t *)v15.i8 = vorr_s8(*(int8x8_t *)v15.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL));
    v10 = v15.i32[0] | (unsigned __int16)v10 | v15.i32[1];
    switch((__int16)v10)
    {
      case 1:
      case 4:
        v16 = 10;
        break;
      case 2:
      case 8:
        v16 = 5;
        break;
      default:
        goto LABEL_13;
    }
    v10 |= v16;
  }
  else
  {
LABEL_13:
    if (!v10)
      return 0;
  }
  return OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GetRegularPatchBoundaryMask(int,int,int)const::vBoundaryMaskToEMask[v10];
}

uint64_t OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GetIrregularPatchCornerSpans(uint64_t a1, int a2, int a3, uint64_t a4, unsigned int a5)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  _BOOL4 v16;
  BOOL v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int16 *v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  _BYTE v39[4];
  _WORD v40[4];
  uint64_t v41;

  v41 = *MEMORY[0x24BDAC8D0];
  v8 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)a1 + 40) + 8 * a2);
  if ((a5 & 0x80000000) == 0
    && (v9 = *(int *)(*(_QWORD *)(a1 + 144) + 4 * a5),
        (OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getFaceCompositeValueTag(*(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(v8[57] + 8 * v9), a3) & 1) != 0))
  {
    result = (uint64_t)OpenSubdiv::v3_1_1::Vtr::internal::Level::getFaceVTags(v8, a3, v40, v9);
    if ((v9 & 0x80000000) == 0)
      result = (uint64_t)OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getFaceValueTags(*(_QWORD **)(v8[57] + 8 * v9), a3, (uint64_t)v39);
  }
  else
  {
    LODWORD(v9) = -1;
    result = (uint64_t)OpenSubdiv::v3_1_1::Vtr::internal::Level::getFaceVTags(v8, a3, v40, 0xFFFFFFFF);
  }
  v11 = v8[3];
  v12 = *(unsigned int *)(v11 + 8 * a3);
  if ((int)v12 >= 1)
  {
    v13 = 0;
    v38 = (2 * a3) | 1;
    v14 = v8[6] + 4 * *(int *)(v11 + 4 * v38);
    v15 = 7;
    if ((*(_WORD *)(a1 + 8) & 8) == 0)
      v15 = 3;
    v36 = v14;
    v37 = v15;
    do
    {
      v16 = (v9 & 0x80000000) != 0 || (v39[v13] & 1) == 0;
      if ((*(_WORD *)(a1 + 8) & 8) != 0
        && ((v40[v13] & 0x1000) != 0 ? (v17 = (v40[v13] & 0x780) != 256) : (v17 = 0), v17)
        || !v16)
      {
        v19 = v40[v13];
        v20 = a4 + 6 * v13;
        if ((v19 & 1) != 0)
        {
          v21 = *(int *)(v8[6] + 4 * *(int *)(v8[3] + 4 * v38) + 4 * v13);
          v22 = v8[36];
          v23 = v8[33];
          v24 = *(int *)(v23 + 8 * v21 + 4);
          v25 = *(unsigned int *)(v23 + 8 * (_DWORD)v21);
          v26 = v8[39];
          *(_WORD *)(v20 + 4) = 0;
          *(_DWORD *)v20 = 0;
          if ((int)v25 < 1)
          {
LABEL_29:
            if ((v19 & 8) == 0)
              goto LABEL_30;
          }
          else
          {
            v27 = 0;
            v28 = v22 + 4 * v24;
            v29 = v26 + 2 * v24;
            while (*(_DWORD *)(v28 + 4 * v27) != a3 || v13 != *(unsigned __int16 *)(v29 + 2 * v27))
            {
              if (v25 == ++v27)
                goto LABEL_29;
            }
            v32 = a4 + 6 * v13;
            *(_WORD *)(v32 + 2) = v27;
            *(_WORD *)v20 = 1;
            *(_BYTE *)(v32 + 4) = 2;
            if ((v19 & 8) == 0)
            {
LABEL_30:
              if ((*(_WORD *)(a1 + 8) & 8) != 0)
              {
                v31 = a4 + 6 * v13;
                v30 = *(_BYTE *)(v31 + 4) & 0xFD | (2 * ((v19 & 0x4780) == 17408));
                *(_BYTE *)(v31 + 4) = v30;
              }
              else
              {
                v30 = *(_BYTE *)(a4 + 6 * v13 + 4);
              }
              goto LABEL_35;
            }
          }
        }
        else
        {
          if ((v19 & 8) == 0)
            goto LABEL_30;
        }
      }
      else
      {
        v18 = a4 + 6 * v13;
        *(_WORD *)(v18 + 4) = 0;
        *(_DWORD *)v18 = 0;
        v19 = v40[v13];
        if ((v19 & 8) == 0)
          goto LABEL_30;
      }
      v33 = a4 + 6 * v13;
      v30 = *(_BYTE *)(v33 + 4) | 2;
      *(_BYTE *)(v33 + 4) = v30;
LABEL_35:
      if ((v30 & 2) == 0 && (v19 & 7) == 6 && *(_BYTE *)(a1 + 24))
      {
        v34 = (unsigned __int16 *)(a4 + 6 * v13);
        v35 = *v34;
        if (!*v34)
          v35 = *(_DWORD *)(v8[33] + 8 * *(int *)(v36 + 4 * v13));
        *((_BYTE *)v34 + 4) = v30 & 0xFD | (2 * (v35 == 1));
      }
      ++v13;
    }
    while (v13 != v12);
  }
  return result;
}

void OpenSubdiv::v3_1_1::Far::PatchTableFactory::allocateVertexTables(OpenSubdiv::v3_1_1::Far::PatchTableFactory *this, const OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext *a2, OpenSubdiv::v3_1_1::Far::PatchTable *a3)
{
  uint64_t v3;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  int v12;

  v3 = *((_QWORD *)a2 + 1);
  if ((int)(-858993459 * ((*((_QWORD *)a2 + 2) - v3) >> 2)) >= 1)
  {
    v6 = 0;
    LODWORD(v7) = 0;
    v8 = 0;
    v9 = -858993459 * ((*((_QWORD *)a2 + 2) - v3) >> 2);
    v10 = (int *)(v3 + 4);
    do
    {
      v11 = *v10;
      v10 += 5;
      v7 = v11 + (int)v7;
      v8 += OpenSubdiv::v3_1_1::Far::PatchTable::GetNumControlVertices(a2, v6++);
    }
    while (v9 != v6);
    if (v8 && (_DWORD)v7)
    {
      std::vector<unsigned int>::resize((std::vector<int> *)((char *)a2 + 32), v8);
      std::vector<OpenSubdiv::v3_1_1::Far::PatchParam>::resize((uint64_t)a2 + 56, v7);
      if ((*(_BYTE *)(*(_QWORD *)this + 8) & 1) == 0)
      {
        v12 = 3;
        OpenSubdiv::v3_1_1::Far::PatchTable::allocateVaryingVertices((uint64_t)a2, &v12, v7);
      }
      if ((*((_WORD *)this + 4) & 4) != 0)
        std::vector<unsigned int>::resize((std::vector<int> *)((char *)a2 + 224), v7, &OpenSubdiv::v3_1_1::Vtr::INDEX_INVALID);
    }
  }
}

void std::vector<OpenSubdiv::v3_1_1::Far::PatchParam>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<OpenSubdiv::v3_1_1::Far::PatchParam>::__append((void **)a1, a2 - v2);
  }
}

void OpenSubdiv::v3_1_1::Far::PatchTableFactory::allocateFVarChannels(OpenSubdiv::v3_1_1::Far::PatchTableFactory *this, const OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext *a2, OpenSubdiv::v3_1_1::Far::PatchTable *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int *v18;
  int v19;
  int v20;
  int v21;

  v5 = *(_QWORD *)this;
  v7 = *((_QWORD *)a2 + 7);
  v6 = *((_QWORD *)a2 + 8);
  v8 = (_QWORD *)((char *)a2 + 176);
  std::vector<OpenSubdiv::v3_1_1::Far::PatchTable::FVarPatchChannel>::resize((uint64_t)a2 + 176, (int)((uint64_t)(*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 2));
  v9 = *((_QWORD *)this + 18);
  if ((int)((unint64_t)(*((_QWORD *)this + 19) - v9) >> 2) >= 1)
  {
    v10 = 0;
    v11 = 0;
    v12 = (unint64_t)(v6 - v7) >> 3;
    do
    {
      v13 = (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v5 + 40) + 456) + 8 * *(int *)(v9 + 4 * v11)) + 8) >> 2) & 7;
      *(_DWORD *)(*v8 + v10) = v13;
      v14 = *((unsigned __int16 *)this + 4);
      if ((*(_BYTE *)(v5 + 8) & 1) != 0)
      {
        if ((v14 & 2) != 0)
          v19 = 4;
        else
          v19 = 3;
        v21 = v19;
        v18 = &v21;
      }
      else
      {
        if (v13 == 5)
          v15 = 1;
        else
          v15 = (v14 >> 13) & 1;
        if ((v14 & 0x700) == 0x300)
          v16 = 9;
        else
          v16 = 6;
        if (v15)
          v17 = 3;
        else
          v17 = v16;
        v20 = v17;
        v18 = &v20;
      }
      OpenSubdiv::v3_1_1::Far::PatchTable::allocateFVarPatchChannelValues((uint64_t)a2, v18, v12, v11++);
      v9 = *((_QWORD *)this + 18);
      v10 += 56;
    }
    while (v11 < (int)((unint64_t)(*((_QWORD *)this + 19) - v9) >> 2));
  }
}

unint64_t OpenSubdiv::v3_1_1::Far::PatchTableFactory::computePatchParam(_QWORD *a1, uint64_t a2, int a3, uint64_t a4, char a5, unsigned __int8 a6)
{
  BOOL v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  _QWORD *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  int v26;
  int v27;

  v6 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1[11] + 24 * a3) + 24) + 8 * (_DWORD)a4) != 4;
  if (a3 < 1)
  {
    v9 = 0;
    LOWORD(v8) = 0;
    v7 = 0;
  }
  else
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = a1[8];
    v11 = a1[5];
    v12 = 1;
    v13 = a3;
    v14 = a3;
    do
    {
      v15 = *(_QWORD **)(v10 + 8 * --v13);
      v16 = a4;
      a4 = *(int *)(v15[33] + 4 * (int)a4);
      if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v11 + 8 * v13) + 24) + 8 * a4) == 4)
      {
        v7 = (*(unsigned __int8 *)(v15[42] + v16) >> 3) & 3;
        v17 = v8 + v12;
        v18 = v9 + v12;
        if (v7 == 1)
          v19 = v9 + v12;
        else
          v19 = v9;
        if (v7 == 2)
          v8 += v12;
        else
          v18 = v19;
        if (v7 == 3)
          v8 = v17;
        else
          v9 = v18;
        v12 = 2 * (v12 & 0x7FFF);
      }
      else
      {
        v20 = v15[11];
        v21 = *(unsigned int *)(v20 + 8 * a4);
        if ((int)v21 < 1)
        {
LABEL_18:
          v6 = 1;
        }
        else
        {
          v22 = 0;
          v23 = v15[15] + 4 * *(int *)(v20 + 4 * (int)((2 * a4) | 1));
          while (*(_DWORD *)(v23 + 4 * v22) != v16)
          {
            if (v21 == ++v22)
              goto LABEL_18;
          }
          v6 = 1;
          v7 = v22;
        }
      }
    }
    while (v14-- > 1);
  }
  if (!v6)
    v7 = 0;
  v25 = (*(_DWORD *)(a2 + 4 * (int)a4) + v7) & 0xFFFFFFF | (a6 << 28);
  v26 = (v9 << 22) | ((v8 & 0x3FF) << 12);
  if (v6)
    v27 = 16;
  else
    v27 = 0;
  return v25 | ((unint64_t)(a3 & 0xF | ((a5 & 0xF) << 8) | v26 | v27) << 32);
}

uint64_t OpenSubdiv::v3_1_1::Far::PatchTableFactory::Create(int *a1, uint64_t a2, uint64_t a3)
{
  if ((a1[2] & 1) != 0)
    return OpenSubdiv::v3_1_1::Far::PatchTableFactory::createUniform((uint64_t)a1, a2, a3);
  else
    return OpenSubdiv::v3_1_1::Far::PatchTableFactory::createAdaptive(a1, a2, a3);
}

uint64_t OpenSubdiv::v3_1_1::Far::PatchTableFactory::createUniform(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v5;
  unsigned int v6;
  int v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  OpenSubdiv::v3_1_1::Far::PatchTable *v14;
  unint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  OpenSubdiv::v3_1_1::Far::PatchTable *v20;
  char *v21;
  uint64_t v22;
  char *v23;
  _DWORD *v24;
  unint64_t *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  size_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  char *v42;
  unsigned int **v43;
  uint64_t i;
  _QWORD *v45;
  unsigned int *v46;
  uint64_t v47;
  int *v48;
  int v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  _DWORD **v63;
  _DWORD *v64;
  int v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  _QWORD *v78;
  unsigned int v79;
  unint64_t v80;
  uint64_t v81;
  int v82;
  int v83;
  _QWORD *v84[4];
  _DWORD *v85;
  _DWORD *v86;
  void *v87;
  void *v88;
  void *v89;
  void *v90;
  uint64_t v91;
  char *v92;
  char *v93;
  void **v94[2];

  v94[1] = *(void ***)MEMORY[0x24BDAC8D0];
  OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::BuilderContext((uint64_t)v84, (int *)a1, a2, a3);
  v5 = *(_DWORD *)a1;
  v6 = (a2 & (2 * (*(_DWORD *)a1 < 2u)));
  v7 = *(_DWORD *)(a1 + 36);
  v81 = a1;
  v8 = ((unint64_t)*(unsigned __int8 *)(a1 + 8) >> 2) & 0xF;
  v76 = a2;
  if ((a2 & 1) != 0)
    v9 = 1;
  else
    v9 = v8;
  v10 = v8 + 1;
  v77 = v9;
  v11 = v8 + 1 - v9;
  v79 = v6;
  if (v6)
  {
    v12 = 4;
  }
  else if (v5 > 2)
  {
    v12 = 0;
  }
  else
  {
    v12 = dword_22619D11C[v5];
  }
  v13 = operator new();
  *(_DWORD *)v13 = v7;
  *(_OWORD *)(v13 + 24) = 0u;
  *(_OWORD *)(v13 + 40) = 0u;
  *(_OWORD *)(v13 + 56) = 0u;
  *(_OWORD *)(v13 + 72) = 0u;
  *(_OWORD *)(v13 + 88) = 0u;
  *(_OWORD *)(v13 + 104) = 0u;
  *(_OWORD *)(v13 + 120) = 0u;
  *(_QWORD *)(v13 + 136) = 0;
  *(_OWORD *)(v13 + 8) = 0u;
  *(_DWORD *)(v13 + 144) = 3;
  *(_OWORD *)(v13 + 152) = 0u;
  *(_OWORD *)(v13 + 168) = 0u;
  *(_OWORD *)(v13 + 184) = 0u;
  *(_OWORD *)(v13 + 200) = 0u;
  *(_OWORD *)(v13 + 216) = 0u;
  *(_OWORD *)(v13 + 232) = 0u;
  *(_OWORD *)(v13 + 248) = 0u;
  *(_QWORD *)(v13 + 264) = 0;
  *(_DWORD *)(v13 + 4) = *(v86 - 1);
  std::vector<OpenSubdiv::v3_1_1::Far::PatchTable::PatchArray>::reserve((char **)(v13 + 8), v11);
  LODWORD(v94[0]) = 0;
  v83 = 0;
  v80 = v8;
  if (v77 <= v8)
  {
    v15 = v77;
    do
    {
      v16 = *(unsigned int **)(*(_QWORD *)(v81 + 88) + 24 * v15);
      v17 = *v16;
      if ((*(_BYTE *)(v81 + 8) & 2) != 0 && (int)v17 >= 1)
      {
        v18 = *((_QWORD *)v16 + 12);
        v19 = v17 + 1;
        do
          LODWORD(v17) = v17 - (*(_BYTE *)(v18 + (v19-- - 2)) & 1);
        while (v19 > 1);
      }
      v82 = v12;
      OpenSubdiv::v3_1_1::Far::PatchTable::pushPatchArray((_QWORD *)v13, &v82, (_DWORD)v17 << (v79 >> 1), &v83, (int *)v94, 0);
      ++v15;
    }
    while (v15 != v10);
  }
  OpenSubdiv::v3_1_1::Far::PatchTableFactory::allocateVertexTables((OpenSubdiv::v3_1_1::Far::PatchTableFactory *)v84, (const OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext *)v13, v14);
  v21 = v92;
  v74 = v13;
  if (v92 == v93)
  {
    v33 = 0;
    v30 = 0;
    v24 = *(_DWORD **)(v13 + 32);
    v25 = *(unint64_t **)(v13 + 56);
    v40 = *(_QWORD *)(v81 + 88);
    v78 = (_QWORD *)(v81 + 88);
    v27 = *(_DWORD *)(*(_QWORD *)v40 + 8);
    v23 = v92;
  }
  else
  {
    OpenSubdiv::v3_1_1::Far::PatchTableFactory::allocateFVarChannels((OpenSubdiv::v3_1_1::Far::PatchTableFactory *)v84, (const OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext *)v13, v20);
    v23 = v92;
    v21 = v93;
    v24 = *(_DWORD **)(v13 + 32);
    v25 = *(unint64_t **)(v13 + 56);
    v26 = *(_QWORD *)(v81 + 88);
    v78 = (_QWORD *)(v81 + 88);
    v27 = *(_DWORD *)(*(_QWORD *)v26 + 8);
    if (v92 == v93)
    {
      v33 = 0;
      v30 = 0;
      v21 = v92;
    }
    else
    {
      v28 = v93 - v92;
      MEMORY[0x24BDAC7A8](v22);
      v30 = (char *)&v73 - v29;
      bzero((char *)&v73 - v29, v21 - v23);
      MEMORY[0x24BDAC7A8](v31);
      v33 = (char *)&v73 - v32;
      bzero((char *)&v73 - v32, v34);
      if ((int)((unint64_t)(v21 - v23) >> 2) >= 1)
      {
        v35 = 0;
        v36 = (int)(v28 >> 2);
        if (v36 <= 1)
          v36 = 1;
        v37 = (uint64_t *)(*(_QWORD *)(v74 + 176) + 8);
        v38 = 8 * v36;
        do
        {
          v39 = *v37;
          v37 += 7;
          *(_QWORD *)&v33[v35] = v39;
          v35 += 8;
        }
        while (v38 != v35);
      }
    }
  }
  if ((_DWORD)v80)
  {
    v41 = 1;
    v42 = v21;
    v75 = v10;
    do
    {
      if (v41 >= v77)
      {
        v43 = (unsigned int **)(*v78 + 24 * v41);
        v80 = **v43;
        if ((int)v80 >= 1)
        {
          for (i = 0; i != v80; ++i)
          {
            v45 = *v43;
            if ((*(_BYTE *)(v81 + 8) & 2) == 0 || (*(_BYTE *)(v45[12] + i) & 1) == 0)
            {
              v46 = (unsigned int *)(v45[3] + 8 * i);
              v47 = *v46;
              if ((int)v47 >= 1)
              {
                v48 = (int *)(v45[6] + 4 * (int)v46[1]);
                do
                {
                  v49 = *v48++;
                  *v24++ = v49 + v27;
                  --v47;
                }
                while (v47);
              }
              v50 = v41;
              *v25 = OpenSubdiv::v3_1_1::Far::PatchTableFactory::computePatchParam(v84[0], (uint64_t)v85, v41, i, 0, 0);
              v23 = v92;
              v21 = v93;
              v42 = v92;
              if (v92 != v93)
              {
                v42 = v93;
                if ((int)((unint64_t)(v93 - v92) >> 2) >= 1)
                {
                  v51 = 0;
                  v52 = *((_QWORD *)*v43 + 57);
                  v53 = (int)((v93 - v92) >> 2);
                  if (v53 <= 1)
                    v53 = 1;
                  do
                  {
                    v54 = *(_QWORD **)(v52 + 8 * *(int *)&v23[4 * v51]);
                    v55 = *(_QWORD *)(*v54 + 24);
                    v56 = *(unsigned int *)(v55 + 8 * (_DWORD)i);
                    if ((int)v56 <= 0)
                    {
                      v60 = *(_QWORD *)&v33[8 * v51];
                    }
                    else
                    {
                      v57 = 0;
                      v58 = v54[3] + 4 * *(int *)(v55 + 4 * ((2 * (int)i) | 1));
                      v59 = *(_DWORD *)&v30[4 * v51];
                      v60 = *(_QWORD *)&v33[8 * v51];
                      do
                      {
                        *(_DWORD *)(v60 + v57) = *(_DWORD *)(v58 + v57) + v59;
                        v57 += 4;
                      }
                      while (4 * v56 != v57);
                    }
                    *(_QWORD *)&v33[8 * v51++] = v60 + 4 * (int)v56;
                  }
                  while (v51 != v53);
                  v42 = v21;
                }
              }
              v41 = v50;
              if (v79)
              {
                v61 = *(v24 - 2);
                *v24 = *(v24 - 4);
                v24[1] = v61;
                v24 += 2;
                v25[1] = *v25;
                v25 += 2;
                v23 = v92;
                v21 = v93;
                if (v92 == v93)
                {
                  v21 = v92;
                  v42 = v92;
                }
                else
                {
                  if ((int)((unint64_t)(v93 - v92) >> 2) >= 1)
                  {
                    v62 = ((unint64_t)(v93 - v92) >> 2);
                    v63 = (_DWORD **)v33;
                    do
                    {
                      v64 = *v63;
                      v65 = *(*v63 - 2);
                      *v64 = *(*v63 - 4);
                      v64[1] = v65;
                      *v63++ = v64 + 2;
                      --v62;
                    }
                    while (v62);
                  }
                  v42 = v21;
                }
              }
              else
              {
                ++v25;
              }
            }
          }
        }
      }
      if ((v76 & 1) != 0)
      {
        v66 = *(_QWORD *)(*v78 + 24 * v41);
        v27 += *(_DWORD *)(v66 + 8);
        if ((int)((unint64_t)(v42 - v23) >> 2) >= 1)
        {
          v67 = 0;
          v68 = *(_QWORD *)(v66 + 456);
          v69 = (int)((v21 - v23) >> 2);
          if (v69 <= 1)
            v69 = 1;
          v70 = 4 * v69;
          do
          {
            *(_DWORD *)&v30[v67] += *(_DWORD *)(*(_QWORD *)(v68 + 8 * *(int *)&v23[v67]) + 16);
            v67 += 4;
          }
          while (v70 != v67);
          v42 = v21;
        }
      }
      ++v41;
    }
    while (v41 != v75);
  }
  if (v23)
  {
    v93 = v23;
    operator delete(v23);
  }
  v94[0] = (void **)&v91;
  std::vector<std::vector<unsigned int>>::__destroy_vector::operator()[abi:nn180100](v94);
  v71 = v74;
  if (v89)
  {
    v90 = v89;
    operator delete(v89);
  }
  if (v87)
  {
    v88 = v87;
    operator delete(v87);
  }
  if (v85)
  {
    v86 = v85;
    operator delete(v85);
  }
  return v71;
}

uint64_t OpenSubdiv::v3_1_1::Far::PatchTableFactory::createAdaptive(int *a1, uint64_t a2, uint64_t a3)
{
  OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext *v4;
  int v5;
  uint64_t v6;
  OpenSubdiv::v3_1_1::Far::PatchTable *v7;
  _BYTE v9[32];
  void *v10;
  _DWORD *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  void *__p;
  void *v18;
  void **v19;

  OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::BuilderContext((uint64_t)v9, a1, a2, a3);
  OpenSubdiv::v3_1_1::Far::PatchTableFactory::identifyAdaptivePatches((OpenSubdiv::v3_1_1::Far::PatchTableFactory *)v9, v4);
  v5 = a1[9];
  v6 = operator new();
  *(_DWORD *)v6 = v5;
  *(_OWORD *)(v6 + 8) = 0u;
  *(_OWORD *)(v6 + 24) = 0u;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *(_OWORD *)(v6 + 72) = 0u;
  *(_OWORD *)(v6 + 88) = 0u;
  *(_OWORD *)(v6 + 104) = 0u;
  *(_OWORD *)(v6 + 120) = 0u;
  *(_QWORD *)(v6 + 136) = 0;
  *(_DWORD *)(v6 + 144) = 3;
  *(_OWORD *)(v6 + 152) = 0u;
  *(_OWORD *)(v6 + 168) = 0u;
  *(_OWORD *)(v6 + 184) = 0u;
  *(_OWORD *)(v6 + 200) = 0u;
  *(_OWORD *)(v6 + 216) = 0u;
  *(_OWORD *)(v6 + 232) = 0u;
  *(_OWORD *)(v6 + 248) = 0u;
  *(_QWORD *)(v6 + 264) = 0;
  *(_DWORD *)(v6 + 4) = *(v11 - 1);
  OpenSubdiv::v3_1_1::Far::PatchTableFactory::populateAdaptivePatches((OpenSubdiv::v3_1_1::Far::PatchTableFactory *)v9, (OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext *)v6, v7);
  if (__p)
  {
    v18 = __p;
    operator delete(__p);
  }
  v19 = (void **)&v16;
  std::vector<std::vector<unsigned int>>::__destroy_vector::operator()[abi:nn180100](&v19);
  if (v14)
  {
    v15 = v14;
    operator delete(v14);
  }
  if (v12)
  {
    v13 = v12;
    operator delete(v12);
  }
  if (v10)
  {
    v11 = v10;
    operator delete(v10);
  }
  return v6;
}

void OpenSubdiv::v3_1_1::Far::PatchTableFactory::identifyAdaptivePatches(OpenSubdiv::v3_1_1::Far::PatchTableFactory *this, OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext *a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  _DWORD *v17;
  char *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  char *v24;
  char *v25;
  int v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  _DWORD *v30;
  _DWORD **v31;
  unint64_t v32;
  _QWORD *v33;
  _DWORD *v34;
  _DWORD *v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  char *v40;
  char *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  int *v45;
  unint64_t v46;
  int *v47;
  int v48;
  _DWORD *v49;
  int *v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  char *v55;
  int *v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int *v61;
  int **v62;
  int v63;
  unint64_t v64;
  _QWORD *v65;
  int *v66;
  int *v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  char *v72;
  int *v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  _QWORD *v77;
  unsigned int *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  __int16 v83;
  uint64_t v84;
  int *v85;
  uint64_t v86;
  unint64_t v87;
  _DWORD *v88;
  _DWORD *v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  char *v98;
  char *v99;
  char *v100;
  uint64_t v101;
  unsigned int v102;
  char *v103;
  char *v104;
  uint64_t v105;

  v3 = *(_QWORD *)this;
  v4 = *(int *)(*(_QWORD *)this + 28);
  v5 = *((_QWORD *)this + 9);
  if (v4 > (*((_QWORD *)this + 11) - v5) >> 3)
  {
    if ((v4 & 0x80000000) != 0)
      goto LABEL_110;
    v6 = *((_QWORD *)this + 10) - v5;
    v7 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<zip_entry_t *>>(v4);
    v8 = &v7[v6];
    v10 = &v7[8 * v9];
    v11 = (char *)*((_QWORD *)this + 9);
    v12 = (char *)*((_QWORD *)this + 10);
    v13 = v8;
    if (v12 != v11)
    {
      v13 = v8;
      do
      {
        v14 = *((_QWORD *)v12 - 1);
        v12 -= 8;
        *((_QWORD *)v13 - 1) = v14;
        v13 -= 8;
      }
      while (v12 != v11);
    }
    *((_QWORD *)this + 9) = v13;
    *((_QWORD *)this + 10) = v8;
    *((_QWORD *)this + 11) = v10;
    if (v11)
      operator delete(v11);
  }
  v15 = *((_QWORD *)this + 14);
  v104 = (char *)this + 112;
  v16 = (char *)*((_QWORD *)this + 13);
  v105 = v3;
  if ((unint64_t)v16 < v15)
  {
    *(_DWORD *)v16 = 0;
    v17 = v16 + 4;
    goto LABEL_24;
  }
  v18 = (char *)*((_QWORD *)this + 12);
  v19 = (v16 - v18) >> 2;
  v20 = v19 + 1;
  if ((unint64_t)(v19 + 1) >> 62)
LABEL_110:
    abort();
  v21 = v15 - (_QWORD)v18;
  if (v21 >> 1 > v20)
    v20 = v21 >> 1;
  if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL)
    v22 = 0x3FFFFFFFFFFFFFFFLL;
  else
    v22 = v20;
  if (v22)
  {
    v23 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)v104, v22);
    v18 = (char *)*((_QWORD *)this + 12);
    v16 = (char *)*((_QWORD *)this + 13);
  }
  else
  {
    v23 = 0;
  }
  v24 = &v23[4 * v19];
  v25 = &v23[4 * v22];
  *(_DWORD *)v24 = 0;
  v17 = v24 + 4;
  while (v16 != v18)
  {
    v26 = *((_DWORD *)v16 - 1);
    v16 -= 4;
    *((_DWORD *)v24 - 1) = v26;
    v24 -= 4;
  }
  *((_QWORD *)this + 12) = v24;
  *((_QWORD *)this + 13) = v17;
  *((_QWORD *)this + 14) = v25;
  if (v18)
    operator delete(v18);
LABEL_24:
  *((_QWORD *)this + 13) = v17;
  v27 = (_QWORD *)((char *)this + 120);
  std::vector<std::vector<unsigned long>>::resize((_QWORD *)this + 15, (uint64_t)(*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 2);
  if ((int)((*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 2) >= 1)
  {
    v28 = 0;
    do
    {
      v29 = *v27 + 24 * v28;
      v31 = (_DWORD **)(v29 + 8);
      v30 = *(_DWORD **)(v29 + 8);
      v33 = (_QWORD *)(v29 + 16);
      v32 = *(_QWORD *)(v29 + 16);
      if ((unint64_t)v30 >= v32)
      {
        v35 = *(_DWORD **)v29;
        v36 = ((uint64_t)v30 - *(_QWORD *)v29) >> 2;
        v37 = v36 + 1;
        if ((unint64_t)(v36 + 1) >> 62)
          goto LABEL_110;
        v38 = v32 - (_QWORD)v35;
        if (v38 >> 1 > v37)
          v37 = v38 >> 1;
        if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFFCLL)
          v39 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v39 = v37;
        if (v39)
        {
          v40 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)v33, v39);
          v30 = *v31;
          v35 = *(_DWORD **)v29;
        }
        else
        {
          v40 = 0;
        }
        v41 = &v40[4 * v36];
        *(_DWORD *)v41 = 0;
        v34 = v41 + 4;
        while (v30 != v35)
        {
          v42 = *--v30;
          *((_DWORD *)v41 - 1) = v42;
          v41 -= 4;
        }
        *(_QWORD *)v29 = v41;
        *v31 = v34;
        *v33 = &v40[4 * v39];
        if (v35)
          operator delete(v35);
      }
      else
      {
        *v30 = 0;
        v34 = v30 + 1;
      }
      *v31 = v34;
      ++v28;
    }
    while (v28 < (int)((*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 2));
  }
  v43 = v105;
  if ((int)(-1431655765 * ((*(_QWORD *)(v105 + 96) - *(_QWORD *)(v105 + 88)) >> 3)) >= 1)
  {
    v44 = 0;
    while (1)
    {
      v45 = *(int **)(*(_QWORD *)(v43 + 40) + 8 * v44);
      v47 = (int *)*((_QWORD *)this + 13);
      v46 = *((_QWORD *)this + 14);
      v48 = v45[2] + *(v47 - 1);
      if ((unint64_t)v47 >= v46)
      {
        v50 = (int *)*((_QWORD *)this + 12);
        v51 = v47 - v50;
        v52 = v51 + 1;
        if ((unint64_t)(v51 + 1) >> 62)
          goto LABEL_110;
        v53 = v46 - (_QWORD)v50;
        if (v53 >> 1 > v52)
          v52 = v53 >> 1;
        if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFFCLL)
          v54 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v54 = v52;
        if (v54)
        {
          v55 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)v104, v54);
          v50 = (int *)*((_QWORD *)this + 12);
          v47 = (int *)*((_QWORD *)this + 13);
        }
        else
        {
          v55 = 0;
        }
        v56 = (int *)&v55[4 * v51];
        *v56 = v48;
        v49 = v56 + 1;
        while (v47 != v50)
        {
          v57 = *--v47;
          *--v56 = v57;
        }
        *((_QWORD *)this + 12) = v56;
        *((_QWORD *)this + 13) = v49;
        *((_QWORD *)this + 14) = &v55[4 * v54];
        if (v50)
          operator delete(v50);
      }
      else
      {
        *v47 = v48;
        v49 = v47 + 1;
      }
      *((_QWORD *)this + 13) = v49;
      v58 = *((_QWORD *)this + 18);
      if ((int)((unint64_t)(*((_QWORD *)this + 19) - v58) >> 2) >= 1)
      {
        v59 = 0;
        do
        {
          v60 = *v27 + 24 * v59;
          v62 = (int **)(v60 + 8);
          v61 = *(int **)(v60 + 8);
          v63 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v45 + 57) + 8 * *(int *)(v58 + 4 * v59)) + 16) + *(v61 - 1);
          v65 = (_QWORD *)(v60 + 16);
          v64 = *(_QWORD *)(v60 + 16);
          if ((unint64_t)v61 >= v64)
          {
            v67 = *(int **)v60;
            v68 = ((uint64_t)v61 - *(_QWORD *)v60) >> 2;
            v69 = v68 + 1;
            if ((unint64_t)(v68 + 1) >> 62)
              goto LABEL_110;
            v70 = v64 - (_QWORD)v67;
            if (v70 >> 1 > v69)
              v69 = v70 >> 1;
            if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFFCLL)
              v71 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v71 = v69;
            if (v71)
            {
              v72 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)v65, v71);
              v61 = *v62;
              v67 = *(int **)v60;
            }
            else
            {
              v72 = 0;
            }
            v73 = (int *)&v72[4 * v68];
            *v73 = v63;
            v66 = v73 + 1;
            while (v61 != v67)
            {
              v74 = *--v61;
              *--v73 = v74;
            }
            *(_QWORD *)v60 = v73;
            *v62 = v66;
            *v65 = &v72[4 * v71];
            if (v67)
              operator delete(v67);
          }
          else
          {
            *v61 = v63;
            v66 = v61 + 1;
          }
          *v62 = v66;
          ++v59;
          v58 = *((_QWORD *)this + 18);
        }
        while (v59 < (int)((unint64_t)(*((_QWORD *)this + 19) - v58) >> 2));
      }
      if (*v45 >= 1)
        break;
LABEL_108:
      ++v44;
      v43 = v105;
      if (v44 >= (int)(-1431655765 * ((*(_QWORD *)(v105 + 96) - *(_QWORD *)(v105 + 88)) >> 3)))
        return;
    }
    v75 = 0;
    while (1)
    {
      v76 = *(_QWORD *)this;
      v77 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)this + 40) + 8 * (int)v44);
      if ((*(_BYTE *)(v77[12] + v75) & 1) != 0
        || ((*(unsigned __int8 *)(v76 + 8) >> 2) & 0xF) > (int)v44
        && (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v76 + 64) + 8 * (int)v44) + 408) + v75) & 1) != 0)
      {
        goto LABEL_107;
      }
      v78 = (unsigned int *)(v77[3] + 8 * v75);
      v79 = v77[6];
      v80 = *v78;
      v81 = (int)v78[1];
      v82 = v77[54];
      v83 = *(_WORD *)(v82 + 2 * *(int *)(v79 + 4 * v81));
      if ((int)v80 >= 2)
      {
        v84 = v80 - 1;
        v85 = (int *)(v79 + 4 * v81 + 4);
        do
        {
          v86 = *v85++;
          v83 |= *(_WORD *)(v82 + 2 * v86);
          --v84;
        }
        while (v84);
      }
      if ((v83 & 0x800) != 0)
        goto LABEL_107;
      v88 = (_DWORD *)*((_QWORD *)this + 10);
      v87 = *((_QWORD *)this + 11);
      if ((unint64_t)v88 >= v87)
      {
        v90 = *((_QWORD *)this + 9);
        v91 = ((uint64_t)v88 - v90) >> 3;
        v92 = v91 + 1;
        if ((unint64_t)(v91 + 1) >> 61)
          goto LABEL_110;
        v93 = v87 - v90;
        if (v93 >> 2 > v92)
          v92 = v93 >> 2;
        v94 = (unint64_t)v93 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v92;
        v96 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<zip_entry_t *>>(v94);
        v97 = &v96[8 * v91];
        *(_DWORD *)v97 = v75;
        *((_DWORD *)v97 + 1) = v44;
        v98 = (char *)*((_QWORD *)this + 9);
        v99 = (char *)*((_QWORD *)this + 10);
        v100 = v97;
        while (v99 != v98)
        {
          v101 = *((_QWORD *)v99 - 1);
          v99 -= 8;
          *((_QWORD *)v100 - 1) = v101;
          v100 -= 8;
        }
        v89 = v97 + 8;
        *((_QWORD *)this + 9) = v100;
        *((_QWORD *)this + 10) = v97 + 8;
        *((_QWORD *)this + 11) = &v96[8 * v95];
        if (v98)
          operator delete(v98);
      }
      else
      {
        *v88 = v75;
        v88[1] = v44;
        v89 = v88 + 2;
      }
      *((_QWORD *)this + 10) = v89;
      if (OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::IsPatchRegular(this, v44, v75, 0xFFFFFFFF))
        break;
      ++*((_DWORD *)this + 15);
      if ((*((_WORD *)this + 4) & 0x700) == 0x400)
      {
        v102 = (OpenSubdiv::v3_1_1::Vtr::internal::Level::getFaceCompositeVTag((OpenSubdiv::v3_1_1::Vtr::internal::Level *)v45, v75, 0xFFFFFFFF) >> 2) & 1;
        v103 = (char *)this + 64;
        goto LABEL_106;
      }
LABEL_107:
      if (++v75 >= *v45)
        goto LABEL_108;
    }
    v102 = 1;
    v103 = (char *)this + 56;
LABEL_106:
    *(_DWORD *)v103 += v102;
    goto LABEL_107;
  }
}

void OpenSubdiv::v3_1_1::Far::PatchTableFactory::populateAdaptivePatches(OpenSubdiv::v3_1_1::Far::PatchTableFactory *this, OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext *a2, OpenSubdiv::v3_1_1::Far::PatchTable *a3)
{
  uint64_t v5;
  char *v6;
  int v7;
  _BOOL4 v8;
  int v9;
  int v10;
  unsigned int v11;
  int *v12;
  int v13;
  int v14;
  BOOL v15;
  int v16;
  unsigned int v17;
  int *v18;
  int *v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  OpenSubdiv::v3_1_1::Far::PatchTable *v24;
  int *v25;
  uint64_t v26;
  int v27;
  OpenSubdiv::v3_1_1::Far::PatchTable *v28;
  uint64_t v29;
  uint64_t PatchArrayVertices;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  unint64_t v37;
  int *v38;
  _DWORD *v39;
  unsigned int v40;
  void **v41;
  void *v42;
  void **v43;
  int *v44;
  _QWORD *v45;
  unint64_t v46;
  unint64_t v47;
  int *v48;
  _DWORD *v49;
  unsigned int v50;
  void **v51;
  void *v52;
  void **v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t *v61;
  uint64_t *v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  int v70;
  unint64_t v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  int v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  OpenSubdiv::v3_1_1::Far::EndCapGregoryBasisPatchFactory *v79;
  OpenSubdiv::v3_1_1::Far::EndCapGregoryBasisPatchFactory *v80;
  uint64_t **v81;
  uint64_t v82;
  OpenSubdiv::v3_1_1::Far::EndCapBSplineBasisPatchFactory *v83;
  uint64_t v84;
  uint64_t v85;
  int *v86;
  int *v87;
  OpenSubdiv::v3_1_1::Vtr::internal::Level *v88;
  __int16 FaceCompositeVTag;
  _BOOL4 IsPatchRegular;
  int v91;
  int v92;
  int RegularPatchBoundaryMask;
  int v94;
  float v95;
  float v96;
  int v97;
  int v98;
  uint64_t *v99;
  int v100;
  uint64_t v101;
  int v102;
  int *v103;
  int v104;
  uint64_t v105;
  _QWORD *v106;
  int v107;
  _DWORD *v108;
  int *v109;
  int v110;
  uint64_t v111;
  int v112;
  unint64_t v113;
  unint64_t *v114;
  float *v115;
  float *v116;
  uint64_t v117;
  uint64_t v118;
  float *v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  char *v123;
  float *v124;
  int v125;
  _DWORD *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  int v132;
  _QWORD *v133;
  int v134;
  uint64_t v135;
  _QWORD *v136;
  uint64_t v137;
  unsigned int *v138;
  int *v139;
  int v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  _DWORD *v146;
  uint64_t v147;
  int v148;
  uint64_t v149;
  unint64_t *v150;
  __int16 *v151;
  uint64_t v152;
  uint64_t v153;
  unint64_t *v154;
  _DWORD *v155;
  int *PatchPoints;
  int v157;
  uint64_t v158;
  int v159;
  OpenSubdiv::v3_1_1::Far::StencilTable *v160;
  uint64_t v161;
  int *v162;
  unint64_t v163;
  int v164;
  _DWORD *v165;
  uint64_t v166;
  int v167;
  int *v168;
  unint64_t v169;
  int v170;
  _DWORD *v171;
  uint64_t v172;
  int v173;
  int v174;
  void *v175;
  void *v176;
  OpenSubdiv::v3_1_1::Far::EndCapGregoryBasisPatchFactory *v177;
  unsigned int v178;
  void *v179;
  void *v180;
  void *v181;
  void *v182;
  uint64_t v183;
  void *v184;
  uint64_t v185;
  uint64_t v186;
  _QWORD *v187;
  uint64_t v188;
  uint64_t v189;
  int *v190;
  unint64_t v191;
  int v192;
  _DWORD *v193;
  uint64_t v194;
  int v195;
  int v196;
  _QWORD *v197;
  void *v198;
  void *v199;
  _QWORD *v200;
  unsigned int v201;
  _QWORD *v202;
  void *v203;
  uint64_t v204;
  char *v205;
  int *v206;
  uint64_t v207;
  OpenSubdiv::v3_1_1::Far::StencilTable *v208;
  _DWORD **v209;
  OpenSubdiv::v3_1_1::Far::EndCapBSplineBasisPatchFactory *v210;
  uint64_t v211;
  OpenSubdiv::v3_1_1::Far::EndCapGregoryBasisPatchFactory *v212;
  uint64_t *v213;
  _QWORD *v214;
  OpenSubdiv::v3_1_1::Far::TopologyRefiner *v215;
  uint64_t v216;
  __int16 v217;
  int v218;
  int v219;
  unsigned int v220;
  BOOL v221;
  unsigned int v222;
  uint64_t v223;
  unint64_t v224;
  int v225;
  int v226;
  int v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  _QWORD v232[3];
  uint64_t *v233;
  uint64_t v234;
  uint64_t v235;
  void *v236;
  uint64_t *v237;
  uint64_t v238;
  uint64_t v239;
  void *__p;
  uint64_t *v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t *v244;
  int v245;
  int v246;
  uint64_t v247[37];

  v5 = 0;
  v247[35] = *MEMORY[0x24BDAC8D0];
  v215 = *(OpenSubdiv::v3_1_1::Far::TopologyRefiner **)this;
  do
  {
    v6 = (char *)&v245 + v5 * 8;
    *(_DWORD *)v6 = 6;
    *(_QWORD *)(v6 + 4) = 0;
    *(_QWORD *)(v6 + 20) = 0;
    *(_QWORD *)(v6 + 12) = 0;
    *((_DWORD *)v6 + 7) = 0;
    *((_QWORD *)v6 + 4) = &v247[v5 + 5];
    *((_QWORD *)v6 + 5) = 0x100000000;
    *((_QWORD *)v6 + 7) = 0;
    *((_QWORD *)v6 + 8) = &v247[v5 + 9];
    *((_QWORD *)v6 + 9) = 0x100000000;
    v5 += 12;
    *((_QWORD *)v6 + 11) = 0;
  }
  while (v5 != 36);
  v7 = *((_DWORD *)this + 14);
  v245 = 6;
  v246 = v7;
  v8 = v7 > 0;
  v9 = *((_BYTE *)this + 9) & 7;
  switch(v9)
  {
    case 4:
      v12 = &v245 + 24 * (v7 > 0);
      v13 = *((_DWORD *)this + 15);
      v14 = *((_DWORD *)this + 16);
      v15 = __OFSUB__(v13, v14);
      v16 = v13 - v14;
      *v12 = 7;
      v12[1] = v16;
      if ((v16 < 0) ^ v15 | (v16 == 0))
        v17 = v8;
      else
        v17 = v8 + 1;
      v18 = &v245 + 24 * v17;
      *v18 = 8;
      v18[1] = v14;
      v220 = v17;
      v222 = v8;
      if (v14 <= 0)
        v11 = v17;
      else
        v11 = v17 + 1;
      break;
    case 3:
      v19 = &v245 + 24 * (v7 > 0);
      v20 = *((_DWORD *)this + 15);
      v21 = v19[1];
      v15 = __OFADD__(v21, v20);
      v22 = v21 + v20;
      *v19 = 9;
      v19[1] = v22;
      if ((v22 < 0) ^ v15 | (v22 == 0))
        v11 = v8;
      else
        v11 = v8 + 1;
      v220 = v8;
      v222 = v8;
      break;
    case 2:
      v220 = 0;
      v222 = 0;
      v10 = *((_DWORD *)this + 15);
      v246 = v10 + v7;
      if ((v246 < 0) ^ __OFADD__(v10, v7) | (v246 == 0))
        v11 = 0;
      else
        v11 = 1;
      break;
    default:
      v11 = v7 > 0;
      v220 = 2;
      v222 = 1;
      break;
  }
  v23 = v11;
  std::vector<OpenSubdiv::v3_1_1::Far::PatchTable::PatchArray>::reserve((char **)a2 + 1, v11);
  v228 = 0;
  v227 = 0;
  if (v11)
  {
    v25 = &v246;
    v26 = v23;
    do
    {
      v27 = *v25;
      v226 = *(v25 - 1);
      OpenSubdiv::v3_1_1::Far::PatchTable::pushPatchArray(a2, &v226, v27, (int *)&v228 + 1, (int *)&v228, &v227);
      v25 += 24;
      --v26;
    }
    while (v26);
  }
  v217 = *((_WORD *)this + 4);
  OpenSubdiv::v3_1_1::Far::PatchTableFactory::allocateVertexTables(this, a2, v24);
  if (*((_QWORD *)this + 18) != *((_QWORD *)this + 19))
    OpenSubdiv::v3_1_1::Far::PatchTableFactory::allocateFVarChannels(this, a2, v28);
  if ((_DWORD)v23)
  {
    v29 = 0;
    v223 = v23;
    do
    {
      PatchArrayVertices = OpenSubdiv::v3_1_1::Far::PatchTable::getPatchArrayVertices(a2, v29);
      v31 = &v245 + 24 * v29;
      *((_QWORD *)v31 + 1) = PatchArrayVertices;
      v32 = *(int *)(*((_QWORD *)a2 + 1) + 20 * (int)v29 + 12);
      *((_QWORD *)v31 + 2) = *((_QWORD *)a2 + 7) + 8 * v32;
      if ((v217 & 4) != 0)
        v247[12 * v29 + 2] = *((_QWORD *)a2 + 28) + 4 * v32;
      v33 = *((_QWORD *)this + 18);
      v34 = *((_QWORD *)this + 19);
      if (v33 != v34)
      {
        v35 = &v247[12 * v29 + 3];
        v36 = v34 - v33;
        v37 = (unint64_t)(v34 - v33) >> 2;
        if ((_DWORD)v37)
        {
          v38 = &v245 + 24 * v29;
          v40 = v38[11];
          v39 = v38 + 11;
          if (v40 < v37)
          {
            v41 = (void **)(&v245 + 24 * v29);
            operator delete(v41[7]);
            *v35 = (uint64_t)(v41 + 6);
            *v39 = 1;
            v42 = operator new((2 * v36) & 0x7FFFFFFF8);
            v41[7] = v42;
            *v35 = (uint64_t)v42;
            *v39 = v37;
          }
        }
        else
        {
          v43 = (void **)(&v245 + 24 * v29);
          operator delete(v43[7]);
          *v35 = (uint64_t)(v43 + 6);
          *((_DWORD *)v43 + 11) = 1;
        }
        v44 = &v245 + 24 * v29;
        v44[10] = v37;
        v45 = v44 + 16;
        v46 = *((_QWORD *)this + 19) - *((_QWORD *)this + 18);
        v47 = v46 >> 2;
        if ((v46 >> 2))
        {
          v48 = &v245 + 24 * v29;
          v50 = v48[19];
          v49 = v48 + 19;
          if (v50 < v47)
          {
            v51 = (void **)(&v245 + 24 * v29);
            operator delete(v51[11]);
            *v45 = v51 + 10;
            *v49 = 1;
            v52 = operator new((2 * v46) & 0x7FFFFFFF8);
            v51[11] = v52;
            v23 = v223;
            *v45 = v52;
            *v49 = v47;
          }
        }
        else
        {
          v53 = (void **)(&v245 + 24 * v29);
          operator delete(v53[11]);
          *v45 = v53 + 10;
          *((_DWORD *)v53 + 19) = 1;
        }
        LODWORD(v247[12 * v29 + 8]) = v47;
        if ((int)((*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 2) >= 1)
        {
          v54 = 0;
          v55 = 0;
          do
          {
            v56 = *((_QWORD *)a2 + 22) + v54;
            v57 = *(_DWORD *)(v56 + 4) - 1;
            if (v57 > 8)
              v58 = -1;
            else
              v58 = dword_22619D128[v57];
            v59 = *(int *)(*((_QWORD *)a2 + 1) + 20 * (int)v29 + 12);
            *(_QWORD *)(*v35 + 8 * v55) = *(_QWORD *)(v56 + 8) + 4 * v58 * (int)v59;
            *(_QWORD *)(*v45 + 8 * v55++) = *(_QWORD *)(*((_QWORD *)a2 + 22) + v54 + 32) + 8 * v59;
            v54 += 56;
          }
          while (v55 < (int)((*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 2));
        }
      }
      ++v29;
    }
    while (v29 != v23);
  }
  v60 = &v243;
  v241 = &v243;
  v242 = 0x100000000;
  v244 = 0;
  v61 = &v239;
  v236 = 0;
  v237 = &v239;
  v238 = 0x100000000;
  __p = 0;
  v62 = &v235;
  v233 = &v235;
  v234 = 0x100000000;
  v63 = *((_BYTE *)this + 9) & 7;
  if (v63 == 2)
  {
    v64 = operator new();
    *(_QWORD *)v64 = &off_24ED89DD0;
    *(_DWORD *)(v64 + 8) = 0;
    *(_OWORD *)(v64 + 16) = 0u;
    *(_OWORD *)(v64 + 32) = 0u;
    *(_OWORD *)(v64 + 48) = 0u;
    *(_OWORD *)(v64 + 64) = 0u;
    *(_OWORD *)(v64 + 80) = 0u;
    *(_OWORD *)(v64 + 96) = 0u;
    v65 = operator new();
    *(_QWORD *)v65 = &off_24ED89DD0;
    *(_DWORD *)(v65 + 8) = 0;
    *(_OWORD *)(v65 + 16) = 0u;
    *(_OWORD *)(v65 + 32) = 0u;
    *(_OWORD *)(v65 + 48) = 0u;
    *(_OWORD *)(v65 + 64) = 0u;
    *(_OWORD *)(v65 + 80) = 0u;
    *(_OWORD *)(v65 + 96) = 0u;
    v210 = (OpenSubdiv::v3_1_1::Far::EndCapBSplineBasisPatchFactory *)operator new();
    OpenSubdiv::v3_1_1::Far::EndCapBSplineBasisPatchFactory::EndCapBSplineBasisPatchFactory(v210, v215, (OpenSubdiv::v3_1_1::Far::StencilTable *)v64, (OpenSubdiv::v3_1_1::Far::StencilTable *)v65);
    v212 = 0;
LABEL_51:
    v211 = 0;
    goto LABEL_52;
  }
  if (v63 == 3)
  {
    v64 = operator new();
    *(_QWORD *)v64 = &off_24ED89DD0;
    *(_DWORD *)(v64 + 8) = 0;
    *(_OWORD *)(v64 + 16) = 0u;
    *(_OWORD *)(v64 + 32) = 0u;
    *(_OWORD *)(v64 + 48) = 0u;
    *(_OWORD *)(v64 + 64) = 0u;
    *(_OWORD *)(v64 + 80) = 0u;
    *(_OWORD *)(v64 + 96) = 0u;
    v65 = operator new();
    *(_QWORD *)v65 = &off_24ED89DD0;
    *(_DWORD *)(v65 + 8) = 0;
    *(_OWORD *)(v65 + 16) = 0u;
    *(_OWORD *)(v65 + 32) = 0u;
    *(_OWORD *)(v65 + 48) = 0u;
    *(_OWORD *)(v65 + 64) = 0u;
    *(_OWORD *)(v65 + 80) = 0u;
    *(_OWORD *)(v65 + 96) = 0u;
    v212 = (OpenSubdiv::v3_1_1::Far::EndCapGregoryBasisPatchFactory *)operator new();
    OpenSubdiv::v3_1_1::Far::EndCapGregoryBasisPatchFactory::EndCapGregoryBasisPatchFactory(v212, v215, (OpenSubdiv::v3_1_1::Far::StencilTable *)v64, (OpenSubdiv::v3_1_1::Far::StencilTable *)v65, (*((_WORD *)this + 4) & 0x800) != 0);
    v210 = 0;
    goto LABEL_51;
  }
  v210 = 0;
  v211 = 0;
  v212 = 0;
  v64 = 0;
  v65 = 0;
  if (v63 == 4)
  {
    v210 = 0;
    v211 = operator new();
    v212 = 0;
    v64 = 0;
    v65 = 0;
    *(_QWORD *)v211 = v215;
    *(_OWORD *)(v211 + 8) = 0u;
    *(_OWORD *)(v211 + 24) = 0u;
    *(_OWORD *)(v211 + 40) = 0u;
    *(_OWORD *)(v211 + 56) = 0u;
    *(_OWORD *)(v211 + 72) = 0u;
    *(_OWORD *)(v211 + 88) = 0u;
  }
LABEL_52:
  v67 = *((_QWORD *)this + 18);
  v66 = *((_QWORD *)this + 19);
  if (v67 == v66)
    goto LABEL_78;
  v68 = v66 - v67;
  v69 = (unint64_t)(v66 - v67) >> 2;
  if (!(_DWORD)v69)
  {
    operator delete(v244);
    v70 = 1;
    goto LABEL_57;
  }
  if (HIDWORD(v242) < v69)
  {
    operator delete(v244);
    v241 = &v243;
    HIDWORD(v242) = 1;
    v60 = (uint64_t *)operator new((2 * v68) & 0x7FFFFFFF8);
    v244 = v60;
    v70 = v69;
LABEL_57:
    v241 = v60;
    HIDWORD(v242) = v70;
    v67 = *((_QWORD *)this + 18);
    v66 = *((_QWORD *)this + 19);
    v68 = v66 - v67;
    v71 = (unint64_t)(v66 - v67) >> 2;
    goto LABEL_59;
  }
  v71 = (unint64_t)(v66 - v67) >> 2;
LABEL_59:
  LODWORD(v242) = v69;
  if (!(_DWORD)v71)
  {
    operator delete(__p);
    v72 = 1;
    goto LABEL_63;
  }
  if (HIDWORD(v238) < v71)
  {
    operator delete(__p);
    v237 = &v239;
    HIDWORD(v238) = 1;
    v61 = (uint64_t *)operator new((2 * v68) & 0x7FFFFFFF8);
    __p = v61;
    v72 = v71;
LABEL_63:
    v237 = v61;
    HIDWORD(v238) = v72;
    v67 = *((_QWORD *)this + 18);
    v66 = *((_QWORD *)this + 19);
    v68 = v66 - v67;
    v73 = (unint64_t)(v66 - v67) >> 2;
    goto LABEL_65;
  }
  LODWORD(v73) = v71;
LABEL_65:
  LODWORD(v238) = v71;
  if ((_DWORD)v73)
  {
    LODWORD(v74) = v73;
    if (HIDWORD(v234) >= v73)
      goto LABEL_70;
    operator delete(v236);
    v233 = &v235;
    HIDWORD(v234) = 1;
    v62 = (uint64_t *)operator new((2 * v68) & 0x7FFFFFFF8);
    v236 = v62;
    v75 = v73;
  }
  else
  {
    operator delete(v236);
    v75 = 1;
  }
  v233 = v62;
  HIDWORD(v234) = v75;
  v67 = *((_QWORD *)this + 18);
  v66 = *((_QWORD *)this + 19);
  v74 = (unint64_t)(v66 - v67) >> 2;
LABEL_70:
  LODWORD(v234) = v73;
  if ((int)v74 >= 1)
  {
    v76 = 0;
    while (1)
    {
      v77 = *((_BYTE *)this + 9) & 7;
      if (v77 == 2)
        break;
      if (v77 == 3)
      {
        v78 = operator new();
        *(_QWORD *)v78 = &off_24ED89DD0;
        *(_DWORD *)(v78 + 8) = 0;
        *(_OWORD *)(v78 + 16) = 0u;
        *(_OWORD *)(v78 + 32) = 0u;
        *(_OWORD *)(v78 + 48) = 0u;
        *(_OWORD *)(v78 + 64) = 0u;
        *(_OWORD *)(v78 + 80) = 0u;
        *(_OWORD *)(v78 + 96) = 0u;
        v233[v76] = v78;
        v79 = (OpenSubdiv::v3_1_1::Far::EndCapGregoryBasisPatchFactory *)operator new();
        v80 = OpenSubdiv::v3_1_1::Far::EndCapGregoryBasisPatchFactory::EndCapGregoryBasisPatchFactory(v79, v215, (OpenSubdiv::v3_1_1::Far::StencilTable *)v233[v76], 0, (*((_WORD *)this + 4) & 0x800) != 0);
        v81 = &v237;
LABEL_76:
        (*v81)[v76] = (uint64_t)v80;
        v67 = *((_QWORD *)this + 18);
        v66 = *((_QWORD *)this + 19);
      }
      if (++v76 >= (int)((unint64_t)(v66 - v67) >> 2))
        goto LABEL_78;
    }
    v82 = operator new();
    *(_QWORD *)v82 = &off_24ED89DD0;
    *(_DWORD *)(v82 + 8) = 0;
    *(_OWORD *)(v82 + 16) = 0u;
    *(_OWORD *)(v82 + 32) = 0u;
    *(_OWORD *)(v82 + 48) = 0u;
    *(_OWORD *)(v82 + 64) = 0u;
    *(_OWORD *)(v82 + 80) = 0u;
    *(_OWORD *)(v82 + 96) = 0u;
    v233[v76] = v82;
    v83 = (OpenSubdiv::v3_1_1::Far::EndCapBSplineBasisPatchFactory *)operator new();
    v80 = OpenSubdiv::v3_1_1::Far::EndCapBSplineBasisPatchFactory::EndCapBSplineBasisPatchFactory(v83, v215, (OpenSubdiv::v3_1_1::Far::StencilTable *)v233[v76], 0);
    v81 = &v241;
    goto LABEL_76;
  }
LABEL_78:
  v207 = v65;
  v208 = (OpenSubdiv::v3_1_1::Far::StencilTable *)v64;
  v84 = *((_QWORD *)this + 9);
  if ((int)((unint64_t)(*((_QWORD *)this + 10) - v84) >> 3) >= 1)
  {
    v85 = 0;
    v206 = &v245 + 24 * v220;
    v209 = (_DWORD **)(v206 + 2);
    v213 = &v247[12 * v222];
    v214 = (_QWORD *)((char *)a2 + 264);
    do
    {
      v86 = (int *)(v84 + 8 * v85);
      v87 = v86 + 1;
      v88 = *(OpenSubdiv::v3_1_1::Vtr::internal::Level **)(*((_QWORD *)v215 + 5) + 8 * v86[1]);
      FaceCompositeVTag = OpenSubdiv::v3_1_1::Vtr::internal::Level::getFaceCompositeVTag(v88, *v86, 0xFFFFFFFF);
      memset(v232, 0, sizeof(v232));
      IsPatchRegular = OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::IsPatchRegular(this, v86[1], *v86, 0xFFFFFFFF);
      v91 = v86[1];
      v92 = *v86;
      v221 = IsPatchRegular;
      v216 = v85;
      if (IsPatchRegular)
      {
        RegularPatchBoundaryMask = OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GetRegularPatchBoundaryMask(this, v91, v92, 0xFFFFFFFF);
        v94 = RegularPatchBoundaryMask;
        v218 = 0;
        v95 = 0.0;
        if ((v217 & 4) == 0 || RegularPatchBoundaryMask)
        {
          v97 = RegularPatchBoundaryMask;
        }
        else
        {
          if ((FaceCompositeVTag & 0x1040) == 0)
            goto LABEL_94;
          LODWORD(v229) = 0;
          v225 = 0;
          if (!OpenSubdiv::v3_1_1::Vtr::internal::Level::isSingleCreasePatch(v88, *v86, (float *)&v229, &v225))goto LABEL_94;
          v96 = (float)((*((_WORD *)this + 4) >> 4) - *v87);
          if (*(float *)&v229 <= v96)
            v96 = *(float *)&v229;
          if (v96 > 0.0)
          {
            v94 = 0;
            v218 = 1;
            v97 = 1 << v225;
            v95 = v96;
          }
          else
          {
LABEL_94:
            v94 = 0;
            v97 = 0;
            v218 = 0;
          }
        }
        OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GatherRegularPatchPoints(this, v247[0], *v86, v86[1], v94, 0xFFFFFFFF);
        v247[0] += 64;
        v101 = *v87;
        if ((_DWORD)v101 == ((*(unsigned __int8 *)(*(_QWORD *)this + 8) >> 2) & 0xF))
          LOBYTE(v102) = 0;
        else
          v102 = (*(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 64) + 8 * v101) + 408)
                                     + *v86) >> 1) & 0xF;
        v103 = &v245;
      }
      else
      {
        OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GetIrregularPatchCornerSpans((uint64_t)this, v91, v92, (uint64_t)v232, 0xFFFFFFFF);
        v98 = *((_BYTE *)this + 9) & 7;
        v95 = 0.0;
        if (v98 == 2)
        {
          v99 = &v247[12 * v222];
          v100 = OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GatherIrregularPatchPoints<OpenSubdiv::v3_1_1::Far::EndCapBSplineBasisPatchFactory>(this, (uint64_t)v210, (_DWORD *)*v213, *v86, v86[1], (__int16 *)v232, 0xFFFFFFFF);
LABEL_100:
          v218 = 0;
          v97 = 0;
          LOBYTE(v102) = 0;
          *v99 += 4 * v100;
          goto LABEL_107;
        }
        if (v98 != 4)
        {
          if (v98 == 3)
          {
            v99 = &v247[12 * v222];
            v100 = OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GatherIrregularPatchPoints<OpenSubdiv::v3_1_1::Far::EndCapGregoryBasisPatchFactory>((uint64_t)this, (uint64_t)v212, (_DWORD *)*v213);
            goto LABEL_100;
          }
          v218 = 0;
          v97 = 0;
          LOBYTE(v102) = 0;
LABEL_107:
          v103 = &v245 + 24 * v222;
          goto LABEL_108;
        }
        v104 = *v86;
        v105 = v86[1];
        v106 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)this + 40) + 8 * v105);
        v107 = *(_DWORD *)(*((_QWORD *)this + 12) + 4 * v105);
        if ((FaceCompositeVTag & 4) != 0)
        {
          v155 = *v209;
          PatchPoints = (int *)OpenSubdiv::v3_1_1::Far::EndCapLegacyGregoryPatchFactory::GetPatchPoints((_QWORD *)v211, v106, v104, (uint64_t)v232, v107, 0xFFFFFFFF);
          if (v157 >= 1)
          {
            v158 = v157;
            do
            {
              v159 = *PatchPoints++;
              *v155++ = v159;
              --v158;
            }
            while (v158);
          }
          v218 = 0;
          v97 = 0;
          LOBYTE(v102) = 0;
          *v209 += v157;
          v103 = v206;
        }
        else
        {
          v108 = (_DWORD *)*v213;
          v109 = (int *)OpenSubdiv::v3_1_1::Far::EndCapLegacyGregoryPatchFactory::GetPatchPoints((_QWORD *)v211, v106, v104, (uint64_t)v232, v107, 0xFFFFFFFF);
          if (v110 >= 1)
          {
            v111 = v110;
            do
            {
              v112 = *v109++;
              *v108++ = v112;
              --v111;
            }
            while (v111);
          }
          v218 = 0;
          v97 = 0;
          LOBYTE(v102) = 0;
          v103 = &v245 + 24 * v222;
          *v213 += 4 * v110;
        }
      }
LABEL_108:
      v113 = OpenSubdiv::v3_1_1::Far::PatchTableFactory::computePatchParam(*(_QWORD **)this, *((_QWORD *)this + 4), *v87, *v86, v97, v102);
      v114 = (unint64_t *)*((_QWORD *)v103 + 2);
      *((_QWORD *)v103 + 2) = v114 + 1;
      v224 = v113;
      *v114 = v113;
      if ((v217 & 4) != 0)
      {
        v115 = (float *)*((_QWORD *)a2 + 31);
        v116 = (float *)*((_QWORD *)a2 + 32);
        v117 = v116 - v115;
        if ((int)v117 < 1)
        {
LABEL_113:
          if ((unint64_t)v116 >= *v214)
          {
            v120 = v117 + 1;
            if ((unint64_t)(v117 + 1) >> 62)
              abort();
            v121 = *v214 - (_QWORD)v115;
            if (v121 >> 1 > v120)
              v120 = v121 >> 1;
            if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFFCLL)
              v122 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v122 = v120;
            if (v122)
            {
              v123 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)v214, v122);
              v115 = (float *)*((_QWORD *)a2 + 31);
              v116 = (float *)*((_QWORD *)a2 + 32);
            }
            else
            {
              v123 = 0;
            }
            v124 = (float *)&v123[4 * v117];
            *v124 = v95;
            v119 = v124 + 1;
            while (v116 != v115)
            {
              v125 = *((_DWORD *)v116-- - 1);
              *((_DWORD *)v124-- - 1) = v125;
            }
            *((_QWORD *)a2 + 31) = v124;
            *((_QWORD *)a2 + 32) = v119;
            *((_QWORD *)a2 + 33) = &v123[4 * v122];
            if (v115)
            {
              operator delete(v115);
              v115 = (float *)*((_QWORD *)a2 + 31);
            }
            else
            {
              v115 = v124;
            }
          }
          else
          {
            *v116 = v95;
            v119 = v116 + 1;
          }
          *((_QWORD *)a2 + 32) = v119;
          LODWORD(v118) = ((unint64_t)((char *)v119 - (char *)v115) >> 2) - 1;
        }
        else
        {
          v118 = 0;
          while (v115[v118] != v95)
          {
            if (((unint64_t)((char *)v116 - (char *)v115) >> 2) == ++v118)
              goto LABEL_113;
          }
        }
        v126 = (_DWORD *)*((_QWORD *)v103 + 3);
        *v126 = v118;
        *((_QWORD *)v103 + 3) = v126 + 1;
      }
      v219 = v97;
      v128 = *((_QWORD *)this + 18);
      v127 = *((_QWORD *)this + 19);
      if (v128 != v127 && (int)((unint64_t)(v127 - v128) >> 2) >= 1)
      {
        v129 = 0;
        while (1)
        {
          v130 = *v86;
          v131 = *v87;
          v132 = *(_DWORD *)(*((_QWORD *)a2 + 22) + 56 * (int)v129 + 4);
          if (v132 == 3)
          {
            v133 = *(_QWORD **)(*(_QWORD *)(*(_QWORD *)this + 40) + 8 * v131);
            if ((v129 & 0x80000000) != 0)
            {
              v134 = *(_DWORD *)(*((_QWORD *)this + 12) + 4 * v131);
            }
            else
            {
              v134 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 15) + 24 * v129) + 4 * v131);
              v135 = *(unsigned int *)(v128 + 4 * v129);
              if ((v135 & 0x80000000) == 0)
              {
                v136 = *(_QWORD **)(v133[57] + 8 * v135);
                v137 = *(_QWORD *)(*v136 + 24);
                v138 = (unsigned int *)(v137 + 8 * v130);
                v139 = (int *)(v136[3] + 4 * *(int *)(v137 + 4 * (int)((2 * v130) | 1)));
LABEL_148:
                v143 = *((_QWORD *)v103 + 4);
                v144 = *(_QWORD *)(v143 + 8 * v129);
                v145 = *v138;
                if ((int)v145 >= 1)
                {
                  v146 = *(_DWORD **)(v143 + 8 * v129);
                  v147 = v145;
                  do
                  {
                    v148 = *v139++;
                    *v146++ = v148 + v134;
                    --v147;
                  }
                  while (v147);
                }
                *(_QWORD *)(v143 + 8 * v129) = v144 + 4 * (int)v145;
                v149 = *((_QWORD *)v103 + 8);
                v150 = *(unint64_t **)(v149 + 8 * v129);
                *(_QWORD *)(v149 + 8 * v129) = v150 + 1;
                *v150 = v224;
                goto LABEL_163;
              }
            }
            v142 = v133[3];
            v139 = (int *)(v133[6] + 4 * *(int *)(v142 + 4 * (int)((2 * v130) | 1)));
            v138 = (unsigned int *)(v142 + 8 * v130);
            goto LABEL_148;
          }
          if ((OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getFaceCompositeValueTag(*(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 40)+ 8 * v131)+ 456)+ 8 * *(int *)(v128 + 4 * v129)), *v86) & 1) != 0)break;
          if (!v221)
          {
            v229 = 0;
            v230 = 0;
            v151 = (__int16 *)v232;
            v231 = 0;
LABEL_154:
            if (v132 == 9)
            {
              OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GatherIrregularPatchPoints<OpenSubdiv::v3_1_1::Far::EndCapGregoryBasisPatchFactory>((uint64_t)this, v237[v129], *(_DWORD **)(*((_QWORD *)v103 + 4) + 8 * v129));
            }
            else if (v132 == 6)
            {
              OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GatherIrregularPatchPoints<OpenSubdiv::v3_1_1::Far::EndCapBSplineBasisPatchFactory>(this, v241[v129], *(_DWORD **)(*((_QWORD *)v103 + 4) + 8 * v129), v130, v131, v151, v129);
            }
            v141 = 0;
            LOBYTE(v140) = 0;
            goto LABEL_159;
          }
          v140 = v219;
          if (!v218)
            goto LABEL_145;
          OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GatherRegularPatchPoints(this, *(_QWORD *)(*((_QWORD *)v103 + 4) + 8 * v129), v130, v131, 0, v129);
          v141 = 0x2000000000;
          LOBYTE(v140) = v219;
LABEL_159:
          if ((v132 - 1) > 8)
            v152 = -1;
          else
            v152 = qword_22619D150[v132 - 1];
          *(_QWORD *)(*((_QWORD *)v103 + 4) + 8 * v129) += 4 * v152;
          v153 = *((_QWORD *)v103 + 8);
          v154 = *(unint64_t **)(v153 + 8 * v129);
          *(_QWORD *)(v153 + 8 * v129) = v154 + 1;
          *v154 = v141 | v224 & 0xFFFFF01FFFFFFFFFLL | ((unint64_t)(v140 & 0xF) << 40);
LABEL_163:
          ++v129;
          v128 = *((_QWORD *)this + 18);
          if (v129 >= (int)((unint64_t)(*((_QWORD *)this + 19) - v128) >> 2))
            goto LABEL_164;
        }
        if (!OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::IsPatchRegular(this, v131, v130, v129))
        {
          v229 = 0;
          v230 = 0;
          v231 = 0;
          v151 = (__int16 *)&v229;
          OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GetIrregularPatchCornerSpans((uint64_t)this, *v87, *v86, (uint64_t)&v229, v129);
          goto LABEL_154;
        }
        v140 = OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GetRegularPatchBoundaryMask(this, *v87, *v86, v129);
LABEL_145:
        OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GatherRegularPatchPoints(this, *(_QWORD *)(*((_QWORD *)v103 + 4) + 8 * v129), v130, v131, v140, v129);
        v141 = 0x2000000000;
        goto LABEL_159;
      }
LABEL_164:
      v85 = v216 + 1;
      v84 = *((_QWORD *)this + 9);
    }
    while (v216 + 1 < (int)((unint64_t)(*((_QWORD *)this + 10) - v84) >> 3));
  }
  OpenSubdiv::v3_1_1::Far::PatchTable::populateVaryingVertices((uint64_t)a2);
  v160 = v208;
  if (v208)
  {
    v161 = v207;
    if ((int)((*((_QWORD *)v208 + 3) - *((_QWORD *)v208 + 2)) >> 2) < 1)
    {
      (*(void (**)(OpenSubdiv::v3_1_1::Far::StencilTable *))(*(_QWORD *)v208 + 8))(v208);
      v160 = 0;
      if (!v207)
        goto LABEL_186;
      goto LABEL_178;
    }
    OpenSubdiv::v3_1_1::Far::StencilTable::shrinkToFit(v208);
    std::vector<unsigned int>::resize((std::vector<int> *)((char *)v208 + 40), (int)((uint64_t)(*((_QWORD *)v208 + 3) - *((_QWORD *)v208 + 2)) >> 2));
    v162 = (int *)*((_QWORD *)v208 + 2);
    v163 = *((_QWORD *)v208 + 3) - (_QWORD)v162;
    if ((int)(v163 >> 2) >= 1)
    {
      v164 = 0;
      v165 = (_DWORD *)*((_QWORD *)v208 + 5);
      v166 = (v163 >> 2);
      do
      {
        *v165++ = v164;
        v167 = *v162++;
        v164 += v167;
        --v166;
      }
      while (v166);
    }
  }
  else
  {
    v161 = v207;
  }
  if (!v161)
    goto LABEL_186;
LABEL_178:
  if ((int)((*(_QWORD *)(v161 + 24) - *(_QWORD *)(v161 + 16)) >> 2) < 1)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v161 + 8))(v161);
    v161 = 0;
  }
  else
  {
    OpenSubdiv::v3_1_1::Far::StencilTable::shrinkToFit((OpenSubdiv::v3_1_1::Far::StencilTable *)v161);
    std::vector<unsigned int>::resize((std::vector<int> *)(v161 + 40), (int)((uint64_t)(*(_QWORD *)(v161 + 24) - *(_QWORD *)(v161 + 16)) >> 2));
    v168 = *(int **)(v161 + 16);
    v169 = *(_QWORD *)(v161 + 24) - (_QWORD)v168;
    if ((int)(v169 >> 2) >= 1)
    {
      v170 = 0;
      v171 = *(_DWORD **)(v161 + 40);
      v172 = (v169 >> 2);
      do
      {
        *v171++ = v170;
        v173 = *v168++;
        v170 += v173;
        --v172;
      }
      while (v172);
    }
  }
LABEL_186:
  v174 = *((_BYTE *)this + 9) & 7;
  switch(v174)
  {
    case 2:
      *((_QWORD *)a2 + 16) = v160;
      *((_QWORD *)a2 + 17) = v161;
      if (v210)
      {
        v184 = (void *)*((_QWORD *)v210 + 4);
        if (v184)
        {
          *((_QWORD *)v210 + 5) = v184;
          operator delete(v184);
        }
        v177 = v210;
        v178 = 1232653951;
        goto LABEL_209;
      }
      break;
    case 4:
      OpenSubdiv::v3_1_1::Far::EndCapLegacyGregoryPatchFactory::Finalize((_QWORD *)v211, *(_DWORD *)a2, (std::vector<int> *)((char *)a2 + 80), (std::vector<int> *)((char *)a2 + 104), (unsigned int *)0xFFFFFFFFLL);
      if (v211)
      {
        v179 = *(void **)(v211 + 80);
        if (v179)
        {
          *(_QWORD *)(v211 + 88) = v179;
          operator delete(v179);
        }
        v180 = *(void **)(v211 + 56);
        if (v180)
        {
          *(_QWORD *)(v211 + 64) = v180;
          operator delete(v180);
        }
        v181 = *(void **)(v211 + 32);
        if (v181)
        {
          *(_QWORD *)(v211 + 40) = v181;
          operator delete(v181);
        }
        v182 = *(void **)(v211 + 8);
        if (v182)
        {
          *(_QWORD *)(v211 + 16) = v182;
          operator delete(v182);
        }
        v177 = (OpenSubdiv::v3_1_1::Far::EndCapGregoryBasisPatchFactory *)v211;
        v183 = 0x70C40F9997B92;
        goto LABEL_210;
      }
      break;
    case 3:
      *((_QWORD *)a2 + 16) = v160;
      *((_QWORD *)a2 + 17) = v161;
      if (v212)
      {
        v175 = (void *)*((_QWORD *)v212 + 8);
        if (v175)
        {
          *((_QWORD *)v212 + 9) = v175;
          operator delete(v175);
        }
        v176 = (void *)*((_QWORD *)v212 + 5);
        if (v176)
        {
          *((_QWORD *)v212 + 6) = v176;
          operator delete(v176);
        }
        v177 = v212;
        v178 = 537674454;
LABEL_209:
        v183 = v178 | 0x1070C4000000000;
LABEL_210:
        MEMORY[0x2276933B8](v177, v183);
      }
      break;
  }
  v185 = *((_QWORD *)this + 18);
  v186 = *((_QWORD *)this + 19);
  if (v185 != v186)
  {
    v187 = (_QWORD *)((char *)a2 + 200);
    std::vector<OpenSubdiv::v3_1_1::Far::PatchParam>::resize((uint64_t)v187, (v186 - v185) >> 2);
    if ((int)((*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 2) >= 1)
    {
      v188 = 0;
      while (1)
      {
        v189 = v233[v188];
        if ((int)((*(_QWORD *)(v189 + 24) - *(_QWORD *)(v189 + 16)) >> 2) < 1)
        {
          (*(void (**)(uint64_t))(*(_QWORD *)v189 + 8))(v233[v188]);
          v233[v188] = 0;
        }
        else
        {
          OpenSubdiv::v3_1_1::Far::StencilTable::shrinkToFit((OpenSubdiv::v3_1_1::Far::StencilTable *)v233[v188]);
          std::vector<unsigned int>::resize((std::vector<int> *)(v189 + 40), (int)((uint64_t)(*(_QWORD *)(v189 + 24) - *(_QWORD *)(v189 + 16)) >> 2));
          v190 = *(int **)(v189 + 16);
          v191 = *(_QWORD *)(v189 + 24) - (_QWORD)v190;
          if ((int)(v191 >> 2) >= 1)
          {
            v192 = 0;
            v193 = *(_DWORD **)(v189 + 40);
            v194 = (v191 >> 2);
            do
            {
              *v193++ = v192;
              v195 = *v190++;
              v192 += v195;
              --v194;
            }
            while (v194);
          }
        }
        v196 = *((_BYTE *)this + 9) & 7;
        if (v196 != 2)
          break;
        v202 = (_QWORD *)v241[v188];
        if (v202)
        {
          v203 = (void *)v202[4];
          if (v203)
          {
            v202[5] = v203;
            operator delete(v203);
          }
          v200 = v202;
          v201 = 1232653951;
LABEL_232:
          MEMORY[0x2276933B8](v200, v201 | 0x1070C4000000000);
        }
LABEL_233:
        *(_QWORD *)(*v187 + 8 * v188) = v233[v188];
        if (++v188 >= (int)((*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 2))
          goto LABEL_234;
      }
      if (v196 != 3)
        goto LABEL_233;
      v197 = (_QWORD *)v237[v188];
      if (!v197)
        goto LABEL_233;
      v198 = (void *)v197[8];
      if (v198)
      {
        v197[9] = v198;
        operator delete(v198);
      }
      v199 = (void *)v197[5];
      if (v199)
      {
        v197[6] = v199;
        operator delete(v199);
      }
      v200 = v197;
      v201 = 537674454;
      goto LABEL_232;
    }
  }
LABEL_234:
  operator delete(v236);
  operator delete(__p);
  operator delete(v244);
  v204 = 288;
  do
  {
    v205 = (char *)&v245 + v204;
    operator delete((&v244)[(unint64_t)v204 / 8]);
    *((_QWORD *)v205 - 4) = v205 - 16;
    *((_DWORD *)v205 - 5) = 1;
    operator delete(*(void **)((char *)&__p + v204));
    *((_QWORD *)v205 - 8) = v205 - 48;
    *((_DWORD *)v205 - 13) = 1;
    v204 -= 96;
  }
  while (v204);
}

uint64_t OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GatherIrregularPatchPoints<OpenSubdiv::v3_1_1::Far::EndCapGregoryBasisPatchFactory>(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v4;
  int *PatchPoints;
  uint64_t result;
  uint64_t v7;
  int v8;

  PatchPoints = (int *)OpenSubdiv::v3_1_1::Far::EndCapGregoryBasisPatchFactory::GetPatchPoints(a2);
  result = v4;
  if ((int)v4 >= 1)
  {
    v7 = v4;
    do
    {
      v8 = *PatchPoints++;
      *a3++ = v8;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t OpenSubdiv::v3_1_1::Far::PatchTableFactory::BuilderContext::GatherIrregularPatchPoints<OpenSubdiv::v3_1_1::Far::EndCapBSplineBasisPatchFactory>(_QWORD *a1, uint64_t a2, _DWORD *a3, int a4, int a5, __int16 *a6, unsigned int a7)
{
  _QWORD *v9;
  unsigned int v10;
  uint64_t v11;
  int *PatchPoints;
  uint64_t result;
  uint64_t v14;
  int v15;

  if ((a7 & 0x80000000) != 0)
  {
    v9 = a1 + 12;
    v10 = -1;
  }
  else
  {
    v9 = (_QWORD *)(a1[15] + 24 * a7);
    v10 = *(_DWORD *)(a1[18] + 4 * a7);
  }
  PatchPoints = (int *)OpenSubdiv::v3_1_1::Far::EndCapBSplineBasisPatchFactory::GetPatchPoints(a2, *(_QWORD *)(*(_QWORD *)(*a1 + 40) + 8 * a5), a4, a6, *(_DWORD *)(*v9 + 4 * a5), v10);
  result = v11;
  if ((int)v11 >= 1)
  {
    v14 = v11;
    do
    {
      v15 = *PatchPoints++;
      *a3++ = v15;
      --v14;
    }
    while (v14);
  }
  return result;
}

void OpenSubdiv::v3_1_1::Far::StencilTable::shrinkToFit(OpenSubdiv::v3_1_1::Far::StencilTable *this)
{
  int *v2;
  int *value;
  int *v4;
  int *v5;
  int *v6;
  int *v7;
  int *v8;
  int *v9;
  int *v10;
  std::vector<int> v11;

  std::vector<float>::vector(&v11, (const std::vector<int> *)((char *)this + 16));
  v2 = (int *)*((_QWORD *)this + 2);
  *((_OWORD *)this + 1) = *(_OWORD *)&v11.__begin_;
  value = v11.__end_cap_.__value_;
  v4 = (int *)*((_QWORD *)this + 4);
  v11.__begin_ = v2;
  v11.__end_cap_.__value_ = v4;
  *((_QWORD *)this + 4) = value;
  if (v2)
  {
    v11.__end_ = v2;
    operator delete(v2);
  }
  std::vector<float>::vector(&v11, (const std::vector<int> *)((char *)this + 64));
  v5 = (int *)*((_QWORD *)this + 8);
  *((_OWORD *)this + 4) = *(_OWORD *)&v11.__begin_;
  v6 = v11.__end_cap_.__value_;
  v7 = (int *)*((_QWORD *)this + 10);
  v11.__begin_ = v5;
  v11.__end_cap_.__value_ = v7;
  *((_QWORD *)this + 10) = v6;
  if (v5)
  {
    v11.__end_ = v5;
    operator delete(v5);
  }
  std::vector<float>::vector(&v11, (const std::vector<int> *)((char *)this + 88));
  v8 = (int *)*((_QWORD *)this + 11);
  *(_OWORD *)((char *)this + 88) = *(_OWORD *)&v11.__begin_;
  v9 = v11.__end_cap_.__value_;
  v10 = (int *)*((_QWORD *)this + 13);
  v11.__begin_ = v8;
  v11.__end_cap_.__value_ = v10;
  *((_QWORD *)this + 13) = v9;
  if (v8)
  {
    v11.__end_ = v8;
    operator delete(v8);
  }
}

void std::vector<OpenSubdiv::v3_1_1::Far::PatchParam>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 3);
    if (v9 >> 61)
      abort();
    v10 = v8 >> 3;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 2 > v9)
      v9 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[8 * v10];
    v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    v16 = &v14[8 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_QWORD *)v17 - 1);
        v17 -= 8;
        *((_QWORD *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

OpenSubdiv::v3_1_1::Osd::CpuPatchTable *OpenSubdiv::v3_1_1::Osd::CpuPatchTable::CpuPatchTable(OpenSubdiv::v3_1_1::Osd::CpuPatchTable *this, const OpenSubdiv::v3_1_1::Far::PatchTable *a2)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  int *v9;
  int v10;
  int v11;
  int v12;
  std::vector<int>::size_type v13;
  int v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  BOOL v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  char *v27;
  char *v28;
  char *v29;
  size_t v30;
  char *v31;
  __int128 v32;
  _QWORD *v33;
  _QWORD *v34;
  OpenSubdiv::v3_1_1::Far::PatchTable *v35;
  void *v36;
  void *v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  void *v41;
  uint64_t v42;
  unint64_t v43;
  _QWORD *v44;
  _QWORD *v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  char *v53;
  char *v54;
  char *v55;
  size_t v56;
  char *v57;
  __int128 v58;
  _QWORD *v59;
  _QWORD *v60;
  OpenSubdiv::v3_1_1::Far::PatchTable *v61;
  void *v62;
  void *v63;
  _QWORD *v64;
  _QWORD *v65;
  void *v66;
  void *v67;
  size_t v68;
  OpenSubdiv::v3_1_1::Far::PatchTable *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  int v74;
  int v75;
  OpenSubdiv::v3_1_1::Far::PatchTable *v76;
  uint64_t v77;
  int *v78;
  int v79;
  int v80;
  uint64_t v81;
  int v82;
  _DWORD *v83;
  unint64_t v84;
  _DWORD *v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  char *v90;
  uint64_t v91;
  char *v92;
  uint64_t v93;
  uint64_t v94;
  char *v95;
  int v96;
  uint64_t v97;
  char *PatchArrayVertices;
  int v99;
  int v100;
  unint64_t v101;
  unint64_t v102;
  char *v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  unint64_t v107;
  char *v108;
  uint64_t v109;
  char *v110;
  char *v111;
  char *v112;
  char *v113;
  int v114;
  uint64_t v115;
  char *PatchArrayVaryingVertices;
  int v117;
  uint64_t v118;
  uint64_t v119;
  int v120;
  char **v121;
  unint64_t v122;
  char **v123;
  unint64_t v124;
  char *v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  unint64_t v129;
  char *v130;
  uint64_t v131;
  char *v132;
  char *v133;
  char *v134;
  char *v135;
  int v136;
  uint64_t v137;
  char *PatchArrayFVarValues;
  int v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  unint64_t *v143;
  unint64_t v144;
  _DWORD **v145;
  unint64_t v146;
  _QWORD *v147;
  _DWORD *v148;
  unint64_t v149;
  unint64_t v150;
  unint64_t v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  _DWORD *v155;
  _DWORD *v156;
  unint64_t v157;
  uint64_t v158;
  int v159;
  int v160;
  int v161;
  unint64_t v162;
  unint64_t v163;
  uint64_t v164;
  int v165;
  uint64_t v166;
  uint64_t v167;
  unint64_t v168;
  unint64_t v169;
  uint64_t v170;
  unint64_t v171;
  uint64_t v172;
  unint64_t v173;
  char *v174;
  char *v175;
  unint64_t v176;
  uint64_t v177;
  int v178;
  char **v180;
  std::vector<int> *v181;
  std::vector<int> *v182;
  int v183;
  _QWORD *v184;
  int v185[2];
  char **v186;
  OpenSubdiv::v3_1_1::Far::PatchTable *v187;

  *((_OWORD *)this + 3) = 0u;
  v186 = (char **)((char *)this + 48);
  v180 = (char **)((char *)this + 72);
  *((_OWORD *)this + 6) = 0u;
  v181 = (std::vector<int> *)((char *)this + 96);
  v182 = (std::vector<int> *)((char *)this + 24);
  *((_OWORD *)this + 9) = 0u;
  v184 = (_QWORD *)((char *)this + 144);
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  v4 = *((_QWORD *)a2 + 1);
  v5 = -858993459 * ((*((_QWORD *)a2 + 2) - v4) >> 2);
  if (v5 < 1)
  {
    v13 = 0;
    v183 = 0;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = -858993459 * ((*((_QWORD *)a2 + 2) - v4) >> 2);
    v9 = (int *)(v4 + 4);
    do
    {
      v10 = *(v9 - 1) - 1;
      if (v10 > 8)
        v11 = -1;
      else
        v11 = dword_22619D198[v10];
      v12 = *v9;
      v9 += 5;
      v6 += v12;
      v7 += v11 * v12;
      --v8;
    }
    while (v8);
    v183 = v6;
    v13 = v7;
  }
  std::vector<OpenSubdiv::v3_1_1::Osd::PatchArray>::reserve((char **)this, v5);
  std::vector<int>::reserve(v182, v13);
  std::vector<OpenSubdiv::v3_1_1::Osd::PatchArray>::reserve(v180, v5);
  v14 = *((_DWORD *)a2 + 36) - 1;
  if (v14 > 8)
    v15 = -1;
  else
    v15 = dword_22619D198[v14];
  std::vector<int>::reserve(v181, v15 * v183);
  v187 = a2;
  v16 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((_QWORD *)a2 + 23) - *((_QWORD *)a2 + 22)) >> 3);
  v17 = (int)v16;
  v18 = (_QWORD *)*((_QWORD *)this + 15);
  v19 = (_QWORD *)*((_QWORD *)this + 16);
  v20 = 0xAAAAAAAAAAAAAAABLL * (v19 - v18);
  v21 = (int)v16 >= v20;
  v22 = (int)v16 - v20;
  if ((int)v16 > v20)
  {
    v23 = *((_QWORD *)this + 17);
    if (0xAAAAAAAAAAAAAAABLL * ((v23 - (uint64_t)v19) >> 3) >= v22)
    {
      bzero(*((void **)this + 16), 24 * ((24 * v22 - 24) / 0x18) + 24);
      *((_QWORD *)this + 16) = &v19[3 * ((24 * v22 - 24) / 0x18) + 3];
      v35 = v187;
      goto LABEL_40;
    }
    if (v16 << 32 < 0)
      goto LABEL_164;
    v24 = 0xAAAAAAAAAAAAAAABLL * ((v23 - (uint64_t)v18) >> 3);
    v25 = 0x5555555555555556 * ((v23 - (uint64_t)v18) >> 3);
    if (v25 > v17)
      v17 = v25;
    if (v24 >= 0x555555555555555)
      v17 = 0xAAAAAAAAAAAAAAALL;
    if (v17 > 0xAAAAAAAAAAAAAAALL)
      goto LABEL_165;
    v26 = 3 * v17;
    v27 = (char *)operator new(24 * v17);
    v28 = &v27[8 * (v19 - v18)];
    v29 = &v27[8 * v26];
    v30 = 24 * ((24 * v22 - 24) / 0x18) + 24;
    bzero(v28, v30);
    v31 = &v28[v30];
    if (v19 == v18)
    {
      *((_QWORD *)this + 15) = v28;
      *((_QWORD *)this + 16) = v31;
      *((_QWORD *)this + 17) = v29;
    }
    else
    {
      do
      {
        v32 = *(_OWORD *)(v19 - 3);
        v19 -= 3;
        *(_OWORD *)(v28 - 24) = v32;
        v28 -= 24;
        *((_QWORD *)v28 + 2) = v19[2];
        *v19 = 0;
        v19[1] = 0;
        v19[2] = 0;
      }
      while (v19 != v18);
      v19 = (_QWORD *)*((_QWORD *)this + 15);
      v33 = (_QWORD *)*((_QWORD *)this + 16);
      *((_QWORD *)this + 15) = v28;
      *((_QWORD *)this + 16) = v31;
      *((_QWORD *)this + 17) = v29;
      if (v33 != v19)
      {
        v34 = v33;
        v35 = v187;
        do
        {
          v37 = (void *)*(v34 - 3);
          v34 -= 3;
          v36 = v37;
          if (v37)
          {
            *(v33 - 2) = v36;
            operator delete(v36);
          }
          v33 = v34;
        }
        while (v34 != v19);
        if (!v19)
          goto LABEL_40;
LABEL_39:
        operator delete(v19);
        goto LABEL_40;
      }
    }
    v35 = v187;
    if (!v19)
      goto LABEL_40;
    goto LABEL_39;
  }
  v35 = v187;
  if (!v21)
  {
    v38 = &v18[3 * (int)v16];
    if (v19 != v38)
    {
      v39 = (_QWORD *)*((_QWORD *)this + 16);
      do
      {
        v41 = (void *)*(v39 - 3);
        v39 -= 3;
        v40 = v41;
        if (v41)
        {
          *(v19 - 2) = v40;
          operator delete(v40);
        }
        v19 = v39;
      }
      while (v39 != v38);
    }
    *((_QWORD *)this + 16) = v38;
  }
LABEL_40:
  std::vector<std::vector<unsigned long>>::resize(v184, (int)(-1227133513 * ((*((_QWORD *)v35 + 23) - *((_QWORD *)v35 + 22)) >> 3)));
  v42 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((_QWORD *)v35 + 23) - *((_QWORD *)v35 + 22)) >> 3);
  v43 = (int)v42;
  v44 = (_QWORD *)*((_QWORD *)this + 21);
  v45 = (_QWORD *)*((_QWORD *)this + 22);
  v46 = 0xAAAAAAAAAAAAAAABLL * (v45 - v44);
  v47 = (int)v42 >= v46;
  v48 = (int)v42 - v46;
  if ((int)v42 > v46)
  {
    v49 = *((_QWORD *)this + 23);
    if (0xAAAAAAAAAAAAAAABLL * ((v49 - (uint64_t)v45) >> 3) >= v48)
    {
      v68 = 24 * ((24 * v48 - 24) / 0x18) + 24;
      bzero(*((void **)this + 22), v68);
      *((_QWORD *)this + 22) = (char *)v45 + v68;
      v61 = v187;
      goto LABEL_68;
    }
    if (((v42 << 32) & 0x8000000000000000) == 0)
    {
      v50 = 0xAAAAAAAAAAAAAAABLL * ((v49 - (uint64_t)v44) >> 3);
      v51 = 0x5555555555555556 * ((v49 - (uint64_t)v44) >> 3);
      if (v51 > v43)
        v43 = v51;
      if (v50 >= 0x555555555555555)
        v43 = 0xAAAAAAAAAAAAAAALL;
      if (v43 <= 0xAAAAAAAAAAAAAAALL)
      {
        v52 = 3 * v43;
        v53 = (char *)operator new(24 * v43);
        v54 = &v53[8 * (v45 - v44)];
        v55 = &v53[8 * v52];
        v56 = 24 * ((24 * v48 - 24) / 0x18) + 24;
        bzero(v54, v56);
        v57 = &v54[v56];
        if (v45 == v44)
        {
          *((_QWORD *)this + 21) = v54;
          *((_QWORD *)this + 22) = v57;
          *((_QWORD *)this + 23) = v55;
        }
        else
        {
          do
          {
            v58 = *(_OWORD *)(v45 - 3);
            v45 -= 3;
            *(_OWORD *)(v54 - 24) = v58;
            v54 -= 24;
            *((_QWORD *)v54 + 2) = v45[2];
            *v45 = 0;
            v45[1] = 0;
            v45[2] = 0;
          }
          while (v45 != v44);
          v45 = (_QWORD *)*((_QWORD *)this + 21);
          v59 = (_QWORD *)*((_QWORD *)this + 22);
          *((_QWORD *)this + 21) = v54;
          *((_QWORD *)this + 22) = v57;
          *((_QWORD *)this + 23) = v55;
          if (v59 != v45)
          {
            v60 = v59;
            v61 = v187;
            do
            {
              v63 = (void *)*(v60 - 3);
              v60 -= 3;
              v62 = v63;
              if (v63)
              {
                *(v59 - 2) = v62;
                operator delete(v62);
              }
              v59 = v60;
            }
            while (v60 != v45);
            if (!v45)
              goto LABEL_68;
LABEL_67:
            operator delete(v45);
            goto LABEL_68;
          }
        }
        v61 = v187;
        if (!v45)
          goto LABEL_68;
        goto LABEL_67;
      }
LABEL_165:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_164:
    abort();
  }
  v61 = v187;
  if (!v47)
  {
    v64 = &v44[3 * (int)v42];
    if (v45 != v64)
    {
      v65 = (_QWORD *)*((_QWORD *)this + 22);
      do
      {
        v67 = (void *)*(v65 - 3);
        v65 -= 3;
        v66 = v67;
        if (v67)
        {
          *(v45 - 2) = v66;
          operator delete(v66);
        }
        v45 = v65;
      }
      while (v65 != v64);
    }
    *((_QWORD *)this + 22) = v64;
  }
LABEL_68:
  v69 = v61;
  if ((int)(-1227133513 * ((*((_QWORD *)v61 + 23) - *((_QWORD *)v61 + 22)) >> 3)) >= 1)
  {
    v70 = 0;
    v71 = 0;
    v72 = 4;
    do
    {
      std::vector<OpenSubdiv::v3_1_1::Osd::PatchArray>::reserve((char **)(*((_QWORD *)this + 15) + v70), v5);
      v73 = *(_DWORD *)(*((_QWORD *)v69 + 22) + v72) - 1;
      if (v73 > 8)
        v74 = -1;
      else
        v74 = dword_22619D198[v73];
      std::vector<int>::reserve((std::vector<int> *)(*((_QWORD *)this + 18) + v70), v74 * v183);
      std::vector<OpenSubdiv::v3_1_1::Osd::PatchParam>::reserve((char **)(*((_QWORD *)this + 21) + v70), v183);
      ++v71;
      v69 = v187;
      v70 += 24;
      v72 += 56;
    }
    while (v71 < (int)(-1227133513 * ((*((_QWORD *)v187 + 23) - *((_QWORD *)v187 + 22)) >> 3)));
  }
  std::vector<OpenSubdiv::v3_1_1::Osd::PatchParam>::reserve(v186, v183);
  v75 = v183;
  if (v5 >= 1)
  {
    v76 = v69;
    v77 = 0;
    do
    {
      v78 = (int *)(*((_QWORD *)v76 + 1) + 20 * v77);
      v80 = *v78;
      v79 = v78[1];
      v81 = (*((_QWORD *)this + 4) - *((_QWORD *)this + 3)) >> 2;
      v82 = -1431655765 * ((*((_QWORD *)this + 7) - *((_QWORD *)this + 6)) >> 2);
      v83 = (_DWORD *)*((_QWORD *)this + 1);
      v84 = *((_QWORD *)this + 2);
      if ((unint64_t)v83 >= v84)
      {
        v86 = ((uint64_t)v83 - *(_QWORD *)this) >> 4;
        v87 = v86 + 1;
        if ((unint64_t)(v86 + 1) >> 60)
          goto LABEL_164;
        v88 = v84 - *(_QWORD *)this;
        if (v88 >> 3 > v87)
          v87 = v88 >> 3;
        if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFF0)
          v89 = 0xFFFFFFFFFFFFFFFLL;
        else
          v89 = v87;
        v90 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<simd_quatf>>(v89);
        v92 = &v90[16 * v86];
        *(_DWORD *)v92 = v80;
        *((_DWORD *)v92 + 1) = v79;
        *((_DWORD *)v92 + 2) = v81;
        *((_DWORD *)v92 + 3) = v82;
        v94 = *(_QWORD *)this;
        v93 = *((_QWORD *)this + 1);
        v95 = v92;
        if (v93 == *(_QWORD *)this)
        {
          v76 = v187;
        }
        else
        {
          v76 = v187;
          do
          {
            v96 = *(_DWORD *)(v93 - 16);
            v93 -= 16;
            *((_DWORD *)v95 - 4) = v96;
            v95 -= 16;
            v97 = *(_QWORD *)(v93 + 4);
            *((_DWORD *)v95 + 3) = *(_DWORD *)(v93 + 12);
            *(_QWORD *)(v95 + 4) = v97;
          }
          while (v93 != v94);
          v93 = *(_QWORD *)this;
        }
        v85 = v92 + 16;
        *(_QWORD *)this = v95;
        *((_QWORD *)this + 1) = v92 + 16;
        *((_QWORD *)this + 2) = &v90[16 * v91];
        if (v93)
          operator delete((void *)v93);
      }
      else
      {
        *v83 = v80;
        v83[1] = v79;
        v85 = v83 + 4;
        v83[2] = v81;
        v83[3] = v82;
        v76 = v187;
      }
      *((_QWORD *)this + 1) = v85;
      PatchArrayVertices = (char *)OpenSubdiv::v3_1_1::Far::PatchTable::getPatchArrayVertices(v76, v77);
      std::vector<int>::__insert_with_size[abi:nn180100]<int const*,int const*>((void **)&v182->__begin_, *((_QWORD *)this + 4), PatchArrayVertices, &PatchArrayVertices[4 * v99], v99);
      v100 = *((_DWORD *)v76 + 36);
      v101 = *((_QWORD *)this + 10);
      v102 = *((_QWORD *)this + 11);
      if (v101 >= v102)
      {
        v104 = (uint64_t)(v101 - (_QWORD)*v180) >> 4;
        v105 = v104 + 1;
        if ((unint64_t)(v104 + 1) >> 60)
          goto LABEL_164;
        v106 = v102 - (_QWORD)*v180;
        if (v106 >> 3 > v105)
          v105 = v106 >> 3;
        if ((unint64_t)v106 >= 0x7FFFFFFFFFFFFFF0)
          v107 = 0xFFFFFFFFFFFFFFFLL;
        else
          v107 = v105;
        v108 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<simd_quatf>>(v107);
        v110 = &v108[16 * v104];
        *(_DWORD *)v110 = v100;
        *((_DWORD *)v110 + 1) = v75;
        *((_QWORD *)v110 + 1) = 0;
        v112 = (char *)*((_QWORD *)this + 9);
        v111 = (char *)*((_QWORD *)this + 10);
        v113 = v110;
        if (v111 != v112)
        {
          do
          {
            v114 = *((_DWORD *)v111 - 4);
            v111 -= 16;
            *((_DWORD *)v113 - 4) = v114;
            v113 -= 16;
            v115 = *(_QWORD *)(v111 + 4);
            *((_DWORD *)v113 + 3) = *((_DWORD *)v111 + 3);
            *(_QWORD *)(v113 + 4) = v115;
          }
          while (v111 != v112);
          v111 = *v180;
        }
        v103 = v110 + 16;
        *((_QWORD *)this + 9) = v113;
        *((_QWORD *)this + 10) = v110 + 16;
        *((_QWORD *)this + 11) = &v108[16 * v109];
        if (v111)
          operator delete(v111);
      }
      else
      {
        *(_DWORD *)v101 = v100;
        *(_DWORD *)(v101 + 4) = v75;
        v103 = (char *)(v101 + 16);
        *(_QWORD *)(v101 + 8) = 0;
      }
      *((_QWORD *)this + 10) = v103;
      *(_QWORD *)v185 = v77;
      PatchArrayVaryingVertices = (char *)OpenSubdiv::v3_1_1::Far::PatchTable::GetPatchArrayVaryingVertices(v76, v77);
      std::vector<int>::__insert_with_size[abi:nn180100]<int const*,int const*>((void **)&v181->__begin_, *((_QWORD *)this + 13), PatchArrayVaryingVertices, &PatchArrayVaryingVertices[4 * v117], v117);
      v118 = *((_QWORD *)v76 + 22);
      if ((int)(-1227133513 * ((unint64_t)(*((_QWORD *)v76 + 23) - v118) >> 3)) >= 1)
      {
        v119 = 0;
        do
        {
          v120 = *(_DWORD *)(v118 + 56 * (int)v119 + 4);
          v121 = (char **)(*((_QWORD *)this + 15) + 24 * v119);
          v123 = v121 + 1;
          v122 = (unint64_t)v121[1];
          v124 = (unint64_t)v121[2];
          if (v122 >= v124)
          {
            v126 = (uint64_t)(v122 - (_QWORD)*v121) >> 4;
            v127 = v126 + 1;
            if ((unint64_t)(v126 + 1) >> 60)
              goto LABEL_164;
            v128 = v124 - (_QWORD)*v121;
            if (v128 >> 3 > v127)
              v127 = v128 >> 3;
            if ((unint64_t)v128 >= 0x7FFFFFFFFFFFFFF0)
              v129 = 0xFFFFFFFFFFFFFFFLL;
            else
              v129 = v127;
            v130 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<simd_quatf>>(v129);
            v132 = &v130[16 * v126];
            *(_DWORD *)v132 = v120;
            *((_DWORD *)v132 + 1) = v75;
            *((_QWORD *)v132 + 1) = 0;
            v133 = *v123;
            v134 = *v121;
            v135 = v132;
            if (*v123 != *v121)
            {
              do
              {
                v136 = *((_DWORD *)v133 - 4);
                v133 -= 16;
                *((_DWORD *)v135 - 4) = v136;
                v135 -= 16;
                v137 = *(_QWORD *)(v133 + 4);
                *((_DWORD *)v135 + 3) = *((_DWORD *)v133 + 3);
                *(_QWORD *)(v135 + 4) = v137;
              }
              while (v133 != v134);
              v133 = *v121;
            }
            *v121 = v135;
            v125 = v132 + 16;
            *v123 = v132 + 16;
            v121[2] = &v130[16 * v131];
            if (v133)
              operator delete(v133);
          }
          else
          {
            *(_DWORD *)v122 = v120;
            *(_DWORD *)(v122 + 4) = v75;
            v125 = (char *)(v122 + 16);
            *(_QWORD *)(v122 + 8) = 0;
          }
          v76 = v187;
          *v123 = v125;
          PatchArrayFVarValues = (char *)OpenSubdiv::v3_1_1::Far::PatchTable::GetPatchArrayFVarValues(v187, v185[0], v119);
          std::vector<int>::__insert_with_size[abi:nn180100]<int const*,int const*>((void **)(*v184 + 24 * v119), *(_QWORD *)(*v184 + 24 * v119 + 8), PatchArrayFVarValues, &PatchArrayFVarValues[4 * v139], v139);
          v118 = *((_QWORD *)v187 + 22);
          if (v75 >= 1)
          {
            v140 = 0;
            v141 = *(_QWORD *)(v118 + 56 * (int)v119 + 32)
                 + 8 * *(int *)(*((_QWORD *)v187 + 1) + 20 * *(_QWORD *)v185 + 12);
            do
            {
              v142 = *(_QWORD *)(v141 + 8 * v140);
              v143 = (unint64_t *)(*((_QWORD *)this + 21) + 24 * v119);
              v145 = (_DWORD **)(v143 + 1);
              v144 = v143[1];
              v147 = v143 + 2;
              v146 = v143[2];
              if (v144 >= v146)
              {
                v149 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v144 - *v143) >> 2);
                v150 = v149 + 1;
                if (v149 + 1 > 0x1555555555555555)
                  goto LABEL_164;
                v151 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v146 - *v143) >> 2);
                if (2 * v151 > v150)
                  v150 = 2 * v151;
                if (v151 >= 0xAAAAAAAAAAAAAAALL)
                  v152 = 0x1555555555555555;
                else
                  v152 = v150;
                if (v152)
                  v152 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<OpenSubdiv::v3_1_1::Osd::PatchParam>>(v152);
                else
                  v153 = 0;
                v154 = v152 + 12 * v149;
                *(_QWORD *)v154 = v142;
                *(_DWORD *)(v154 + 8) = 0;
                v155 = *v145;
                v156 = (_DWORD *)*v143;
                v157 = v154;
                if (*v145 != (_DWORD *)*v143)
                {
                  do
                  {
                    v158 = *(_QWORD *)(v155 - 3);
                    v155 -= 3;
                    v159 = v155[2];
                    *(_QWORD *)(v157 - 12) = v158;
                    v157 -= 12;
                    *(_DWORD *)(v157 + 8) = v159;
                  }
                  while (v155 != v156);
                  v155 = (_DWORD *)*v143;
                }
                *v143 = v157;
                v148 = (_DWORD *)(v154 + 12);
                *v145 = (_DWORD *)(v154 + 12);
                *v147 = v152 + 12 * v153;
                if (v155)
                  operator delete(v155);
              }
              else
              {
                *(_QWORD *)v144 = v142;
                *(_DWORD *)(v144 + 8) = 0;
                v148 = (_DWORD *)(v144 + 12);
              }
              *v145 = v148;
              ++v140;
            }
            while (v140 != v183);
            v76 = v187;
            v118 = *((_QWORD *)v187 + 22);
            v75 = v183;
          }
          ++v119;
        }
        while (v119 < (int)(-1227133513 * ((unint64_t)(*((_QWORD *)v76 + 23) - v118) >> 3)));
      }
      v160 = *(_DWORD *)(*((_QWORD *)v76 + 1) + 20 * *(_QWORD *)v185 + 4);
      if (v160 >= 1)
      {
        v161 = 0;
        v162 = *((_QWORD *)this + 7);
        do
        {
          v163 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v162 - (_QWORD)*v186) >> 2);
          v164 = *((_QWORD *)v76 + 28);
          v165 = 0;
          if ((int)v163 < (int)((unint64_t)(*((_QWORD *)v76 + 29) - v164) >> 2))
          {
            v166 = *(unsigned int *)(v164 + 4 * (int)v163);
            if ((v166 & 0x80000000) == 0)
              v165 = *(_DWORD *)(*((_QWORD *)v76 + 31) + 4 * v166);
          }
          v167 = *(_QWORD *)(*((_QWORD *)v76 + 7) + 8 * (int)v163);
          v168 = *((_QWORD *)this + 8);
          if (v162 >= v168)
          {
            if (v163 + 1 > 0x1555555555555555)
              goto LABEL_164;
            v169 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v168 - (_QWORD)*v186) >> 2);
            v170 = 2 * v169;
            if (2 * v169 <= v163 + 1)
              v170 = v163 + 1;
            if (v169 >= 0xAAAAAAAAAAAAAAALL)
              v171 = 0x1555555555555555;
            else
              v171 = v170;
            if (v171)
              v171 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<OpenSubdiv::v3_1_1::Osd::PatchParam>>(v171);
            else
              v172 = 0;
            v173 = v171 + 12 * v163;
            *(_QWORD *)v173 = v167;
            *(_DWORD *)(v173 + 8) = v165;
            v175 = (char *)*((_QWORD *)this + 6);
            v174 = (char *)*((_QWORD *)this + 7);
            v176 = v173;
            if (v174 != v175)
            {
              do
              {
                v177 = *(_QWORD *)(v174 - 12);
                v174 -= 12;
                v178 = *((_DWORD *)v174 + 2);
                *(_QWORD *)(v176 - 12) = v177;
                v176 -= 12;
                *(_DWORD *)(v176 + 8) = v178;
              }
              while (v174 != v175);
              v174 = *v186;
            }
            v162 = v173 + 12;
            *((_QWORD *)this + 6) = v176;
            *((_QWORD *)this + 7) = v173 + 12;
            *((_QWORD *)this + 8) = v171 + 12 * v172;
            if (v174)
              operator delete(v174);
          }
          else
          {
            *(_QWORD *)v162 = v167;
            *(_DWORD *)(v162 + 8) = v165;
            v162 += 12;
          }
          *((_QWORD *)this + 7) = v162;
          ++v161;
        }
        while (v161 != v160);
      }
      v77 = *(_QWORD *)v185 + 1;
      v75 = v183;
    }
    while (*(_QWORD *)v185 + 1 != v5);
  }
  return this;
}

void std::vector<OpenSubdiv::v3_1_1::Osd::PatchArray>::reserve(char **a1, unint64_t a2)
{
  uint64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  int v11;
  uint64_t v12;

  if (a2 > (a1[2] - *a1) >> 4)
  {
    if (a2 >> 60)
      abort();
    v3 = a1[1] - *a1;
    v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<simd_quatf>>(a2);
    v5 = &v4[v3];
    v7 = &v4[16 * v6];
    v9 = *a1;
    v8 = a1[1];
    v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        v11 = *((_DWORD *)v8 - 4);
        v8 -= 16;
        *((_DWORD *)v10 - 4) = v11;
        v10 -= 16;
        v12 = *(_QWORD *)(v8 + 4);
        *((_DWORD *)v10 + 3) = *((_DWORD *)v8 + 3);
        *(_QWORD *)(v10 + 4) = v12;
      }
      while (v8 != v9);
      v8 = *a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
      operator delete(v8);
  }
}

void std::vector<OpenSubdiv::v3_1_1::Osd::PatchParam>::reserve(char **a1, unint64_t a2)
{
  uint64_t v3;
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  int v12;

  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 2) < a2)
  {
    if (a2 >= 0x1555555555555556)
      abort();
    v3 = (a1[1] - *a1) / 12;
    v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<OpenSubdiv::v3_1_1::Osd::PatchParam>>(a2);
    v5 = &v4[12 * v3];
    v7 = &v4[12 * v6];
    v9 = *a1;
    v8 = a1[1];
    v10 = v5;
    if (v8 != *a1)
    {
      do
      {
        v11 = *(_QWORD *)(v8 - 12);
        v8 -= 12;
        v12 = *((_DWORD *)v8 + 2);
        *(_QWORD *)(v10 - 12) = v11;
        v10 -= 12;
        *((_DWORD *)v10 + 2) = v12;
      }
      while (v8 != v9);
      v8 = *a1;
    }
    *a1 = v10;
    a1[1] = v5;
    a1[2] = v7;
    if (v8)
      operator delete(v8);
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<OpenSubdiv::v3_1_1::Osd::PatchParam>>(unint64_t a1)
{
  if (a1 >= 0x1555555555555556)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(12 * a1);
}

void std::vector<int>::__insert_with_size[abi:nn180100]<int const*,int const*>(void **a1, uint64_t a2, char *__src, char *a4, uint64_t a5)
{
  char *v6;
  char *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  _BYTE *v12;
  _BYTE *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  int64_t v23;
  char *v24;
  char *v25;
  int *v26;
  char *v27;
  int v28;
  char *v29;
  char *v30;
  uint64_t v31;
  char *v32;
  int v33;
  char *v34;
  char *v35;
  int v36;
  char *v37;
  _BYTE *v38;
  uint64_t v39;
  void *v40;

  if (a5 < 1)
    return;
  v6 = __src;
  v8 = (char *)*a1;
  v9 = a2 - (_QWORD)*a1;
  v10 = (char *)*a1 + (v9 & 0xFFFFFFFFFFFFFFFCLL);
  v13 = a1[2];
  v11 = (uint64_t)(a1 + 2);
  v12 = v13;
  v14 = *(_QWORD *)(v11 - 8);
  if (a5 > (uint64_t)&v13[-v14] >> 2)
  {
    v15 = a5 + ((uint64_t)(v14 - (_QWORD)v8) >> 2);
    if (v15 >> 62)
      abort();
    v16 = v9 >> 2;
    v17 = v12 - v8;
    v18 = v17 >> 1;
    if (v17 >> 1 <= v15)
      v18 = v15;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL)
      v19 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v19 = v18;
    if (v19)
      v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(v11, v19);
    else
      v20 = 0;
    v29 = &v20[4 * v16];
    v30 = &v29[4 * a5];
    v31 = 4 * a5;
    v32 = v29;
    do
    {
      v33 = *(_DWORD *)v6;
      v6 += 4;
      *(_DWORD *)v32 = v33;
      v32 += 4;
      v31 -= 4;
    }
    while (v31);
    v34 = (char *)*a1;
    if (*a1 != v10)
    {
      v35 = v10;
      do
      {
        v36 = *((_DWORD *)v35 - 1);
        v35 -= 4;
        *((_DWORD *)v29 - 1) = v36;
        v29 -= 4;
      }
      while (v35 != v34);
    }
    v37 = &v20[4 * v19];
    v38 = a1[1];
    v39 = v38 - v10;
    if (v38 != v10)
      memmove(v30, v10, v38 - v10);
    v40 = *a1;
    *a1 = v29;
    a1[1] = &v30[v39];
    a1[2] = v37;
    if (v40)
      operator delete(v40);
    return;
  }
  v21 = (uint64_t)(v14 - (_QWORD)v10) >> 2;
  if (v21 >= a5)
  {
    v22 = &__src[4 * a5];
    v24 = *(char **)(v11 - 8);
LABEL_17:
    v25 = &v10[4 * a5];
    v26 = (int *)&v24[-4 * a5];
    v27 = v24;
    if ((unint64_t)v26 < v14)
    {
      v27 = v24;
      do
      {
        v28 = *v26++;
        *(_DWORD *)v27 = v28;
        v27 += 4;
      }
      while ((unint64_t)v26 < v14);
    }
    a1[1] = v27;
    if (v24 != v25)
      memmove(&v24[-4 * ((v24 - v25) >> 2)], v10, v24 - v25);
    if (v22 != v6)
      memmove(v10, v6, v22 - v6);
    return;
  }
  v22 = &__src[4 * v21];
  v23 = a4 - v22;
  if (a4 != v22)
    memmove(*(void **)(v11 - 8), &__src[4 * v21], a4 - v22);
  v24 = (char *)(v14 + v23);
  a1[1] = (void *)(v14 + v23);
  if ((uint64_t)(v14 - (_QWORD)v10) >= 1)
    goto LABEL_17;
}

void OpenSubdiv::v3_1_1::Far::PatchTable::~PatchTable(OpenSubdiv::v3_1_1::Far::PatchTable *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  v2 = *((_QWORD *)this + 16);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  v3 = *((_QWORD *)this + 17);
  if (v3)
    (*(void (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v5 = *((_QWORD *)this + 25);
  v4 = *((_QWORD *)this + 26);
  if ((int)((unint64_t)(v4 - v5) >> 3) >= 1)
  {
    v6 = 0;
    do
    {
      v7 = *(_QWORD *)(v5 + 8 * v6);
      if (v7)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
        v5 = *((_QWORD *)this + 25);
        v4 = *((_QWORD *)this + 26);
      }
      ++v6;
    }
    while (v6 < (int)((unint64_t)(v4 - v5) >> 3));
  }
  v8 = (void *)*((_QWORD *)this + 31);
  if (v8)
  {
    *((_QWORD *)this + 32) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 28);
  if (v9)
  {
    *((_QWORD *)this + 29) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 25);
  if (v10)
  {
    *((_QWORD *)this + 26) = v10;
    operator delete(v10);
  }
  v11 = (_QWORD *)*((_QWORD *)this + 22);
  if (v11)
  {
    v12 = (_QWORD *)*((_QWORD *)this + 23);
    v13 = (void *)*((_QWORD *)this + 22);
    if (v12 != v11)
    {
      do
      {
        v12 -= 7;
        std::allocator<OpenSubdiv::v3_1_1::Far::PatchTable::FVarPatchChannel>::destroy[abi:nn180100]((uint64_t)this + 192, v12);
      }
      while (v12 != v11);
      v13 = (void *)*((_QWORD *)this + 22);
    }
    *((_QWORD *)this + 23) = v11;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)this + 19);
  if (v14)
  {
    *((_QWORD *)this + 20) = v14;
    operator delete(v14);
  }
  v15 = (void *)*((_QWORD *)this + 13);
  if (v15)
  {
    *((_QWORD *)this + 14) = v15;
    operator delete(v15);
  }
  v16 = (void *)*((_QWORD *)this + 10);
  if (v16)
  {
    *((_QWORD *)this + 11) = v16;
    operator delete(v16);
  }
  v17 = (void *)*((_QWORD *)this + 7);
  if (v17)
  {
    *((_QWORD *)this + 8) = v17;
    operator delete(v17);
  }
  v18 = (void *)*((_QWORD *)this + 4);
  if (v18)
  {
    *((_QWORD *)this + 5) = v18;
    operator delete(v18);
  }
  v19 = (void *)*((_QWORD *)this + 1);
  if (v19)
  {
    *((_QWORD *)this + 2) = v19;
    operator delete(v19);
  }
}

void std::vector<OpenSubdiv::v3_1_1::Far::PatchTable::PatchArray>::reserve(char **a1, unint64_t a2)
{
  uint64_t v3;
  char *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  int v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (0xCCCCCCCCCCCCCCCDLL * ((v4 - *a1) >> 2) < a2)
  {
    if (a2 >= 0xCCCCCCCCCCCCCCDLL)
      abort();
    v5 = a1[1] - *a1;
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<OpenSubdiv::v3_1_1::Far::PatchTable::PatchArray>>(v3, a2);
    v7 = &v6[v5];
    v9 = &v6[20 * v8];
    v11 = *a1;
    v10 = a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_DWORD *)v10 - 5);
        v10 -= 20;
        *((_DWORD *)v12 - 5) = v13;
        v12 -= 20;
        *(_OWORD *)(v12 + 4) = *(_OWORD *)(v10 + 4);
      }
      while (v10 != v11);
      v10 = *a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void OpenSubdiv::v3_1_1::Far::PatchTable::allocateVaryingVertices(uint64_t a1, _DWORD *a2, int a3)
{
  unsigned int v3;
  int v4;

  *(_DWORD *)(a1 + 144) = *a2;
  v3 = *a2 - 1;
  if (v3 > 8)
    v4 = -1;
  else
    v4 = dword_22619D1C8[v3];
  std::vector<unsigned int>::resize((std::vector<int> *)(a1 + 152), v4 * a3);
}

void std::vector<OpenSubdiv::v3_1_1::Far::PatchTable::FVarPatchChannel>::resize(uint64_t a1, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;

  v3 = *(_QWORD **)(a1 + 8);
  v4 = 0x6DB6DB6DB6DB6DB7 * (((uint64_t)v3 - *(_QWORD *)a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<OpenSubdiv::v3_1_1::Far::PatchTable::FVarPatchChannel>::__append((char **)a1, v6);
  }
  else if (!v5)
  {
    v7 = *(_QWORD *)a1 + 56 * a2;
    while (v3 != (_QWORD *)v7)
    {
      v3 -= 7;
      std::allocator<OpenSubdiv::v3_1_1::Far::PatchTable::FVarPatchChannel>::destroy[abi:nn180100](a1 + 16, v3);
    }
    *(_QWORD *)(a1 + 8) = v7;
  }
}

void OpenSubdiv::v3_1_1::Far::PatchTable::allocateFVarPatchChannelValues(uint64_t a1, _DWORD *a2, int a3, int a4)
{
  uint64_t v5;
  unsigned int v6;
  int v7;
  uint64_t v8;

  v5 = *(_QWORD *)(a1 + 176);
  *(_DWORD *)(v5 + 56 * a4 + 4) = *a2;
  v6 = *a2 - 1;
  if (v6 > 8)
    v7 = -1;
  else
    v7 = dword_22619D1C8[v6];
  v8 = v5 + 56 * a4;
  std::vector<unsigned int>::resize((std::vector<int> *)(v8 + 8), v7 * a3);
  std::vector<OpenSubdiv::v3_1_1::Far::PatchParam>::resize(v8 + 32, a3);
}

void OpenSubdiv::v3_1_1::Far::PatchTable::pushPatchArray(_QWORD *a1, int *a2, int a3, int *a4, int *a5, int *a6)
{
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  _DWORD *v18;
  _DWORD *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  char *v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  unsigned int v32;
  int v33;
  int v34;
  int v35;

  if (a3 >= 1)
  {
    if (a6)
      v12 = *a6;
    else
      v12 = 0;
    v13 = *a2;
    v14 = *a4;
    v15 = *a5;
    v16 = (uint64_t)(a1 + 3);
    v17 = a1[3];
    v18 = (_DWORD *)a1[2];
    if ((unint64_t)v18 >= v17)
    {
      v35 = v12;
      v20 = a1[1];
      v21 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v18 - v20) >> 2);
      v22 = v21 + 1;
      if (v21 + 1 > 0xCCCCCCCCCCCCCCCLL)
        abort();
      v23 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v17 - v20) >> 2);
      if (2 * v23 > v22)
        v22 = 2 * v23;
      if (v23 >= 0x666666666666666)
        v24 = 0xCCCCCCCCCCCCCCCLL;
      else
        v24 = v22;
      v25 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<OpenSubdiv::v3_1_1::Far::PatchTable::PatchArray>>(v16, v24);
      v26 = &v25[20 * v21];
      v28 = &v25[20 * v27];
      *(_DWORD *)v26 = v13;
      *((_DWORD *)v26 + 1) = a3;
      *((_DWORD *)v26 + 2) = v14;
      *((_DWORD *)v26 + 3) = v15;
      *((_DWORD *)v26 + 4) = v35;
      v19 = v26 + 20;
      v30 = a1[1];
      v29 = a1[2];
      if (v29 != v30)
      {
        do
        {
          v31 = *(_DWORD *)(v29 - 20);
          v29 -= 20;
          *((_DWORD *)v26 - 5) = v31;
          v26 -= 20;
          *(_OWORD *)(v26 + 4) = *(_OWORD *)(v29 + 4);
        }
        while (v29 != v30);
        v29 = a1[1];
      }
      a1[1] = v26;
      a1[2] = v19;
      a1[3] = v28;
      if (v29)
        operator delete((void *)v29);
    }
    else
    {
      *v18 = v13;
      v18[1] = a3;
      v18[2] = v14;
      v18[3] = v15;
      v19 = v18 + 5;
      v18[4] = v12;
    }
    a1[2] = v19;
    v32 = *a2 - 1;
    if (v32 > 8)
      v33 = -1;
    else
      v33 = dword_22619D1C8[v32];
    v34 = v33 * a3;
    *a4 += v34;
    *a5 += a3;
    if (a6)
    {
      if (*a2 != 7)
        v34 = 0;
      *a6 += v34;
    }
  }
}

uint64_t OpenSubdiv::v3_1_1::Far::PatchTable::GetNumControlVertices(OpenSubdiv::v3_1_1::Far::PatchTable *this, int a2)
{
  int v2;
  int v3;

  v2 = *(_DWORD *)(*((_QWORD *)this + 1) + 20 * a2) - 1;
  if (v2 > 8)
    v3 = -1;
  else
    v3 = dword_22619D1C8[v2];
  return (v3 * *(_DWORD *)(*((_QWORD *)this + 1) + 20 * a2 + 4));
}

uint64_t OpenSubdiv::v3_1_1::Far::PatchTable::getPatchArrayVertices(OpenSubdiv::v3_1_1::Far::PatchTable *this, int a2)
{
  return *((_QWORD *)this + 4) + 4 * *(int *)(*((_QWORD *)this + 1) + 20 * a2 + 8);
}

uint64_t OpenSubdiv::v3_1_1::Far::PatchTable::GetPatchArrayVaryingVertices(OpenSubdiv::v3_1_1::Far::PatchTable *this, int a2)
{
  uint64_t v2;
  unsigned int v3;
  int v4;

  v2 = *((_QWORD *)this + 19);
  if (v2 == *((_QWORD *)this + 20))
    return 0;
  v3 = *((_DWORD *)this + 36) - 1;
  if (v3 > 8)
    v4 = -1;
  else
    v4 = dword_22619D1C8[v3];
  return v2 + 4 * *(_DWORD *)(*((_QWORD *)this + 1) + 20 * a2 + 12) * v4;
}

uint64_t OpenSubdiv::v3_1_1::Far::PatchTable::populateVaryingVertices(uint64_t this)
{
  unsigned int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int *v8;
  int v9;
  int v10;
  int v11;
  _DWORD *v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  _DWORD *v24;
  _DWORD *v25;

  v1 = *(_DWORD *)(this + 144) - 1;
  if (v1 > 8)
    v2 = -1;
  else
    v2 = dword_22619D1C8[v1];
  v3 = *(_QWORD *)(this + 8);
  if ((int)(-858993459 * ((*(_QWORD *)(this + 16) - v3) >> 2)) >= 1)
  {
    v4 = 0;
    v5 = -858993459 * ((*(_QWORD *)(this + 16) - v3) >> 2);
    do
    {
      v6 = v3 + 20 * v4;
      v9 = *(_DWORD *)(v6 + 4);
      v8 = (int *)(v6 + 4);
      v7 = v9;
      if (v9 >= 1)
      {
        v10 = 0;
        v11 = *(_DWORD *)(v3 + 20 * v4);
        v12 = (_DWORD *)(v3 + 20 * (int)v4);
        v13 = *(_QWORD *)(this + 32);
        do
        {
          v14 = *v12 - 1;
          if (v14 > 8)
            v15 = -1;
          else
            v15 = dword_22619D1C8[v14];
          v16 = (_DWORD *)(v13 + 4 * (v12[2] + v15 * v10));
          v17 = (v10 + *(_DWORD *)(v3 + 20 * v4 + 12)) * (uint64_t)v2;
          switch(v11)
          {
            case 3:
              v18 = *(_QWORD *)(this + 152);
              v19 = (_DWORD *)(v18 + 4 * (int)v17);
              *v19 = *v16;
              v19[1] = v16[1];
              v20 = 3;
              v21 = 2;
              v22 = 2;
              v23 = 3;
              goto LABEL_16;
            case 4:
              v18 = *(_QWORD *)(this + 152);
              *(_DWORD *)(v18 + 4 * (int)v17) = *v16;
              v20 = 2;
              v21 = 1;
              v22 = 1;
              v23 = 2;
              goto LABEL_16;
            case 6:
              v18 = *(_QWORD *)(this + 152);
              v24 = (_DWORD *)(v18 + 4 * (int)v17);
              *v24 = v16[5];
              v24[1] = v16[6];
              v23 = 3;
              v22 = 2;
              v21 = 10;
              v20 = 9;
              goto LABEL_16;
            case 9:
              v18 = *(_QWORD *)(this + 152);
              v25 = (_DWORD *)(v18 + 4 * v17);
              *v25 = *v16;
              v25[1] = v16[5];
              v23 = 3;
              v22 = 2;
              v21 = 10;
              v20 = 15;
LABEL_16:
              *(_DWORD *)(v18 + 4 * (v22 + (int)v17)) = v16[v21];
              *(_DWORD *)(v18 + 4 * (v23 + (int)v17)) = v16[v20];
              v7 = *v8;
              break;
            default:
              break;
          }
          ++v10;
        }
        while (v10 < v7);
      }
      ++v4;
    }
    while (v4 != v5);
  }
  return this;
}

uint64_t OpenSubdiv::v3_1_1::Far::PatchTable::GetPatchArrayFVarValues(OpenSubdiv::v3_1_1::Far::PatchTable *this, int a2, int a3)
{
  uint64_t v3;
  unsigned int v4;
  int v5;

  v3 = *((_QWORD *)this + 22);
  v4 = *(_DWORD *)(v3 + 56 * a3 + 4) - 1;
  if (v4 > 8)
    v5 = -1;
  else
    v5 = dword_22619D1C8[v4];
  return *(_QWORD *)(v3 + 56 * a3 + 8) + 4 * *(_DWORD *)(*((_QWORD *)this + 1) + 20 * a2 + 12) * v5;
}

void std::allocator<OpenSubdiv::v3_1_1::Far::PatchTable::FVarPatchChannel>::destroy[abi:nn180100](uint64_t a1, _QWORD *a2)
{
  void *v3;
  void *v4;

  v3 = (void *)a2[4];
  if (v3)
  {
    a2[5] = v3;
    operator delete(v3);
  }
  v4 = (void *)a2[1];
  if (v4)
  {
    a2[2] = v4;
    operator delete(v4);
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<OpenSubdiv::v3_1_1::Far::PatchTable::PatchArray>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xCCCCCCCCCCCCCCDLL)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(20 * a2);
}

void std::vector<OpenSubdiv::v3_1_1::Far::PatchTable::FVarPatchChannel>::__append(char **a1, unint64_t a2)
{
  char *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  char *v20;
  char *v21;

  v5 = (uint64_t)(a1 + 2);
  v4 = a1[2];
  v6 = a1[1];
  if (0x6DB6DB6DB6DB6DB7 * ((v4 - v6) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 56 * ((56 * a2 - 56) / 0x38) + 56;
      bzero(a1[1], v13);
      v6 += v13;
    }
    a1[1] = v6;
  }
  else
  {
    v7 = *a1;
    v8 = 0x6DB6DB6DB6DB6DB7 * ((v6 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x492492492492492)
      abort();
    v10 = 0x6DB6DB6DB6DB6DB7 * ((v4 - v7) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x249249249249249)
      v11 = 0x492492492492492;
    else
      v11 = v9;
    if (v11)
    {
      if (v11 > 0x492492492492492)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v12 = (char *)operator new(56 * v11);
    }
    else
    {
      v12 = 0;
    }
    v14 = &v12[56 * v8];
    v15 = &v12[56 * v11];
    v16 = 56 * ((56 * a2 - 56) / 0x38) + 56;
    bzero(v14, v16);
    v17 = &v14[v16];
    if (v6 == v7)
    {
      *a1 = v14;
      a1[1] = v17;
      a1[2] = v15;
    }
    else
    {
      v18 = 0;
      do
      {
        v19 = &v14[v18];
        v20 = &v6[v18];
        *((_QWORD *)v19 - 7) = *(_QWORD *)&v6[v18 - 56];
        *((_QWORD *)v19 - 5) = 0;
        *((_QWORD *)v19 - 4) = 0;
        *((_OWORD *)v19 - 3) = *(_OWORD *)&v6[v18 - 48];
        *((_QWORD *)v19 - 4) = *(_QWORD *)&v6[v18 - 32];
        *((_QWORD *)v20 - 6) = 0;
        *((_QWORD *)v20 - 5) = 0;
        *((_QWORD *)v20 - 4) = 0;
        *((_QWORD *)v19 - 2) = 0;
        *((_QWORD *)v19 - 1) = 0;
        *(_OWORD *)(v19 - 24) = *(_OWORD *)&v6[v18 - 24];
        *((_QWORD *)v19 - 1) = *(_QWORD *)&v6[v18 - 8];
        *((_QWORD *)v20 - 3) = 0;
        *((_QWORD *)v20 - 2) = 0;
        *((_QWORD *)v20 - 1) = 0;
        v18 -= 56;
      }
      while (&v6[v18] != v7);
      v6 = *a1;
      v21 = a1[1];
      *a1 = &v14[v18];
      a1[1] = v17;
      a1[2] = v15;
      while (v21 != v6)
      {
        v21 -= 56;
        std::allocator<OpenSubdiv::v3_1_1::Far::PatchTable::FVarPatchChannel>::destroy[abi:nn180100](v5, v21);
      }
    }
    if (v6)
      operator delete(v6);
  }
}

uint64_t OpenSubdiv::v3_1_1::Far::TopologyRefinerFactoryBase::prepareComponentTopologySizing(OpenSubdiv::v3_1_1::Far::TopologyRefinerFactoryBase *this, OpenSubdiv::v3_1_1::Far::TopologyRefiner *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  std::vector<int> **v8;
  std::vector<int> *v9;
  int end;
  int begin;
  const char *v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  std::vector<int>::size_type v16;
  int begin_high;
  int *v19;
  std::vector<int>::size_type v20;
  int v21;
  unint64_t v22;
  std::vector<int>::size_type v23;
  std::vector<int>::size_type v24;
  char v25;

  v8 = (std::vector<int> **)*((_QWORD *)this + 5);
  v9 = *v8;
  end = (int)(*v8)->__end_;
  if (!end)
  {
    v12 = "Failure in TopologyRefinerFactory<>::Create() -- mesh contains no vertices.";
LABEL_12:
    OpenSubdiv::v3_1_1::Far::Error(4, (uint64_t)v12, a3, a4, a5, a6, a7, a8, v25);
    return 0;
  }
  begin = (int)v9->__begin_;
  if (!LODWORD(v9->__begin_))
  {
    v12 = "Failure in TopologyRefinerFactory<>::Create() -- meshes without faces not yet supported.";
    goto LABEL_12;
  }
  if (SHIDWORD(v9->__end_cap_.__value_) >= 0x10000)
  {
    OpenSubdiv::v3_1_1::Far::Error(4, (uint64_t)"Failure in TopologyRefinerFactory<>::Create() -- face with %d vertices > %d max.", a3, a4, a5, a6, a7, a8, HIDWORD(v9->__end_cap_.__value_));
    return 0;
  }
  v13 = &v9[1].__begin_[2 * begin - 2];
  v15 = *v13;
  v14 = v13[1];
  v16 = v14 + v15;
  if (!((_DWORD)v14 + (_DWORD)v15))
  {
    v12 = "Failure in TopologyRefinerFactory<>::Create() -- mesh contains no face-vertices.";
    goto LABEL_12;
  }
  if (*(_DWORD *)this == 2 && (_DWORD)v16 != 3 * begin)
  {
    v12 = "Failure in TopologyRefinerFactory<>::Create() -- non-triangular faces not supported by Loop scheme.";
    goto LABEL_12;
  }
  std::vector<unsigned int>::resize(v9 + 2, v16);
  begin_high = HIDWORD(v9->__begin_);
  if (begin_high >= 1)
  {
    std::vector<unsigned int>::resize(v9 + 3, (int)(v9[2].__end_ - v9[2].__begin_));
    std::vector<unsigned int>::resize(v9 + 5, 2 * SHIDWORD(v9->__begin_));
    v19 = &v9[6].__begin_[2 * begin_high - 2];
    v20 = v19[1] + (uint64_t)*v19;
    std::vector<unsigned int>::resize(v9 + 7, v20);
    std::vector<unsigned short>::resize((uint64_t)&v9[8], v20);
    v21 = 2 * end - 2;
    v22 = (8 * ((unint64_t)v21 >> 1)) | 4;
    v23 = *(int *)((char *)v9[11].__begin_ + v22) + (uint64_t)v9[11].__begin_[v21];
    std::vector<unsigned int>::resize(v9 + 12, v23);
    std::vector<unsigned short>::resize((uint64_t)&v9[13], v23);
    v24 = *(int *)((char *)v9[14].__begin_ + v22) + (uint64_t)v9[14].__begin_[v21];
    std::vector<unsigned int>::resize(v9 + 15, v24);
    std::vector<unsigned short>::resize((uint64_t)&v9[16], v24);
  }
  return 1;
}

uint64_t OpenSubdiv::v3_1_1::Far::TopologyRefinerFactoryBase::prepareComponentTopologyAssignment(OpenSubdiv::v3_1_1::Far::TopologyRefiner *this, int a2, void (*a3)(uint64_t, char *, uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OpenSubdiv::v3_1_1::Vtr::internal::Level **v12;
  OpenSubdiv::v3_1_1::Vtr::internal::Level *v13;
  int v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v23;

  v12 = (OpenSubdiv::v3_1_1::Vtr::internal::Level **)*((_QWORD *)this + 5);
  v13 = *v12;
  v14 = *((_DWORD *)*v12 + 1);
  if (v14)
  {
    if (!*((_DWORD *)v13 + 5))
    {
      v15 = "Failure in TopologyRefinerFactory<>::Create() -- maximum valence not assigned.";
LABEL_12:
      OpenSubdiv::v3_1_1::Far::Error(4, (uint64_t)v15, (uint64_t)a3, a4, a5, a6, a7, a8, v23);
      return 0;
    }
LABEL_5:
    if (!a2 || OpenSubdiv::v3_1_1::Vtr::internal::Level::validateTopology(v13, a3, a4))
    {
      OpenSubdiv::v3_1_1::Far::TopologyRefiner::initializeInventory(this);
      return 1;
    }
    if (v14)
      v15 = "Failure in TopologyRefinerFactory<>::Create() -- invalid topology detected as fully specified.";
    else
      v15 = "Failure in TopologyRefinerFactory<>::Create() -- invalid topology detected from partial specification.";
    goto LABEL_12;
  }
  if (OpenSubdiv::v3_1_1::Vtr::internal::Level::completeTopologyFromFaceVertices(*v12))
    goto LABEL_5;
  OpenSubdiv::v3_1_1::Far::Error(4, (uint64_t)"Failure in TopologyRefinerFactory<>::Create() -- vertex with valence %d > %d max.", v16, v17, v18, v19, v20, v21, *((_DWORD *)v13 + 5));
  return 0;
}

uint64_t OpenSubdiv::v3_1_1::Far::TopologyRefinerFactoryBase::prepareComponentTagsAndSharpness(int *a1)
{
  uint64_t v2;
  int v3;
  _BOOL4 v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  char v11;
  int v12;
  float v14;
  char v15;
  BOOL v16;
  char v17;
  unsigned int v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int *v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _BOOL4 v41;
  __int16 v42;
  int v43;
  _BOOL4 v44;
  __int16 v45;
  float v46;
  __int16 v48;
  __int16 v49;
  BOOL v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  __int16 v58;
  unsigned int v59;
  __int16 v60;
  float v61;
  BOOL v62;
  int v63;
  unsigned int v64;
  BOOL v66;
  uint64_t v67;
  __int16 v68;
  int *v69;
  uint64_t v70;

  v2 = **((_QWORD **)a1 + 5);
  v3 = a1[1] & 3;
  if (v3)
  {
    v4 = 0;
  }
  else
  {
    v5 = *a1;
    OpenSubdiv::v3_1_1::Sdc::staticTraitsTable((OpenSubdiv::v3_1_1::Sdc *)a1);
    v4 = SHIDWORD(OpenSubdiv::v3_1_1::Sdc::staticTraitsTable(void)::staticTraitsTable[3 * v5 + 2]) > 0;
  }
  if (*(int *)(v2 + 4) >= 1)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = *(_QWORD *)(v2 + 240);
      v9 = *(_QWORD *)(v2 + 216);
      v16 = *(_DWORD *)(*(_QWORD *)(v2 + 144) + v6) < 2;
      v10 = *(_BYTE *)(v8 + v7);
      v11 = v10 & 0xFD | (2 * v16);
      *(_BYTE *)(v8 + v7) = v11;
      v12 = v10 & 1;
      if (!v16 && v12 == 0)
      {
        v14 = *(float *)(v9 + 4 * v7);
      }
      else
      {
        *(_DWORD *)(v9 + 4 * v7) = 1092616192;
        v11 = *(_BYTE *)(v8 + v7);
        v14 = 10.0;
      }
      v15 = v11 & 0xFB | (4 * (v14 >= 10.0));
      *(_BYTE *)(v8 + v7) = v15;
      v16 = v14 >= 10.0 || *(float *)(v9 + 4 * v7) <= 0.0;
      if (v16)
        v17 = 0;
      else
        v17 = 8;
      *(_BYTE *)(v8 + v7++) = v17 | v15 & 0xF7;
      v6 += 8;
    }
    while (v7 < *(int *)(v2 + 4));
  }
  v18 = *a1;
  OpenSubdiv::v3_1_1::Sdc::staticTraitsTable((OpenSubdiv::v3_1_1::Sdc *)a1);
  v19 = OpenSubdiv::v3_1_1::Sdc::staticTraitsTable(void)::staticTraitsTable[3 * v18 + 2];
  if (v19 >= 0)
    v20 = OpenSubdiv::v3_1_1::Sdc::staticTraitsTable(void)::staticTraitsTable[3 * v18 + 2];
  else
    v20 = v19 + 1;
  if (*(int *)(v2 + 8) >= 1)
  {
    v21 = 0;
    v22 = v20 >> 1;
    while (1)
    {
      v23 = *(_QWORD *)(v2 + 336);
      v24 = (8 * v21) | 4;
      v25 = (int *)(*(_QWORD *)(v2 + 360) + 4 * *(int *)(v23 + v24));
      v26 = *(_DWORD *)(v23 + 8 * v21);
      if (v26 < 1)
      {
        v30 = 0;
        v29 = 0;
        v28 = 0;
        v27 = 0;
      }
      else
      {
        v27 = 0;
        v28 = 0;
        v29 = 0;
        v30 = 0;
        v31 = (int *)(*(_QWORD *)(v2 + 360) + 4 * *(int *)(v23 + v24));
        v32 = *(unsigned int *)(v23 + 8 * v21);
        do
        {
          v33 = *v31++;
          v34 = *(unsigned __int8 *)(*(_QWORD *)(v2 + 240) + v33);
          v30 += (v34 >> 1) & 1;
          v29 += (v34 >> 2) & 1;
          v28 += (v34 >> 3) & 1;
          v27 += v34 & 1;
          --v32;
        }
        while (v32);
      }
      v35 = *(_QWORD *)(v2 + 432);
      v36 = *(_QWORD *)(v2 + 408);
      v37 = *(_QWORD *)(v2 + 288);
      v38 = *(_QWORD *)(v2 + 264);
      v39 = *(int *)(v38 + v24);
      v40 = *(unsigned int *)(v38 + 8 * v21);
      if ((_DWORD)v40 != 1)
        break;
      v41 = v26 == 2;
      if (v3 != 2 || v26 != 2)
        goto LABEL_34;
      v41 = 1;
LABEL_38:
      *(_DWORD *)(v36 + 4 * v21) = 1092616192;
      v42 = *(_WORD *)(v35 + 2 * v21);
LABEL_39:
      v43 = v28 + v29;
      v44 = *(float *)(v36 + 4 * v21) >= 10.0;
      v45 = v42 & 0xFFEF | (16 * v44);
      *(_WORD *)(v35 + 2 * v21) = v45;
      v46 = *(float *)(v36 + 4 * v21);
      if (v46 >= 10.0 || v46 <= 0.0)
        v48 = 0;
      else
        v48 = 32;
      v49 = v45 & 0xFF9F | ((v28 != 0) << 6) | v48;
      *(_WORD *)(v35 + 2 * v21) = v49;
      v50 = *(float *)(v36 + 4 * v21) <= 0.0 && v43 <= 2;
      v51 = ((1 << v43) & 0xF) << 7;
      if (!v50)
        v51 = 1024;
      v52 = v49 & 0xF871;
      v53 = v44 && v41;
      if (v53)
        v54 = 8;
      else
        v54 = 0;
      v55 = v54 | (4 * (v30 != 0)) | v51 | v52;
      if (v30)
        v56 = v55 | (2 * ((_DWORD)v40 != v22));
      else
        v56 = v55 | (2 * ((_DWORD)v40 != v19));
      if ((v53 & 1) != 0)
        v57 = v55;
      else
        v57 = v56;
      v58 = (v29 | v57 & 0x10) != 0;
      v59 = v57 & 0xFFFF87FF | ((v29 != 0) << 12);
      v60 = v59 | (v58 << 14);
      *(_WORD *)(v35 + 2 * v21) = v57 & 0x87FF | ((v29 != 0) << 12) | (v58 << 14);
      if (!v29)
        goto LABEL_91;
      v61 = *(float *)(v36 + 4 * v21);
      if ((v57 & 0x10) == 0)
        v61 = 0.0;
      v62 = v61 <= 0.0 && v29 <= 2;
      v63 = 1 << v29;
      if (!v62)
        v63 = 8;
      if (v63 != 8)
      {
        if (v63 != 4)
          goto LABEL_91;
        v60 |= 0x2000u;
        *(_WORD *)(v35 + 2 * v21) = v60;
        if ((v57 & 3) != 0)
          goto LABEL_91;
        if ((v57 & 4) != 0)
        {
          LOWORD(v59) = v59 | 0x2000;
        }
        else
        {
          if (v19 == 6)
          {
            v67 = *(_QWORD *)(v2 + 240);
            if (((*(unsigned __int8 *)(v67 + v25[3]) ^ *(unsigned __int8 *)(v67 + *v25)) & 4) != 0
              || ((*(unsigned __int8 *)(v67 + v25[4]) ^ *(unsigned __int8 *)(v67 + v25[1])) & 4) != 0)
            {
              v68 = 0x4000;
            }
            else
            {
              v68 = 0;
            }
            LOWORD(v64) = v59 | v68;
          }
          else
          {
            if (v19 != 4)
              goto LABEL_91;
            v64 = v59 | ((((*(unsigned __int8 *)(*(_QWORD *)(v2 + 240) + v25[2]) ^ *(unsigned __int8 *)(*(_QWORD *)(v2 + 240) + *v25)) >> 2) & 1) << 14);
          }
          LOWORD(v59) = v64 | 0x2000;
        }
LABEL_90:
        *(_WORD *)(v35 + 2 * v21) = v59;
        LOBYTE(v60) = v59;
        goto LABEL_91;
      }
      v66 = (v57 & 0x10) == 0 && v26 < 3;
      if (v29 == v26 && !v66)
        goto LABEL_90;
LABEL_91:
      if (v4 && (v60 & 4) != 0 && (int)v40 >= 1)
      {
        v69 = (int *)(v37 + 4 * v39);
        do
        {
          v70 = *v69++;
          *(_BYTE *)(*(_QWORD *)(v2 + 96) + v70) |= 1u;
          *((_BYTE *)a1 + 8) |= 2u;
          --v40;
        }
        while (v40);
      }
      if (++v21 >= *(int *)(v2 + 8))
        return 1;
    }
    v41 = 0;
LABEL_34:
    v42 = *(_WORD *)(v35 + 2 * v21);
    if ((v42 & 1) == 0 || v27 == 2 && !v30 && (int)v40 > v26)
      goto LABEL_39;
    goto LABEL_38;
  }
  return 1;
}

uint64_t OpenSubdiv::v3_1_1::Far::TopologyRefinerFactoryBase::prepareFaceVaryingChannels(OpenSubdiv::v3_1_1::Far::TopologyRefinerFactoryBase *this, OpenSubdiv::v3_1_1::Far::TopologyRefiner *a2)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v15;

  v3 = **((_QWORD **)this + 5);
  v4 = *(_DWORD *)this;
  OpenSubdiv::v3_1_1::Sdc::staticTraitsTable(this);
  v11 = OpenSubdiv::v3_1_1::Sdc::staticTraitsTable(void)::staticTraitsTable[3 * v4 + 2];
  v12 = v11 + (v11 < 0);
  if ((int)((*(_QWORD *)(**((_QWORD **)this + 5) + 464) - *(_QWORD *)(**((_QWORD **)this + 5) + 456)) >> 3) < 1)
    return 1;
  v13 = 0;
  v14 = v12 >> 1;
  while (1)
  {
    v15 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(_QWORD *)(v3 + 456) + 8 * v13);
    if (!*((_DWORD *)v15 + 4))
      break;
    OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::completeTopologyFromFaceValues(v15, v14);
    if (++v13 >= (int)((*(_QWORD *)(**((_QWORD **)this + 5) + 464) - *(_QWORD *)(**((_QWORD **)this + 5) + 456)) >> 3))
      return 1;
  }
  OpenSubdiv::v3_1_1::Far::Error(4, (uint64_t)"Failure in TopologyRefinerFactory<>::Create() -- face-varying channel %d has no values.", v5, v6, v7, v8, v9, v10, v13);
  return 0;
}

void OpenSubdiv::v3_1_1::Far::PtexIndices::initializePtexIndices(OpenSubdiv::v3_1_1::Sdc *a1, int *a2)
{
  unsigned int v4;
  int v5;
  unsigned int **v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  int v11;
  int *v12;
  _DWORD *v13;
  uint64_t v14;
  int v15;
  int v16;

  v4 = *a2;
  OpenSubdiv::v3_1_1::Sdc::staticTraitsTable(a1);
  v5 = HIDWORD(OpenSubdiv::v3_1_1::Sdc::staticTraitsTable(void)::staticTraitsTable[3 * v4 + 1]);
  v6 = (unsigned int **)*((_QWORD *)a2 + 5);
  v7 = *v6;
  v8 = (int)**v6;
  v9 = **v6;
  std::vector<unsigned int>::resize((std::vector<int> *)a1, v8 + 1);
  v10 = *(_DWORD **)a1;
  if ((int)v8 < 1)
  {
    v11 = 0;
  }
  else
  {
    v11 = 0;
    v12 = (int *)*((_QWORD *)v7 + 3);
    v13 = *(_DWORD **)a1;
    v14 = v9;
    do
    {
      *v13++ = v11;
      v16 = *v12;
      v12 += 2;
      v15 = v16;
      if (v16 == v5)
        v15 = 1;
      v11 += v15;
      --v14;
    }
    while (v14);
  }
  v10[(int)v9] = v11;
}

float OpenSubdiv::v3_1_1::Sdc::Crease::ComputeFractionalWeightAtVertex(OpenSubdiv::v3_1_1::Sdc::Crease *this, float a2, float a3, int a4, float *a5, const float *a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  float v9;
  float v10;
  float result;

  v6 = a2 > 0.0 && a3 <= 0.0;
  if (a2 <= 0.0 || a3 > 0.0)
    a2 = 0.0;
  if (a6 && (*(_WORD *)this & 0x60) != 0)
  {
    if (a4 >= 1)
    {
      v7 = a4;
      do
      {
        if (*a5 > 0.0 && *a6 <= 0.0)
        {
          a2 = a2 + *a5;
          ++v6;
        }
        ++a6;
        ++a5;
        --v7;
      }
      while (v7);
    }
  }
  else if (a4 >= 1)
  {
    v8 = a4;
    do
    {
      v9 = *a5++;
      v10 = v9;
      v6 += v9 > 0.0 && v9 <= 1.0;
      if (v9 <= 0.0 || v9 > 1.0)
        v10 = -0.0;
      a2 = a2 + v10;
      --v8;
    }
    while (v8);
  }
  if (!v6)
    return 0.0;
  result = a2 / (float)v6;
  if (result > 1.0)
    return 1.0;
  return result;
}

float OpenSubdiv::v3_1_1::Sdc::Crease::SubdivideEdgeSharpnessAtVertex(OpenSubdiv::v3_1_1::Sdc::Crease *this, float a2, int a3, float *a4)
{
  float v4;
  int v5;
  uint64_t v6;
  float v7;
  float v8;
  float v9;
  int v10;
  BOOL v11;
  int v12;

  if (a3 >= 2 && (*(_WORD *)this & 0x60) != 0)
  {
    v4 = 0.0;
    if (a2 > 0.0)
    {
      v4 = 10.0;
      if (a2 < 10.0)
      {
        v5 = 0;
        v6 = a3;
        v7 = 0.0;
        do
        {
          v8 = *a4++;
          v9 = v8;
          v10 = v8 > 0.0 && v8 < 10.0;
          if (v8 <= 0.0 || v8 >= 10.0)
            v9 = -0.0;
          v7 = v7 + v9;
          v5 += v10;
          --v6;
        }
        while (v6);
        v11 = v5 != 0;
        v12 = v5 - 1;
        if (v12 != 0 && v11)
          a2 = (float)((float)((float)(v7 - a2) / (float)v12) * 0.25) + (float)(a2 * 0.75);
        return fmaxf(a2 + -1.0, 0.0);
      }
    }
  }
  else
  {
    v4 = 0.0;
    if (a2 > 0.0)
    {
      v4 = 10.0;
      if (a2 < 10.0)
      {
        v4 = 0.0;
        if (a2 > 1.0)
          return a2 + -1.0;
      }
    }
  }
  return v4;
}

_WORD *OpenSubdiv::v3_1_1::Sdc::Crease::SubdivideEdgeSharpnessesAroundVertex(_WORD *this, int a2, float *a3, float *a4)
{
  int v4;
  uint64_t v5;
  float v6;
  float *v7;
  uint64_t v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  int v14;
  uint64_t v15;
  float v16;
  float v17;

  if (a2 > 1 && (*this & 0x60) != 0)
  {
    if ((*this & 0x60) == 0x20)
    {
      v4 = 0;
      v5 = a2;
      v6 = 0.0;
      v7 = a3;
      v8 = a2;
      do
      {
        v9 = *v7++;
        v10 = v9;
        v4 += v9 > 0.0 && v9 < 10.0;
        if (v9 <= 0.0 || v9 >= 10.0)
          v10 = -0.0;
        v6 = v6 + v10;
        --v8;
      }
      while (v8);
      if (v4)
      {
        while (1)
        {
          v11 = *a3;
          v12 = 0.0;
          if (*a3 <= 0.0)
            goto LABEL_16;
          v12 = 10.0;
          if (v11 >= 10.0)
            goto LABEL_16;
          if (v4 == 1)
            break;
          v13 = (float)((float)((float)((float)(v6 - v11) / (float)(v4 - 1)) * 0.25) + (float)(v11 * 0.75)) + -1.0;
          v12 = 0.0;
          if (v13 <= 0.0)
            goto LABEL_16;
LABEL_17:
          *a4++ = v13;
          ++a3;
          if (!--v5)
            return this;
        }
        v12 = v11 + -1.0;
        if (v11 <= 1.0)
          v12 = 0.0;
LABEL_16:
        v13 = v12;
        goto LABEL_17;
      }
      do
      {
        v14 = *(_DWORD *)a3++;
        *(_DWORD *)a4++ = v14;
        --v5;
      }
      while (v5);
    }
  }
  else if (a2 >= 1)
  {
    v15 = a2;
    do
    {
      v16 = *a3;
      v17 = 0.0;
      if (*a3 > 0.0)
      {
        v17 = 10.0;
        if (v16 < 10.0)
        {
          v17 = 0.0;
          if (v16 > 1.0)
            v17 = v16 + -1.0;
        }
      }
      *a4++ = v17;
      ++a3;
      --v15;
    }
    while (v15);
  }
  return this;
}

void OpenSubdiv::v3_1_1::Vtr::internal::Level::~Level(OpenSubdiv::v3_1_1::Vtr::internal::Level *this)
{
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;

  v4 = (char *)this + 456;
  v2 = (OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)*((_QWORD *)this + 57);
  v3 = *((_QWORD *)v4 + 1);
  if ((int)((unint64_t)(v3 - (_QWORD)v2) >> 3) >= 1)
  {
    v5 = 0;
    do
    {
      if (v2[v5])
      {
        OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::~FVarLevel(v2[v5]);
        MEMORY[0x2276933B8]();
        v2 = (OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)*((_QWORD *)this + 57);
        v3 = *((_QWORD *)this + 58);
      }
      ++v5;
    }
    while (v5 < (int)((unint64_t)(v3 - (_QWORD)v2) >> 3));
  }
  if (v2)
  {
    *((_QWORD *)this + 58) = v2;
    operator delete(v2);
  }
  v6 = (void *)*((_QWORD *)this + 54);
  if (v6)
  {
    *((_QWORD *)this + 55) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 51);
  if (v7)
  {
    *((_QWORD *)this + 52) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 48);
  if (v8)
  {
    *((_QWORD *)this + 49) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 45);
  if (v9)
  {
    *((_QWORD *)this + 46) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 42);
  if (v10)
  {
    *((_QWORD *)this + 43) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 39);
  if (v11)
  {
    *((_QWORD *)this + 40) = v11;
    operator delete(v11);
  }
  v12 = (void *)*((_QWORD *)this + 36);
  if (v12)
  {
    *((_QWORD *)this + 37) = v12;
    operator delete(v12);
  }
  v13 = (void *)*((_QWORD *)this + 33);
  if (v13)
  {
    *((_QWORD *)this + 34) = v13;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)this + 30);
  if (v14)
  {
    *((_QWORD *)this + 31) = v14;
    operator delete(v14);
  }
  v15 = (void *)*((_QWORD *)this + 27);
  if (v15)
  {
    *((_QWORD *)this + 28) = v15;
    operator delete(v15);
  }
  v16 = (void *)*((_QWORD *)this + 24);
  if (v16)
  {
    *((_QWORD *)this + 25) = v16;
    operator delete(v16);
  }
  v17 = (void *)*((_QWORD *)this + 21);
  if (v17)
  {
    *((_QWORD *)this + 22) = v17;
    operator delete(v17);
  }
  v18 = (void *)*((_QWORD *)this + 18);
  if (v18)
  {
    *((_QWORD *)this + 19) = v18;
    operator delete(v18);
  }
  v19 = (void *)*((_QWORD *)this + 15);
  if (v19)
  {
    *((_QWORD *)this + 16) = v19;
    operator delete(v19);
  }
  v20 = (void *)*((_QWORD *)this + 12);
  if (v20)
  {
    *((_QWORD *)this + 13) = v20;
    operator delete(v20);
  }
  v21 = (void *)*((_QWORD *)this + 9);
  if (v21)
  {
    *((_QWORD *)this + 10) = v21;
    operator delete(v21);
  }
  v22 = (void *)*((_QWORD *)this + 6);
  if (v22)
  {
    *((_QWORD *)this + 7) = v22;
    operator delete(v22);
  }
  v23 = (void *)*((_QWORD *)this + 3);
  if (v23)
  {
    *((_QWORD *)this + 4) = v23;
    operator delete(v23);
  }
}

BOOL OpenSubdiv::v3_1_1::Vtr::internal::Level::validateTopology(OpenSubdiv::v3_1_1::Vtr::internal::Level *this, void (*a2)(uint64_t, char *, uint64_t), uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  unsigned __int16 *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int *v34;
  unsigned __int16 *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  char v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int *v49;
  unsigned __int16 *v50;
  int v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  _BOOL4 v63;
  uint64_t v64;
  BOOL v65;
  _BOOL4 v67;
  _BOOL4 v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int *v77;
  uint64_t v78;
  void *__p;
  char __str[1024];
  uint64_t v81;

  v81 = *MEMORY[0x24BDAC8D0];
  v6 = *((_QWORD *)this + 6);
  if (((*((_QWORD *)this + 7) - v6) & 0x3FFFFFFFCLL) == 0)
  {
    if (!a2)
      return 0;
    snprintf(__str, 0x400uLL, "%s - missing face-verts", "MISSING_FACE_VERTS");
    a2(3, __str, a3);
    v8 = *((_QWORD *)this + 37) - *((_QWORD *)this + 36);
    v63 = 1;
LABEL_65:
    v65 = 0;
    if (v63 && (v8 & 0x3FFFFFFFCLL) == 0)
    {
      snprintf(__str, 0x400uLL, "%s - missing vert-faces", "MISSING_VERT_FACES");
      v64 = 4;
      goto LABEL_68;
    }
    return v65;
  }
  v7 = *((_QWORD *)this + 36);
  v8 = *((_QWORD *)this + 37) - v7;
  if ((v8 & 0x3FFFFFFFCLL) == 0)
  {
    v63 = a2 != 0;
    goto LABEL_65;
  }
  v9 = *(unsigned int *)this;
  if ((int)v9 >= 1)
  {
    v10 = 0;
    while (1)
    {
      v11 = (unsigned int *)(*((_QWORD *)this + 3) + 8 * v10);
      v12 = *v11;
      if ((int)v12 >= 1)
        break;
LABEL_14:
      if (++v10 == v9)
        goto LABEL_15;
    }
    v13 = 0;
    v14 = v6 + 4 * (int)v11[1];
    v15 = *((_QWORD *)this + 33);
    while (1)
    {
      v16 = *(int *)(v14 + 4 * v13);
      v17 = *(unsigned int *)(v15 + 8 * (_DWORD)v16);
      if ((int)v17 < 1)
        break;
      v18 = *(int *)(v15 + 8 * v16 + 4);
      v19 = (int *)(v7 + 4 * v18);
      v20 = (unsigned __int16 *)(*((_QWORD *)this + 39) + 2 * v18);
      while (1)
      {
        v21 = *v19++;
        if (v10 == v21 && v13 == *v20)
          break;
        ++v20;
        if (!--v17)
          goto LABEL_61;
      }
      if (++v13 == v12)
        goto LABEL_14;
    }
LABEL_61:
    if (!a2)
      return 0;
    snprintf(__str, 0x400uLL, "%s - face %d correlation of vert %d failed");
    goto LABEL_63;
  }
LABEL_15:
  v22 = *((_QWORD *)this + 21);
  if (((*((_QWORD *)this + 22) - v22) & 0x3FFFFFFFCLL) == 0)
  {
    if (!a2)
      return 0;
    snprintf(__str, 0x400uLL, "%s - missing edge-faces", "MISSING_EDGE_FACES");
    a2(0, __str, a3);
    v24 = *((_QWORD *)this + 10) - *((_QWORD *)this + 9);
    v67 = 1;
LABEL_76:
    v65 = 0;
    if (v67 && (v24 & 0x3FFFFFFFCLL) == 0)
    {
      snprintf(__str, 0x400uLL, "%s - missing face-edges", "MISSING_FACE_EDGES");
      v64 = 2;
      goto LABEL_68;
    }
    return v65;
  }
  v23 = *((_QWORD *)this + 9);
  v24 = *((_QWORD *)this + 10) - v23;
  if ((v24 & 0x3FFFFFFFCLL) == 0)
  {
    v67 = a2 != 0;
    goto LABEL_76;
  }
  if ((int)v9 >= 1)
  {
    v25 = 0;
    while (1)
    {
      v26 = (unsigned int *)(*((_QWORD *)this + 3) + 8 * v25);
      v27 = *v26;
      if ((int)v27 >= 1)
        break;
LABEL_28:
      if (++v25 == v9)
        goto LABEL_29;
    }
    v28 = 0;
    v29 = v23 + 4 * (int)v26[1];
    v30 = *((_QWORD *)this + 18);
    while (1)
    {
      v31 = *(int *)(v29 + 4 * v28);
      v32 = *(unsigned int *)(v30 + 8 * (_DWORD)v31);
      if ((int)v32 < 1)
        break;
      v33 = *(int *)(v30 + 8 * v31 + 4);
      v34 = (int *)(v22 + 4 * v33);
      v35 = (unsigned __int16 *)(*((_QWORD *)this + 24) + 2 * v33);
      while (1)
      {
        v36 = *v34++;
        if (v25 == v36 && v28 == *v35)
          break;
        ++v35;
        if (!--v32)
          goto LABEL_73;
      }
      if (++v28 == v27)
        goto LABEL_28;
    }
LABEL_73:
    if (!a2)
      return 0;
    snprintf(__str, 0x400uLL, "%s - face %d correlation of edge %d failed", "FAILED_CORRELATION_FACE_EDGE", v25, v28);
    v64 = 8;
    goto LABEL_68;
  }
LABEL_29:
  v37 = *((_QWORD *)this + 15);
  if (((*((_QWORD *)this + 16) - v37) & 0x3FFFFFFFCLL) == 0)
  {
    if (!a2)
      return 0;
    snprintf(__str, 0x400uLL, "%s - missing edge-verts", "MISSING_EDGE_VERTS");
    v68 = 1;
    a2(1, __str, a3);
    v39 = *((_QWORD *)this + 46) - *((_QWORD *)this + 45);
LABEL_84:
    v65 = 0;
    if (v68 && (v39 & 0x3FFFFFFFCLL) == 0)
    {
      snprintf(__str, 0x400uLL, "%s - missing vert-edges", "MISSING_VERT_EDGES");
      v64 = 5;
      goto LABEL_68;
    }
    return v65;
  }
  v38 = *((_QWORD *)this + 45);
  v39 = *((_QWORD *)this + 46) - v38;
  if ((v39 & 0x3FFFFFFFCLL) == 0)
  {
    v68 = a2 != 0;
    goto LABEL_84;
  }
  v40 = *((unsigned int *)this + 1);
  if ((int)v40 >= 1)
  {
    v41 = 0;
    v42 = *((_QWORD *)this + 42);
LABEL_33:
    v43 = 0;
    v44 = 1;
    while (1)
    {
      v45 = v44;
      v46 = *(int *)(v37 + 8 * v41 + 4 * v43);
      v47 = *(unsigned int *)(v42 + 8 * (_DWORD)v46);
      if ((int)v47 < 1)
        break;
      v48 = *(int *)(v42 + 8 * v46 + 4);
      v49 = (int *)(v38 + 4 * v48);
      v50 = (unsigned __int16 *)(*((_QWORD *)this + 48) + 2 * v48);
      while (1)
      {
        v51 = *v49++;
        if (v41 == v51 && v43 == *v50)
          break;
        ++v50;
        if (!--v47)
          goto LABEL_81;
      }
      v44 = 0;
      v43 = 1;
      if ((v45 & 1) == 0)
      {
        if (++v41 != v40)
          goto LABEL_33;
        goto LABEL_42;
      }
    }
LABEL_81:
    if (!a2)
      return 0;
    snprintf(__str, 0x400uLL, "%s - edge %d correlation of vert %d failed");
LABEL_63:
    v64 = 7;
LABEL_68:
    a2(v64, __str, a3);
    return 0;
  }
LABEL_42:
  v52 = 2 * *((_DWORD *)this + 5);
  v77 = (int *)&v78;
  __p = 0;
  if (v52 >= 0x21)
  {
    __p = operator new(4 * v52);
    v77 = (int *)__p;
  }
  if (*((int *)this + 2) < 1)
  {
LABEL_87:
    v69 = *((unsigned int *)this + 1);
    if ((int)v69 < 1)
    {
LABEL_93:
      v65 = 1;
    }
    else
    {
      v70 = 0;
      v71 = 0;
      v65 = 0;
      while (1)
      {
        if ((*(_BYTE *)(*((_QWORD *)this + 30) + v71) & 1) == 0)
        {
          if (*(_DWORD *)(*((_QWORD *)this + 15) + v70) == *(_DWORD *)(*((_QWORD *)this + 15) + v70 + 4))
          {
            if (!a2)
              goto LABEL_100;
            snprintf(__str, 0x400uLL, "%s - Error in eIndex = %d:  degenerate edge not tagged marked non-manifold", "DEGENERATE_EDGE", v71);
            v74 = 12;
            goto LABEL_105;
          }
          v72 = *(_DWORD *)(*((_QWORD *)this + 18) + v70);
          if ((v72 - 3) <= 0xFFFFFFFD)
            break;
        }
        v65 = ++v71 >= v69;
        v70 += 8;
        if (v69 == v71)
          goto LABEL_93;
      }
      if (!a2)
        goto LABEL_100;
      snprintf(__str, 0x400uLL, "%s - edge %d with %d incident faces not tagged non-manifold", "NON_MANIFOLD_EDGE", v71, v72);
      v74 = 13;
LABEL_105:
      a2(v74, __str, a3);
    }
  }
  else
  {
    v53 = 0;
    while (1)
    {
      if ((*(_WORD *)(*((_QWORD *)this + 54) + 2 * v53) & 0x801) == 0)
      {
        v54 = *((_QWORD *)this + 33);
        v55 = (8 * v53) | 4;
        v56 = *(int *)(v54 + v55);
        v57 = *((_QWORD *)this + 36);
        v58 = *(int *)(v54 + 8 * v53);
        v59 = *((_QWORD *)this + 42);
        v75 = *(int *)(v59 + v55);
        v76 = *((_QWORD *)this + 45);
        v60 = *(unsigned int *)(v59 + 8 * v53);
        if (!OpenSubdiv::v3_1_1::Vtr::internal::Level::orderVertexFacesAndEdges(this, v53, v77, &v77[v58]))
        {
          if (a2)
          {
            snprintf(__str, 0x400uLL, "%s - vertex %d cannot orient incident faces and edges", "FAILED_ORIENTATION_INCIDENT_FACES_EDGES", v53);
            v73 = 11;
            goto LABEL_98;
          }
          goto LABEL_99;
        }
        if ((int)v58 >= 1)
        {
          v61 = 0;
          while (*(_DWORD *)(v57 + 4 * v56 + 4 * v61) == v77[v61])
          {
            if (v58 == ++v61)
              goto LABEL_54;
          }
          if (a2)
          {
            snprintf(__str, 0x400uLL, "%s - vertex %d orientation failure at incident face %d", "FAILED_ORIENTATION_INCIDENT_FACE", v53, v61);
            v73 = 10;
LABEL_98:
            a2(v73, __str, a3);
            goto LABEL_99;
          }
          goto LABEL_99;
        }
LABEL_54:
        if ((int)v60 >= 1)
          break;
      }
LABEL_47:
      if (++v53 >= *((int *)this + 2))
        goto LABEL_87;
    }
    v62 = 0;
    while (*(_DWORD *)(v76 + 4 * v75 + 4 * v62) == v77[v58 + v62])
    {
      if (v60 == ++v62)
        goto LABEL_47;
    }
    if (a2)
    {
      snprintf(__str, 0x400uLL, "%s - vertex %d orientation failure at incident edge %d", "FAILED_ORIENTATION_INCIDENT_EDGE", v53, v62);
      v73 = 9;
      goto LABEL_98;
    }
LABEL_99:
    v65 = 0;
  }
LABEL_100:
  operator delete(__p);
  return v65;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Level::orderVertexFacesAndEdges(OpenSubdiv::v3_1_1::Vtr::internal::Level *this, __int32 __c, int *a3, int *a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  unint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __int32 *v19;
  size_t v20;
  __int32 *v21;
  __int32 *v22;
  __int32 *v23;
  unint64_t v24;
  int v25;
  int *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  __int32 *v32;
  size_t v33;
  __int32 *v34;
  __int32 *v35;
  __int32 *v36;
  int v37;
  int *v38;
  uint64_t v39;
  int v40;
  __int32 v41;
  unint64_t v42;
  int v43;
  __int32 v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v49;
  int *v50;
  int v51;
  int v52;
  __int32 *v53;
  size_t v54;
  __int32 *v55;
  __int32 *v56;
  __int32 *v57;
  uint64_t v58;
  int v60;

  v5 = *((_QWORD *)this + 42);
  v6 = 8 * __c;
  v7 = *(unsigned int *)(v5 + v6);
  v8 = *((_QWORD *)this + 33);
  v9 = *(_DWORD *)(v8 + v6);
  if (v9)
    v10 = (int)v7 < 2;
  else
    v10 = 1;
  if (!v10 && (int)v7 - v9 <= 1)
  {
    v15 = (8 * ((unint64_t)(2 * __c) >> 1)) | 4;
    v60 = v9;
    v58 = v7;
    if ((_DWORD)v7 == v9)
    {
      v16 = *(int *)(*((_QWORD *)this + 36) + 4 * *(int *)(v8 + v15));
      v17 = (2 * v16) | 1;
      v18 = *((_QWORD *)this + 3);
      v19 = (__int32 *)(*((_QWORD *)this + 6) + 4 * *(int *)(v18 + 4 * v17));
      v20 = *(int *)(v18 + 8 * v16);
      v21 = &v19[v20];
      v22 = wmemchr(v19, __c, v20);
      if (v22)
        v23 = v22;
      else
        v23 = v21;
      v24 = (unint64_t)((char *)v23 - (char *)v19) >> 2;
      v25 = *(_DWORD *)(*((_QWORD *)this + 9) + 4 * *(int *)(*((_QWORD *)this + 3) + 4 * v17) + 4 * (int)v24);
    }
    else
    {
      LODWORD(v24) = 0;
      v26 = (int *)(*((_QWORD *)this + 45) + 4 * *(int *)(v5 + v15));
      LODWORD(v16) = -1;
      v25 = -1;
      do
      {
        v28 = *v26++;
        v27 = v28;
        v29 = *((_QWORD *)this + 18);
        if (*(_DWORD *)(v29 + 8 * v28) == 1)
        {
          v16 = *(int *)(*((_QWORD *)this + 21) + 4 * *(int *)(v29 + 4 * ((2 * v27) | 1)));
          v30 = (2 * v16) | 1;
          v31 = *((_QWORD *)this + 3);
          v32 = (__int32 *)(*((_QWORD *)this + 6) + 4 * *(int *)(v31 + 4 * v30));
          v33 = *(int *)(v31 + 8 * v16);
          v34 = &v32[v33];
          v35 = wmemchr(v32, __c, v33);
          v36 = v35 ? v35 : v34;
          v24 = (unint64_t)((char *)v36 - (char *)v32) >> 2;
          v37 = *(_DWORD *)(*((_QWORD *)this + 9) + 4 * *(int *)(*((_QWORD *)this + 3) + 4 * v30) + 4 * (int)v24);
          v25 = v27;
          if (v27 == v37)
            break;
        }
        --v7;
      }
      while (v7);
    }
    *a3 = v16;
    *a4 = v25;
    v38 = a4 + 1;
    v39 = v58 - 1;
    v40 = 1;
    v41 = v25;
    LODWORD(v42) = v24;
    v43 = v60;
    while (1)
    {
      v44 = v41;
      v45 = *((_QWORD *)this + 3);
      v46 = *(_DWORD *)(v45 + 8 * (int)v16);
      v47 = *((_QWORD *)this + 9);
      if ((_DWORD)v42)
        v46 = v42;
      v41 = *(_DWORD *)(v47 + 4 * *(int *)(v45 + 8 * (_DWORD)v16 + 4) + 4 * (v46 - 1));
      if (v41 == v44 || v41 == v25)
        break;
      *v38 = v41;
      if (v40 < v43)
      {
        v49 = *((_QWORD *)this + 18);
        v50 = (int *)(*((_QWORD *)this + 21) + 4 * *(int *)(v49 + 4 * ((2 * v41) | 1)));
        v51 = *(_DWORD *)(v49 + 8 * v41);
        if (v51 == 1)
        {
          v52 = *v50;
          if (*v50 == (_DWORD)v16)
            return 0;
        }
        else
        {
          if (!v51)
            return 0;
          v52 = *v50;
        }
        v16 = v50[v52 == (_DWORD)v16];
        v53 = (__int32 *)(v47 + 4 * *(int *)(v45 + 4 * (int)((2 * v16) | 1)));
        v54 = *(int *)(v45 + 8 * v16);
        v55 = &v53[v54];
        v56 = wmemchr(v53, v41, v54);
        v43 = v60;
        if (v56)
          v57 = v56;
        else
          v57 = v55;
        v42 = (unint64_t)((char *)v57 - (char *)v53) >> 2;
        a3[v40++] = v16;
      }
      ++v38;
      if (!--v39)
        return 1;
    }
  }
  return 0;
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::Level::getFaceVTags(_QWORD *result, int a2, _WORD *a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int *v14;
  int v15;
  unsigned int v16;
  __int16 v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;

  v4 = (2 * a2) | 1;
  v5 = result[3];
  v6 = (int *)(result[6] + 4 * *(int *)(v5 + 4 * v4));
  v7 = *(unsigned int *)(v5 + 8 * a2);
  if ((a4 & 0x80000000) != 0)
  {
    if ((int)v7 >= 1)
    {
      do
      {
        v21 = *v6++;
        *a3++ = *(_WORD *)(result[54] + 2 * v21);
        --v7;
      }
      while (v7);
    }
  }
  else if ((int)v7 >= 1)
  {
    v8 = 0;
    v9 = *(_QWORD **)(result[57] + 8 * a4);
    v10 = v9[3] + 4 * *(int *)(*(_QWORD *)(*v9 + 24) + 4 * v4);
    do
    {
      v11 = v6[v8];
      v12 = *(_DWORD *)(v10 + 4 * v8);
      if (*(int *)(*v9 + 12) <= 0)
      {
        v13 = *(int *)(v9[12] + 4 * v11);
        v12 = v13 - 1;
        v14 = (int *)(v9[18] + 4 * v13);
        do
        {
          v15 = *v14++;
          ++v12;
        }
        while (v15 != *(_DWORD *)(v10 + 4 * v8));
      }
      v16 = *(unsigned __int8 *)(v9[21] + v12);
      LOWORD(v11) = *(_WORD *)(result[54] + 2 * v11);
      if ((v16 & 1) != 0)
      {
        v17 = v11 & 0xD867;
        v18 = v17 | 0x2200;
        if ((v16 & 0x80u) == 0)
          v19 = ~(v16 >> 3) & 8;
        else
          LOWORD(v19) = 0;
        v20 = v17 | 0x410 | v19;
        if ((v16 & 8) != 0)
          v20 = v18;
        LODWORD(v11) = v20 & 0xAFF8 | (((v16 >> 7) & 1) << 14) | v16 & 2 | (v16 >> 2) & 1 | 0x1004;
      }
      a3[v8++] = v11;
    }
    while (v8 != v7);
  }
  return result;
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::Level::getFaceETags(_QWORD *result, int a2, _BYTE *a3, unsigned int a4)
{
  uint64_t v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  uint64_t v10;

  v4 = result[3];
  v5 = (int *)(result[9] + 4 * *(int *)(v4 + 8 * a2 + 4));
  v6 = *(unsigned int *)(v4 + 8 * a2);
  if ((a4 & 0x80000000) != 0)
  {
    if ((int)v6 >= 1)
    {
      do
      {
        v10 = *v5++;
        *a3++ = *(_BYTE *)(result[30] + v10);
        --v6;
      }
      while (v6);
    }
  }
  else if ((int)v6 >= 1)
  {
    v7 = *(_QWORD *)(result[57] + 8 * a4);
    do
    {
      v8 = *v5++;
      v9 = *(_BYTE *)(result[30] + v8);
      if ((*(_BYTE *)(*(_QWORD *)(v7 + 48) + v8) & 1) != 0)
        v9 |= 6u;
      *a3++ = v9;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Level::getFaceCompositeVTag(OpenSubdiv::v3_1_1::Vtr::internal::Level *this, int a2, unsigned int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  _QWORD *v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  __int16 v15;
  size_t v16;
  int *v17;
  unsigned __int8 *v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  __int16 v22;
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  size_t v27;
  int *v28;
  uint64_t v29;
  unsigned __int8 *v31;
  _BYTE v32[64];
  void *__p;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v5 = *((_QWORD *)this + 3);
  v6 = *(int *)(v5 + 8 * a2 + 4);
  v7 = *((_QWORD *)this + 6);
  v8 = *(unsigned int *)(v5 + 8 * a2);
  if ((a3 & 0x80000000) != 0)
  {
    v26 = *((_QWORD *)this + 54);
    v12 = *(unsigned __int16 *)(v26 + 2 * *(int *)(v7 + 4 * v6));
    if ((int)v8 >= 2)
    {
      v27 = v8 - 1;
      v28 = (int *)(v7 + 4 * v6 + 4);
      do
      {
        v29 = *v28++;
        v12 = *(unsigned __int16 *)(v26 + 2 * v29) | v12;
        --v27;
      }
      while (v27);
    }
  }
  else
  {
    v9 = *(_QWORD **)(*((_QWORD *)this + 57) + 8 * a3);
    v10 = v32;
    v31 = v32;
    __p = 0;
    if (v8 >= 0x41)
    {
      v10 = operator new(v8);
      __p = v10;
      v31 = v10;
    }
    OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getFaceValueTags(v9, a2, (uint64_t)v10);
    v11 = *((_QWORD *)this + 54);
    v12 = *(unsigned __int16 *)(v11 + 2 * *(int *)(v7 + 4 * v6));
    v13 = *v31;
    if ((v13 & 1) != 0)
    {
      if ((v13 & 0x80u) == 0)
        v14 = ~(v13 >> 3) & 8;
      else
        LOWORD(v14) = 0;
      v15 = v12 & 0xD867 | v14 | 0x410;
      if ((v13 & 8) != 0)
        v15 = v12 & 0xD867 | 0x2200;
      v12 = v15 & 0xAFF8 | (((v13 >> 7) & 1) << 14) | v13 & 2 | (v13 >> 2) & 1 | 0x1004;
    }
    if ((int)v8 >= 2)
    {
      v16 = v8 - 1;
      v17 = (int *)(v7 + 4 * v6 + 4);
      v18 = v31 + 1;
      do
      {
        v19 = *v17++;
        v20 = *(unsigned __int16 *)(v11 + 2 * v19);
        LODWORD(v19) = *v18++;
        v21 = v19;
        if ((v19 & 1) != 0)
        {
          v22 = v20 & 0xD867;
          v23 = v22 | 0x2200;
          if ((v21 & 0x80u) == 0)
            v24 = ~(v21 >> 3) & 8;
          else
            LOWORD(v24) = 0;
          v25 = v22 | v24 | 0x410;
          if ((v21 & 8) != 0)
            v25 = v23;
          v20 = v25 & 0xAFF8 | (((v21 >> 7) & 1) << 14) | v21 & 2 | (v21 >> 2) & 1 | 0x1004;
        }
        v12 = v20 | v12;
        --v16;
      }
      while (v16);
    }
    operator delete(__p);
  }
  return v12;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Level::getVertexCompositeFVarVTag(OpenSubdiv::v3_1_1::Vtr::internal::Level *this, int a2, int a3)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  uint64_t result;
  uint64_t v9;
  __int16 v10;
  int v11;
  __int16 v12;
  __int16 v13;
  uint64_t v14;
  unsigned __int8 *v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  int v19;
  __int16 v20;

  v3 = *(_QWORD **)(*((_QWORD *)this + 57) + 8 * a3);
  v4 = *(int *)(v3[12] + 4 * a2);
  v5 = v3[21];
  v6 = *(unsigned __int16 *)(*((_QWORD *)this + 54) + 2 * a2);
  v7 = *(unsigned __int8 *)(v5 + v4);
  if ((v7 & 1) == 0)
    return *(unsigned __int16 *)(*((_QWORD *)this + 54) + 2 * a2);
  v9 = *(unsigned __int16 *)(v3[9] + 2 * a2);
  v10 = v6 & 0xD867;
  v11 = ~(v7 >> 3) & 8;
  if ((v7 & 0x80u) != 0)
    LOWORD(v11) = 0;
  v12 = v10 | 0x410 | v11;
  if ((v7 & 8) != 0)
    v13 = v6 & 0xD867 | 0x2200;
  else
    v13 = v12;
  result = v13 & 0xAFF8 | (((v7 >> 7) & 1) << 14) | v7 & 2 | (v7 >> 2) & 1 | 0x1004;
  if (v9 >= 2)
  {
    v14 = v9 - 1;
    v15 = (unsigned __int8 *)(v4 + v5 + 1);
    do
    {
      v17 = *v15++;
      v16 = v17;
      v18 = v6;
      if ((v17 & 1) != 0)
      {
        if ((v16 & 0x80u) == 0)
          v19 = ~(v16 >> 3) & 8;
        else
          LOWORD(v19) = 0;
        v20 = v10 | v19 | 0x410;
        if ((v16 & 8) != 0)
          v20 = v6 & 0xD867 | 0x2200;
        v18 = v20 & 0xAFF8 | (((v16 >> 7) & 1) << 14) | v16 & 2 | (v16 >> 2) & 1 | 0x1004;
      }
      result = v18 | result;
      --v14;
    }
    while (v14);
  }
  return result;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Level::gatherQuadRegularRingAroundVertex(OpenSubdiv::v3_1_1::Vtr::internal::Level *this, int a2, int *a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int *v8;
  __int16 *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  __int16 v20;
  int *v21;
  uint64_t v22;

  v4 = *((_QWORD *)this + 33);
  v5 = *(unsigned int *)(v4 + 8 * a2);
  if ((int)v5 < 1)
    return 0;
  v6 = 0;
  v7 = *(int *)(v4 + 8 * a2 + 4);
  v8 = (int *)(*((_QWORD *)this + 36) + 4 * v7);
  v9 = (__int16 *)(*((_QWORD *)this + 39) + 2 * v7);
  v10 = *(_DWORD *)(*((_QWORD *)this + 42) + 8 * a2);
  v11 = (v5 - 1);
  v12 = v5;
  do
  {
    v14 = *v8++;
    v13 = v14;
    if ((a4 & 0x80000000) != 0)
    {
      v18 = (int *)(*((_QWORD *)this + 3) + 4 * ((2 * v13) | 1));
      v16 = (_QWORD *)((char *)this + 48);
    }
    else
    {
      v15 = *(uint64_t **)(*((_QWORD *)this + 57) + 8 * a4);
      v17 = *v15;
      v16 = v15 + 3;
      v18 = (int *)(*(_QWORD *)(v17 + 24) + 4 * ((2 * v13) | 1));
    }
    v19 = *v16 + 4 * *v18;
    v20 = *v9;
    v21 = &a3[v6];
    *v21 = *(_DWORD *)(v19 + 4 * ((*v9 + 1) & 3));
    v22 = v6 + 2;
    v21[1] = *(_DWORD *)(v19 + 4 * (((_BYTE)v20 + 2) & 3));
    if (v10 > (int)v5 && !v11)
    {
      a3[v22] = *(_DWORD *)(v19 + 4 * (((_BYTE)v20 - 1) & 3));
      v22 = (v6 + 3);
    }
    --v11;
    ++v9;
    v6 = v22;
    --v12;
  }
  while (v12);
  return v22;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Level::gatherQuadRegularPartialRingAroundVertex(_QWORD *a1, int a2, unsigned __int16 *a3, uint64_t a4, unsigned int a5)
{
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t *v15;
  _QWORD *v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  __int16 v20;
  _DWORD *v21;
  uint64_t v22;

  v5 = *a3;
  if (!*a3)
    return 0;
  v6 = 0;
  v7 = a1[33];
  v8 = *(int *)(v7 + 8 * a2 + 4);
  v9 = a1[36] + 4 * v8;
  v10 = *(_DWORD *)(v7 + 8 * a2);
  v11 = a1[39] + 2 * v8;
  v12 = a3[1];
  do
  {
    v13 = (v12 % v10);
    v14 = *(_DWORD *)(v9 + 4 * v13);
    if ((a5 & 0x80000000) != 0)
    {
      v18 = (int *)(a1[3] + 4 * ((2 * v14) | 1));
      v16 = a1 + 6;
    }
    else
    {
      v15 = *(uint64_t **)(a1[57] + 8 * a5);
      v17 = *v15;
      v16 = v15 + 3;
      v18 = (int *)(*(_QWORD *)(v17 + 24) + 4 * ((2 * v14) | 1));
    }
    v19 = *v16 + 4 * *v18;
    v20 = *(_WORD *)(v11 + 2 * v13);
    v21 = (_DWORD *)(a4 + 4 * v6);
    *v21 = *(_DWORD *)(v19 + 4 * (((_BYTE)v20 + 1) & 3));
    v22 = v6 + 2;
    v21[1] = *(_DWORD *)(v19 + 4 * (((_BYTE)v20 + 2) & 3));
    if (v5 == 1 && (a3[2] & 1) == 0)
    {
      *(_DWORD *)(a4 + 4 * v22) = *(_DWORD *)(v19 + 4 * (((_BYTE)v20 - 1) & 3));
      v22 = (v6 + 3);
    }
    ++v12;
    v6 = v22;
    --v5;
  }
  while (v5);
  return v22;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Level::gatherQuadRegularInteriorPatchPoints(OpenSubdiv::v3_1_1::Vtr::internal::Level *this, int a2, int *a3, int a4, unsigned int a5)
{
  int *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  _DWORD *v20;
  char v21;
  uint64_t v22;
  int v23;
  _QWORD *v24;
  uint64_t v25;
  char v26;

  v5 = (int *)((char *)&OpenSubdiv::v3_1_1::Vtr::internal::Level::gatherQuadRegularInteriorPatchPoints(int,int *,int,int)const::rotationSequence
             + 4 * a4);
  v6 = (2 * a2) | 1;
  v7 = *((_QWORD *)this + 3);
  v8 = *((_QWORD *)this + 6);
  v9 = v8 + 4 * *(int *)(v7 + 4 * v6);
  if ((a5 & 0x80000000) != 0)
  {
    v11 = a5;
    v13 = v9;
  }
  else
  {
    v10 = v6;
    v11 = a5;
    v12 = *(_QWORD **)(*((_QWORD *)this + 57) + 8 * a5);
    v13 = v12[3] + 4 * *(int *)(*(_QWORD *)(*v12 + 24) + 4 * v10);
  }
  v14 = 0;
  *a3 = *(_DWORD *)(v13 + 4 * *v5);
  a3[1] = *(_DWORD *)(v13 + 4 * v5[1]);
  a3[2] = *(_DWORD *)(v13 + 4 * v5[2]);
  a3[3] = *(_DWORD *)(v13 + 4 * v5[3]);
  v15 = *((_QWORD *)this + 36);
  v16 = *((_QWORD *)this + 33);
  v17 = *((_QWORD *)this + 39);
  v18 = a3 + 6;
  do
  {
    v19 = *(int *)(v16 + 8 * *(int *)(v9 + 4 * v5[v14]) + 4);
    v20 = (_DWORD *)(v15 + 4 * v19);
    if (*v20 == a2)
    {
      v21 = 0;
    }
    else if (v20[1] == a2)
    {
      v21 = 1;
    }
    else if (v20[2] == a2)
    {
      v21 = 2;
    }
    else if (v20[3] == a2)
    {
      v21 = 3;
    }
    else
    {
      v21 = -1;
    }
    v22 = (v21 + 2) & 3;
    v23 = v20[v22];
    if ((a5 & 0x80000000) != 0)
    {
      v25 = v8 + 4 * *(int *)(v7 + 4 * ((2 * v23) | 1));
    }
    else
    {
      v24 = *(_QWORD **)(*((_QWORD *)this + 57) + 8 * v11);
      v25 = v24[3] + 4 * *(int *)(*(_QWORD *)(*v24 + 24) + 4 * ((2 * v23) | 1));
    }
    v26 = *(_WORD *)(v17 + 2 * v19 + 2 * v22);
    *(v18 - 2) = *(_DWORD *)(v25 + 4 * ((v26 + 1) & 3));
    *(v18 - 1) = *(_DWORD *)(v25 + 4 * ((v26 + 2) & 3));
    *v18 = *(_DWORD *)(v25 + 4 * ((v26 - 1) & 3));
    v18 += 3;
    ++v14;
  }
  while (v14 != 4);
  return 16;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Level::gatherQuadRegularBoundaryPatchPoints(OpenSubdiv::v3_1_1::Vtr::internal::Level *this, int a2, int *a3, int a4, unsigned int a5)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  char v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __int16 v30;
  __int16 v31;
  __int16 v32;
  __int16 v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;

  v5 = 0;
  v6 = (2 * a2) | 1;
  v7 = *((_QWORD *)this + 3);
  v8 = *((_QWORD *)this + 6);
  v9 = v8 + 4 * *(int *)(v7 + 4 * v6);
  v10 = v6;
  v11 = *((_QWORD *)this + 36);
  v12 = *((_QWORD *)this + 33);
  v13 = *(int *)(v12 + 8 * *(int *)(v9 + 4 * (((_BYTE)a4 + 2) & 3)) + 4);
  v14 = v11 + 4 * v13;
  v15 = *(int *)(v12 + 8 * *(int *)(v9 + 4 * (((_BYTE)a4 - 1) & 3)) + 4);
  v16 = v11 + 4 * v15;
  v17 = *((_QWORD *)this + 39);
  v18 = -1;
  v19 = -1;
  do
  {
    if (*(_DWORD *)(v14 + 4 * v5) == a2)
      v18 = v5;
    if (*(_DWORD *)(v16 + 4 * v5) == a2)
      v19 = v5;
    ++v5;
  }
  while (v5 != 4);
  v20 = (v18 + 1) & 3;
  v21 = (v18 + 2) & 3;
  v22 = (v19 + 2) & 3;
  v23 = v17 + 2 * v13;
  v24 = (v19 - 1) & 3;
  v25 = *(int *)(v14 + 4 * ((v18 + 1) & 3));
  v26 = *(int *)(v14 + 4 * ((v18 + 2) & 3));
  v27 = v17 + 2 * v15;
  v28 = *(int *)(v16 + 4 * v22);
  v29 = *(int *)(v16 + 4 * v24);
  v30 = *(_WORD *)(v23 + 2 * v20);
  v31 = *(_WORD *)(v23 + 2 * v21);
  v32 = *(_WORD *)(v27 + 2 * v22);
  v33 = *(_WORD *)(v27 + 2 * v24);
  if ((a5 & 0x80000000) == 0)
  {
    v34 = *(_QWORD **)(*((_QWORD *)this + 57) + 8 * a5);
    v7 = *(_QWORD *)(*v34 + 24);
    v8 = v34[3];
    v9 = v8 + 4 * *(int *)(v7 + 4 * v10);
  }
  v35 = *(int *)(v7 + 8 * v25 + 4);
  v36 = *(int *)(v7 + 8 * v26 + 4);
  v37 = *(int *)(v7 + 8 * v28 + 4);
  v38 = *(int *)(v7 + 8 * v29 + 4);
  *a3 = *(_DWORD *)(v9 + 4 * (((_BYTE)a4 + 1) & 3));
  a3[1] = *(_DWORD *)(v9 + 4 * (((_BYTE)a4 + 2) & 3));
  a3[2] = *(_DWORD *)(v9 + 4 * (((_BYTE)a4 - 1) & 3));
  a3[3] = *(_DWORD *)(v9 + 4 * a4);
  v39 = v8 + 4 * v36;
  a3[4] = *(_DWORD *)(v8 + 4 * v35 + 4 * (((_BYTE)v30 + 2) & 3));
  a3[5] = *(_DWORD *)(v39 + 4 * (((_BYTE)v31 + 1) & 3));
  a3[6] = *(_DWORD *)(v39 + 4 * (((_BYTE)v31 + 2) & 3));
  v40 = *(_DWORD *)(v39 + 4 * (((_BYTE)v31 - 1) & 3));
  v41 = v8 + 4 * v37;
  a3[7] = v40;
  a3[8] = *(_DWORD *)(v41 + 4 * (((_BYTE)v32 + 1) & 3));
  a3[9] = *(_DWORD *)(v41 + 4 * (((_BYTE)v32 + 2) & 3));
  a3[10] = *(_DWORD *)(v41 + 4 * (((_BYTE)v32 - 1) & 3));
  a3[11] = *(_DWORD *)(v8 + 4 * v38 + 4 * (((_BYTE)v33 + 2) & 3));
  return 12;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Level::gatherQuadRegularCornerPatchPoints(OpenSubdiv::v3_1_1::Vtr::internal::Level *this, int a2, int *a3, int a4, unsigned int a5)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int16 v21;
  __int16 v22;
  __int16 v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v5 = (2 * a2) | 1;
  v6 = *((_QWORD *)this + 3);
  v7 = *((_QWORD *)this + 6);
  v8 = v7 + 4 * *(int *)(v6 + 4 * v5);
  v9 = *(int *)(v8 + 4 * (((_BYTE)a4 + 2) & 3));
  v10 = 2 * v9;
  v11 = *((_QWORD *)this + 33);
  v12 = *(int *)(v11 + 8 * v9 + 4);
  v13 = *((_QWORD *)this + 36) + 4 * v12;
  v14 = *(unsigned int *)(v11 + 4 * v10);
  v15 = *((_QWORD *)this + 39) + 2 * v12;
  if ((int)v14 < 1)
  {
LABEL_5:
    LOBYTE(v16) = -1;
  }
  else
  {
    v16 = 0;
    while (*(_DWORD *)(v13 + 4 * v16) != a2)
    {
      if (v14 == ++v16)
        goto LABEL_5;
    }
  }
  v17 = ((_BYTE)v16 - 1) & 3;
  v18 = *(int *)(v13 + 4 * (((_BYTE)v16 + 1) & 3));
  v19 = *(int *)(v13 + 4 * (((_BYTE)v16 + 2) & 3));
  v20 = *(int *)(v13 + 4 * (((_BYTE)v16 - 1) & 3));
  v21 = *(_WORD *)(v15 + 2 * (((_BYTE)v16 + 1) & 3));
  v22 = *(_WORD *)(v15 + 2 * (((_BYTE)v16 + 2) & 3));
  v23 = *(_WORD *)(v15 + 2 * v17);
  if ((a5 & 0x80000000) == 0)
  {
    v24 = *(_QWORD **)(*((_QWORD *)this + 57) + 8 * a5);
    v6 = *(_QWORD *)(*v24 + 24);
    v7 = v24[3];
    v8 = v7 + 4 * *(int *)(v6 + 4 * v5);
  }
  v25 = *(int *)(v6 + 8 * v18 + 4);
  v26 = *(int *)(v6 + 8 * v19 + 4);
  v27 = *(int *)(v6 + 8 * v20 + 4);
  *a3 = *(_DWORD *)(v8 + 4 * a4);
  a3[1] = *(_DWORD *)(v8 + 4 * (((_BYTE)a4 + 1) & 3));
  a3[2] = *(_DWORD *)(v8 + 4 * (((_BYTE)a4 + 2) & 3));
  a3[3] = *(_DWORD *)(v8 + 4 * (((_BYTE)a4 - 1) & 3));
  v28 = v7 + 4 * v26;
  a3[4] = *(_DWORD *)(v7 + 4 * v25 + 4 * (((_BYTE)v21 + 2) & 3));
  a3[5] = *(_DWORD *)(v28 + 4 * (((_BYTE)v22 + 1) & 3));
  a3[6] = *(_DWORD *)(v28 + 4 * (((_BYTE)v22 + 2) & 3));
  a3[7] = *(_DWORD *)(v28 + 4 * (((_BYTE)v22 - 1) & 3));
  a3[8] = *(_DWORD *)(v7 + 4 * v27 + 4 * (((_BYTE)v23 + 2) & 3));
  return 9;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Level::isSingleCreasePatch(OpenSubdiv::v3_1_1::Vtr::internal::Level *this, int a2, float *a3, int *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  int *v19;

  v4 = *((_QWORD *)this + 3);
  v5 = *(int *)(v4 + 8 * a2 + 4);
  v6 = *(unsigned int *)(v4 + 8 * a2);
  v7 = (int *)(*((_QWORD *)this + 6) + 4 * v5);
  v8 = *((_QWORD *)this + 54);
  if ((int)v6 < 2)
  {
    v11 = *(_WORD *)(v8 + 2 * *v7);
  }
  else
  {
    v9 = v6 - 1;
    v10 = v7 + 1;
    v11 = *(_WORD *)(v8 + 2 * *v7);
    do
    {
      v12 = *v10++;
      v11 |= *(_WORD *)(v8 + 2 * v12);
      --v9;
    }
    while (v9);
  }
  if ((v11 & 0x707) != 0x200)
    return 0;
  v13 = ((*(_WORD *)(v8 + 2 * *v7) & 0x780) == 512) | (2 * ((*(_WORD *)(v8 + 2 * v7[1]) & 0x780) == 512)) | (4 * ((*(_WORD *)(v8 + 2 * v7[2]) & 0x780) == 512)) | (8 * ((*(_WORD *)(v8 + 2 * v7[3]) & 0x780) == 512));
  if (((0xEDB7uLL >> v13) & 1) != 0)
    return 0;
  v14 = OpenSubdiv::v3_1_1::Vtr::internal::Level::isSingleCreasePatch(int,float *,int *)const::sharpEdgeFromCreaseMask[v13];
  v15 = *((_QWORD *)this + 45);
  v16 = *((_QWORD *)this + 42);
  v17 = (int *)(v15 + 4 * *(int *)(v16 + 8 * v7[v14] + 4));
  v18 = *((_QWORD *)this + 27);
  if (*(float *)(v18 + 4 * *v17) != *(float *)(v18 + 4 * v17[2]))
    return 0;
  if (*(float *)(v18 + 4 * v17[1]) != *(float *)(v18 + 4 * v17[3]))
    return 0;
  v19 = (int *)(v15 + 4 * *(int *)(v16 + 8 * v7[((_BYTE)v14 + 1) & 3] + 4));
  if (*(float *)(v18 + 4 * *v19) != *(float *)(v18 + 4 * v19[2])
    || *(float *)(v18 + 4 * v19[1]) != *(float *)(v18 + 4 * v19[3]))
  {
    return 0;
  }
  if (a3)
    *a3 = *(float *)(v18 + 4 * *(int *)(*((_QWORD *)this + 9) + 4 * v5 + 4 * v14));
  if (a4)
    *a4 = v14;
  return 1;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Level::findEdge(OpenSubdiv::v3_1_1::Vtr::internal::Level *this, int a2, int a3)
{
  uint64_t v3;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;

  v3 = *((_QWORD *)this + 42);
  v4 = (int *)(*((_QWORD *)this + 45) + 4 * *(int *)(v3 + 8 * a2 + 4));
  v5 = *(unsigned int *)(v3 + 8 * a2);
  if (a2 == a3)
  {
    if ((int)v5 >= 1)
    {
      v6 = *((_QWORD *)this + 15);
      while (1)
      {
        v8 = *v4++;
        result = v8;
        if (*(_DWORD *)(v6 + 8 * v8) == *(_DWORD *)(v6 + 8 * v8 + 4))
          break;
        if (!--v5)
          return 0xFFFFFFFFLL;
      }
      return result;
    }
    return 0xFFFFFFFFLL;
  }
  if ((int)v5 < 1)
    return 0xFFFFFFFFLL;
  v9 = *((_QWORD *)this + 15);
  while (1)
  {
    v10 = *v4++;
    result = v10;
    v11 = (_DWORD *)(v9 + 8 * v10);
    if (*v11 == a3 || v11[1] == a3)
      break;
    if (!--v5)
      return 0xFFFFFFFFLL;
  }
  return result;
}

BOOL OpenSubdiv::v3_1_1::Vtr::internal::Level::completeTopologyFromFaceVertices(OpenSubdiv::v3_1_1::Vtr::internal::Level *this)
{
  int v2;
  unint64_t v3;
  char *v4;
  unint64_t v5;
  uint64_t v6;
  std::vector<int>::size_type v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  _DWORD *v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  _DWORD *v21;
  int v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  _DWORD *v28;
  uint64_t v29;
  unsigned int *v30;
  uint64_t v31;
  void **v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t **v42;
  char *v43;
  char *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  _DWORD *v52;
  unint64_t v53;
  uint64_t **v54;
  int *v55;
  char *v56;
  int v57;
  char *v58;
  int *v59;
  int *v60;
  int *v61;
  int *v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  unint64_t v66;
  char *v67;
  int *v68;
  int v69;
  _DWORD *v70;
  int *v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  char *v76;
  int *v77;
  int v78;
  char *v79;
  _DWORD *v80;
  unint64_t v81;
  _DWORD *v82;
  _DWORD *v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  char *v88;
  char *v89;
  int v90;
  char *v91;
  int v92;
  int *v93;
  unint64_t v94;
  _DWORD *v95;
  int *v96;
  uint64_t v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  char *v101;
  int *v102;
  int v103;
  uint64_t v104;
  char *v105;
  char *v106;
  char *v107;
  char *v108;
  char *v109;
  uint64_t v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  char *v114;
  char *v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  char *v120;
  char *v121;
  char *v122;
  int v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  char *v128;
  char *v129;
  int v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  char *v134;
  int v135;
  int v136;
  int v137;
  int v138;
  int v139;
  int v140;
  _QWORD *v141;
  _QWORD *v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  _QWORD *v146;
  uint64_t *v147;
  char *v148;
  uint64_t v149;
  uint64_t v150;
  int *v151;
  uint64_t v152;
  uint64_t v153;
  __int32 v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  _BYTE *v161;
  uint64_t v162;
  uint64_t v163;
  unsigned int *v164;
  uint64_t v165;
  uint64_t v166;
  int *v167;
  _WORD *v168;
  int v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  __int32 *v174;
  uint64_t v175;
  __int32 *v176;
  int v177;
  int v178;
  uint64_t v179;
  std::vector<int>::pointer v180;
  uint64_t v181;
  uint64_t v182;
  unsigned int *v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  int *v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  int *v191;
  uint64_t v192;
  int v193;
  BOOL v194;
  __int16 v195;
  uint64_t i;
  int *v197;
  uint64_t v198;
  uint64_t v199;
  int *v200;
  _WORD *v201;
  int v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  __int32 *v206;
  uint64_t v207;
  __int32 *v208;
  int v209;
  int v210;
  std::vector<int> *v212;
  uint64_t *v213;
  std::vector<int> *v214;
  std::vector<int> *v215;
  std::vector<int> *v216;
  _QWORD *v217;
  uint64_t v218;
  int v219;
  int *v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t *v223;
  uint64_t v224;
  std::vector<int>::pointer begin;
  _QWORD *v226;
  uint64_t v227;
  std::vector<int>::pointer v228;
  uint64_t v229;
  char *__p;
  char *v231;
  char *v232;
  int v233;
  int v234;
  _QWORD *v235;
  _QWORD *v236;
  uint64_t *v237;
  _QWORD *v238[2];
  int v239;
  int v240;
  _QWORD *v241;
  char *v242;
  _QWORD **v243;
  _QWORD *v244[2];
  int v245;
  int v246;
  char *v247;
  std::vector<int> *v248;
  uint64_t *v249;
  _QWORD *v250[2];
  _BYTE *v251;
  int v252;
  int v253;
  _BYTE v254[128];
  void *v255;
  uint64_t v256;

  v256 = *MEMORY[0x24BDAC8D0];
  v2 = *((_DWORD *)this + 2);
  v3 = *(int *)this;
  v217 = (_QWORD *)((char *)this + 264);
  std::vector<unsigned int>::resize((std::vector<int> *)this + 11, 2 * v2);
  v213 = (uint64_t *)((char *)this + 336);
  std::vector<unsigned int>::resize((std::vector<int> *)this + 14, 2 * v2);
  std::vector<float>::resize((uint64_t)this + 408, v2);
  std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Level::VTag>::resize((uint64_t)this + 432, v2);
  bzero(*((void **)this + 54), 2 * *((int *)this + 2));
  *(_DWORD *)this = v3;
  std::vector<unsigned int>::resize((std::vector<int> *)this + 1, 2 * v3);
  v4 = (char *)*((_QWORD *)this + 12);
  v5 = *((_QWORD *)this + 13) - (_QWORD)v4;
  if (v3 <= v5)
  {
    if (v3 < v5)
      *((_QWORD *)this + 13) = &v4[v3];
  }
  else
  {
    std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Level::FTag>::__append((void **)this + 12, v3 - v5);
    v4 = (char *)*((_QWORD *)this + 12);
  }
  bzero(v4, *(int *)this);
  *((_DWORD *)this + 1) = 0;
  v215 = (std::vector<int> *)((char *)this + 144);
  std::vector<unsigned int>::resize((std::vector<int> *)this + 6, 0);
  std::vector<float>::resize((uint64_t)this + 216, 0);
  v6 = *((_QWORD *)this + 30);
  if (*((_QWORD *)this + 31) != v6)
    *((_QWORD *)this + 31) = v6;
  std::vector<unsigned int>::resize((std::vector<int> *)this + 3, (int)((uint64_t)(*((_QWORD *)this + 7) - *((_QWORD *)this + 6)) >> 2));
  v7 = 4 * v2;
  v223 = (uint64_t *)((char *)this + 120);
  std::vector<int>::reserve((std::vector<int> *)this + 5, v7);
  std::vector<int>::reserve((std::vector<int> *)this + 7, v7);
  std::vector<int>::reserve(v215, v7);
  v8 = 2;
  v247 = (char *)this + 144;
  v248 = (std::vector<int> *)((char *)this + 168);
  v214 = (std::vector<int> *)((char *)this + 168);
  v250[0] = 0;
  v250[1] = 0;
  v249 = (uint64_t *)v250;
  v9 = *((_QWORD *)this + 18);
  v10 = (unint64_t)(*((_QWORD *)this + 19) - v9) >> 2;
  if ((v10 & 0x80000000) == 0)
    v11 = (unint64_t)(*((_QWORD *)this + 19) - v9) >> 2;
  else
    v11 = v10 + 1;
  v12 = v11 >> 1;
  v246 = 2;
  v245 = v12;
  if ((int)v10 >= 2)
  {
    v13 = 0;
    v14 = (_DWORD *)(v9 + 4);
    do
    {
      *(v14 - 1) = 0;
      *v14 = v246 * v13;
      v14 += 2;
      ++v13;
      v12 = v245;
    }
    while (v13 < v245);
    v8 = v246;
  }
  std::vector<unsigned int>::resize(v214, v12 * v8);
  v15 = 6;
  v241 = v217;
  v242 = (char *)this + 288;
  v216 = (std::vector<int> *)((char *)this + 288);
  v244[0] = 0;
  v244[1] = 0;
  v243 = v244;
  v16 = *((_QWORD *)this + 33);
  v17 = (unint64_t)(*((_QWORD *)this + 34) - v16) >> 2;
  if ((v17 & 0x80000000) == 0)
    v18 = (unint64_t)(*((_QWORD *)this + 34) - v16) >> 2;
  else
    v18 = v17 + 1;
  v19 = v18 >> 1;
  v239 = v19;
  v240 = 6;
  if ((int)v17 < 2)
  {
    v22 = 6;
  }
  else
  {
    v20 = 0;
    v21 = (_DWORD *)(v16 + 4);
    do
    {
      *(v21 - 1) = 0;
      *v21 = v240 * v20;
      v21 += 2;
      ++v20;
      v19 = v239;
    }
    while (v20 < v239);
    v22 = v240;
  }
  std::vector<unsigned int>::resize(v216, v19 * v22);
  v235 = (_QWORD *)((char *)this + 336);
  v236 = (_QWORD *)((char *)this + 360);
  v212 = (std::vector<int> *)((char *)this + 360);
  v238[0] = 0;
  v238[1] = 0;
  v237 = (uint64_t *)v238;
  v23 = *((_QWORD *)this + 42);
  v24 = (unint64_t)(*((_QWORD *)this + 43) - v23) >> 2;
  if ((v24 & 0x80000000) == 0)
    v25 = (unint64_t)(*((_QWORD *)this + 43) - v23) >> 2;
  else
    v25 = v24 + 1;
  v26 = v25 >> 1;
  v233 = v26;
  v234 = 6;
  if ((int)v24 > 1)
  {
    v27 = 0;
    v28 = (_DWORD *)(v23 + 4);
    do
    {
      *(v28 - 1) = 0;
      *v28 = v234 * v27;
      v28 += 2;
      ++v27;
      v26 = v233;
    }
    while (v27 < v233);
    v15 = v234;
  }
  std::vector<unsigned int>::resize(v212, v26 * v15);
  __p = 0;
  v231 = 0;
  v232 = 0;
  if ((int)v3 >= 1)
  {
    v29 = 0;
    v220 = (int *)((char *)this + 136);
    v218 = v3;
    while (1)
    {
      v30 = (unsigned int *)(*((_QWORD *)this + 3) + 8 * v29);
      v31 = *v30;
      v32 = (void **)((char *)this + 120);
      if ((int)v31 >= 1)
        break;
LABEL_200:
      if (++v29 == v218)
        goto LABEL_201;
    }
    v33 = 0;
    v34 = (int)v30[1];
    v224 = *((_QWORD *)this + 9) + 4 * v34;
    v227 = *((_QWORD *)this + 6) + 4 * v34;
    v221 = v31;
    while (1)
    {
      v35 = *(_DWORD *)(v227 + 4 * v33);
      v36 = v33 + 1;
      if (v33 + 1 == v31)
        v37 = 0;
      else
        v37 = v33 + 1;
      v38 = *(_DWORD *)(v227 + 4 * v37);
      if (v35 == v38)
      {
        v39 = v231;
        if (v231 < v232)
        {
          *(_DWORD *)v231 = *((_DWORD *)this + 1);
          v40 = v231 + 4;
LABEL_65:
          v231 = v40;
LABEL_66:
          LODWORD(v50) = *((_DWORD *)this + 1);
          *((_DWORD *)this + 1) = v50 + 1;
          v60 = (int *)*((_QWORD *)this + 16);
          v59 = (int *)*((_QWORD *)this + 17);
          if (v60 >= v59)
          {
            v62 = (int *)*v32;
            v63 = ((char *)v60 - (_BYTE *)*v32) >> 2;
            v64 = v63 + 1;
            if ((unint64_t)(v63 + 1) >> 62)
              goto LABEL_269;
            v65 = (char *)v59 - (char *)v62;
            if (v65 >> 1 > v64)
              v64 = v65 >> 1;
            if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFFCLL)
              v66 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v66 = v64;
            if (v66)
            {
              v67 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)v220, v66);
              v62 = (int *)*((_QWORD *)this + 15);
              v60 = (int *)*((_QWORD *)this + 16);
            }
            else
            {
              v67 = 0;
            }
            v68 = (int *)&v67[4 * v63];
            *v68 = v35;
            v61 = v68 + 1;
            while (v60 != v62)
            {
              v69 = *--v60;
              *--v68 = v69;
            }
            v59 = (int *)&v67[4 * v66];
            *((_QWORD *)this + 15) = v68;
            *((_QWORD *)this + 16) = v61;
            *((_QWORD *)this + 17) = v59;
            if (v62)
            {
              operator delete(v62);
              v59 = *(int **)v220;
            }
          }
          else
          {
            *v60 = v35;
            v61 = v60 + 1;
          }
          *((_QWORD *)this + 16) = v61;
          if (v61 >= v59)
          {
            v71 = (int *)*v32;
            v72 = ((char *)v61 - (_BYTE *)*v32) >> 2;
            v73 = v72 + 1;
            if ((unint64_t)(v72 + 1) >> 62)
              goto LABEL_269;
            v74 = (char *)v59 - (char *)v71;
            if (v74 >> 1 > v73)
              v73 = v74 >> 1;
            if ((unint64_t)v74 >= 0x7FFFFFFFFFFFFFFCLL)
              v75 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v75 = v73;
            if (v75)
            {
              v76 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)v220, v75);
              v71 = (int *)*((_QWORD *)this + 15);
              v61 = (int *)*((_QWORD *)this + 16);
            }
            else
            {
              v76 = 0;
            }
            v77 = (int *)&v76[4 * v72];
            *v77 = v38;
            v70 = v77 + 1;
            while (v61 != v71)
            {
              v78 = *--v61;
              *--v77 = v78;
            }
            *((_QWORD *)this + 15) = v77;
            *((_QWORD *)this + 16) = v70;
            *((_QWORD *)this + 17) = &v76[4 * v75];
            if (v71)
              operator delete(v71);
          }
          else
          {
            *v61 = v38;
            v70 = v61 + 1;
          }
          *((_QWORD *)this + 16) = v70;
          v79 = v247;
          v80 = (_DWORD *)*((_QWORD *)v247 + 1);
          v81 = *((_QWORD *)v247 + 2);
          if ((unint64_t)v80 >= v81)
          {
            v83 = *(_DWORD **)v247;
            v84 = ((uint64_t)v80 - *(_QWORD *)v247) >> 2;
            v85 = v84 + 1;
            if ((unint64_t)(v84 + 1) >> 62)
              goto LABEL_269;
            v86 = v81 - (_QWORD)v83;
            if (v86 >> 1 > v85)
              v85 = v86 >> 1;
            if ((unint64_t)v86 >= 0x7FFFFFFFFFFFFFFCLL)
              v87 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v87 = v85;
            if (v87)
            {
              v88 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)(v247 + 16), v87);
              v83 = *(_DWORD **)v79;
              v80 = (_DWORD *)*((_QWORD *)v79 + 1);
            }
            else
            {
              v88 = 0;
            }
            v89 = &v88[4 * v84];
            *(_DWORD *)v89 = 0;
            v82 = v89 + 4;
            while (v80 != v83)
            {
              v90 = *--v80;
              *((_DWORD *)v89 - 1) = v90;
              v89 -= 4;
            }
            *(_QWORD *)v79 = v89;
            *((_QWORD *)v79 + 1) = v82;
            *((_QWORD *)v79 + 2) = &v88[4 * v87];
            if (v83)
              operator delete(v83);
          }
          else
          {
            *v80 = 0;
            v82 = v80 + 1;
          }
          *((_QWORD *)v79 + 1) = v82;
          v91 = v247;
          v92 = v246 * v245;
          v93 = (int *)*((_QWORD *)v247 + 1);
          v94 = *((_QWORD *)v247 + 2);
          if ((unint64_t)v93 >= v94)
          {
            v96 = *(int **)v247;
            v97 = ((uint64_t)v93 - *(_QWORD *)v247) >> 2;
            v98 = v97 + 1;
            if ((unint64_t)(v97 + 1) >> 62)
              goto LABEL_269;
            v99 = v94 - (_QWORD)v96;
            if (v99 >> 1 > v98)
              v98 = v99 >> 1;
            if ((unint64_t)v99 >= 0x7FFFFFFFFFFFFFFCLL)
              v100 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v100 = v98;
            if (v100)
            {
              v101 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)(v247 + 16), v100);
              v96 = *(int **)v91;
              v93 = (int *)*((_QWORD *)v91 + 1);
            }
            else
            {
              v101 = 0;
            }
            v102 = (int *)&v101[4 * v97];
            *v102 = v92;
            v95 = v102 + 1;
            if (v93 == v96)
            {
              v32 = (void **)((char *)this + 120);
            }
            else
            {
              v32 = (void **)((char *)this + 120);
              do
              {
                v103 = *--v93;
                *--v102 = v103;
              }
              while (v93 != v96);
            }
            *(_QWORD *)v91 = v102;
            *((_QWORD *)v91 + 1) = v95;
            *((_QWORD *)v91 + 2) = &v101[4 * v100];
            if (v96)
              operator delete(v96);
          }
          else
          {
            *v93 = v92;
            v95 = v93 + 1;
            v32 = (void **)((char *)this + 120);
          }
          *((_QWORD *)v91 + 1) = v95;
          v104 = ++v245;
          std::vector<unsigned int>::resize(v248, v246 * v104);
          v31 = v221;
          goto LABEL_133;
        }
        v44 = __p;
        v45 = (v231 - __p) >> 2;
        v46 = v45 + 1;
        if ((unint64_t)(v45 + 1) >> 62)
          goto LABEL_269;
        v47 = v232 - __p;
        if ((v232 - __p) >> 1 > v46)
          v46 = v47 >> 1;
        if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL)
          v48 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v48 = v46;
        if (v48)
        {
          v49 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)&v232, v48);
          v44 = __p;
          v39 = v231;
        }
        else
        {
          v49 = 0;
        }
        v56 = &v49[4 * v45];
        *(_DWORD *)v56 = *((_DWORD *)this + 1);
        v40 = v56 + 4;
        while (v39 != v44)
        {
          v57 = *((_DWORD *)v39 - 1);
          v39 -= 4;
          *((_DWORD *)v56 - 1) = v57;
          v56 -= 4;
        }
        v58 = &v49[4 * v48];
        __p = v56;
        goto LABEL_63;
      }
      LODWORD(v251) = *(_DWORD *)(v227 + 4 * v33);
      v41 = *(unsigned int *)(*v235 + 8 * v35);
      if ((int)v41 <= v234)
      {
        v43 = (char *)(*v236 + 4 * *(int *)(*v235 + 4 * ((2 * v35) | 1)));
      }
      else
      {
        v42 = std::__tree<std::__value_type<int,std::vector<int>>,std::__map_value_compare<int,std::__value_type<int,std::vector<int>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::vector<int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v237, v35, &v251);
        v43 = (char *)v42[5];
        v41 = ((unint64_t)((char *)v42[6] - v43) >> 2);
      }
      if ((int)v41 < 1)
        goto LABEL_66;
      while (1)
      {
        v51 = *(int *)v43;
        v43 += 4;
        v50 = v51;
        v52 = (char *)*v32 + 8 * v51;
        if (*v52 == v38 || v52[1] == v38)
          break;
        if (!--v41)
          goto LABEL_66;
      }
      if ((_DWORD)v50 == -1)
        goto LABEL_66;
      LODWORD(v251) = v50;
      LODWORD(v53) = *(_DWORD *)(*(_QWORD *)v247 + 8 * v50);
      if ((int)v53 <= v246)
      {
        v55 = &v248->__begin_[*(int *)(*(_QWORD *)v247 + 4 * (int)((2 * v50) | 1))];
      }
      else
      {
        v54 = std::__tree<std::__value_type<int,std::vector<int>>,std::__map_value_compare<int,std::__value_type<int,std::vector<int>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::vector<int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(&v249, v50, &v251);
        v55 = (int *)v54[5];
        v53 = (unint64_t)((char *)v54[6] - (char *)v55) >> 2;
      }
      if (v29 == v55[(int)v53 - 1])
      {
        v106 = v231;
        v105 = v232;
        if (v231 >= v232)
        {
          v115 = __p;
          v116 = (v231 - __p) >> 2;
          v117 = v116 + 1;
          if ((unint64_t)(v116 + 1) >> 62)
            goto LABEL_269;
          v118 = v232 - __p;
          if ((v232 - __p) >> 1 > v117)
            v117 = v118 >> 1;
          if ((unint64_t)v118 >= 0x7FFFFFFFFFFFFFFCLL)
            v119 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v119 = v117;
          if (v119)
          {
            v120 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)&v232, v119);
            v115 = __p;
            v106 = v231;
          }
          else
          {
            v120 = 0;
          }
          v122 = &v120[4 * v116];
          *(_DWORD *)v122 = v50;
          v107 = v122 + 4;
          while (v106 != v115)
          {
            v123 = *((_DWORD *)v106 - 1);
            v106 -= 4;
            *((_DWORD *)v122 - 1) = v123;
            v122 -= 4;
          }
          v105 = &v120[4 * v119];
          __p = v122;
          v232 = v105;
          if (v115)
          {
            operator delete(v115);
            v105 = v232;
          }
        }
        else
        {
          *(_DWORD *)v231 = v50;
          v107 = v231 + 4;
        }
        if (v107 < v105)
        {
          *(_DWORD *)v107 = *((_DWORD *)this + 1);
          v40 = v107 + 4;
          goto LABEL_65;
        }
        v44 = __p;
        v124 = (v107 - __p) >> 2;
        v125 = v124 + 1;
        if ((unint64_t)(v124 + 1) >> 62)
          goto LABEL_269;
        v126 = v105 - __p;
        if (v126 >> 1 > v125)
          v125 = v126 >> 1;
        if ((unint64_t)v126 >= 0x7FFFFFFFFFFFFFFCLL)
          v127 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v127 = v125;
        if (v127)
        {
          v128 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)&v232, v127);
          v44 = __p;
        }
        else
        {
          v128 = 0;
        }
        v129 = &v128[4 * v124];
        *(_DWORD *)v129 = *((_DWORD *)this + 1);
        v40 = v129 + 4;
        while (v107 != v44)
        {
          v130 = *((_DWORD *)v107 - 1);
          v107 -= 4;
          *((_DWORD *)v129 - 1) = v130;
          v129 -= 4;
        }
        v58 = &v128[4 * v127];
        __p = v129;
LABEL_63:
        v232 = v58;
        if (v44)
          operator delete(v44);
        goto LABEL_65;
      }
      if ((int)v53 >= 2)
        break;
      if (v35 == *((_DWORD *)*v32 + 2 * v50))
      {
        v108 = v231;
        if (v231 < v232)
        {
LABEL_159:
          *(_DWORD *)v108 = v50;
          v121 = v108 + 4;
LABEL_199:
          v231 = v121;
          goto LABEL_133;
        }
        v109 = __p;
        v131 = (v231 - __p) >> 2;
        v132 = v131 + 1;
        if ((unint64_t)(v131 + 1) >> 62)
LABEL_269:
          abort();
        v133 = v232 - __p;
        if ((v232 - __p) >> 1 > v132)
          v132 = v133 >> 1;
        if ((unint64_t)v133 >= 0x7FFFFFFFFFFFFFFCLL)
          v113 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v113 = v132;
        if (v113)
        {
          v114 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)&v232, v113);
          v109 = __p;
          v108 = v231;
        }
        else
        {
          v114 = 0;
        }
        v134 = &v114[4 * v131];
        *(_DWORD *)v134 = v50;
        v121 = v134 + 4;
        while (v108 != v109)
        {
          v136 = *((_DWORD *)v108 - 1);
          v108 -= 4;
          *((_DWORD *)v134 - 1) = v136;
          v134 -= 4;
        }
LABEL_197:
        __p = v134;
        v232 = &v114[4 * v113];
        if (v109)
          operator delete(v109);
        goto LABEL_199;
      }
LABEL_133:
      *(_DWORD *)(v224 + 4 * v33++) = v50;
      if (v36 == v31)
        goto LABEL_200;
    }
    v108 = v231;
    if (v231 < v232)
      goto LABEL_159;
    v109 = __p;
    v110 = (v231 - __p) >> 2;
    v111 = v110 + 1;
    if ((unint64_t)(v110 + 1) >> 62)
      goto LABEL_269;
    v112 = v232 - __p;
    if ((v232 - __p) >> 1 > v111)
      v111 = v112 >> 1;
    if ((unint64_t)v112 >= 0x7FFFFFFFFFFFFFFCLL)
      v113 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v113 = v111;
    if (v113)
    {
      v114 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>((uint64_t)&v232, v113);
      v109 = __p;
      v108 = v231;
    }
    else
    {
      v114 = 0;
    }
    v134 = &v114[4 * v110];
    *(_DWORD *)v134 = v50;
    v121 = v134 + 4;
    while (v108 != v109)
    {
      v135 = *((_DWORD *)v108 - 1);
      v108 -= 4;
      *((_DWORD *)v134 - 1) = v135;
      v134 -= 4;
    }
    goto LABEL_197;
  }
LABEL_201:
  v140 = *((_DWORD *)this + 5);
  if (v138 > v140)
    v140 = v138;
  if (v139 > v140)
    v140 = v139;
  *((_DWORD *)this + 4) = v137;
  *((_DWORD *)this + 5) = v140;
  v219 = v140;
  v142 = (_QWORD *)((char *)this + 72);
  v141 = (_QWORD *)((char *)this + 24);
  if (v140 < 0x10000)
  {
    v143 = *((int *)this + 1);
    std::vector<unsigned int>::resize(v215, 2 * v143);
    std::vector<float>::resize((uint64_t)this + 216, v143);
    v144 = *((_QWORD *)this + 30);
    v145 = *((_QWORD *)this + 31) - v144;
    if (v143 <= v145)
    {
      v146 = (_QWORD *)((char *)this + 240);
      v147 = (uint64_t *)((char *)this + 432);
      if (v143 < v145)
        *((_QWORD *)this + 31) = v144 + v143;
    }
    else
    {
      v146 = (_QWORD *)((char *)this + 240);
      std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Level::FTag>::__append((void **)this + 30, v143 - v145);
      v147 = (uint64_t *)((char *)this + 432);
    }
    if ((int)v143 >= 1)
      bzero(*((void **)this + 30), *((int *)this + 1));
    v148 = __p;
    if ((int)((unint64_t)(v231 - __p) >> 2) >= 1)
    {
      v149 = 0;
      do
      {
        v150 = *(int *)&v148[4 * v149];
        *(_BYTE *)(*v146 + v150) |= 1u;
        v151 = (int *)(*v223 + 8 * v150);
        *(_WORD *)(*v147 + 2 * *v151) |= 1u;
        *(_WORD *)(*v147 + 2 * v151[1]) |= 1u;
        ++v149;
        v148 = __p;
      }
      while (v149 < (int)((unint64_t)(v231 - __p) >> 2));
    }
    v152 = *((unsigned int *)this + 2);
    if ((int)v152 >= 1)
    {
      v153 = 0;
      v154 = 0;
      v155 = 2 * v152;
      v222 = 2 * v152;
      do
      {
        v156 = *v147;
        if ((*(_WORD *)(*v147 + v153) & 1) == 0)
        {
          v157 = *(int *)(*v217 + 4 * ((int)v153 + 1));
          v158 = *(int *)(*v217 + 4 * (int)v153);
          begin = v212->__begin_;
          v228 = v216->__begin_;
          v159 = *(int *)(*v213 + 4 * ((int)v153 + 1));
          v160 = *(int *)(*v213 + 4 * (int)v153);
          v161 = v254;
          v251 = v254;
          v252 = v160 + v158;
          v253 = 32;
          v255 = 0;
          if ((v160 + v158) >= 0x21)
          {
            v161 = operator new(4 * (v160 + v158));
            v255 = v161;
            v251 = v161;
            v253 = v160 + v158;
          }
          if (OpenSubdiv::v3_1_1::Vtr::internal::Level::orderVertexFacesAndEdges(this, v154, (int *)v161, (int *)&v161[4 * v158]))
          {
            memcpy(&v228[v157], v161, 4 * v158);
            memcpy(&begin[v159], &v161[4 * v158], 4 * v160);
            operator delete(v255);
          }
          else
          {
            operator delete(v255);
            *(_WORD *)(v156 + v153) |= 1u;
          }
          v142 = (_QWORD *)((char *)this + 72);
          v141 = (_QWORD *)((char *)this + 24);
          v147 = (uint64_t *)((char *)this + 432);
          v155 = v222;
        }
        ++v154;
        v153 += 2;
      }
      while (v155 != v153);
      LODWORD(v152) = *((_DWORD *)this + 2);
    }
    v229 = *((unsigned int *)this + 1);
    std::vector<unsigned short>::resize((uint64_t)this + 312, (uint64_t)(*((_QWORD *)this + 37) - *((_QWORD *)this + 36)) >> 2);
    std::vector<unsigned short>::resize((uint64_t)this + 384, (uint64_t)(*((_QWORD *)this + 46) - *((_QWORD *)this + 45)) >> 2);
    v226 = (_QWORD *)((char *)this + 192);
    std::vector<unsigned short>::resize((uint64_t)this + 192, (uint64_t)(*((_QWORD *)this + 22) - *((_QWORD *)this + 21)) >> 2);
    if ((int)v152 >= 1)
    {
      v162 = 0;
      v163 = v152;
      do
      {
        v164 = (unsigned int *)(*v217 + 8 * v162);
        v165 = *v164;
        if ((int)v165 >= 1)
        {
          v166 = (int)v164[1];
          v167 = &v216->__begin_[v166];
          v168 = (_WORD *)(*((_QWORD *)this + 39) + 2 * v166);
          v169 = -1;
          do
          {
            v170 = *v167;
            if ((_DWORD)v170 == v169)
              v171 = (unsigned __int16)*(v168 - 1) + 1;
            else
              v171 = 0;
            v172 = *((_QWORD *)this + 3);
            v173 = *((_QWORD *)this + 6) + 4 * *(int *)(v172 + 4 * (int)((2 * v170) | 1));
            v174 = (__int32 *)(v173 + 4 * v171);
            v175 = v173 + 4 * *(int *)(v172 + 8 * v170);
            v176 = wmemchr(v174, v162, (v175 - (uint64_t)v174) >> 2);
            if (v176)
              v177 = (int)v176;
            else
              v177 = v175;
            *v168++ = (v174 + ((v177 - (_DWORD)v174) & 0x3FFFC) - v173) >> 2;
            v178 = *v167++;
            v169 = v178;
            --v165;
          }
          while (v165);
        }
        ++v162;
      }
      while (v162 != v163);
      v179 = 0;
      v180 = v212->__begin_;
      v181 = *v213;
      v182 = *((_QWORD *)this + 48);
      v142 = (_QWORD *)((char *)this + 72);
      v141 = (_QWORD *)((char *)this + 24);
      while (1)
      {
        v183 = (unsigned int *)(v181 + 8 * v179);
        v184 = *v183;
        if ((int)v184 >= 1)
          break;
LABEL_251:
        if (*((_DWORD *)this + 5) > (int)v184)
          LODWORD(v184) = *((_DWORD *)this + 5);
        *((_DWORD *)this + 5) = v184;
        if (++v179 == v163)
          goto LABEL_254;
      }
      v185 = 0;
      v186 = (int)v183[1];
      v187 = &v180[v186];
      v188 = v182 + 2 * v186;
      v189 = *v223;
      while (1)
      {
        v190 = v187[v185];
        v191 = (int *)(v189 + 8 * v190);
        v193 = *v191;
        v192 = v191[1];
        if (v193 != (_DWORD)v192)
          break;
        if (v185)
        {
          v194 = (_DWORD)v190 == v187[v185 - 1];
          goto LABEL_245;
        }
        v195 = 0;
LABEL_248:
        *(_WORD *)(v188 + 2 * v185++) = v195;
        if (v184 == v185)
          goto LABEL_251;
      }
      v194 = v179 == v192;
LABEL_245:
      v195 = v194;
      goto LABEL_248;
    }
LABEL_254:
    if ((int)v229 >= 1)
    {
      for (i = 0; i != v229; ++i)
      {
        v197 = &v215->__begin_[2 * i];
        v198 = *v197;
        if ((int)v198 >= 1)
        {
          v199 = v197[1];
          v200 = &v214->__begin_[v199];
          v201 = (_WORD *)(*v226 + 2 * v199);
          v202 = -1;
          do
          {
            v203 = *v200;
            if ((_DWORD)v203 == v202)
              v204 = (unsigned __int16)*(v201 - 1) + 1;
            else
              v204 = 0;
            v205 = *v142 + 4 * *(int *)(*v141 + 4 * (int)((2 * v203) | 1));
            v206 = (__int32 *)(v205 + 4 * v204);
            v207 = v205 + 4 * *(int *)(*v141 + 8 * v203);
            v208 = wmemchr(v206, i, (v207 - (uint64_t)v206) >> 2);
            if (v208)
              v209 = (int)v208;
            else
              v209 = v207;
            *v201++ = (v206 + ((v209 - (_DWORD)v206) & 0x3FFFC) - v205) >> 2;
            v210 = *v200++;
            v202 = v210;
            --v198;
          }
          while (v198);
        }
      }
    }
  }
  if (__p)
    operator delete(__p);
  std::__tree<std::__value_type<int,std::vector<int>>,std::__map_value_compare<int,std::__value_type<int,std::vector<int>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::vector<int>>>>::destroy(v238[0]);
  std::__tree<std::__value_type<int,std::vector<int>>,std::__map_value_compare<int,std::__value_type<int,std::vector<int>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::vector<int>>>>::destroy(v244[0]);
  std::__tree<std::__value_type<int,std::vector<int>>,std::__map_value_compare<int,std::__value_type<int,std::vector<int>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::vector<int>>>>::destroy(v250[0]);
  return v219 < 0x10000;
}

void OpenSubdiv::v3_1_1::Vtr::internal::`anonymous namespace'::DynamicRelation::appendCompMember(OpenSubdiv::v3_1_1::Vtr::internal::_anonymous_namespace_::DynamicRelation *this, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t **v9;
  void **v10;
  uint64_t v11;
  uint64_t **v12;
  uint64_t v13;
  uint64_t *v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  char *v23;
  uint64_t *v24;
  int v25;
  int v26;

  v26 = a2;
  v5 = 2 * a2;
  v6 = **((_QWORD **)this + 1);
  v7 = *(_DWORD *)(v6 + 4 * v5);
  v8 = *(int *)(v6 + 8 * a2 + 4);
  if (v7 >= *((_DWORD *)this + 1))
  {
    v9 = std::__tree<std::__value_type<int,std::vector<int>>,std::__map_value_compare<int,std::__value_type<int,std::vector<int>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::vector<int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t **)this + 3, a2, &v26);
    v10 = (void **)(v9 + 5);
    v11 = *((int *)this + 1);
    if (v7 <= (int)v11)
    {
      std::vector<unsigned int>::resize((std::vector<int> *)(v9 + 5), v11 + 1);
      memcpy(*v10, (const void *)(**((_QWORD **)this + 2) + 4 * v8), 4 * *((int *)this + 1));
      *((_DWORD *)*v10 + *((int *)this + 1)) = a3;
    }
    else
    {
      v12 = v9;
      v13 = (uint64_t)(v9 + 7);
      v14 = v9[7];
      v15 = (char *)v9[6];
      if (v15 >= (char *)v14)
      {
        v17 = (char *)*v10;
        v18 = (v15 - (_BYTE *)*v10) >> 2;
        v19 = v18 + 1;
        if ((unint64_t)(v18 + 1) >> 62)
          abort();
        v20 = (char *)v14 - v17;
        if (v20 >> 1 > v19)
          v19 = v20 >> 1;
        if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFFCLL)
          v21 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v21 = v19;
        if (v21)
        {
          v22 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(v13, v21);
          v17 = (char *)v12[5];
          v15 = (char *)v12[6];
        }
        else
        {
          v22 = 0;
        }
        v23 = &v22[4 * v18];
        v24 = (uint64_t *)&v22[4 * v21];
        *(_DWORD *)v23 = a3;
        v16 = (uint64_t *)(v23 + 4);
        while (v15 != v17)
        {
          v25 = *((_DWORD *)v15 - 1);
          v15 -= 4;
          *((_DWORD *)v23 - 1) = v25;
          v23 -= 4;
        }
        v12[5] = (uint64_t *)v23;
        v12[6] = v16;
        v12[7] = v24;
        if (v17)
          operator delete(v17);
      }
      else
      {
        *(_DWORD *)v15 = a3;
        v16 = (uint64_t *)(v15 + 4);
      }
      v12[6] = v16;
      v5 = 2 * v26;
    }
  }
  else
  {
    *(_DWORD *)(**((_QWORD **)this + 2) + 4 * ((int)v8 + v7)) = a3;
  }
  ++*(_DWORD *)(**((_QWORD **)this + 1) + 4 * v5);
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::`anonymous namespace'::DynamicRelation::compressMemberIndices(OpenSubdiv::v3_1_1::Vtr::internal::_anonymous_namespace_::DynamicRelation *this)
{
  int *v2;
  int v3;
  uint64_t v4;
  char v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  std::vector<int> *v13;
  uint64_t v14;
  int v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  std::vector<int>::pointer begin;
  int v20;
  uint64_t *v21;
  uint64_t v22;
  int *v23;
  int *v24;
  char v26;
  int v27;
  std::vector<int> v28;

  v2 = (int *)**((_QWORD **)this + 1);
  v3 = *v2;
  LODWORD(v4) = *(_DWORD *)this;
  if (*((_QWORD *)this + 5))
  {
    if ((int)v4 < 2)
    {
      v5 = 0;
      v8 = *((unsigned int *)this + 1);
    }
    else
    {
      v5 = 0;
      v6 = v2 + 3;
      v7 = 1;
      do
      {
        *v6 = v3;
        v8 = *((unsigned int *)this + 1);
        v4 = *(int *)this;
        v5 |= v3 > (int)v8 * (int)v7;
        v3 += *(v6 - 1);
        ++v7;
        v6 += 2;
      }
      while (v7 < v4);
    }
    v12 = v5 | (v3 > (int)v4 * (int)v8);
    memset(&v28, 0, sizeof(v28));
    if (v5 & 1 | (v3 > (int)v4 * (int)v8))
    {
      v13 = &v28;
      std::vector<unsigned int>::resize(&v28, v3);
      LODWORD(v4) = *(_DWORD *)this;
      v8 = *((unsigned int *)this + 1);
    }
    else
    {
      v13 = (std::vector<int> *)*((_QWORD *)this + 2);
    }
    v26 = v12;
    v27 = 0;
    if ((int)v4 >= 1)
    {
      v14 = 0;
      v15 = 0;
      do
      {
        v16 = (int *)(**((_QWORD **)this + 1) + v14);
        v17 = *v16;
        v18 = v16[1];
        begin = v13->__begin_;
        v20 = *((_DWORD *)this + 1);
        if ((int)v17 <= v20)
        {
          v21 = (uint64_t *)(**((_QWORD **)this + 2) + 4 * v20 * v15);
        }
        else
        {
          v21 = std::__tree<std::__value_type<int,std::vector<int>>,std::__map_value_compare<int,std::__value_type<int,std::vector<int>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::vector<int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t **)this + 3, v15, &v27)[5];
          if ((int)v8 <= (int)v17)
            v8 = v17;
          else
            v8 = v8;
        }
        memmove(&begin[v18], v21, 4 * v17);
        v27 = ++v15;
        v14 += 8;
      }
      while (v15 < *(_DWORD *)this);
    }
    v22 = *((_QWORD *)this + 2);
    if ((v26 & 1) != 0)
    {
      v23 = *(int **)v22;
      *(_QWORD *)v22 = v28.__begin_;
      *(_QWORD *)(v22 + 8) = v28.__end_;
      v24 = *(int **)(v22 + 16);
      *(_QWORD *)(v22 + 16) = v28.__end_cap_.__value_;
      v28.__begin_ = v23;
      v28.__end_cap_.__value_ = v24;
      if (!v23)
        return v8;
      goto LABEL_29;
    }
    std::vector<unsigned int>::resize(*((std::vector<int> **)this + 2), v3);
    v23 = v28.__begin_;
    if (v28.__begin_)
    {
LABEL_29:
      v28.__end_ = v23;
      operator delete(v23);
    }
  }
  else
  {
    if ((int)v4 < 2)
    {
      v8 = *v2;
    }
    else
    {
      v9 = 0;
      v10 = 1;
      LODWORD(v8) = *v2;
      do
      {
        v11 = v2[v9 + 2];
        memmove((void *)(**((_QWORD **)this + 2) + 4 * v3), (const void *)(**((_QWORD **)this + 2) + 4 * v2[v9 + 3]), 4 * v11);
        v2 = (int *)**((_QWORD **)this + 1);
        v2[v9 + 3] = v3;
        v3 += v11;
        if ((int)v8 <= (int)v11)
          v8 = v11;
        else
          v8 = v8;
        ++v10;
        v9 += 2;
      }
      while (v10 < *(int *)this);
    }
    std::vector<unsigned int>::resize(*((std::vector<int> **)this + 2), v3);
  }
  return v8;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Level::createFVarChannel(_QWORD *a1, int a2, _WORD *a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;

  v6 = operator new();
  *(_QWORD *)v6 = a1;
  *(_WORD *)(v6 + 12) = 0;
  *(_BYTE *)(v6 + 14) = 0;
  *(_OWORD *)(v6 + 24) = 0u;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *(_OWORD *)(v6 + 72) = 0u;
  *(_OWORD *)(v6 + 88) = 0u;
  *(_OWORD *)(v6 + 104) = 0u;
  *(_OWORD *)(v6 + 120) = 0u;
  *(_OWORD *)(v6 + 136) = 0u;
  *(_OWORD *)(v6 + 152) = 0u;
  *(_OWORD *)(v6 + 168) = 0u;
  *(_OWORD *)(v6 + 184) = 0u;
  *(_OWORD *)(v6 + 200) = 0u;
  *(_WORD *)(v6 + 8) = *a3;
  *(_DWORD *)(v6 + 16) = a2;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::resizeComponents((std::vector<int> *)v6);
  v8 = (uint64_t *)a1[58];
  v7 = a1[59];
  if ((unint64_t)v8 >= v7)
  {
    v10 = a1[57];
    v11 = ((uint64_t)v8 - v10) >> 3;
    if ((unint64_t)(v11 + 1) >> 61)
      abort();
    v12 = v7 - v10;
    v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1))
      v13 = v11 + 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v14 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v14 = v13;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)(a1 + 59), v14);
    else
      v15 = 0;
    v16 = (uint64_t *)&v15[8 * v11];
    v17 = &v15[8 * v14];
    *v16 = v6;
    v9 = v16 + 1;
    v19 = (char *)a1[57];
    v18 = (char *)a1[58];
    if (v18 != v19)
    {
      do
      {
        v20 = *((_QWORD *)v18 - 1);
        v18 -= 8;
        *--v16 = v20;
      }
      while (v18 != v19);
      v18 = (char *)a1[57];
    }
    a1[57] = v16;
    a1[58] = v9;
    a1[59] = v17;
    if (v18)
      operator delete(v18);
  }
  else
  {
    *v8 = v6;
    v9 = v8 + 1;
  }
  a1[58] = v9;
  return (((unint64_t)v9 - a1[57]) >> 3) - 1;
}

void std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Level::VTag>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 1;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 2 * a2;
  }
  else
  {
    std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Level::VTag>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Level::VTag>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  __int16 v17;

  v4 = (uint64_t)(a1 + 2);
  v5 = a1[2];
  v6 = a1[1];
  if (a2 <= (v5 - v6) >> 1)
  {
    a1[1] = &v6[2 * a2];
  }
  else
  {
    v7 = *a1;
    v8 = v6 - *a1;
    v9 = a2 + (v8 >> 1);
    if (v9 < 0)
      abort();
    v10 = v8 >> 1;
    v11 = v5 - v7;
    if (v11 > v9)
      v9 = v11;
    if (v11 >= 0x7FFFFFFFFFFFFFFELL)
      v12 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned short>>(v4, v12);
      v7 = *a1;
      v6 = a1[1];
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[2 * v10];
    v15 = &v13[2 * v12];
    v16 = &v14[2 * a2];
    if (v6 != v7)
    {
      do
      {
        v17 = *((_WORD *)v6 - 1);
        v6 -= 2;
        *((_WORD *)v14 - 1) = v17;
        v14 -= 2;
      }
      while (v6 != v7);
      v7 = *a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v7)
      operator delete(v7);
  }
}

void std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Level::FTag>::__append(void **a1, unint64_t a2)
{
  _BYTE *v4;
  char *v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char v15;

  v5 = (char *)a1[1];
  v4 = a1[2];
  if (v4 - v5 >= a2)
  {
    a1[1] = &v5[a2];
  }
  else
  {
    v6 = (unint64_t)*a1;
    v7 = (char *)(v5 - (_BYTE *)*a1);
    v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0)
      abort();
    v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if (v10)
      v11 = (char *)operator new(v10);
    else
      v11 = 0;
    v12 = &v11[v10];
    v13 = &v7[(_QWORD)v11 + a2];
    if (v5 == (char *)v6)
    {
      v11 = &v7[(_QWORD)v11];
    }
    else
    {
      v14 = &v5[~v6];
      do
      {
        v15 = *--v5;
        (v14--)[(_QWORD)v11] = v15;
      }
      while (v5 != (char *)v6);
      v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = v13;
    a1[2] = v12;
    if (v5)
      operator delete(v5);
  }
}

uint64_t **std::__tree<std::__value_type<int,std::vector<int>>,std::__map_value_compare<int,std::__value_type<int,std::vector<int>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::vector<int>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  int v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = *((_DWORD *)v5 + 8);
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= a2)
        break;
      v5 = v7[1];
      if (!v5)
      {
        v6 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = (uint64_t *)v7;
    v7 = (uint64_t **)operator new(0x40uLL);
    *((_DWORD *)v7 + 8) = *a3;
    v7[6] = 0;
    v7[7] = 0;
    v7[5] = 0;
    *v7 = 0;
    v7[1] = 0;
    v7[2] = v9;
    *v6 = (uint64_t *)v7;
    v10 = (uint64_t *)**a1;
    v11 = (uint64_t *)v7;
    if (v10)
    {
      *a1 = v10;
      v11 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v11);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v7;
}

void std::__tree<std::__value_type<int,std::vector<int>>,std::__map_value_compare<int,std::__value_type<int,std::vector<int>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::vector<int>>>>::destroy(_QWORD *a1)
{
  void *v2;

  if (a1)
  {
    std::__tree<std::__value_type<int,std::vector<int>>,std::__map_value_compare<int,std::__value_type<int,std::vector<int>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::vector<int>>>>::destroy(*a1);
    std::__tree<std::__value_type<int,std::vector<int>>,std::__map_value_compare<int,std::__value_type<int,std::vector<int>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::vector<int>>>>::destroy(a1[1]);
    v2 = (void *)a1[5];
    if (v2)
    {
      a1[6] = v2;
      operator delete(v2);
    }
    operator delete(a1);
  }
}

uint64_t OpenSubdiv::v3_1_1::Far::StencilTableFactory::Create(int *a1, uint64_t a2)
{
  int *v3;
  uint64_t v4;
  int *v5;
  int v6;
  int v7;
  uint64_t v8;
  OpenSubdiv::v3_1_1::Far::internal::WeightTable *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  int v23;
  unsigned int *v24;
  uint64_t v25;
  uint64_t v26;
  float *v27;
  uint64_t v28;
  unint64_t v29;
  int v30;
  uint64_t v31;
  float v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t k;
  uint64_t v38;
  _DWORD *v39;
  uint64_t v40;
  unsigned int *v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  int v48;
  uint64_t v49;
  float v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  int v59;
  _QWORD *v60;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v61;
  uint64_t v62;
  unsigned int v63;
  int v64;
  uint64_t m;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  float *v73;
  float *v74;
  uint64_t v75;
  int *v76;
  uint64_t v77;
  BOOL v78;
  int *v79;
  _DWORD *v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  int v85;
  unsigned int *v86;
  uint64_t v87;
  _DWORD *v88;
  float v89;
  int v90;
  int v91;
  uint64_t v92;
  uint64_t jj;
  int v94;
  _DWORD *v95;
  int v96;
  int v97;
  uint64_t kk;
  int v99;
  int v100;
  float *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  void *v105;
  uint64_t v106;
  uint64_t v107;
  _QWORD *v108;
  uint64_t v109;
  int v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  unsigned int *v114;
  uint64_t v115;
  int v116;
  uint64_t v117;
  float *v118;
  uint64_t v119;
  unint64_t v120;
  int v121;
  uint64_t v122;
  float v123;
  void *v124;
  uint64_t v125;
  uint64_t v126;
  _QWORD *v127;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v128;
  uint64_t v129;
  float *v130;
  BOOL v131;
  char v132;
  uint64_t v133;
  uint64_t v134;
  int *v135;
  int v136;
  int v137;
  unsigned int *v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  int v142;
  int v143;
  uint64_t v144;
  float v145;
  int v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  int v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  int v157;
  int v158;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v159;
  uint64_t v160;
  float v161;
  BOOL v162;
  int v163;
  unsigned int v164;
  void *v165;
  uint64_t v166;
  uint64_t v167;
  int *v168;
  uint64_t v169;
  int *v170;
  uint64_t v171;
  uint64_t v172;
  int v173;
  int v174;
  int v175;
  OpenSubdiv::v3_1_1::Far::internal::WeightTable *v176;
  float v177;
  uint64_t v178;
  uint64_t v179;
  float *v180;
  float *v181;
  int v182;
  int v183;
  uint64_t v184;
  uint64_t v185;
  int *v186;
  uint64_t v187;
  unint64_t v188;
  uint64_t v189;
  float v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  int v195;
  int v196;
  int v197;
  OpenSubdiv::v3_1_1::Far::internal::WeightTable *v198;
  float v199;
  int v200;
  float v201;
  float v202;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v203;
  int v204;
  unsigned int v205;
  float FractionalWeight;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  void *v212;
  uint64_t v213;
  int v214;
  uint64_t v215;
  int v216;
  unsigned int *v217;
  uint64_t v218;
  uint64_t v219;
  float *v220;
  uint64_t v221;
  unint64_t v222;
  int v223;
  uint64_t v224;
  float v225;
  void *v226;
  uint64_t v227;
  int v228;
  uint64_t v229;
  uint64_t i;
  int v231;
  _DWORD *v232;
  int v233;
  uint64_t v234;
  uint64_t v235;
  unsigned int v236;
  int v237;
  uint64_t j;
  int v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  void *v243;
  uint64_t v244;
  int v245;
  uint64_t v246;
  int v247;
  unsigned int *v248;
  uint64_t v249;
  uint64_t v250;
  float *v251;
  uint64_t v252;
  unint64_t v253;
  int v254;
  uint64_t v255;
  float v256;
  void *v257;
  uint64_t v258;
  uint64_t v259;
  int v260;
  uint64_t n;
  uint64_t v262;
  _DWORD *v263;
  uint64_t v264;
  unsigned int *v265;
  uint64_t v266;
  uint64_t v267;
  int v268;
  uint64_t v269;
  uint64_t v270;
  int v271;
  int v272;
  uint64_t v273;
  float v274;
  int v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  int v279;
  uint64_t v280;
  uint64_t v281;
  int v282;
  _QWORD *v283;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v284;
  uint64_t v285;
  unsigned int v286;
  int v287;
  uint64_t ii;
  unsigned int v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  float *v296;
  float *v297;
  uint64_t v298;
  int *v299;
  uint64_t v300;
  BOOL v301;
  int *v302;
  _DWORD *v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v307;
  void *v308;
  uint64_t v309;
  _QWORD *v310;
  uint64_t v311;
  int v312;
  uint64_t v313;
  uint64_t v314;
  unsigned int *v315;
  uint64_t v316;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v317;
  int v318;
  uint64_t v319;
  float *v320;
  uint64_t v321;
  unint64_t v322;
  int v323;
  uint64_t v324;
  float v325;
  void *v326;
  uint64_t v327;
  uint64_t v328;
  _QWORD *v329;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  int *v334;
  int v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  int v339;
  _QWORD *v340;
  uint64_t v341;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v342;
  BOOL v343;
  int v344;
  unsigned int v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  int *v349;
  uint64_t v350;
  int *v351;
  uint64_t v352;
  uint64_t v353;
  int v354;
  int v355;
  int v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  int v360;
  int v361;
  int v362;
  OpenSubdiv::v3_1_1::Far::internal::WeightTable *v363;
  float v364;
  int v365;
  float v366;
  float v367;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v368;
  int v369;
  unsigned int v370;
  float v371;
  uint64_t v372;
  uint64_t v373;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v374;
  void *v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  _QWORD *v379;
  uint64_t v380;
  int v381;
  uint64_t v382;
  uint64_t v383;
  unsigned int *v384;
  uint64_t v385;
  int v386;
  uint64_t v387;
  float *v388;
  uint64_t v389;
  unint64_t v390;
  int v391;
  uint64_t v392;
  float v393;
  void *v394;
  uint64_t v395;
  uint64_t v396;
  _QWORD *v397;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v398;
  uint64_t v399;
  float *v400;
  BOOL v401;
  char v402;
  uint64_t v403;
  uint64_t v404;
  int *v405;
  int v406;
  int v407;
  unsigned int *v408;
  uint64_t v409;
  uint64_t v410;
  uint64_t v411;
  int v412;
  int v413;
  uint64_t v414;
  float v415;
  int v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  int v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  uint64_t v426;
  int v427;
  int v428;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v429;
  uint64_t v430;
  int v431;
  BOOL v432;
  int v433;
  unsigned int v434;
  uint64_t v435;
  uint64_t v436;
  int *v437;
  uint64_t v438;
  int *v439;
  uint64_t v440;
  uint64_t v441;
  int v442;
  int v443;
  int v444;
  OpenSubdiv::v3_1_1::Far::internal::WeightTable *v445;
  float v446;
  uint64_t v447;
  uint64_t v448;
  float *v449;
  float *v450;
  int v451;
  int v452;
  uint64_t v453;
  uint64_t v454;
  int *v455;
  uint64_t v456;
  unint64_t v457;
  uint64_t v458;
  float v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  int v464;
  int v465;
  int v466;
  OpenSubdiv::v3_1_1::Far::internal::WeightTable *v467;
  float v468;
  int v469;
  float v470;
  float v471;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v472;
  int v473;
  unsigned int v474;
  float v475;
  _DWORD *v476;
  int v477;
  unint64_t v478;
  uint64_t v479;
  unsigned int v480;
  int v482;
  uint64_t v483;
  uint64_t v484;
  uint64_t v485;
  unsigned int v486;
  int v487;
  uint64_t v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  int *v495;
  uint64_t v496;
  _QWORD *v497;
  _QWORD *v498;
  uint64_t v499;
  _QWORD *v500;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v501;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v502;
  uint64_t v503;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v504;
  unsigned int v505;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v506;
  char v507;
  uint64_t v508;
  uint64_t v509;
  _QWORD *v510;
  char v511;
  uint64_t v512;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v513;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v514;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v515;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v516;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v517;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v518;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v519;
  int v520;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v521;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v522;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v523;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *v524;
  int v525;
  uint64_t v526;
  uint64_t v527;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v528;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v529;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v530;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v531;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v532;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v533;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v534;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v535;
  int v536;
  uint64_t v537;
  int v538;
  uint64_t v539;
  _QWORD *v540;
  int v541;
  uint64_t v542;
  int v543;
  uint64_t v544;
  uint64_t v545;
  int v546;
  uint64_t v547;
  _QWORD *v548;
  int v549;
  int v550;
  OpenSubdiv::v3_1_1::Far::internal::WeightTable *v551;
  float v552;
  float v553;
  int v554[2];
  float *v555;
  unint64_t v556;
  _DWORD v557[4];
  int v558[2];
  uint64_t v559;
  int v560;
  int v561;
  int v562;
  int v563;
  int *v564;
  uint64_t v565;
  float *v566;
  _DWORD v567[14];
  void *v568;
  float *v569;
  int v570;
  int v571;
  _BYTE v572[32];
  void *v573;
  void *__p;
  void *v575;
  uint64_t v576;

  v3 = a1;
  v576 = *MEMORY[0x24BDAC8D0];
  v487 = a2 & 3;
  v4 = **((_QWORD **)a1 + 11);
  if (v487 == 2)
    v5 = (int *)(*(_QWORD *)(*(_QWORD *)(v4 + 456) + 8 * (a2 >> 32)) + 16);
  else
    v5 = (int *)(v4 + 8);
  v6 = *v5;
  if (((*((unsigned __int8 *)a1 + 8) >> 2) & 0xFu) >= (((unsigned __int16)a2 >> 6) & 0xFu))
    v7 = ((unsigned __int16)a2 >> 6) & 0xF;
  else
    v7 = (*((unsigned __int8 *)a1 + 8) >> 2) & 0xF;
  v486 = (unsigned __int16)a2;
  if (!(a2 & 8 | v7))
  {
    v8 = operator new();
    *(_QWORD *)v8 = &off_24ED89DD0;
    *(_OWORD *)(v8 + 16) = 0u;
    *(_OWORD *)(v8 + 32) = 0u;
    *(_OWORD *)(v8 + 48) = 0u;
    *(_OWORD *)(v8 + 64) = 0u;
    *(_OWORD *)(v8 + 80) = 0u;
    *(_OWORD *)(v8 + 96) = 0u;
    *(_DWORD *)(v8 + 8) = v6;
    return v8;
  }
  v9 = (OpenSubdiv::v3_1_1::Far::internal::WeightTable *)operator new();
  v551 = OpenSubdiv::v3_1_1::Far::internal::WeightTable::WeightTable(v9, v6, 1, 1);
  v482 = v6;
  if (!v7)
  {
    v11 = 0;
    v14 = v486;
    goto LABEL_524;
  }
  v10 = v6;
  v11 = 0;
  v488 = a2 >> 32;
  v485 = (v7 + 1);
  v526 = 1;
  v12 = v10;
  v14 = v486;
  v13 = v487;
  v495 = v3;
  do
  {
    if (v13 != 1)
    {
      v550 = v12;
      if (!v13)
      {
        v15 = *v3;
        if (!*v3)
        {
          v207 = *((_QWORD *)v3 + 8);
          v208 = (v526 << 32) - 0x100000000;
          v209 = v208 >> 32;
          v210 = *(_QWORD *)(v207 + (v208 >> 29));
          v211 = *(_QWORD *)(v210 + 8);
          if (*(_DWORD *)(v210 + 52))
          {
            v212 = 0;
            v213 = *(unsigned int *)(v211 + 20);
            v569 = (float *)v572;
            v570 = v213;
            v571 = 16;
            __p = 0;
            if (v213 >= 0x11)
            {
              v212 = operator new(4 * v213);
              __p = v212;
              v569 = (float *)v212;
              v571 = v213;
            }
            v214 = *(_DWORD *)v211;
            if (*(int *)v211 >= 1)
            {
              v215 = 0;
              do
              {
                v216 = *(_DWORD *)(*(_QWORD *)(v210 + 168) + 4 * v215);
                if (v216 != -1)
                {
                  v217 = (unsigned int *)(*(_QWORD *)(v211 + 24) + 8 * v215);
                  v218 = *v217;
                  if ((int)v218 >= 1)
                  {
                    v219 = *(_QWORD *)(v211 + 48) + 4 * (int)v217[1];
                    v220 = v569;
                    v221 = *v217;
                    do
                    {
                      *v220++ = 1.0 / (float)(int)v218;
                      --v221;
                    }
                    while (v221);
                    v222 = 0;
                    v223 = v216 + v12;
                    v224 = 4 * v218;
                    do
                    {
                      v225 = v569[v222 / 4];
                      if (v225 != 0.0)
                        OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, *(_DWORD *)(v219 + v222) + v11, v223, v551, v225);
                      v222 += 4;
                    }
                    while (v224 != v222);
                    v214 = *(_DWORD *)v211;
                  }
                }
                ++v215;
              }
              while (v215 < v214);
              v212 = __p;
            }
            operator delete(v212);
            v210 = *(_QWORD *)(*((_QWORD *)v495 + 8) + 8 * v209);
            v211 = *(_QWORD *)(v210 + 8);
          }
          v226 = 0;
          v227 = *(unsigned int *)(v211 + 16);
          v569 = (float *)v572;
          v570 = v227;
          v571 = 8;
          v573 = 0;
          if (v227 >= 9)
          {
            v226 = operator new(4 * v227);
            v573 = v226;
            v569 = (float *)v226;
            v571 = v227;
          }
          v228 = *(_DWORD *)(v211 + 4);
          if (v228 >= 1)
          {
            v229 = 0;
            for (i = 0; i < v228; ++i)
            {
              v231 = *(_DWORD *)(*(_QWORD *)(v210 + 216) + 4 * i);
              if (v231 != -1)
              {
                v232 = (_DWORD *)(*(_QWORD *)(v211 + 120) + v229);
                v233 = v231 + v12;
                OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, *v232 + v11, v231 + v12, v551, 0.5);
                OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v232[1] + v11, v233, v551, 0.5);
                v228 = *(_DWORD *)(v211 + 4);
              }
              v229 += 8;
            }
            v226 = v573;
          }
          operator delete(v226);
          v58 = 0;
          v234 = *(_QWORD *)(*((_QWORD *)v495 + 8) + 8 * v209);
          v235 = *(_QWORD *)(v234 + 8);
          v236 = 2 * *(_DWORD *)(v235 + 20);
          v569 = (float *)v572;
          v570 = v236;
          v571 = 32;
          v575 = 0;
          if (v236 >= 0x21)
          {
            v58 = operator new(4 * v236);
            v575 = v58;
            v569 = (float *)v58;
            v571 = v236;
          }
          v237 = *(_DWORD *)(v235 + 8);
          if (v237 < 1)
            goto LABEL_513;
          for (j = 0; j < v237; ++j)
          {
            v239 = *(_DWORD *)(*(_QWORD *)(v234 + 240) + 4 * j);
            if (v239 != -1)
            {
              OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v11 + j, v239 + v12, v551, 1.0);
              v237 = *(_DWORD *)(v235 + 8);
            }
          }
          goto LABEL_512;
        }
        if (v15 != 1)
        {
          if (v15 != 2)
          {
            if ((v14 & 0x20) != 0)
              v11 = v12;
            v304 = *(_QWORD *)(*((_QWORD *)v3 + 11) + 24 * v526);
            v13 = v487;
            goto LABEL_518;
          }
          v16 = (v526 << 32) - 0x100000000;
          v527 = v16 >> 32;
          v17 = *(_QWORD *)(*((_QWORD *)v3 + 8) + (v16 >> 29));
          v18 = *(_QWORD *)(v17 + 8);
          if (*(_DWORD *)(v17 + 52))
          {
            v19 = 0;
            v20 = *(unsigned int *)(v18 + 20);
            v569 = (float *)v572;
            v570 = v20;
            v571 = 16;
            __p = 0;
            if (v20 >= 0x11)
            {
              v19 = operator new(4 * v20);
              __p = v19;
              v569 = (float *)v19;
              v571 = v20;
            }
            v21 = *(_DWORD *)v18;
            if (*(int *)v18 >= 1)
            {
              v22 = 0;
              do
              {
                v23 = *(_DWORD *)(*(_QWORD *)(v17 + 168) + 4 * v22);
                if (v23 != -1)
                {
                  v24 = (unsigned int *)(*(_QWORD *)(v18 + 24) + 8 * v22);
                  v25 = *v24;
                  if ((int)v25 >= 1)
                  {
                    v26 = *(_QWORD *)(v18 + 48) + 4 * (int)v24[1];
                    v27 = v569;
                    v28 = *v24;
                    do
                    {
                      *v27++ = 1.0 / (float)(int)v25;
                      --v28;
                    }
                    while (v28);
                    v29 = 0;
                    v30 = v23 + v12;
                    v31 = 4 * v25;
                    do
                    {
                      v32 = v569[v29 / 4];
                      if (v32 != 0.0)
                        OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, *(_DWORD *)(v26 + v29) + v11, v30, v551, v32);
                      v29 += 4;
                    }
                    while (v31 != v29);
                    v21 = *(_DWORD *)v18;
                    v3 = v495;
                  }
                }
                ++v22;
              }
              while (v22 < v21);
              v19 = __p;
            }
            operator delete(v19);
            v17 = *(_QWORD *)(*((_QWORD *)v3 + 8) + 8 * v527);
            v18 = *(_QWORD *)(v17 + 8);
          }
          v33 = 0;
          v34 = v3[1];
          v537 = *(_QWORD *)(v17 + 16);
          v35 = *(unsigned int *)(v18 + 16);
          v569 = (float *)v572;
          v570 = v35;
          v571 = 8;
          v573 = 0;
          if (v35 >= 9)
          {
            v33 = operator new(4 * v35);
            v573 = v33;
            v569 = (float *)v33;
            v571 = v35;
          }
          v36 = *(_DWORD *)(v18 + 4);
          if (v36 >= 1)
          {
            for (k = 0; k < v36; ++k)
            {
              v38 = *(int *)(*(_QWORD *)(v17 + 216) + 4 * k);
              if ((_DWORD)v38 != -1)
              {
                v39 = (_DWORD *)(*(_QWORD *)(v18 + 120) + 8 * k);
                v40 = *(_QWORD *)(v18 + 168);
                v41 = (unsigned int *)(*(_QWORD *)(v18 + 144) + 8 * k);
                v42 = *v41;
                v43 = (int)v41[1];
                v564 = v554;
                v565 = 0;
                v566 = v569;
                memset(v567, 0, 13);
                if (*(float *)(*(_QWORD *)(v18 + 216) + 4 * k) <= 0.0)
                  v44 = 1;
                else
                  v44 = 4;
                OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(v34, v18, k, (uint64_t)&v564, v44, (*(unsigned __int16 *)(*(_QWORD *)(v537 + 432) + 2 * v38) >> 7) & 0xF);
                if (*(float *)v554 != 0.0)
                  OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, *v39 + v11, v38 + v550, v551, *(float *)v554);
                if (*(float *)&v554[1] != 0.0)
                  OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v39[1] + v11, v38 + v550, v551, *(float *)&v554[1]);
                if (v567[2] >= 1 && (int)v42 >= 1)
                {
                  v45 = 0;
                  v46 = v40 + 4 * v43;
                  v47 = LOBYTE(v567[3]);
                  v48 = v38 + v550;
                  while (1)
                  {
                    v49 = *(int *)(v46 + 4 * v45);
                    if (!v47)
                      break;
                    v50 = v569[v45];
                    if (v50 != 0.0)
                    {
                      v51 = *(_DWORD *)(*(_QWORD *)(v17 + 168) + 4 * v49) + v550;
LABEL_57:
                      OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v51, v48, v551, v50);
                    }
LABEL_58:
                    if (++v45 == v42)
                      goto LABEL_59;
                  }
                  v52 = 0;
                  v53 = *(_QWORD *)(v18 + 24);
                  v54 = *(int *)(v53 + 8 * (_DWORD)v49 + 4);
                  v55 = *(_DWORD *)(v53 + 8 * v49);
                  do
                    v56 = *(unsigned int *)(*(_QWORD *)(v18 + 72) + 4 * v54 + 4 * v52++);
                  while (k != v56);
                  v50 = v569[v45];
                  if (v50 == 0.0)
                    goto LABEL_58;
                  v57 = *(_QWORD *)(v18 + 48) + 4 * v54;
                  if ((int)v52 + 1 < v55)
                    v55 = 0;
                  v51 = *(_DWORD *)(v57 + 4 * ((int)v52 - v55 + 1)) + v11;
                  goto LABEL_57;
                }
LABEL_59:
                v36 = *(_DWORD *)(v18 + 4);
                v12 = v550;
              }
            }
            v33 = v573;
            v3 = v495;
          }
          operator delete(v33);
          v58 = 0;
          v59 = v3[1];
          v60 = *(_QWORD **)(*((_QWORD *)v3 + 8) + 8 * v527);
          v62 = v60[1];
          v61 = (OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *)v60[2];
          v558[0] = v59;
          *(_QWORD *)v554 = v62;
          v555 = (float *)v61;
          v513 = v61;
          v63 = 2 * *(_DWORD *)(v62 + 20);
          v569 = (float *)v572;
          v570 = v63;
          v571 = 32;
          v575 = 0;
          if (v63 >= 0x21)
          {
            v58 = operator new(4 * v63);
            v575 = v58;
            v569 = (float *)v58;
            v571 = v63;
          }
          v64 = *(_DWORD *)(v62 + 8);
          if (v64 < 1)
            goto LABEL_513;
          for (m = 0; m < v64; ++m)
          {
            v66 = *(_DWORD *)(v60[30] + 4 * m);
            if (v66 != -1)
            {
              v528 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(v62 + 360);
              v67 = *(_QWORD *)(v62 + 336);
              v68 = (8 * m) | 4;
              v518 = (OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *)*(int *)(v67 + v68);
              v69 = *(int *)(v67 + 8 * m);
              v70 = *(_QWORD *)(v62 + 264);
              v71 = *(int *)(v70 + v68);
              v72 = *(unsigned int *)(v70 + 8 * m);
              v553 = 0.0;
              v73 = v569;
              v538 = v69;
              v74 = &v569[v69];
              v564 = (int *)&v553;
              v565 = (uint64_t)v569;
              v566 = v74;
              memset(v567, 0, 13);
              v556 = __PAIR64__(v66, m);
              v557[0] = *(_DWORD *)(v67 + 8 * m);
              v557[1] = *(_DWORD *)(v70 + 8 * m);
              v75 = *(_QWORD *)(v62 + 288);
              OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(v558, (uint64_t)v554, (uint64_t)&v564, (*(unsigned __int16 *)(*(_QWORD *)(v62 + 432) + 2 * m) >> 7) & 0xF, (*(unsigned __int16 *)(*((_QWORD *)v513 + 54) + 2 * (int)v66) >> 7) & 0xF);
              if (v567[2] >= 1 && (int)v72 >= 1)
              {
                v76 = (int *)(v75 + 4 * v71);
                do
                {
                  if (*v74 != 0.0)
                    OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, *(_DWORD *)(v60[21] + 4 * *v76) + v550, v66 + v550, v551, *v74);
                  ++v76;
                  ++v74;
                  --v72;
                }
                while (v72);
              }
              v77 = v538;
              v78 = v567[1] < 1 || v538 < 1;
              v12 = v550;
              if (!v78)
              {
                v79 = (int *)((char *)v528 + 4 * (_QWORD)v518);
                do
                {
                  if (*v73 != 0.0)
                  {
                    v80 = (_DWORD *)(*(_QWORD *)(v62 + 120) + 8 * *v79);
                    OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v80[m == *v80] + v11, v66 + v550, v551, *v73);
                  }
                  ++v79;
                  ++v73;
                  --v77;
                }
                while (v77);
              }
              if (v553 != 0.0)
                OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v11 + m, v66 + v550, v551, v553);
              v64 = *(_DWORD *)(v62 + 8);
            }
          }
          goto LABEL_512;
        }
        v240 = (v526 << 32) - 0x100000000;
        v542 = v240 >> 32;
        v241 = *(_QWORD *)(*((_QWORD *)v3 + 8) + (v240 >> 29));
        v242 = *(_QWORD *)(v241 + 8);
        if (*(_DWORD *)(v241 + 52))
        {
          v243 = 0;
          v244 = *(unsigned int *)(v242 + 20);
          v569 = (float *)v572;
          v570 = v244;
          v571 = 16;
          __p = 0;
          if (v244 >= 0x11)
          {
            v243 = operator new(4 * v244);
            __p = v243;
            v569 = (float *)v243;
            v571 = v244;
          }
          v245 = *(_DWORD *)v242;
          if (*(int *)v242 >= 1)
          {
            v246 = 0;
            do
            {
              v247 = *(_DWORD *)(*(_QWORD *)(v241 + 168) + 4 * v246);
              if (v247 != -1)
              {
                v248 = (unsigned int *)(*(_QWORD *)(v242 + 24) + 8 * v246);
                v249 = *v248;
                if ((int)v249 >= 1)
                {
                  v250 = *(_QWORD *)(v242 + 48) + 4 * (int)v248[1];
                  v251 = v569;
                  v252 = *v248;
                  do
                  {
                    *v251++ = 1.0 / (float)(int)v249;
                    --v252;
                  }
                  while (v252);
                  v253 = 0;
                  v254 = v247 + v12;
                  v255 = 4 * v249;
                  do
                  {
                    v256 = v569[v253 / 4];
                    if (v256 != 0.0)
                      OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, *(_DWORD *)(v250 + v253) + v11, v254, v551, v256);
                    v253 += 4;
                  }
                  while (v255 != v253);
                  v245 = *(_DWORD *)v242;
                  v3 = v495;
                }
              }
              ++v246;
            }
            while (v246 < v245);
            v243 = __p;
          }
          operator delete(v243);
          v241 = *(_QWORD *)(*((_QWORD *)v3 + 8) + 8 * v542);
          v242 = *(_QWORD *)(v241 + 8);
        }
        v257 = 0;
        v258 = *(_QWORD *)(v241 + 16);
        v558[0] = v3[1];
        v259 = *(unsigned int *)(v242 + 16);
        v569 = (float *)v572;
        v570 = v259;
        v571 = 8;
        v573 = 0;
        if (v259 >= 9)
        {
          v257 = operator new(4 * v259);
          v573 = v257;
          v569 = (float *)v257;
          v571 = v259;
        }
        v260 = *(_DWORD *)(v242 + 4);
        if (v260 >= 1)
        {
          for (n = 0; n < v260; ++n)
          {
            v262 = *(int *)(*(_QWORD *)(v241 + 216) + 4 * n);
            if ((_DWORD)v262 != -1)
            {
              v263 = (_DWORD *)(*(_QWORD *)(v242 + 120) + 8 * n);
              v264 = *(_QWORD *)(v242 + 168);
              v265 = (unsigned int *)(*(_QWORD *)(v242 + 144) + 8 * n);
              v266 = *v265;
              v267 = (int)v265[1];
              v564 = v554;
              v565 = 0;
              v566 = v569;
              memset(v567, 0, 13);
              if (*(float *)(*(_QWORD *)(v242 + 216) + 4 * n) <= 0.0)
                v268 = 1;
              else
                v268 = 4;
              OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(v558, (_QWORD *)v242, n, (uint64_t)&v564, v268, (*(unsigned __int16 *)(*(_QWORD *)(v258 + 432) + 2 * v262) >> 7) & 0xF);
              if (*(float *)v554 != 0.0)
                OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, *v263 + v11, v262 + v550, v551, *(float *)v554);
              if (*(float *)&v554[1] != 0.0)
                OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v263[1] + v11, v262 + v550, v551, *(float *)&v554[1]);
              if (v567[2] >= 1 && (int)v266 >= 1)
              {
                v269 = 0;
                v270 = v264 + 4 * v267;
                v271 = LOBYTE(v567[3]);
                v272 = v262 + v550;
                while (1)
                {
                  v273 = *(int *)(v270 + 4 * v269);
                  if (!v271)
                    break;
                  v274 = v569[v269];
                  if (v274 != 0.0)
                  {
                    v275 = *(_DWORD *)(*(_QWORD *)(v241 + 168) + 4 * v273) + v550;
LABEL_298:
                    OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v275, v272, v551, v274);
                  }
LABEL_299:
                  if (++v269 == v266)
                    goto LABEL_300;
                }
                v276 = 0;
                v277 = *(_QWORD *)(v242 + 24);
                v278 = *(int *)(v277 + 8 * (_DWORD)v273 + 4);
                v279 = *(_DWORD *)(v277 + 8 * v273);
                do
                  v280 = *(unsigned int *)(*(_QWORD *)(v242 + 72) + 4 * v278 + 4 * v276++);
                while (n != v280);
                v274 = v569[v269];
                if (v274 == 0.0)
                  goto LABEL_299;
                v281 = *(_QWORD *)(v242 + 48) + 4 * v278;
                if ((int)v276 + 1 < v279)
                  v279 = 0;
                v275 = *(_DWORD *)(v281 + 4 * ((int)v276 - v279 + 1)) + v11;
                goto LABEL_298;
              }
LABEL_300:
              v260 = *(_DWORD *)(v242 + 4);
              v12 = v550;
            }
          }
          v257 = v573;
          v3 = v495;
        }
        operator delete(v257);
        v58 = 0;
        v282 = v3[1];
        v283 = *(_QWORD **)(*((_QWORD *)v3 + 8) + 8 * v542);
        v285 = v283[1];
        v284 = (OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *)v283[2];
        v558[0] = v282;
        *(_QWORD *)v554 = v285;
        v555 = (float *)v284;
        v515 = v284;
        v286 = 2 * *(_DWORD *)(v285 + 20);
        v569 = (float *)v572;
        v570 = v286;
        v571 = 32;
        v575 = 0;
        if (v286 >= 0x21)
        {
          v58 = operator new(4 * v286);
          v575 = v58;
          v569 = (float *)v58;
          v571 = v286;
        }
        v287 = *(_DWORD *)(v285 + 8);
        if (v287 < 1)
          goto LABEL_513;
        for (ii = 0; ii < v287; ++ii)
        {
          v289 = *(_DWORD *)(v283[30] + 4 * ii);
          if (v289 != -1)
          {
            v531 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(v285 + 360);
            v290 = *(_QWORD *)(v285 + 336);
            v291 = (8 * ii) | 4;
            v521 = (OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *)*(int *)(v290 + v291);
            v292 = *(int *)(v290 + 8 * ii);
            v293 = *(_QWORD *)(v285 + 264);
            v294 = *(int *)(v293 + v291);
            v295 = *(unsigned int *)(v293 + 8 * ii);
            v553 = 0.0;
            v296 = v569;
            v543 = v292;
            v297 = &v569[v292];
            v564 = (int *)&v553;
            v565 = (uint64_t)v569;
            v566 = v297;
            memset(v567, 0, 13);
            v556 = __PAIR64__(v289, ii);
            v557[0] = *(_DWORD *)(v290 + 8 * ii);
            v557[1] = *(_DWORD *)(v293 + 8 * ii);
            v298 = *(_QWORD *)(v285 + 288);
            OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(v558, (uint64_t)v554, (uint64_t)&v564, (*(unsigned __int16 *)(*(_QWORD *)(v285 + 432) + 2 * ii) >> 7) & 0xF, (*(unsigned __int16 *)(*((_QWORD *)v515 + 54) + 2 * (int)v289) >> 7) & 0xF);
            if (v567[2] >= 1 && (int)v295 >= 1)
            {
              v299 = (int *)(v298 + 4 * v294);
              do
              {
                if (*v297 != 0.0)
                  OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, *(_DWORD *)(v283[21] + 4 * *v299) + v550, v289 + v550, v551, *v297);
                ++v299;
                ++v297;
                --v295;
              }
              while (v295);
            }
            v300 = v543;
            v301 = v567[1] < 1 || v543 < 1;
            v12 = v550;
            if (!v301)
            {
              v302 = (int *)((char *)v531 + 4 * (_QWORD)v521);
              do
              {
                if (*v296 != 0.0)
                {
                  v303 = (_DWORD *)(*(_QWORD *)(v285 + 120) + 8 * *v302);
                  OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v303[ii == *v303] + v11, v289 + v550, v551, *v296);
                }
                ++v302;
                ++v296;
                --v300;
              }
              while (v300);
            }
            if (v553 != 0.0)
              OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v11 + ii, v289 + v550, v551, v553);
            v287 = *(_DWORD *)(v285 + 8);
          }
        }
LABEL_512:
        v58 = v575;
LABEL_513:
        operator delete(v58);
        goto LABEL_514;
      }
      v100 = *v3;
      v536 = v11;
      if (*v3)
      {
        if (v100 != 2)
        {
          if (v100 != 1)
            goto LABEL_514;
          v101 = (float *)v495;
          v102 = (v526 << 32) - 0x100000000;
          v103 = v102 >> 32;
          v104 = *(_QWORD *)(*((_QWORD *)v495 + 8) + (v102 >> 29));
          v496 = v103;
          if (*(_DWORD *)(v104 + 52))
          {
            v105 = 0;
            v106 = *(_QWORD *)(v104 + 8);
            v107 = v104;
            v108 = *(_QWORD **)(*(_QWORD *)(v106 + 456) + 8 * v488);
            v539 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v104 + 16) + 456) + 8 * v488);
            v109 = *(unsigned int *)(v106 + 20);
            v569 = (float *)v572;
            v570 = v109;
            v571 = 16;
            __p = 0;
            if (v109 >= 0x11)
            {
              v105 = operator new(4 * v109);
              __p = v105;
              v569 = (float *)v105;
              v571 = v109;
            }
            v110 = *(_DWORD *)v106;
            if (*(int *)v106 >= 1)
            {
              v111 = 0;
              v112 = v107;
              do
              {
                v113 = *(int *)(*(_QWORD *)(v112 + 168) + 4 * v111);
                if ((_DWORD)v113 != -1)
                {
                  v114 = (unsigned int *)(*(_QWORD *)(*v108 + 24) + 8 * v111);
                  v115 = *v114;
                  if ((int)v115 >= 1)
                  {
                    v116 = *(_DWORD *)(*(_QWORD *)(v539 + 96) + 4 * v113);
                    v117 = v108[3] + 4 * (int)v114[1];
                    v118 = v569;
                    v119 = *v114;
                    do
                    {
                      *v118++ = 1.0 / (float)(int)v115;
                      --v119;
                    }
                    while (v119);
                    v120 = 0;
                    v121 = v116 + v12;
                    v122 = 4 * v115;
                    do
                    {
                      v123 = v569[v120 / 4];
                      if (v123 != 0.0)
                        OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, *(_DWORD *)(v117 + v120) + v11, v121, v551, v123);
                      v120 += 4;
                    }
                    while (v122 != v120);
                    v110 = *(_DWORD *)v106;
                    v112 = v107;
                  }
                }
                ++v111;
              }
              while (v111 < v110);
              v105 = __p;
              v103 = v496;
            }
            operator delete(v105);
            v101 = (float *)v495;
            v104 = *(_QWORD *)(*((_QWORD *)v495 + 8) + 8 * v103);
          }
          v124 = 0;
          v553 = v101[1];
          v125 = *(_QWORD *)(v104 + 8);
          v519 = (OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *)v104;
          v126 = *(_QWORD *)(*(_QWORD *)(v104 + 480) + 8 * v488);
          v127 = *(_QWORD **)(*(_QWORD *)(v125 + 456) + 8 * v488);
          v501 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(v104 + 16);
          v128 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(*((_QWORD *)v501 + 57) + 8 * v488);
          v129 = *(unsigned int *)(v125 + 16);
          v130 = (float *)v572;
          v569 = (float *)v572;
          v570 = v129;
          v571 = 8;
          v573 = 0;
          if (v129 >= 9)
          {
            v124 = operator new(4 * v129);
            v573 = v124;
            v569 = (float *)v124;
            v571 = v129;
            v130 = (float *)v124;
          }
          v564 = v554;
          v565 = 0;
          v566 = v130;
          memset(v567, 0, 13);
          if (*((_BYTE *)v127 + 12))
            v131 = 1;
          else
            v131 = *(_DWORD *)v101 == 0;
          v132 = v131;
          v507 = v132;
          if (v131)
          {
            v567[0] = 2;
            *(_QWORD *)v554 = 0x3F0000003F000000;
          }
          if (*(int *)(v125 + 4) >= 1)
          {
            v529 = v128;
            v133 = 0;
            v540 = v127;
            do
            {
              v134 = *(int *)(*((_QWORD *)v519 + 27) + 4 * v133);
              if ((_DWORD)v134 != -1)
              {
                v135 = (int *)(*((_QWORD *)v529 + 18) + 4 * *(int *)(*((_QWORD *)v529 + 12) + 4 * v134));
                if ((*(_BYTE *)(*((_QWORD *)v529 + 21) + *v135) & 1) != 0)
                {
                  v154 = *((_QWORD *)v529 + 9);
                  v155 = *(unsigned __int16 *)(v154 + 2 * v134);
                  if (*(_WORD *)(v154 + 2 * v134))
                  {
                    v156 = 0;
                    do
                    {
                      OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues(v127, v133, *(unsigned __int16 *)(*(_QWORD *)(v126 + 40)+ 2* (v156 + *(int *)(*(_QWORD *)(*(_QWORD *)(v126 + 32) + 96) + 4 * v134))), v558);
                      v157 = v135[v156] + v550;
                      OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v558[0] + v11, v157, v551, 0.5);
                      v158 = v157;
                      v127 = v540;
                      OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v558[1] + v11, v158, v551, 0.5);
                      ++v156;
                    }
                    while (v155 != v156);
                  }
                }
                else
                {
                  if ((v507 & 1) == 0)
                  {
                    if (*(float *)(*(_QWORD *)(v125 + 216) + 4 * v133) <= 0.0)
                      v136 = 1;
                    else
                      v136 = 4;
                    OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(&v553, (_QWORD *)v125, v133, (uint64_t)&v564, v136, (*(unsigned __int16 *)(*((_QWORD *)v501 + 54) + 2 * v134) >> 7) & 0xF);
                  }
                  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues(v127, v133, 0, v558);
                  v137 = *v135;
                  if (*(float *)v554 != 0.0)
                    OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v558[0] + v11, v137 + v550, v551, *(float *)v554);
                  if (*(float *)&v554[1] != 0.0)
                    OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v558[1] + v11, v137 + v550, v551, *(float *)&v554[1]);
                  if (v567[2] >= 1)
                  {
                    v138 = (unsigned int *)(*(_QWORD *)(v125 + 144) + 8 * v133);
                    v139 = *v138;
                    if ((int)v139 >= 1)
                    {
                      v140 = 0;
                      v141 = *(_QWORD *)(v125 + 168) + 4 * (int)v138[1];
                      v142 = LOBYTE(v567[3]);
                      v143 = v137 + v550;
                      while (1)
                      {
                        v144 = *(int *)(v141 + 4 * v140);
                        if (!v142)
                          break;
                        v145 = v569[v140];
                        if (v145 != 0.0)
                        {
                          v146 = *(_DWORD *)(*((_QWORD *)v529 + 12) + 4 * *(int *)(*((_QWORD *)v519 + 21) + 4 * v144))
                               + v550;
LABEL_164:
                          OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v146, v143, v551, v145);
                        }
LABEL_165:
                        if (++v140 == v139)
                          goto LABEL_166;
                      }
                      v147 = 0;
                      v148 = (2 * (int)v144) | 1;
                      v149 = *(_QWORD *)(v125 + 24);
                      v150 = *(_QWORD *)(v125 + 72) + 4 * *(int *)(v149 + 4 * v148);
                      v151 = *(_DWORD *)(v149 + 8 * v144);
                      do
                        v152 = *(unsigned int *)(v150 + 4 * v147++);
                      while (v133 != v152);
                      v145 = v569[v140];
                      if (v145 == 0.0)
                        goto LABEL_165;
                      v153 = v540[3] + 4 * *(int *)(*(_QWORD *)(*v540 + 24) + 4 * v148);
                      if ((int)v147 + 1 < v151)
                        v151 = 0;
                      v146 = *(_DWORD *)(v153 + 4 * ((int)v147 - v151 + 1)) + v11;
                      goto LABEL_164;
                    }
                  }
LABEL_166:
                  v127 = v540;
                }
              }
              ++v133;
            }
            while (v133 < *(int *)(v125 + 4));
            v124 = v573;
            v101 = (float *)v495;
            v103 = v496;
          }
          operator delete(v124);
          v159 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*((_QWORD *)v101 + 8) + 8 * v103);
          v160 = *((_QWORD *)v159 + 1);
          v514 = v159;
          v530 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(*((_QWORD *)v159 + 60) + 8 * v488);
          v483 = *((_QWORD *)v159 + 2);
          v497 = *(_QWORD **)(*(_QWORD *)(v483 + 456) + 8 * v488);
          v502 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(_QWORD *)(v160 + 456) + 8 * v488);
          v161 = *v101;
          v553 = v101[1];
          if (*((_BYTE *)v502 + 12))
            v162 = 1;
          else
            v162 = LODWORD(v161) == 0;
          v163 = v162;
          v541 = v163;
          v491 = v160;
          v164 = *(_DWORD *)(v160 + 20);
          v569 = (float *)v572;
          v570 = 2 * v164;
          v571 = 32;
          v575 = 0;
          if (2 * v164 >= 0x21)
          {
            v575 = operator new(8 * v164);
            v569 = (float *)v575;
            v571 = 2 * v164;
            v164 = *(_DWORD *)(v491 + 20);
          }
          v165 = 0;
          v564 = (int *)&v566;
          v565 = v164 | 0x1000000000;
          v568 = 0;
          v12 = v550;
          if (v164 >= 0x11)
          {
            v165 = operator new(4 * v164);
            v568 = v165;
            v564 = (int *)v165;
            HIDWORD(v565) = v164;
          }
          *(_QWORD *)v558 = v491;
          v559 = v483;
          if (*(int *)(v491 + 8) >= 1)
          {
            v166 = 0;
            while (1)
            {
              v520 = *(_DWORD *)(*((_QWORD *)v514 + 30) + 4 * v166);
              if (v520 != -1)
              {
                v167 = *(int *)(*((_QWORD *)v502 + 12) + 4 * v166);
                v168 = (int *)(*((_QWORD *)v502 + 18) + 4 * v167);
                v169 = *(int *)(v497[12] + 4 * v520);
                v170 = (int *)(v497[18] + 4 * v169);
                v171 = *v170;
                v172 = v497[21];
                v173 = v541;
                if ((*(_BYTE *)(v172 + v171) & 1) != 0)
                  v173 = 0;
                if (v173 == 1)
                {
                  v174 = v171 + v550;
                  v175 = *v168 + v11;
                  v176 = v551;
                  v177 = 1.0;
                }
                else
                {
                  if ((*(_BYTE *)(v172 + v171) & 1) != 0)
                  {
                    v191 = v497[9];
                    v192 = *(unsigned __int16 *)(v191 + 2 * v520);
                    if (!*(_WORD *)(v191 + 2 * v520))
                      goto LABEL_222;
                    v193 = 0;
                    v489 = *((_QWORD *)v502 + 21) + v167;
                    v508 = v172 + v169;
                    while (2)
                    {
                      v194 = *(unsigned __int16 *)(*((_QWORD *)v530 + 5)
                                                 + 2
                                                 * (v193
                                                  + *(int *)(*(_QWORD *)(*((_QWORD *)v530 + 4) + 96) + 4 * v520)));
                      v195 = v168[v194];
                      v196 = v170[v193] + v550;
                      if ((v541 & 1) != 0 || (*(_BYTE *)(v508 + v193) & 8) == 0)
                      {
                        v197 = v195 + v11;
                        v198 = v551;
                        v199 = 1.0;
                        v200 = v170[v193] + v550;
                        goto LABEL_210;
                      }
                      OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(v502, v166, *(unsigned __int16 *)(*((_QWORD *)v530 + 5)+ 2* (v193 + *(int *)(*(_QWORD *)(*((_QWORD *)v530 + 4) + 96) + 4 * v520))), v554);
                      if ((*(_BYTE *)(v489 + v194) & 0x10) == 0)
                      {
                        v201 = 0.75;
                        v202 = 0.125;
                        goto LABEL_219;
                      }
                      if ((*(_BYTE *)(v489 + v194) & 0x20) != 0)
                      {
                        v205 = v194 == 0;
                        v203 = v530;
                        v204 = v166;
                      }
                      else
                      {
                        v203 = v530;
                        v204 = v166;
                        v205 = v194;
                      }
                      FractionalWeight = OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(v203, v204, v205, v520);
                      v201 = FractionalWeight + (float)((float)(1.0 - FractionalWeight) * 0.75);
                      v202 = (float)(1.0 - FractionalWeight) * 0.125;
                      if (v202 != 0.0)
                      {
LABEL_219:
                        OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v554[0] + v11, v196, v551, v202);
                        OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v554[1] + v11, v196, v551, v202);
                      }
                      if (v201 != 0.0)
                      {
                        v197 = v195 + v11;
                        v198 = v551;
                        v200 = v196;
                        v199 = v201;
LABEL_210:
                        OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v198, v197, v200, v198, v199);
                      }
                      if (v192 == ++v193)
                        goto LABEL_222;
                      continue;
                    }
                  }
                  v178 = *(_QWORD *)(v491 + 336);
                  v179 = *(int *)(v178 + 8 * v166);
                  v552 = 0.0;
                  v180 = v569;
                  v181 = &v569[v179];
                  *(_QWORD *)v554 = &v552;
                  v555 = v569;
                  v556 = (unint64_t)v181;
                  memset(v557, 0, 13);
                  v560 = v166;
                  v561 = v520;
                  v562 = *(_DWORD *)(v178 + 8 * v166);
                  v563 = *(_DWORD *)(*(_QWORD *)(v491 + 264) + 8 * v166);
                  OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>((int *)&v553, (uint64_t)v558, (uint64_t)v554, (*(unsigned __int16 *)(*(_QWORD *)(v491 + 432) + 2 * v166) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v483 + 432) + 2 * v520) >> 7) & 0xF);
                  v182 = *v168;
                  v183 = *v170;
                  if (v557[2] >= 1)
                  {
                    v184 = *(_QWORD *)(v491 + 264);
                    v185 = *(unsigned int *)(v184 + 8 * v166);
                    if ((int)v185 >= 1)
                    {
                      v186 = (int *)(*(_QWORD *)(v491 + 288) + 4 * *(int *)(v184 + ((8 * v166) | 4)));
                      do
                      {
                        if (*v181 != 0.0)
                          OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, *(_DWORD *)(v497[12] + 4 * *(int *)(*((_QWORD *)v514 + 21) + 4 * *v186)) + v550, v183 + v550, v551, *v181);
                        ++v186;
                        ++v181;
                        --v185;
                      }
                      while (v185);
                    }
                  }
                  if (v557[1] >= 1)
                  {
                    v187 = v179;
                    OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexEdgeValues(v502, v166, v564);
                    if ((int)v179 >= 1)
                    {
                      v188 = 0;
                      v189 = 4 * v187;
                      do
                      {
                        v190 = v180[v188 / 4];
                        if (v190 != 0.0)
                          OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v564[v188 / 4] + v11, v183 + v550, v551, v190);
                        v188 += 4;
                      }
                      while (v189 != v188);
                    }
                  }
                  v177 = v552;
                  if (v552 == 0.0)
                    goto LABEL_222;
                  v175 = v182 + v11;
                  v174 = v183 + v550;
                  v176 = v551;
                }
                OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v176, v175, v174, v176, v177);
              }
LABEL_222:
              if (++v166 >= *(int *)(v491 + 8))
                goto LABEL_510;
            }
          }
LABEL_511:
          operator delete(v165);
          goto LABEL_512;
        }
        v372 = (v526 << 32) - 0x100000000;
        v373 = v372 >> 32;
        v374 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*((_QWORD *)v3 + 8) + (v372 >> 29));
        v493 = v372 >> 32;
        if (*((_DWORD *)v374 + 13))
        {
          v375 = 0;
          v377 = *((_QWORD *)v374 + 1);
          v376 = *((_QWORD *)v374 + 2);
          v378 = *(_QWORD *)(*((_QWORD *)v3 + 8) + (v372 >> 29));
          v379 = *(_QWORD **)(*(_QWORD *)(v377 + 456) + 8 * v488);
          v547 = *(_QWORD *)(*(_QWORD *)(v376 + 456) + 8 * v488);
          v380 = *(unsigned int *)(v377 + 20);
          v569 = (float *)v572;
          v570 = v380;
          v571 = 16;
          __p = 0;
          if (v380 >= 0x11)
          {
            v375 = operator new(4 * v380);
            __p = v375;
            v569 = (float *)v375;
            v571 = v380;
          }
          v381 = *(_DWORD *)v377;
          if (*(int *)v377 >= 1)
          {
            v382 = 0;
            do
            {
              v383 = *(int *)(*(_QWORD *)(v378 + 168) + 4 * v382);
              if ((_DWORD)v383 != -1)
              {
                v384 = (unsigned int *)(*(_QWORD *)(*v379 + 24) + 8 * v382);
                v385 = *v384;
                if ((int)v385 >= 1)
                {
                  v386 = *(_DWORD *)(*(_QWORD *)(v547 + 96) + 4 * v383);
                  v387 = v379[3] + 4 * (int)v384[1];
                  v388 = v569;
                  v389 = *v384;
                  do
                  {
                    *v388++ = 1.0 / (float)(int)v385;
                    --v389;
                  }
                  while (v389);
                  v390 = 0;
                  v391 = v386 + v12;
                  v392 = 4 * v385;
                  do
                  {
                    v393 = v569[v390 / 4];
                    if (v393 != 0.0)
                      OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, *(_DWORD *)(v387 + v390) + v11, v391, v551, v393);
                    v390 += 4;
                  }
                  while (v392 != v390);
                  v381 = *(_DWORD *)v377;
                }
              }
              ++v382;
            }
            while (v382 < v381);
            v375 = __p;
            v373 = v493;
          }
          operator delete(v375);
          v3 = v495;
          v374 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*((_QWORD *)v495 + 8) + 8 * v373);
        }
        v394 = 0;
        v505 = v3[1];
        v395 = *((_QWORD *)v374 + 1);
        v396 = *(_QWORD *)(*((_QWORD *)v374 + 60) + 8 * v488);
        v397 = *(_QWORD **)(*(_QWORD *)(v395 + 456) + 8 * v488);
        v499 = *((_QWORD *)v374 + 2);
        v398 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(*(_QWORD *)(v499 + 456) + 8 * v488);
        v399 = *(unsigned int *)(v395 + 16);
        v400 = (float *)v572;
        v569 = (float *)v572;
        v570 = v399;
        v571 = 8;
        v573 = 0;
        if (v399 >= 9)
        {
          v394 = operator new(4 * v399);
          v573 = v394;
          v569 = (float *)v394;
          v571 = v399;
          v400 = (float *)v394;
        }
        v564 = v554;
        v565 = 0;
        v566 = v400;
        memset(v567, 0, 13);
        if (*((_BYTE *)v397 + 12))
          v401 = 1;
        else
          v401 = *v495 == 0;
        v402 = v401;
        v511 = v402;
        if (v401)
        {
          v567[0] = 2;
          *(_QWORD *)v554 = 0x3F0000003F000000;
        }
        if (*(int *)(v395 + 4) >= 1)
        {
          v534 = v398;
          v403 = 0;
          v548 = v397;
          v524 = v374;
          do
          {
            v404 = *(int *)(*((_QWORD *)v374 + 27) + 4 * v403);
            if ((_DWORD)v404 != -1)
            {
              v405 = (int *)(*((_QWORD *)v534 + 18) + 4 * *(int *)(*((_QWORD *)v534 + 12) + 4 * v404));
              if ((*(_BYTE *)(*((_QWORD *)v534 + 21) + *v405) & 1) != 0)
              {
                v424 = *((_QWORD *)v534 + 9);
                v425 = *(unsigned __int16 *)(v424 + 2 * v404);
                if (*(_WORD *)(v424 + 2 * v404))
                {
                  v426 = 0;
                  do
                  {
                    OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues(v397, v403, *(unsigned __int16 *)(*(_QWORD *)(v396 + 40)+ 2 * (v426 + *(int *)(*(_QWORD *)(*(_QWORD *)(v396 + 32) + 96) + 4 * v404))), v558);
                    v427 = v405[v426] + v550;
                    OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v558[0] + v11, v427, v551, 0.5);
                    v428 = v427;
                    v397 = v548;
                    OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v558[1] + v11, v428, v551, 0.5);
                    ++v426;
                  }
                  while (v425 != v426);
                }
              }
              else
              {
                if ((v511 & 1) == 0)
                {
                  if (*(float *)(*(_QWORD *)(v395 + 216) + 4 * v403) <= 0.0)
                    v406 = 1;
                  else
                    v406 = 4;
                  OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(v505, v395, v403, (uint64_t)&v564, v406, (*(unsigned __int16 *)(*(_QWORD *)(v499 + 432) + 2 * v404) >> 7) & 0xF);
                }
                OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues(v397, v403, 0, v558);
                v407 = *v405;
                if (*(float *)v554 != 0.0)
                  OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v558[0] + v11, v407 + v550, v551, *(float *)v554);
                if (*(float *)&v554[1] != 0.0)
                  OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v558[1] + v11, v407 + v550, v551, *(float *)&v554[1]);
                if (v567[2] >= 1)
                {
                  v408 = (unsigned int *)(*(_QWORD *)(v395 + 144) + 8 * v403);
                  v409 = *v408;
                  if ((int)v409 >= 1)
                  {
                    v410 = 0;
                    v411 = *(_QWORD *)(v395 + 168) + 4 * (int)v408[1];
                    v412 = LOBYTE(v567[3]);
                    v413 = v407 + v550;
                    while (1)
                    {
                      v414 = *(int *)(v411 + 4 * v410);
                      if (!v412)
                        break;
                      v415 = v569[v410];
                      if (v415 != 0.0)
                      {
                        v416 = *(_DWORD *)(*((_QWORD *)v534 + 12) + 4 * *(int *)(*((_QWORD *)v524 + 21) + 4 * v414))
                             + v550;
LABEL_451:
                        OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v416, v413, v551, v415);
                      }
LABEL_452:
                      if (++v410 == v409)
                        goto LABEL_453;
                    }
                    v417 = 0;
                    v418 = (2 * (int)v414) | 1;
                    v419 = *(_QWORD *)(v395 + 24);
                    v420 = *(_QWORD *)(v395 + 72) + 4 * *(int *)(v419 + 4 * v418);
                    v421 = *(_DWORD *)(v419 + 8 * v414);
                    do
                      v422 = *(unsigned int *)(v420 + 4 * v417++);
                    while (v403 != v422);
                    v415 = v569[v410];
                    if (v415 == 0.0)
                      goto LABEL_452;
                    v423 = v548[3] + 4 * *(int *)(*(_QWORD *)(*v548 + 24) + 4 * v418);
                    if ((int)v417 + 1 < v421)
                      v421 = 0;
                    v416 = *(_DWORD *)(v423 + 4 * ((int)v417 - v421 + 1)) + v11;
                    goto LABEL_451;
                  }
                }
LABEL_453:
                v397 = v548;
              }
            }
            ++v403;
            v374 = v524;
          }
          while (v403 < *(int *)(v395 + 4));
          v394 = v573;
          v12 = v550;
          v373 = v493;
        }
        operator delete(v394);
        v429 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*((_QWORD *)v495 + 8) + 8 * v373);
        v430 = *((_QWORD *)v429 + 1);
        v517 = v429;
        v535 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(*((_QWORD *)v429 + 60) + 8 * v488);
        v484 = *((_QWORD *)v429 + 2);
        v500 = *(_QWORD **)(*(_QWORD *)(v484 + 456) + 8 * v488);
        v506 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(_QWORD *)(v430 + 456) + 8 * v488);
        v431 = *v495;
        v553 = *((float *)v495 + 1);
        if (*((_BYTE *)v506 + 12))
          v432 = 1;
        else
          v432 = v431 == 0;
        v433 = v432;
        v549 = v433;
        v494 = v430;
        v434 = *(_DWORD *)(v430 + 20);
        v569 = (float *)v572;
        v570 = 2 * v434;
        v571 = 32;
        v575 = 0;
        if (2 * v434 >= 0x21)
        {
          v575 = operator new(8 * v434);
          v569 = (float *)v575;
          v571 = 2 * v434;
          v434 = *(_DWORD *)(v494 + 20);
        }
        v165 = 0;
        v564 = (int *)&v566;
        v565 = v434 | 0x1000000000;
        v568 = 0;
        if (v434 >= 0x11)
        {
          v165 = operator new(4 * v434);
          v568 = v165;
          v564 = (int *)v165;
          HIDWORD(v565) = v434;
        }
        *(_QWORD *)v558 = v494;
        v559 = v484;
        if (*(int *)(v494 + 8) < 1)
          goto LABEL_511;
        v435 = 0;
        while (1)
        {
          v525 = *(_DWORD *)(*((_QWORD *)v517 + 30) + 4 * v435);
          if (v525 != -1)
          {
            v436 = *(int *)(*((_QWORD *)v506 + 12) + 4 * v435);
            v437 = (int *)(*((_QWORD *)v506 + 18) + 4 * v436);
            v438 = *(int *)(v500[12] + 4 * v525);
            v439 = (int *)(v500[18] + 4 * v438);
            v440 = *v439;
            v441 = v500[21];
            v442 = v549;
            if ((*(_BYTE *)(v441 + v440) & 1) != 0)
              v442 = 0;
            if (v442 == 1)
            {
              v443 = v440 + v550;
              v444 = *v437 + v11;
              v445 = v551;
              v446 = 1.0;
            }
            else
            {
              if ((*(_BYTE *)(v441 + v440) & 1) != 0)
              {
                v460 = v500[9];
                v461 = *(unsigned __int16 *)(v460 + 2 * v525);
                if (!*(_WORD *)(v460 + 2 * v525))
                  goto LABEL_509;
                v462 = 0;
                v490 = *((_QWORD *)v506 + 21) + v436;
                v512 = v441 + v438;
                while (2)
                {
                  v463 = *(unsigned __int16 *)(*((_QWORD *)v535 + 5)
                                             + 2
                                             * (v462 + *(int *)(*(_QWORD *)(*((_QWORD *)v535 + 4) + 96) + 4 * v525)));
                  v464 = v437[v463];
                  v465 = v439[v462] + v550;
                  if ((v549 & 1) != 0 || (*(_BYTE *)(v512 + v462) & 8) == 0)
                  {
                    v466 = v464 + v11;
                    v467 = v551;
                    v468 = 1.0;
                    v469 = v439[v462] + v550;
                    goto LABEL_497;
                  }
                  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(v506, v435, *(unsigned __int16 *)(*((_QWORD *)v535 + 5)+ 2 * (v462 + *(int *)(*(_QWORD *)(*((_QWORD *)v535 + 4) + 96) + 4 * v525))), v554);
                  if ((*(_BYTE *)(v490 + v463) & 0x10) == 0)
                  {
                    v470 = 0.75;
                    v471 = 0.125;
                    goto LABEL_506;
                  }
                  if ((*(_BYTE *)(v490 + v463) & 0x20) != 0)
                  {
                    v474 = v463 == 0;
                    v472 = v535;
                    v473 = v435;
                  }
                  else
                  {
                    v472 = v535;
                    v473 = v435;
                    v474 = v463;
                  }
                  v475 = OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(v472, v473, v474, v525);
                  v470 = v475 + (float)((float)(1.0 - v475) * 0.75);
                  v471 = (float)(1.0 - v475) * 0.125;
                  if (v471 != 0.0)
                  {
LABEL_506:
                    OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v554[0] + v11, v465, v551, v471);
                    OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v554[1] + v11, v465, v551, v471);
                  }
                  if (v470 != 0.0)
                  {
                    v466 = v464 + v11;
                    v467 = v551;
                    v469 = v465;
                    v468 = v470;
LABEL_497:
                    OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v467, v466, v469, v467, v468);
                  }
                  if (v461 == ++v462)
                    goto LABEL_509;
                  continue;
                }
              }
              v447 = *(_QWORD *)(v494 + 336);
              v448 = *(int *)(v447 + 8 * v435);
              v552 = 0.0;
              v449 = v569;
              v450 = &v569[v448];
              *(_QWORD *)v554 = &v552;
              v555 = v569;
              v556 = (unint64_t)v450;
              memset(v557, 0, 13);
              v560 = v435;
              v561 = v525;
              v562 = *(_DWORD *)(v447 + 8 * v435);
              v563 = *(_DWORD *)(*(_QWORD *)(v494 + 264) + 8 * v435);
              OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>((int *)&v553, (uint64_t)v558, (uint64_t)v554, (*(unsigned __int16 *)(*(_QWORD *)(v494 + 432) + 2 * v435) >> 7) & 0xF, (*(unsigned __int16 *)(*(_QWORD *)(v484 + 432) + 2 * v525) >> 7) & 0xF);
              v451 = *v437;
              v452 = *v439;
              if (v557[2] >= 1)
              {
                v453 = *(_QWORD *)(v494 + 264);
                v454 = *(unsigned int *)(v453 + 8 * v435);
                if ((int)v454 >= 1)
                {
                  v455 = (int *)(*(_QWORD *)(v494 + 288) + 4 * *(int *)(v453 + ((8 * v435) | 4)));
                  do
                  {
                    if (*v450 != 0.0)
                      OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, *(_DWORD *)(v500[12] + 4 * *(int *)(*((_QWORD *)v517 + 21) + 4 * *v455)) + v550, v452 + v550, v551, *v450);
                    ++v455;
                    ++v450;
                    --v454;
                  }
                  while (v454);
                }
              }
              if (v557[1] >= 1)
              {
                v456 = v448;
                OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexEdgeValues(v506, v435, v564);
                if ((int)v448 >= 1)
                {
                  v457 = 0;
                  v458 = 4 * v456;
                  do
                  {
                    v459 = v449[v457 / 4];
                    if (v459 != 0.0)
                      OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v564[v457 / 4] + v11, v452 + v550, v551, v459);
                    v457 += 4;
                  }
                  while (v458 != v457);
                }
              }
              v446 = v552;
              if (v552 == 0.0)
                goto LABEL_509;
              v444 = v451 + v11;
              v443 = v452 + v550;
              v445 = v551;
            }
            OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v445, v444, v443, v445, v446);
          }
LABEL_509:
          if (++v435 >= *(int *)(v494 + 8))
          {
LABEL_510:
            v165 = v568;
            v12 = v550;
            goto LABEL_511;
          }
        }
      }
      v305 = (v526 << 32) - 0x100000000;
      v306 = v305 >> 32;
      v307 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(*((_QWORD *)v3 + 8) + (v305 >> 29));
      v503 = v305 >> 32;
      if (*((_DWORD *)v307 + 13))
      {
        v308 = 0;
        v309 = *((_QWORD *)v307 + 1);
        v310 = *(_QWORD **)(*(_QWORD *)(v309 + 456) + 8 * v488);
        v544 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)v307 + 2) + 456) + 8 * v488);
        v311 = *(unsigned int *)(v309 + 20);
        v569 = (float *)v572;
        v570 = v311;
        v571 = 16;
        __p = 0;
        if (v311 >= 0x11)
        {
          v308 = operator new(4 * v311);
          __p = v308;
          v569 = (float *)v308;
          v571 = v311;
        }
        v312 = *(_DWORD *)v309;
        if (*(int *)v309 >= 1)
        {
          v313 = 0;
          do
          {
            v314 = *(int *)(*((_QWORD *)v307 + 21) + 4 * v313);
            if ((_DWORD)v314 != -1)
            {
              v315 = (unsigned int *)(*(_QWORD *)(*v310 + 24) + 8 * v313);
              v316 = *v315;
              if ((int)v316 >= 1)
              {
                v317 = v307;
                v318 = *(_DWORD *)(*(_QWORD *)(v544 + 96) + 4 * v314);
                v319 = v310[3] + 4 * (int)v315[1];
                v320 = v569;
                v321 = *v315;
                do
                {
                  *v320++ = 1.0 / (float)(int)v316;
                  --v321;
                }
                while (v321);
                v322 = 0;
                v323 = v318 + v12;
                v324 = 4 * v316;
                do
                {
                  v325 = v569[v322 / 4];
                  if (v325 != 0.0)
                    OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, *(_DWORD *)(v319 + v322) + v11, v323, v551, v325);
                  v322 += 4;
                }
                while (v324 != v322);
                v312 = *(_DWORD *)v309;
                v307 = v317;
              }
            }
            ++v313;
          }
          while (v313 < v312);
          v308 = __p;
          v306 = v503;
        }
        operator delete(v308);
        v3 = v495;
        v307 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(*((_QWORD *)v495 + 8) + 8 * v306);
      }
      v326 = 0;
      v327 = *((_QWORD *)v307 + 1);
      v328 = *(_QWORD *)(*((_QWORD *)v307 + 60) + 8 * v488);
      v329 = *(_QWORD **)(*(_QWORD *)(v327 + 456) + 8 * v488);
      v330 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(_QWORD *)(*((_QWORD *)v307 + 2) + 456) + 8 * v488);
      v545 = v327;
      v331 = *(unsigned int *)(v327 + 16);
      v569 = (float *)v572;
      v570 = v331;
      v571 = 8;
      v573 = 0;
      if (v331 >= 9)
      {
        v326 = operator new(4 * v331);
        v573 = v326;
        v569 = (float *)v326;
        v571 = v331;
      }
      if (*(int *)(v545 + 4) >= 1)
      {
        v522 = v330;
        v509 = v328;
        v332 = 0;
        v532 = v307;
        do
        {
          v333 = *(int *)(*((_QWORD *)v307 + 27) + 4 * v332);
          if ((_DWORD)v333 != -1)
          {
            v334 = (int *)(*((_QWORD *)v522 + 18) + 4 * *(int *)(*((_QWORD *)v522 + 12) + 4 * v333));
            if ((*(_BYTE *)(*((_QWORD *)v522 + 21) + *v334) & 1) != 0)
            {
              v336 = *((_QWORD *)v522 + 9);
              v337 = *(unsigned __int16 *)(v336 + 2 * v333);
              if (*(_WORD *)(v336 + 2 * v333))
              {
                v338 = 0;
                do
                {
                  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues(v329, v332, *(unsigned __int16 *)(*(_QWORD *)(v509 + 40)+ 2 * (v338 + *(int *)(*(_QWORD *)(*(_QWORD *)(v509 + 32) + 96) + 4 * v333))), (int *)&v564);
                  v339 = v334[v338] + v12;
                  OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, (_DWORD)v564 + v536, v339, v551, 0.5);
                  OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, HIDWORD(v564) + v536, v339, v551, 0.5);
                  ++v338;
                }
                while (v337 != v338);
              }
            }
            else
            {
              OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getEdgeFaceValues(v329, v332, 0, (int *)&v564);
              v335 = *v334 + v12;
              OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, (_DWORD)v564 + v536, v335, v551, 0.5);
              OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, HIDWORD(v564) + v536, v335, v551, 0.5);
            }
          }
          ++v332;
          v307 = v532;
        }
        while (v332 < *(int *)(v545 + 4));
        v326 = v573;
        v3 = v495;
        v11 = v536;
        v306 = v503;
      }
      operator delete(v326);
      v340 = *(_QWORD **)(*((_QWORD *)v3 + 8) + 8 * v306);
      v341 = v340[1];
      v510 = v340;
      v516 = (OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *)v341;
      v342 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)(v340[60] + 8 * v488);
      v498 = *(_QWORD **)(*(_QWORD *)(v340[2] + 456) + 8 * v488);
      v523 = *(OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel **)(*(_QWORD *)(v341 + 456) + 8 * v488);
      if (*((_BYTE *)v523 + 12))
        v343 = 1;
      else
        v343 = *v3 == 0;
      v344 = v343;
      v546 = v344;
      v345 = *(_DWORD *)(v341 + 20);
      v569 = (float *)v572;
      v570 = 2 * v345;
      v571 = 32;
      v575 = 0;
      if (2 * v345 >= 0x21)
      {
        v575 = operator new(8 * v345);
        v569 = (float *)v575;
        v571 = 2 * v345;
        v345 = *((_DWORD *)v516 + 5);
      }
      v165 = 0;
      v564 = (int *)&v566;
      v565 = v345 | 0x1000000000;
      v568 = 0;
      if (v345 >= 0x11)
      {
        v165 = operator new(4 * v345);
        v568 = v165;
        v564 = (int *)v165;
        HIDWORD(v565) = v345;
      }
      if (*((int *)v516 + 2) < 1)
        goto LABEL_511;
      v346 = 0;
      while (1)
      {
        v347 = *(int *)(v510[30] + 4 * v346);
        if ((_DWORD)v347 != -1)
        {
          v348 = *(int *)(*((_QWORD *)v523 + 12) + 4 * v346);
          v349 = (int *)(*((_QWORD *)v523 + 18) + 4 * v348);
          v350 = *(int *)(v498[12] + 4 * v347);
          v351 = (int *)(v498[18] + 4 * v350);
          v352 = *v351;
          v353 = v498[21];
          v354 = v546;
          if ((*(_BYTE *)(v353 + v352) & 1) != 0)
            v354 = 0;
          if (v354 == 1)
          {
            v355 = v352 + v550;
            v356 = *v349;
          }
          else
          {
            if ((*(_BYTE *)(v353 + v352) & 1) != 0)
            {
              v533 = (OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *)*(unsigned __int16 *)(v498[9] + 2 * v347);
              if (!*(_WORD *)(v498[9] + 2 * v347))
                goto LABEL_379;
              v357 = 0;
              v504 = (OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel *)(*((_QWORD *)v523 + 21) + v348);
              v358 = v353 + v350;
              v492 = v498[18] + 4 * v350;
              while (2)
              {
                v359 = *(unsigned __int16 *)(*((_QWORD *)v342 + 5)
                                           + 2 * (v357 + *(int *)(*(_QWORD *)(*((_QWORD *)v342 + 4) + 96) + 4 * v347)));
                v360 = v349[v359];
                v361 = v351[v357] + v550;
                if ((v546 & 1) != 0 || (*(_BYTE *)(v358 + v357) & 8) == 0)
                {
                  v362 = v360 + v536;
                  v363 = v551;
                  v364 = 1.0;
                  v365 = v351[v357] + v550;
                  goto LABEL_386;
                }
                OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::getVertexCreaseEndValues(v523, v346, *(unsigned __int16 *)(*((_QWORD *)v342 + 5)+ 2 * (v357 + *(int *)(*(_QWORD *)(*((_QWORD *)v342 + 4) + 96) + 4 * v347))), v554);
                if ((*((_BYTE *)v504 + v359) & 0x10) == 0)
                {
                  v366 = 0.75;
                  v367 = 0.125;
                  goto LABEL_395;
                }
                if ((*((_BYTE *)v504 + v359) & 0x20) != 0)
                {
                  v370 = v359 == 0;
                  v368 = v342;
                  v369 = v346;
                }
                else
                {
                  v368 = v342;
                  v369 = v346;
                  v370 = v359;
                }
                v371 = OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(v368, v369, v370, v347);
                v366 = v371 + (float)((float)(1.0 - v371) * 0.75);
                v367 = (float)(1.0 - v371) * 0.125;
                if (v367 != 0.0)
                {
LABEL_395:
                  OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v554[0] + v536, v361, v551, v367);
                  v351 = (int *)v492;
                  OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v554[1] + v536, v361, v551, v367);
                }
                if (v366 != 0.0)
                {
                  v362 = v360 + v536;
                  v363 = v551;
                  v365 = v361;
                  v364 = v366;
LABEL_386:
                  OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v363, v362, v365, v363, v364);
                }
                if (v533 == (OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *)++v357)
                  goto LABEL_379;
                continue;
              }
            }
            v356 = *v349;
            v355 = v352 + v550;
          }
          OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v356 + v536, v355, v551, 1.0);
        }
LABEL_379:
        if (++v346 >= *((int *)v516 + 2))
        {
          v165 = v568;
          v12 = v550;
          v11 = v536;
          goto LABEL_511;
        }
      }
    }
    v81 = *(_QWORD *)(*((_QWORD *)v3 + 8) + (((v526 << 32) - 0x100000000) >> 29));
    v82 = *(_QWORD *)(v81 + 8);
    if (*(int *)(v81 + 52) >= 1)
    {
      v83 = *(_DWORD *)v82;
      if (*(int *)v82 >= 1)
      {
        v84 = 0;
        do
        {
          v85 = *(_DWORD *)(*(_QWORD *)(v81 + 168) + 4 * v84);
          if (v85 != -1)
          {
            v86 = (unsigned int *)(*(_QWORD *)(v82 + 24) + 8 * v84);
            v87 = *v86;
            if ((int)v87 >= 1)
            {
              v88 = (_DWORD *)(*(_QWORD *)(v82 + 48) + 4 * (int)v86[1]);
              v89 = 1.0 / (float)(int)v87;
              v90 = v85 + v12;
              do
              {
                if (v89 != 0.0)
                  OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, *v88 + v11, v90, v551, v89);
                ++v88;
                --v87;
              }
              while (v87);
              v83 = *(_DWORD *)v82;
            }
          }
          ++v84;
        }
        while (v84 < v83);
      }
    }
    v91 = *(_DWORD *)(v82 + 4);
    if (v91 >= 1)
    {
      v92 = 0;
      for (jj = 0; jj < v91; ++jj)
      {
        v94 = *(_DWORD *)(*(_QWORD *)(v81 + 216) + 4 * jj);
        if (v94 != -1)
        {
          v95 = (_DWORD *)(*(_QWORD *)(v82 + 120) + v92);
          v96 = v94 + v12;
          OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, *v95 + v11, v94 + v12, v551, 0.5);
          OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v95[1] + v11, v96, v551, 0.5);
          v91 = *(_DWORD *)(v82 + 4);
        }
        v92 += 8;
      }
    }
    v97 = *(_DWORD *)(v82 + 8);
    if (v97 >= 1)
    {
      for (kk = 0; kk < v97; ++kk)
      {
        v99 = *(_DWORD *)(*(_QWORD *)(v81 + 240) + 4 * kk);
        if (v99 != -1)
        {
          OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v551, v11 + kk, v99 + v12, v551, 1.0);
          v97 = *(_DWORD *)(v82 + 8);
        }
      }
    }
LABEL_514:
    v14 = v486;
    if ((v486 & 0x20) != 0)
      v11 = v12;
    v3 = v495;
    v304 = *(_QWORD *)(*((_QWORD *)v495 + 11) + 24 * v526);
    v13 = v487;
    if (v487 == 2)
    {
      v476 = (_DWORD *)(*(_QWORD *)(*(_QWORD *)(v304 + 456) + 8 * v488) + 16);
      goto LABEL_519;
    }
LABEL_518:
    v476 = (_DWORD *)(v304 + 8);
LABEL_519:
    v12 += *v476;
    if ((v14 & 0x20) == 0)
      *((_DWORD *)v551 + 62) = v12;
    ++v526;
  }
  while (v526 != v485);
  v9 = v551;
LABEL_524:
  if ((v14 & 0x10) != 0)
    v477 = v482;
  else
    v477 = v11;
  v478 = v477;
  v479 = operator new();
  v480 = v14;
  v8 = v479;
  OpenSubdiv::v3_1_1::Far::StencilTable::StencilTable(v479, v482, (uint64_t *)v9 + 24, (_QWORD *)v9 + 27, (_QWORD *)v9 + 3, (_QWORD *)v9 + 6, (v480 >> 3) & 1, v478);
  OpenSubdiv::v3_1_1::Far::internal::StencilBuilder::~StencilBuilder(&v551);
  return v8;
}

uint64_t OpenSubdiv::v3_1_1::Far::StencilTableFactory::appendLocalPointStencilTable(OpenSubdiv::v3_1_1::Far::StencilTableFactory *this, const OpenSubdiv::v3_1_1::Far::TopologyRefiner *a2, const OpenSubdiv::v3_1_1::Far::StencilTable *a3, const OpenSubdiv::v3_1_1::Far::StencilTable *a4, int a5)
{
  uint64_t v5;
  unint64_t v7;
  uint64_t v10;
  int *v11;
  int v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  OpenSubdiv::v3_1_1::Far::internal::WeightTable *v22;
  OpenSubdiv::v3_1_1::Far::internal::WeightTable *v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float v34;
  int v35;
  int v36;
  uint64_t v37;
  unsigned int *v38;
  unsigned int *v39;
  uint64_t v40;
  int v41;
  char *v42;
  char *v43;
  char *v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  char *v48;
  int *v49;
  OpenSubdiv::v3_1_1::Far::internal::WeightTable *v50;
  uint64_t v51;
  unint64_t v52;
  int v53;
  uint64_t v54;
  int *v55;
  int *v56;
  uint64_t v57;
  int v58;
  int v59;
  int *v60;
  unint64_t v61;
  int v62;
  _DWORD *v63;
  uint64_t v64;
  int v65;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int *v73[3];
  OpenSubdiv::v3_1_1::Far::internal::WeightTable **v74;
  int v75;
  OpenSubdiv::v3_1_1::Far::internal::WeightTable *v76;

  v5 = 0;
  if (!a2 || !a3)
    return v5;
  v7 = *((_QWORD *)a3 + 3) - *((_QWORD *)a3 + 2);
  if ((v7 & 0x3FFFFFFFCLL) == 0)
    return 0;
  v10 = **((_QWORD **)this + 11);
  if ((a4 & 0x80000000) != 0)
    v11 = (int *)(v10 + 8);
  else
    v11 = (int *)(*(_QWORD *)(*(_QWORD *)(v10 + 456) + 8 * a4) + 16);
  v12 = *v11;
  v13 = (*((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2)) >> 2;
  if ((a4 & 0x80000000) != 0)
  {
    v16 = *((_DWORD *)this + 5);
  }
  else
  {
    v14 = (uint64_t *)*((_QWORD *)this + 5);
    v15 = *((_QWORD *)this + 6) - (_QWORD)v14;
    if ((int)((unint64_t)v15 >> 3) < 1)
    {
      v16 = 0;
    }
    else
    {
      v16 = 0;
      v17 = (int)(v15 >> 3);
      if (v17 <= 1)
        v17 = 1;
      do
      {
        v18 = *v14++;
        v16 += *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v18 + 456) + 8 * a4) + 16);
        --v17;
      }
      while (v17);
    }
  }
  v20 = *((_QWORD *)a2 + 8);
  v19 = *((_QWORD *)a2 + 9);
  if (v16 != (_DWORD)v13)
  {
    v21 = v12;
    if (v16 - v12 == (_DWORD)v13)
      goto LABEL_18;
    return 0;
  }
  v21 = 0;
LABEL_18:
  v71 = *((_QWORD *)a2 + 3) - *((_QWORD *)a2 + 2);
  v69 = v19 - v20;
  v67 = (unint64_t)(v19 - v20) >> 2;
  v22 = (OpenSubdiv::v3_1_1::Far::internal::WeightTable *)operator new();
  v70 = v12;
  v23 = OpenSubdiv::v3_1_1::Far::internal::WeightTable::WeightTable(v22, v12, 0, a5);
  v76 = v23;
  v24 = (v7 >> 2);
  v68 = v7 >> 2;
  if ((int)(v7 >> 2) < 1)
  {
    v26 = 0;
  }
  else
  {
    v25 = 0;
    v26 = 0;
    v72 = v24;
    do
    {
      v27 = *(int *)(*((_QWORD *)a3 + 5) + 4 * v25);
      v28 = *((_QWORD *)a3 + 2);
      v29 = *((_QWORD *)a3 + 8);
      v30 = *((_QWORD *)a3 + 11);
      v74 = &v76;
      v75 = v25;
      if (*(int *)(v28 + 4 * v25) >= 1)
      {
        v31 = 0;
        v32 = v29 + 4 * v27;
        v33 = v30 + 4 * v27;
        do
        {
          v34 = *(float *)(v33 + 4 * v31);
          if (v34 != 0.0)
          {
            v35 = *(_DWORD *)(v32 + 4 * v31);
            if (a5)
            {
              v36 = v35 - v21;
              v37 = *(int *)(*((_QWORD *)a2 + 5) + 4 * v36);
              v38 = (unsigned int *)(*((_QWORD *)a2 + 8) + 4 * v37);
              v39 = (unsigned int *)(*((_QWORD *)a2 + 11) + 4 * v37);
              v73[0] = (unsigned int *)(*((_QWORD *)a2 + 2) + 4 * v36);
              v73[1] = v38;
              v73[2] = v39;
              OpenSubdiv::v3_1_1::Far::internal::StencilBuilder::Index::AddWithWeight((_QWORD ***)&v74, v73, v34);
            }
            else
            {
              OpenSubdiv::v3_1_1::Far::internal::WeightTable::AddWithWeight<float,OpenSubdiv::v3_1_1::Far::internal::WeightTable::ScalarAccumulator>((uint64_t)v76, v35 + v21, v25, v76, v34);
            }
          }
          ++v31;
        }
        while (v31 < *(int *)(v28 + 4 * v25));
        v23 = v76;
        v24 = v72;
      }
      v40 = *((_QWORD *)v23 + 27);
      if (((*((_QWORD *)v23 + 28) - v40) >> 2) - 1 >= v25)
        v41 = *(_DWORD *)(v40 + 4 * v25);
      else
        v41 = 0;
      v26 += v41;
      ++v25;
    }
    while (v25 != v24);
  }
  v5 = operator new();
  *(_QWORD *)v5 = &off_24ED89DD0;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_OWORD *)(v5 + 48) = 0u;
  *(_OWORD *)(v5 + 80) = 0u;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 64) = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_DWORD *)(v5 + 8) = v70;
  std::vector<unsigned int>::resize((std::vector<int> *)(v5 + 16), (int)(((unint64_t)v71 >> 2) + v68));
  std::vector<unsigned int>::resize((std::vector<int> *)(v5 + 64), v26 + (int)v67);
  std::vector<float>::resize(v5 + 88, v26 + (int)v67);
  v42 = *(char **)(v5 + 16);
  v43 = *(char **)(v5 + 64);
  v44 = *(char **)(v5 + 88);
  v45 = (int)(v71 >> 2);
  memcpy(v42, *((const void **)a2 + 2), 4 * v45);
  memcpy(v43, *((const void **)a2 + 8), v69 << 30 >> 30);
  memcpy(v44, *((const void **)a2 + 11), v69 << 30 >> 30);
  if ((int)v68 >= 1)
  {
    v46 = 0;
    v47 = &v44[v69 << 30 >> 30];
    v48 = &v43[v69 << 30 >> 30];
    v49 = (int *)&v42[4 * v45];
    v50 = v76;
    v51 = *((_QWORD *)v76 + 27);
    v52 = ((*((_QWORD *)v76 + 28) - v51) >> 2) - 1;
    do
    {
      if (v52 >= v46)
      {
        v53 = *(_DWORD *)(v51 + 4 * v46);
        if (v53 >= 1)
        {
          v54 = *(int *)(*((_QWORD *)v50 + 24) + 4 * v46);
          v55 = (int *)(*((_QWORD *)v50 + 6) + 4 * v54);
          v56 = (int *)(*((_QWORD *)v50 + 3) + 4 * v54);
          v57 = *(unsigned int *)(v51 + 4 * v46);
          do
          {
            v58 = *v56++;
            *(_DWORD *)v48 = v58;
            v48 += 4;
            v59 = *v55++;
            *(_DWORD *)v47 = v59;
            v47 += 4;
            --v57;
          }
          while (v57);
        }
      }
      else
      {
        v53 = 0;
      }
      *v49++ = v53;
      ++v46;
    }
    while (v46 != v24);
  }
  std::vector<unsigned int>::resize((std::vector<int> *)(v5 + 40), (int)((uint64_t)(*(_QWORD *)(v5 + 24) - *(_QWORD *)(v5 + 16)) >> 2));
  v60 = *(int **)(v5 + 16);
  v61 = *(_QWORD *)(v5 + 24) - (_QWORD)v60;
  if ((int)(v61 >> 2) >= 1)
  {
    v62 = 0;
    v63 = *(_DWORD **)(v5 + 40);
    v64 = (v61 >> 2);
    do
    {
      *v63++ = v62;
      v65 = *v60++;
      v62 += v65;
      --v64;
    }
    while (v64);
  }
  OpenSubdiv::v3_1_1::Far::internal::StencilBuilder::~StencilBuilder(&v76);
  return v5;
}

_WORD *OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(_WORD *result, _QWORD *a2, int a3, uint64_t a4, int a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  float32x2_t *v28;
  float *v31;
  float v32;
  float v33;
  float v35;
  float *v36;
  float *v38;
  float v39;
  float v40;
  float v41;
  float v42;
  float *v43;
  float *v45;
  uint64_t v46;
  float v47;
  float v48;
  float32_t v49;
  float v50;
  float *v51;
  int v52;
  int v53;
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  if (a5 != 1)
  {
    if (a6)
    {
      if (a6 != 4)
        goto LABEL_14;
    }
    else if (a5 != 4)
    {
      v33 = *(float *)(a2[27] + 4 * a3);
      if (v33 < 1.0 && ((*(_DWORD *)result & 0x60) == 0 || (float)(v33 + -1.0) <= 0.0))
      {
LABEL_14:
        v19 = a2[18];
        v20 = *(unsigned int *)(v19 + 8 * a3);
        *(_QWORD *)(a4 + 24) = 2;
        *(_DWORD *)(a4 + 32) = v20;
        *(_BYTE *)(a4 + 36) = 1;
        v21 = *result & 0x180;
        if (v21 == 128)
        {
          if ((_DWORD)v20 == 2)
          {
            v22 = *(unsigned int *)(v19 + 8 * a3);
            if ((int)v22 <= 0)
              goto LABEL_51;
            v23 = 0;
            v24 = a2[21] + 4 * *(int *)(v19 + 4 * ((2 * a3) | 1));
            v25 = a2[3];
            v26 = 4 * v22;
            do
            {
              *(int *)((char *)&v52 + v23) = *(_DWORD *)(v25 + 8 * *(int *)(v24 + v23));
              v23 += 4;
            }
            while (v26 != v23);
            LOBYTE(v21) = v53 == 3;
            LOBYTE(v19) = v52 == 3;
            if (v52 == 3 || v53 == 3)
            {
LABEL_51:
              v47 = 0.47;
              if ((v21 & 1) != 0)
                v48 = 0.47;
              else
                v48 = 0.25;
              if ((v19 & 1) == 0)
                v47 = 0.25;
              v39 = (float)(v47 + v48) * 0.5;
              v49 = (float)((float)(v39 * -2.0) + 1.0) * 0.5;
              v28 = *(float32x2_t **)a4;
              v28->f32[0] = v49;
              v28->f32[1] = v49;
              v38 = *(float **)(a4 + 16);
              *v38 = v39;
              goto LABEL_57;
            }
            v28 = *(float32x2_t **)a4;
            __asm { FMOV            V0.2S, #0.25 }
            **(_QWORD **)a4 = _D0;
LABEL_37:
            v38 = *(float **)(a4 + 16);
            *v38 = 0.25;
            v39 = 0.25;
LABEL_57:
            v38[1] = v39;
LABEL_58:
            v50 = *(float *)(a2[27] + 4 * a3);
            *v28 = vmla_n_f32(vmul_n_f32(*v28, 1.0 - v50), (float32x2_t)0x3F0000003F000000, v50);
            if ((int)v20 >= 1)
            {
              v51 = *(float **)(a4 + 16);
              do
              {
                *v51 = (float)(1.0 - v50) * *v51;
                ++v51;
                --v20;
              }
              while (v20);
            }
            return result;
          }
          v28 = *(float32x2_t **)a4;
          __asm { FMOV            V0.2S, #0.25 }
          **(_QWORD **)a4 = _D0;
        }
        else
        {
          v28 = *(float32x2_t **)a4;
          __asm { FMOV            V0.2S, #0.25 }
          **(_QWORD **)a4 = _D0;
          if ((_DWORD)v20 == 2)
            goto LABEL_37;
        }
        if ((int)v20 >= 1)
        {
          v45 = *(float **)(a4 + 16);
          v46 = v20;
          do
          {
            *v45++ = 0.5 / (float)(int)v20;
            --v46;
          }
          while (v46);
        }
        goto LABEL_58;
      }
    }
    *(_DWORD *)(a4 + 24) = 2;
    *(_QWORD *)(a4 + 28) = 0;
    *(_BYTE *)(a4 + 36) = 0;
    v31 = *(float **)a4;
    **(_DWORD **)a4 = 1056964608;
    v32 = 0.5;
    goto LABEL_44;
  }
  v6 = a2[18];
  v7 = *(unsigned int *)(v6 + 8 * a3);
  *(_QWORD *)(a4 + 24) = 2;
  *(_DWORD *)(a4 + 32) = v7;
  *(_BYTE *)(a4 + 36) = 1;
  if ((*result & 0x180) == 0x80)
  {
    if ((_DWORD)v7 == 2)
    {
      v8 = 2 * a3;
      v9 = *(unsigned int *)(v6 + 8 * a3);
      if ((int)v9 <= 0)
        goto LABEL_38;
      v10 = 0;
      v11 = a2[21] + 4 * *(int *)(v6 + ((8 * a3) | 4));
      v12 = a2[3];
      v13 = 4 * v9;
      do
      {
        *(int *)((char *)&v52 + v10) = *(_DWORD *)(v12 + 8 * *(int *)(v11 + v10));
        v10 += 4;
      }
      while (v13 != v10);
      LOBYTE(v6) = v53 == 3;
      v8 = v52 == 3;
      if (v52 == 3 || v53 == 3)
      {
LABEL_38:
        v40 = 0.47;
        if ((v6 & 1) != 0)
          v41 = 0.47;
        else
          v41 = 0.25;
        if ((v8 & 1) == 0)
          v40 = 0.25;
        v32 = (float)(v40 + v41) * 0.5;
        v42 = (float)((float)(v32 * -2.0) + 1.0) * 0.5;
        v43 = *(float **)a4;
        *v43 = v42;
        v43[1] = v42;
        v31 = *(float **)(a4 + 16);
        *v31 = v32;
        goto LABEL_44;
      }
      __asm { FMOV            V0.2S, #0.25 }
      **(_QWORD **)a4 = _D0;
      goto LABEL_25;
    }
    __asm { FMOV            V0.2S, #0.25 }
    **(_QWORD **)a4 = _D0;
  }
  else
  {
    __asm { FMOV            V0.2S, #0.25 }
    **(_QWORD **)a4 = _D0;
    if ((_DWORD)v7 == 2)
    {
LABEL_25:
      v31 = *(float **)(a4 + 16);
      *v31 = 0.25;
      v32 = 0.25;
LABEL_44:
      v31[1] = v32;
      return result;
    }
  }
  if ((int)v7 >= 1)
  {
    v35 = 0.5 / (float)(int)v7;
    v36 = *(float **)(a4 + 16);
    do
    {
      *v36++ = v35;
      --v7;
    }
    while (v7);
  }
  return result;
}

void OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)1>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(int *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  unsigned int v7;
  uint64_t v8;
  float v9;
  float *v10;
  float *v11;
  int v12;
  BOOL v14;
  int v15;
  uint64_t v16;
  size_t v17;
  uint64_t v18;
  float *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  float *v26;
  uint64_t v27;
  uint64_t v28;
  float v29;
  unsigned int v30;
  float *v31;
  uint64_t v32;
  float v33;
  uint64_t v34;
  float v35;
  float *v36;
  float *v37;
  uint64_t v38;
  uint64_t v39;
  float *v40;
  float v41;
  uint64_t v42;
  float *v43;
  float v44;
  char *v45;
  _BYTE *v46;
  float *ChildSharpnessPerEdge;
  float v48;
  unsigned int v49;
  float *v50;
  uint64_t v51;
  float v52;
  uint64_t v53;
  float *v54;
  size_t v55;
  _DWORD *v56;
  uint64_t v57;
  float v58;
  float *v59;
  uint64_t v60;
  char v61;
  uint64_t v62;
  uint64_t v63;
  float *v64;
  float v65;
  uint64_t v66;
  float *v67;
  float v68;
  uint64_t v69;
  float v70;
  float v71;
  float *v72;
  uint64_t v73;
  float *v74;
  float v75;
  float *v76;
  uint64_t v77;
  float *v78;
  float v79;
  float *v80;
  float *v81;
  uint64_t v82;
  float v83;
  float *v84;
  uint64_t v85;
  float v86;
  _BYTE v87[4];
  int v88;
  uint64_t v89;
  int v90;
  uint64_t v91;

  v91 = *MEMORY[0x24BDAC8D0];
  v7 = a4 - 1;
  if ((a4 - 1) <= 1)
  {
    v8 = *(unsigned int *)(a2 + 28);
    *(_DWORD *)(a3 + 24) = 1;
    *(_DWORD *)(a3 + 28) = v8;
    *(_DWORD *)(a3 + 32) = v8;
    *(_BYTE *)(a3 + 36) = 1;
    **(float **)a3 = (float)(v8 - 2) / (float)(int)v8;
    if ((int)v8 >= 1)
    {
      v9 = 1.0 / (float)(v8 * v8);
      v10 = *(float **)(a3 + 8);
      v11 = *(float **)(a3 + 16);
      do
      {
        *v10++ = v9;
        *v11++ = v9;
        --v8;
      }
      while (v8);
    }
    return;
  }
  v12 = a4;
  if (a5)
    v14 = 1;
  else
    v14 = a4 == 0;
  if (v14)
    v15 = a5;
  else
    v15 = a4;
  v16 = *(unsigned int *)(a2 + 24);
  v17 = 4 * (int)v16;
  MEMORY[0x24BDAC7A8](a1);
  v19 = (float *)&v87[-v18];
  bzero(&v87[-v18], v17);
  if ((v12 | 4) != 4 && v15 == v12)
  {
    v19 = 0;
    v29 = 0.0;
LABEL_37:
    v38 = (int)v16;
    if (v12 == 4)
    {
      v88 = v15;
      v39 = 0xFFFFFFFF00000000;
      v40 = v19;
      do
      {
        v41 = *v40++;
        v39 += 0x100000000;
      }
      while (v41 <= 0.0);
      v42 = (uint64_t)(int)v16 << 32;
      v89 = (int)v16;
      v43 = &v19[(int)v16 - 1];
      do
      {
        v44 = *v43--;
        v42 -= 0x100000000;
      }
      while (v44 <= 0.0);
      *(_DWORD *)(a3 + 24) = 1;
      *(_DWORD *)(a3 + 28) = v16;
      *(_DWORD *)(a3 + 32) = 0;
      *(_BYTE *)(a3 + 36) = 0;
      v45 = *(char **)(a3 + 8);
      **(_DWORD **)a3 = 1061158912;
      if ((int)v16 >= 1)
        bzero(v45, 4 * v16);
      *(_DWORD *)&v45[v39 >> 30] = 1040187392;
      *(_DWORD *)&v45[v42 >> 30] = 1040187392;
      v38 = v89;
      v15 = v88;
    }
    else
    {
      *(_DWORD *)(a3 + 24) = 1;
      *(_QWORD *)(a3 + 28) = 0;
      *(_BYTE *)(a3 + 36) = 0;
      **(_DWORD **)a3 = 1065353216;
    }
    if (v15 != v12)
    {
      v90 = *a1;
      MEMORY[0x24BDAC7A8](v20);
      v46 = &v87[-((v17 + 15) & 0xFFFFFFFFFFFFFFF0)];
      bzero(v46, 4 * (int)v16);
      ChildSharpnessPerEdge = OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface::GetChildSharpnessPerEdge((OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface *)a2, (const OpenSubdiv::v3_1_1::Sdc::Crease *)&v90, (float *)v46);
      v48 = *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 408) + 4 * *(int *)(a2 + 20));
      if (v15)
        goto LABEL_60;
      if (v48 <= 0.0)
      {
        if ((int)v16 < 1)
        {
          v15 = 1;
        }
        else
        {
          v49 = 0;
          v50 = (float *)&v87[-((v17 + 15) & 0xFFFFFFFFFFFFFFF0)];
          v51 = v16;
          do
          {
            v52 = *v50++;
            if (v52 > 0.0)
              ++v49;
            --v51;
          }
          while (v51);
          v15 = v49 <= 2 ? 1 << v49 : 8;
        }
      }
      else
      {
        v15 = 8;
      }
      if (v15 != v12)
      {
LABEL_60:
        MEMORY[0x24BDAC7A8](ChildSharpnessPerEdge);
        v54 = (float *)&v87[-v53];
        bzero(&v87[-v53], v55);
        v56 = v54 + 1;
        if ((v15 - 1) > 1)
        {
          if (v15 == 4)
          {
            v89 = v38;
            v63 = 0xFFFFFFFF00000000;
            v64 = (float *)v46;
            do
            {
              v65 = *v64++;
              v63 += 0x100000000;
            }
            while (v65 <= 0.0);
            v66 = v89 << 32;
            v67 = (float *)&v46[4 * v89 - 4];
            do
            {
              v68 = *v67--;
              v66 -= 0x100000000;
            }
            while (v68 <= 0.0);
            v62 = *(unsigned int *)(a2 + 24);
            *v54 = 0.75;
            if ((int)v62 >= 1)
              bzero(v54 + 1, 4 * v62);
            LODWORD(v57) = 0;
            *(_DWORD *)((char *)v56 + (v63 >> 30)) = 1040187392;
            v69 = v66 >> 30;
            v61 = 0;
            *(_DWORD *)((char *)v56 + v69) = 1040187392;
            v38 = v89;
          }
          else
          {
            v61 = 0;
            LODWORD(v57) = 0;
            LODWORD(v62) = 0;
            *v54 = 1.0;
          }
        }
        else
        {
          v57 = *(unsigned int *)(a2 + 28);
          *v54 = (float)(v57 - 2) / (float)(int)v57;
          if ((int)v57 >= 1)
          {
            v58 = 1.0 / (float)(v57 * v57);
            v59 = v54 + 1;
            v60 = v57;
            do
            {
              *v59 = v58;
              v59[v38] = v58;
              ++v59;
              --v60;
            }
            while (v60);
          }
          v61 = 1;
          LODWORD(v62) = v57;
        }
        v70 = OpenSubdiv::v3_1_1::Sdc::Crease::ComputeFractionalWeightAtVertex((OpenSubdiv::v3_1_1::Sdc::Crease *)&v90, v29, v48, v16, v19, (const float *)v46);
        v71 = 1.0 - v70;
        **(float **)a3 = (float)((float)(1.0 - v70) * *v54) + (float)(v70 * **(float **)a3);
        if ((_DWORD)v62)
        {
          if (*(_DWORD *)(a3 + 28))
          {
            if ((int)v62 >= 1)
            {
              v72 = *(float **)(a3 + 8);
              v73 = v62;
              v74 = v54 + 1;
              do
              {
                v75 = *v74++;
                *v72 = (float)(v71 * v75) + (float)(v70 * *v72);
                ++v72;
                --v73;
              }
              while (v73);
            }
          }
          else
          {
            *(_DWORD *)(a3 + 28) = v62;
            if ((int)v62 >= 1)
            {
              v76 = *(float **)(a3 + 8);
              v77 = v62;
              v78 = v54 + 1;
              do
              {
                v79 = *v78++;
                *v76++ = v71 * v79;
                --v77;
              }
              while (v77);
            }
          }
        }
        if ((_DWORD)v57)
        {
          v80 = (float *)&v56[v38];
          if (*(_DWORD *)(a3 + 32))
          {
            if ((int)v57 >= 1)
            {
              v81 = *(float **)(a3 + 16);
              v82 = v57;
              do
              {
                v83 = *v80++;
                *v81 = (float)(v71 * v83) + (float)(v70 * *v81);
                ++v81;
                --v82;
              }
              while (v82);
            }
          }
          else
          {
            *(_DWORD *)(a3 + 32) = v57;
            *(_BYTE *)(a3 + 36) = v61;
            if ((int)v57 >= 1)
            {
              v84 = *(float **)(a3 + 16);
              v85 = v57;
              do
              {
                v86 = *v80++;
                *v84++ = v71 * v86;
                --v85;
              }
              while (v85);
            }
          }
        }
      }
    }
    return;
  }
  v21 = *(_QWORD **)a2;
  v22 = *(int *)(a2 + 16);
  v23 = *(_QWORD *)(*(_QWORD *)a2 + 408);
  if ((int)v16 >= 1)
  {
    v24 = (int *)(v21[45] + 4 * *(int *)(v21[42] + 8 * v22 + 4));
    v25 = v21[27];
    v26 = v19;
    v27 = v16;
    do
    {
      v28 = *v24++;
      *v26++ = *(float *)(v25 + 4 * v28);
      --v27;
    }
    while (v27);
  }
  v29 = *(float *)(v23 + 4 * v22);
  if (!v12)
  {
    if (v29 <= 0.0)
      v12 = 1;
    else
      v12 = 8;
    if ((int)v16 >= 1 && v29 <= 0.0)
    {
      v30 = 0;
      v31 = v19;
      v32 = v16;
      do
      {
        v33 = *v31++;
        if (v33 > 0.0)
          ++v30;
        --v32;
      }
      while (v32);
      if (v30 <= 2)
        v12 = 1 << v30;
      else
        v12 = 8;
    }
    v7 = v12 - 1;
  }
  if (v7 > 1)
    goto LABEL_37;
  v34 = *(unsigned int *)(a2 + 28);
  *(_DWORD *)(a3 + 24) = 1;
  *(_DWORD *)(a3 + 28) = v34;
  *(_DWORD *)(a3 + 32) = v34;
  *(_BYTE *)(a3 + 36) = 1;
  **(float **)a3 = (float)(v34 - 2) / (float)(int)v34;
  if ((int)v34 >= 1)
  {
    v35 = 1.0 / (float)(v34 * v34);
    v36 = *(float **)(a3 + 8);
    v37 = *(float **)(a3 + 16);
    do
    {
      *v36++ = v35;
      *v37++ = v35;
      --v34;
    }
    while (v34);
  }
}

float *OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface::GetChildSharpnessPerEdge(OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface *this, const OpenSubdiv::v3_1_1::Sdc::Crease *a2, float *a3)
{
  uint64_t v6;
  float *v7;
  float *v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  uint64_t v13;
  uint64_t v15;
  float *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v6 = *((unsigned int *)this + 6);
  v7 = (float *)&v15;
  v16 = 0;
  if (v6 < 0x11)
  {
    v8 = 0;
  }
  else
  {
    v8 = (float *)operator new(4 * v6);
    v16 = v8;
    LODWORD(v6) = *((_DWORD *)this + 6);
    v7 = v8;
  }
  if ((int)v6 >= 1)
  {
    v9 = (int *)(*(_QWORD *)(*(_QWORD *)this + 360)
               + 4 * *(int *)(*(_QWORD *)(*(_QWORD *)this + 336) + 8 * *((int *)this + 4) + 4));
    v10 = *(_QWORD *)(*(_QWORD *)this + 216);
    v11 = v6;
    v12 = v7;
    do
    {
      v13 = *v9++;
      *v12++ = *(float *)(v10 + 4 * v13);
      --v11;
    }
    while (v11);
  }
  OpenSubdiv::v3_1_1::Sdc::Crease::SubdivideEdgeSharpnessesAroundVertex(a2, v6, v7, a3);
  operator delete(v8);
  return a3;
}

uint64_t OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeEdgeVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::EdgeInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(uint64_t result, uint64_t a2, int a3, uint64_t a4, int a5, int a6)
{
  uint64_t v6;
  float32x2_t *v12;
  float v13;
  uint64_t v14;
  float32x2_t *v15;
  float v17;
  float *v18;
  float v19;
  float *v20;
  uint64_t v21;
  float v22;
  float *v23;

  if (a5 != 1)
  {
    if (a6)
    {
      if (a6 != 4)
      {
LABEL_6:
        v14 = *(unsigned int *)(*(_QWORD *)(a2 + 144) + 8 * a3);
        *(_QWORD *)(a4 + 24) = 2;
        *(_DWORD *)(a4 + 32) = v14;
        *(_BYTE *)(a4 + 36) = 0;
        v15 = *(float32x2_t **)a4;
        __asm { FMOV            V0.2S, #0.375 }
        **(_QWORD **)a4 = _D0;
        if ((_DWORD)v14 == 2)
        {
          **(_QWORD **)(a4 + 16) = 0x3E0000003E000000;
        }
        else if ((int)v14 >= 1)
        {
          v20 = *(float **)(a4 + 16);
          v21 = v14;
          do
          {
            *v20++ = (float)(2.0 / (float)(int)v14) * 0.125;
            --v21;
          }
          while (v21);
        }
        v22 = *(float *)(*(_QWORD *)(a2 + 216) + 4 * a3);
        *v15 = vmla_n_f32(vmul_n_f32(*v15, 1.0 - v22), (float32x2_t)0x3F0000003F000000, v22);
        if ((int)v14 >= 1)
        {
          v23 = *(float **)(a4 + 16);
          do
          {
            *v23 = (float)(1.0 - v22) * *v23;
            ++v23;
            --v14;
          }
          while (v14);
        }
        return result;
      }
    }
    else if (a5 != 4)
    {
      v19 = *(float *)(*(_QWORD *)(a2 + 216) + 4 * a3);
      if (v19 < 1.0 && ((result & 0x60) == 0 || (float)(v19 + -1.0) <= 0.0))
        goto LABEL_6;
    }
    *(_DWORD *)(a4 + 24) = 2;
    *(_QWORD *)(a4 + 28) = 0;
    *(_BYTE *)(a4 + 36) = 0;
    v12 = *(float32x2_t **)a4;
    **(_DWORD **)a4 = 1056964608;
    v13 = 0.5;
    goto LABEL_17;
  }
  v6 = *(unsigned int *)(*(_QWORD *)(a2 + 144) + 8 * a3);
  *(_QWORD *)(a4 + 24) = 2;
  *(_DWORD *)(a4 + 32) = v6;
  *(_BYTE *)(a4 + 36) = 0;
  __asm { FMOV            V0.2S, #0.375 }
  **(_QWORD **)a4 = _D0;
  if ((_DWORD)v6 == 2)
  {
    v12 = *(float32x2_t **)(a4 + 16);
    v12->i32[0] = 1040187392;
    v13 = 0.125;
LABEL_17:
    v12->f32[1] = v13;
    return result;
  }
  if ((int)v6 >= 1)
  {
    v17 = (float)(2.0 / (float)(int)v6) * 0.125;
    v18 = *(float **)(a4 + 16);
    do
    {
      *v18++ = v17;
      --v6;
    }
    while (v6);
  }
  return result;
}

void OpenSubdiv::v3_1_1::Sdc::Scheme<(OpenSubdiv::v3_1_1::Sdc::SchemeType)2>::ComputeVertexVertexMask<OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface,OpenSubdiv::v3_1_1::Far::PrimvarRefiner::Mask>(int *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  unsigned int v7;
  uint64_t v8;
  float v9;
  int v10;
  BOOL v12;
  int v13;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  float *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  int *v22;
  uint64_t v23;
  float *v24;
  uint64_t v25;
  uint64_t v26;
  float v27;
  unsigned int v28;
  float *v29;
  uint64_t v30;
  float v31;
  uint64_t v32;
  float v33;
  float v34;
  float v35;
  float *v36;
  uint64_t v37;
  uint64_t v38;
  float *v39;
  float v40;
  uint64_t v41;
  float *v42;
  float v43;
  char *v44;
  char *v45;
  float *ChildSharpnessPerEdge;
  float v47;
  float v48;
  float v49;
  float *v50;
  unsigned int v51;
  float *v52;
  uint64_t v53;
  float v54;
  uint64_t v55;
  float *v56;
  size_t v57;
  float *v58;
  uint64_t v59;
  float v60;
  float v61;
  uint64_t v62;
  uint64_t v63;
  float *v64;
  float v65;
  uint64_t v66;
  float *v67;
  float v68;
  float v69;
  float v70;
  float *v71;
  uint64_t v72;
  float v73;
  float v74;
  float *v75;
  uint64_t v76;
  float v77;
  float *v78;
  uint64_t v79;
  float v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  int v84;
  uint64_t v85;

  v85 = *MEMORY[0x24BDAC8D0];
  v7 = a4 - 1;
  if ((a4 - 1) <= 1)
  {
    v8 = *(unsigned int *)(a2 + 28);
    *(_DWORD *)(a3 + 24) = 1;
    *(_QWORD *)(a3 + 28) = v8;
    *(_BYTE *)(a3 + 36) = 0;
    if ((_DWORD)v8 == 6)
    {
      **(_DWORD **)a3 = 1059061760;
      v9 = 0.0625;
    }
    else
    {
      v34 = 1.0 / (float)(int)v8;
      v35 = cosf(v34 * 6.2832);
      v9 = v34 * (float)(0.625 - (float)((float)((float)(v35 * 0.25) + 0.375) * (float)((float)(v35 * 0.25) + 0.375)));
      **(float **)a3 = 1.0 - (float)(v9 * (float)(int)v8);
      if ((int)v8 < 1)
        return;
    }
    v36 = *(float **)(a3 + 8);
    do
    {
      *v36++ = v9;
      --v8;
    }
    while (v8);
    return;
  }
  v10 = a4;
  if (a5)
    v12 = 1;
  else
    v12 = a4 == 0;
  if (v12)
    v13 = a5;
  else
    v13 = a4;
  v14 = *(unsigned int *)(a2 + 24);
  v15 = 4 * (int)v14;
  MEMORY[0x24BDAC7A8](a1);
  v17 = (float *)((char *)&v81 - v16);
  bzero((char *)&v81 - v16, v15);
  if ((v10 | 4) != 4 && v13 == v10)
  {
    v17 = 0;
    v27 = 0.0;
    goto LABEL_37;
  }
  v19 = *(_QWORD **)a2;
  v20 = *(int *)(a2 + 16);
  v21 = *(_QWORD *)(*(_QWORD *)a2 + 408);
  if ((int)v14 >= 1)
  {
    v22 = (int *)(v19[45] + 4 * *(int *)(v19[42] + 8 * v20 + 4));
    v23 = v19[27];
    v24 = v17;
    v25 = v14;
    do
    {
      v26 = *v22++;
      *v24++ = *(float *)(v23 + 4 * v26);
      --v25;
    }
    while (v25);
  }
  v27 = *(float *)(v21 + 4 * v20);
  if (!v10)
  {
    if (v27 <= 0.0)
      v10 = 1;
    else
      v10 = 8;
    if ((int)v14 >= 1 && v27 <= 0.0)
    {
      v28 = 0;
      v29 = v17;
      v30 = v14;
      do
      {
        v31 = *v29++;
        if (v31 > 0.0)
          ++v28;
        --v30;
      }
      while (v30);
      if (v28 <= 2)
        v10 = 1 << v28;
      else
        v10 = 8;
    }
    v7 = v10 - 1;
  }
  if (v7 > 1)
  {
LABEL_37:
    v37 = (int)v14;
    if (v10 == 4)
    {
      v83 = v13;
      v38 = 0xFFFFFFFF00000000;
      v39 = v17;
      do
      {
        v40 = *v39++;
        v38 += 0x100000000;
      }
      while (v40 <= 0.0);
      v41 = (uint64_t)(int)v14 << 32;
      v82 = (int)v14;
      v42 = &v17[(int)v14 - 1];
      do
      {
        v43 = *v42--;
        v41 -= 0x100000000;
      }
      while (v43 <= 0.0);
      *(_DWORD *)(a3 + 24) = 1;
      *(_DWORD *)(a3 + 28) = v14;
      *(_DWORD *)(a3 + 32) = 0;
      *(_BYTE *)(a3 + 36) = 0;
      v44 = *(char **)(a3 + 8);
      **(_DWORD **)a3 = 1061158912;
      if ((int)v14 >= 1)
        bzero(v44, 4 * v14);
      *(_DWORD *)&v44[v38 >> 30] = 1040187392;
      *(_DWORD *)&v44[v41 >> 30] = 1040187392;
      v13 = v83;
      v37 = v82;
    }
    else
    {
      *(_DWORD *)(a3 + 24) = 1;
      *(_QWORD *)(a3 + 28) = 0;
      *(_BYTE *)(a3 + 36) = 0;
      **(_DWORD **)a3 = 1065353216;
    }
    if (v13 == v10)
      return;
    v84 = *a1;
    MEMORY[0x24BDAC7A8](v18);
    v45 = (char *)&v81 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v45, 4 * (int)v14);
    ChildSharpnessPerEdge = OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface::GetChildSharpnessPerEdge((OpenSubdiv::v3_1_1::Vtr::internal::VertexInterface *)a2, (const OpenSubdiv::v3_1_1::Sdc::Crease *)&v84, (float *)v45);
    v47 = *(float *)(*(_QWORD *)(*(_QWORD *)(a2 + 8) + 408) + 4 * *(int *)(a2 + 20));
    if (!v13)
    {
      if (v47 <= 0.0)
      {
        if ((int)v14 < 1)
        {
          v13 = 1;
        }
        else
        {
          v51 = 0;
          v52 = (float *)((char *)&v81 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0));
          v53 = v14;
          do
          {
            v54 = *v52++;
            if (v54 > 0.0)
              ++v51;
            --v53;
          }
          while (v53);
          v13 = v51 <= 2 ? 1 << v51 : 8;
        }
      }
      else
      {
        v13 = 8;
      }
      if (v13 == v10)
        return;
    }
    MEMORY[0x24BDAC7A8](ChildSharpnessPerEdge);
    v56 = (float *)((char *)&v81 - v55);
    bzero((char *)&v81 - v55, v57);
    v58 = v56 + 1;
    if ((v13 - 1) > 1)
    {
      if (v13 == 4)
      {
        v62 = v37;
        v63 = 0xFFFFFFFF00000000;
        v64 = (float *)v45;
        do
        {
          v65 = *v64++;
          v63 += 0x100000000;
        }
        while (v65 <= 0.0);
        v66 = v62 << 32;
        v67 = (float *)&v45[4 * v62 - 4];
        do
        {
          v68 = *v67--;
          v66 -= 0x100000000;
        }
        while (v68 <= 0.0);
        v59 = *(unsigned int *)(a2 + 24);
        *v56 = 0.75;
        if ((int)v59 >= 1)
          bzero(v56 + 1, 4 * v59);
        *(float *)((char *)v58 + (v63 >> 30)) = 0.125;
        *(float *)((char *)v58 + (v66 >> 30)) = 0.125;
        v60 = *v56;
      }
      else
      {
        LODWORD(v59) = 0;
        v60 = 1.0;
      }
      goto LABEL_80;
    }
    v59 = *(unsigned int *)(a2 + 28);
    if ((_DWORD)v59 == 6)
    {
      v60 = 0.625;
      v61 = 0.0625;
    }
    else
    {
      v69 = 1.0 / (float)(int)v59;
      v70 = cosf(v69 * 6.2832);
      v61 = v69 * (float)(0.625 - (float)((float)((float)(v70 * 0.25) + 0.375) * (float)((float)(v70 * 0.25) + 0.375)));
      v60 = 1.0 - (float)(v61 * (float)(int)v59);
      if ((int)v59 < 1)
        goto LABEL_80;
    }
    v71 = v56 + 1;
    v72 = v59;
    do
    {
      *v71++ = v61;
      --v72;
    }
    while (v72);
LABEL_80:
    v73 = OpenSubdiv::v3_1_1::Sdc::Crease::ComputeFractionalWeightAtVertex((OpenSubdiv::v3_1_1::Sdc::Crease *)&v84, v27, v47, v14, v17, (const float *)v45);
    v74 = 1.0 - v73;
    **(float **)a3 = (float)((float)(1.0 - v73) * v60) + (float)(v73 * **(float **)a3);
    if ((_DWORD)v59)
    {
      if (*(_DWORD *)(a3 + 28))
      {
        if ((int)v59 >= 1)
        {
          v75 = *(float **)(a3 + 8);
          v76 = v59;
          do
          {
            v77 = *v58++;
            *v75 = (float)(v74 * v77) + (float)(v73 * *v75);
            ++v75;
            --v76;
          }
          while (v76);
        }
      }
      else
      {
        *(_DWORD *)(a3 + 28) = v59;
        if ((int)v59 >= 1)
        {
          v78 = *(float **)(a3 + 8);
          v79 = v59;
          do
          {
            v80 = *v58++;
            *v78++ = v74 * v80;
            --v79;
          }
          while (v79);
        }
      }
    }
    return;
  }
  v32 = *(unsigned int *)(a2 + 28);
  *(_DWORD *)(a3 + 24) = 1;
  *(_QWORD *)(a3 + 28) = v32;
  *(_BYTE *)(a3 + 36) = 0;
  if ((_DWORD)v32 == 6)
  {
    **(_DWORD **)a3 = 1059061760;
    v33 = 0.0625;
  }
  else
  {
    v48 = 1.0 / (float)(int)v32;
    v49 = cosf(v48 * 6.2832);
    v33 = v48 * (float)(0.625 - (float)((float)((float)(v49 * 0.25) + 0.375) * (float)((float)(v49 * 0.25) + 0.375)));
    **(float **)a3 = 1.0 - (float)(v33 * (float)(int)v32);
    if ((int)v32 < 1)
      return;
  }
  v50 = *(float **)(a3 + 8);
  do
  {
    *v50++ = v33;
    --v32;
  }
  while (v32);
}

uint64_t OpenSubdiv::v3_1_1::Far::GregoryBasis::ProtoBasis::ProtoBasis(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  OpenSubdiv::v3_1_1::Vtr::internal::Level *v20;
  uint64_t v21;
  _QWORD *v22;
  unsigned int v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  unsigned __int16 *v27;
  int v28;
  uint64_t *v29;
  int v30;
  char v31;
  int v32;
  int v33;
  float v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  int v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t i;
  void **v48;
  uint64_t j;
  void **v50;
  _QWORD *v51;
  uint64_t v52;
  unsigned int v53;
  _QWORD *v54;
  uint64_t v55;
  OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v60;
  float v61;
  float v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  int *v68;
  int v69;
  int v70;
  uint64_t v71;
  int v72;
  int v73;
  int v74;
  int **v75;
  int v76;
  int v77;
  void **v78;
  float v79;
  float v80;
  __float2 v81;
  float v82;
  float v83;
  void **v84;
  unint64_t v85;
  int v86;
  float v87;
  float v88;
  float v89;
  int *v90;
  int v91;
  uint64_t v92;
  OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v93;
  float *v94;
  float v95;
  float v96;
  float v97;
  float v98;
  void **v99;
  void **v100;
  uint64_t v101;
  uint64_t v102;
  float v103;
  int v104;
  float v105;
  int v106;
  __float2 v107;
  const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v108;
  unint64_t v109;
  uint64_t v110;
  char *v111;
  uint64_t v112;
  char v113;
  int v114;
  float v115;
  float v116;
  float v117;
  int *v118;
  __float2 v119;
  int *v120;
  __float2 v121;
  unint64_t v122;
  void **v123;
  uint64_t v124;
  uint64_t v125;
  float v126;
  void **v127;
  uint64_t v128;
  uint64_t v129;
  int v130;
  const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v131;
  const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v132;
  float v133;
  float v134;
  float v135;
  float v136;
  float v137;
  float v138;
  float v139;
  int v140;
  void **v141;
  const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v142;
  float v143;
  float v144;
  uint64_t v145;
  float v146;
  const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v147;
  void **v148;
  float v149;
  float v150;
  const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v151;
  char *v152;
  uint64_t v153;
  const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v154;
  uint64_t k;
  uint64_t v156;
  _DWORD *v157;
  uint64_t v158;
  _DWORD *v159;
  uint64_t v160;
  _DWORD *v161;
  uint64_t v162;
  _DWORD *v163;
  uint64_t v164;
  _DWORD *v165;
  unint64_t v166;
  uint64_t v167;
  _BYTE *v168;
  _QWORD *v169;
  unint64_t v170;
  uint64_t v171;
  _BYTE *v172;
  _QWORD *v173;
  unint64_t v174;
  uint64_t v175;
  uint64_t v176;
  char *v177;
  uint64_t v179;
  void **v180;
  int v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  unsigned int v186;
  OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v187;
  OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v188;
  OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v189;
  OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v190;
  OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v191;
  OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v192;
  int v193;
  OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *v194;
  uint64_t v195;
  int v196;
  int v197[2];
  _BYTE v198[4];
  _BYTE *v199;
  unsigned int v200;
  int v201;
  _BYTE v202[14080];
  void *v203;
  _BYTE *v204;
  unsigned int v205;
  int v206;
  _BYTE v207[3520];
  void *v208[361];
  _BYTE *v209;
  unsigned int v210;
  unsigned int v211;
  _BYTE v212[160];
  void *v213;
  _BYTE *v214;
  unsigned int v215;
  unsigned int v216;
  _BYTE v217[160];
  void *v218;
  _BYTE *v219;
  unsigned int v220;
  unsigned int v221;
  _BYTE v222[160];
  void *v223;
  _BYTE *v224;
  unsigned int v225;
  unsigned int v226;
  _BYTE v227[160];
  void *v228;
  uint64_t v229;

  v1 = MEMORY[0x24BDAC7A8](a1);
  v182 = v6;
  v7 = 0;
  v229 = *MEMORY[0x24BDAC8D0];
  do
  {
    v8 = v1 + v7;
    *(_DWORD *)v8 = 0;
    *(_QWORD *)(v8 + 8) = v1 + v7 + 24;
    *(_QWORD *)(v8 + 344) = 0;
    *(_QWORD *)(v8 + 16) = 0x2800000028;
    v7 += 352;
  }
  while (v7 != 1408);
  do
  {
    v9 = v1 + v7;
    *(_DWORD *)v9 = 0;
    *(_QWORD *)(v9 + 8) = v1 + v7 + 24;
    *(_QWORD *)(v9 + 344) = 0;
    *(_QWORD *)(v9 + 16) = 0x2800000028;
    v7 += 352;
  }
  while (v9 + 352 != v1 + 2816);
  v10 = 2816;
  do
  {
    v11 = v1 + v10;
    *(_DWORD *)v11 = 0;
    *(_QWORD *)(v11 + 8) = v1 + v10 + 24;
    *(_QWORD *)(v11 + 344) = 0;
    *(_QWORD *)(v11 + 16) = 0x2800000028;
    v10 += 352;
  }
  while (v11 + 352 != v1 + 4224);
  v12 = 4224;
  do
  {
    v13 = v1 + v12;
    *(_DWORD *)v13 = 0;
    *(_QWORD *)(v13 + 8) = v1 + v12 + 24;
    *(_QWORD *)(v13 + 344) = 0;
    *(_QWORD *)(v13 + 16) = 0x2800000028;
    v12 += 352;
  }
  while (v13 + 352 != v1 + 5632);
  v181 = v4;
  v14 = 5632;
  do
  {
    v15 = v1 + v14;
    *(_DWORD *)v15 = 0;
    *(_QWORD *)(v15 + 8) = v1 + v14 + 24;
    *(_QWORD *)(v15 + 344) = 0;
    *(_QWORD *)(v15 + 16) = 0x2800000028;
    v14 += 352;
  }
  while (v15 + 352 != v1 + 7040);
  v16 = (2 * v3) | 1;
  v17 = *(_QWORD *)(v2 + 48) + 4 * *(int *)(*(_QWORD *)(v2 + 24) + 4 * v16);
  v183 = v17;
  if ((v5 & 0x80000000) == 0)
  {
    v18 = *(_QWORD **)(*(_QWORD *)(v2 + 456) + 8 * v5);
    v183 = v18[3] + 4 * *(int *)(*(_QWORD *)(*v18 + 24) + 4 * v16);
  }
  v19 = 0;
  v20 = (OpenSubdiv::v3_1_1::Vtr::internal::Level *)v2;
  v21 = *(int *)(v2 + 20);
  do
  {
    v22 = &(&v209)[v19];
    *v22 = &v212[v19 * 8];
    v22[1] = 0x2800000000;
    v22[22] = 0;
    v19 += 23;
  }
  while (v19 != 92);
  v23 = v5;
  v24 = v21 + ((v5 & 0x80000000) == 0);
  v25 = 2 * v24;
  v184 = v1;
  v179 = v24;
  v180 = (void **)(v1 + 2816);
  if ((_DWORD)v24)
  {
    if (v211 < v25)
    {
      operator delete(v213);
      v209 = v212;
      v211 = 40;
      v213 = operator new(4 * v25);
      v209 = v213;
      v211 = v25;
    }
    v210 = v25;
    if (v216 < v25)
    {
      operator delete(v218);
      v214 = v217;
      v216 = 40;
      v218 = operator new(4 * v25);
      v214 = v218;
      v216 = v25;
    }
    v215 = v25;
    if (v221 < v25)
    {
      operator delete(v223);
      v219 = v222;
      v221 = 40;
      v223 = operator new(4 * v25);
      v219 = v223;
      v221 = v25;
    }
    v220 = v25;
    if (v226 < v25)
    {
      operator delete(v228);
      v224 = v227;
      v226 = 40;
      v228 = operator new(4 * v25);
      v224 = v228;
      v226 = v25;
    }
  }
  else
  {
    operator delete(v213);
    v209 = v212;
    v210 = v25;
    v211 = 40;
    operator delete(v218);
    v214 = v217;
    v215 = v25;
    v216 = 40;
    operator delete(v223);
    v219 = v222;
    v221 = 40;
    v220 = v25;
    operator delete(v228);
    v224 = v227;
    v226 = 40;
  }
  v26 = 0;
  v225 = v25;
  v186 = 4;
  do
  {
    *(_DWORD *)(v184 + 4 * v26 + 7040) = *(_DWORD *)(v17 + 4 * v26) + v181;
    v27 = (unsigned __int16 *)(v182 + 6 * v26);
    v28 = *(_DWORD *)(v17 + 4 * v26);
    v29 = (uint64_t *)&(&v209)[23 * v26];
    if (*v27)
    {
      v30 = OpenSubdiv::v3_1_1::Vtr::internal::Level::gatherQuadRegularPartialRingAroundVertex(v20, v28, v27, *v29, v23);
      if ((v30 & 1) == 0)
        goto LABEL_27;
    }
    else
    {
      v30 = OpenSubdiv::v3_1_1::Vtr::internal::Level::gatherQuadRegularRingAroundVertex(v20, v28, (int *)*v29, v23);
      if ((v30 & 1) == 0)
      {
LABEL_27:
        v31 = 0;
        if (v30 >= 0)
          v32 = v30;
        else
          v32 = v30 + 1;
        v33 = v32 >> 1;
        v34 = 6.2832 / (float)v33;
        v35 = v33;
        goto LABEL_36;
      }
    }
    v36 = v30 - 1;
    if ((int)v36 >= 0)
      v37 = v30 - 1;
    else
      v37 = v30;
    v33 = v37 >> 1;
    v35 = v33 + 1;
    v34 = 3.1416 / (float)v33;
    *(_DWORD *)(*v29 + 4 * v30) = *(_DWORD *)(*v29 + 4 * v36);
    v31 = 1;
LABEL_36:
    v198[v26] = v31;
    *((_DWORD *)&v208[357] + v26) = v33;
    *((_DWORD *)&v208[359] + v26) = v35;
    *((float *)&v208[353] + v26) = v34;
    v38 = v26 + 1;
    v39 = *(_DWORD *)(v183 + 4 * ((v26 + 1) & 3));
    v40 = *(_DWORD *)(v183 + 4 * (((_BYTE)v26 - 1) & 3));
    *((_DWORD *)&v208[355] + v26) = -1;
    if (v35 >= 1)
    {
      v41 = 0;
      v42 = 0;
      v43 = *v29;
      v44 = 2 * v35;
      while (1)
      {
        v45 = v41 + 2;
        if (*(_DWORD *)(v43 + 4 * v41) == v39)
        {
          v46 = v44 - 2 == v41 ? 0 : v41 + 2;
          if (*(_DWORD *)(v43 + 4 * v46) == v40)
            break;
        }
        ++v42;
        v41 = v45;
        if (v44 == v45)
          goto LABEL_46;
      }
      *((_DWORD *)&v208[355] + v26) = v42;
    }
LABEL_46:
    v186 = v186 + v30 - 3;
    ++v26;
  }
  while (v38 != 4);
  for (i = 0; i != 176; i += 44)
  {
    v48 = &v208[i + 177];
    *(_DWORD *)v48 = 0;
    v48[1] = &v208[i + 180];
    v48[43] = 0;
    v48[2] = (void *)0x2800000028;
  }
  for (j = 0; j != 176; j += 44)
  {
    v50 = &v208[j + 1];
    *(_DWORD *)v50 = 0;
    v50[1] = &v208[j + 4];
    v50[43] = 0;
    v50[2] = (void *)0x2800000028;
  }
  v51 = v207;
  v204 = v207;
  v205 = v179;
  v206 = 10;
  v208[0] = 0;
  LODWORD(v52) = v179;
  if (v179 >= 0xB)
  {
    v51 = operator new(352 * v179);
    v208[0] = v51;
    v204 = v51;
    v206 = v179;
    LODWORD(v52) = v205;
  }
  if ((_DWORD)v52)
  {
    v52 = v52;
    do
    {
      *(_DWORD *)v51 = 0;
      v51[1] = v51 + 3;
      v51[43] = 0;
      v51[2] = 0x2800000028;
      v51 += 44;
      --v52;
    }
    while (v52);
  }
  v53 = 4 * v179;
  v54 = v202;
  v199 = v202;
  v200 = 4 * v179;
  v201 = 40;
  v203 = 0;
  if ((4 * v179) >= 0x29)
  {
    v54 = operator new(352 * v53);
    v203 = v54;
    v199 = v54;
    v201 = 4 * v179;
    v53 = v200;
  }
  if (v53)
  {
    v55 = v53;
    do
    {
      *(_DWORD *)v54 = 0;
      v54[1] = v54 + 3;
      v54[43] = 0;
      v54[2] = 0x2800000028;
      v54 += 44;
      --v55;
    }
    while (v55);
  }
  v56 = 0;
  v57 = 0;
  do
  {
    v191 = v56;
    v193 = *(_DWORD *)(v183 + 4 * v57);
    v185 = v57;
    v58 = *((int *)&v208[359] + v57);
    v59 = *((_DWORD *)&v208[359] + v57);
    v195 = v59;
    if ((int)v58 >= 1)
    {
      v60 = 0;
      v61 = 1.0 / (float)((float)v59 + 5.0);
      v62 = v61 * (float)v59;
      v187 = (OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(352 * v59);
      v189 = (OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&(&v209)[23 * v57];
      v63 = -1;
      v64 = 2;
      v65 = 4;
      do
      {
        v66 = (v59 + v63) % (int)v58;
        v67 = *(_QWORD *)v189;
        v68 = (int *)(*(_QWORD *)v189 + v65);
        v69 = *(v68 - 1);
        v70 = *v68;
        if ((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)((char *)v187 - 352) == v60)
          v71 = 0;
        else
          v71 = v64;
        v72 = *(_DWORD *)(v67 + 4 * v71);
        v73 = *(_DWORD *)(v67 + 8 * v66);
        v196 = *(_DWORD *)(v67 + 8 * v66 + 4);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear((void **)((char *)v60 + (_QWORD)v204), 4u);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)((char *)v60 + (_QWORD)v204), v193, v62);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)((char *)v60 + (_QWORD)v204), v72, v61 + v61);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)((char *)v60 + (_QWORD)v204), v69, v61 + v61);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)((char *)v60 + (_QWORD)v204), v70, v61);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear((void **)&v199[(unint64_t)v60 + (_QWORD)v191], 4u);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v199[(unint64_t)v60 + (_QWORD)v191], v72, 0.33333);
        v74 = v73;
        v59 = v195;
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v199[(unint64_t)v60 + (_QWORD)v191], v74, -0.33333);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v199[(unint64_t)v60 + (_QWORD)v191], v70, 0.16667);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v199[(unint64_t)v60 + (_QWORD)v191], v196, -0.16667);
        v60 = (OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)((char *)v60 + 352);
        v65 += 8;
        v64 += 2;
        ++v63;
      }
      while (v187 != v60);
    }
    if ((*(_BYTE *)(v182 + 6 * v185 + 4) & 2) != 0)
    {
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear((void **)(v184 + 352 * v185), v186);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v184 + 352 * v185), v193, 1.0);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear(&v208[44 * v185 + 177], v186);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v208[44 * v185 + 177], *(_DWORD *)(v183 + 4 * v185), 0.66667);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v208[44 * v185 + 177], *(_DWORD *)(v183 + 4 * (((_BYTE)v185 + 1) & 3)), 0.33333);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear(&v208[44 * v185 + 1], v186);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v208[44 * v185 + 1], *(_DWORD *)(v183 + 4 * v185), 0.66667);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v208[44 * v185 + 1], *(_DWORD *)(v183 + 4 * (((_BYTE)v185 - 1) & 3)), 0.33333);
      v93 = v191;
    }
    else if (v198[v185])
    {
      v75 = (int **)&(&v209)[23 * v185];
      v76 = **v75;
      v77 = (*v75)[2 * (int)v58 - 1];
      v78 = (void **)(v184 + 352 * v185);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear(v78, v186);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v78, v76, 0.16667);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v78, v77, 0.16667);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v78, v193, 0.66667);
      v79 = (float)*((int *)&v208[357] + v185);
      v80 = *((float *)&v208[353] + v185);
      v81 = __sincosf_stret(v80);
      v82 = 1.0 / (float)(v81.__cosval + (float)(v79 * 3.0));
      LODWORD(v78) = (*v75)[1];
      v83 = (float)(v82 * (float)-(float)((float)((float)(v81.__cosval * 2.0) + 1.0) * sqrtf(v81.__cosval + 1.0)))
          / sqrtf(1.0 - v81.__cosval);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear(&v208[44 * v185 + 177], v186);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v208[44 * v185 + 177], v76, 0.16667);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v208[44 * v185 + 177], v77, -0.16667);
      v84 = &v208[44 * v185 + 1];
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear(v84, v186);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v84, v193, (float)(v81.__sinval * -4.0) * v82);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v84, v76, v83);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v84, (int)v78, v81.__sinval * v82);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v84, v77, v83);
      if ((int)v195 >= 3)
      {
        v85 = 0;
        v86 = 2;
        do
        {
          v87 = sinf(v80 * (float)(v86 - 1));
          v88 = v82 * (float)(v87 * 4.0);
          v89 = v82 * (float)(v87 + sinf(v80 * (float)v86));
          v90 = &(*v75)[v85 / 4];
          v91 = v90[3];
          OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v84, v90[2], v88);
          OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v84, v91, v89);
          v85 += 8;
          ++v86;
        }
        while (8 * (v195 - 1) - 8 != v85);
      }
      v92 = *(unsigned int *)v84;
      v93 = v191;
      if ((int)v92 >= 1)
      {
        v94 = (float *)((char *)v208[44 * v185 + 2] + 4);
        do
        {
          *v94 = *v94 * 0.33333;
          v94 += 2;
          --v92;
        }
        while (v92);
      }
    }
    else
    {
      v95 = *((float *)&v208[353] + v185);
      v96 = (float)v59;
      if (v59 > 29)
      {
        v98 = cosf(6.2832 / v96);
        v97 = 1.0
            / (float)((float)((float)((float)(v98 + 5.0) + sqrtf((float)(v98 + 9.0) * (float)(v98 + 1.0))) * v96)
                    * 0.0625);
      }
      else
      {
        v97 = OpenSubdiv::v3_1_1::Far::computeCoefficient(int)::efTable[v58];
      }
      v93 = v191;
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear((void **)(v184 + 352 * v185), v186);
      v99 = &v208[44 * v185 + 177];
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear(v99, v186);
      v100 = &v208[44 * v185 + 1];
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear(v100, v186);
      if (v59 >= 1)
      {
        v101 = 0;
        v102 = 0;
        v103 = v97 * 0.5;
        v104 = v59 - 1;
        v105 = 1.0 / v96;
        do
        {
          v106 = v104 + v102 - (v104 + (int)v102) / v59 * v195;
          OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v184 + 352 * v185), (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v204[v101], v105);
          v107 = __sincosf_stret(v95 * (float)(int)v102);
          OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v99, (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v204[v101], v103 * v107.__cosval);
          OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v99, (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v204[352 * v106], v103 * v107.__cosval);
          OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v100, (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v204[v101], v103 * v107.__sinval);
          v108 = (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v204[352 * v106];
          v59 = v195;
          OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v100, v108, v103 * v107.__sinval);
          ++v102;
          v101 += 352;
        }
        while (v195 != v102);
      }
    }
    v57 = v185 + 1;
    v56 = (OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)((char *)v93 + 352 * v179);
  }
  while (v185 != 3);
  v109 = 0;
  v110 = 0;
  v111 = (char *)(v182 + 4);
  v112 = v184;
  do
  {
    v113 = *v111;
    v111 += 6;
    if ((v113 & 2) != 0)
    {
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::operator=((int *)(v112 + v109 + 1408), (int *)&v208[v109 / 8 + 177]);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::operator=((int *)(v112 + v109 + 2816), (int *)&v208[v109 / 8 + 1]);
    }
    else
    {
      v114 = *((_DWORD *)&v208[355] + v110);
      v115 = *((float *)&v208[353] + v110);
      v116 = v115 * (float)v114;
      v117 = v115 * (float)((v114 + 1) % *((_DWORD *)&v208[359] + v110));
      if (v198[v110] && *((int *)&v208[357] + v110) < 2)
      {
        v122 = v112 + v109;
        v123 = (void **)(v112 + v109 + 1408);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear(v123, v186);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v123, *(_DWORD *)(v183 + 4 * v110), 0.66667);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v123, *(_DWORD *)(v183 + 4 * (((_BYTE)v110 + 1) & 3)), 0.33333);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear((void **)(v122 + 2816), v186);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v122 + 2816), *(_DWORD *)(v183 + 4 * v110), 0.66667);
        v112 = v184;
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v122 + 2816), *(_DWORD *)(v183 + 4 * (((_BYTE)v110 - 1) & 3)), 0.33333);
      }
      else
      {
        v118 = (int *)(v184 + v109 + 1408);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::operator=(v118, (int *)(v184 + v109));
        v119 = __sincosf_stret(v116);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v118, (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v208[v109 / 8 + 177], v119.__cosval);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v118, (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v208[v109 / 8 + 1], v119.__sinval);
        v120 = (int *)(v184 + v109 + 2816);
        v112 = v184;
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::operator=(v120, (int *)(v184 + v109));
        v121 = __sincosf_stret(v117);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v120, (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v208[v109 / 8 + 177], v121.__cosval);
        OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v120, (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v208[v109 / 8 + 1], v121.__sinval);
      }
    }
    ++v110;
    v109 += 352;
  }
  while (v110 != 4);
  v124 = 0;
  v125 = 0;
  v126 = -2.0;
  v127 = v180;
  while (2)
  {
    *(_QWORD *)v197 = v125 + 1;
    v128 = (v125 + 1) & 3;
    v129 = ((_BYTE)v125 - 1) & 3;
    v130 = *((_DWORD *)&v208[355] + v125);
    v131 = (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v199[352 * v130 + v124];
    v132 = (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)&v199[352
                                                                     * ((v130 + 1) % *((_DWORD *)&v208[359] + v125))
                                                                     + v124];
    v133 = cosf(*((float *)&v208[353] + v125));
    v134 = cosf(*((float *)&v208[353] + v129));
    v135 = cosf(*((float *)&v208[353] + v128));
    v136 = (float)(v133 * v126) + 3.0;
    v137 = v136 - v135;
    v138 = v133 + v133;
    v139 = v136 - v134;
    if (!v198[v125])
    {
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear(v127 + 176, v186);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 176), (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 - 352), v135 / 3.0);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 176), (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 - 176), v137 / 3.0);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 176), (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v184 + 352 * v128 + 2816), v138 / 3.0);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 176), v131, 0.33333);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear(v127 + 352, v186);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 352), (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 - 352), v134 / 3.0);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 352), (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v127, v139 / 3.0);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 352), (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v184 + 352 * (((_BYTE)v125 - 1) & 3) + 1408), v138 / 3.0);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 352), v132, -0.33333);
      goto LABEL_101;
    }
    v194 = v132;
    v140 = *((_DWORD *)&v208[357] + v125);
    v141 = v127 + 176;
    OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear(v127 + 176, v186);
    if (v140 < 2)
    {
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 176), *(_DWORD *)(v183 + 4 * v125), 0.44444);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 176), *(_DWORD *)(v183 + 4 * (((_BYTE)v125 + 2) & 3)), 0.11111);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 176), *(_DWORD *)(v183 + 4 * v128), 0.22222);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 176), *(_DWORD *)(v183 + 4 * v129), 0.22222);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::operator=((int *)v127 + 704, (int *)v127 + 352);
LABEL_101:
      v152 = (char *)v127;
LABEL_102:
      v153 = *(_QWORD *)v197;
      goto LABEL_103;
    }
    v142 = (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 - 352);
    v143 = v135 / 3.0;
    OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 176), (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 - 352), v135 / 3.0);
    v144 = v137 / 3.0;
    v192 = (OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 - 176);
    OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 176), (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 - 176), v137 / 3.0);
    v145 = ((_BYTE)v125 - 1) & 3;
    v146 = v138 / 3.0;
    v190 = (OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v184 + 352 * v128 + 2816);
    OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 176), v190, v138 / 3.0);
    v188 = v131;
    OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v127 + 176), v131, 0.33333);
    v147 = (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v127;
    v148 = v127 + 352;
    OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear(v148, v186);
    v149 = v134 / 3.0;
    OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v148, v142, v149);
    v150 = v139 / 3.0;
    OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v148, v147, v150);
    v151 = (const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)(v184 + 352 * v145 + 1408);
    OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v148, v151, v138 / 3.0);
    OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v148, v194, -0.33333);
    if (v198[v145])
    {
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear(v141, v186);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v141, v142, v143);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v141, v192, v144);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v141, v190, v146);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v141, v188, 0.33333);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::operator=((int *)v148, (int *)v141);
      v152 = (char *)v147;
      v126 = -2.0;
      goto LABEL_102;
    }
    v154 = v142;
    v152 = (char *)v147;
    v126 = -2.0;
    v153 = *(_QWORD *)v197;
    if (v198[v128])
    {
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear(v148, v186);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v148, v154, v149);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v148, v147, v150);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v148, v151, v146);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight((OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *)v148, v194, -0.33333);
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::operator=((int *)v141, (int *)v148);
    }
LABEL_103:
    v127 = (void **)(v152 + 352);
    v124 += 352 * v179;
    v125 = v153;
    if (v153 != 4)
      continue;
    break;
  }
  for (k = 0; k != 4; ++k)
  {
    v156 = *(unsigned int *)(v184 + 352 * k);
    if ((int)v156 >= 1)
    {
      v157 = *(_DWORD **)(v184 + 352 * k + 8);
      do
      {
        *v157 += v181;
        v157 += 2;
        --v156;
      }
      while (v156);
    }
    v158 = *(unsigned int *)(v184 + 352 * k + 1408);
    if ((int)v158 >= 1)
    {
      v159 = *(_DWORD **)(v184 + 352 * k + 1416);
      do
      {
        *v159 += v181;
        v159 += 2;
        --v158;
      }
      while (v158);
    }
    v160 = *(unsigned int *)(v184 + 352 * k + 2816);
    if ((int)v160 >= 1)
    {
      v161 = *(_DWORD **)(v184 + 352 * k + 2824);
      do
      {
        *v161 += v181;
        v161 += 2;
        --v160;
      }
      while (v160);
    }
    v162 = *(unsigned int *)(v184 + 352 * k + 4224);
    if ((int)v162 >= 1)
    {
      v163 = *(_DWORD **)(v184 + 352 * k + 4232);
      do
      {
        *v163 += v181;
        v163 += 2;
        --v162;
      }
      while (v162);
    }
    v164 = *(unsigned int *)(v184 + 352 * k + 5632);
    if ((int)v164 >= 1)
    {
      v165 = *(_DWORD **)(v184 + 352 * k + 5640);
      do
      {
        *v165 += v181;
        v165 += 2;
        --v164;
      }
      while (v164);
    }
  }
  if (v200)
  {
    v166 = 0;
    v167 = 344;
    do
    {
      v168 = &v199[v167];
      v169 = &v199[v167 - 336];
      operator delete(*(void **)&v199[v167]);
      *v169 = v168 - 320;
      *((_DWORD *)v168 - 81) = 40;
      ++v166;
      v167 += 352;
    }
    while (v166 < v200);
  }
  operator delete(v203);
  if (v205)
  {
    v170 = 0;
    v171 = 344;
    do
    {
      v172 = &v204[v171];
      v173 = &v204[v171 - 336];
      operator delete(*(void **)&v204[v171]);
      *v173 = v172 - 320;
      *((_DWORD *)v172 - 81) = 40;
      ++v170;
      v171 += 352;
    }
    while (v170 < v205);
  }
  operator delete(v208[0]);
  v174 = 1408;
  do
  {
    operator delete(v208[v174 / 8]);
    *(_QWORD *)&v207[v174 + 3184] = &v207[v174 + 3200];
    *(_DWORD *)&v207[v174 + 3196] = 40;
    v174 -= 352;
  }
  while (v174);
  v175 = 176;
  do
  {
    operator delete(v208[v175 + 176]);
    v208[v175 + 134] = &v208[v175 + 136];
    HIDWORD(v208[v175 + 135]) = 40;
    v175 -= 44;
  }
  while (v175 * 8);
  v176 = 92;
  do
  {
    v177 = (char *)&(&v209)[v176];
    operator delete(v208[v176 + 360]);
    *((_QWORD *)v177 - 23) = v177 - 168;
    *((_DWORD *)v177 - 43) = 40;
    v176 -= 23;
  }
  while (v176 * 8);
  return v184;
}

void OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear(void **this, unsigned int a2)
{
  void *v4;

  *(_DWORD *)this = 0;
  if (*((_DWORD *)this + 4) < (signed int)a2)
  {
    if (a2)
    {
      if (*((_DWORD *)this + 5) < a2)
      {
        operator delete(this[43]);
        this[1] = this + 3;
        *((_DWORD *)this + 5) = 40;
        v4 = operator new(8 * a2);
        this[43] = v4;
        this[1] = v4;
        *((_DWORD *)this + 5) = a2;
      }
    }
    else
    {
      operator delete(this[43]);
      this[1] = this + 3;
      *((_DWORD *)this + 5) = 40;
    }
    *((_DWORD *)this + 4) = a2;
  }
}

float OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight(OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *this, int a2, float result)
{
  int v3;
  uint64_t v4;
  float *v5;
  uint64_t v6;
  uint64_t v7;

  v3 = *(_DWORD *)this;
  v4 = *((_QWORD *)this + 1);
  if (*(int *)this < 1)
  {
LABEL_5:
    v7 = v4 + 8 * v3;
    *(_DWORD *)v7 = a2;
    *(float *)(v7 + 4) = result;
    *(_DWORD *)this = v3 + 1;
  }
  else
  {
    v5 = (float *)(v4 + 4);
    v6 = *(unsigned int *)this;
    while (*((_DWORD *)v5 - 1) != a2)
    {
      v5 += 2;
      if (!--v6)
        goto LABEL_5;
    }
    result = *v5 + result;
    *v5 = result;
  }
  return result;
}

void OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight(OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *this, const OpenSubdiv::v3_1_1::Far::GregoryBasis::Point *a2, float a3)
{
  uint64_t v6;
  uint64_t v7;

  if (*(int *)a2 >= 1)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::AddWithWeight(this, *(_DWORD *)(*((_QWORD *)a2 + 1) + v6), *(float *)(*((_QWORD *)a2 + 1) + v6 + 4) * a3);
      ++v7;
      v6 += 8;
    }
    while (v7 < *(int *)a2);
  }
}

int *OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::operator=(int *a1, int *a2)
{
  int v4;
  uint64_t v5;

  OpenSubdiv::v3_1_1::Far::GregoryBasis::Point::Clear((void **)a1, a2[4]);
  v4 = *a2;
  *a1 = *a2;
  if (v4 >= 1)
  {
    v5 = 0;
    do
    {
      *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v5) = *(_QWORD *)(*((_QWORD *)a2 + 1) + 8 * v5);
      ++v5;
    }
    while (v5 < *a1);
  }
  return a1;
}

void OpenSubdiv::v3_1_1::Vtr::internal::Refinement::~Refinement(OpenSubdiv::v3_1_1::Vtr::internal::Refinement *this)
{
  _QWORD *v2;
  uint64_t v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;

  *(_QWORD *)this = off_24ED89E00;
  v4 = (char *)this + 480;
  v2 = (_QWORD *)*((_QWORD *)this + 60);
  v3 = *((_QWORD *)v4 + 1);
  if ((int)((unint64_t)(v3 - (_QWORD)v2) >> 3) >= 1)
  {
    v5 = 0;
    do
    {
      v6 = v2[v5];
      if (v6)
      {
        v7 = *(void **)(v6 + 40);
        if (v7)
        {
          *(_QWORD *)(v6 + 48) = v7;
          operator delete(v7);
        }
        MEMORY[0x2276933B8](v6, 0x70C4089CF00AFLL);
        v2 = (_QWORD *)*((_QWORD *)this + 60);
        v3 = *((_QWORD *)this + 61);
      }
      ++v5;
    }
    while (v5 < (int)((unint64_t)(v3 - (_QWORD)v2) >> 3));
  }
  if (v2)
  {
    *((_QWORD *)this + 61) = v2;
    operator delete(v2);
  }
  v8 = (void *)*((_QWORD *)this + 57);
  if (v8)
  {
    *((_QWORD *)this + 58) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 54);
  if (v9)
  {
    *((_QWORD *)this + 55) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 51);
  if (v10)
  {
    *((_QWORD *)this + 52) = v10;
    operator delete(v10);
  }
  v11 = (void *)*((_QWORD *)this + 48);
  if (v11)
  {
    *((_QWORD *)this + 49) = v11;
    operator delete(v11);
  }
  v12 = (void *)*((_QWORD *)this + 45);
  if (v12)
  {
    *((_QWORD *)this + 46) = v12;
    operator delete(v12);
  }
  v13 = (void *)*((_QWORD *)this + 42);
  if (v13)
  {
    *((_QWORD *)this + 43) = v13;
    operator delete(v13);
  }
  v14 = (void *)*((_QWORD *)this + 39);
  if (v14)
  {
    *((_QWORD *)this + 40) = v14;
    operator delete(v14);
  }
  v15 = (void *)*((_QWORD *)this + 36);
  if (v15)
  {
    *((_QWORD *)this + 37) = v15;
    operator delete(v15);
  }
  v16 = (void *)*((_QWORD *)this + 33);
  if (v16)
  {
    *((_QWORD *)this + 34) = v16;
    operator delete(v16);
  }
  v17 = (void *)*((_QWORD *)this + 30);
  if (v17)
  {
    *((_QWORD *)this + 31) = v17;
    operator delete(v17);
  }
  v18 = (void *)*((_QWORD *)this + 27);
  if (v18)
  {
    *((_QWORD *)this + 28) = v18;
    operator delete(v18);
  }
  v19 = (void *)*((_QWORD *)this + 24);
  if (v19)
  {
    *((_QWORD *)this + 25) = v19;
    operator delete(v19);
  }
  v20 = (void *)*((_QWORD *)this + 21);
  if (v20)
  {
    *((_QWORD *)this + 22) = v20;
    operator delete(v20);
  }
  v21 = (void *)*((_QWORD *)this + 18);
  if (v21)
  {
    *((_QWORD *)this + 19) = v21;
    operator delete(v21);
  }
  v22 = (void *)*((_QWORD *)this + 15);
  if (v22)
  {
    *((_QWORD *)this + 16) = v22;
    operator delete(v22);
  }
}

void OpenSubdiv::v3_1_1::Vtr::internal::Refinement::initializeSparseSelectionTags(OpenSubdiv::v3_1_1::Vtr::internal::Refinement *this)
{
  int *v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v2 = (int *)*((_QWORD *)this + 1);
  v3 = *v2;
  v4 = *((_QWORD *)this + 51);
  v5 = *((_QWORD *)this + 52) - v4;
  if (v3 <= v5)
  {
    if (v3 < v5)
      *((_QWORD *)this + 52) = v4 + v3;
  }
  else
  {
    std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Refinement::SparseTag>::__append((_QWORD *)this + 51, v3 - v5);
    v2 = (int *)*((_QWORD *)this + 1);
  }
  v6 = v2[1];
  v7 = *((_QWORD *)this + 54);
  v8 = *((_QWORD *)this + 55) - v7;
  if (v6 <= v8)
  {
    if (v6 < v8)
      *((_QWORD *)this + 55) = v7 + v6;
  }
  else
  {
    std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Refinement::SparseTag>::__append((_QWORD *)this + 54, v6 - v8);
    v2 = (int *)*((_QWORD *)this + 1);
  }
  v9 = v2[2];
  v10 = *((_QWORD *)this + 57);
  v11 = *((_QWORD *)this + 58) - v10;
  if (v9 <= v11)
  {
    if (v9 < v11)
      *((_QWORD *)this + 58) = v10 + v9;
  }
  else
  {
    std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Refinement::SparseTag>::__append((_QWORD *)this + 57, v9 - v11);
  }
}

void OpenSubdiv::v3_1_1::Vtr::internal::Refinement::refine(uint64_t a1, char a2)
{
  uint64_t v4;
  _DWORD *v5;
  int v6;
  int v7;
  uint8x8_t v8;
  uint8x8_t v9;
  char v10;
  char v11[4];

  *(_BYTE *)(a1 + 36) = (a2 & 1) == 0;
  *(_BYTE *)(a1 + 37) = (a2 & 2) != 0;
  v4 = (*(_QWORD *)(*(_QWORD *)(a1 + 8) + 464) - *(_QWORD *)(*(_QWORD *)(a1 + 8) + 456)) >> 3;
  OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateParentToChildMapping((OpenSubdiv::v3_1_1::Vtr::internal::Refinement *)a1);
  v5 = *(_DWORD **)(a1 + 16);
  v6 = *(_DWORD *)(a1 + 52);
  v7 = *(_DWORD *)(a1 + 48) + *(_DWORD *)(a1 + 44);
  *v5 = *(_DWORD *)(a1 + 40);
  v5[1] = v7;
  v5[2] = *(_DWORD *)(a1 + 56) + v6 + *(_DWORD *)(a1 + 60);
  OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateChildToParentMapping((std::vector<int> *)a1, v8, v9);
  OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateFaceTagVectors((OpenSubdiv::v3_1_1::Vtr::internal::Refinement *)a1);
  OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateEdgeTagVectors((OpenSubdiv::v3_1_1::Vtr::internal::Refinement *)a1);
  OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexTagVectors((OpenSubdiv::v3_1_1::Vtr::internal::Refinement *)a1);
  if ((a2 & 4) != 0)
    v10 = 1;
  else
    v10 = -1;
  v11[0] = v10;
  if ((int)v4 < 1)
  {
    OpenSubdiv::v3_1_1::Vtr::internal::Refinement::subdivideTopology(a1, v11);
    OpenSubdiv::v3_1_1::Vtr::internal::Refinement::subdivideEdgeSharpness((OpenSubdiv::v3_1_1::Vtr::internal::Refinement *)a1);
    OpenSubdiv::v3_1_1::Vtr::internal::Refinement::subdivideVertexSharpness((OpenSubdiv::v3_1_1::Vtr::internal::Refinement *)a1);
    OpenSubdiv::v3_1_1::Vtr::internal::Refinement::reclassifySemisharpVertices(a1);
  }
  else
  {
    v11[0] = v10 | 0x10;
    OpenSubdiv::v3_1_1::Vtr::internal::Refinement::subdivideTopology(a1, v11);
    OpenSubdiv::v3_1_1::Vtr::internal::Refinement::subdivideEdgeSharpness((OpenSubdiv::v3_1_1::Vtr::internal::Refinement *)a1);
    OpenSubdiv::v3_1_1::Vtr::internal::Refinement::subdivideVertexSharpness((OpenSubdiv::v3_1_1::Vtr::internal::Refinement *)a1);
    OpenSubdiv::v3_1_1::Vtr::internal::Refinement::reclassifySemisharpVertices(a1);
    OpenSubdiv::v3_1_1::Vtr::internal::Refinement::subdivideFVarChannels((OpenSubdiv::v3_1_1::Vtr::internal::Refinement *)a1);
  }
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateParentToChildMapping(OpenSubdiv::v3_1_1::Vtr::internal::Refinement *this)
{
  (*(void (**)(OpenSubdiv::v3_1_1::Vtr::internal::Refinement *))(*(_QWORD *)this + 16))(this);
  if (!*((_BYTE *)this + 36))
    OpenSubdiv::v3_1_1::Vtr::internal::Refinement::markSparseChildComponentIndices(this);
  return OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateParentChildIndices((uint64_t)this);
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateChildToParentMapping(std::vector<int> *this, uint8x8_t a2, uint8x8_t a3)
{
  int16x8_t v4;
  int16x8_t v5;
  _QWORD v7[2];

  v7[1] = *MEMORY[0x24BDAC8D0];
  a3.i32[0] = HIDWORD(v7[0]);
  a2.i32[0] = v7[0];
  v4 = (int16x8_t)vmovl_u8(a2);
  *(int8x8_t *)v4.i8 = vorr_s8((int8x8_t)(v4.i64[0] & 0xFFE0FFE0FFE0FFE0), (int8x8_t)0x18001000080000);
  v4.i32[0] = vmovn_s16(v4).u32[0];
  v5 = (int16x8_t)vmovl_u8(a3);
  *(int8x8_t *)v5.i8 = vorr_s8((int8x8_t)(v5.i64[0] & 0xFFE0FFE0FFE0FFE0), (int8x8_t)0x19001100090001);
  v4.i32[1] = vmovn_s16(v5).u32[0];
  v7[0] = v4.i64[0];
  OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateFaceParentVectors(this, v7);
  OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateEdgeParentVectors(this, v7);
  return OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexParentVectors((uint64_t)this, v7);
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::subdivideTopology(uint64_t result, char *a2)
{
  uint64_t v3;
  char v4;
  int v5;

  v3 = result;
  v4 = *a2;
  if ((*a2 & 1) != 0)
  {
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 32))(result);
    v4 = *a2;
    if ((*a2 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0)
        goto LABEL_4;
      goto LABEL_16;
    }
  }
  else if ((*a2 & 2) == 0)
  {
    goto LABEL_3;
  }
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
  v4 = *a2;
  if ((*a2 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0)
      goto LABEL_5;
    goto LABEL_17;
  }
LABEL_16:
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3);
  v4 = *a2;
  if ((*a2 & 8) == 0)
  {
LABEL_5:
    if ((v4 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_18;
  }
LABEL_17:
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 56))(v3);
  v4 = *a2;
  if ((*a2 & 0x10) == 0)
  {
LABEL_6:
    if ((v4 & 0x20) == 0)
      goto LABEL_8;
    goto LABEL_7;
  }
LABEL_18:
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 64))(v3);
  if ((*a2 & 0x20) != 0)
LABEL_7:
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 72))(v3);
LABEL_8:
  if (*(_DWORD *)(v3 + 28))
    v5 = 6;
  else
    v5 = 4;
  if (*(_DWORD *)(*(_QWORD *)(v3 + 8) + 20) > v5)
    v5 = *(_DWORD *)(*(_QWORD *)(v3 + 8) + 20);
  *(_DWORD *)(*(_QWORD *)(v3 + 16) + 20) = v5;
  return result;
}

void OpenSubdiv::v3_1_1::Vtr::internal::Refinement::subdivideFVarChannels(OpenSubdiv::v3_1_1::Vtr::internal::Refinement *this)
{
  unint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  char *v32;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **v33;
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *v34;

  v1 = *(_QWORD *)(*((_QWORD *)this + 1) + 464) - *(_QWORD *)(*((_QWORD *)this + 1) + 456);
  if ((int)(v1 >> 3) >= 1)
  {
    v3 = 0;
    v4 = (v1 >> 3);
    do
    {
      v5 = *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 1) + 456) + 8 * v3);
      v6 = operator new();
      *(_QWORD *)v6 = *((_QWORD *)this + 2);
      *(_WORD *)(v6 + 8) = *(_WORD *)(v6 + 8) & 0xFE00 | 0x14;
      *(_WORD *)(v6 + 12) = 0;
      *(_BYTE *)(v6 + 14) = 0;
      *(_DWORD *)(v6 + 16) = 0;
      *(_OWORD *)(v6 + 24) = 0u;
      *(_OWORD *)(v6 + 40) = 0u;
      *(_OWORD *)(v6 + 56) = 0u;
      *(_OWORD *)(v6 + 72) = 0u;
      *(_OWORD *)(v6 + 88) = 0u;
      *(_OWORD *)(v6 + 104) = 0u;
      *(_OWORD *)(v6 + 120) = 0u;
      *(_OWORD *)(v6 + 136) = 0u;
      *(_OWORD *)(v6 + 152) = 0u;
      *(_OWORD *)(v6 + 168) = 0u;
      *(_OWORD *)(v6 + 184) = 0u;
      *(_OWORD *)(v6 + 200) = 0u;
      v7 = (OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *)operator new();
      v8 = *((_QWORD *)this + 1);
      v9 = *((_QWORD *)this + 2);
      *(_QWORD *)v7 = this;
      *((_QWORD *)v7 + 1) = v8;
      *((_QWORD *)v7 + 2) = v5;
      *((_QWORD *)v7 + 3) = v9;
      *((_QWORD *)v7 + 4) = v6;
      *((_QWORD *)v7 + 5) = 0;
      *((_QWORD *)v7 + 6) = 0;
      *((_QWORD *)v7 + 7) = 0;
      OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::applyRefinement(v7);
      v10 = (_QWORD *)*((_QWORD *)this + 2);
      v12 = (uint64_t *)v10[58];
      v11 = v10[59];
      if ((unint64_t)v12 >= v11)
      {
        v14 = v10[57];
        v15 = ((uint64_t)v12 - v14) >> 3;
        if ((unint64_t)(v15 + 1) >> 61)
          goto LABEL_38;
        v16 = v11 - v14;
        v17 = v16 >> 2;
        if (v16 >> 2 <= (unint64_t)(v15 + 1))
          v17 = v15 + 1;
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
          v18 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v18 = v17;
        if (v18)
          v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)(v10 + 59), v18);
        else
          v19 = 0;
        v20 = (uint64_t *)&v19[8 * v15];
        *v20 = v6;
        v13 = v20 + 1;
        v22 = (char *)v10[57];
        v21 = (char *)v10[58];
        if (v21 != v22)
        {
          do
          {
            v23 = *((_QWORD *)v21 - 1);
            v21 -= 8;
            *--v20 = v23;
          }
          while (v21 != v22);
          v21 = (char *)v10[57];
        }
        v10[57] = v20;
        v10[58] = v13;
        v10[59] = &v19[8 * v18];
        if (v21)
          operator delete(v21);
      }
      else
      {
        *v12 = v6;
        v13 = v12 + 1;
      }
      v10[58] = v13;
      v25 = (OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)*((_QWORD *)this + 61);
      v24 = *((_QWORD *)this + 62);
      if ((unint64_t)v25 >= v24)
      {
        v27 = (_QWORD *)*((_QWORD *)this + 60);
        v28 = v25 - (OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)v27;
        v29 = v28 + 1;
        if ((unint64_t)(v28 + 1) >> 61)
LABEL_38:
          abort();
        v30 = v24 - (_QWORD)v27;
        if (v30 >> 2 > v29)
          v29 = v30 >> 2;
        if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8)
          v31 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v31 = v29;
        if (v31)
        {
          if (v31 >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v32 = (char *)operator new(8 * v31);
        }
        else
        {
          v32 = 0;
        }
        v33 = (OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)&v32[8 * v28];
        *v33 = v7;
        v26 = v33 + 1;
        if (v25 != v27)
        {
          do
          {
            v34 = *--v25;
            *--v33 = v34;
          }
          while (v25 != v27);
          v25 = (OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement **)*((_QWORD *)this + 60);
        }
        *((_QWORD *)this + 60) = v33;
        *((_QWORD *)this + 61) = v26;
        *((_QWORD *)this + 62) = &v32[8 * v31];
        if (v25)
          operator delete(v25);
      }
      else
      {
        *v25 = v7;
        v26 = v25 + 1;
      }
      *((_QWORD *)this + 61) = v26;
      ++v3;
    }
    while (v3 != v4);
  }
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::markSparseChildComponentIndices(OpenSubdiv::v3_1_1::Vtr::internal::Refinement *this)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *((_QWORD *)this + 1);
  v3 = *(_DWORD *)(v2 + 8);
  if (v3 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)this + 57);
    do
    {
      if ((*(_BYTE *)(v5 + v4) & 1) != 0)
      {
        *(_DWORD *)(*((_QWORD *)this + 30) + 4 * v4) = 2;
        v3 = *(_DWORD *)(v2 + 8);
      }
      ++v4;
    }
    while (v4 < v3);
  }
  OpenSubdiv::v3_1_1::Vtr::internal::Refinement::markSparseEdgeChildren(this);
  return (*(uint64_t (**)(OpenSubdiv::v3_1_1::Vtr::internal::Refinement *))(*(_QWORD *)this + 24))(this);
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateParentChildIndices(uint64_t this)
{
  int v1;
  int *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  _DWORD *v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  int v35;
  _DWORD *v36;
  unint64_t v37;
  unint64_t v38;
  uint64_t v39;
  int *v40;
  unint64_t v41;
  int v42;
  uint64_t v43;
  int v44;
  int *v45;
  unint64_t v46;
  int v47;
  uint64_t v48;
  int v49;
  int v50;
  int *v51;
  unint64_t v52;
  int v53;
  uint64_t v54;
  int v55;
  int v56;
  int *v57;
  unint64_t v58;
  int v59;
  uint64_t v60;
  int v61;
  int v62;
  int v63;
  _DWORD *v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  int v68;
  _DWORD *v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  int v73;
  int *v74;
  unint64_t v75;
  int v76;
  uint64_t v77;
  int v78;
  int v79;
  int v80;
  int *v81;
  unint64_t v82;
  int v83;
  uint64_t v84;
  int v85;
  int v86;
  int v87;
  int *v88;
  unint64_t v89;
  int v90;
  uint64_t v91;
  int v92;
  int v93;
  int v94;
  int *v95;
  unint64_t v96;
  int v97;
  uint64_t v98;
  int v99;
  int v100;

  v1 = *(unsigned __int8 *)(this + 36);
  *(_DWORD *)(this + 64) = 0;
  v2 = *(int **)(this + 120);
  v3 = *(_QWORD *)(this + 128) - (_QWORD)v2;
  v4 = v3 >> 2;
  if (v1)
  {
    if ((int)v4 >= 1)
    {
      v5 = 0;
      do
      {
        v2[v5] = v5;
        ++v5;
      }
      while ((v3 >> 2) != v5);
    }
    *(_DWORD *)(this + 40) = v4;
    *(_DWORD *)(this + 68) = 0;
    v6 = *(_QWORD *)(this + 144);
    v7 = *(_QWORD *)(this + 152) - v6;
    v8 = v7 >> 2;
    if ((int)(v7 >> 2) >= 1)
    {
      v9 = 0;
      v10 = (v7 >> 2);
      do
      {
        *(_DWORD *)(v6 + 4 * v9) = v9;
        ++v9;
      }
      while (v10 != v9);
    }
    *(_DWORD *)(this + 44) = v8;
    *(_DWORD *)(this + 72) = v8;
    v11 = *(_DWORD **)(this + 192);
    v12 = *(_QWORD *)(this + 200) - (_QWORD)v11;
    v13 = v12 >> 2;
    if ((int)(v12 >> 2) >= 1)
    {
      v14 = (v12 >> 2);
      do
      {
        *v11++ = v8;
        LODWORD(v8) = v8 + 1;
        --v14;
      }
      while (v14);
    }
    *(_DWORD *)(this + 48) = v13;
    if (*(_BYTE *)(this + 37))
    {
      *(_DWORD *)(this + 76) = 0;
      v15 = *(_QWORD *)(this + 168);
      v16 = *(_QWORD *)(this + 176) - v15;
      v17 = v16 >> 2;
      if ((int)(v16 >> 2) < 1)
      {
        v20 = 0;
      }
      else
      {
        v18 = 0;
        v19 = (v16 >> 2);
        do
        {
          *(_DWORD *)(v15 + 4 * v18) = v18;
          ++v18;
        }
        while (v19 != v18);
        v20 = *(_DWORD *)(this + 76);
      }
      *(_DWORD *)(this + 52) = v17;
      v30 = v20 + v17;
      *(_DWORD *)(this + 80) = v30;
      v31 = *(_DWORD **)(this + 216);
      v32 = *(_QWORD *)(this + 224) - (_QWORD)v31;
      v33 = v32 >> 2;
      if ((int)(v32 >> 2) >= 1)
      {
        v34 = (v32 >> 2);
        do
        {
          *v31++ = v30++;
          --v34;
        }
        while (v34);
        v30 = *(_DWORD *)(this + 80);
      }
      *(_DWORD *)(this + 56) = v33;
      v35 = v30 + v33;
      *(_DWORD *)(this + 84) = v30 + v33;
      v36 = *(_DWORD **)(this + 240);
      v37 = *(_QWORD *)(this + 248) - (_QWORD)v36;
      v38 = v37 >> 2;
      if ((int)(v37 >> 2) >= 1)
      {
        v39 = (v37 >> 2);
        do
        {
          *v36++ = v35++;
          --v39;
        }
        while (v39);
      }
      *(_DWORD *)(this + 60) = v38;
    }
    else
    {
      *(_DWORD *)(this + 84) = 0;
      v24 = *(_QWORD *)(this + 240);
      v25 = *(_QWORD *)(this + 248) - v24;
      v26 = v25 >> 2;
      if ((int)(v25 >> 2) < 1)
      {
        v29 = 0;
      }
      else
      {
        v27 = 0;
        v28 = (v25 >> 2);
        do
        {
          *(_DWORD *)(v24 + 4 * v27) = v27;
          ++v27;
        }
        while (v28 != v27);
        v29 = *(_DWORD *)(this + 84);
      }
      *(_DWORD *)(this + 60) = v26;
      v63 = v29 + v26;
      *(_DWORD *)(this + 76) = v63;
      v64 = *(_DWORD **)(this + 168);
      v65 = *(_QWORD *)(this + 176) - (_QWORD)v64;
      v66 = v65 >> 2;
      if ((int)(v65 >> 2) >= 1)
      {
        v67 = (v65 >> 2);
        do
        {
          *v64++ = v63++;
          --v67;
        }
        while (v67);
        v63 = *(_DWORD *)(this + 76);
      }
      *(_DWORD *)(this + 52) = v66;
      v68 = v63 + v66;
      *(_DWORD *)(this + 80) = v63 + v66;
      v69 = *(_DWORD **)(this + 216);
      v70 = *(_QWORD *)(this + 224) - (_QWORD)v69;
      v71 = v70 >> 2;
      if ((int)(v70 >> 2) >= 1)
      {
        v72 = (v70 >> 2);
        do
        {
          *v69++ = v68++;
          --v72;
        }
        while (v72);
      }
      *(_DWORD *)(this + 56) = v71;
    }
  }
  else
  {
    if ((int)v4 < 1)
    {
      v23 = 0;
    }
    else
    {
      v21 = 0;
      v22 = (v3 >> 2);
      do
      {
        if (*v2)
          v23 = v21 + 1;
        else
          v23 = v21;
        if (!*v2)
          v21 = -1;
        *v2++ = v21;
        v21 = v23;
        --v22;
      }
      while (v22);
    }
    *(_DWORD *)(this + 40) = v23;
    *(_DWORD *)(this + 68) = 0;
    v40 = *(int **)(this + 144);
    v41 = *(_QWORD *)(this + 152) - (_QWORD)v40;
    if ((int)(v41 >> 2) < 1)
    {
      v44 = 0;
    }
    else
    {
      v42 = 0;
      v43 = (v41 >> 2);
      do
      {
        if (*v40)
          v44 = v42 + 1;
        else
          v44 = v42;
        if (!*v40)
          v42 = -1;
        *v40++ = v42;
        v42 = v44;
        --v43;
      }
      while (v43);
    }
    *(_DWORD *)(this + 44) = v44;
    *(_DWORD *)(this + 72) = v44;
    v45 = *(int **)(this + 192);
    v46 = *(_QWORD *)(this + 200) - (_QWORD)v45;
    if ((int)(v46 >> 2) < 1)
    {
      v47 = 0;
    }
    else
    {
      v47 = 0;
      v48 = (v46 >> 2);
      do
      {
        v49 = v47 + v44;
        if (*v45)
        {
          ++v47;
          v50 = v49;
        }
        else
        {
          v50 = -1;
        }
        *v45++ = v50;
        --v48;
      }
      while (v48);
    }
    *(_DWORD *)(this + 48) = v47;
    if (*(_BYTE *)(this + 37))
    {
      *(_DWORD *)(this + 76) = 0;
      v51 = *(int **)(this + 168);
      v52 = *(_QWORD *)(this + 176) - (_QWORD)v51;
      if ((int)(v52 >> 2) < 1)
      {
        v56 = 0;
        v53 = 0;
      }
      else
      {
        v53 = 0;
        v54 = (v52 >> 2);
        do
        {
          if (*v51)
            v55 = v53;
          else
            v55 = -1;
          if (*v51)
            ++v53;
          *v51++ = v55;
          --v54;
        }
        while (v54);
        v56 = *(_DWORD *)(this + 76);
      }
      *(_DWORD *)(this + 52) = v53;
      v73 = v53 + v56;
      *(_DWORD *)(this + 80) = v73;
      v74 = *(int **)(this + 216);
      v75 = *(_QWORD *)(this + 224) - (_QWORD)v74;
      if ((int)(v75 >> 2) < 1)
      {
        v76 = 0;
      }
      else
      {
        v76 = 0;
        v77 = (v75 >> 2);
        do
        {
          v78 = v76 + v73;
          if (*v74)
          {
            ++v76;
            v79 = v78;
          }
          else
          {
            v79 = -1;
          }
          *v74++ = v79;
          --v77;
        }
        while (v77);
        v73 = *(_DWORD *)(this + 80);
      }
      *(_DWORD *)(this + 56) = v76;
      v80 = v76 + v73;
      *(_DWORD *)(this + 84) = v80;
      v81 = *(int **)(this + 240);
      v82 = *(_QWORD *)(this + 248) - (_QWORD)v81;
      if ((int)(v82 >> 2) < 1)
      {
        v83 = 0;
      }
      else
      {
        v83 = 0;
        v84 = (v82 >> 2);
        do
        {
          v85 = v83 + v80;
          if (*v81)
          {
            ++v83;
            v86 = v85;
          }
          else
          {
            v86 = -1;
          }
          *v81++ = v86;
          --v84;
        }
        while (v84);
      }
      *(_DWORD *)(this + 60) = v83;
    }
    else
    {
      *(_DWORD *)(this + 84) = 0;
      v57 = *(int **)(this + 240);
      v58 = *(_QWORD *)(this + 248) - (_QWORD)v57;
      if ((int)(v58 >> 2) < 1)
      {
        v62 = 0;
        v59 = 0;
      }
      else
      {
        v59 = 0;
        v60 = (v58 >> 2);
        do
        {
          if (*v57)
            v61 = v59;
          else
            v61 = -1;
          if (*v57)
            ++v59;
          *v57++ = v61;
          --v60;
        }
        while (v60);
        v62 = *(_DWORD *)(this + 84);
      }
      *(_DWORD *)(this + 60) = v59;
      v87 = v59 + v62;
      *(_DWORD *)(this + 76) = v87;
      v88 = *(int **)(this + 168);
      v89 = *(_QWORD *)(this + 176) - (_QWORD)v88;
      if ((int)(v89 >> 2) < 1)
      {
        v90 = 0;
      }
      else
      {
        v90 = 0;
        v91 = (v89 >> 2);
        do
        {
          v92 = v90 + v87;
          if (*v88)
          {
            ++v90;
            v93 = v92;
          }
          else
          {
            v93 = -1;
          }
          *v88++ = v93;
          --v91;
        }
        while (v91);
        v87 = *(_DWORD *)(this + 76);
      }
      *(_DWORD *)(this + 52) = v90;
      v94 = v90 + v87;
      *(_DWORD *)(this + 80) = v94;
      v95 = *(int **)(this + 216);
      v96 = *(_QWORD *)(this + 224) - (_QWORD)v95;
      if ((int)(v96 >> 2) < 1)
      {
        v97 = 0;
      }
      else
      {
        v97 = 0;
        v98 = (v96 >> 2);
        do
        {
          v99 = v97 + v94;
          if (*v95)
          {
            ++v97;
            v100 = v99;
          }
          else
          {
            v100 = -1;
          }
          *v95++ = v100;
          --v98;
        }
        while (v98);
      }
      *(_DWORD *)(this + 56) = v97;
    }
  }
  return this;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateFaceParentVectors(std::vector<int> *a1, _BYTE *a2)
{
  std::vector<int>::size_type v4;
  std::vector<int>::pointer begin;
  char *v6;
  BOOL v7;
  unint64_t v8;

  v4 = *a1->__end_cap_.__value_;
  begin = a1[14].__begin_;
  v6 = (char *)((char *)a1[14].__end_ - (char *)begin);
  v7 = v4 >= (unint64_t)v6;
  v8 = v4 - (_QWORD)v6;
  if (v8 != 0 && v7)
  {
    std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Level::FTag>::__append((void **)&a1[14].__begin_, v8);
    v4 = *a1->__end_cap_.__value_;
  }
  else if (!v7)
  {
    a1[14].__end_ = (std::vector<int>::pointer)((char *)begin + v4);
  }
  std::vector<unsigned int>::resize(a1 + 11, v4);
  return OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateFaceParentFromParentFaces((uint64_t)a1, a2);
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateEdgeParentVectors(std::vector<int> *a1, _BYTE *a2)
{
  std::vector<int>::size_type v4;
  std::vector<int>::pointer begin;
  char *v6;
  BOOL v7;
  unint64_t v8;

  v4 = a1->__end_cap_.__value_[1];
  begin = a1[15].__begin_;
  v6 = (char *)((char *)a1[15].__end_ - (char *)begin);
  v7 = v4 >= (unint64_t)v6;
  v8 = v4 - (_QWORD)v6;
  if (v8 != 0 && v7)
  {
    std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Level::FTag>::__append((void **)&a1[15].__begin_, v8);
    v4 = a1->__end_cap_.__value_[1];
  }
  else if (!v7)
  {
    a1[15].__end_ = (std::vector<int>::pointer)((char *)begin + v4);
  }
  std::vector<unsigned int>::resize(a1 + 12, v4);
  OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateEdgeParentFromParentFaces((uint64_t)a1, a2);
  return OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateEdgeParentFromParentEdges((uint64_t)a1, a2);
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexParentVectors(uint64_t a1, _BYTE *a2)
{
  int v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  _BYTE *v9;

  v4 = *(unsigned __int8 *)(a1 + 36);
  v5 = (_QWORD *)(a1 + 384);
  v6 = *(int *)(*(_QWORD *)(a1 + 16) + 8);
  v7 = *(_QWORD *)(a1 + 384);
  v8 = *(_QWORD *)(a1 + 392) - v7;
  if (v4)
  {
    if (v6 > v8)
    {
      v9 = a2;
LABEL_6:
      std::vector<OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::ETag>::__append(v5, v6 - v8, v9);
      goto LABEL_9;
    }
  }
  else if (v6 > v8)
  {
    v9 = a2 + 4;
    goto LABEL_6;
  }
  if (v6 < v8)
    *(_QWORD *)(a1 + 392) = v7 + v6;
LABEL_9:
  std::vector<unsigned int>::resize((std::vector<int> *)(a1 + 312), *(int *)(*(_QWORD *)(a1 + 16) + 8));
  OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexParentFromParentFaces(a1, a2);
  OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexParentFromParentEdges(a1, a2);
  return OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexParentFromParentVertices(a1, a2);
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateFaceParentFromParentFaces(uint64_t result, _BYTE *a2)
{
  int v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL8 v19;
  uint64_t v20;
  uint64_t v21;

  v2 = **(_DWORD **)(result + 8);
  if (*(_BYTE *)(result + 36))
  {
    if (v2 >= 1)
    {
      v3 = 0;
      v4 = *(_DWORD *)(result + 64);
      do
      {
        v5 = *(_DWORD *)(*(_QWORD *)(result + 88) + 8 * v3);
        if (v5 == 4)
        {
          *(_BYTE *)(*(_QWORD *)(result + 336) + v4) = *a2;
          v6 = v4 + 1;
          *(_BYTE *)(*(_QWORD *)(result + 336) + v6) = a2[1];
          v7 = v4 + 2;
          *(_BYTE *)(*(_QWORD *)(result + 336) + v7) = a2[2];
          v8 = v4 + 3;
          *(_BYTE *)(*(_QWORD *)(result + 336) + v8) = a2[3];
          v9 = *(_QWORD *)(result + 264);
          *(_DWORD *)(v9 + 4 * v4) = v3;
          *(_DWORD *)(v9 + 4 * v6) = v3;
          *(_DWORD *)(v9 + 4 * v7) = v3;
          *(_DWORD *)(v9 + 4 * v8) = v3;
          v4 += 4;
        }
        else if (v5 >= 1)
        {
          v10 = 0;
          v11 = v4;
          do
          {
            if (v5 <= 4)
              v12 = v10;
            else
              v12 = 0;
            *(_BYTE *)(*(_QWORD *)(result + 336) + v11) = a2[v12];
            *(_DWORD *)(*(_QWORD *)(result + 264) + 4 * v11) = v3;
            ++v10;
            ++v11;
          }
          while (v5 != v10);
          v4 += v10;
        }
        ++v3;
      }
      while (v3 < **(int **)(result + 8));
    }
  }
  else if (v2 >= 1)
  {
    v13 = 0;
    do
    {
      v14 = (unsigned int *)(*(_QWORD *)(result + 88) + 8 * v13);
      v15 = *v14;
      v16 = (int *)(*(_QWORD *)(result + 120) + 4 * (int)v14[1]);
      if ((*(_BYTE *)(*(_QWORD *)(result + 408) + v13) & 1) != 0 && (_DWORD)v15 == 4)
      {
        *(_BYTE *)(*(_QWORD *)(result + 336) + *v16) = *a2;
        *(_BYTE *)(*(_QWORD *)(result + 336) + v16[1]) = a2[1];
        *(_BYTE *)(*(_QWORD *)(result + 336) + v16[2]) = a2[2];
        *(_BYTE *)(*(_QWORD *)(result + 336) + v16[3]) = a2[3];
        v17 = *(_QWORD *)(result + 264);
        *(_DWORD *)(v17 + 4 * *v16) = v13;
        *(_DWORD *)(v17 + 4 * v16[1]) = v13;
        *(_DWORD *)(v17 + 4 * v16[2]) = v13;
        *(_DWORD *)(v17 + 4 * v16[3]) = v13;
      }
      else if ((int)v15 >= 1)
      {
        v18 = 0;
        v19 = (*(_BYTE *)(*(_QWORD *)(result + 408) + v13) & 1) == 0;
        do
        {
          v20 = v16[v18];
          if ((_DWORD)v20 != -1)
          {
            if ((int)v15 <= 4)
              v21 = v18;
            else
              v21 = 0;
            *(_BYTE *)(*(_QWORD *)(result + 336) + v20) = a2[4 * v19 + v21];
            *(_DWORD *)(*(_QWORD *)(result + 264) + 4 * v16[v18]) = v13;
          }
          ++v18;
        }
        while (v15 != v18);
      }
      ++v13;
    }
    while (v13 < **(int **)(result + 8));
  }
  return result;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateEdgeParentFromParentFaces(uint64_t result, _BYTE *a2)
{
  int v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL8 v19;
  uint64_t v20;
  uint64_t v21;

  v2 = **(_DWORD **)(result + 8);
  if (*(_BYTE *)(result + 36))
  {
    if (v2 >= 1)
    {
      v3 = 0;
      v4 = *(_DWORD *)(result + 68);
      do
      {
        v5 = *(_DWORD *)(*(_QWORD *)(result + 104) + 8 * v3);
        if (v5 == 4)
        {
          *(_BYTE *)(*(_QWORD *)(result + 360) + v4) = *a2;
          v6 = v4 + 1;
          *(_BYTE *)(*(_QWORD *)(result + 360) + v6) = a2[1];
          v7 = v4 + 2;
          *(_BYTE *)(*(_QWORD *)(result + 360) + v7) = a2[2];
          v8 = v4 + 3;
          *(_BYTE *)(*(_QWORD *)(result + 360) + v8) = a2[3];
          v9 = *(_QWORD *)(result + 288);
          *(_DWORD *)(v9 + 4 * v4) = v3;
          *(_DWORD *)(v9 + 4 * v6) = v3;
          *(_DWORD *)(v9 + 4 * v7) = v3;
          *(_DWORD *)(v9 + 4 * v8) = v3;
          v4 += 4;
        }
        else if (v5 >= 1)
        {
          v10 = 0;
          v11 = v4;
          do
          {
            if (v5 <= 4)
              v12 = v10;
            else
              v12 = 0;
            *(_BYTE *)(*(_QWORD *)(result + 360) + v11) = a2[v12];
            *(_DWORD *)(*(_QWORD *)(result + 288) + 4 * v11) = v3;
            ++v10;
            ++v11;
          }
          while (v5 != v10);
          v4 += v10;
        }
        ++v3;
      }
      while (v3 < **(int **)(result + 8));
    }
  }
  else if (v2 >= 1)
  {
    v13 = 0;
    do
    {
      v14 = (unsigned int *)(*(_QWORD *)(result + 104) + 8 * v13);
      v15 = *v14;
      v16 = (int *)(*(_QWORD *)(result + 144) + 4 * (int)v14[1]);
      if ((*(_BYTE *)(*(_QWORD *)(result + 408) + v13) & 1) != 0 && (_DWORD)v15 == 4)
      {
        *(_BYTE *)(*(_QWORD *)(result + 360) + *v16) = *a2;
        *(_BYTE *)(*(_QWORD *)(result + 360) + v16[1]) = a2[1];
        *(_BYTE *)(*(_QWORD *)(result + 360) + v16[2]) = a2[2];
        *(_BYTE *)(*(_QWORD *)(result + 360) + v16[3]) = a2[3];
        v17 = *(_QWORD *)(result + 288);
        *(_DWORD *)(v17 + 4 * *v16) = v13;
        *(_DWORD *)(v17 + 4 * v16[1]) = v13;
        *(_DWORD *)(v17 + 4 * v16[2]) = v13;
        *(_DWORD *)(v17 + 4 * v16[3]) = v13;
      }
      else if ((int)v15 >= 1)
      {
        v18 = 0;
        v19 = (*(_BYTE *)(*(_QWORD *)(result + 408) + v13) & 1) == 0;
        do
        {
          v20 = v16[v18];
          if ((_DWORD)v20 != -1)
          {
            if ((int)v15 <= 4)
              v21 = v18;
            else
              v21 = 0;
            *(_BYTE *)(*(_QWORD *)(result + 360) + v20) = a2[4 * v19 + v21];
            *(_DWORD *)(*(_QWORD *)(result + 288) + 4 * v16[v18]) = v13;
          }
          ++v18;
        }
        while (v15 != v18);
      }
      ++v13;
    }
    while (v13 < **(int **)(result + 8));
  }
  return result;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateEdgeParentFromParentEdges(uint64_t result, _BYTE *a2)
{
  int v2;
  int v3;
  uint64_t v4;
  _DWORD *v5;
  uint64_t v6;
  int *v7;
  uint64_t v8;
  char v9;
  char v10;
  uint64_t v11;
  uint64_t v12;

  v2 = *(_DWORD *)(*(_QWORD *)(result + 8) + 4);
  if (*(_BYTE *)(result + 36))
  {
    if (v2 >= 1)
    {
      v3 = 0;
      v4 = *(int *)(result + 72);
      do
      {
        *(_BYTE *)(*(_QWORD *)(result + 360) + v4) = *a2;
        *(_BYTE *)(*(_QWORD *)(result + 360) + v4 + 1) = a2[1];
        v5 = (_DWORD *)(*(_QWORD *)(result + 288) + 4 * v4);
        *v5 = v3;
        v5[1] = v3++;
        v4 += 2;
      }
      while (v3 < *(_DWORD *)(*(_QWORD *)(result + 8) + 4));
    }
  }
  else if (v2 >= 1)
  {
    v6 = 0;
    do
    {
      v7 = (int *)(*(_QWORD *)(result + 192) + 8 * v6);
      if ((*(_BYTE *)(*(_QWORD *)(result + 432) + v6) & 1) != 0)
      {
        *(_BYTE *)(*(_QWORD *)(result + 360) + *v7) = *a2;
        *(_BYTE *)(*(_QWORD *)(result + 360) + v7[1]) = a2[1];
        v12 = *(_QWORD *)(result + 288);
        *(_DWORD *)(v12 + 4 * *v7) = v6;
        *(_DWORD *)(v12 + 4 * v7[1]) = v6;
      }
      else
      {
        v8 = 0;
        v9 = 1;
        do
        {
          v10 = v9;
          v11 = v7[v8];
          if ((_DWORD)v11 != -1)
          {
            *(_BYTE *)(*(_QWORD *)(result + 360) + v11) = a2[v8 + 4];
            *(_DWORD *)(*(_QWORD *)(result + 288) + 4 * v7[v8]) = v6;
          }
          v9 = 0;
          v8 = 1;
        }
        while ((v10 & 1) != 0);
      }
      ++v6;
    }
    while (v6 < *(int *)(*(_QWORD *)(result + 8) + 4));
  }
  return result;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexParentFromParentFaces(uint64_t result, _BYTE *a2)
{
  int *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;

  if (*(_DWORD *)(result + 52))
  {
    v2 = *(int **)(result + 8);
    v3 = *v2;
    if (*(_BYTE *)(result + 36))
    {
      if (v3 >= 1)
      {
        v4 = 0;
        v5 = *(_QWORD *)(result + 312) + 4 * *(int *)(result + 76);
        do
        {
          *(_DWORD *)(v5 + 4 * v4) = v4;
          ++v4;
        }
        while ((int)v4 < *v2);
      }
    }
    else if (v3 >= 1)
    {
      for (i = 0; i < v3; ++i)
      {
        v7 = *(int *)(*(_QWORD *)(result + 168) + 4 * i);
        if ((_DWORD)v7 != -1)
        {
          if ((*(_BYTE *)(*(_QWORD *)(result + 408) + i) & 1) != 0)
          {
            *(_BYTE *)(*(_QWORD *)(result + 384) + v7) = *a2;
            v2 = *(int **)(result + 8);
          }
          *(_DWORD *)(*(_QWORD *)(result + 312) + 4 * v7) = i;
          v3 = *v2;
        }
      }
    }
  }
  return result;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexParentFromParentEdges(uint64_t result, _BYTE *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *(_QWORD *)(result + 8);
  v3 = *(_DWORD *)(v2 + 4);
  if (*(_BYTE *)(result + 36))
  {
    if (v3 >= 1)
    {
      v4 = 0;
      v5 = *(_QWORD *)(result + 312) + 4 * *(int *)(result + 80);
      do
      {
        *(_DWORD *)(v5 + 4 * v4) = v4;
        ++v4;
      }
      while ((int)v4 < *(_DWORD *)(v2 + 4));
    }
  }
  else if (v3 >= 1)
  {
    v6 = 0;
    do
    {
      v7 = *(int *)(*(_QWORD *)(result + 216) + 4 * v6);
      if ((_DWORD)v7 != -1)
      {
        if ((*(_BYTE *)(*(_QWORD *)(result + 432) + v6) & 1) != 0)
        {
          *(_BYTE *)(*(_QWORD *)(result + 384) + v7) = *a2;
          v2 = *(_QWORD *)(result + 8);
        }
        *(_DWORD *)(*(_QWORD *)(result + 312) + 4 * v7) = v6;
      }
      ++v6;
    }
    while (v6 < *(int *)(v2 + 4));
  }
  return result;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexParentFromParentVertices(uint64_t result, _BYTE *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = *(_QWORD *)(result + 8);
  v3 = *(_DWORD *)(v2 + 8);
  if (*(_BYTE *)(result + 36))
  {
    if (v3 >= 1)
    {
      v4 = 0;
      v5 = *(_QWORD *)(result + 312) + 4 * *(int *)(result + 84);
      do
      {
        *(_DWORD *)(v5 + 4 * v4) = v4;
        ++v4;
      }
      while ((int)v4 < *(_DWORD *)(v2 + 8));
    }
  }
  else if (v3 >= 1)
  {
    v6 = 0;
    do
    {
      v7 = *(int *)(*(_QWORD *)(result + 240) + 4 * v6);
      if ((_DWORD)v7 != -1)
      {
        if ((*(_BYTE *)(*(_QWORD *)(result + 456) + v6) & 1) != 0)
        {
          *(_BYTE *)(*(_QWORD *)(result + 384) + v7) = *a2;
          v2 = *(_QWORD *)(result + 8);
        }
        *(_DWORD *)(*(_QWORD *)(result + 312) + 4 * v7) = v6;
      }
      ++v6;
    }
    while (v6 < *(int *)(v2 + 8));
  }
  return result;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateFaceTagVectors(OpenSubdiv::v3_1_1::Vtr::internal::Refinement *this)
{
  int *v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;

  v2 = (int *)*((_QWORD *)this + 2);
  v3 = *((_QWORD *)v2 + 12);
  v4 = *v2;
  v5 = *((_QWORD *)v2 + 13) - v3;
  if (v4 <= v5)
  {
    if (v4 < v5)
      *((_QWORD *)v2 + 13) = v3 + v4;
  }
  else
  {
    std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Level::FTag>::__append((void **)v2 + 12, v4 - v5);
  }
  return OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateFaceTagsFromParentFaces((uint64_t)this);
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateEdgeTagVectors(OpenSubdiv::v3_1_1::Vtr::internal::Refinement *this)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *((_QWORD *)this + 2);
  v3 = *(_QWORD *)(v2 + 240);
  v4 = *(int *)(v2 + 4);
  v5 = *(_QWORD *)(v2 + 248) - v3;
  if (v4 <= v5)
  {
    if (v4 < v5)
      *(_QWORD *)(v2 + 248) = v3 + v4;
  }
  else
  {
    std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Level::FTag>::__append((void **)(v2 + 240), v4 - v5);
  }
  v6 = *((int *)this + 11);
  if ((int)v6 >= 1)
  {
    v7 = *((int *)this + 17);
    v8 = v7 + v6;
    do
      *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 2) + 240) + v7++) = 0;
    while (v7 < v8);
  }
  return OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateEdgeTagsFromParentEdges((uint64_t)this);
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexTagVectors(OpenSubdiv::v3_1_1::Vtr::internal::Refinement *this)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Level::VTag>::resize(*((_QWORD *)this + 2) + 432, *(int *)(*((_QWORD *)this + 2) + 8));
  OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexTagsFromParentFaces((uint64_t)this);
  OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexTagsFromParentEdges(this);
  result = OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexTagsFromParentVertices((uint64_t)this);
  if (!*((_BYTE *)this + 36))
  {
    v3 = *((_QWORD *)this + 2);
    if (*(int *)(v3 + 8) >= 1)
    {
      v4 = 0;
      do
      {
        if ((*(_BYTE *)(*((_QWORD *)this + 48) + v4) & 1) != 0)
        {
          *(_WORD *)(*(_QWORD *)(v3 + 432) + 2 * v4) |= 0x800u;
          v3 = *((_QWORD *)this + 2);
        }
        ++v4;
      }
      while (v4 < *(int *)(v3 + 8));
    }
  }
  return result;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateFaceTagsFromParentFaces(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(int *)(this + 40);
  if ((int)v1 >= 1)
  {
    v2 = *(int *)(this + 64);
    v3 = v2 + v1;
    do
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(this + 16) + 96) + v2) = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(this + 8) + 96)
                                                                             + *(int *)(*(_QWORD *)(this + 264) + 4 * v2));
      ++v2;
    }
    while (v2 < v3);
  }
  return this;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateEdgeTagsFromParentEdges(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(int *)(this + 48);
  if ((int)v1 >= 1)
  {
    v2 = *(int *)(this + 72);
    v3 = v2 + v1;
    do
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(this + 16) + 240) + v2) = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(this + 8) + 240)
                                                                              + *(int *)(*(_QWORD *)(this + 288) + 4 * v2));
      ++v2;
    }
    while (v2 < v3);
  }
  return this;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexTagsFromParentFaces(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(int *)(this + 52);
  if ((_DWORD)v1)
  {
    v2 = *(int *)(this + 76);
    v3 = v2 + v1;
    if (*(int *)(*(_QWORD *)(this + 8) + 12) <= 0)
    {
      if ((int)v1 >= 1)
      {
        do
        {
          *(_WORD *)(*(_QWORD *)(*(_QWORD *)(this + 16) + 432) + 2 * v2) = 128;
          if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(this + 8) + 24) + 8 * *(int *)(*(_QWORD *)(this + 312) + 4 * v2)) != *(_DWORD *)(this + 32))
            *(_WORD *)(*(_QWORD *)(*(_QWORD *)(this + 16) + 432) + 2 * v2) |= 2u;
          ++v2;
        }
        while (v2 < v3);
      }
    }
    else if ((int)v1 >= 1)
    {
      do
        *(_WORD *)(*(_QWORD *)(*(_QWORD *)(this + 16) + 432) + 2 * v2++) = 128;
      while (v2 < (int)v3);
    }
  }
  return this;
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexTagsFromParentEdges(_QWORD *this)
{
  uint64_t v1;
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  int v7;

  v1 = this[1];
  if (*(int *)(v1 + 4) >= 1)
  {
    v2 = 0;
    v3 = 0;
    do
    {
      v4 = *(int *)(this[27] + 4 * v2);
      if ((_DWORD)v4 != -1)
      {
        v5 = *(unsigned __int8 *)(*(_QWORD *)(v1 + 240) + v2);
        v6 = v3 & 0xFFFF883A;
        if ((v5 & 0xC) != 0)
          v7 = 512;
        else
          v7 = 128;
        v3 = v6 & 0xFFFFCFBA | v5 & 1 | (((v5 >> 3) & 1) << 6) & 0xFFFFCFFF | (((~v5 & 5) == 0) << 14) | (4 * ((v5 >> 1) & 1)) & 0xFFFFCFFF | (((v5 >> 2) & 1) << 12) & 0xFFFFDFFF | (((v5 >> 2) & 1) << 13) | v7;
        *(_WORD *)(*(_QWORD *)(this[2] + 432) + 2 * v4) = v3;
        v1 = this[1];
      }
      ++v2;
    }
    while (v2 < *(int *)(v1 + 4));
  }
  return this;
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::populateVertexTagsFromParentVertices(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(int *)(this + 60);
  if ((int)v1 >= 1)
  {
    v2 = *(int *)(this + 84);
    v3 = v2 + v1;
    do
    {
      *(_WORD *)(*(_QWORD *)(*(_QWORD *)(this + 16) + 432) + 2 * v2) = *(_WORD *)(*(_QWORD *)(*(_QWORD *)(this + 8)
                                                                                              + 432)
                                                                                  + 2
                                                                                  * *(int *)(*(_QWORD *)(this + 312)
                                                                                           + 4 * v2));
      ++v2;
    }
    while (v2 < v3);
  }
  return this;
}

void OpenSubdiv::v3_1_1::Vtr::internal::Refinement::subdivideEdgeSharpness(OpenSubdiv::v3_1_1::Vtr::internal::Refinement *this)
{
  char v2;
  _QWORD *v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  float v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  float *v21;
  int *v22;
  float *v23;
  uint64_t v24;
  uint64_t v25;
  float v26;
  int v27;
  float *v28;
  uint64_t v29;
  uint64_t v30;
  void *__p;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v27 = *((_DWORD *)this + 6);
  v2 = v27;
  v3 = (_QWORD *)*((_QWORD *)this + 2);
  v4 = v3[27];
  v3 += 27;
  v3[1] = v4;
  std::vector<float>::resize(v3, *((int *)v3 - 53));
  v28 = (float *)&v30;
  v29 = 0x1000000000;
  __p = 0;
  v5 = v2 & 0x60;
  if (v5 && (v6 = *(unsigned int *)(*((_QWORD *)this + 1) + 20), v6 >= 0x11))
  {
    operator delete(0);
    v7 = operator new(4 * v6);
    __p = v7;
    v28 = (float *)v7;
    HIDWORD(v29) = v6;
  }
  else
  {
    v7 = 0;
  }
  v8 = *((int *)this + 12);
  if ((int)v8 >= 1)
  {
    v9 = *((int *)this + 18);
    v10 = v9 + v8;
    while (1)
    {
      v11 = *((_QWORD *)this + 2);
      v12 = *(_QWORD *)(v11 + 216);
      v13 = *(_QWORD *)(v11 + 240);
      if ((*(_BYTE *)(v13 + v9) & 4) != 0)
        goto LABEL_20;
      if ((*(_BYTE *)(v13 + v9) & 8) != 0)
        break;
LABEL_23:
      if (++v9 >= v10)
      {
        v7 = __p;
        goto LABEL_25;
      }
    }
    v14 = *(int *)(*((_QWORD *)this + 36) + 4 * v9);
    v15 = (_QWORD *)*((_QWORD *)this + 1);
    v16 = v15[27];
    v17 = *(float *)(v16 + 4 * v14);
    if (v5)
    {
      v18 = *(int *)(v15[15]
                   + 8 * v14
                   + 4 * (((unint64_t)*(unsigned __int8 *)(*((_QWORD *)this + 45) + v9) >> 3) & 3));
      v19 = v15[42];
      v20 = *(unsigned int *)(v19 + 8 * (_DWORD)v18);
      v21 = v28;
      if ((int)v20 >= 1)
      {
        v22 = (int *)(v15[45] + 4 * *(int *)(v19 + 8 * v18 + 4));
        v23 = v28;
        v24 = v20;
        do
        {
          v25 = *v22++;
          *v23++ = *(float *)(v16 + 4 * v25);
          --v24;
        }
        while (v24);
      }
      v26 = OpenSubdiv::v3_1_1::Sdc::Crease::SubdivideEdgeSharpnessAtVertex((OpenSubdiv::v3_1_1::Sdc::Crease *)&v27, v17, v20, v21);
      goto LABEL_14;
    }
    if (v17 <= 0.0)
      goto LABEL_21;
    if (v17 < 10.0)
    {
      if (v17 <= 1.0)
      {
LABEL_21:
        *(_DWORD *)(v12 + 4 * v9) = 0;
      }
      else
      {
        v26 = v17 + -1.0;
LABEL_14:
        *(float *)(v12 + 4 * v9) = v26;
        if (v26 > 0.0)
          goto LABEL_23;
      }
      *(_BYTE *)(v13 + v9) &= ~8u;
      goto LABEL_23;
    }
LABEL_20:
    *(_DWORD *)(v12 + 4 * v9) = 1092616192;
    goto LABEL_23;
  }
LABEL_25:
  operator delete(v7);
}

void OpenSubdiv::v3_1_1::Vtr::internal::Refinement::subdivideVertexSharpness(OpenSubdiv::v3_1_1::Vtr::internal::Refinement *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int16 v9;
  float v10;
  float v11;

  v2 = *((_QWORD *)this + 2);
  *(_QWORD *)(v2 + 416) = *(_QWORD *)(v2 + 408);
  std::vector<float>::resize((_QWORD *)(v2 + 408), *(int *)(v2 + 8));
  v3 = *((int *)this + 15);
  if ((int)v3 >= 1)
  {
    v4 = *((int *)this + 21);
    v5 = v4 + v3;
    while (1)
    {
      v6 = *((_QWORD *)this + 2);
      v7 = *(_QWORD *)(v6 + 408);
      v8 = *(_QWORD *)(v6 + 432);
      v9 = *(_WORD *)(v8 + 2 * v4);
      if ((v9 & 0x10) != 0)
        goto LABEL_10;
      if ((v9 & 0x20) != 0)
        break;
LABEL_13:
      if (++v4 >= v5)
        return;
    }
    v10 = *(float *)(*(_QWORD *)(*((_QWORD *)this + 1) + 408) + 4 * *(int *)(*((_QWORD *)this + 39) + 4 * v4));
    if (v10 <= 0.0)
      goto LABEL_11;
    if (v10 < 10.0)
    {
      if (v10 <= 1.0)
      {
LABEL_11:
        *(_DWORD *)(v7 + 4 * v4) = 0;
      }
      else
      {
        v11 = v10 + -1.0;
        *(float *)(v7 + 4 * v4) = v11;
        if (v11 > 0.0)
          goto LABEL_13;
      }
      *(_WORD *)(v8 + 2 * v4) &= ~0x20u;
      goto LABEL_13;
    }
LABEL_10:
    *(_DWORD *)(v7 + 4 * v4) = 1092616192;
    goto LABEL_13;
  }
}

uint64_t OpenSubdiv::v3_1_1::Vtr::internal::Refinement::reclassifySemisharpVertices(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int *v7;
  int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  __int16 v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  unsigned int v19;
  _QWORD *v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int *v26;
  int32x2_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int *v33;
  unsigned __int16 *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __int32 v38;
  __int16 v39;
  __int32 v40;
  __int16 v41;
  int v42;
  int v43;
  __int16 v44;

  v1 = *(int *)(this + 56);
  if ((int)v1 >= 1)
  {
    v2 = *(int *)(this + 80);
    v3 = v2 + v1;
    do
    {
      v4 = *(_QWORD *)(this + 16);
      v5 = *(_QWORD *)(v4 + 432);
      v6 = *(unsigned __int16 *)(v5 + 2 * v2);
      if ((v6 & 0x40) != 0)
      {
        v7 = (int *)(*(_QWORD *)(this + 192) + 8 * *(int *)(*(_QWORD *)(this + 312) + 4 * v2));
        if ((*(_BYTE *)(*(_QWORD *)(this + 384) + v2) & 1) != 0)
        {
          v10 = *v7;
          if ((_DWORD)v10 != -1 && (*(_BYTE *)(*(_QWORD *)(v4 + 240) + v10) & 8) != 0)
          {
            v12 = v6 & 0xF83F | 0x40;
            v13 = 512;
          }
          else
          {
            v11 = v7[1];
            if ((_DWORD)v11 == -1)
            {
              v12 = v6 & 0xF83F;
              v13 = 128;
            }
            else
            {
              v12 = v6 & 0xF83F;
              if ((*(_BYTE *)(*(_QWORD *)(v4 + 240) + v11) & 8) != 0)
              {
                v12 |= 0x40u;
                v13 = 512;
              }
              else
              {
                v13 = 128;
              }
            }
          }
          LOWORD(v9) = v13 | v12;
        }
        else
        {
          v8 = ((*(unsigned __int8 *)(*(_QWORD *)(v4 + 240) + v7[1]) >> 3) & 1)
             + ((*(unsigned __int8 *)(*(_QWORD *)(v4 + 240) + *v7) >> 3) & 1);
          v9 = v6 & 0xFFFFF83F | ((v8 != 0) << 6) | (128 << v8);
        }
        *(_WORD *)(v5 + 2 * v2) = v9;
      }
      ++v2;
    }
    while (v2 < v3);
  }
  v14 = *(int *)(this + 60);
  if ((int)v14 >= 1)
  {
    v15 = *(int *)(this + 84);
    v16 = v15 + v14;
    while (1)
    {
      v17 = *(int *)(*(_QWORD *)(this + 312) + 4 * v15);
      v18 = *(_QWORD **)(this + 8);
      v19 = *(unsigned __int16 *)(v18[54] + 2 * v17);
      if ((v19 & 0x60) != 0)
      {
        v20 = *(_QWORD **)(this + 16);
        v21 = v20[54];
        v22 = *(_WORD *)(v21 + 2 * v15);
        if ((v19 & 0x40) != 0 || (((v22 & 0x20) == 0) & (v19 >> 5)) != 0)
          break;
      }
LABEL_37:
      if (++v15 >= v16)
        return this;
    }
    v23 = v20[45];
    if ((int)((unint64_t)(v20[46] - v23) >> 2) < 1)
    {
      v30 = v18[42];
      v31 = *(unsigned int *)(v30 + 8 * (_DWORD)v17);
      if ((int)v31 >= 1)
      {
        v32 = *(int *)(v30 + 8 * v17 + 4);
        v33 = (int *)(v18[45] + 4 * v32);
        v34 = (unsigned __int16 *)(v18[48] + 2 * v32);
        v27 = 0;
        v35 = v20[30];
        do
        {
          v36 = *v33++;
          v37 = *(_QWORD *)(this + 192) + 8 * v36;
          LODWORD(v36) = *v34++;
          v27 = vadd_s32(v27, (int32x2_t)(*(_QWORD *)&vshl_u32((uint32x2_t)vand_s8((int8x8_t)vdup_n_s32(*(unsigned __int8 *)(v35+ *(int *)(v37 + 4 * v36))), (int8x8_t)0xFF000000FFLL), (uint32x2_t)0xFFFFFFFEFFFFFFFDLL) & 0xFFFFFFC1FFFFFFC1));
          --v31;
        }
        while (v31);
        goto LABEL_30;
      }
    }
    else
    {
      v24 = v20[42];
      v25 = *(unsigned int *)(v24 + 8 * (int)v15);
      if ((int)v25 >= 1)
      {
        v26 = (int *)(v23 + 4 * *(int *)(v24 + 8 * (_DWORD)v15 + 4));
        v27 = 0;
        v28 = v20[30];
        do
        {
          v29 = *v26++;
          v27 = vadd_s32(v27, (int32x2_t)(*(_QWORD *)&vshl_u32((uint32x2_t)vand_s8((int8x8_t)vdup_n_s32(*(unsigned __int8 *)(v28 + v29)), (int8x8_t)0xFF000000FFLL), (uint32x2_t)0xFFFFFFFEFFFFFFFDLL) & 0xFFFFFFC1FFFFFFC1));
          --v25;
        }
        while (v25);
LABEL_30:
        v38 = v27.i32[0];
        v39 = (v27.i32[0] > 0) << 6;
        v40 = v27.i32[1];
        goto LABEL_32;
      }
    }
    v40 = 0;
    v38 = 0;
    v39 = 0;
LABEL_32:
    v41 = v39 | v22 & 0xFFBF;
    *(_WORD *)(v21 + 2 * v15) = v41;
    if ((v22 & 0x30) == 0)
    {
      v42 = v38 + v40;
      v43 = ((1 << (v38 + v40)) & 0xF) << 7;
      if (v42 <= 2)
        v44 = v43;
      else
        v44 = 1024;
      *(_WORD *)(v21 + 2 * v15) = v44 | v41 & 0xF87F;
    }
    goto LABEL_37;
  }
  return this;
}

void std::vector<float>::resize(_QWORD *a1, unint64_t a2)
{
  char *v4;
  char *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  int v19;
  char *v20;

  v5 = (char *)*a1;
  v4 = (char *)a1[1];
  v6 = (uint64_t)&v4[-*a1] >> 2;
  if (a2 <= v6)
  {
    if (a2 < v6)
      a1[1] = &v5[4 * a2];
  }
  else
  {
    v7 = a2 - v6;
    v8 = (uint64_t)(a1 + 2);
    v9 = a1[2];
    if (a2 - v6 <= (v9 - (uint64_t)v4) >> 2)
    {
      v20 = &v4[4 * v7];
      bzero(v4, 4 * v7);
      a1[1] = v20;
    }
    else
    {
      if (a2 >> 62)
        abort();
      v10 = v9 - (_QWORD)v5;
      v11 = (v9 - (uint64_t)v5) >> 1;
      if (v11 <= a2)
        v11 = a2;
      if (v10 >= 0x7FFFFFFFFFFFFFFCLL)
        v12 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v12 = v11;
      v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<float>>(v8, v12);
      v15 = v14;
      v16 = (char *)*a1;
      v17 = (char *)a1[1];
      v18 = &v13[4 * v6];
      bzero(v18, 4 * v7);
      while (v17 != v16)
      {
        v19 = *((_DWORD *)v17 - 1);
        v17 -= 4;
        *((_DWORD *)v18 - 1) = v19;
        v18 -= 4;
      }
      *a1 = v18;
      a1[1] = &v13[4 * a2];
      a1[2] = &v13[4 * v15];
      if (v16)
        operator delete(v16);
    }
  }
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::Refinement::markSparseEdgeChildren(_QWORD *this)
{
  uint64_t v1;
  uint64_t i;
  _DWORD *v3;
  uint64_t v4;
  int *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  int *v13;
  int *v14;
  uint64_t v15;
  int v16;
  char v17;
  uint64_t v18;
  uint64_t v19;

  v1 = this[1];
  if (*(int *)(v1 + 4) >= 1)
  {
    for (i = 0; i < *(int *)(v1 + 4); ++i)
    {
      v3 = (_DWORD *)(this[24] + 8 * i);
      v4 = this[54];
      if ((*(_BYTE *)(v4 + i) & 1) != 0)
      {
        v7 = 2;
        *v3 = 2;
      }
      else
      {
        v5 = (int *)(*(_QWORD *)(v1 + 120) + 8 * i);
        v6 = this[57];
        if ((*(_BYTE *)(v6 + *v5) & 1) != 0)
        {
          *v3 = 1;
          *(_DWORD *)(this[27] + 4 * i) = 1;
        }
        if ((*(_BYTE *)(v6 + v5[1]) & 1) == 0)
          goto LABEL_10;
        v7 = 1;
      }
      v3[1] = v7;
      *(_DWORD *)(this[27] + 4 * i) = v7;
LABEL_10:
      v8 = *(_QWORD *)(v1 + 168);
      v9 = *(_QWORD *)(v1 + 144);
      v10 = *(int *)(v9 + ((8 * i) | 4));
      v11 = *(unsigned int *)(v9 + 8 * i);
      if ((_DWORD)v11 == 2)
      {
        v12 = *(_BYTE *)(v4 + i) & 0xE1 | (2
                                         * ((*(_BYTE *)(this[51] + *(int *)(v8 + 4 * v10 + 4)) ^ *(_BYTE *)(this[51] + *(int *)(v8 + 4 * v10))) & 1));
      }
      else if ((int)v11 > 1)
      {
        v13 = (int *)(v8 + 4 * v10);
        v15 = *v13;
        v14 = v13 + 1;
        v16 = *(unsigned __int8 *)(this[51] + v15);
        v17 = *(_BYTE *)(v4 + i) & 0xE1;
        *(_BYTE *)(v4 + i) = v17;
        v18 = v11 - 1;
        while (1)
        {
          v19 = *v14++;
          if (((*(unsigned __int8 *)(this[51] + v19) ^ v16) & 1) != 0)
            break;
          if (!--v18)
            goto LABEL_20;
        }
        v12 = v17 | 2;
      }
      else
      {
        v12 = *(_BYTE *)(v4 + i) & 0xE1;
      }
      *(_BYTE *)(v4 + i) = v12;
LABEL_20:
      v1 = this[1];
    }
  }
  return this;
}

void std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Refinement::SparseTag>::__append(_QWORD *a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  unint64_t v7;
  unint64_t v8;
  size_t v9;
  void *v10;
  _BYTE *v11;
  char *v12;
  char *v13;
  _BYTE *v14;
  _BYTE *v15;
  char v16;

  v2 = a2;
  v5 = (_BYTE *)a1[1];
  v4 = a1[2];
  if (v4 - (uint64_t)v5 >= a2)
  {
    if (a2)
    {
      v11 = &v5[a2];
      do
      {
        *v5++ &= 0xE0u;
        --v2;
      }
      while (v2);
      v5 = v11;
    }
    a1[1] = v5;
  }
  else
  {
    v6 = &v5[-*a1];
    v7 = (unint64_t)&v6[a2];
    if ((uint64_t)&v6[a2] < 0)
      abort();
    v8 = v4 - *a1;
    if (2 * v8 > v7)
      v7 = 2 * v8;
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL)
      v9 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v9 = v7;
    if (v9)
      v10 = operator new(v9);
    else
      v10 = 0;
    v12 = &v6[(_QWORD)v10];
    v13 = &v6[(_QWORD)v10 + v2];
    v14 = &v6[(_QWORD)v10];
    do
    {
      *v14++ &= 0xE0u;
      --v2;
    }
    while (v2);
    v15 = (_BYTE *)*a1;
    if (v5 != (_BYTE *)*a1)
    {
      do
      {
        v16 = *--v5;
        *--v12 = v16;
      }
      while (v5 != v15);
      v5 = (_BYTE *)*a1;
    }
    *a1 = v12;
    a1[1] = v13;
    a1[2] = (char *)v10 + v9;
    if (v5)
      operator delete(v5);
  }
}

uint64_t OpenSubdiv::v3_1_1::Far::Error(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9;
  const char *v10;
  char __str[10240];
  uint64_t v13;

  v9 = MEMORY[0x24BDAC7A8](a1);
  v13 = *MEMORY[0x24BDAC8D0];
  vsnprintf(__str, 0x2800uLL, v10, &a9);
  return printf("%s: %s\n", OpenSubdiv::v3_1_1::Far::Error(OpenSubdiv::v3_1_1::Far::ErrorType,char const*,...)::errorTypeLabel[v9], __str);
}

uint64_t OpenSubdiv::v3_1_1::Far::Warning(OpenSubdiv::v3_1_1::Far *this, const char *a2, ...)
{
  const char *v2;
  char __str[10240];
  uint64_t v5;
  va_list va;

  va_start(va, a2);
  v2 = (const char *)MEMORY[0x24BDAC7A8](this);
  v5 = *MEMORY[0x24BDAC8D0];
  vsnprintf(__str, 0x2800uLL, v2, va);
  return fprintf((FILE *)*MEMORY[0x24BDAC8E8], "Warning: %s\n", __str);
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::applyRefinement(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_WORD *)(*((_QWORD *)this + 4) + 8) = *(_WORD *)(*((_QWORD *)this + 2) + 8);
  v2 = *((_QWORD *)this + 2);
  v3 = *((_QWORD *)this + 4);
  *(_BYTE *)(v3 + 12) = *(_BYTE *)(v2 + 12);
  *(_WORD *)(v3 + 13) = *(_WORD *)(v2 + 13);
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::estimateAndAllocateChildValues(this);
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::populateChildValues(this);
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::trimAndFinalizeChildValues(this);
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::propagateEdgeTags(this);
  OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::propagateValueTags((int **)this);
  v4 = *((_QWORD *)this + 4);
  if (!*(_BYTE *)(v4 + 13))
  {
    OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::propagateValueCreases(this);
    OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::reclassifySemisharpValues(this);
    v4 = *((_QWORD *)this + 4);
  }
  if (*(_DWORD *)(v4 + 16) <= *(_DWORD *)(*((_QWORD *)this + 3) + 8))
    return memcpy(*(void **)(v4 + 24), *(const void **)(*(_QWORD *)v4 + 48), ((uint64_t)((*(_QWORD *)(*(_QWORD *)v4 + 56) - *(_QWORD *)(*(_QWORD *)v4 + 48)) << 30) >> 30) & 0xFFFFFFFFFFFFFFFCLL);
  else
    return OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::initializeFaceValuesFromVertexFaceSiblings((_QWORD *)v4);
}

void OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::estimateAndAllocateChildValues(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *this)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  __int16 v16;

  v2 = *(_QWORD *)this;
  v3 = *(_DWORD *)(*(_QWORD *)this + 52);
  v4 = *(int *)(*(_QWORD *)this + 56);
  if ((int)v4 >= 1)
  {
    v5 = *(int *)(v2 + 80);
    v6 = v5 + v4;
    do
    {
      v7 = *(int *)(*(_QWORD *)(v2 + 312) + 4 * v5);
      if ((*(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 2) + 48) + v7) & 1) != 0)
        v8 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 1) + 144) + 8 * v7);
      else
        v8 = 1;
      v3 += v8;
      ++v5;
    }
    while (v5 < v6);
  }
  v9 = *(int *)(v2 + 60);
  if ((int)v9 >= 1)
  {
    v10 = *(int *)(v2 + 84);
    v11 = v10 + v9;
    v12 = *(_QWORD *)(v2 + 312);
    do
      v3 += *(unsigned __int16 *)(*(_QWORD *)(*((_QWORD *)this + 2) + 72) + 2 * *(int *)(v12 + 4 * v10++));
    while (v10 < v11);
  }
  OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::resizeComponents(*((std::vector<int> **)this + 4));
  v13 = *((_QWORD *)this + 4);
  v14 = *(_QWORD *)(v13 + 168);
  v15 = *(_QWORD *)(v13 + 176) - v14;
  if (v3 <= v15)
  {
    if (v3 < v15)
      *(_QWORD *)(v13 + 176) = v14 + v3;
  }
  else
  {
    std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Level::FTag>::__append((void **)(v13 + 168), v3 - v15);
  }
  v16 = 0;
  std::vector<unsigned short>::resize((uint64_t)this + 40, v3, &v16);
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::populateChildValues(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *this)
{
  *(_DWORD *)(*((_QWORD *)this + 4) + 16) = 0;
  if (*(_BYTE *)(*(_QWORD *)this + 37))
  {
    OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::populateChildValuesFromFaceVertices(this);
    OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::populateChildValuesFromEdgeVertices(this);
    return OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::populateChildValuesFromVertexVertices(this);
  }
  else
  {
    OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::populateChildValuesFromVertexVertices(this);
    OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::populateChildValuesFromFaceVertices(this);
    return OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::populateChildValuesFromEdgeVertices(this);
  }
}

void OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::trimAndFinalizeChildValues(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *this)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *((_QWORD *)this + 4);
  v3 = *(_QWORD *)(v2 + 168);
  v4 = *(int *)(v2 + 16);
  v5 = *(_QWORD *)(v2 + 176) - v3;
  if (v4 <= v5)
  {
    if (v4 < v5)
      *(_QWORD *)(v2 + 176) = v3 + v4;
  }
  else
  {
    std::vector<OpenSubdiv::v3_1_1::Vtr::internal::Level::FTag>::__append((void **)(v2 + 168), v4 - v5);
    v2 = *((_QWORD *)this + 4);
  }
  if (!*(_BYTE *)(v2 + 13))
  {
    std::vector<OpenSubdiv::v3_1_1::Vtr::internal::FVarLevel::CreaseEndPair>::resize(v2 + 192, *(int *)(v2 + 16));
    v2 = *((_QWORD *)this + 4);
  }
  std::vector<unsigned short>::resize((uint64_t)this + 40, *(int *)(v2 + 16));
  std::vector<unsigned int>::resize((std::vector<int> *)(*((_QWORD *)this + 4) + 144), *(int *)(*((_QWORD *)this + 4) + 16));
  v6 = *((_QWORD *)this + 4);
  if (*(int *)(v6 + 16) >= 1)
  {
    v7 = 0;
    v8 = *(_QWORD *)(v6 + 144);
    do
    {
      *(_DWORD *)(v8 + 4 * v7) = v7;
      ++v7;
    }
    while (v7 < *(int *)(v6 + 16));
  }
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::propagateEdgeTags(_QWORD *this)
{
  uint64_t v1;
  uint64_t v2;

  LODWORD(v1) = *(_DWORD *)(*this + 44);
  if ((int)v1 >= 1)
  {
    v2 = 0;
    do
      *(_BYTE *)(*(_QWORD *)(this[4] + 48) + v2++) = 0;
    while (v2 < *(int *)(*this + 44));
    LODWORD(v1) = *(_DWORD *)(*this + 44);
  }
  if ((int)v1 < *(_DWORD *)(this[3] + 4))
  {
    v1 = (int)v1;
    do
    {
      *(_BYTE *)(*(_QWORD *)(this[4] + 48) + v1) = *(_BYTE *)(*(_QWORD *)(this[2] + 48)
                                                              + *(int *)(*(_QWORD *)(*this + 288) + 4 * v1));
      ++v1;
    }
    while (v1 < *(int *)(this[3] + 4));
  }
  return this;
}

int **OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::propagateValueTags(int **this)
{
  int **v1;
  int *v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v1 = this;
  v2 = *this;
  v3 = (*this)[13];
  if (v3 >= 1)
  {
    v4 = v2[19];
    v5 = v3 + v4;
    v6 = *(int *)(*((_QWORD *)this[4] + 12) + 4 * v4);
    do
    {
      *(_BYTE *)(*((_QWORD *)this[4] + 21) + v6) = 0;
      ++v4;
      ++v6;
    }
    while (v4 < v5);
    v2 = *this;
  }
  v7 = v2[14];
  if ((int)v7 >= 1)
  {
    v8 = v2[20];
    v9 = v8 + v7;
    if (*((_BYTE *)this[2] + 13))
      v10 = 1;
    else
      v10 = 9;
    do
    {
      v11 = v1[4];
      v12 = *((_QWORD *)v11 + 9);
      if (*(_WORD *)(v12 + 2 * v8))
      {
        if ((*(_BYTE *)(*((_QWORD *)v1[2] + 6) + *(int *)(*((_QWORD *)*v1 + 39) + 4 * v8)) & 9) != 0)
          v13 = v10;
        else
          v13 = 0;
        this = (int **)memset((void *)(*((_QWORD *)v11 + 21) + *(int *)(*((_QWORD *)v11 + 12) + 4 * v8)), v13, *(unsigned __int16 *)(v12 + 2 * v8));
      }
      ++v8;
    }
    while (v8 < v9);
    v2 = *v1;
  }
  v14 = v2[15];
  if ((int)v14 >= 1)
  {
    v15 = v2[21];
    v16 = v15 + v14;
    do
    {
      v17 = *(int *)(*((_QWORD *)*v1 + 39) + 4 * v15);
      this = (int **)memcpy((void *)(*((_QWORD *)v1[4] + 21) + *(int *)(*((_QWORD *)v1[4] + 12) + 4 * v15++)), (const void *)(*((_QWORD *)v1[2] + 21) + *(int *)(*((_QWORD *)v1[2] + 12) + 4 * v17)), *(unsigned __int16 *)(*((_QWORD *)v1[2] + 9) + 2 * v17));
    }
    while (v15 < v16);
  }
  return this;
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::propagateValueCreases(_QWORD *this)
{
  uint64_t v1;
  __int16 v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  __int16 v13;
  _WORD *v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  _DWORD *v23;
  _DWORD *v24;
  char v25;

  v1 = *this;
  if (*(_DWORD *)(*this + 32) == 4)
    v2 = 2;
  else
    v2 = 3;
  v3 = *(int *)(v1 + 56);
  if ((int)v3 >= 1)
  {
    v4 = *(int *)(v1 + 80);
    v5 = v4 + v3;
    v6 = (_QWORD *)this[4];
    v7 = v6[9];
    v8 = v6[12];
    v9 = v6[21];
    do
    {
      v10 = *(int *)(v8 + 4 * v4);
      v11 = (char *)(v9 + v10);
      if ((*(_BYTE *)(v9 + v10) & 1) != 0 && (*(_BYTE *)(*(_QWORD *)(v1 + 384) + v4) & 1) == 0)
      {
        v12 = *(unsigned __int16 *)(v7 + 2 * v4);
        if (*(_WORD *)(v7 + 2 * v4))
        {
          v13 = 0;
          v14 = (_WORD *)(v6[24] + 4 * v10 + 2);
          do
          {
            v15 = *v11++;
            if ((v15 & 0x18) != 0)
            {
              *(v14 - 1) = v13;
              *v14 = v2 - 1 + v13;
            }
            v13 += v2;
            v14 += 2;
            --v12;
          }
          while (v12);
        }
      }
      ++v4;
    }
    while (v4 < v5);
  }
  v16 = *(int *)(v1 + 60);
  if ((int)v16 >= 1)
  {
    v17 = *(int *)(v1 + 84);
    v18 = v17 + v16;
    do
    {
      v19 = (_QWORD *)this[4];
      v20 = *(int *)(v19[12] + 4 * v17);
      v21 = (char *)(v19[21] + v20);
      if ((*v21 & 1) != 0 && (*(_BYTE *)(*(_QWORD *)(*this + 384) + v17) & 1) == 0)
      {
        v22 = *(unsigned __int16 *)(v19[9] + 2 * v17);
        if (*(_WORD *)(v19[9] + 2 * v17))
        {
          v23 = (_DWORD *)(*(_QWORD *)(this[2] + 192)
                         + 4
                         * *(int *)(*(_QWORD *)(this[2] + 96) + 4 * *(int *)(*(_QWORD *)(*this + 312) + 4 * v17)));
          v24 = (_DWORD *)(v19[24] + 4 * v20);
          do
          {
            v25 = *v21++;
            if ((v25 & 0x18) != 0)
              *v24 = *v23;
            ++v24;
            ++v23;
            --v22;
          }
          while (v22);
        }
      }
      ++v17;
    }
    while (v17 < v18);
  }
  return this;
}

void OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::reclassifySemisharpValues(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *this)
{
  void *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  unsigned __int16 *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  char v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  unint64_t v38;
  char v39;
  uint64_t *v40;
  uint64_t v41;
  void *__p;
  uint64_t v43;

  v2 = 0;
  v43 = *MEMORY[0x24BDAC8D0];
  v3 = *(unsigned __int8 *)(*((_QWORD *)this + 2) + 14);
  v4 = *(unsigned int *)(*((_QWORD *)this + 3) + 20);
  v40 = &v41;
  __p = 0;
  if (v4 >= 0x11)
  {
    v2 = operator new(4 * v4);
    __p = v2;
    v40 = (uint64_t *)v2;
  }
  v5 = *(int *)(*(_QWORD *)this + 60);
  if ((int)v5 >= 1)
  {
    v6 = *(int *)(*(_QWORD *)this + 84);
    v7 = v6 + v5;
    while (1)
    {
      v8 = (_QWORD *)*((_QWORD *)this + 4);
      v9 = *(int *)(v8[12] + 4 * v6);
      v10 = (char *)(v8[21] + v9);
      if ((*v10 & 1) == 0)
        goto LABEL_9;
      v11 = *(_QWORD *)this;
      if ((*(_BYTE *)(*(_QWORD *)(*(_QWORD *)this + 384) + v6) & 1) != 0)
        goto LABEL_9;
      v12 = *(int *)(*(_QWORD *)(v11 + 312) + 4 * v6);
      v13 = (_QWORD *)*((_QWORD *)this + 1);
      if ((*(_WORD *)(v13[54] + 2 * v12) & 0x60) == 0)
        goto LABEL_9;
      v14 = (_QWORD *)*((_QWORD *)this + 3);
      v15 = *(_WORD *)(v14[54] + 2 * v6);
      if ((v15 & 0x30) != 0)
        goto LABEL_9;
      v16 = *(unsigned __int16 *)(v8[9] + 2 * v6);
      if ((v15 & 0x40) == 0)
      {
        if (*(_WORD *)(v8[9] + 2 * v6))
        {
          do
          {
            if ((*v10 & 0x10) != 0)
              *v10 = *v10 & 0xC7 | 8;
            ++v10;
            --v16;
          }
          while (v16);
        }
        goto LABEL_9;
      }
      v17 = v8[24];
      v18 = v14[45];
      if (((v14[46] - v18) & 0x3FFFFFFFCLL) != 0)
      {
        v20 = v14[42];
        v19 = (uint64_t *)(v18 + 4 * *(int *)(v20 + 8 * (_DWORD)v6 + 4));
        LODWORD(v20) = *(_DWORD *)(v20 + 8 * (int)v6);
      }
      else
      {
        v21 = v13[42];
        v20 = *(unsigned int *)(v21 + 8 * (_DWORD)v12);
        v19 = v40;
        if ((int)v20 >= 1)
        {
          v22 = 0;
          v23 = *(int *)(v21 + 8 * v12 + 4);
          v24 = v13[45] + 4 * v23;
          v25 = v13[48] + 2 * v23;
          v26 = *(_QWORD *)(v11 + 192);
          do
          {
            *((_DWORD *)v40 + v22) = *(_DWORD *)(v26
                                               + 8 * *(int *)(v24 + 4 * v22)
                                               + 4 * *(unsigned __int16 *)(v25 + 2 * v22));
            ++v22;
          }
          while (v20 != v22);
        }
      }
      if ((_DWORD)v16)
        break;
LABEL_9:
      if (++v6 >= v7)
      {
        v2 = __p;
        goto LABEL_49;
      }
    }
    v27 = 0;
    v28 = v17 + 4 * v9;
    while (1)
    {
      v29 = v10[v27];
      if ((v29 & 0x30) == 0x10)
      {
        v30 = (unsigned __int16 *)(v28 + 4 * v27);
        v31 = *v30;
        v32 = v30[1];
        if (v32 <= v31)
        {
          if (v31 <= v32)
            goto LABEL_39;
          v35 = *(_QWORD *)(*((_QWORD *)this + 3) + 240);
          if ((int)v31 + 1 < (int)v20)
          {
            do
            {
              v36 = *(_BYTE *)(v35 + *((int *)v19 + v31 + 1));
              if ((v36 & 8) != 0)
                break;
              v37 = v31 + 2;
              ++v31;
            }
            while (v37 < (int)v20);
            if ((v36 & 8) != 0)
              goto LABEL_40;
          }
          v38 = 0;
          do
          {
            v34 = *(_BYTE *)(v35 + *((int *)v19 + v38));
            if (v38 >= v32)
              break;
            ++v38;
          }
          while ((v34 & 8) == 0);
        }
        else
        {
          v33 = v31 + 1;
          do
          {
            v34 = *(_BYTE *)(*(_QWORD *)(*((_QWORD *)this + 3) + 240) + *((int *)v19 + v33));
            if (v33 >= v32)
              break;
            ++v33;
          }
          while ((v34 & 8) == 0);
        }
        if ((v34 & 8) == 0)
LABEL_39:
          v10[v27] = v29 & 0xC7 | 8;
      }
LABEL_40:
      if (++v27 == v16)
      {
        if (v3 && (_DWORD)v16 == 2)
        {
          v39 = *v10;
          if ((*v10 & 0x20) != 0 && (v10[1] & 0x10) == 0)
          {
LABEL_48:
            *v10 = v39 & 0xDF;
          }
          else if ((*v10 & 0x10) == 0 && (v10[1] & 0x20) != 0)
          {
            v39 = *++v10;
            goto LABEL_48;
          }
        }
        goto LABEL_9;
      }
    }
  }
LABEL_49:
  operator delete(v2);
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::populateChildValuesFromFaceVertices(_QWORD *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;

  v1 = *(int *)(*this + 52);
  if ((int)v1 >= 1)
  {
    v2 = *(int *)(*this + 76);
    v3 = v2 + v1;
    v4 = this[4];
    v5 = *(_QWORD *)(v4 + 96);
    v6 = *(_QWORD *)(v4 + 72);
    v7 = *(_DWORD *)(v4 + 16);
    do
    {
      *(_DWORD *)(v5 + 4 * v2) = v7;
      *(_WORD *)(v6 + 2 * v2) = 1;
      v7 = *(_DWORD *)(v4 + 16) + 1;
      *(_DWORD *)(v4 + 16) = v7;
      ++v2;
    }
    while (v2 < v3);
  }
  return this;
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::populateChildValuesFromEdgeVertices(_QWORD *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t i;

  v1 = *this;
  v2 = *(int *)(*this + 56);
  if ((int)v2 >= 1)
  {
    v3 = *(int *)(v1 + 80);
    v4 = v3 + v2;
    v5 = *(_QWORD *)(v1 + 312);
    v6 = this[4];
    v7 = *(_QWORD *)(v6 + 96);
    v8 = *(_QWORD *)(this[2] + 48);
    v9 = *(_DWORD *)(v6 + 16);
    v10 = *(_QWORD *)(v6 + 72);
    do
    {
      v11 = *(int *)(v5 + 4 * v3);
      *(_DWORD *)(v7 + 4 * v3) = v9;
      if ((*(_BYTE *)(v8 + v11) & 1) != 0)
      {
        v13 = this[1];
        v14 = *(_QWORD *)(v13 + 144);
        v12 = *(unsigned int *)(v14 + 8 * (_DWORD)v11);
        if ((_DWORD)v12 != 1)
        {
          v15 = *(_QWORD *)(v13 + 168);
          v16 = *(int *)(v14 + 8 * v11 + 4);
          if ((int)v12 >= 1)
          {
            v17 = 0;
            v18 = this[5] + 2 * v9;
            do
            {
              *(_WORD *)(v18 + 2 * v17) = v17;
              ++v17;
            }
            while (v12 != v17);
          }
          v19 = *(_QWORD *)(*(_QWORD *)v6 + 264);
          v20 = *(unsigned int *)(v19 + 8 * (int)v3);
          if ((int)v20 >= 1)
          {
            v21 = 0;
            v22 = v15 + 4 * v16;
            v23 = (8 * ((unint64_t)(2 * (int)v3) >> 1)) | 4;
            v24 = *(_QWORD *)(this[3] + 288) + 4 * *(int *)(*(_QWORD *)(this[3] + 264) + v23);
            v25 = *(_QWORD *)(v6 + 120) + 2 * *(int *)(v19 + v23);
            v26 = *(_QWORD *)(v1 + 264);
            do
            {
              v27 = *(_DWORD *)(v26 + 4 * *(int *)(v24 + 4 * v21));
              if ((_DWORD)v12 == 2)
              {
                if (v27 == *(_DWORD *)(v22 + 4))
                  *(_WORD *)(v25 + 2 * v21) = 1;
              }
              else if ((int)v12 >= 1)
              {
                for (i = 0; i != v12; ++i)
                {
                  if (v27 == *(_DWORD *)(v22 + 4 * i))
                    *(_WORD *)(v25 + 2 * v21) = i;
                }
              }
              ++v21;
            }
            while (v21 != v20);
          }
        }
      }
      else
      {
        LODWORD(v12) = 1;
      }
      *(_WORD *)(v10 + 2 * v3) = v12;
      v9 = *(_DWORD *)(v6 + 16) + v12;
      *(_DWORD *)(v6 + 16) = v9;
      ++v3;
    }
    while (v3 < v4);
  }
  return this;
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::populateChildValuesFromVertexVertices(_QWORD *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t i;
  uint64_t v17;
  uint64_t v18;
  __int16 *v19;
  _WORD *v20;
  __int16 v21;

  v1 = *this;
  v2 = *(int *)(*this + 60);
  if ((int)v2 >= 1)
  {
    v3 = *(int *)(v1 + 84);
    v4 = v3 + v2;
    v5 = *(_QWORD *)(v1 + 312);
    v6 = this[4];
    v7 = *(_QWORD *)(v6 + 96);
    v8 = (_QWORD *)this[2];
    v9 = v8[12];
    v10 = v8[21];
    v11 = *(_DWORD *)(v6 + 16);
    v12 = *(_QWORD *)(v6 + 72);
    do
    {
      v13 = *(int *)(v5 + 4 * v3);
      *(_DWORD *)(v7 + 4 * v3) = v11;
      if ((*(_BYTE *)(v10 + *(int *)(v9 + 4 * v13)) & 1) != 0)
      {
        v14 = *(unsigned __int16 *)(v8[9] + 2 * v13);
        if (v14 >= 2)
        {
          v15 = this[5] + 2 * v11;
          for (i = 1; i != v14; ++i)
            *(_WORD *)(v15 + 2 * i) = i;
          v17 = *(_QWORD *)(*(_QWORD *)v6 + 264);
          v18 = *(unsigned int *)(v17 + 8 * (_DWORD)v3);
          if ((int)v18 >= 1)
          {
            v19 = (__int16 *)(v8[15] + 2 * *(int *)(*(_QWORD *)(*v8 + 264) + 4 * (int)((2 * v13) | 1)));
            v20 = (_WORD *)(*(_QWORD *)(v6 + 120) + 2 * *(int *)(v17 + 8 * (int)v3 + 4));
            do
            {
              v21 = *v19++;
              *v20++ = v21;
              --v18;
            }
            while (v18);
          }
        }
      }
      else
      {
        LODWORD(v14) = 1;
      }
      *(_WORD *)(v12 + 2 * v3) = v14;
      v11 = *(_DWORD *)(v6 + 16) + v14;
      *(_DWORD *)(v6 + 16) = v11;
      ++v3;
    }
    while (v3 < v4);
  }
  return this;
}

float OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement::getFractionalWeight(OpenSubdiv::v3_1_1::Vtr::internal::FVarRefinement *this, int a2, unsigned int a3, int a4)
{
  int v4;
  unsigned int v5;
  int *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v21;
  float *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  void *v29;
  unsigned __int16 *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  int *v39;
  float *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int *v47;
  int *v48;
  float *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  float *v54;
  uint64_t v55;
  uint64_t v56;
  float v57;
  uint64_t v60;
  int v61;
  int v62;
  _BYTE *v63;
  uint64_t v64;
  _BYTE v65[128];
  void *v66;
  _BYTE *v67;
  uint64_t v68;
  _BYTE v69[64];
  void *v70;
  uint64_t v71;

  v4 = a4;
  v5 = a3;
  v71 = *MEMORY[0x24BDAC8D0];
  v7 = (int *)v69;
  v67 = v69;
  v68 = 0x1000000000;
  v70 = 0;
  v8 = (_QWORD *)*((_QWORD *)this + 1);
  v9 = v8[45];
  v10 = a2;
  v11 = (2 * a2) | 1;
  v12 = v8[42];
  v13 = *(int *)(v12 + 4 * v11);
  v14 = (int *)(v9 + 4 * v13);
  v15 = *(unsigned int *)(v12 + 8 * a2);
  v16 = (_QWORD *)*((_QWORD *)this + 3);
  v17 = v16[45];
  if (((v16[46] - v17) & 0x3FFFFFFFCLL) != 0)
  {
    v61 = a4;
    v7 = (int *)(v17 + 4 * *(int *)(v16[42] + 8 * a4 + 4));
    goto LABEL_11;
  }
  if ((_DWORD)v15)
  {
    v61 = a4;
    if (v15 <= 0x10)
    {
      LODWORD(v68) = *(_DWORD *)(v12 + 8 * a2);
      v18 = v8[48] + 2 * *(int *)(v12 + 4 * v11);
    }
    else
    {
      v60 = a2;
      operator delete(0);
      v7 = (int *)operator new(4 * v15);
      v70 = v7;
      v67 = v7;
      LODWORD(v68) = v15;
      HIDWORD(v68) = v15;
      if ((int)v15 < 1)
      {
        v10 = v60;
        v5 = a3;
        goto LABEL_11;
      }
      v18 = *(_QWORD *)(*((_QWORD *)this + 1) + 384)
          + 2 * *(int *)(*(_QWORD *)(*((_QWORD *)this + 1) + 336) + 4 * v11);
      v10 = v60;
      v5 = a3;
    }
    v23 = 0;
    v24 = *(_QWORD *)(*(_QWORD *)this + 192);
    do
    {
      v7[v23] = *(_DWORD *)(v24 + 8 * v14[v23] + 4 * *(unsigned __int16 *)(v18 + 2 * v23));
      ++v23;
    }
    while (v15 != v23);
LABEL_11:
    v22 = (float *)v65;
    v63 = v65;
    LODWORD(v64) = 2 * v15;
    HIDWORD(v64) = 32;
    v66 = 0;
    if ((2 * v15) < 0x21)
    {
      v21 = 0;
    }
    else
    {
      v25 = v10;
      v26 = v13;
      v27 = v9;
      v28 = v5;
      v29 = operator new(4 * (2 * v15));
      v5 = v28;
      v9 = v27;
      v13 = v26;
      v10 = v25;
      v21 = v29;
      v66 = v29;
      v63 = v29;
      HIDWORD(v64) = 2 * v15;
      v22 = (float *)v29;
    }
    v4 = v61;
    goto LABEL_15;
  }
  v19 = a2;
  operator delete(0);
  v5 = a3;
  v10 = v19;
  v21 = 0;
  v68 = 0x1000000000;
  v22 = (float *)v65;
  v63 = v65;
  v64 = 0x2000000000;
  v66 = 0;
  v67 = v69;
LABEL_15:
  v30 = (unsigned __int16 *)(*(_QWORD *)(*((_QWORD *)this + 2) + 192)
                           + 4 * *(int *)(*(_QWORD *)(*((_QWORD *)this + 2) + 96) + 4 * v10)
                           + 4 * v5);
  v31 = *v30;
  v32 = v30[1];
  v33 = (v32 - v31);
  if (v32 <= v31)
  {
    v34 = *((_QWORD *)this + 1);
    if (v31 <= v32)
    {
      LODWORD(v33) = 0;
      v36 = *((_QWORD *)this + 3);
    }
    else
    {
      v44 = *(_QWORD *)(v34 + 216);
      v36 = *((_QWORD *)this + 3);
      v45 = *(_QWORD *)(v36 + 216);
      if ((int)v31 + 1 >= (int)v15)
      {
        v46 = 0;
      }
      else
      {
        v46 = (v15 + ~(_DWORD)v31);
        v47 = &v7[v31 + 1];
        v48 = (int *)(4 * v13 + 4 * v31 + v9 + 4);
        v49 = v22;
        v50 = v46;
        do
        {
          v51 = *v48++;
          *v49 = *(float *)(v44 + 4 * v51);
          v52 = *v47++;
          v49[(int)v15] = *(float *)(v45 + 4 * v52);
          ++v49;
          --v50;
        }
        while (v50);
      }
      v53 = v32 + 1;
      v54 = &v22[v46];
      LODWORD(v33) = v32 + v46 + 1;
      do
      {
        v55 = *v14++;
        *v54 = *(float *)(v44 + 4 * v55);
        v56 = *v7++;
        v54[(int)v15] = *(float *)(v45 + 4 * v56);
        ++v54;
        --v53;
      }
      while (v53);
    }
  }
  else
  {
    v34 = *((_QWORD *)this + 1);
    v35 = *(_QWORD *)(v34 + 216);
    v36 = *((_QWORD *)this + 3);
    v37 = *(_QWORD *)(v36 + 216);
    v38 = &v7[v31 + 1];
    v39 = (int *)(4 * v13 + 4 * v31 + v9 + 4);
    v40 = v22;
    v41 = v33;
    do
    {
      v42 = *v39++;
      *v40 = *(float *)(v35 + 4 * v42);
      v43 = *v38++;
      v40[(int)v15] = *(float *)(v37 + 4 * v43);
      ++v40;
      --v41;
    }
    while (v41);
  }
  v62 = *(_DWORD *)(*(_QWORD *)this + 24);
  v57 = OpenSubdiv::v3_1_1::Sdc::Crease::ComputeFractionalWeightAtVertex((OpenSubdiv::v3_1_1::Sdc::Crease *)&v62, *(float *)(*(_QWORD *)(v34 + 408) + 4 * v10), *(float *)(*(_QWORD *)(v36 + 408) + 4 * v4), v33, v22, &v22[(int)v15]);
  operator delete(v21);
  operator delete(v70);
  return v57;
}

void OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::~TriRefinement(OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement *this)
{
  void *v2;

  *(_QWORD *)this = &off_24ED89E98;
  v2 = (void *)*((_QWORD *)this + 63);
  if (v2)
  {
    *((_QWORD *)this + 64) = v2;
    operator delete(v2);
  }
  OpenSubdiv::v3_1_1::Vtr::internal::Refinement::~Refinement(this);
}

{
  OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::~TriRefinement(this);
  JUMPOUT(0x2276933B8);
}

void OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::allocateParentChildIndices(std::vector<int> *this)
{
  std::vector<int>::pointer end;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  std::vector<int>::size_type v7;
  uint64_t v8;
  std::vector<int>::size_type v9;
  std::vector<int>::pointer v10;
  std::vector<int>::pointer begin;
  int v12;
  uint64_t v13;
  _DWORD *v14;
  unint64_t v15;
  int *v16;
  uint64_t v17;
  std::vector<int>::value_type v18;
  std::vector<int>::value_type __x;

  end = this->__end_;
  v4 = *((_QWORD *)end + 9);
  v3 = *((_QWORD *)end + 10);
  v6 = *((_QWORD *)end + 15);
  v5 = *((_QWORD *)end + 16);
  v8 = *end;
  v7 = end[1];
  v9 = end[2];
  __x = 4;
  std::vector<unsigned int>::resize(this + 21, 2 * v8, &__x);
  v10 = this->__end_;
  begin = this[21].__begin_;
  if (*v10 >= 1)
  {
    v12 = 0;
    v13 = 0;
    v14 = begin + 1;
    do
    {
      *v14 = v12;
      v14 += 2;
      ++v13;
      v12 += 4;
    }
    while (v13 < *v10);
  }
  v15 = (unint64_t)((char *)this[21].__end_ - (char *)begin) >> 2;
  this[3].__end_cap_.__value_ = begin;
  LODWORD(this[4].__begin_) = v15;
  v16 = (int *)*((_QWORD *)v10 + 3);
  v17 = (*((_QWORD *)v10 + 4) - (_QWORD)v16) >> 2;
  this[4].__end_ = v16;
  LODWORD(this[4].__end_cap_.__value_) = v17;
  v18 = 0;
  std::vector<unsigned int>::resize(this + 5, 4 * v8, &v18);
  std::vector<unsigned int>::resize(this + 6, (int)((v3 - v4) >> 2), &v18);
  std::vector<unsigned int>::resize(this + 8, (int)((v5 - v6) >> 2), &v18);
  std::vector<unsigned int>::resize(this + 7, 0, &v18);
  std::vector<unsigned int>::resize(this + 9, v7, &v18);
  std::vector<unsigned int>::resize(this + 10, v9, &v18);
}

void OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateFaceVertexRelation(OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement *this)
{
  std::vector<int> *v2;
  int *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int *v9;
  int *v10;
  uint64_t v11;
  int *v12;
  int *v13;
  uint64_t v14;
  int v15;
  int v16;
  _DWORD *v17;
  int v18;
  _DWORD *v19;
  int v20;
  _DWORD *v21;
  int v22;
  _DWORD *v23;
  int v24;
  _DWORD *v25;

  v2 = (std::vector<int> *)*((_QWORD *)this + 2);
  if (v2[1].__end_ == v2[1].__begin_)
  {
    OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateFaceVertexCountsAndOffsets(this);
    v2 = (std::vector<int> *)*((_QWORD *)this + 2);
  }
  std::vector<unsigned int>::resize(v2 + 2, 3 * SLODWORD(v2->__begin_));
  v3 = (int *)*((_QWORD *)this + 1);
  if (*v3 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)v3 + 6);
    v6 = *((_QWORD *)v3 + 9);
    v7 = *((_QWORD *)this + 15);
    v8 = *((_QWORD *)this + 27);
    v9 = (int *)(*((_QWORD *)this + 11) + 4);
    v10 = (int *)(*((_QWORD *)v3 + 3) + 4);
    do
    {
      v11 = *v10;
      v10 += 2;
      v12 = (int *)(v5 + 4 * v11);
      v13 = (int *)(v6 + 4 * v11);
      v14 = *v9;
      v9 += 2;
      v15 = *(_DWORD *)(v8 + 4 * *v13);
      v16 = *(_DWORD *)(v8 + 4 * v13[1]);
      v17 = (_DWORD *)(v7 + 4 * v14);
      v18 = *(_DWORD *)(v8 + 4 * v13[2]);
      if (*v17 != -1)
      {
        v19 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 2) + 48)
                       + 4 * *(int *)(*(_QWORD *)(*((_QWORD *)this + 2) + 24) + 4 * ((2 * *v17) | 1)));
        *v19 = *(_DWORD *)(*((_QWORD *)this + 30) + 4 * *v12);
        v19[1] = v15;
        v19[2] = v18;
      }
      v20 = v17[1];
      if (v20 != -1)
      {
        v21 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 2) + 48)
                       + 4 * *(int *)(*(_QWORD *)(*((_QWORD *)this + 2) + 24) + 4 * ((2 * v20) | 1)));
        *v21 = v15;
        v21[1] = *(_DWORD *)(*((_QWORD *)this + 30) + 4 * v12[1]);
        v21[2] = v16;
      }
      v22 = v17[2];
      if (v22 != -1)
      {
        v23 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 2) + 48)
                       + 4 * *(int *)(*(_QWORD *)(*((_QWORD *)this + 2) + 24) + 4 * ((2 * v22) | 1)));
        *v23 = v18;
        v23[1] = v16;
        v23[2] = *(_DWORD *)(*((_QWORD *)this + 30) + 4 * v12[2]);
      }
      v24 = v17[3];
      if (v24 != -1)
      {
        v25 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 2) + 48)
                       + 4 * *(int *)(*(_QWORD *)(*((_QWORD *)this + 2) + 24) + 4 * ((2 * v24) | 1)));
        *v25 = v16;
        v25[1] = v18;
        v25[2] = v15;
      }
      ++v4;
    }
    while (v4 < *v3);
  }
}

void OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateFaceVertexCountsAndOffsets(OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement *this)
{
  std::vector<int> *v2;
  uint64_t begin_low;
  int *v4;
  int v5;
  uint64_t v6;
  _DWORD *v7;
  std::vector<int>::value_type __x;

  v2 = (std::vector<int> *)*((_QWORD *)this + 2);
  begin_low = SLODWORD(v2->__begin_);
  __x = 3;
  std::vector<unsigned int>::resize(v2 + 1, 2 * begin_low, &__x);
  v4 = (int *)*((_QWORD *)this + 2);
  if (*v4 >= 1)
  {
    v5 = 0;
    v6 = 0;
    v7 = (_DWORD *)(*((_QWORD *)v4 + 3) + 4);
    do
    {
      *v7 = v5;
      v7 += 2;
      ++v6;
      v5 += 3;
    }
    while (v6 < *v4);
  }
}

void OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateFaceEdgeRelation(OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement *this)
{
  std::vector<int> *v2;
  int *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  int *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  _BOOL4 v24;
  uint64_t v25;
  int v26;
  _DWORD *v27;
  _DWORD *v28;
  _DWORD *v29;
  _DWORD *v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  _DWORD *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  v2 = (std::vector<int> *)*((_QWORD *)this + 2);
  if (v2[1].__end_ == v2[1].__begin_)
  {
    OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateFaceVertexCountsAndOffsets(this);
    v2 = (std::vector<int> *)*((_QWORD *)this + 2);
  }
  std::vector<unsigned int>::resize(v2 + 3, 3 * SLODWORD(v2->__begin_));
  v3 = (int *)*((_QWORD *)this + 1);
  if (*v3 >= 1)
  {
    v4 = 0;
    v5 = *((_QWORD *)v3 + 3);
    v6 = *((_QWORD *)v3 + 6);
    v7 = *((_QWORD *)v3 + 9);
    v8 = *((_QWORD *)this + 11);
    v9 = *((_QWORD *)this + 15);
    v10 = *((_QWORD *)this + 13);
    v11 = *((_QWORD *)this + 18);
    v12 = *((_QWORD *)this + 24);
    v13 = *((_QWORD *)v3 + 15);
    do
    {
      v14 = 0;
      v15 = (8 * v4) | 4;
      v16 = *(int *)(v5 + v15);
      v17 = (_DWORD *)(v6 + 4 * v16);
      v18 = (int *)(v7 + 4 * v16);
      v19 = *(int *)(v8 + v15);
      v20 = *(int *)(v10 + v15);
      do
      {
        v22 = *v18++;
        v21 = v22;
        v23 = (_DWORD *)(v13 + 8 * v22);
        v24 = *v23 != v23[1] && *v17 != *v23;
        v25 = v12 + 8 * v21;
        v26 = *(_DWORD *)(v25 + 4 * v24);
        LODWORD(v25) = *(_DWORD *)(v25 + 4 * !v24);
        v27 = (int *)((char *)&v38 + v14);
        *v27 = v26;
        v27[1] = v25;
        v14 += 8;
        ++v17;
      }
      while (v14 != 24);
      v28 = (_DWORD *)(v9 + 4 * v19);
      v29 = (_DWORD *)(v11 + 4 * v20);
      if (*v28 != -1)
      {
        v30 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 2) + 72)
                       + 4 * *(int *)(*(_QWORD *)(*((_QWORD *)this + 2) + 24) + 4 * ((2 * *v28) | 1)));
        v31 = v41;
        *v30 = v38;
        v30[1] = *v29;
        v30[2] = v31;
      }
      v32 = v28[1];
      if (v32 != -1)
      {
        v33 = *(_QWORD *)(*((_QWORD *)this + 2) + 72)
            + 4 * *(int *)(*(_QWORD *)(*((_QWORD *)this + 2) + 24) + 4 * ((2 * v32) | 1));
        *(_QWORD *)v33 = v39;
        *(_DWORD *)(v33 + 8) = v29[1];
      }
      v34 = v28[2];
      if (v34 != -1)
      {
        v35 = *(_QWORD *)(*((_QWORD *)this + 2) + 72)
            + 4 * *(int *)(*(_QWORD *)(*((_QWORD *)this + 2) + 24) + 4 * ((2 * v34) | 1));
        *(_DWORD *)v35 = v29[2];
        *(_QWORD *)(v35 + 4) = v40;
      }
      v36 = v28[3];
      if (v36 != -1)
      {
        v37 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 2) + 72)
                       + 4 * *(int *)(*(_QWORD *)(*((_QWORD *)this + 2) + 24) + 4 * ((2 * v36) | 1)));
        *v37 = v29[2];
        v37[1] = *v29;
        v37[2] = v29[1];
      }
      ++v4;
    }
    while (v4 < *v3);
  }
}

void OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateEdgeVertexRelation(OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement *this)
{
  int *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int *v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  int v12;
  int v13;
  int *v14;
  int v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  int *v23;
  int *v24;
  uint64_t v25;
  _DWORD *v26;
  uint64_t v27;
  _DWORD *v28;

  std::vector<unsigned int>::resize((std::vector<int> *)(*((_QWORD *)this + 2) + 120), 2 * *(int *)(*((_QWORD *)this + 2) + 4));
  v2 = (int *)*((_QWORD *)this + 1);
  if (*v2 >= 1)
  {
    v3 = 0;
    v4 = *((_QWORD *)v2 + 9);
    v5 = *((_QWORD *)this + 18);
    v6 = *((_QWORD *)this + 27);
    v7 = (int *)(*((_QWORD *)this + 13) + 4);
    v8 = (int *)(*((_QWORD *)v2 + 3) + 4);
    do
    {
      v9 = *v8;
      v8 += 2;
      v10 = (int *)(v4 + 4 * v9);
      v11 = *v7;
      v7 += 2;
      v12 = *(_DWORD *)(v6 + 4 * *v10);
      v13 = *(_DWORD *)(v6 + 4 * v10[1]);
      v14 = (int *)(v5 + 4 * v11);
      v15 = *(_DWORD *)(v6 + 4 * v10[2]);
      v16 = *v14;
      if ((_DWORD)v16 != -1)
      {
        v17 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 2) + 120) + 8 * v16);
        *v17 = v12;
        v17[1] = v15;
      }
      v18 = v14[1];
      if ((_DWORD)v18 != -1)
      {
        v19 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 2) + 120) + 8 * v18);
        *v19 = v13;
        v19[1] = v12;
      }
      v20 = v14[2];
      if ((_DWORD)v20 != -1)
      {
        v21 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 2) + 120) + 8 * v20);
        *v21 = v15;
        v21[1] = v13;
      }
      ++v3;
    }
    while (v3 < *v2);
  }
  if (v2[1] >= 1)
  {
    v22 = 0;
    v23 = (int *)(*((_QWORD *)this + 24) + 4);
    v24 = (int *)(*((_QWORD *)v2 + 15) + 4);
    do
    {
      v25 = *(v23 - 1);
      if ((_DWORD)v25 != -1)
      {
        v26 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 2) + 120) + 8 * v25);
        *v26 = *(_DWORD *)(*((_QWORD *)this + 27) + 4 * v22);
        v26[1] = *(_DWORD *)(*((_QWORD *)this + 30) + 4 * *(v24 - 1));
      }
      v27 = *v23;
      if ((_DWORD)v27 != -1)
      {
        v28 = (_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 2) + 120) + 8 * v27);
        *v28 = *(_DWORD *)(*((_QWORD *)this + 27) + 4 * v22);
        v28[1] = *(_DWORD *)(*((_QWORD *)this + 30) + 4 * *v24);
      }
      ++v22;
      v23 += 2;
      v24 += 2;
    }
    while (v22 < v2[1]);
  }
}

void OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateEdgeFaceRelation(OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement *this)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  int *v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  int v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t v25;
  _DWORD *v26;
  _WORD *v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  _DWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _DWORD *v39;
  char v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  _DWORD *v44;
  int v45;
  int v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int *v54;
  unsigned __int16 *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _BOOL4 v61;
  uint64_t v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  int *v66;
  std::vector<int>::size_type v67;

  v2 = 2
     * (((*(_QWORD *)(*((_QWORD *)this + 1) + 176) - *(_QWORD *)(*((_QWORD *)this + 1) + 168)) >> 2)
      + ((*((_QWORD *)this + 19) - *((_QWORD *)this + 18)) >> 2));
  std::vector<unsigned int>::resize((std::vector<int> *)(*((_QWORD *)this + 2) + 144), 2 * *(int *)(*((_QWORD *)this + 2) + 4));
  std::vector<unsigned int>::resize((std::vector<int> *)(*((_QWORD *)this + 2) + 168), v2);
  std::vector<unsigned short>::resize(*((_QWORD *)this + 2) + 192, v2);
  v4 = *((_QWORD *)this + 1);
  v3 = *((_QWORD *)this + 2);
  *(_DWORD *)(v3 + 16) = *(_DWORD *)(v4 + 16);
  v5 = *(_DWORD *)v4;
  if (*(int *)v4 >= 1)
  {
    v6 = 0;
    v7 = *((_QWORD *)this + 11);
    v8 = *((_QWORD *)this + 15);
    v9 = *((_QWORD *)this + 13);
    v10 = *((_QWORD *)this + 18);
    do
    {
      v11 = *(unsigned int *)(v9 + 8 * v6);
      if ((int)v11 >= 1)
      {
        v12 = (8 * v6) | 4;
        v13 = (_DWORD *)(v8 + 4 * *(int *)(v7 + v12));
        v14 = (int *)(v10 + 4 * *(int *)(v9 + v12));
        v15 = v13[3];
        v16 = 1;
        do
        {
          v18 = *v14++;
          v17 = v18;
          if ((_DWORD)v18 != -1)
          {
            v19 = *(_QWORD *)(v3 + 144);
            v20 = (_DWORD *)(v19 + 8 * v17);
            *v20 = 2;
            if ((_DWORD)v17)
              v21 = *(v20 - 1) + *(v20 - 2);
            else
              v21 = 0;
            v22 = v16 % 3;
            v23 = 2 * v17;
            v20[1] = v21;
            v24 = *(_DWORD *)(v3 + 16);
            if (v24 <= 2)
              v24 = 2;
            *(_DWORD *)(v3 + 16) = v24;
            v25 = *(int *)(v19 + 4 * (v23 | 1));
            v26 = (_DWORD *)(*(_QWORD *)(v3 + 168) + 4 * v25);
            v27 = (_WORD *)(*(_QWORD *)(v3 + 192) + 2 * v25);
            if (*v13 == -1)
            {
              v28 = 0;
            }
            else
            {
              *v26 = *v13;
              *v27 = v22;
              v28 = 1;
            }
            if (v15 != -1)
            {
              v26[v28] = v15;
              v27[v28] = v22;
              LODWORD(v28) = v28 + 1;
            }
            *v20 = v28;
          }
          ++v16;
          ++v13;
          --v11;
        }
        while (v11);
        v5 = *(_DWORD *)v4;
      }
      ++v6;
    }
    while (v6 < v5);
  }
  v29 = *(_DWORD *)(v4 + 4);
  if (v29 >= 1)
  {
    v30 = 0;
    v31 = *((_QWORD *)this + 24);
    do
    {
      v32 = (_DWORD *)(v31 + 8 * v30);
      if (*v32 != -1 || v32[1] != -1)
      {
        v33 = 0;
        v34 = *(_QWORD *)(v4 + 144);
        v35 = *(int *)(v34 + ((8 * v30) | 4));
        v36 = *(unsigned int *)(v34 + 8 * v30);
        v37 = *(_QWORD *)(v4 + 168) + 4 * v35;
        v38 = *(_QWORD *)(v4 + 192) + 2 * v35;
        v39 = (_DWORD *)(*(_QWORD *)(v4 + 120) + 8 * v30);
        v40 = 1;
        do
        {
          v41 = v40;
          v42 = (int)v32[v33];
          if ((_DWORD)v42 != -1)
          {
            v43 = *(_QWORD *)(v3 + 144);
            v44 = (_DWORD *)(v43 + 8 * v42);
            *v44 = v36;
            if ((_DWORD)v42)
              v45 = *(v44 - 1) + *(v44 - 2);
            else
              v45 = 0;
            v44[1] = v45;
            v46 = *(_DWORD *)(v3 + 16);
            if (v46 <= (int)v36)
              v46 = v36;
            *(_DWORD *)(v3 + 16) = v46;
            if ((int)v36 < 1)
            {
              v47 = 0;
            }
            else
            {
              v47 = 0;
              v48 = *(int *)(v43 + 4 * (int)((2 * v42) | 1));
              v49 = *(_QWORD *)(v3 + 168) + 4 * v48;
              v50 = *(_QWORD *)(v3 + 192) + 2 * v48;
              v51 = *(_QWORD *)(v4 + 24);
              v52 = *((_QWORD *)this + 11);
              v53 = *((_QWORD *)this + 15);
              v54 = (int *)v37;
              v55 = (unsigned __int16 *)v38;
              v56 = v36;
              do
              {
                v58 = *v54++;
                v57 = v58;
                LODWORD(v58) = *v55++;
                v59 = v58;
                v60 = (2 * v57) | 1;
                v61 = v33;
                if (*v39 != v39[1])
                  v61 = *(_DWORD *)(*(_QWORD *)(v4 + 48) + 4 * *(int *)(v51 + 4 * v60) + 4 * v59) != v39[v33];
                v62 = v53 + 4 * *(int *)(v52 + 4 * v60);
                v63 = v61 + v59;
                if (v63 == *(_DWORD *)(v51 + 8 * (_DWORD)v57))
                  v64 = 0;
                else
                  v64 = v63;
                v65 = *(_DWORD *)(v62 + 4 * v64);
                if (v65 != -1)
                {
                  *(_DWORD *)(v49 + 4 * v47) = v65;
                  *(_WORD *)(v50 + 2 * v47++) = v59;
                }
                --v56;
              }
              while (v56);
            }
            *v44 = v47;
          }
          v40 = 0;
          v33 = 1;
        }
        while ((v41 & 1) != 0);
        v29 = *(_DWORD *)(v4 + 4);
      }
      ++v30;
    }
    while (v30 < v29);
  }
  v66 = (int *)(*(_QWORD *)(v3 + 144) + 4 * (2 * *(_DWORD *)(v3 + 4) - 2));
  v67 = v66[1] + (uint64_t)*v66;
  std::vector<unsigned int>::resize((std::vector<int> *)(v3 + 168), v67);
  std::vector<unsigned short>::resize(*((_QWORD *)this + 2) + 192, v67);
}

void OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateVertexFaceRelation(OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement *this)
{
  int v2;
  uint64_t v3;
  int *v4;
  std::vector<int>::size_type v5;

  v2 = ((*(_QWORD *)(*((_QWORD *)this + 1) + 296) - *(_QWORD *)(*((_QWORD *)this + 1) + 288)) >> 2)
     + 3 * ((*(_QWORD *)(*((_QWORD *)this + 1) + 176) - *(_QWORD *)(*((_QWORD *)this + 1) + 168)) >> 2);
  std::vector<unsigned int>::resize((std::vector<int> *)(*((_QWORD *)this + 2) + 264), 2 * *(int *)(*((_QWORD *)this + 2) + 8));
  std::vector<unsigned int>::resize((std::vector<int> *)(*((_QWORD *)this + 2) + 288), v2);
  std::vector<unsigned short>::resize(*((_QWORD *)this + 2) + 312, v2);
  if (*((_DWORD *)this + 21))
  {
    OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateVertexFacesFromParentEdges(this);
    OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateVertexFacesFromParentVertices(this);
  }
  else
  {
    OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateVertexFacesFromParentVertices(this);
    OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateVertexFacesFromParentEdges(this);
  }
  v3 = *((_QWORD *)this + 2);
  v4 = (int *)(*(_QWORD *)(v3 + 264) + 4 * (2 * *(_DWORD *)(v3 + 8) - 2));
  v5 = v4[1] + (uint64_t)*v4;
  std::vector<unsigned int>::resize((std::vector<int> *)(v3 + 288), v5);
  std::vector<unsigned short>::resize(*((_QWORD *)this + 2) + 312, v5);
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateVertexFacesFromParentVertices(_QWORD *this)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _DWORD *v12;
  int v13;
  int v14;
  int *v15;
  unsigned __int16 *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int16 v23;
  int v24;

  v1 = this[1];
  v2 = *(_DWORD *)(v1 + 8);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = this[30];
    do
    {
      v5 = *(int *)(v4 + 4 * v3);
      if ((_DWORD)v5 != -1)
      {
        v6 = *(_QWORD *)(v1 + 288);
        v7 = (unsigned int *)(*(_QWORD *)(v1 + 264) + 8 * v3);
        v8 = *v7;
        v9 = (int)v7[1];
        v10 = *(_QWORD *)(v1 + 312);
        v11 = (_QWORD *)this[2];
        v12 = (_DWORD *)(v11[33] + 8 * v5);
        *v12 = v8;
        if ((_DWORD)v5)
          v13 = *(v12 - 1) + *(v12 - 2);
        else
          v13 = 0;
        v12[1] = v13;
        if ((int)v8 < 1)
        {
          v14 = 0;
        }
        else
        {
          v14 = 0;
          v15 = (int *)(v6 + 4 * v9);
          v16 = (unsigned __int16 *)(v10 + 2 * v9);
          v17 = v11[36] + 4 * v13;
          v18 = v11[39] + 2 * v13;
          v19 = this[11];
          v20 = this[15];
          do
          {
            v22 = *v15++;
            v21 = v22;
            LODWORD(v22) = *v16++;
            v23 = v22;
            v24 = *(_DWORD *)(v20 + 4 * *(int *)(v19 + 8 * v21 + 4) + 4 * v22);
            if (v24 != -1)
            {
              *(_DWORD *)(v17 + 4 * v14) = v24;
              *(_WORD *)(v18 + 2 * v14++) = v23;
            }
            --v8;
          }
          while (v8);
        }
        *v12 = v14;
        v2 = *(_DWORD *)(v1 + 8);
      }
      ++v3;
    }
    while (v3 < v2);
  }
  return this;
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateVertexFacesFromParentEdges(_QWORD *this)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _DWORD *v12;
  int v13;
  int v14;
  int *v15;
  unsigned __int16 *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;

  v1 = this[1];
  v2 = *(_DWORD *)(v1 + 4);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = this[27];
    do
    {
      v5 = *(int *)(v4 + 4 * v3);
      if ((_DWORD)v5 != -1)
      {
        v6 = *(_QWORD *)(v1 + 168);
        v7 = (unsigned int *)(*(_QWORD *)(v1 + 144) + 8 * v3);
        v8 = *v7;
        v9 = (int)v7[1];
        v10 = *(_QWORD *)(v1 + 192);
        v11 = (_QWORD *)this[2];
        v12 = (_DWORD *)(v11[33] + 8 * v5);
        *v12 = 2 * v8;
        if ((_DWORD)v5)
          v13 = *(v12 - 1) + *(v12 - 2);
        else
          v13 = 0;
        v12[1] = v13;
        if ((int)v8 < 1)
        {
          v14 = 0;
        }
        else
        {
          v14 = 0;
          v15 = (int *)(v6 + 4 * v9);
          v16 = (unsigned __int16 *)(v10 + 2 * v9);
          v17 = v11[36] + 4 * v13;
          v18 = v11[39] + 2 * v13;
          v19 = this[11];
          v20 = this[15];
          do
          {
            v22 = *v15++;
            v21 = v22;
            LODWORD(v22) = *v16++;
            v23 = v22;
            v24 = v22 + 1 - 3 * ((1431655766 * (unint64_t)(v22 + 1)) >> 32);
            v25 = v20 + 4 * *(int *)(v19 + 8 * v21 + 4);
            v26 = *(_DWORD *)(v25 + 4 * v24);
            if (v26 != -1)
            {
              *(_DWORD *)(v17 + 4 * v14) = v26;
              *(_WORD *)(v18 + 2 * v14++) = v23;
            }
            v27 = *(_DWORD *)(v25 + 12);
            if (v27 != -1)
            {
              *(_DWORD *)(v17 + 4 * v14) = v27;
              *(_WORD *)(v18 + 2 * v14++) = v23
                                            + 2
                                            - 3 * ((1431655766 * (unint64_t)(v23 + 2)) >> 32);
            }
            v28 = *(_DWORD *)(v25 + 4 * v23);
            if (v28 != -1)
            {
              *(_DWORD *)(v17 + 4 * v14) = v28;
              *(_WORD *)(v18 + 2 * v14++) = v24;
            }
            --v8;
          }
          while (v8);
        }
        *v12 = v14;
        v2 = *(_DWORD *)(v1 + 4);
      }
      ++v3;
    }
    while (v3 < v2);
  }
  return this;
}

void OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateVertexEdgeRelation(OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement *this)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  int *v5;
  std::vector<int>::size_type v6;

  v2 = *((_QWORD *)this + 1);
  v3 = ((*(_QWORD *)(v2 + 368) - *(_QWORD *)(v2 + 360)) >> 2)
     + 2 * (*(_DWORD *)(v2 + 4) + ((*(_QWORD *)(v2 + 176) - *(_QWORD *)(v2 + 168)) >> 2));
  std::vector<unsigned int>::resize((std::vector<int> *)(*((_QWORD *)this + 2) + 336), 2 * *(int *)(*((_QWORD *)this + 2) + 8));
  std::vector<unsigned int>::resize((std::vector<int> *)(*((_QWORD *)this + 2) + 360), v3);
  std::vector<unsigned short>::resize(*((_QWORD *)this + 2) + 384, v3);
  if (*((_DWORD *)this + 21))
  {
    OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateVertexEdgesFromParentEdges(this);
    OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateVertexEdgesFromParentVertices(this);
  }
  else
  {
    OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateVertexEdgesFromParentVertices(this);
    OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateVertexEdgesFromParentEdges(this);
  }
  v4 = *((_QWORD *)this + 2);
  v5 = (int *)(*(_QWORD *)(v4 + 336) + 4 * (2 * *(_DWORD *)(v4 + 8) - 2));
  v6 = v5[1] + (uint64_t)*v5;
  std::vector<unsigned int>::resize((std::vector<int> *)(v4 + 360), v6);
  std::vector<unsigned short>::resize(*((_QWORD *)this + 2) + 384, v6);
}

_QWORD *OpenSubdiv::v3_1_1::Vtr::internal::TriRefinement::populateVertexEdgesFromParentVertices(_QWORD *this)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  int v14;
  int v15;
  int v16;
  int *v17;
  unsigned __int16 *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;

  v1 = this[1];
  v2 = *(_DWORD *)(v1 + 8);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = this[30];
    do
    {
      v5 = *(int *)(v4 + 4 * v3);
      if ((_DWORD)v5 != -1)
      {
        v6 = *(_QWORD *)(v1 + 360);
        v7 = (unsigned int *)(*(_QWORD *)(v1 + 336) + 8 * v3);
        v8 = *v7;
        v9 = (int)v7[1];
        v10 = *(_QWORD *)(v1 + 384);
        v11 = this[2];
        v12 = *(_QWORD *)(v11 + 336);
        v13 = (_DWORD *)(v12 + 8 * v5);
        *v13 = v8;
        if ((_DWORD)v5)
          v14 = *(v13 - 1) + *(v13 - 2);
        else
          v14 = 0;
        v13[1] = v14;
        v15 = *(_DWORD *)(v11 + 20);
        if (v15 <= (int)v8)
          v15 = v8;
        *(_DWORD *)(v11 + 20) = v15;
        if ((int)v8 < 1)
        {
          v16 = 0;
        }
        else
        {
          v16 = 0;
          v17 = (int *)(v6 + 4 * v9);
          v18 = (unsigned __int16 *)(v10 + 2 * v9);
          v19 = *(int *)(v12 + 4 * (int)((2 * v5) | 1));
          v20 = *(_QWORD *)(v11 + 360) + 4 * v19;
          v21 = *(_QWORD *)(v11 + 384) + 2 * v19;
          v22 = this[24];
          do
          {
            v23 = *v17++;
            v24 = v22 + 8 * v23;
            LODWORD(v23) = *v18++;
            v25 = *(_DWORD *)(v24 + 4 * v23);
            if (v25 != -1)
            {
              *(_DWORD *)(v20 + 4 * v16) = v25;
              *(_WORD *)(v21 + 2 * v16++) = 1;
            }
            --v8;
          }
          while (v8);
        }
        *v13 = v16;
        v2 = *(_DWORD *)(v1 + 8);
      }
      ++v3;
    }
    while (v3 < v2);
  }
  return this;
}

