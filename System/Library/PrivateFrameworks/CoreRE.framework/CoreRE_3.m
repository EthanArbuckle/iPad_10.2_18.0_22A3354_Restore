BOOL re::serializeDynamicString<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, _QWORD *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  char *v19;
  int v20;
  _BOOL8 result;
  _anonymous_namespace_ *v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  size_t v33;
  char *v34;
  unint64_t v35;

  v9 = (int)a3;
  if (a5 == a6)
    goto LABEL_14;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x22C6ED80D0CLL
    || (v19 = (char *)v18[1], v19 != "StringID") && strcmp(v19, "StringID"))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v35 = 0;
    v20 = re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v35, 0);
    result = 0;
    if (!v20)
      return result;
    if (v35)
      re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
    v22 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_34;
  }
  v23 = a4[1];
  if ((v23 & 1) != 0)
    v24 = v23 >> 1;
  else
    v24 = v23 >> 1;
  v35 = v24;
  v25 = re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v35, 0);
  result = 0;
  if (v25)
  {
    v26 = v35;
    if (v26 <= (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24)))
    {
      if (!*a4)
      {
        v33 = v35 + 1;
        *a4 = *(_QWORD *)(a1 + 48);
        re::DynamicString::setCapacity(a4, v33);
      }
      re::DynamicString::resize(a4, v35, 0);
      if (v35)
      {
        if ((a4[1] & 1) != 0)
          v34 = (char *)a4[2];
        else
          v34 = (char *)a4 + 9;
        re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, v34, 0);
      }
      v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_34:
      re::EncoderOPACK<re::FixedArrayInputStream>::endString(v22);
      return *(_BYTE *)(a1 + 64) == 0;
    }
    v27 = v35;
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v28, v29, v30, v31, v32, v27);
    return 0;
  }
  return result;
}

uint64_t re::internal::serializeObjectWithOneMember<re::EncoderOPACK<re::FixedArrayInputStream>>(_BYTE *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t *v14;
  uint64_t v15;
  const re::TypeInfo *v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23[5];
  _QWORD *v24[4];
  _BYTE v25[32];
  _BYTE v26[32];
  _QWORD *v27;
  uint64_t v28;
  _BYTE v29[8];
  _BYTE v30[32];

  v14 = (uint64_t *)re::TypeMemberCollection::TypeMemberCollection((uint64_t)v29, *a5, a5[2]);
  re::TypeMemberCollection::operator[](v14, 0, (uint64_t)&v27);
  v15 = a4 + *(unsigned int *)(v28 + 24);
  re::TypeRegistry::typeInfo(v27, *(_QWORD *)v28, v29);
  re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)v30);
  if (a5 == a6)
    goto LABEL_4;
  if (*a5 == *a6)
  {
    v18 = *(_QWORD *)a5[2];
    v19 = a6[2];
    v20 = *(_QWORD *)v19;
    if ((unsigned __int16)v18 != (unsigned __int16)*(_QWORD *)v19)
      goto LABEL_14;
    v22 = WORD1(v18) == WORD1(v20);
    v21 = (v20 ^ v18) & 0xFFFFFF00000000;
    v22 = v22 && v21 == 0;
    if (!v22)
      goto LABEL_14;
LABEL_4:
    if (!a1[64])
      return (*(uint64_t (**)(_BYTE *, const char *, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, a3, v15, v26, v26, a7);
    return 0;
  }
  if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, v16))
    goto LABEL_4;
  v19 = a6[2];
LABEL_14:
  if (*(_DWORD *)(v19 + 88) != 1)
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
    return 0;
  }
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v23, *a6, v19);
  re::TypeMemberCollection::operator[](v23, 0, (uint64_t)v24);
  re::TypeRegistry::typeInfo(v24[0], *v24[2], v29);
  re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)v30);
  if (a1[64])
    return 0;
  return (*(uint64_t (**)(_BYTE *, const char *, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, a3, v15, v26, v25, a7);
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::beginString(uint64_t a1, const char *a2, int a3, uint64_t *a4, int a5)
{
  uint64_t result;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v16 = 0;
  result = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v16, 0);
  if ((_DWORD)result)
  {
    re::EncoderOPACK<re::FixedArrayInputStream>::readStringTag(a1, a2, a4);
    v10 = *a4;
    LOBYTE(v11) = 8;
    DWORD1(v11) = a5;
    *((_QWORD *)&v11 + 1) = a2;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v11);
    *(_QWORD *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 32) = v16;
    return *(_BYTE *)(a1 + 40) == 0;
  }
  return result;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(uint64_t result, char *a2, char a3)
{
  _anonymous_namespace_ *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;

  if (*(_BYTE *)(result + 40))
    return result;
  v4 = (_anonymous_namespace_ *)result;
  v5 = *(_QWORD *)(result + 128) + 48 * *(_QWORD *)(result + 112);
  v6 = *(_QWORD *)(v5 - 24);
  v7 = *(_QWORD *)(result + 168);
  if (v7)
  {
    if (v7 >= v6)
      v8 = *(_QWORD *)(v5 - 24);
    else
      v8 = *(_QWORD *)(result + 168);
    v9 = v7 - v8;
    if ((uint64_t)(v7 - 1) >= (uint64_t)(v7 - v8))
    {
      do
      {
        *a2++ = *(_BYTE *)(result + 159 + v7);
        v10 = v7 - 2;
        --v7;
      }
      while (v10 >= v9);
    }
    *(_QWORD *)(result + 168) = v9;
    v11 = v6 - v8;
    if (v6 == v8)
      goto LABEL_15;
    goto LABEL_11;
  }
  v11 = *(_QWORD *)(v5 - 24);
  if (v6)
  {
LABEL_11:
    if ((a3 & 1) != 0)
      a2 = 0;
    result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)result, a2, v11);
    if ((result & 1) == 0)
      result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType(v4, 0, (uint64_t)"String");
  }
LABEL_15:
  if ((a3 & 2) == 0)
  {
    v12 = *((_QWORD *)v4 + 16);
    v13 = *((_QWORD *)v4 + 14) - 1;
    if (*(_BYTE *)(v12 + 48 * v13) != 2)
      *(_QWORD *)(v12 + 48 * v13 + 32) += v6;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::FixedArrayInputStream>::endString(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  _anonymous_namespace_ *v9;
  char v10;
  _BYTE v11[23];
  _OWORD v12[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    v2 = *((_QWORD *)result + 16);
    v3 = *((_QWORD *)result + 14) - 1;
    if (*(_QWORD *)(v2 + 48 * v3 + 32) == *(_QWORD *)(v2 + 48 * v3 + 24))
    {
      for (i = *(_QWORD *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::FixedArrayInputStream>::skipObject((uint64_t)v1);
      result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 8);
      v5 = *((_QWORD *)v1 + 16);
      v6 = *((_QWORD *)v1 + 14) - 1;
      if (*(_BYTE *)(v5 + 48 * v6) != 2)
        ++*(_QWORD *)(v5 + 48 * v6 + 32);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v9);
      if ((v10 & 1) != 0)
        v7 = *(_BYTE **)&v11[7];
      else
        v7 = v11;
      v8 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
      re::DynamicString::format((re::DynamicString *)"Failed to serialize string \"%s\". Expected number of characters: %lld. Actual number of characters: %lld.", (re::DynamicString *)v12, v7, *(_QWORD *)(v8 - 24), *(_QWORD *)(v8 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v12);
      if (*(_QWORD *)&v12[0])
      {
        if ((BYTE8(v12[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v12[0] + 40))();
        memset(v12, 0, sizeof(v12));
      }
      result = v9;
      if (v9 && (v10 & 1) != 0)
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v9 + 40))();
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::FixedArrayInputStream>>(_BYTE *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t result;
  unint64_t i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  _BYTE v15[32];
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18[2];
  uint64_t v19;
  unint64_t v20;
  _BYTE v21[8];
  uint64_t v22;
  _BYTE v23[8];
  uint64_t v24;

  re::TypeRegistry::typeInfo((_QWORD *)*a3, *(_QWORD *)(a3[2] + 72), v21);
  if (v21[0])
  {
    re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)&v22);
    if (*(_DWORD *)(v19 + 88) || (re::TypeRegistry::typeInfo(v18[0], *(_QWORD *)(v19 + 72), v23), v23[0]))
    {
      if (re::EncoderOPACK<re::FixedArrayInputStream>::beginObject((uint64_t)(a1 + 24), "@super", 0, 0))
      {
        re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, v18, a4);
        re::EncoderOPACK<re::FixedArrayInputStream>::endObject((uint64_t)(a1 + 24));
      }
    }
  }
  result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v18, *a3, a3[2]);
  if (v20)
  {
    for (i = 0; i < v20; ++i)
    {
      if (a1[64])
        break;
      result = (uint64_t)re::TypeMemberCollection::operator[]((uint64_t *)v18, i, (uint64_t)&v16);
      if (*(_BYTE *)(v17 + 28))
      {
        v10 = *(_QWORD *)(v17 + 16);
        if (strlen((const char *)v10) >= 3 && *(_BYTE *)v10 == 109)
          v10 += 2 * (*(_BYTE *)(v10 + 1) == 95);
        v11 = *(unsigned int *)(v17 + 32);
        v12 = a2 + *(unsigned int *)(v17 + 24);
        re::TypeRegistry::typeInfo(v16, *(_QWORD *)v17, v23);
        re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)&v24);
        if (a1[64]
          || (result = (*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v10, v11, v12, v15, v15, a4), (result & 1) == 0))
        {
          result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a3);
          if (v13)
          {
            v14 = (_DWORD *)(result + 16);
            while (i != *v14)
            {
              v14 += 6;
              if (!--v13)
                goto LABEL_22;
            }
            if (!a1[64])
              result = (*(uint64_t (**)(_BYTE *, _QWORD, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, *((_QWORD *)v14 - 1), v11, v12, v15, v15, a4);
          }
        }
      }
LABEL_22:
      ;
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  const re::TypeInfo *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t i;
  uint64_t v29;
  uint64_t v30;
  re *v31;
  uint64_t v32;
  uint64_t v33;
  _DWORD *v34;
  NSObject *v35;
  NSObject *v36;
  uint64_t v37;
  re::internal *v38;
  uint64_t v39;
  _BYTE v40[32];
  _BYTE v41[32];
  _QWORD *v42[2];
  uint64_t v43;
  _QWORD *v44[2];
  uint64_t v45;
  uint64_t v46[4];
  unint64_t v47;
  uint64_t v48[5];
  _BYTE v49[8];
  uint64_t v50;
  char v51;
  uint64_t *v52;
  _BYTE v53[8];
  uint64_t v54;
  char v55;
  uint64_t *v56;
  uint8_t buf[4];
  uint64_t v58;
  __int16 v59;
  uint64_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  re::TypeRegistry::typeInfo((_QWORD *)*a3, *(_QWORD *)(a3[2] + 72), v53);
  re::TypeRegistry::typeInfo((_QWORD *)*a4, *(_QWORD *)(a4[2] + 72), v49);
  if (v49[0])
  {
    if (!v53[0])
    {
      v11 = re::TypeInfo::name((re::TypeInfo *)&v50)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
      return re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Base class \"%s\" removed from type \"%s\".", v12, v13, v14, v15, v16, v11);
    }
    if (re::EncoderOPACK<re::FixedArrayInputStream>::beginObject(a1 + 24, "@super", 0, 0))
    {
      if (v54 == v50)
      {
        v18 = *v56;
        v19 = *v52;
        if ((unsigned __int16)*v56 == (unsigned __int16)*v52)
        {
          v21 = WORD1(v18) == WORD1(v19);
          v20 = (v19 ^ v18) & 0xFFFFFF00000000;
          v21 = v21 && v20 == 0;
          if (v21)
            goto LABEL_6;
        }
      }
      else if (re::areSameTranslatedVersion((re *)&v54, (const re::TypeInfo *)&v50, v10))
      {
LABEL_6:
        re::internal::serializeMembersWithoutVersioning<re::EncoderOPACK<re::FixedArrayInputStream>>((_BYTE *)a1, a2, &v54, a5);
LABEL_16:
        re::EncoderOPACK<re::FixedArrayInputStream>::endObject(a1 + 24);
        goto LABEL_17;
      }
      if (v55 == v51)
      {
        re::internal::serializeMembersWithVersioning<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, &v54, &v50, a5);
      }
      else
      {
        v22 = re::TypeInfo::name((re::TypeInfo *)&v54)[1];
        re::TypeInfo::name((re::TypeInfo *)&v50);
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v23, v24, v25, v26, v27, v22);
      }
      goto LABEL_16;
    }
  }
LABEL_17:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v48, *a3, a3[2]);
  result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v46, *a4, a4[2]);
  if (v47)
  {
    for (i = 0; i < v47; ++i)
    {
      if (*(_BYTE *)(a1 + 64))
        break;
      result = (uint64_t)re::TypeMemberCollection::operator[](v46, i, (uint64_t)v44);
      if (*(_BYTE *)(v45 + 28))
      {
        v29 = *(_QWORD *)(v45 + 16);
        if (strlen((const char *)v29) >= 3 && *(_BYTE *)v29 == 109)
          v29 += 2 * (*(_BYTE *)(v29 + 1) == 95);
        v30 = *(unsigned int *)(v45 + 32);
        v31 = *(re **)(*a4 + 856);
        if (!v31
          || (v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v44),
              (_DWORD)v31 == -1))
        {
          v35 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
          {
            v36 = v35;
            v37 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            v58 = v37;
            v59 = 2080;
            v60 = v29;
            _os_log_impl(&dword_224FE9000, v36, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);

          }
          v38 = *(re::internal **)(a1 + 208);
          re::TypeRegistry::typeInfo(v44[0], *(_QWORD *)v45, buf);
          re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v58 + 4);
          result = re::internal::translateType(v38, (const re::TypeRegistry *)v42, (uint64_t)buf);
          if (!*(_BYTE *)(a1 + 64))
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint8_t *, uint8_t *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
        }
        else
        {
          re::TypeMemberCollection::operator[](v48, (int)v31, (uint64_t)v42);
          v32 = a2 + *(unsigned int *)(v43 + 24);
          re::TypeRegistry::typeInfo(v42[0], *(_QWORD *)v43, buf);
          re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v58 + 4);
          re::TypeRegistry::typeInfo(v44[0], *(_QWORD *)v45, buf);
          re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v58 + 4);
          if (*(_BYTE *)(a1 + 64)
            || (result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, v32, v41, v40, a5), (result & 1) == 0))
          {
            result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a4);
            if (v33)
            {
              v34 = (_DWORD *)(result + 16);
              while (i != *v34)
              {
                v34 += 6;
                if (!--v33)
                  goto LABEL_37;
              }
              v39 = *((_QWORD *)v34 - 1);
              re::TypeRegistry::typeInfo(v42[0], *(_QWORD *)v43, buf);
              re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v58 + 4);
              re::TypeRegistry::typeInfo(v44[0], *(_QWORD *)v45, buf);
              result = re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v58 + 4);
              if (!*(_BYTE *)(a1 + 64))
                result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v39, v30, v32, v41, v40, a5);
            }
          }
        }
      }
LABEL_37:
      ;
    }
  }
  return result;
}

uint64_t re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::deserializeSharedObjects(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  const char *v22;
  __int128 *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  void **Instance;
  char v38;
  const char *v39;
  const char *v40;
  char v41;
  uint64_t v42;
  unint64_t v43;
  char **v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  int v48;
  char **v49;
  BOOL v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char **v57;
  uint64_t v58;
  void **v59;
  uint64_t v60;
  void (*v61)(char **);
  uint64_t v62;
  re *v63;
  const char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  re *v78[2];
  __int128 v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t *v82;
  _WORD v83[20];
  _DWORD v84[8];
  uint64_t v85;
  unsigned __int16 v86;
  unsigned __int16 v87;
  int v88;
  _BYTE v89[32];
  __int128 v90;
  re *v91[2];
  uint64_t v92;
  _QWORD *v93[4];
  __int16 v94;
  __int128 v95;
  uint64_t v96;
  uint64_t v97;
  const char *v98;
  uint64_t v99;

  if (!*(_BYTE *)(result + 64))
  {
    v9 = result;
    v10 = result + 24;
    result = re::EncoderOPACK<re::FixedArrayInputStream>::beginObject(result + 24, "@shared", 20, 0);
    if ((result & 1) != 0)
    {
      v16 = *(_QWORD *)(v9 + 56);
      v98 = 0;
      v99 = 0;
      v96 = v16;
      v97 = 0;
      re::DynamicString::setCapacity(&v96, 8uLL);
      v17 = v9 + 400;
      LODWORD(v90) = 0;
      v18 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet(v9 + 400, (unsigned int *)&v90);
      if (v18)
        *((_QWORD *)&v95 + 1) = **(_QWORD **)(v18 + 24);
      else
        *((_QWORD *)&v95 + 1) = 0xFFFFFFFFLL;
      if (*(_QWORD *)(v9 + 376))
      {
        v77 = v10;
        v19 = 0;
        v20 = 0;
        LODWORD(v21) = *(_DWORD *)(v9 + 428) - 1;
        v22 = (char *)&v97 + 1;
        do
        {
          v23 = (__int128 *)(*(_QWORD *)(v9 + 392) + v19);
          v90 = *v23;
          re::TypeInfo::TypeInfo((uint64_t)v91, (uint64_t)(v23 + 1));
          re::TypeInfo::TypeInfo((uint64_t)v93, (uint64_t)(v23 + 3));
          v94 = *((_WORD *)v23 + 40);
          if ((v90 & 0x80000000) != 0)
          {
            re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(v9, 0, "Invalid referenceID %u.", v24, v25, v26, v27, v28, v90);
            goto LABEL_69;
          }
          re::TypeRegistry::typeInfo((_QWORD *)v91[0], *(_QWORD *)(v92 + 72), &v80);
          re::TypeInfo::TypeInfo((uint64_t)v89, (uint64_t)&v81);
          re::TypeRegistry::typeInfo(v93[0], v93[2][9], &v80);
          re::TypeInfo::TypeInfo((uint64_t)&v85, (uint64_t)&v81);
          if ((int)v90 > (int)v21)
          {
            re::DynamicString::assignf((re::DynamicString *)&v96, "%u", (_DWORD)v90);
            v21 = v90;
            if ((_BYTE)v94)
            {
              if ((v97 & 1) != 0)
                v29 = v98;
              else
                v29 = v22;
              if (!re::internal::deserializePolymorphicObject<re::EncoderOPACK<re::FixedArrayInputStream>,false>(v9, v29, v90, *((void ***)&v90 + 1), v91, (re::TypeInfo *)v89, (re::TypeInfo *)&v85, HIBYTE(v94), 0))goto LABEL_62;
            }
            else
            {
              v35 = v22;
              v36 = **((_QWORD **)&v90 + 1);
              if (!**((_QWORD **)&v90 + 1))
              {
                Instance = re::TypeInfo::createInstance((re::TypeInfo *)v89, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
                **((_QWORD **)&v90 + 1) = Instance;
                v36 = **((_QWORD **)&v90 + 1);
              }
              v38 = v97;
              v39 = v98;
              re::TypeRegistry::typeInfo((_QWORD *)v91[0], *(_QWORD *)(v92 + 72), &v80);
              re::TypeInfo::TypeInfo((uint64_t)v84, (uint64_t)&v81);
              if (*(_BYTE *)(v9 + 64))
                goto LABEL_67;
              if ((v38 & 1) != 0)
                v40 = v39;
              else
                v40 = v35;
              v22 = v35;
              v41 = (*(uint64_t (**)(uint64_t, const char *, uint64_t, uint64_t, _DWORD *, uint64_t *, _QWORD))(*(_QWORD *)v9 + 72))(v9, v40, v21, v36, v84, &v85, 0);
              v17 = v9 + 400;
              if ((v41 & 1) == 0)
              {
LABEL_62:
                if (!*(_BYTE *)(v9 + 64))
                {
                  if ((v97 & 1) != 0)
                    v64 = v98;
                  else
                    v64 = v22;
                  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(v9, v64, "Failed to deserialize shared object (reference ID = %d).", v30, v31, v32, v33, v34, v21);
                }
LABEL_67:
                if (**((_QWORD **)&v90 + 1))
                {
                  re::TypeInfo::releaseInstance((re::TypeInfo *)v89, **((void ***)&v90 + 1), *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
                  **((_QWORD **)&v90 + 1) = 0;
                }
                goto LABEL_69;
              }
            }
            v42 = **((_QWORD **)&v90 + 1);
            v84[0] = v21;
            v80 = v42;
            re::TypeInfo::TypeInfo((uint64_t)&v81, (uint64_t)v89);
            re::TypeInfo::TypeInfo((uint64_t)v83, (uint64_t)&v85);
            v83[16] = v94;
            re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addNew(v17, v84, (uint64_t)&v80);
          }
          ++v20;
          v43 = *(_QWORD *)(v9 + 376);
          v19 += 88;
        }
        while (v43 > v20);
        *(_QWORD *)&v95 = 0;
        *((_QWORD *)&v95 + 1) = 0xFFFFFFFFLL;
        v10 = v77;
        if (v43)
        {
          v44 = 0;
          v45 = *(_QWORD *)(v9 + 392);
          v46 = 88 * v43;
          v47 = -1;
          do
          {
            re::TypeRegistry::typeInfo(*(_QWORD **)(v45 + 16), *(_QWORD *)(*(_QWORD *)(v45 + 32) + 72), &v90);
            re::TypeInfo::TypeInfo((uint64_t)&v80, (uint64_t)&v90 + 8);
            re::TypeRegistry::typeInfo(*(_QWORD **)(v45 + 48), *(_QWORD *)(*(_QWORD *)(v45 + 64) + 72), &v90);
            re::TypeInfo::TypeInfo((uint64_t)v89, (uint64_t)&v90 + 8);
            v48 = *(_DWORD *)v45;
            if (*(_DWORD *)v45 == v47)
            {
              v79 = v95;
              if (!re::internal::areCompatible((re **)(v45 + 16), (uint64_t)&v79))
              {
                v65 = re::TypeInfo::name((re::TypeInfo *)&v80)[1];
                re::TypeRegistry::typeName(*(_anonymous_namespace_ **)(v9 + 208), &v95);
                re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(v9, 0, "Invalid reference. Objects are not compatible. Expected type \"%s\". Actual type \"%s\".", v66, v67, v68, v69, v70, v65);
                goto LABEL_69;
              }
              v49 = **(char ****)(v45 + 8);
              if (v49)
                v50 = v49 == v44;
              else
                v50 = 1;
              if (!v50)
                re::TypeInfo::releaseInstance((re::TypeInfo *)&v80, v49, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
              re::TypeInfo::TypeInfo((uint64_t)&v90, (uint64_t)&v80);
              if (*(_BYTE *)(v45 + 80))
              {
                if (!(_QWORD)v95)
                {
                  v76 = re::TypeInfo::name((re::TypeInfo *)&v80)[1];
                  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(v9, 0, "Invalid reference. Polymorphic type \"%s\" has invalid actual type.", v71, v72, v73, v74, v75, v76);
                  goto LABEL_69;
                }
                LODWORD(v85) = v47;
                v51 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet(v17, (unsigned int *)&v85);
                if (!v51)
                {
                  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(v9, 0, "Invalid reference. No such object %z", v52, v53, v54, v55, v56, v47);
                  goto LABEL_69;
                }
                re::TypeInfo::operator=((uint64_t)&v90, v51 + 8);
              }
              v57 = *(char ***)(v45 + 8);
              if ((*((_BYTE *)v82 + 49) & 2) != 0)
              {
                *v57 = (char *)v44;
                v61 = (void (*)(char **))v82[4];
                if (v61)
                  v61(v44);
                if (*(_BYTE *)(v45 + 80))
                {
                  v62 = *(_QWORD *)(v45 + 8);
                  v63 = *(re **)v91[0];
                  v78[0] = (re *)v90;
                  v78[1] = v63;
                  re::TypeInfo::setActualTypeForPointer((_QWORD **)(v45 + 16), v62, v78);
                }
              }
              else
              {
                if (*v57)
                {
                  if (*(_BYTE *)(v45 + 80))
                  {
                    re::TypeInfo::getActualTypeFromPointer((uint64_t)&v80, *v57, &v85);
                    if (v85 != (_QWORD)v90
                      || (v58 = *(_QWORD *)v91[0], v86 != (unsigned __int16)*(_QWORD *)v91[0])
                      || v87 != WORD1(v58)
                      || ((v88 ^ HIDWORD(v58)) & 0xFFFFFF) != 0)
                    {
                      re::TypeInfo::releaseInstance((re::TypeInfo *)&v80, **(void ***)(v45 + 8), *(re::Allocator **)(v9 + 48), 0);
                    }
                  }
                }
                v59 = **(void ****)(v45 + 8);
                if (!v59)
                {
                  **(_QWORD **)(v45 + 8) = re::TypeInfo::createInstance((re::TypeInfo *)&v90, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
                  v59 = **(void ****)(v45 + 8);
                }
                re::TypeInfo::copy((re::TypeInfo *)&v90, v59, v44, *(re::Allocator **)(v9 + 48), *(void **)(v9 + 200));
              }
            }
            else if (v48 > v47)
            {
              v44 = **(char ****)(v45 + 8);
              v60 = *v82;
              *(_QWORD *)&v95 = v80;
              *((_QWORD *)&v95 + 1) = v60;
              v47 = v48;
            }
            v45 += 88;
            v46 -= 88;
          }
          while (v46);
        }
      }
      re::EncoderOPACK<re::FixedArrayInputStream>::endObject(v10);
LABEL_69:
      result = v96;
      if (v96)
      {
        if ((v97 & 1) != 0)
          return (*(uint64_t (**)(void))(*(_QWORD *)v96 + 40))();
      }
    }
    else if (!*(_BYTE *)(v9 + 64) && *(_QWORD *)(v9 + 376))
    {
      return re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(v9, "@shared", "Failed to deserialize shared objects. Entry not found.", v11, v12, v13, v14, v15, a9);
    }
  }
  return result;
}

uint64_t re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::tryGet(uint64_t a1, unsigned int *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v6;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *a2;
  v3 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) >> 27));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v3 ^ (v3 >> 31)) % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_DWORD *)(v6 + 96 * v4 + 12) != (_DWORD)v2)
  {
    while (1)
    {
      LODWORD(v4) = *(_DWORD *)(v6 + 96 * v4 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v4 == 0x7FFFFFFF)
        break;
      if (*(_DWORD *)(v6 + 96 * v4 + 12) == (_DWORD)v2)
        return v6 + 96 * v4 + 16;
    }
    return 0;
  }
  return v6 + 96 * v4 + 16;
}

BOOL re::internal::deserializePolymorphicObject<re::EncoderOPACK<re::FixedArrayInputStream>,false>(uint64_t a1, const char *a2, uint64_t a3, void **a4, re **a5, re::TypeInfo *a6, re::TypeInfo *a7, int a8, char a9)
{
  uint64_t v15;
  int v16;
  _BOOL8 result;
  re::TypeRegistry *v18;
  uint64_t *v19;
  char *v20;
  re::TypeRegistry *v21;
  _BOOL8 v22;
  NSObject *v23;
  char *v24;
  uint64_t *v25;
  uint64_t *v26;
  re *v27;
  re *v28;
  void **Instance;
  NSObject *v30;
  NSObject *v31;
  uint64_t v32;
  NSObject *v33;
  NSObject *v34;
  uint64_t v35;
  _QWORD v36[2];
  re *v37[2];
  _QWORD v38[2];
  _QWORD v39[2];
  _BYTE v40[32];
  uint64_t *v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  re *v45[2];
  uint64_t v46;
  uint8_t buf[4];
  uint64_t v48;
  __int16 v49;
  _BYTE v50[18];
  uint64_t v51;

  v51 = *MEMORY[0x24BDAC8D0];
  v15 = a1 + 24;
  v16 = re::EncoderOPACK<re::FixedArrayInputStream>::beginObject(a1 + 24, a2, 0, 0);
  result = 0;
  if (v16)
  {
    v46 = 0;
    if ((re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned long long>(v15, "customClassID", 1, (char *)&v46, 0) & 1) == 0)return 0;
    re::TypeInfo::typeIDForCustomClassID(a7, v46, v45);
    if (v45[0])
    {
      if ((a9 & 1) == 0 && *a4)
      {
        re::TypeInfo::releaseInstance(a6, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
        *a4 = 0;
      }
      re::TypeRegistry::typeInfo(*(re **)a7, v45, buf);
      re::TypeInfo::TypeInfo((uint64_t)&v41, (uint64_t)&v48 + 4);
      if (a8)
      {
        v18 = *(re::TypeRegistry **)(a1 + 208);
      }
      else
      {
        v18 = *(re::TypeRegistry **)(a1 + 208);
        if (*a5 == v18)
        {
          re::TypeInfo::operator=((uint64_t)a6, (uint64_t)&v41);
          v27 = v45[0];
          v28 = v45[1];
          if ((a9 & 1) != 0)
          {
LABEL_30:
            Instance = 0;
            goto LABEL_37;
          }
LABEL_36:
          Instance = re::TypeInfo::createInstance(a6, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
          *a4 = Instance;
          v37[0] = v27;
          v37[1] = v28;
          re::internal::setActualType(a4, a5, v37);
LABEL_37:
          v36[0] = v27;
          v36[1] = v28;
          (*(void (**)(uint64_t, void **, _QWORD *))(*(_QWORD *)a1 + 16))(a1, Instance, v36);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, const char *, uint64_t, void **, re::TypeInfo *, uint64_t **, BOOL))(*(_QWORD *)a1 + 72))(a1, "object", 10, Instance, a6, &v41, Instance == 0);
LABEL_39:
          (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
          re::EncoderOPACK<re::FixedArrayInputStream>::endObject(v15);
          return *(_BYTE *)(a1 + 64) == 0;
        }
      }
      v25 = re::TypeInfo::name((re::TypeInfo *)&v41);
      v26 = re::TypeRegistry::typeInfo(v18, (const re::StringID *)v25, buf);
      if (!buf[0] || !*(_BYTE *)(*(_QWORD *)&v50[10] + 120))
      {
        v30 = *re::foundationSerializationLogObjects((re *)v26);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          v31 = v30;
          v32 = re::TypeInfo::name((re::TypeInfo *)&v41)[1];
          *(_DWORD *)buf = 136315138;
          v48 = v32;
          _os_log_impl(&dword_224FE9000, v31, OS_LOG_TYPE_DEFAULT, "No matching runtime type found for serialized polymorphic type \"%s\". Skipping unknown type.", buf, 0xCu);

        }
        v38[0] = 0;
        v38[1] = 0xFFFFFFFFLL;
        (*(void (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)a1 + 16))(a1, 0, v38);
        if (!*(_BYTE *)(a1 + 64))
          (*(void (**)(uint64_t, const char *, uint64_t, _QWORD, uint64_t **, uint64_t **, uint64_t))(*(_QWORD *)a1 + 72))(a1, "object", 10, 0, &v41, &v41, 1);
        goto LABEL_39;
      }
      re::TypeInfo::operator=((uint64_t)a6, (uint64_t)&v48 + 4);
      v27 = *(re **)a6;
      v28 = (re *)**((_QWORD **)a6 + 2);
      if ((a9 & 1) != 0)
        goto LABEL_30;
      goto LABEL_36;
    }
    if ((a9 & 1) == 0 && *a4)
    {
      re::TypeInfo::releaseInstance(a6, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
      *a4 = 0;
    }
    v19 = re::TypeInfo::name(a7);
    if ((unint64_t)*v19 >> 1 == 0x36D724013CDDLL)
    {
      v20 = (char *)v19[1];
      if (v20 == "Component" || (v19 = (uint64_t *)strcmp(v20, "Component"), !(_DWORD)v19))
      {
        v19 = (uint64_t *)re::EncoderOPACK<re::FixedArrayInputStream>::checkForString(v15, 10);
        if ((_DWORD)v19)
        {
          v42 = 0;
          v43 = 0;
          v44 = 0;
          re::DynamicString::setCapacity(&v41, 0);
          v21 = *(re::TypeRegistry **)(a1 + 208);
          v39[0] = 0x2686EB529B3EE220;
          v39[1] = "DynamicString";
          re::TypeRegistry::typeInfo(v21, (const re::StringID *)v39, buf);
          re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v48 + 4);
          re::StringID::destroyString((re::StringID *)v39);
          v22 = re::serializeDynamicString<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, "object", (const re::TypeInfo *)0xA, &v41, (re *)v40, (const re::TypeInfo *)v40, 0);
          if (v22)
          {
            v23 = *re::foundationSerializationLogObjects((re *)v22);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
            {
              if ((v42 & 1) != 0)
                v24 = v43;
              else
                v24 = (char *)&v42 + 1;
              *(_DWORD *)buf = 134218498;
              v48 = v46;
              v49 = 1040;
              *(_DWORD *)v50 = 256;
              *(_WORD *)&v50[4] = 2080;
              *(_QWORD *)&v50[6] = v24;
              _os_log_impl(&dword_224FE9000, v23, OS_LOG_TYPE_DEFAULT, "Skipping unknown Component %llu. String data: %.256s", buf, 0x1Cu);
            }
            if (v41 && (v42 & 1) != 0)
              (*(void (**)(void))(*v41 + 40))();
LABEL_45:
            re::EncoderOPACK<re::FixedArrayInputStream>::endObject(v15);
            return 1;
          }
          v19 = v41;
          if (v41 && (v42 & 1) != 0)
            v19 = (uint64_t *)(*(uint64_t (**)(void))(*v41 + 40))();
        }
      }
    }
    v33 = *re::foundationSerializationLogObjects((re *)v19);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      v34 = v33;
      v35 = re::TypeInfo::name(a7)[1];
      *(_DWORD *)buf = 136315394;
      v48 = v35;
      v49 = 2048;
      *(_QWORD *)v50 = v46;
      _os_log_impl(&dword_224FE9000, v34, OS_LOG_TYPE_DEFAULT, "Skipping unknown polymorphic \"%s\" type. Custom class ID = %llu", buf, 0x16u);

    }
    goto LABEL_45;
  }
  return result;
}

uint64_t re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addNew(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
  v8 = v7 ^ (v7 >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 96 * v13;
    return v12 + 16;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_DWORD *)(v11 + 96 * v10 + 12) != (_DWORD)v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 96 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + 96 * v10;
  return v12 + 16;
}

BOOL re::EncoderOPACK<re::FixedArrayInputStream>::checkForString(uint64_t a1, char a2)
{
  _BOOL8 result;
  uint64_t v5;
  uint64_t v6;
  int v7;
  unint64_t v8;
  unsigned __int8 v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  unsigned __int8 v13;
  unsigned __int8 __dst;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  __dst = 0;
  v5 = *(_QWORD *)(a1 + 168);
  if (v5)
  {
    v6 = v5 - 1;
    v7 = *(unsigned __int8 *)(a1 + v5 - 1 + 160);
    __dst = v7;
    *(_QWORD *)(a1 + 168) = v6;
  }
  else
  {
    if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&__dst, 1uLL))
    {
      re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, "check", (uint64_t)"Key");
      return 0;
    }
    v7 = __dst;
  }
  if (v7 != (a2 + 8))
  {
    v10 = *(_QWORD *)(a1 + 168);
    if (v10 <= 7)
    {
      result = 0;
      *(_QWORD *)(a1 + 168) = v10 + 1;
      *(_BYTE *)(a1 + v10 + 160) = v7;
      return result;
    }
    return 0;
  }
  v13 = 0;
  v8 = *(_QWORD *)(a1 + 168);
  if (!*(_BYTE *)(a1 + 40))
  {
    if (v8)
    {
      v11 = v8 - 1;
      v12 = *(unsigned __int8 *)(a1 + v11 + 160);
      *(_QWORD *)(a1 + 168) = v11;
    }
    else
    {
      if (!re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&v13, 1uLL))
      {
        re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, "check", (uint64_t)"String");
        v8 = *(_QWORD *)(a1 + 168);
        goto LABEL_10;
      }
      v12 = v13;
      v11 = *(_QWORD *)(a1 + 168);
    }
    result = (v12 - 64) < 0x30;
    if (v11 <= 7)
    {
      *(_QWORD *)(a1 + 168) = v11 + 1;
      *(_BYTE *)(a1 + v11 + 160) = v12;
      v8 = *(_QWORD *)(a1 + 168);
      if (v8 <= 7)
        goto LABEL_11;
    }
    return result;
  }
LABEL_10:
  result = 0;
  if (v8 < 8)
  {
LABEL_11:
    v9 = __dst;
    *(_QWORD *)(a1 + 168) = v8 + 1;
    *(_BYTE *)(a1 + v8 + 160) = v9;
  }
  return result;
}

uint64_t re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _DWORD *a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 96 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 96 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 96 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 96 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 96 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 96 * v10) = a3;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 96 * v10 + 12) = *a4;
  v14 = *(_QWORD *)(a1 + 16) + 96 * v10;
  *(_QWORD *)(v14 + 16) = *(_QWORD *)a5;
  re::TypeInfo::TypeInfo(v14 + 24, a5 + 8);
  re::TypeInfo::TypeInfo(v14 + 56, a5 + 40);
  *(_WORD *)(v14 + 88) = *(_WORD *)(a5 + 72);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 12, *(_QWORD *)&v13[16] + v10 + 16);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 96;
        }
        while (v11 < v9);
      }
      re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

void re::HashTable<unsigned int,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::SharedObject,re::Hash<unsigned int>,re::EqualTo<unsigned int>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 96 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_402, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t *re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFunc(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t *result;
  BOOL v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  v5 = *(_QWORD *)(a1 + 208);
  result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v5 + 200, a2);
  if (v5)
    v7 = result == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v8 = *result;
    v10 = a3;
    v9 = v8 | 0xFFFFFFFF00000000;
    return (uint64_t *)re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1 + 224, &v9, &v10);
  }
  return result;
}

uint64_t re::serializeBool<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, _BYTE *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeBool(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::FixedArrayInputStream>::serializeBool(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeBool(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeChar<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI8<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<signed char>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI16<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, __int16 *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<short>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<short>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<short>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI32<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, int *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<int>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<int>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<int>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI64<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, _QWORD *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<long long>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<long long>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeSignedInteger<long long>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU8<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned char>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned char>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned char>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU16<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, __int16 *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned short>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned short>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned short>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU32<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, int *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned int>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned int>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned int>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU64<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeUnsignedInteger<unsigned long long>(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeFloat<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeFloat(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::FixedArrayInputStream>::serializeFloat(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeFloat(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeDouble<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  int v9;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  v9 = (int)a3;
  if (a5 == a6)
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeDouble(a1 + 24, a2, v9, a4, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderOPACK<re::FixedArrayInputStream>::serializeDouble(a1 + 24, a2, v9, a4, a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderOPACK<re::FixedArrayInputStream>::serializeDouble(a1 + 24, a2, v9, a4, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

BOOL re::serializeCString<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  _BOOL8 result;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  size_t v27;
  char *v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  char v46;
  size_t v47;
  int v48;

  v9 = (int)a3;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_22:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    v23 = **((_QWORD **)a5 + 2);
    v24 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v23 != (unsigned __int16)v24)
      goto LABEL_22;
    v26 = WORD1(v23) == WORD1(v24);
    v25 = (v24 ^ v23) & 0xFFFFFF00000000;
    v26 = v26 && v25 == 0;
    if (!v26)
      goto LABEL_22;
  }
LABEL_4:
  if (a7)
  {
    v48 = 0;
    v19 = re::EncoderOPACK<re::FixedArrayInputStream>::beginPointer(a1 + 24, a2, v9, &v48, 0);
    result = 0;
    if (!v19)
      return result;
    if (!v48)
      goto LABEL_12;
    if (v48 != 1)
    {
      v47 = 0;
      if (re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, 0, (uint64_t *)&v47, 0))
      {
        if (v47)
          re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
        re::EncoderOPACK<re::FixedArrayInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
LABEL_12:
      re::EncoderOPACK<re::FixedArrayInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
      goto LABEL_47;
    }
    goto LABEL_16;
  }
  v48 = 2 * (*a4 != 0);
  v21 = re::EncoderOPACK<re::FixedArrayInputStream>::beginPointer(a1 + 24, a2, v9, &v48, 0);
  result = 0;
  if (!v21)
    return result;
  v22 = v48;
  if (v48)
  {
    if (v48 == 1)
    {
LABEL_16:
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Found pointer reference instead of C string.", v14, v15, v16, v17, v18, v46);
      return 0;
    }
  }
  else
  {
    if (!*a4)
      goto LABEL_44;
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
    *a4 = 0;
    v22 = v48;
  }
  if (v22 == 2)
  {
    v27 = *a4 ? strlen(*a4) : 0;
    v47 = v27;
    if (re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, 0, (uint64_t *)&v47, 0))
    {
      v28 = (char *)*a4;
      v29 = v47;
      if (!*a4 || v47 != v27)
      {
        if (v28)
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
          *a4 = 0;
          v29 = v47;
        }
        v30 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
        v36 = v47;
        if (v29 > v30)
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v37, v38, v39, v40, v41, v36);
          return 0;
        }
        v42 = v47 == -1;
        v43 = v42 << 63 >> 63;
        if (v43 != v42 || v43 < 0)
        {
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, v47);
          return 0;
        }
        v28 = (char *)(*(uint64_t (**)(_QWORD, size_t, _QWORD))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v47 + 1, 0);
        *a4 = v28;
        v27 = v47;
      }
      if (v27)
      {
        re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, v28, 0);
        v28 = (char *)*a4;
        v44 = v47;
      }
      else
      {
        v44 = 0;
      }
      v28[v44] = 0;
      re::EncoderOPACK<re::FixedArrayInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    }
  }
LABEL_44:
  re::EncoderOPACK<re::FixedArrayInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
  v45 = *(unsigned __int8 *)(a1 + 64);
  if (!*a4 || !*(_BYTE *)(a1 + 64))
    return v45 == 0;
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
  *a4 = 0;
LABEL_47:
  v45 = *(unsigned __int8 *)(a1 + 64);
  return v45 == 0;
}

BOOL re::serializeStringID<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v9;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  char *v19;
  int v20;
  _BOOL8 result;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  _anonymous_namespace_ *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;

  v9 = (int)a3;
  if (a5 == a6)
    goto LABEL_14;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x134375A94D9F7110
    || (v19 = (char *)v18[1], v19 != "DynamicString") && strcmp(v19, "DynamicString"))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v47 = 0;
    v20 = re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v47, 0);
    result = 0;
    if (!v20)
      return result;
    if (v47)
      re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
    goto LABEL_26;
  }
  v46 = 0;
  if (re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, v9, (uint64_t *)&v46, 0))
  {
    v22 = v46;
    if (v46)
    {
      v23 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
      v29 = v46;
      if (v22 > v23)
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v30, v31, v32, v33, v34, v29);
        return 0;
      }
      v36 = v46 == -1;
      v37 = v36 << 63 >> 63;
      if (v37 != v36 || v37 < 0)
      {
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v24, v25, v26, v27, v28, v46);
        return 0;
      }
      v38 = (char *)(*(uint64_t (**)(_QWORD, unint64_t, _QWORD))(**(_QWORD **)(a1 + 56) + 32))(*(_QWORD *)(a1 + 56), v46 + 1, 0);
      v39 = (_anonymous_namespace_ *)re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, v38, 0);
      v38[v46] = 0;
      v44 = 0;
      v45 = &str_110;
      v40 = v44;
      v41 = (uint64_t)v45;
      v44 = 0;
      v45 = &str_110;
      v42 = *a4;
      v43 = a4[1];
      *a4 = v40;
      a4[1] = v41;
      v47 = v40 & 0xFFFFFFFFFFFFFFFELL | v42 & 1;
      v48 = v43;
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
      (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 56) + 40))(*(_QWORD *)(a1 + 56), v38);
    }
    else
    {
      v44 = 0;
      v45 = &str_110;
      v35 = a4[1];
      v47 = *a4 & 1;
      v48 = v35;
      *a4 = 0;
      a4[1] = (uint64_t)&str_110;
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
    }
LABEL_26:
    re::EncoderOPACK<re::FixedArrayInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return 0;
}

uint64_t re::serializeIntrospectionCallbackSerializer<re::EncoderOPACK<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  int v10;
  int v14;
  uint64_t result;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  re *v24;
  NSObject *v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  unint64_t v36;
  _BYTE buf[22];
  __int16 v38;
  uint64_t v39;
  uint64_t v40;

  v10 = (int)a3;
  v40 = *MEMORY[0x24BDAC8D0];
  if (a5 == a6)
    goto LABEL_4;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v28 = **((_QWORD **)a5 + 2);
    v29 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v28 == (unsigned __int16)v29)
    {
      v31 = WORD1(v28) == WORD1(v29);
      v30 = (v29 ^ v28) & 0xFFFFFF00000000;
      v31 = v31 && v30 == 0;
      if (v31)
        goto LABEL_4;
    }
LABEL_32:
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_32;
LABEL_4:
  if (a7)
  {
    v32 = 0;
    v14 = re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, v10, &v32, 0);
    result = 0;
    if (!v14)
      return result;
    if (v32)
      re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
    re::EncoderOPACK<re::FixedArrayInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
  }
  else
  {
    v16 = **((_QWORD **)a5 + 2);
    v32 = *(_QWORD *)a5;
    v33 = v16;
    LODWORD(v34) = -1;
    *(_QWORD *)buf = 0x258C98EAAF29A10ALL;
    *(_QWORD *)&buf[8] = "CallbackSerializerAttribute";
    v17 = (uint64_t *)re::TypeAttributeCollection::operator[](&v32, buf);
    re::StringID::destroyString((re::StringID *)buf);
    v18 = *v17;
    v19 = *(_QWORD *)(a1 + 200);
    v36 = 0;
    result = re::EncoderOPACK<re::FixedArrayInputStream>::beginString(a1 + 24, a2, v10, (uint64_t *)&v36, 0);
    if (!(_DWORD)result)
      return result;
    v20 = *(_QWORD *)(a1 + 56);
    v34 = 0;
    v35 = 0;
    v32 = v20;
    v33 = 0;
    re::DynamicString::setCapacity(&v32, 0);
    if (v36)
    {
      re::DynamicString::resize(&v32, v36, 0);
      if ((v33 & 1) != 0)
        v21 = v34;
      else
        v21 = (char *)&v33 + 1;
      re::EncoderOPACK<re::FixedArrayInputStream>::serializeString(a1 + 24, v21, 0);
    }
    re::EncoderOPACK<re::FixedArrayInputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    v22 = (char *)&v33 + 1;
    if ((v33 & 1) != 0)
      v23 = v34;
    else
      v23 = (char *)&v33 + 1;
    v24 = (re *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, char *))(v18 + 80))(*(_QWORD *)(a1 + 48), v19, v18, a4, v23);
    if ((v24 & 1) == 0)
    {
      v25 = *re::foundationSerializationLogObjects(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        if ((v33 & 1) != 0)
          v22 = v34;
        v26 = v25;
        v27 = re::TypeInfo::name(a5)[1];
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = a2;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v22;
        v38 = 2080;
        v39 = v27;
        _os_log_impl(&dword_224FE9000, v26, OS_LOG_TYPE_INFO, "Failed to parse \"%s\": \"%s\" (type %s) using deserialization callback - skipping.", buf, 0x20u);

      }
    }
    if (v32 && (v33 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v32 + 40))();
  }
  return *(_BYTE *)(a1 + 64) == 0;
}

uint64_t re::EncoderOPACK<re::FixedArrayInputStream>::beginPointer(uint64_t a1, const char *a2, int a3, int *a4, int a5)
{
  uint64_t result;
  _BOOL8 v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  unint64_t v15;
  __int128 v16;
  uint64_t v17;
  _BOOL8 v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 __dst;
  uint64_t v22;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v22 = 0;
  result = re::EncoderOPACK<re::FixedArrayInputStream>::advance(a1, a2, a3, &v22, 0);
  if ((_DWORD)result)
  {
    __dst = 0;
    if (*(_BYTE *)(a1 + 40))
    {
LABEL_5:
      v10 = *a4 != 0;
      LOBYTE(v16) = 9;
      DWORD1(v16) = a5;
      *((_QWORD *)&v16 + 1) = a2;
      v17 = 0;
      v19 = 0;
      v20 = 0;
      v18 = v10;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v16);
      *(_QWORD *)(*(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112) - 32) = v22;
      return *(_BYTE *)(a1 + 40) == 0;
    }
    v11 = *(_QWORD *)(a1 + 168);
    if (v11)
    {
      v12 = v11 - 1;
      v13 = *(unsigned __int8 *)(a1 + v11 - 1 + 160);
      __dst = v13;
      *(_QWORD *)(a1 + 168) = v12;
    }
    else
    {
      if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, (char *)&__dst, 1uLL) & 1) == 0)
      {
        re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, (uint64_t)"Optional");
        goto LABEL_5;
      }
      v13 = __dst;
    }
    if (v13 == 4)
    {
      *a4 = 0;
    }
    else
    {
      if ((v13 - 7) > 0x2C)
        v14 = 2;
      else
        v14 = 1;
      *a4 = v14;
      v15 = *(_QWORD *)(a1 + 168);
      if (v15 <= 7)
      {
        *(_QWORD *)(a1 + 168) = v15 + 1;
        *(_BYTE *)(a1 + v15 + 160) = v13;
      }
    }
    goto LABEL_5;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderOPACK<re::FixedArrayInputStream>::endPointer(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  _anonymous_namespace_ *v8;
  char v9;
  _BYTE v10[23];
  _OWORD v11[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    v2 = *((_QWORD *)result + 16);
    v3 = *((_QWORD *)result + 14) - 1;
    if (*(_QWORD *)(v2 + 48 * v3 + 32) == *(_QWORD *)(v2 + 48 * v3 + 24))
    {
      for (i = *(_QWORD *)(v2 + 48 * v3 + 16); i; --i)
        re::EncoderOPACK<re::FixedArrayInputStream>::skipObject((uint64_t)v1);
      result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 9);
      v5 = *((_QWORD *)v1 + 16);
      v6 = *((_QWORD *)v1 + 14) - 1;
      if (*(_BYTE *)(v5 + 48 * v6) != 2)
        ++*(_QWORD *)(v5 + 48 * v6 + 32);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v8);
      if ((v9 & 1) != 0)
        v7 = *(_BYTE **)&v10[7];
      else
        v7 = v10;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize pointer \"%s\". No value was provided.", (re::DynamicString *)v11, v7);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)v1, (uint64_t)v11);
      if (*(_QWORD *)&v11[0])
      {
        if ((BYTE8(v11[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v11[0] + 40))();
        memset(v11, 0, sizeof(v11));
      }
      result = v8;
      if (v8 && (v9 & 1) != 0)
        return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v8 + 40))();
    }
  }
  return result;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unint64_t *a2, _QWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v6 = *a2;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v7) = 0;
    goto LABEL_8;
  }
  v7 = v6 % *(unsigned int *)(a1 + 24);
  v8 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v7);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, v7, v6, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  v9 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v9 + 24 * v8 + 4) != v6)
  {
    v8 = *(_DWORD *)(v9 + 24 * v8) & 0x7FFFFFFF;
    if ((_DWORD)v8 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v10 = 3 * v8;
  *(_QWORD *)(v9 + 8 * v10 + 16) = *a3;
  ++*(_DWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 16) + 8 * v10;
  return v11 + 16;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v11;
  int v12;
  uint64_t v13;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 24 * v8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 24 * v8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  v13 = 24 * v8;
  *(_DWORD *)(v11 + v13) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v13) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 4) = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10) & 0x80000000) != 0)
          {
            re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10 + 4) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10 + 4), *(_QWORD *)&v13[16] + v10 + 4, *(_QWORD *)&v13[16] + v10 + 16);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

BOOL re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::serializePointer(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, uint64_t a7)
{
  const re::TypeInfo *v14;
  _BOOL4 isPointerToPolymorphicType;
  int v16;
  re *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  _DWORD *v34;
  unint64_t v35;
  unsigned int *v36;
  _DWORD *v37;
  unsigned int v38;
  char *Instance;
  unsigned int v40;
  char **v41;
  uint64_t v42;
  _BYTE v43[40];
  unsigned int v44;
  int v45;
  _BYTE v46[32];
  re *v47[2];
  _BYTE v48[32];
  _QWORD v49[5];

  isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6)
    goto LABEL_4;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v24 = **((_QWORD **)this + 2);
    v25 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v24 == (unsigned __int16)v25)
    {
      v27 = WORD1(v24) == WORD1(v25);
      v26 = (v25 ^ v24) & 0xFFFFFF00000000;
      v27 = v27 && v26 == 0;
      if (v27)
        goto LABEL_4;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v14))
  {
LABEL_4:
    v16 = 0;
    goto LABEL_5;
  }
  if (*((_BYTE *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (v28 = re::TypeInfo::name(this), v29 = re::TypeInfo::name(a6), !re::StringID::operator==(v28, v29))))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, this, a6);
    return 0;
  }
  v16 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v40);
  re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)&v41);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v40);
  re::TypeInfo::TypeInfo((uint64_t)v48, (uint64_t)&v41);
  if (isPointerToPolymorphicType && (a7 & 1) == 0)
  {
    re::internal::actualType(a4, (void **)this, v47);
    if (v47[0])
      goto LABEL_8;
LABEL_15:
    v18 = re::TypeInfo::name(this);
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Failed to get actual type of polymorphic object. Type \"%s\".", v19, v20, v21, v22, v23, v18[1]);
    return 0;
  }
  v17 = *(re **)v49[2];
  v47[0] = (re *)v49[0];
  v47[1] = v17;
  if (!v49[0])
    goto LABEL_15;
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, v47, &v40);
  re::TypeInfo::TypeInfo((uint64_t)v46, (uint64_t)&v41);
  v45 = 0;
  if (!re::EncoderOPACK<re::FixedArrayInputStream>::beginPointer(a1 + 24, a2, a3, &v45, 0))
    return 0;
  if (v45 == 1)
  {
    v44 = 0;
    if (!*(_BYTE *)(a1 + 64))
    {
      re::EncoderOPACK<re::FixedArrayInputStream>::readIntegerAs<unsigned int>((_anonymous_namespace_ *)(a1 + 24), "ID", &v44);
      v31 = *(_QWORD *)(a1 + 152);
      v32 = *(_QWORD *)(a1 + 136) - 1;
      if (*(_BYTE *)(v31 + 48 * v32) != 2)
        ++*(_QWORD *)(v31 + 48 * v32 + 32);
      if (!*(_BYTE *)(a1 + 64))
      {
        if ((a7 & 1) == 0)
        {
          v40 = v44;
          v41 = a4;
          re::TypeInfo::TypeInfo((uint64_t)&v42, (uint64_t)this);
          re::TypeInfo::TypeInfo((uint64_t)v43, (uint64_t)a6);
          v43[32] = isPointerToPolymorphicType;
          v43[33] = v16;
          v33 = *(_QWORD *)(a1 + 376);
          if (v33)
          {
            v34 = *(_DWORD **)(a1 + 392);
            do
            {
              v35 = v33 >> 1;
              v36 = &v34[22 * (v33 >> 1)];
              v38 = *v36;
              v37 = v36 + 22;
              v33 += ~(v33 >> 1);
              if (v40 < v38)
                v33 = v35;
              else
                v34 = v37;
            }
            while (v33);
          }
          else
          {
            v34 = *(_DWORD **)(a1 + 392);
          }
          re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::insert((_anonymous_namespace_ *)(a1 + 360), 0x2E8BA2E8BA2E8BA3 * (((uint64_t)v34 - *(_QWORD *)(a1 + 392)) >> 3), (uint64_t)&v40);
        }
        goto LABEL_50;
      }
    }
    return 0;
  }
  if (v45)
  {
    if (isPointerToPolymorphicType)
    {
      re::internal::deserializePolymorphicObject<re::EncoderOPACK<re::FixedArrayInputStream>,false>(a1, a2, a3, (void **)a4, (re **)this, (re::TypeInfo *)v46, (re::TypeInfo *)v48, v16, a7);
    }
    else
    {
      if ((a7 & 1) != 0)
      {
        Instance = 0;
      }
      else
      {
        Instance = *a4;
        if (!*a4)
        {
          Instance = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v49, *(re::Allocator **)(a1 + 48), 0);
          *a4 = Instance;
        }
      }
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, char *, _QWORD *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, 0, Instance, v49, v48, a7);
    }
  }
  else if ((a7 & 1) == 0)
  {
    if (*a4)
    {
      re::TypeInfo::releaseInstance((re::TypeInfo *)v46, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 200));
      *a4 = 0;
    }
  }
LABEL_50:
  re::EncoderOPACK<re::FixedArrayInputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
  return *(_BYTE *)(a1 + 64) == 0;
}

uint64_t re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::insert(_anonymous_namespace_ *this, unint64_t a2, uint64_t a3)
{
  unint64_t v4;
  uint64_t v7;
  _OWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  _OWORD v13[5];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)this + 2);
  if (v4 + 1 <= a2)
  {
    memset(v13, 0, sizeof(v13));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v7 = *((_QWORD *)this + 4);
  v8 = (_OWORD *)(v7 + 88 * v4);
  if (v4 <= a2)
  {
    *v8 = *(_OWORD *)a3;
    v11 = v7 + 88 * v4;
    re::TypeInfo::TypeInfo(v11 + 16, a3 + 16);
    result = re::TypeInfo::TypeInfo(v11 + 48, a3 + 48);
  }
  else
  {
    v9 = v7 + 88 * v4;
    *v8 = *(_OWORD *)(v9 - 88);
    re::TypeInfo::TypeInfo(v9 + 16, v9 - 72);
    re::TypeInfo::TypeInfo(v9 + 48, v9 - 40);
    *(_WORD *)(v9 + 80) = *(_WORD *)(v9 - 8);
    v10 = 88 * a2;
    std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup *,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup *,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup *>((uint64_t)v13, *((_QWORD *)this + 4) + v10, *((_QWORD *)this + 4) + 88 * *((_QWORD *)this + 2) - 88, *((_QWORD *)this + 4) + 88 * *((_QWORD *)this + 2));
    v11 = *((_QWORD *)this + 4) + v10;
    *(_OWORD *)v11 = *(_OWORD *)a3;
    re::TypeInfo::operator=(v11 + 16, a3 + 16);
    result = re::TypeInfo::operator=(v11 + 48, a3 + 48);
  }
  *(_WORD *)(v11 + 80) = *(_WORD *)(a3 + 80);
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

_QWORD *re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x58uLL))
        {
          v2 = 88 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 88 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 88, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = v8 + 88 * v9;
        v11 = (uint64_t)(v7 + 6);
        v12 = v8 + 48;
        do
        {
          *(_OWORD *)(v11 - 48) = *(_OWORD *)(v12 - 48);
          re::TypeInfo::TypeInfo(v11 - 32, v12 - 32);
          re::TypeInfo::TypeInfo(v11, v12);
          *(_WORD *)(v11 + 32) = *(_WORD *)(v12 + 32);
          v11 += 88;
          v13 = v12 + 40;
          v12 += 88;
        }
        while (v13 != v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup *,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup *,re::SerializerV2<re::EncoderOPACK<re::FixedArrayInputStream>>::PointerFixup *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  if (a3 != a2)
  {
    v7 = 0;
    do
    {
      *(_OWORD *)(a4 + v7 - 88) = *(_OWORD *)(a3 + v7 - 88);
      re::TypeInfo::operator=(a4 + v7 - 72, a3 + v7 - 72);
      re::TypeInfo::operator=(a4 + v7 - 40, a3 + v7 - 40);
      *(_WORD *)(a4 + v7 - 8) = *(_WORD *)(a3 + v7 - 8);
      v7 -= 88;
    }
    while (a3 + v7 != a2);
  }
  return a3;
}

re::NetworkCompatSerializer *re::NetworkCompatSerializer::NetworkCompatSerializer(re::NetworkCompatSerializer *this)
{
  uint64_t v2;
  StringID v4;

  *(_QWORD *)&v4.var0 = 0x287C37956ADFC9C4;
  v4.var1 = "NetworkCompatSerializer";
  v2 = re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::SerializerV1((uint64_t)this, &v4);
  *(_QWORD *)v2 = &off_24ED2B528;
  *(_OWORD *)(v2 + 432) = 0u;
  *(_OWORD *)(v2 + 448) = 0u;
  *(_QWORD *)(v2 + 184) = v2 + 440;
  re::StringID::destroyString((re::StringID *)&v4);
  *(_QWORD *)this = &off_24ED2B468;
  return this;
}

void re::NetworkCompatSerializer::~NetworkCompatSerializer(re::NetworkCompatSerializer *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24ED2B590;
  v2 = *((_QWORD *)this + 49);
  if (v2)
  {
    if (*((_QWORD *)this + 53))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 53) = 0;
    *((_QWORD *)this + 50) = 0;
    *((_QWORD *)this + 51) = 0;
    *((_QWORD *)this + 49) = 0;
    ++*((_DWORD *)this + 104);
  }
  v3 = *((_QWORD *)this + 44);
  if (v3)
  {
    if (*((_QWORD *)this + 48))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 48) = 0;
    *((_QWORD *)this + 45) = 0;
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 44) = 0;
    ++*((_DWORD *)this + 94);
  }
  v4 = *((_QWORD *)this + 39);
  if (v4)
  {
    if (*((_QWORD *)this + 43))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 40) = 0;
    *((_QWORD *)this + 41) = 0;
    *((_QWORD *)this + 39) = 0;
    ++*((_DWORD *)this + 84);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 33);
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer(this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24ED2B590;
  v2 = *((_QWORD *)this + 49);
  if (v2)
  {
    if (*((_QWORD *)this + 53))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 53) = 0;
    *((_QWORD *)this + 50) = 0;
    *((_QWORD *)this + 51) = 0;
    *((_QWORD *)this + 49) = 0;
    ++*((_DWORD *)this + 104);
  }
  v3 = *((_QWORD *)this + 44);
  if (v3)
  {
    if (*((_QWORD *)this + 48))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 48) = 0;
    *((_QWORD *)this + 45) = 0;
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 44) = 0;
    ++*((_DWORD *)this + 94);
  }
  v4 = *((_QWORD *)this + 39);
  if (v4)
  {
    if (*((_QWORD *)this + 43))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 40) = 0;
    *((_QWORD *)this + 41) = 0;
    *((_QWORD *)this + 39) = 0;
    ++*((_DWORD *)this + 84);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 33);
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer(this);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::trackObject(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v4;

  v4 = *a3;
  return re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 256), a2, &v4);
}

uint64_t re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::untrackObject(uint64_t result)
{
  if (*(_BYTE *)(result + 256))
  {
    --*(_QWORD *)(result + 408);
    ++*(_DWORD *)(result + 416);
  }
  return result;
}

void re::NetworkSerializerBase<re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>>::doOpen(uint64_t a1)
{
  *(_BYTE *)(a1 + 257) = 0;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 264);
  *(_QWORD *)(a1 + 328) = 0;
  ++*(_DWORD *)(a1 + 336);
  *(_QWORD *)(a1 + 368) = 0;
  ++*(_DWORD *)(a1 + 376);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
}

void re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::doClose(uint64_t a1)
{
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 264);
  *(_QWORD *)(a1 + 328) = 0;
  ++*(_DWORD *)(a1 + 336);
  *(_QWORD *)(a1 + 368) = 0;
  ++*(_DWORD *)(a1 + 376);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
}

void re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::doRegisterSerializeFuncs(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  BOOL (*v16)(uint64_t, const char *, const re::TypeInfo *, uint64_t, re *, const re::TypeInfo *, int);

  v11 = 6059476;
  v12 = "BOOL";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeBool<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6104748;
  v12 = "char";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeChar<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x172E117BCLL;
  v12 = "int8_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI8<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93A4A92;
  v12 = "int16_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI16<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93BFE06;
  v12 = "int32_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI32<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93EC744;
  v12 = "int64_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6655224;
  v12 = "long";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x31CD534126;
  v12 = "uint8_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU8<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0D4E68;
  v12 = "uint16_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU16<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0F01DCLL;
  v12 = "uint32_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU32<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD11CB1ALL;
  v12 = "uint64_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x1947BDF6CLL;
  v12 = "size_t";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 195052728;
  v12 = "float";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeFloat<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x161EEF7A2;
  v12 = "double";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDouble<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 189247272;
  v12 = "char*";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeCString<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2686EB529B3EE220;
  v12 = "DynamicString";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDynamicString<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x458DDB01A18;
  v12 = "StringID";
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeStringID<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v2 = *(_QWORD *)(a1 + 192);
  v11 = 0x258C98EAAF29A10ALL;
  v12 = "CallbackSerializerAttribute";
  v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v11);
  if (v3)
  {
    v4 = *v3;
    re::StringID::destroyString((re::StringID *)&v11);
    if (v2)
    {
      v5 = *(_QWORD *)(a1 + 192);
      v10[0] = v2;
      v10[1] = v4;
      re::TypeRegistry::attributesByAttributeType(v5, (uint64_t)v10, (uint64_t)&v11);
      if (v13)
      {
        v6 = a1 + 208;
        v7 = (uint64_t *)(v14 + 24);
        v8 = 48 * v13;
        do
        {
          v9 = *v7;
          v7 += 6;
          v16 = re::serializeIntrospectionCallbackSerializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>;
          v15 = v9 | 0xFFFFFFFF00000000;
          re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v6, &v15, &v16);
          v8 -= 48;
        }
        while (v8);
      }
      if (v11)
      {
        if (v14)
          (*(void (**)(void))(*(_QWORD *)v11 + 40))();
      }
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v11);
  }
}

uint64_t re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t result;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;

  v14 = (_BYTE *)(a1 + 256);
  v15 = *(_QWORD *)(a1 + 408);
  if (!v15)
  {
    if ((_DWORD)a7)
      v16 = 0;
    else
      v16 = a4;
    v17 = **((_QWORD **)a5 + 2);
    *(_QWORD *)&v26 = *(_QWORD *)a5;
    *((_QWORD *)&v26 + 1) = v17;
    re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 256), v16, &v26);
  }
  v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v18)
  {
    result = v18(a1, a2, a3, a4, a5, a6, a7);
    if (!v15)
    {
      if (*v14)
      {
        --*(_QWORD *)(a1 + 408);
        ++*(_DWORD *)(a1 + 416);
      }
    }
  }
  else
  {
    v20 = re::TypeInfo::name(a5);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v21, v22, v23, v24, v25, v20[1]);
    return 0;
  }
  return result;
}

uint64_t (*re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::doResolveSerializeFunc(uint64_t a1, re::TypeInfo *this))(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  uint64_t *v4;
  uint64_t v5;
  char *v6;
  unsigned int v7;
  uint64_t (*result)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, char);
  uint64_t v9;
  uint64_t v10;

  v4 = re::TypeInfo::name(this);
  if ((unint64_t)*v4 >> 1 == 94623636)
  {
    v6 = (char *)v4[1];
    if (v6 == "char*" || !strcmp(v6, "char*"))
      return (uint64_t (*)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, char))re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::serializeCString;
  }
  if (*((_BYTE *)this + 12) == 9)
  {
    v7 = *(unsigned __int8 *)(*((_QWORD *)this + 2) + 80);
    if (v7 >= 2)
    {
      if (v7 == 2)
      {
        re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) External references are not supported by the SerializerV1.", "!\"Unreachable code\"", "doResolveSerializeFunc", 82);
        _os_crash();
        __break(1u);
      }
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Invalid PointerSharing type.", "!\"Unreachable code\"", "doResolveSerializeFunc", 84);
      result = (uint64_t (*)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, char))_os_crash();
      __break(1u);
    }
    else
    {
      return re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::serializePointer;
    }
  }
  else if (*(_QWORD *)this == *(_QWORD *)(a1 + 192)
         && (LODWORD(v10) = **((_QWORD **)this + 2),
             HIDWORD(v10) = -1,
             (v9 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 208, &v10)) != 0))
  {
    return *(uint64_t (**)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, char))v9;
  }
  else
  {
    return (uint64_t (*)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, char))re::serializeType<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>;
  }
  return result;
}

uint64_t re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::SerializerV1(uint64_t a1, const StringID *a2)
{
  *(_QWORD *)a1 = &off_24ED2B5F8;
  re::StringID::StringID((re::StringID *)(a1 + 8), a2);
  re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::Encoder(a1 + 24, 12);
  *(_DWORD *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 244) = 0x7FFFFFFFLL;
  *(_QWORD *)a1 = &off_24ED2B590;
  *(_WORD *)(a1 + 256) = 1;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_DWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 300) = 0x7FFFFFFFLL;
  *(_QWORD *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 312) = 0;
  *(_DWORD *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 424) = 0;
  *(_DWORD *)(a1 + 376) = 0;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_DWORD *)(a1 + 416) = 0;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  return a1;
}

_QWORD *re::NetworkSerializerBase<re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>>::~NetworkSerializerBase(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED2B590;
  v2 = *(_QWORD *)(a1 + 392);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  v3 = *(_QWORD *)(a1 + 352);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 384))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 384) = 0;
    *(_QWORD *)(a1 + 360) = 0;
    *(_QWORD *)(a1 + 368) = 0;
    *(_QWORD *)(a1 + 352) = 0;
    ++*(_DWORD *)(a1 + 376);
  }
  v4 = *(_QWORD *)(a1 + 312);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 344))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 344) = 0;
    *(_QWORD *)(a1 + 320) = 0;
    *(_QWORD *)(a1 + 328) = 0;
    *(_QWORD *)(a1 + 312) = 0;
    ++*(_DWORD *)(a1 + 336);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 264));
  return re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer((_QWORD *)a1);
}

void re::NetworkSerializerBase<re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>>::~NetworkSerializerBase(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED2B590;
  v2 = *(_QWORD *)(a1 + 392);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  v3 = *(_QWORD *)(a1 + 352);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 384))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 384) = 0;
    *(_QWORD *)(a1 + 360) = 0;
    *(_QWORD *)(a1 + 368) = 0;
    *(_QWORD *)(a1 + 352) = 0;
    ++*(_DWORD *)(a1 + 376);
  }
  v4 = *(_QWORD *)(a1 + 312);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 344))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 344) = 0;
    *(_QWORD *)(a1 + 320) = 0;
    *(_QWORD *)(a1 + 328) = 0;
    *(_QWORD *)(a1 + 312) = 0;
    ++*(_DWORD *)(a1 + 336);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 264));
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer((_QWORD *)a1);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED2B590;
  v2 = *(_QWORD *)(a1 + 392);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  v3 = *(_QWORD *)(a1 + 352);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 384))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 384) = 0;
    *(_QWORD *)(a1 + 360) = 0;
    *(_QWORD *)(a1 + 368) = 0;
    *(_QWORD *)(a1 + 352) = 0;
    ++*(_DWORD *)(a1 + 376);
  }
  v4 = *(_QWORD *)(a1 + 312);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 344))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 344) = 0;
    *(_QWORD *)(a1 + 320) = 0;
    *(_QWORD *)(a1 + 328) = 0;
    *(_QWORD *)(a1 + 312) = 0;
    ++*(_DWORD *)(a1 + 336);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 264));
  return re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer((_QWORD *)a1);
}

void re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED2B590;
  v2 = *(_QWORD *)(a1 + 392);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  v3 = *(_QWORD *)(a1 + 352);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 384))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 384) = 0;
    *(_QWORD *)(a1 + 360) = 0;
    *(_QWORD *)(a1 + 368) = 0;
    *(_QWORD *)(a1 + 352) = 0;
    ++*(_DWORD *)(a1 + 376);
  }
  v4 = *(_QWORD *)(a1 + 312);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 344))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 344) = 0;
    *(_QWORD *)(a1 + 320) = 0;
    *(_QWORD *)(a1 + 328) = 0;
    *(_QWORD *)(a1 + 312) = 0;
    ++*(_DWORD *)(a1 + 336);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 264));
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer((_QWORD *)a1);
  JUMPOUT(0x2276933B8);
}

void re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::doOpen(uint64_t a1)
{
  *(_BYTE *)(a1 + 257) = 0;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 264);
  *(_QWORD *)(a1 + 328) = 0;
  ++*(_DWORD *)(a1 + 336);
  *(_QWORD *)(a1 + 368) = 0;
  ++*(_DWORD *)(a1 + 376);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
}

void re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer(_QWORD *a1)
{
  re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t (*v14)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v14)
    return v14(a1, a2, a3, a4, a5, a6, a7);
  v16 = re::TypeInfo::name(a5);
  re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v17, v18, v19, v20, v21, v16[1]);
  return 0;
}

uint64_t (*re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(_BYTE *a1, const char *a2, const re::TypeInfo *a3, char *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v3;
  uint64_t v4;

  if (*(_QWORD *)a2 == *(_QWORD *)(a1 + 192)
    && (LODWORD(v4) = **(_QWORD **)(a2 + 16),
        HIDWORD(v4) = -1,
        (v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 208, &v4)) != 0))
  {
    return *(uint64_t (**)(_BYTE *, const char *, const re::TypeInfo *, char *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>;
  }
}

uint64_t re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::Encoder(uint64_t result, int a2)
{
  __objc2_class_ro **p_info;
  unsigned __int8 v3;
  __objc2_class_ro *v4;
  int v5;
  const char *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE v10[4];
  int v11;

  *(_QWORD *)(result + 128) = 0;
  *(_QWORD *)(result + 104) = 0;
  *(_QWORD *)(result + 112) = 0;
  *(_QWORD *)(result + 96) = 0;
  *(_DWORD *)(result + 120) = 0;
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_BYTE *)(result + 40) = 0;
  *(_DWORD *)(result + 136) = a2;
  *(_BYTE *)(result + 140) = 0;
  *(_QWORD *)(result + 152) = 1024;
  p_info = VideoSpillMapMetalSession.info;
  if ((v3 & 1) == 0)
  {
    v9 = result;
    p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    v7 = v5;
    result = v9;
    if (v7)
    {
      re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v6, (uint64_t)v10);
      v8 = v11;
      if (!v10[0])
        v8 = 0;
      re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::Encoder(int)::s_maxSerializationDepth = v8;
      p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
      result = v9;
    }
  }
  v4 = p_info[494];
  if (v4)
    *(_QWORD *)(result + 152) = v4;
  return result;
}

_QWORD *re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::~Serializer(_QWORD *a1)
{
  *a1 = &off_24ED2B5F8;
  if (a1[24])
  {
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 26));
    a1[24] = 0;
  }
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit(a1 + 26);
  re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::~Encoder((uint64_t)(a1 + 3));
  re::StringID::destroyString((re::StringID *)(a1 + 1));
  return a1;
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_400, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 24 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16);
        v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
        v4 += 24;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

uint64_t re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::~Encoder(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::close(a1);
  v2 = *(_QWORD *)(a1 + 96);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 128))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 96) = 0;
    ++*(_DWORD *)(a1 + 120);
  }
  if (*(_BYTE *)(a1 + 40))
  {
    v3 = *(_QWORD *)(a1 + 64);
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 80));
      *(_OWORD *)(a1 + 64) = 0u;
      *(_OWORD *)(a1 + 80) = 0u;
    }
  }
  return a1;
}

uint64_t re::Encoder<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::close(uint64_t result)
{
  _anonymous_namespace_ *v1;

  if (*(_QWORD *)result)
  {
    v1 = (_anonymous_namespace_ *)result;
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::doClose(result);
    if (!*((_BYTE *)v1 + 40))
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 0);
    result = *((_QWORD *)v1 + 12);
    if (result)
    {
      if (*((_QWORD *)v1 + 16))
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
      *((_QWORD *)v1 + 16) = 0;
      *((_QWORD *)v1 + 13) = 0;
      *((_QWORD *)v1 + 14) = 0;
      *((_QWORD *)v1 + 12) = 0;
      ++*((_DWORD *)v1 + 30);
    }
    if (*((int *)v1 + 4) >= 1)
    {
      result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v1 + 24))(*(_QWORD *)v1);
      *((_QWORD *)v1 + 1) = 0;
      *((_DWORD *)v1 + 4) = 0;
    }
    *(_QWORD *)v1 = 0;
    *((_QWORD *)v1 + 3) = 0;
    *((_QWORD *)v1 + 4) = 0;
  }
  return result;
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::doClose(uint64_t result)
{
  char v1;

  if (!*(_BYTE *)(result + 40))
  {
    v1 = 69;
    return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(result, "End-of-file", 0, &v1, (uint64_t)"uint8", 0);
  }
  return result;
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  uint64_t v11;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if ((a6 & 1) != 0)
    a4 = 0;
  if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((_QWORD *)a1, a4, 1uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    v11 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v11 - 16);
  }
  return 1;
}

uint64_t re::serializeType<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(_BYTE *a1, const char *a2, const re::TypeInfo *a3, char *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t result;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  if (this != (re::TypeInfo *)a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **(_QWORD **)(a6 + 16);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_19;
      }
    }
    else if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, a3))
    {
      goto LABEL_19;
    }
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
      if (v19)
        v20 = *(_DWORD *)(v19 + 16);
      else
        v20 = -1;
      v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
      if (v21)
        v22 = *(_DWORD *)(v21 + 16);
      else
        v22 = -1;
      if (v20 == v22)
        goto LABEL_19;
      v24 = re::TypeInfo::name(this)[1];
      re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
      re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError((uint64_t)a1, a2, "Cannot serialize type \"%s\" version %u as version %u. Downgrading versions is not supported.", v30, v31, v32, v33, v34, v24);
    }
    else
    {
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, this, (re::TypeInfo *)a6);
    }
    return 0;
  }
LABEL_19:
  switch(*((_BYTE *)this + 12))
  {
    case 1:
      result = re::serializeBasic<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a3, a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 2:
      result = re::serializeEnum<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a2, a3, (re::TypeInfo *)a4, (uint64_t)this, a6, a7);
      break;
    case 3:
      result = re::serializeOptional<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 4:
      result = re::serializeArray<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a2, a3, a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 5:
      result = re::serializeList<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 6:
      result = re::serializeDictionary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 7:
      result = re::serializeUnion<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a3, a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 8:
      result = re::serializeObject<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, (uint64_t)a3, (uint64_t)a4, this, a6, a7);
      break;
    case 9:
      v35 = re::TypeInfo::name(this)[1];
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError((uint64_t)a1, a2, "Pointer type (\"%s\") needs to be handled explicitly by the serializer.", v25, v26, v27, v28, v29, v35);
      return 0;
    default:
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError((uint64_t)a1, a2, "Invalid type category. Value = %d", (uint64_t)a4, (uint64_t)this, a6, a7, a8, *((_BYTE *)this + 12));
      return 0;
  }
  return result;
}

uint64_t re::serializeBasic<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  uint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_19:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, this, a6);
      return 0;
    }
    v17 = **((_QWORD **)this + 2);
    v18 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v17 != (unsigned __int16)v18)
      goto LABEL_19;
    v20 = WORD1(v17) == WORD1(v18);
    v19 = (v18 ^ v17) & 0xFFFFFF00000000;
    v20 = v20 && v19 == 0;
    if (!v20)
      goto LABEL_19;
  }
LABEL_4:
  v14 = re::TypeInfo::name(this);
  v15 = (unint64_t)*v14 >> 1;
  if (v15 > 0xCA3DEFB5)
  {
    if ((unint64_t)*v14 >> 1 > 0x18E6A9A092)
    {
      if ((unint64_t)*v14 >> 1 <= 0x303EE8780EDLL)
      {
        if (v15 != 0x18E6A9A093)
        {
          if (v15 == 0x303EE86A734)
            return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint16", a7);
          goto LABEL_48;
        }
        return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint8", a7);
      }
      if (v15 == 0x303EE8780EELL)
        return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint32", a7);
      if (v15 != 0x303EE88E58DLL)
        goto LABEL_48;
    }
    else
    {
      if ((unint64_t)*v14 >> 1 > 0x16749DFF02)
      {
        if (v15 == 0x16749DFF03)
          return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int32", a7);
        v21 = 0x16749F63A2;
        goto LABEL_34;
      }
      if (v15 != 3393056694)
      {
        v16 = 0x16749D2549;
        goto LABEL_24;
      }
    }
    return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint64", a7);
  }
  if ((unint64_t)*v14 >> 1 > 0x5D0225B)
  {
    if ((unint64_t)*v14 >> 1 > 0xB0F77BD0)
    {
      if (v15 != 2969009105)
      {
        if (v15 == 3111160798)
          return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int8", a7);
LABEL_48:
        v23 = re::TypeInfo::name(this);
        re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Unsupported basic type \"%s\".", v24, v25, v26, v27, v28, v23[1]);
        return 0;
      }
      return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"double", a7);
    }
    if (v15 == 97526364)
      return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"float", a7);
    v16 = 109413500;
LABEL_24:
    if (v15 == v16)
      return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int16", a7);
    goto LABEL_48;
  }
  if ((unint64_t)*v14 >> 1 <= 0x2E9355)
  {
    if (v15 != 104431)
    {
      if (v15 == 3029738)
        return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"BOOL", a7);
      goto LABEL_48;
    }
    return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int32", a7);
  }
  if (v15 != 3052374)
  {
    v21 = 3327612;
LABEL_34:
    if (v15 == v21)
      return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int64", a7);
    goto LABEL_48;
  }
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"char", a7);
}

uint64_t re::serializeEnum<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(_BYTE *a1, const char *a2, const re::TypeInfo *a3, re::TypeInfo *a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  uint64_t *v19;

  if (a5 == a6)
    return re::internal::serializeEnumAsBinary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::TypeInfo *)a6, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **(_QWORD **)(a5 + 16);
    v15 = **(_QWORD **)(a6 + 16);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::internal::serializeEnumAsBinary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::TypeInfo *)a6, a7);
    }
  }
  else if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, a3))
  {
    return re::internal::serializeEnumAsBinary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::TypeInfo *)a6, a7);
  }
  if (*(unsigned __int8 *)(a5 + 12) == *(unsigned __int8 *)(a6 + 12))
  {
    v18 = re::TypeInfo::name((re::TypeInfo *)a5);
    v19 = re::TypeInfo::name((re::TypeInfo *)a6);
    if (re::StringID::operator==(v18, v19))
      return re::internal::serializeEnumAsBinary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::TypeInfo *)a6, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
  return 0;
}

BOOL re::serializeOptional<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  re::internal *v18;
  _anonymous_namespace_ *v19;
  double v20;
  uint64_t v21;
  BOOL v23;
  char v24[32];
  _BYTE v25[32];
  _BYTE v26[8];
  uint64_t v27;
  uint64_t v28;

  if (a5 == a6)
    goto LABEL_11;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_11;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (a7)
  {
    v24[0] = 0;
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginOptional(a1 + 24, a2, (uint64_t)a3, v24, 0);
    if (v24[0])
    {
      v18 = *(re::internal **)(a1 + 192);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), v26);
      re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)&v27);
      re::internal::translateType(v18, (const re::TypeRegistry *)v25, (uint64_t)v26);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, 0, 0, v26, v26, 1);
    }
    v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), v26);
    re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)&v27);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), v26);
    re::TypeInfo::TypeInfo((uint64_t)v24, (uint64_t)&v27);
    re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)a5);
    v23 = (*(uint64_t (**)(uint64_t))(v28 + 80))(a4) != 0;
    v20 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginOptional(a1 + 24, a2, (uint64_t)a3, (char *)&v23, 0);
    if (v23)
    {
      v21 = (*(uint64_t (**)(uint64_t, double))(v28 + 80))(a4, v20);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, char *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, 0, v21, v25, v24, 0);
    }
    v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endOptional(v19);
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeArray<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(_BYTE *a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char v14;
  re::internal *v15;
  uint64_t v16;
  void (*v17)(_BYTE *, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t);
  _QWORD *v18;
  int v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  _QWORD *v26;
  _QWORD *v27;
  int v28;
  uint64_t v29;
  void (*v30)(_BYTE *, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  int v31;
  int v32;
  _BOOL8 result;
  unint64_t v34;
  BOOL v35;
  char v36;
  uint64_t v37;
  char v38;
  char *v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  BOOL v47;
  char v48;
  unint64_t v49;
  uint64_t v50;
  _anonymous_namespace_ *v51;
  unint64_t v52;
  _QWORD v53[2];
  unint64_t v54;
  _QWORD v55[2];
  _BYTE v56[32];
  _BYTE v57[12];
  char v58;
  uint64_t v59;
  unint64_t v60;
  _BYTE v61[32];

  if (a5 == a6)
    goto LABEL_4;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v22 = **((_QWORD **)a5 + 2);
    v23 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v22 != (unsigned __int16)v23)
      goto LABEL_13;
    v25 = WORD1(v22) == WORD1(v23);
    v24 = (v23 ^ v22) & 0xFFFFFF00000000;
    v25 = v25 && v24 == 0;
    if (!v25)
      goto LABEL_13;
LABEL_4:
    v14 = 1;
    if (a7)
      goto LABEL_5;
    goto LABEL_17;
  }
  if (re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_4;
LABEL_13:
  if (*((_BYTE *)a6 + 12) != 4)
    goto LABEL_52;
  v26 = (_QWORD *)*((_QWORD *)a5 + 2);
  v27 = (_QWORD *)*((_QWORD *)a6 + 2);
  v28 = *((_DWORD *)v27 + 21) & 0xFFFFFF;
  if ((*((_DWORD *)v26 + 21) & 0xFFFFFF) != 0)
  {
    if (v28)
      goto LABEL_16;
LABEL_52:
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a5, a6);
    return 0;
  }
  if (v28 || *((_DWORD *)v26 + 22) != *((_DWORD *)v27 + 22))
    goto LABEL_52;
LABEL_16:
  v14 = 0;
  if (a7)
  {
LABEL_5:
    v15 = (re::internal *)*((_QWORD *)a1 + 24);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v60);
    re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v61);
    re::internal::translateType(v15, (const re::TypeRegistry *)v56, (uint64_t)v57);
    v16 = (*(uint64_t (**)(_BYTE *, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v57);
    if (v16)
    {
      v17 = (void (*)(_BYTE *, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))v16;
      v18 = (_QWORD *)*((_QWORD *)a6 + 2);
      v19 = *((_DWORD *)v18 + 21) & 0xFFFFFF;
      if (v19)
      {
        v20 = 0;
        v21 = 8;
      }
      else
      {
        v20 = *((int *)v18 + 22);
        v21 = 4;
      }
      v60 = v20;
      result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginArray((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v60, v21);
      if (result)
      {
        v46 = v60;
        if (v19)
          v47 = v60 == 0;
        else
          v47 = 1;
        v48 = v47;
        if (!v47)
        {
          v55[0] = 0;
          v55[1] = 0xFFFFFFFFLL;
          (*(void (**)(_BYTE *, _QWORD, _QWORD *))(*(_QWORD *)a1 + 16))(a1, 0, v55);
          v46 = v60;
        }
        if (v58 == 1)
        {
          if (v46)
            re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeArray((uint64_t)(a1 + 24), 0, *(unsigned int *)(v59 + 8), v46, 1);
        }
        else if (v46)
        {
          v52 = 0;
          do
          {
            v17(a1, 0, 0, 0, v57, v57, 1);
            ++v52;
          }
          while (v52 < v60);
        }
        if ((v48 & 1) == 0)
          (*(void (**)(_BYTE *))(*(_QWORD *)a1 + 24))(a1);
        v51 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_66:
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endArray(v51);
        return a1[64] == 0;
      }
      return result;
    }
    goto LABEL_36;
  }
LABEL_17:
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &v60);
  re::TypeInfo::TypeInfo((uint64_t)v57, (uint64_t)v61);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v60);
  re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v61);
  re::TypeInfo::TypeInfo((uint64_t)&v60, (uint64_t)a5);
  v29 = (*(uint64_t (**)(_BYTE *, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v57);
  if (!v29)
  {
LABEL_36:
    v40 = re::TypeInfo::name((re::TypeInfo *)v57);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError((uint64_t)a1, 0, "Failed to resolve serialize function for type \"%s\"", v41, v42, v43, v44, v45, v40[1]);
    return 0;
  }
  v30 = (void (*)(_BYTE *, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v29;
  v54 = re::ArrayAccessor::size((re::ArrayAccessor *)&v60, a4);
  v31 = *(_DWORD *)(*((_QWORD *)a5 + 2) + 84) & 0xFFFFFF;
  if (v31)
    v32 = 8;
  else
    v32 = 4;
  result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginArray((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v54, v32);
  if (result)
  {
    v34 = v54;
    if (v31)
      v35 = v54 == 0;
    else
      v35 = 1;
    v36 = v35;
    if (!v35)
    {
      v37 = *(_QWORD *)a4;
      v53[0] = 0;
      v53[1] = 0xFFFFFFFFLL;
      (*(void (**)(_BYTE *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 16))(a1, v37, v53);
      v34 = v54;
    }
    if (v58 == 1)
      v38 = v14;
    else
      v38 = 0;
    if ((v38 & 1) != 0)
    {
      if (v34)
      {
        v39 = (char *)re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v60, a4, 0);
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeArray((uint64_t)(a1 + 24), v39, *(unsigned int *)(v59 + 8), v54, 0);
      }
    }
    else if (v34)
    {
      v49 = 0;
      do
      {
        v50 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)&v60, a4, v49);
        v30(a1, 0, 0, v50, v57, v56, 0);
        ++v49;
      }
      while (v49 < v54);
    }
    if ((v36 & 1) == 0)
      (*(void (**)(_BYTE *))(*(_QWORD *)a1 + 24))(a1);
    v51 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_66;
  }
  return result;
}

BOOL re::serializeList<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  int v14;
  re::internal *v15;
  uint64_t v16;
  void (*v17)(uint64_t, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t);
  _BOOL4 v18;
  _BOOL8 result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  void (*v25)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v26;
  uint64_t (*v27)(uint64_t, _QWORD);
  int v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t i;
  _anonymous_namespace_ *v36;
  unint64_t j;
  uint64_t v38;
  uint64_t (*v39)(uint64_t, _QWORD);
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _BYTE v50[32];
  unint64_t v51;
  _BYTE v52[32];
  _BYTE v53[12];
  char v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;

  if (a5 == a6)
    goto LABEL_4;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v20 = **((_QWORD **)a5 + 2);
    v21 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v20 != (unsigned __int16)v21)
      goto LABEL_15;
    v23 = WORD1(v20) == WORD1(v21);
    v22 = (v21 ^ v20) & 0xFFFFFF00000000;
    v23 = v23 && v22 == 0;
    if (!v23)
      goto LABEL_15;
LABEL_4:
    v14 = 1;
    if (a7)
      goto LABEL_5;
    goto LABEL_17;
  }
  if (re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_4;
LABEL_15:
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
  v14 = 0;
  if (a7)
  {
LABEL_5:
    v15 = *(re::internal **)(a1 + 192);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v56);
    re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)&v57);
    re::internal::translateType(v15, (const re::TypeRegistry *)v52, (uint64_t)v53);
    v16 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v53);
    if (v16)
    {
      v17 = (void (*)(uint64_t, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))v16;
      v56 = 0;
      v18 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginArray((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v56, 0);
      result = 0;
      if (!v18)
        return result;
      if (v54 == 1)
      {
        if (v56)
          re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeArray(a1 + 24, 0, *(unsigned int *)(v55 + 8), v56, 1);
      }
      else if (v56)
      {
        for (i = 0; i < v56; ++i)
          v17(a1, 0, 0, 0, v53, v53, 1);
      }
      v36 = (_anonymous_namespace_ *)(a1 + 24);
      goto LABEL_48;
    }
    goto LABEL_28;
  }
LABEL_17:
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &v56);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)&v57);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v56);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)&v57);
  re::TypeInfo::TypeInfo((uint64_t)&v56, (uint64_t)a5);
  v24 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v53);
  if (!v24)
  {
LABEL_28:
    v48 = re::TypeInfo::name((re::TypeInfo *)v53)[1];
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v30, v31, v32, v33, v34, v48);
    return 0;
  }
  v25 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v24;
  v51 = (*(uint64_t (**)(uint64_t))(v58 + 80))(a4);
  v26 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginArray((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v51, 0);
  result = 0;
  if (!v26)
    return result;
  v27 = *(uint64_t (**)(uint64_t, _QWORD))(v58 + 96);
  if (!v27)
  {
    v39 = *(uint64_t (**)(uint64_t, _QWORD))(v58 + 104);
    if (v39 && *(_QWORD *)(v58 + 112) && *(_QWORD *)(v58 + 120))
    {
      v40 = v39(a4, *(_QWORD *)(a1 + 56));
      v41 = (*(uint64_t (**)(void))(v58 + 112))();
      if (v41)
      {
        v42 = v41;
        do
        {
          v25(a1, 0, 0, v42, v53, v52, 0);
          v42 = (*(uint64_t (**)(uint64_t))(v58 + 112))(v40);
        }
        while (v42);
      }
      (*(void (**)(uint64_t, _QWORD))(v58 + 120))(v40, *(_QWORD *)(a1 + 56));
      goto LABEL_47;
    }
    re::TypeInfo::TypeInfo((uint64_t)v50, (uint64_t)&v56);
    v49 = re::TypeInfo::name((re::TypeInfo *)v50)[1];
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "List type \"%s\" does not provide an indexer or iterator.", v43, v44, v45, v46, v47, v49);
    return 0;
  }
  if (*((_BYTE *)a5 + 12) == 5)
    v28 = v14;
  else
    v28 = 0;
  if (v28 == 1 && (*(_BYTE *)(*((_QWORD *)a5 + 2) + 48) & 8) != 0 && v54 == 1)
  {
    if (v51)
    {
      v29 = (char *)v27(a4, 0);
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeArray(a1 + 24, v29, *(unsigned int *)(v55 + 8), v51, 0);
    }
  }
  else if (v51)
  {
    for (j = 0; j < v51; ++j)
    {
      v38 = (*(uint64_t (**)(uint64_t, unint64_t))(v58 + 96))(a4, j);
      v25(a1, 0, 0, v38, v53, v52, 0);
    }
  }
LABEL_47:
  v36 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_48:
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endArray(v36);
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeDictionary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  re::internal *v18;
  re::internal *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, _QWORD, _QWORD, _QWORD *, _QWORD *, uint64_t, double);
  uint64_t v22;
  void (*v23)(uint64_t, const char *, _QWORD, _QWORD, int *, int *, uint64_t);
  _BOOL4 v24;
  _BOOL8 result;
  unint64_t v26;
  double v27;
  _anonymous_namespace_ *v28;
  uint64_t v29;
  void (*v30)(uint64_t, const char *, _QWORD, uint64_t, _QWORD *, _BYTE *, _QWORD, double);
  uint64_t v31;
  void (*v32)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v33;
  uint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __n128 v43;
  __n128 v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t i;
  double v49;
  unint64_t v50;
  void (*v51)(void);
  re::TypeInfo *v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t j;
  double v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  _QWORD v66[2];
  unint64_t v67;
  int v68;
  uint64_t *v69;
  unint64_t v70;
  _BYTE v71[16];
  uint64_t v72;
  _BYTE v73[32];
  _BYTE v74[32];
  _BYTE v75[32];
  _QWORD v76[4];
  uint64_t v77;
  int v78;
  const char *v79;
  __int16 v80;
  int v81;
  __int16 v82;
  unint64_t v83;
  __int16 v84;
  unint64_t v85;
  __n128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  uint64_t v91;

  v91 = *MEMORY[0x24BDAC8D0];
  if (a5 == a6)
    goto LABEL_11;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_11;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (!a7)
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &v86);
    re::TypeInfo::TypeInfo((uint64_t)v76, (uint64_t)&v86.n128_i64[1]);
    re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v86);
    re::TypeInfo::TypeInfo((uint64_t)v75, (uint64_t)&v86.n128_i64[1]);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v86);
    re::TypeInfo::TypeInfo((uint64_t)v74, (uint64_t)&v86.n128_i64[1]);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v86);
    re::TypeInfo::TypeInfo((uint64_t)v73, (uint64_t)&v86.n128_i64[1]);
    re::TypeInfo::TypeInfo((uint64_t)v71, (uint64_t)a5);
    v29 = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 80))(a1, v76);
    if (!v29)
    {
      v52 = (re::TypeInfo *)v76;
      goto LABEL_45;
    }
    v30 = (void (*)(uint64_t, const char *, _QWORD, uint64_t, _QWORD *, _BYTE *, _QWORD, double))v29;
    v31 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v75);
    if (!v31)
    {
      v52 = (re::TypeInfo *)v75;
      goto LABEL_45;
    }
    v32 = (void (*)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v31;
    v70 = (*(uint64_t (**)(uint64_t))(v72 + 88))(a4);
    v33 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginDictionary((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v70, 0);
    result = 0;
    if (!v33)
      return result;
    if (!v70)
    {
LABEL_54:
      v28 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_55:
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionary(v28);
      return *(_BYTE *)(a1 + 64) == 0;
    }
    v34 = *(_QWORD *)a5;
    v86.n128_u64[0] = 0x449AD97C4B77BED4;
    v86.n128_u64[1] = (unint64_t)"_CompareFunc";
    v35 = (unint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v34 + 200, &v86);
    if (v35)
    {
      v36 = *v35;
      re::StringID::destroyString((re::StringID *)&v86);
      if (v34)
      {
        v37 = *(_QWORD *)v76[2];
        v86.n128_u64[0] = v36;
        v86.n128_u64[1] = v37;
        LODWORD(v87) = -1;
        v38 = (unint64_t *)re::HashTable<re::internal::TypeAttributeKey,re::internal::TypeAttributeData,re::Hash<re::internal::TypeAttributeKey>,re::EqualTo<re::internal::TypeAttributeKey>,true,false>::tryGet(v76[0] + 768, (uint64_t *)&v86);
        if (v38)
        {
          v39 = *v38;
          if (*v38)
          {
            v69 = 0;
            v66[1] = 0;
            v67 = 0;
            v68 = 0;
            v66[0] = *(_QWORD *)(a1 + 56);
            re::DynamicArray<re::RigNodeConstraint>::setCapacity(v66, v70);
            ++v68;
            v40 = (*(uint64_t (**)(uint64_t, _QWORD))(v72 + 112))(a4, *(_QWORD *)(a1 + 56));
            if ((*(unsigned int (**)(void))(v72 + 120))())
            {
              do
              {
                v41 = (*(uint64_t (**)(uint64_t))(v72 + 128))(v40);
                v42 = (*(uint64_t (**)(uint64_t))(v72 + 136))(v40);
                v86.n128_u64[0] = v41;
                v86.n128_u64[1] = v42;
                v43 = re::DynamicArray<re::RigNodeConstraint>::add((_anonymous_namespace_ *)v66, &v86);
              }
              while (((*(uint64_t (**)(uint64_t, __n128))(v72 + 120))(v40, v43) & 1) != 0);
            }
            (*(void (**)(uint64_t, _QWORD))(v72 + 144))(v40, *(_QWORD *)(a1 + 56));
            v86.n128_u64[0] = v39;
            v45 = 126 - 2 * __clz(v67);
            if (v67)
              v46 = v45;
            else
              v46 = 0;
            std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(v69, &v69[2 * v67], (uint64_t (**)(uint64_t, uint64_t))&v86, v46, 1, v44);
            if (v70)
            {
              v47 = 0;
              for (i = 0; i < v70; ++i)
              {
                v49 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 0);
                if (v67 <= i)
                {
                  v77 = 0;
                  v89 = 0u;
                  v90 = 0u;
                  v87 = 0u;
                  v88 = 0u;
                  v86 = 0u;
                  v64 = v67;
                  os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                  v78 = 136315906;
                  v79 = "operator[]";
                  v80 = 1024;
                  v81 = 789;
                  v82 = 2048;
                  v83 = i;
                  v84 = 2048;
                  v85 = v64;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
LABEL_57:
                  v77 = 0;
                  v89 = 0u;
                  v90 = 0u;
                  v87 = 0u;
                  v88 = 0u;
                  v86 = 0u;
                  v65 = v50;
                  os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                  v78 = 136315906;
                  v79 = "operator[]";
                  v80 = 1024;
                  v81 = 789;
                  v82 = 2048;
                  v83 = i;
                  v84 = 2048;
                  v85 = v65;
                  _os_log_send_and_compose_impl();
                  _os_crash_msg();
                  __break(1u);
                }
                v30(a1, "key", 0, v69[v47], v76, v74, 0, v49);
                v50 = v67;
                if (v67 <= i)
                  goto LABEL_57;
                v32(a1, "value", 0, v69[v47 + 1], v75, v73, 0);
                re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
                v47 += 2;
              }
            }
            if (!v66[0] || !v69)
              goto LABEL_54;
            v51 = *(void (**)(void))(*(_QWORD *)v66[0] + 40);
            goto LABEL_53;
          }
        }
      }
    }
    else
    {
      re::StringID::destroyString((re::StringID *)&v86);
    }
    v59 = (*(uint64_t (**)(uint64_t, _QWORD))(v72 + 112))(a4, *(_QWORD *)(a1 + 56));
    (*(void (**)(void))(v72 + 120))();
    if (v70)
    {
      for (j = 0; j < v70; ++j)
      {
        v61 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 0);
        v62 = (*(uint64_t (**)(uint64_t, double))(v72 + 128))(v59, v61);
        ((void (*)(uint64_t, const char *, _QWORD, uint64_t, _QWORD *, _BYTE *, _QWORD))v30)(a1, "key", 0, v62, v76, v74, 0);
        v63 = (*(uint64_t (**)(uint64_t))(v72 + 136))(v59);
        v32(a1, "value", 0, v63, v75, v73, 0);
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
        (*(void (**)(uint64_t))(v72 + 120))(v59);
      }
    }
    v51 = *(void (**)(void))(v72 + 144);
LABEL_53:
    v51();
    goto LABEL_54;
  }
  v18 = *(re::internal **)(a1 + 192);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v86);
  re::TypeInfo::TypeInfo((uint64_t)&v78, (uint64_t)&v86.n128_i64[1]);
  re::internal::translateType(v18, (const re::TypeRegistry *)&v78, (uint64_t)v66);
  v19 = *(re::internal **)(a1 + 192);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v86);
  re::TypeInfo::TypeInfo((uint64_t)v76, (uint64_t)&v86.n128_i64[1]);
  re::internal::translateType(v19, (const re::TypeRegistry *)v76, (uint64_t)&v78);
  v20 = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 80))(a1, v66);
  if (!v20)
  {
    v52 = (re::TypeInfo *)v66;
LABEL_45:
    v53 = re::TypeInfo::name(v52);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v54, v55, v56, v57, v58, v53[1]);
    return 0;
  }
  v21 = (void (*)(uint64_t, const char *, _QWORD, _QWORD, _QWORD *, _QWORD *, uint64_t, double))v20;
  v22 = (*(uint64_t (**)(uint64_t, int *))(*(_QWORD *)a1 + 80))(a1, &v78);
  if (!v22)
  {
    v52 = (re::TypeInfo *)&v78;
    goto LABEL_45;
  }
  v23 = (void (*)(uint64_t, const char *, _QWORD, _QWORD, int *, int *, uint64_t))v22;
  v86.n128_u64[0] = 0;
  v24 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginDictionary((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, v86.n128_u64, 0);
  result = 0;
  if (v24)
  {
    if (v86.n128_u64[0])
    {
      v26 = 0;
      do
      {
        v27 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 1);
        v21(a1, "key", 0, 0, v66, v66, 1, v27);
        v23(a1, "value", 0, 0, &v78, &v78, 1);
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
        ++v26;
      }
      while (v26 < v86.n128_u64[0]);
    }
    v28 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_55;
  }
  return result;
}

BOOL re::serializeUnion<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  unint64_t v18[4];
  unint64_t Tag;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_19:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
      return 0;
    }
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 != (unsigned __int16)v15)
      goto LABEL_19;
    v17 = WORD1(v14) == WORD1(v15);
    v16 = (v15 ^ v14) & 0xFFFFFF00000000;
    v17 = v17 && v16 == 0;
    if (!v17)
      goto LABEL_19;
  }
LABEL_4:
  if (a7)
  {
    if (!*(_BYTE *)(a1 + 64))
    {
      LOBYTE(v20) = 1;
      DWORD1(v20) = 16;
      *((_QWORD *)&v20 + 1) = a2;
      v21 = 0u;
      v22 = 0u;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)(a1 + 24), &v20);
      v18[0] = 0;
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(a1 + 24, "tag", 0, (char *)v18, (uint64_t)"uint64", 0);
      if (v18[0] < *(unsigned int *)(*((_QWORD *)a6 + 2) + 88))
      {
        re::TypeInfo::unionMember(a6, v18[0], (uint64_t)&v20);
        if (!*(_BYTE *)(a1 + 64))
          (*(void (**)(uint64_t, const char *, _QWORD, _QWORD, __int128 *, __int128 *, uint64_t))(*(_QWORD *)a1 + 72))(a1, "value", 0, 0, &v20, &v20, 1);
      }
LABEL_13:
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(_BYTE *)(a1 + 64) == 0;
    }
  }
  else if (!*(_BYTE *)(a1 + 64))
  {
    LOBYTE(v20) = 1;
    DWORD1(v20) = 16;
    *((_QWORD *)&v20 + 1) = a2;
    v21 = 0u;
    v22 = 0u;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)(a1 + 24), &v20);
    re::TypeInfo::TypeInfo((uint64_t)&v20, (uint64_t)a5);
    Tag = re::UnionAccessor::readTag((re::UnionAccessor *)&v20, a4);
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(a1 + 24, "tag", 0, (char *)&Tag, (uint64_t)"uint64", 0);
    if (Tag < *(unsigned int *)(*((_QWORD *)a5 + 2) + 88))
    {
      re::TypeInfo::unionMember(a5, Tag, (uint64_t)v18);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, char *, unint64_t *, unint64_t *, _QWORD))(*(_QWORD *)a1 + 72))(a1, "value", 0, a4, v18, v18, 0);
    }
    goto LABEL_13;
  }
  return 0;
}

uint64_t re::serializeObject<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, re::TypeInfo *this, uint64_t a6, uint64_t a7)
{
  uint64_t *v14;
  const char *v15;
  re::TypeRegistry *v17;
  re *v18;
  const re::TypeInfo *v19;
  uint64_t v20;
  const char *v21;
  const re::TypeInfo *v22;
  const re::TypeInfo *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[2];
  _BYTE v35[32];
  _OWORD v36[3];

  if (!(_DWORD)a7)
  {
LABEL_6:
    if ((*(_BYTE *)(*((_QWORD *)this + 2) + 48) & 4) != 0)
      return re::internal::serializeObjectWithOneMember<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((_BYTE *)a1, a2, a3, a4, (uint64_t *)this, (uint64_t *)a6, a7);
    if (*(_BYTE *)(a1 + 64))
      return 0;
    LOBYTE(v36[0]) = 1;
    DWORD1(v36[0]) = 0;
    *((_QWORD *)&v36[0] + 1) = a2;
    memset(&v36[1], 0, 32);
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)(a1 + 24), v36);
    if (this == (re::TypeInfo *)a6)
      goto LABEL_14;
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v24 = **((_QWORD **)this + 2);
      v25 = **(_QWORD **)(a6 + 16);
      if ((unsigned __int16)v24 == (unsigned __int16)v25)
      {
        v27 = WORD1(v24) == WORD1(v25);
        v26 = (v25 ^ v24) & 0xFFFFFF00000000;
        v27 = v27 && v26 == 0;
        if (v27)
          goto LABEL_14;
      }
    }
    else if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, v23))
    {
LABEL_14:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((_BYTE *)a1, a4, (uint64_t *)this, a7);
LABEL_25:
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(_BYTE *)(a1 + 64) == 0;
    }
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      re::internal::serializeMembersWithVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a4, (uint64_t *)this, (uint64_t *)a6, a7);
    }
    else
    {
      v28 = re::TypeInfo::name(this)[1];
      re::TypeInfo::name((re::TypeInfo *)a6);
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v29, v30, v31, v32, v33, v28);
    }
    goto LABEL_25;
  }
  if ((*(_BYTE *)(*((_QWORD *)this + 2) + 49) & 1) != 0)
  {
    v17 = *(re::TypeRegistry **)(a1 + 192);
    v34[0] = 0x2686EB529B3EE220;
    v34[1] = "DynamicString";
    re::TypeRegistry::typeInfo(v17, (const re::StringID *)v34, v36);
    re::TypeInfo::TypeInfo((uint64_t)v35, (uint64_t)v36 + 8);
    re::StringID::destroyString((re::StringID *)v34);
    v18 = (re *)v35;
    v19 = (const re::TypeInfo *)v35;
    v20 = a1;
    v21 = a2;
    v22 = (const re::TypeInfo *)a3;
  }
  else
  {
    v14 = re::TypeInfo::name(this);
    if ((*v14 & 0xFFFFFFFFFFFFFFFELL) != 0x2686EB529B3EE220)
      goto LABEL_6;
    v15 = (const char *)v14[1];
    if (v15 != "DynamicString")
    {
      if (strcmp(v15, "DynamicString"))
        goto LABEL_6;
    }
    v20 = a1;
    v21 = a2;
    v22 = (const re::TypeInfo *)a3;
    v18 = this;
    v19 = this;
  }
  re::serializeDynamicString<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(v20, v21, v22, 0, v18, v19, 1);
  return *(_BYTE *)(a1 + 64) == 0;
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<short>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  uint64_t v11;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if ((a6 & 1) != 0)
    a4 = 0;
  if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((_QWORD *)a1, a4, 2uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    v11 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v11 - 16);
  }
  return 1;
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  uint64_t v11;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if ((a6 & 1) != 0)
    a4 = 0;
  if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((_QWORD *)a1, a4, 4uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    v11 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v11 - 16);
  }
  return 1;
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  uint64_t v11;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if ((a6 & 1) != 0)
    a4 = 0;
  if ((re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((_QWORD *)a1, a4, 8uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    v11 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v11 - 16);
  }
  return 1;
}

uint64_t re::internal::serializeEnumAsBinary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(_BYTE *a1, const char *a2, const re::TypeInfo *a3, re::TypeInfo *a4, re::internal *a5, re::TypeInfo *a6, int a7)
{
  re::internal *v11;
  uint64_t result;
  _QWORD *v15;
  uint64_t (*v16)(_BYTE *, const char *, const re::TypeInfo *, re::TypeInfo *, _BYTE *, _BYTE *, _QWORD);
  _BYTE *v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  re::internal *v23;
  _BYTE v24[32];
  _BYTE v25[8];
  _BYTE v26[32];

  if (a7)
  {
    v11 = (re::internal *)*((_QWORD *)a1 + 24);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), v25);
    re::TypeInfo::TypeInfo((uint64_t)v24, (uint64_t)v26);
    re::internal::translateType(v11, (const re::TypeRegistry *)v24, (uint64_t)v25);
    if (!a1[64])
      return (*(uint64_t (**)(_BYTE *, const char *, const re::TypeInfo *, _QWORD, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, a3, 0, v25, v25, 1);
    return 0;
  }
  v15 = *(_QWORD **)a5;
  if (a5 == a6)
    goto LABEL_8;
  if (v15 == *(_QWORD **)a6)
  {
    v19 = **((_QWORD **)a5 + 2);
    v20 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v19 == (unsigned __int16)v20)
    {
      v22 = WORD1(v19) == WORD1(v20);
      v21 = (v20 ^ v19) & 0xFFFFFF00000000;
      v22 = v22 && v21 == 0;
      if (v22)
        goto LABEL_8;
    }
LABEL_15:
    result = re::internal::findEnumConstantToSerialize<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a4, a5, a6, 1);
    if (!result)
      return result;
    a4 = (re::TypeInfo *)result;
    v23 = (re::internal *)*((_QWORD *)a1 + 24);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), v25);
    re::TypeInfo::TypeInfo((uint64_t)v24, (uint64_t)v26);
    re::internal::translateType(v23, (const re::TypeRegistry *)v24, (uint64_t)v25);
    if (a1[64])
      return 0;
    v16 = *(uint64_t (**)(_BYTE *, const char *, const re::TypeInfo *, re::TypeInfo *, _BYTE *, _BYTE *, _QWORD))(*(_QWORD *)a1 + 72);
    v17 = v25;
    v18 = v25;
    return v16(a1, a2, a3, a4, v17, v18, 0);
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_15;
  v15 = *(_QWORD **)a5;
LABEL_8:
  re::TypeRegistry::typeInfo(v15, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), v25);
  re::TypeInfo::TypeInfo((uint64_t)v24, (uint64_t)v26);
  if (a1[64])
    return 0;
  v16 = *(uint64_t (**)(_BYTE *, const char *, const re::TypeInfo *, re::TypeInfo *, _BYTE *, _BYTE *, _QWORD))(*(_QWORD *)a1 + 72);
  v17 = v24;
  v18 = v24;
  return v16(a1, a2, a3, a4, v17, v18, 0);
}

double re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginOptional(uint64_t a1, const char *a2, uint64_t a3, char *a4, int a5)
{
  uint64_t v9;
  double result;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (!*(_BYTE *)(a1 + 40))
  {
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1, a2, 0, a4, (uint64_t)"BOOL", 2);
    v9 = *a4;
    LOBYTE(v11) = 3;
    DWORD1(v11) = a5;
    *((_QWORD *)&v11 + 1) = a2;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = v9;
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v11);
  }
  return result;
}

_anonymous_namespace_ *re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endOptional(_anonymous_namespace_ *result)
{
  uint64_t v1;
  uint64_t v2;
  _BYTE *v3;
  const char *v4;
  _anonymous_namespace_ *v5;
  char v6;
  _BYTE v7[23];
  _OWORD v8[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = (uint64_t)result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == *(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 24))
    {
      result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 3);
      v2 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      ++*(_QWORD *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if ((v6 & 1) != 0)
        v3 = *(_BYTE **)&v7[7];
      else
        v3 = v7;
      if (*(uint64_t *)(*(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112) - 24) <= 0)
        v4 = "Optional should not have a value.";
      else
        v4 = "Optional requires a value.";
      re::DynamicString::format((re::DynamicString *)"Failed to serialize optional type \"%s\". %s", (re::DynamicString *)v8, v3, v4);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v8);
      if (*(_QWORD *)&v8[0])
      {
        if ((BYTE8(v8[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v8[0] + 40))();
        memset(v8, 0, sizeof(v8));
      }
      result = v5;
      if (v5)
      {
        if ((v6 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
      }
    }
  }
  return result;
}

BOOL re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginArray(_anonymous_namespace_ *a1, const char *a2, uint64_t a3, unint64_t *a4, int a5)
{
  _BOOL8 result;
  char v10;
  unint64_t v11;
  __int128 v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;

  if (*((_BYTE *)a1 + 40))
    return 0;
  result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::isValidSize(a1, a2, *a4);
  if (result)
  {
    if ((a5 & 4) == 0)
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>((uint64_t)a1, a2, 0, (char *)a4, (uint64_t)"uint32", 2);
    if ((a5 & 8) != 0)
    {
      if (*a4)
        v10 = 73;
      else
        v10 = 78;
      v17 = v10;
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>((uint64_t)a1, a2, 0, &v17, (uint64_t)"uint8", 2);
    }
    v11 = *a4;
    LOBYTE(v12) = 5;
    DWORD1(v12) = a5;
    *((_QWORD *)&v12 + 1) = a2;
    v13 = 0;
    v15 = 0;
    v16 = 0;
    v14 = v11;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v12);
    return *((_BYTE *)a1 + 40) == 0;
  }
  return result;
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeArray(uint64_t result, char *a2, uint64_t a3, uint64_t a4, char a5)
{
  _anonymous_namespace_ *v7;
  size_t v8;
  uint64_t v9;

  if (!*(_BYTE *)(result + 40))
  {
    v7 = (_anonymous_namespace_ *)result;
    v8 = a4 * a3;
    if ((a5 & 1) != 0)
      a2 = 0;
    result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((_QWORD *)result, a2, v8);
    if ((result & 1) != 0)
    {
      if ((a5 & 2) == 0)
      {
        v9 = *((_QWORD *)v7 + 16) + 48 * *((_QWORD *)v7 + 14);
        *(_QWORD *)(v9 - 16) += a4;
      }
    }
    else
    {
      return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v7, 0, (uint64_t)"Array");
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endArray(_anonymous_namespace_ *result)
{
  uint64_t v1;
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  _anonymous_namespace_ *v5;
  char v6;
  _BYTE v7[23];
  _OWORD v8[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = (uint64_t)result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == *(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 24))
    {
      result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 5);
      v2 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      ++*(_QWORD *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if ((v6 & 1) != 0)
        v3 = *(_BYTE **)&v7[7];
      else
        v3 = v7;
      v4 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize array \"%s\". Expected number of elements: %lld. Actual number of elements: %lld.", (re::DynamicString *)v8, v3, *(_QWORD *)(v4 - 24), *(_QWORD *)(v4 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v8);
      if (*(_QWORD *)&v8[0])
      {
        if ((BYTE8(v8[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v8[0] + 40))();
        memset(v8, 0, sizeof(v8));
      }
      result = v5;
      if (v5)
      {
        if ((v6 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
      }
    }
  }
  return result;
}

BOOL re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::isValidSize(_anonymous_namespace_ *a1, const char *a2, unint64_t a3)
{
  unint64_t v3;
  _BYTE *v6;
  uint64_t v8;
  char v9;
  _BYTE v10[23];
  _OWORD v11[2];

  v3 = HIDWORD(a3);
  if (HIDWORD(a3))
  {
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, a2, (re::DynamicString *)&v8);
    if ((v9 & 1) != 0)
      v6 = *(_BYTE **)&v10[7];
    else
      v6 = v10;
    re::DynamicString::format((re::DynamicString *)"Failed to serialize array/string \"%s\". Max length exceeded: actual length \"%zu\", max length: \"%u\".", (re::DynamicString *)v11, v6, a3, 0xFFFFFFFFLL);
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v11);
    if (*(_QWORD *)&v11[0])
    {
      if ((BYTE8(v11[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v11[0] + 40))();
      memset(v11, 0, sizeof(v11));
    }
    if (v8 && (v9 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v8 + 40))();
  }
  return v3 == 0;
}

BOOL re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginDictionary(_anonymous_namespace_ *a1, const char *a2, uint64_t a3, unint64_t *a4, int a5)
{
  _BOOL8 result;
  unint64_t v10;
  __int128 v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (*((_BYTE *)a1 + 40))
    return 0;
  result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::isValidSize(a1, a2, *a4);
  if (result)
  {
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>((uint64_t)a1, a2, 0, (char *)a4, (uint64_t)"uint32", 2);
    v10 = *a4;
    LOBYTE(v11) = 6;
    DWORD1(v11) = a5;
    *((_QWORD *)&v11 + 1) = a2;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v11);
    return *((_BYTE *)a1 + 40) == 0;
  }
  return result;
}

_anonymous_namespace_ *re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry(_anonymous_namespace_ *result)
{
  uint64_t v1;
  uint64_t v2;
  _BYTE *v3;
  _anonymous_namespace_ *v4;
  char v5;
  _BYTE v6[23];
  _OWORD v7[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = (uint64_t)result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == 2)
    {
      result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 7);
      v2 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      ++*(_QWORD *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v4);
      if ((v5 & 1) != 0)
        v3 = *(_BYTE **)&v6[7];
      else
        v3 = v6;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary entry \"%s\". Expected 2 objects (key+value). Actual number of objects: %lld.", (re::DynamicString *)v7, v3, *(_QWORD *)(*(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112) - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v7);
      if (*(_QWORD *)&v7[0])
      {
        if ((BYTE8(v7[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v7[0] + 40))();
        memset(v7, 0, sizeof(v7));
      }
      result = v4;
      if (v4)
      {
        if ((v5 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v4 + 40))();
      }
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionary(_anonymous_namespace_ *result)
{
  uint64_t v1;
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  _anonymous_namespace_ *v5;
  char v6;
  _BYTE v7[23];
  _OWORD v8[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = (uint64_t)result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == *(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 24))
    {
      result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 6);
      v2 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      ++*(_QWORD *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if ((v6 & 1) != 0)
        v3 = *(_BYTE **)&v7[7];
      else
        v3 = v7;
      v4 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize dictionary \"%s\". Expected number of entries: %lld. Actual number of entries: %lld.", (re::DynamicString *)v8, v3, *(_QWORD *)(v4 - 24), *(_QWORD *)(v4 - 16));
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v8);
      if (*(_QWORD *)&v8[0])
      {
        if ((BYTE8(v8[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v8[0] + 40))();
        memset(v8, 0, sizeof(v8));
      }
      result = v5;
      if (v5)
      {
        if ((v6 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
      }
    }
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*,false>(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5, __n128 a6)
{
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t *v16;
  char *v17;
  char v18;
  BOOL v19;
  uint64_t *v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(char *a1, char *a2, uint64_t (**a3)(uint64_t, _QWORD))
{
  uint64_t v6;
  _BOOL8 result;
  char *v8;
  __int128 v9;
  char *v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  char *v17;
  __int128 v18;

  v6 = (a2 - a1) >> 4;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v8 = a2 - 16;
      if ((*a3)(*((_QWORD *)a2 - 2), *(_QWORD *)a1))
      {
        v9 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v8;
        *(_OWORD *)v8 = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a2 - 2, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, (_QWORD *)a2 - 2, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, (_QWORD *)a1 + 6, (_QWORD *)a2 - 2, a3);
      return 1;
    default:
      v10 = a1 + 32;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,BOOL re::serializeDictionary<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)::{lambda(re::Pair<void const*,void *,true> const&,re::Pair<void const*,void *,true> const&)#1} &,re::Pair<void const*,void *,true>*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, a3);
      v11 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(*(_QWORD *)v11, *(_QWORD *)v10))
    {
      v18 = *(_OWORD *)v11;
      v14 = *(_QWORD *)v11;
      v15 = v12;
      while (1)
      {
        *(_OWORD *)&a1[v15 + 48] = *(_OWORD *)&a1[v15 + 32];
        if (v15 == -32)
          break;
        v16 = (*a3)(v14, *(_QWORD *)&a1[v15 + 16]);
        v15 -= 16;
        if ((v16 & 1) == 0)
        {
          v17 = &a1[v15 + 48];
          goto LABEL_12;
        }
      }
      v17 = a1;
LABEL_12:
      *(_OWORD *)v17 = v18;
      if (++v13 == 8)
        return v11 + 16 == a2;
    }
    v10 = v11;
    v12 += 16;
    v11 += 16;
    if (v11 == a2)
      return 1;
  }
}

_anonymous_namespace_ *re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endObject(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  uint64_t v2;

  if (!*((_BYTE *)result + 40))
  {
    v1 = result;
    result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 1);
    v2 = *((_QWORD *)v1 + 16) + 48 * *((_QWORD *)v1 + 14);
    ++*(_QWORD *)(v2 - 16);
  }
  return result;
}

BOOL re::serializeDynamicString<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  char *v19;
  _BOOL8 result;
  _BOOL4 v21;
  _anonymous_namespace_ *v22;
  unint64_t v23;
  unint64_t v24;
  _BOOL4 v25;
  char *v26;
  unint64_t v27;

  if (a5 == a6)
    goto LABEL_14;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x22C6ED80D0CLL
    || (v19 = (char *)v18[1], v19 != "StringID") && strcmp(v19, "StringID"))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v27 = 0;
    v21 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v27, 0);
    result = 0;
    if (!v21)
      return result;
    if (v27)
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, 0, 1);
    v22 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_29;
  }
  v23 = *(_QWORD *)(a4 + 8);
  if ((v23 & 1) != 0)
    v24 = v23 >> 1;
  else
    v24 = v23 >> 1;
  v27 = v24;
  v25 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v27, 0);
  result = 0;
  if (v25)
  {
    if (v27)
    {
      if ((*(_BYTE *)(a4 + 8) & 1) != 0)
        v26 = *(char **)(a4 + 16);
      else
        v26 = (char *)(a4 + 9);
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, v26, 0);
    }
    v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_29:
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString(v22);
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

BOOL re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString(_anonymous_namespace_ *a1, const char *a2, uint64_t a3, unint64_t *a4, int a5)
{
  _BOOL8 result;
  unint64_t v10;
  __int128 v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (*((_BYTE *)a1 + 40))
    return 0;
  result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::isValidSize(a1, a2, *a4);
  if (result)
  {
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>((uint64_t)a1, "length", 0, (char *)a4, (uint64_t)"uint32", 2);
    v10 = *a4;
    LOBYTE(v11) = 8;
    DWORD1(v11) = a5;
    *((_QWORD *)&v11 + 1) = a2;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = v10;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v11);
    return *((_BYTE *)a1 + 40) == 0;
  }
  return result;
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(uint64_t result, char *a2, char a3)
{
  _anonymous_namespace_ *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (!*(_BYTE *)(result + 40))
  {
    v4 = (_anonymous_namespace_ *)result;
    v5 = *(_QWORD *)(result + 128) + 48 * *(_QWORD *)(result + 112);
    v6 = *(_QWORD *)(v5 - 24);
    if ((a3 & 1) != 0)
      a2 = 0;
    result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::process<re::DynamicArrayBufferedOutputStream,0>((_QWORD *)result, a2, *(_QWORD *)(v5 - 24));
    if ((result & 1) != 0)
    {
      if ((a3 & 2) == 0)
      {
        v7 = *((_QWORD *)v4 + 16) + 48 * *((_QWORD *)v4 + 14);
        *(_QWORD *)(v7 - 16) += v6;
      }
    }
    else
    {
      return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setErrorWithType(v4, 0, (uint64_t)"string");
    }
  }
  return result;
}

_anonymous_namespace_ *re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString(_anonymous_namespace_ *result)
{
  uint64_t v1;
  uint64_t v2;
  _BYTE *v3;
  uint64_t v4;
  _anonymous_namespace_ *v5;
  char v6;
  _BYTE v7[23];
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  __int128 v11[3];

  if (!*((_BYTE *)result + 40))
  {
    v1 = (uint64_t)result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == *(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 24))
    {
      result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 8);
      v2 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      ++*(_QWORD *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v5);
      if ((v6 & 1) != 0)
        v3 = *(_BYTE **)&v7[7];
      else
        v3 = v7;
      v4 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      re::DynamicString::format((re::DynamicString *)"Failed to serialize string \"%s\". Expected number of characters: %lld. Actual number of characters: %lld.", (re::DynamicString *)&v8, v3, *(_QWORD *)(v4 - 24), *(_QWORD *)(v4 - 16));
      *(_QWORD *)&v11[0] = 400;
      *((_QWORD *)&v11[0] + 1) = &re::FoundationErrorCategory(void)::instance;
      *(_QWORD *)&v11[1] = v8;
      *((_QWORD *)&v11[2] + 1) = v10;
      *(__int128 *)((char *)&v11[1] + 8) = v9;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, v11);
      if (*(_QWORD *)&v11[1])
      {
        if ((BYTE8(v11[1]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v11[1] + 40))();
        memset(&v11[1], 0, 32);
      }
      result = v5;
      if (v5)
      {
        if ((v6 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(_BYTE *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t result;
  unint64_t i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[32];
  _QWORD *v14;
  uint64_t v15;
  _QWORD *v16[2];
  uint64_t v17;
  unint64_t v18;
  _BYTE v19[8];
  uint64_t v20;
  _BYTE v21[8];
  uint64_t v22;

  re::TypeRegistry::typeInfo((_QWORD *)*a3, *(_QWORD *)(a3[2] + 72), v19);
  if (v19[0])
  {
    re::TypeInfo::TypeInfo((uint64_t)v16, (uint64_t)&v20);
    if (*(_DWORD *)(v17 + 88) || (re::TypeRegistry::typeInfo(v16[0], *(_QWORD *)(v17 + 72), v21), v21[0]))
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a2, v16, a4);
  }
  result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v16, *a3, a3[2]);
  if (v18)
  {
    for (i = 0; i < v18; ++i)
    {
      if (a1[64])
        break;
      result = (uint64_t)re::TypeMemberCollection::operator[]((uint64_t *)v16, i, (uint64_t)&v14);
      if (*(_BYTE *)(v15 + 28))
      {
        v10 = *(_QWORD *)(v15 + 16);
        if (strlen((const char *)v10) >= 3 && *(_BYTE *)v10 == 109)
          v10 += 2 * (*(_BYTE *)(v10 + 1) == 95);
        v11 = *(unsigned int *)(v15 + 32);
        v12 = *(unsigned int *)(v15 + 24);
        re::TypeRegistry::typeInfo(v14, *(_QWORD *)v15, v21);
        result = re::TypeInfo::TypeInfo((uint64_t)v13, (uint64_t)&v22);
        if (!a1[64])
          result = (*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v10, v11, a2 + v12, v13, v13, a4);
      }
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  const re::TypeInfo *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t i;
  uint64_t v29;
  uint64_t v30;
  re *v31;
  uint64_t v32;
  NSObject *v33;
  NSObject *v34;
  uint64_t v35;
  re::internal *v36;
  _BYTE v37[32];
  _BYTE v38[32];
  _QWORD *v39[2];
  uint64_t v40;
  _QWORD *v41[2];
  uint64_t v42;
  uint64_t v43[4];
  unint64_t v44;
  uint64_t v45[5];
  _BYTE v46[8];
  uint64_t v47;
  char v48;
  uint64_t *v49;
  _BYTE v50[8];
  uint64_t v51;
  char v52;
  uint64_t *v53;
  uint8_t buf[4];
  uint64_t v55;
  __int16 v56;
  uint64_t v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  re::TypeRegistry::typeInfo((_QWORD *)*a3, *(_QWORD *)(a3[2] + 72), v50);
  re::TypeRegistry::typeInfo((_QWORD *)*a4, *(_QWORD *)(a4[2] + 72), v46);
  if (v46[0])
  {
    if (!v50[0])
    {
      v11 = re::TypeInfo::name((re::TypeInfo *)&v47)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
      return re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Base class \"%s\" removed from type \"%s\".", v12, v13, v14, v15, v16, v11);
    }
    if (v51 == v47)
    {
      v18 = *v53;
      v19 = *v49;
      if ((unsigned __int16)*v53 == (unsigned __int16)*v49)
      {
        v21 = WORD1(v18) == WORD1(v19);
        v20 = (v19 ^ v18) & 0xFFFFFF00000000;
        v21 = v21 && v20 == 0;
        if (v21)
          goto LABEL_5;
      }
    }
    else if (re::areSameTranslatedVersion((re *)&v51, (const re::TypeInfo *)&v47, v10))
    {
LABEL_5:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>((_BYTE *)a1, a2, &v51, a5);
      goto LABEL_15;
    }
    if (v52 == v48)
    {
      re::internal::serializeMembersWithVersioning<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a2, &v51, &v47, a5);
    }
    else
    {
      v22 = re::TypeInfo::name((re::TypeInfo *)&v51)[1];
      re::TypeInfo::name((re::TypeInfo *)&v47);
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v23, v24, v25, v26, v27, v22);
    }
  }
LABEL_15:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v45, *a3, a3[2]);
  result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v43, *a4, a4[2]);
  if (v44)
  {
    for (i = 0; i < v44; ++i)
    {
      if (*(_BYTE *)(a1 + 64))
        break;
      result = (uint64_t)re::TypeMemberCollection::operator[](v43, i, (uint64_t)v41);
      if (*(_BYTE *)(v42 + 28))
      {
        v29 = *(_QWORD *)(v42 + 16);
        if (strlen((const char *)v29) >= 3 && *(_BYTE *)v29 == 109)
          v29 += 2 * (*(_BYTE *)(v29 + 1) == 95);
        v30 = *(unsigned int *)(v42 + 32);
        v31 = *(re **)(*a4 + 856);
        if (!v31
          || (v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v41),
              (_DWORD)v31 == -1))
        {
          v33 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
          {
            v34 = v33;
            v35 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            v55 = v35;
            v56 = 2080;
            v57 = v29;
            _os_log_impl(&dword_224FE9000, v34, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);

          }
          v36 = *(re::internal **)(a1 + 192);
          re::TypeRegistry::typeInfo(v41[0], *(_QWORD *)v42, buf);
          re::TypeInfo::TypeInfo((uint64_t)v39, (uint64_t)&v55 + 4);
          result = re::internal::translateType(v36, (const re::TypeRegistry *)v39, (uint64_t)buf);
          if (!*(_BYTE *)(a1 + 64))
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint8_t *, uint8_t *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
        }
        else
        {
          re::TypeMemberCollection::operator[](v45, (int)v31, (uint64_t)v39);
          v32 = *(unsigned int *)(v40 + 24);
          re::TypeRegistry::typeInfo(v39[0], *(_QWORD *)v40, buf);
          re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)&v55 + 4);
          re::TypeRegistry::typeInfo(v41[0], *(_QWORD *)v42, buf);
          result = re::TypeInfo::TypeInfo((uint64_t)v37, (uint64_t)&v55 + 4);
          if (!*(_BYTE *)(a1 + 64))
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, a2 + v32, v38, v37, a5);
        }
      }
    }
  }
  return result;
}

uint64_t *re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFunc(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t *result;
  BOOL v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  v5 = *(_QWORD *)(a1 + 192);
  result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v5 + 200, a2);
  if (v5)
    v7 = result == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v8 = *result;
    v10 = a3;
    v9 = v8 | 0xFFFFFFFF00000000;
    return (uint64_t *)re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1 + 208, &v9, &v10);
  }
  return result;
}

uint64_t re::serializeBool<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  char v20;

  v20 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v16 = **((_QWORD **)a5 + 2);
      v17 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        v19 = WORD1(v16) == WORD1(v17);
        v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        v19 = v19 && v18 == 0;
        if (v19)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v14 = &v20;
  else
    v14 = a4;
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"BOOL", a7);
}

uint64_t re::serializeChar<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  char v20;

  v20 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v16 = **((_QWORD **)a5 + 2);
      v17 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        v19 = WORD1(v16) == WORD1(v17);
        v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        v19 = v19 && v18 == 0;
        if (v19)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v14 = &v20;
  else
    v14 = a4;
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"char", a7);
}

uint64_t re::serializeI8<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  char v20;

  v20 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v16 = **((_QWORD **)a5 + 2);
      v17 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        v19 = WORD1(v16) == WORD1(v17);
        v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        v19 = v19 && v18 == 0;
        if (v19)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v14 = &v20;
  else
    v14 = a4;
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"int8", a7);
}

uint64_t re::serializeI16<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  __int16 v20;

  v20 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v16 = **((_QWORD **)a5 + 2);
      v17 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        v19 = WORD1(v16) == WORD1(v17);
        v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        v19 = v19 && v18 == 0;
        if (v19)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v14 = (char *)&v20;
  else
    v14 = a4;
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"int16", a7);
}

uint64_t re::serializeI32<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  int v20;

  v20 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v16 = **((_QWORD **)a5 + 2);
      v17 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        v19 = WORD1(v16) == WORD1(v17);
        v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        v19 = v19 && v18 == 0;
        if (v19)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v14 = (char *)&v20;
  else
    v14 = a4;
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"int32", a7);
}

uint64_t re::serializeI64<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;

  v20 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v16 = **((_QWORD **)a5 + 2);
      v17 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        v19 = WORD1(v16) == WORD1(v17);
        v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        v19 = v19 && v18 == 0;
        if (v19)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v14 = (char *)&v20;
  else
    v14 = a4;
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"int64", a7);
}

uint64_t re::serializeU8<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  char v20;

  v20 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v16 = **((_QWORD **)a5 + 2);
      v17 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        v19 = WORD1(v16) == WORD1(v17);
        v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        v19 = v19 && v18 == 0;
        if (v19)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v14 = &v20;
  else
    v14 = a4;
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"uint8", a7);
}

uint64_t re::serializeU16<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  __int16 v20;

  v20 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v16 = **((_QWORD **)a5 + 2);
      v17 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        v19 = WORD1(v16) == WORD1(v17);
        v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        v19 = v19 && v18 == 0;
        if (v19)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v14 = (char *)&v20;
  else
    v14 = a4;
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"uint16", a7);
}

uint64_t re::serializeU32<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  int v20;

  v20 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v16 = **((_QWORD **)a5 + 2);
      v17 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        v19 = WORD1(v16) == WORD1(v17);
        v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        v19 = v19 && v18 == 0;
        if (v19)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v14 = (char *)&v20;
  else
    v14 = a4;
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"uint32", a7);
}

uint64_t re::serializeU64<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;

  v20 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v16 = **((_QWORD **)a5 + 2);
      v17 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        v19 = WORD1(v16) == WORD1(v17);
        v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        v19 = v19 && v18 == 0;
        if (v19)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v14 = (char *)&v20;
  else
    v14 = a4;
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"uint64", a7);
}

uint64_t re::serializeFloat<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  int v20;

  v20 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v16 = **((_QWORD **)a5 + 2);
      v17 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        v19 = WORD1(v16) == WORD1(v17);
        v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        v19 = v19 && v18 == 0;
        if (v19)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v14 = (char *)&v20;
  else
    v14 = a4;
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"float", a7);
}

uint64_t re::serializeDouble<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;

  v20 = 0;
  if (a5 != a6)
  {
    if (*(_QWORD *)a5 == *(_QWORD *)a6)
    {
      v16 = **((_QWORD **)a5 + 2);
      v17 = **((_QWORD **)a6 + 2);
      if ((unsigned __int16)v16 == (unsigned __int16)v17)
      {
        v19 = WORD1(v16) == WORD1(v17);
        v18 = (v17 ^ v16) & 0xFFFFFF00000000;
        v19 = v19 && v18 == 0;
        if (v19)
          goto LABEL_4;
      }
    }
    else if (re::areSameTranslatedVersion(a5, a6, a3))
    {
      goto LABEL_4;
    }
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_4:
  if (a7)
    v14 = (char *)&v20;
  else
    v14 = a4;
  return re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, v14, (uint64_t)"double", a7);
}

BOOL re::serializeCString<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char **a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  _BOOL8 result;
  int v21;
  const char *v22;
  _anonymous_namespace_ *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  const char *v28;
  int v29;

  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_23:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
      return 0;
    }
    v24 = **((_QWORD **)a5 + 2);
    v25 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v24 != (unsigned __int16)v25)
      goto LABEL_23;
    v27 = WORD1(v24) == WORD1(v25);
    v26 = (v25 ^ v24) & 0xFFFFFF00000000;
    v27 = v27 && v26 == 0;
    if (!v27)
      goto LABEL_23;
  }
LABEL_4:
  if (a7)
  {
    v29 = 0;
    v19 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer(a1 + 24, a2, (uint64_t)a3, &v29, 0);
    result = 0;
    if (!v19)
      return result;
    if (v29)
    {
      if (v29 == 1)
      {
        re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Found pointer reference instead of C string.", v14, v15, v16, v17, v18, (char)v28);
        return 0;
      }
      v28 = 0;
      if (re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, 0, (unint64_t *)&v28, 0))
      {
        if (v28)
          re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, 0, 1);
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
    }
    v23 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    v29 = 2 * (*a4 != 0);
    v21 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer(a1 + 24, a2, (uint64_t)a3, &v29, 0);
    result = 0;
    if (!v21)
      return result;
    if (v29 == 2)
    {
      v22 = *a4;
      if (*a4)
        v22 = (const char *)strlen(v22);
      v28 = v22;
      if (re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, 0, (unint64_t *)&v28, 0))
      {
        if (v28)
          re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, *a4, 0);
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
    }
    v23 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer(v23);
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeStringID<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  char *v19;
  _BOOL8 result;
  _BOOL4 v21;
  _anonymous_namespace_ *v22;
  size_t v23;

  if (a5 == a6)
    goto LABEL_14;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x134375A94D9F7110
    || (v19 = (char *)v18[1], v19 != "DynamicString") && strcmp(v19, "DynamicString"))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v23 = 0;
    v21 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v23, 0);
    result = 0;
    if (!v21)
      return result;
    if (v23)
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, 0, 1);
    v22 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    v23 = strlen(*(const char **)(a4 + 8));
    result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v23, 0);
    if (!result)
      return result;
    if (v23)
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, *(char **)(a4 + 8), 0);
    v22 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString(v22);
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeIntrospectionCallbackSerializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  _BOOL4 v14;
  _BOOL8 result;
  unint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  unint64_t v36[2];

  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_28:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, a5, a6);
      return 0;
    }
    v23 = **((_QWORD **)a5 + 2);
    v24 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v23 != (unsigned __int16)v24)
      goto LABEL_28;
    v26 = WORD1(v23) == WORD1(v24);
    v25 = (v24 ^ v23) & 0xFFFFFF00000000;
    v26 = v26 && v25 == 0;
    if (!v26)
      goto LABEL_28;
  }
LABEL_4:
  if (!a7)
  {
    v16 = **((_QWORD **)a5 + 2);
    v32 = *(_QWORD *)a5;
    v33 = v16;
    LODWORD(v34) = -1;
    v36[0] = 0x258C98EAAF29A10ALL;
    v36[1] = (unint64_t)"CallbackSerializerAttribute";
    v17 = (uint64_t *)re::TypeAttributeCollection::operator[](&v32, v36);
    re::StringID::destroyString((re::StringID *)v36);
    v18 = *v17;
    v19 = *(_QWORD *)(a1 + 184);
    v20 = *(_QWORD *)(a1 + 56);
    v34 = 0;
    v35 = 0;
    v32 = v20;
    v33 = 0;
    re::DynamicString::setCapacity(&v32, 0);
    if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(v18 + 72))(v19, v18, a4, &v32) & 1) != 0)
    {
      if ((v33 & 1) != 0)
        v21 = v33 >> 1;
      else
        v21 = v33 >> 1;
      v36[0] = v21;
      if (re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, v36, 0))
      {
        if (v36[0])
        {
          if ((v33 & 1) != 0)
            v22 = v34;
          else
            v22 = (char *)&v33 + 1;
          re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, v22, 0);
        }
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
        if (v32 && (v33 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v32 + 40))();
        return *(_BYTE *)(a1 + 64) == 0;
      }
    }
    else
    {
      re::TypeInfo::name(a5);
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Failed to write string for \"%s\" (type %s) using serialization callback.", v27, v28, v29, v30, v31, (char)a2);
    }
    if (v32 && (v33 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v32 + 40))();
    return 0;
  }
  v32 = 0;
  v14 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, (unint64_t *)&v32, 0);
  result = 0;
  if (v14)
  {
    if (v32)
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString(a1 + 24, 0, 1);
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

uint64_t re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer(uint64_t a1, const char *a2, uint64_t a3, int *a4, int a5)
{
  uint64_t result;
  int v10;
  char v11;
  _BOOL8 v12;
  __int128 v13;
  uint64_t v14;
  _BOOL8 v15;
  uint64_t v16;
  uint64_t v17;
  char v18;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  v10 = *a4;
  if (*a4 == 2)
  {
    v11 = 73;
  }
  else if (v10 == 1)
  {
    v11 = 82;
  }
  else
  {
    if (v10)
    {
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Unexpected PointerEncoding.", "!\"Unreachable code\"", "beginPointer", 410);
      result = _os_crash();
      __break(1u);
      return result;
    }
    v11 = 78;
  }
  v18 = v11;
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<unsigned char>(a1, a2, 0, &v18, (uint64_t)"uint8", 2);
  v12 = *a4 != 0;
  LOBYTE(v13) = 9;
  DWORD1(v13) = a5;
  *((_QWORD *)&v13 + 1) = a2;
  v14 = 0;
  v16 = 0;
  v17 = 0;
  v15 = v12;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v13);
  return *(_BYTE *)(a1 + 40) == 0;
}

_anonymous_namespace_ *re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer(_anonymous_namespace_ *result)
{
  uint64_t v1;
  uint64_t v2;
  _BYTE *v3;
  _anonymous_namespace_ *v4;
  char v5;
  _BYTE v6[23];
  _OWORD v7[2];

  if (!*((_BYTE *)result + 40))
  {
    v1 = (uint64_t)result;
    if (*(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 16) == *(_QWORD *)(*((_QWORD *)result + 16) + 48 * *((_QWORD *)result + 14) - 24))
    {
      result = re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(result, 9);
      v2 = *(_QWORD *)(v1 + 128) + 48 * *(_QWORD *)(v1 + 112);
      ++*(_QWORD *)(v2 - 16);
    }
    else
    {
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(result, 0, (re::DynamicString *)&v4);
      if ((v5 & 1) != 0)
        v3 = *(_BYTE **)&v6[7];
      else
        v3 = v6;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize pointer \"%s\". No value was provided.", (re::DynamicString *)v7, v3);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, (uint64_t)v7);
      if (*(_QWORD *)&v7[0])
      {
        if ((BYTE8(v7[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v7[0] + 40))();
        memset(v7, 0, sizeof(v7));
      }
      result = v4;
      if (v4)
      {
        if ((v5 & 1) != 0)
          return (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v4 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unint64_t *a2, _QWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v6 = *a2;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v7) = 0;
    goto LABEL_8;
  }
  v7 = v6 % *(unsigned int *)(a1 + 24);
  v8 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v7);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, v7, v6, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  v9 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v9 + 24 * v8 + 4) != v6)
  {
    v8 = *(_DWORD *)(v9 + 24 * v8) & 0x7FFFFFFF;
    if ((_DWORD)v8 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v10 = 3 * v8;
  *(_QWORD *)(v9 + 8 * v10 + 16) = *a3;
  ++*(_DWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 16) + 8 * v10;
  return v11 + 16;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v11;
  int v12;
  uint64_t v13;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 24 * v8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 24 * v8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  v13 = 24 * v8;
  *(_DWORD *)(v11 + v13) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v13) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 4) = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10) & 0x80000000) != 0)
          {
            re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10 + 4) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10 + 4), *(_QWORD *)&v13[16] + v10 + 4, *(_QWORD *)&v13[16] + v10 + 16);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

BOOL re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::serializeCString(_BYTE *a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *a5, const re::TypeInfo *a6)
{
  int *v12;
  int v13;
  _anonymous_namespace_ *v14;
  int v15;
  _BOOL8 result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  const char *v21;
  uint64_t v22;
  int v23;
  __int128 v24;
  int v25;
  const char *v26;

  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_15:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>((uint64_t)a1, a2, a5, a6);
      return 0;
    }
    v17 = **((_QWORD **)a5 + 2);
    v18 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v17 != (unsigned __int16)v18)
      goto LABEL_15;
    v20 = WORD1(v17) == WORD1(v18);
    v19 = (v18 ^ v17) & 0xFFFFFF00000000;
    v20 = v20 && v19 == 0;
    if (!v20)
      goto LABEL_15;
  }
LABEL_4:
  if (!*a4)
  {
    LODWORD(v26) = 0;
    v14 = (_anonymous_namespace_ *)(a1 + 24);
    v23 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer((uint64_t)(a1 + 24), a2, (uint64_t)a3, (int *)&v26, 0);
    result = 0;
    if (!v23)
      return result;
    goto LABEL_23;
  }
  if (!a1[256]
    || (v26 = *a4,
        (v12 = (int *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(a1 + 264), (uint64_t *)&v26)) == 0))
  {
    v25 = 2;
    if ((re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer((uint64_t)(a1 + 24), a2, (uint64_t)a3, &v25, 0) & 1) != 0)
    {
      v26 = (const char *)strlen(*a4);
      result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginString((_anonymous_namespace_ *)(a1 + 24), a2, 0, (unint64_t *)&v26, 0);
      if (!result)
        return result;
      if (v26)
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeString((uint64_t)(a1 + 24), (char *)*a4, 0);
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
      v21 = *a4;
      v22 = **((_QWORD **)a5 + 2);
      *(_QWORD *)&v24 = *(_QWORD *)a5;
      *((_QWORD *)&v24 + 1) = v22;
      re::internal::SharedObjectGraph::addObject((uint64_t)(a1 + 256), (uint64_t)v21, &v24);
      return a1[64] == 0;
    }
    return 0;
  }
  v13 = *v12;
  v25 = 1;
  LODWORD(v26) = v13;
  v14 = (_anonymous_namespace_ *)(a1 + 24);
  v15 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer((uint64_t)(a1 + 24), a2, (uint64_t)a3, &v25, 0);
  result = 0;
  if (!v15)
    return result;
  if (!a1[64])
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>((uint64_t)(a1 + 24), "ID", 0, (char *)&v26, (uint64_t)"Reference ID", 0);
LABEL_23:
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer(v14);
  return a1[64] == 0;
}

uint64_t re::SerializerV1<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::serializePointer(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  const re::TypeInfo *v14;
  _BOOL4 isPointerToPolymorphicType;
  int v16;
  char *v17;
  _DWORD *v18;
  _anonymous_namespace_ *v19;
  int v20;
  uint64_t result;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  BOOL v33;
  uint64_t *v34;
  uint64_t *v35;
  __int128 v36;
  int v37;
  _BYTE v38[32];
  __int128 v39;
  re::TypeRegistry *v40[4];
  _QWORD v41[4];
  char *v42;
  _BYTE v43[40];

  isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6)
    goto LABEL_4;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v30 = **((_QWORD **)this + 2);
    v31 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v30 == (unsigned __int16)v31)
    {
      v33 = WORD1(v30) == WORD1(v31);
      v32 = (v31 ^ v30) & 0xFFFFFF00000000;
      v33 = v33 && v32 == 0;
      if (v33)
        goto LABEL_4;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v14))
  {
LABEL_4:
    v16 = 0;
    goto LABEL_5;
  }
  if (*((_BYTE *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (v34 = re::TypeInfo::name(this), v35 = re::TypeInfo::name(a6), !re::StringID::operator==(v34, v35))))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>(a1, a2, this, a6);
    return 0;
  }
  v16 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v42);
  re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)v43);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v42);
  re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)v43);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    v22 = *(_QWORD *)v41[2];
    *(_QWORD *)&v39 = v41[0];
    *((_QWORD *)&v39 + 1) = v22;
    if (v41[0])
      goto LABEL_8;
    goto LABEL_16;
  }
  re::internal::actualType(a4, (void **)this, &v39);
  if (!(_QWORD)v39)
  {
LABEL_16:
    v23 = re::TypeInfo::name(this);
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Failed to get actual type of polymorphic object. Type \"%s\".", v24, v25, v26, v27, v28, v23[1]);
    return 0;
  }
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, (re **)&v39, &v42);
  re::TypeInfo::TypeInfo((uint64_t)v38, (uint64_t)v43);
  if ((a7 & 1) == 0)
  {
    v17 = *a4;
    if (*a4)
    {
      if (*(_BYTE *)(a1 + 256))
      {
        v42 = *a4;
        v18 = (_DWORD *)re::HashTable<unsigned long long,re::PeerAttributionContext *,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 264, (uint64_t *)&v42);
        if (v18)
        {
          LODWORD(v42) = *v18;
          v37 = 1;
          v19 = (_anonymous_namespace_ *)(a1 + 24);
          v20 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer(a1 + 24, a2, a3, &v37, 0);
          result = 0;
          if (v20)
          {
            if (!*(_BYTE *)(a1 + 64))
              re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<int>(a1 + 24, "ID", 0, (char *)&v42, (uint64_t)"Reference ID", 0);
            goto LABEL_18;
          }
          return result;
        }
        v17 = *a4;
      }
      v36 = v39;
      re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 256), (uint64_t)v17, &v36);
      LODWORD(v42) = 2;
      result = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer(a1 + 24, a2, a3, (int *)&v42, 0);
      if ((_DWORD)result)
      {
        if (isPointerToPolymorphicType)
        {
          re::internal::serializePolymorphicObject<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(a1, a2, a3, (uint64_t)*a4, (re::TypeInfo *)v38, v40, v16);
        }
        else if (!*(_BYTE *)(a1 + 64))
        {
          (*(void (**)(uint64_t, const char *, _QWORD, char *, _QWORD *, re::TypeRegistry **, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, 0, *a4, v41, v40, 0);
        }
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
        if (*(_BYTE *)(a1 + 256))
        {
          --*(_QWORD *)(a1 + 408);
          ++*(_DWORD *)(a1 + 416);
        }
        return *(_BYTE *)(a1 + 64) == 0;
      }
      return result;
    }
  }
  LODWORD(v42) = 0;
  v19 = (_anonymous_namespace_ *)(a1 + 24);
  v29 = re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::beginPointer(a1 + 24, a2, a3, (int *)&v42, 0);
  result = 0;
  if (v29)
  {
LABEL_18:
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer(v19);
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return result;
}

_QWORD *re::internal::SharedObjectGraph::addObject(uint64_t a1, uint64_t a2, __int128 *a3)
{
  _QWORD *result;
  __int128 v5;

  v5 = *a3;
  result = re::internal::SharedObjectGraph::beginObject((_QWORD *)a1, a2, &v5);
  if (*(_BYTE *)a1)
  {
    --*(_QWORD *)(a1 + 152);
    ++*(_DWORD *)(a1 + 160);
  }
  return result;
}

BOOL re::internal::serializePolymorphicObject<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, re::TypeRegistry **a6, int a7)
{
  re::TypeRegistry *v13;
  uint64_t *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _BYTE v29[16];
  uint64_t v30;
  _OWORD v31[3];

  re::TypeInfo::TypeInfo((uint64_t)v29, (uint64_t)a5);
  if (a7)
  {
    v13 = *a6;
    v14 = re::TypeInfo::name(a5);
    re::TypeRegistry::typeInfo(v13, (const re::StringID *)v14, v31);
    if (!LOBYTE(v31[0]))
    {
      v27 = re::TypeInfo::name(a5)[1];
      re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "No matching type found for polymorphic type \"%s\" to serialize.", v21, v22, v23, v24, v25, v27);
      return 0;
    }
    re::TypeInfo::operator=((uint64_t)v29, (uint64_t)v31 + 8);
  }
  if (!*(_BYTE *)(v30 + 120))
  {
    v26 = re::TypeInfo::name((re::TypeInfo *)v29)[1];
    re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::setError(a1, a2, "Failed to get custom class ID for type \"%s\".", v16, v17, v18, v19, v20, v26);
    return 0;
  }
  v28 = *(_QWORD *)(v30 + 128);
  if (*(_BYTE *)(a1 + 64))
    return 0;
  LOBYTE(v31[0]) = 1;
  DWORD1(v31[0]) = 0;
  *((_QWORD *)&v31[0] + 1) = a2;
  memset(&v31[1], 0, 32);
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)(a1 + 24), v31);
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::serializeValue<long long>(a1 + 24, "customClassID", 1, (char *)&v28, (uint64_t)"uint64", 0);
  if (!*(_BYTE *)(a1 + 64))
    (*(void (**)(uint64_t, const char *, uint64_t, uint64_t, re::TypeInfo *, _BYTE *, _QWORD))(*(_QWORD *)a1 + 72))(a1, "object", 10, a4, a5, v29, 0);
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
  return *(_BYTE *)(a1 + 64) == 0;
}

re::NetworkCompatDeserializer *re::NetworkCompatDeserializer::NetworkCompatDeserializer(re::NetworkCompatDeserializer *this)
{
  uint64_t v2;
  StringID v4;

  *(_QWORD *)&v4.var0 = 0xEFB8C0610360E046;
  v4.var1 = "NetworkCompatDeserializer";
  v2 = re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::SerializerV1((uint64_t)this, &v4);
  *(_QWORD *)v2 = &off_24ED2B720;
  *(_OWORD *)(v2 + 432) = 0u;
  *(_OWORD *)(v2 + 448) = 0u;
  *(_QWORD *)(v2 + 184) = v2 + 440;
  re::StringID::destroyString((re::StringID *)&v4);
  *(_QWORD *)this = &off_24ED2B660;
  return this;
}

void re::NetworkCompatDeserializer::~NetworkCompatDeserializer(re::NetworkCompatDeserializer *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24ED2B788;
  v2 = *((_QWORD *)this + 49);
  if (v2)
  {
    if (*((_QWORD *)this + 53))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 53) = 0;
    *((_QWORD *)this + 50) = 0;
    *((_QWORD *)this + 51) = 0;
    *((_QWORD *)this + 49) = 0;
    ++*((_DWORD *)this + 104);
  }
  v3 = *((_QWORD *)this + 44);
  if (v3)
  {
    if (*((_QWORD *)this + 48))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 48) = 0;
    *((_QWORD *)this + 45) = 0;
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 44) = 0;
    ++*((_DWORD *)this + 94);
  }
  v4 = *((_QWORD *)this + 39);
  if (v4)
  {
    if (*((_QWORD *)this + 43))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 40) = 0;
    *((_QWORD *)this + 41) = 0;
    *((_QWORD *)this + 39) = 0;
    ++*((_DWORD *)this + 84);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 33);
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer(this);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24ED2B788;
  v2 = *((_QWORD *)this + 49);
  if (v2)
  {
    if (*((_QWORD *)this + 53))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 53) = 0;
    *((_QWORD *)this + 50) = 0;
    *((_QWORD *)this + 51) = 0;
    *((_QWORD *)this + 49) = 0;
    ++*((_DWORD *)this + 104);
  }
  v3 = *((_QWORD *)this + 44);
  if (v3)
  {
    if (*((_QWORD *)this + 48))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *((_QWORD *)this + 48) = 0;
    *((_QWORD *)this + 45) = 0;
    *((_QWORD *)this + 46) = 0;
    *((_QWORD *)this + 44) = 0;
    ++*((_DWORD *)this + 94);
  }
  v4 = *((_QWORD *)this + 39);
  if (v4)
  {
    if (*((_QWORD *)this + 43))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 40) = 0;
    *((_QWORD *)this + 41) = 0;
    *((_QWORD *)this + 39) = 0;
    ++*((_DWORD *)this + 84);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 33);
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer(this);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::trackObject(uint64_t a1, uint64_t a2, __int128 *a3)
{
  __int128 v4;

  v4 = *a3;
  return re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 256), a2, &v4);
}

uint64_t re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::untrackObject(uint64_t result)
{
  if (*(_BYTE *)(result + 256))
  {
    --*(_QWORD *)(result + 408);
    ++*(_DWORD *)(result + 416);
  }
  return result;
}

void re::NetworkSerializerBase<re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>>::doOpen(uint64_t a1)
{
  *(_BYTE *)(a1 + 257) = 1;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 264);
  *(_QWORD *)(a1 + 328) = 0;
  ++*(_DWORD *)(a1 + 336);
  *(_QWORD *)(a1 + 368) = 0;
  ++*(_DWORD *)(a1 + 376);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
}

void re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::doClose(uint64_t a1)
{
  re::internal::SharedObjectGraph::markAndSweep((re::internal::SharedObjectGraph *)(a1 + 256), *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 264);
  *(_QWORD *)(a1 + 328) = 0;
  ++*(_DWORD *)(a1 + 336);
  *(_QWORD *)(a1 + 368) = 0;
  ++*(_DWORD *)(a1 + 376);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
}

void re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::doRegisterSerializeFuncs(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  BOOL (*v16)(uint64_t, const char *, const re::TypeInfo *, uint64_t, re::TypeInfo *, re::TypeInfo *, int);

  v11 = 6059476;
  v12 = "BOOL";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeBool<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6104748;
  v12 = "char";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeChar<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x172E117BCLL;
  v12 = "int8_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI8<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93A4A92;
  v12 = "int16_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI16<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93BFE06;
  v12 = "int32_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI32<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2CE93EC744;
  v12 = "int64_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 6655224;
  v12 = "long";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeI64<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x31CD534126;
  v12 = "uint8_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU8<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0D4E68;
  v12 = "uint16_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU16<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD0F01DCLL;
  v12 = "uint32_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU32<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x607DD11CB1ALL;
  v12 = "uint64_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x1947BDF6CLL;
  v12 = "size_t";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeU64<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 195052728;
  v12 = "float";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeFloat<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x161EEF7A2;
  v12 = "double";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDouble<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 189247272;
  v12 = "char*";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeCString<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x2686EB529B3EE220;
  v12 = "DynamicString";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeDynamicString<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v11 = 0x458DDB01A18;
  v12 = "StringID";
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(a1, &v11, (uint64_t)re::serializeStringID<re::EncoderBinary<re::FixedArrayInputStream>>);
  re::StringID::destroyString((re::StringID *)&v11);
  v2 = *(_QWORD *)(a1 + 192);
  v11 = 0x258C98EAAF29A10ALL;
  v12 = "CallbackSerializerAttribute";
  v3 = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v2 + 200, &v11);
  if (v3)
  {
    v4 = *v3;
    re::StringID::destroyString((re::StringID *)&v11);
    if (v2)
    {
      v5 = *(_QWORD *)(a1 + 192);
      v10[0] = v2;
      v10[1] = v4;
      re::TypeRegistry::attributesByAttributeType(v5, (uint64_t)v10, (uint64_t)&v11);
      if (v13)
      {
        v6 = a1 + 208;
        v7 = (uint64_t *)(v14 + 24);
        v8 = 48 * v13;
        do
        {
          v9 = *v7;
          v7 += 6;
          v16 = re::serializeIntrospectionCallbackSerializer<re::EncoderBinary<re::FixedArrayInputStream>>;
          v15 = v9 | 0xFFFFFFFF00000000;
          re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v6, &v15, &v16);
          v8 -= 48;
        }
        while (v8);
      }
      if (v11)
      {
        if (v14)
          (*(void (**)(void))(*(_QWORD *)v11 + 40))();
      }
    }
  }
  else
  {
    re::StringID::destroyString((re::StringID *)&v11);
  }
}

uint64_t re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t result;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;

  v14 = (_BYTE *)(a1 + 256);
  v15 = *(_QWORD *)(a1 + 408);
  if (!v15)
  {
    if ((_DWORD)a7)
      v16 = 0;
    else
      v16 = a4;
    v17 = **((_QWORD **)a5 + 2);
    *(_QWORD *)&v26 = *(_QWORD *)a5;
    *((_QWORD *)&v26 + 1) = v17;
    re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 256), v16, &v26);
  }
  v18 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v18)
  {
    result = v18(a1, a2, a3, a4, a5, a6, a7);
    if (!v15)
    {
      if (*v14)
      {
        --*(_QWORD *)(a1 + 408);
        ++*(_DWORD *)(a1 + 416);
      }
    }
  }
  else
  {
    v20 = re::TypeInfo::name(a5);
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v21, v22, v23, v24, v25, v20[1]);
    return 0;
  }
  return result;
}

BOOL (*re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::doResolveSerializeFunc(uint64_t a1, re::TypeInfo *this))(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, int a7)
{
  uint64_t *v4;
  uint64_t v5;
  char *v6;
  unsigned int v7;
  BOOL (*result)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, int);
  uint64_t v9;
  uint64_t v10;

  v4 = re::TypeInfo::name(this);
  if ((unint64_t)*v4 >> 1 == 94623636)
  {
    v6 = (char *)v4[1];
    if (v6 == "char*" || !strcmp(v6, "char*"))
      return (BOOL (*)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, int))re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::serializeCString;
  }
  if (*((_BYTE *)this + 12) == 9)
  {
    v7 = *(unsigned __int8 *)(*((_QWORD *)this + 2) + 80);
    if (v7 >= 2)
    {
      if (v7 == 2)
      {
        re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) External references are not supported by the SerializerV1.", "!\"Unreachable code\"", "doResolveSerializeFunc", 82);
        _os_crash();
        __break(1u);
      }
      re::internal::assertLog((re::internal *)4, v5, "assertion failure: '%s' (%s:line %i) Invalid PointerSharing type.", "!\"Unreachable code\"", "doResolveSerializeFunc", 84);
      result = (BOOL (*)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, int))_os_crash();
      __break(1u);
    }
    else
    {
      return re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::serializePointer;
    }
  }
  else if (*(_QWORD *)this == *(_QWORD *)(a1 + 192)
         && (LODWORD(v10) = **((_QWORD **)this + 2),
             HIDWORD(v10) = -1,
             (v9 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 208, &v10)) != 0))
  {
    return *(BOOL (**)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, int))v9;
  }
  else
  {
    return (BOOL (*)(uint64_t, const char *, uint64_t, char **, re::TypeInfo *, const re::TypeInfo *, int))re::serializeType<re::EncoderBinary<re::FixedArrayInputStream>>;
  }
  return result;
}

uint64_t re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::SerializerV1(uint64_t a1, const StringID *a2)
{
  *(_QWORD *)a1 = &off_24ED2B7F0;
  re::StringID::StringID((re::StringID *)(a1 + 8), a2);
  re::Encoder<re::EncoderBinary<re::FixedArrayInputStream>,re::FixedArrayInputStream>::Encoder(a1 + 24, 12);
  *(_DWORD *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_DWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 244) = 0x7FFFFFFFLL;
  *(_QWORD *)a1 = &off_24ED2B788;
  *(_WORD *)(a1 + 256) = 1;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_DWORD *)(a1 + 296) = 0;
  *(_QWORD *)(a1 + 300) = 0x7FFFFFFFLL;
  *(_QWORD *)(a1 + 320) = 0;
  *(_QWORD *)(a1 + 328) = 0;
  *(_QWORD *)(a1 + 312) = 0;
  *(_DWORD *)(a1 + 336) = 0;
  *(_QWORD *)(a1 + 424) = 0;
  *(_DWORD *)(a1 + 376) = 0;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_DWORD *)(a1 + 416) = 0;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  return a1;
}

_QWORD *re::NetworkSerializerBase<re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>>::~NetworkSerializerBase(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED2B788;
  v2 = *(_QWORD *)(a1 + 392);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  v3 = *(_QWORD *)(a1 + 352);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 384))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 384) = 0;
    *(_QWORD *)(a1 + 360) = 0;
    *(_QWORD *)(a1 + 368) = 0;
    *(_QWORD *)(a1 + 352) = 0;
    ++*(_DWORD *)(a1 + 376);
  }
  v4 = *(_QWORD *)(a1 + 312);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 344))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 344) = 0;
    *(_QWORD *)(a1 + 320) = 0;
    *(_QWORD *)(a1 + 328) = 0;
    *(_QWORD *)(a1 + 312) = 0;
    ++*(_DWORD *)(a1 + 336);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 264));
  return re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer((_QWORD *)a1);
}

void re::NetworkSerializerBase<re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>>::~NetworkSerializerBase(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED2B788;
  v2 = *(_QWORD *)(a1 + 392);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  v3 = *(_QWORD *)(a1 + 352);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 384))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 384) = 0;
    *(_QWORD *)(a1 + 360) = 0;
    *(_QWORD *)(a1 + 368) = 0;
    *(_QWORD *)(a1 + 352) = 0;
    ++*(_DWORD *)(a1 + 376);
  }
  v4 = *(_QWORD *)(a1 + 312);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 344))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 344) = 0;
    *(_QWORD *)(a1 + 320) = 0;
    *(_QWORD *)(a1 + 328) = 0;
    *(_QWORD *)(a1 + 312) = 0;
    ++*(_DWORD *)(a1 + 336);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 264));
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer((_QWORD *)a1);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED2B788;
  v2 = *(_QWORD *)(a1 + 392);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  v3 = *(_QWORD *)(a1 + 352);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 384))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 384) = 0;
    *(_QWORD *)(a1 + 360) = 0;
    *(_QWORD *)(a1 + 368) = 0;
    *(_QWORD *)(a1 + 352) = 0;
    ++*(_DWORD *)(a1 + 376);
  }
  v4 = *(_QWORD *)(a1 + 312);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 344))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 344) = 0;
    *(_QWORD *)(a1 + 320) = 0;
    *(_QWORD *)(a1 + 328) = 0;
    *(_QWORD *)(a1 + 312) = 0;
    ++*(_DWORD *)(a1 + 336);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 264));
  return re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer((_QWORD *)a1);
}

void re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::~SerializerV1(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)a1 = &off_24ED2B788;
  v2 = *(_QWORD *)(a1 + 392);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 424))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 424) = 0;
    *(_QWORD *)(a1 + 400) = 0;
    *(_QWORD *)(a1 + 408) = 0;
    *(_QWORD *)(a1 + 392) = 0;
    ++*(_DWORD *)(a1 + 416);
  }
  v3 = *(_QWORD *)(a1 + 352);
  if (v3)
  {
    if (*(_QWORD *)(a1 + 384))
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
    *(_QWORD *)(a1 + 384) = 0;
    *(_QWORD *)(a1 + 360) = 0;
    *(_QWORD *)(a1 + 368) = 0;
    *(_QWORD *)(a1 + 352) = 0;
    ++*(_DWORD *)(a1 + 376);
  }
  v4 = *(_QWORD *)(a1 + 312);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 344))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 344) = 0;
    *(_QWORD *)(a1 + 320) = 0;
    *(_QWORD *)(a1 + 328) = 0;
    *(_QWORD *)(a1 + 312) = 0;
    ++*(_DWORD *)(a1 + 336);
  }
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)(a1 + 264));
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer((_QWORD *)a1);
  JUMPOUT(0x2276933B8);
}

void re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::doOpen(uint64_t a1)
{
  *(_BYTE *)(a1 + 257) = 1;
  re::HashTable<void const*,unsigned int,re::Hash<void const*>,re::EqualTo<void const*>,true,false>::clear(a1 + 264);
  *(_QWORD *)(a1 + 328) = 0;
  ++*(_DWORD *)(a1 + 336);
  *(_QWORD *)(a1 + 368) = 0;
  ++*(_DWORD *)(a1 + 376);
  *(_QWORD *)(a1 + 408) = 0;
  ++*(_DWORD *)(a1 + 416);
}

void re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer(_QWORD *a1)
{
  re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::doSerialize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, re::TypeInfo *a5, uint64_t a6, uint64_t a7)
{
  uint64_t (*v14)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t);
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, re::TypeInfo *, uint64_t, uint64_t))(*(uint64_t (**)(uint64_t, re::TypeInfo *))(*(_QWORD *)a1 + 80))(a1, a5);
  if (v14)
    return v14(a1, a2, a3, a4, a5, a6, a7);
  v16 = re::TypeInfo::name(a5);
  re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v17, v18, v19, v20, v21, v16[1]);
  return 0;
}

uint64_t (*re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::doResolveSerializeFunc(uint64_t a1, uint64_t a2))(re::Allocator **a1, const char *a2, const re::TypeInfo *a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v3;
  uint64_t v4;

  if (*(_QWORD *)a2 == *(_QWORD *)(a1 + 192)
    && (LODWORD(v4) = **(_QWORD **)(a2 + 16),
        HIDWORD(v4) = -1,
        (v3 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::tryGet(a1 + 208, &v4)) != 0))
  {
    return *(uint64_t (**)(re::Allocator **, const char *, const re::TypeInfo *, void *, re::TypeInfo *, uint64_t, uint64_t, uint64_t))v3;
  }
  else
  {
    return re::serializeType<re::EncoderBinary<re::FixedArrayInputStream>>;
  }
}

uint64_t re::Encoder<re::EncoderBinary<re::FixedArrayInputStream>,re::FixedArrayInputStream>::Encoder(uint64_t result, int a2)
{
  __objc2_class_ro **p_info;
  unsigned __int8 v3;
  __objc2_class_ro *v4;
  int v5;
  const char *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE v10[4];
  int v11;

  *(_QWORD *)(result + 128) = 0;
  *(_QWORD *)(result + 104) = 0;
  *(_QWORD *)(result + 112) = 0;
  *(_QWORD *)(result + 96) = 0;
  *(_DWORD *)(result + 120) = 0;
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_BYTE *)(result + 40) = 0;
  *(_DWORD *)(result + 136) = a2;
  *(_BYTE *)(result + 140) = 0;
  *(_QWORD *)(result + 152) = 1024;
  p_info = VideoSpillMapMetalSession.info;
  if ((v3 & 1) == 0)
  {
    v9 = result;
    p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    v7 = v5;
    result = v9;
    if (v7)
    {
      re::Defaults::intValue((re::Defaults *)"maxSerializationDepth", v6, (uint64_t)v10);
      v8 = v11;
      if (!v10[0])
        v8 = 0;
      re::Encoder<re::EncoderBinary<re::FixedArrayInputStream>,re::FixedArrayInputStream>::Encoder(int)::s_maxSerializationDepth = v8;
      p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
      result = v9;
    }
  }
  v4 = p_info[496];
  if (v4)
    *(_QWORD *)(result + 152) = v4;
  return result;
}

_QWORD *re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::~Serializer(_QWORD *a1)
{
  *a1 = &off_24ED2B7F0;
  if (a1[24])
  {
    re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 26));
    a1[24] = 0;
  }
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit(a1 + 26);
  re::Encoder<re::EncoderBinary<re::FixedArrayInputStream>,re::FixedArrayInputStream>::~Encoder((uint64_t)(a1 + 3));
  re::StringID::destroyString((re::StringID *)(a1 + 1));
  return a1;
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_402, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 24 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16);
        v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
        v4 += 24;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

uint64_t re::Encoder<re::EncoderBinary<re::FixedArrayInputStream>,re::FixedArrayInputStream>::~Encoder(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  re::Encoder<re::EncoderBinary<re::FixedArrayInputStream>,re::FixedArrayInputStream>::close(a1);
  v2 = *(_QWORD *)(a1 + 96);
  if (v2)
  {
    if (*(_QWORD *)(a1 + 128))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 96) = 0;
    ++*(_DWORD *)(a1 + 120);
  }
  if (*(_BYTE *)(a1 + 40))
  {
    v3 = *(_QWORD *)(a1 + 64);
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 72) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 80));
      *(_OWORD *)(a1 + 64) = 0u;
      *(_OWORD *)(a1 + 80) = 0u;
    }
  }
  return a1;
}

uint64_t re::Encoder<re::EncoderBinary<re::FixedArrayInputStream>,re::FixedArrayInputStream>::close(uint64_t result)
{
  _anonymous_namespace_ *v1;

  if (*(_QWORD *)result)
  {
    v1 = (_anonymous_namespace_ *)result;
    re::EncoderBinary<re::FixedArrayInputStream>::doClose(result);
    if (!*((_BYTE *)v1 + 40))
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::popState(v1, 0);
    result = *((_QWORD *)v1 + 12);
    if (result)
    {
      if (*((_QWORD *)v1 + 16))
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
      *((_QWORD *)v1 + 16) = 0;
      *((_QWORD *)v1 + 13) = 0;
      *((_QWORD *)v1 + 14) = 0;
      *((_QWORD *)v1 + 12) = 0;
      ++*((_DWORD *)v1 + 30);
    }
    if (*((int *)v1 + 4) >= 1)
    {
      result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)v1 + 24))(*(_QWORD *)v1);
      *((_QWORD *)v1 + 1) = 0;
      *((_DWORD *)v1 + 4) = 0;
    }
    *(_QWORD *)v1 = 0;
    *((_QWORD *)v1 + 3) = 0;
    *((_QWORD *)v1 + 4) = 0;
  }
  return result;
}

uint64_t re::EncoderBinary<re::FixedArrayInputStream>::doClose(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  char v9;

  if (!*(_BYTE *)(result + 40))
  {
    v1 = result;
    v9 = 69;
    result = re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(result, "End-of-file", 0, &v9, (uint64_t)"uint8", 0);
    if (v9 != 69)
    {
      re::DynamicString::format((re::DynamicString *)"Failed to read end-of-file marker.", (re::DynamicString *)&v2);
      *(_QWORD *)&v5 = 400;
      *((_QWORD *)&v5 + 1) = &re::FoundationErrorCategory(void)::instance;
      v6 = v2;
      v8 = v4;
      v7 = v3;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError(v1, &v5);
      result = v6;
      if (v6)
      {
        if ((v7 & 1) != 0)
          return (*(uint64_t (**)(void))(*(_QWORD *)v6 + 40))();
      }
    }
  }
  return result;
}

uint64_t re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  uint64_t v11;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if ((a6 & 1) != 0)
    a4 = 0;
  if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, a4, 1uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    v11 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v11 - 16);
  }
  return 1;
}

uint64_t re::serializeType<re::EncoderBinary<re::FixedArrayInputStream>>(re::Allocator **a1, const char *a2, const re::TypeInfo *a3, void *a4, re::TypeInfo *this, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t result;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void **Instance;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _BYTE *v51;
  uint64_t v52;
  uint64_t *v53[4];
  _BYTE v54[24];
  uint64_t v55;
  char v56;
  _BYTE v57[23];
  unsigned __int8 v58[8];
  _BYTE v59[32];

  if (this != (re::TypeInfo *)a6)
  {
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v15 = **((_QWORD **)this + 2);
      v16 = **(_QWORD **)(a6 + 16);
      if ((unsigned __int16)v15 == (unsigned __int16)v16)
      {
        v18 = WORD1(v15) == WORD1(v16);
        v17 = (v16 ^ v15) & 0xFFFFFF00000000;
        v18 = v18 && v17 == 0;
        if (v18)
          goto LABEL_19;
      }
    }
    else if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, a3))
    {
      goto LABEL_19;
    }
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      v19 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
      if (v19)
        v20 = *(_DWORD *)(v19 + 16);
      else
        v20 = -1;
      v21 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
      if (v21)
        v22 = *(_DWORD *)(v21 + 16);
      else
        v22 = -1;
      if (v20 == v22)
        goto LABEL_19;
      v24 = re::TypeInfo::name(this);
      v25 = re::TypeInfo::name((re::TypeInfo *)a6);
      if (re::StringID::operator==(v24, v25))
      {
        v26 = re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
        if (v26)
          v27 = *(_DWORD *)(v26 + 16);
        else
          v27 = -1;
        re::TypeInfo::atVersion(this, v27, v58);
        if (v58[0])
        {
          if ((a7 & 1) != 0)
            Instance = 0;
          else
            Instance = re::TypeInfo::createInstance((re::TypeInfo *)v59, a1[6], a1[23]);
          if (*((_BYTE *)a1 + 64)
            || ((*((void (**)(re::Allocator **, const char *, const re::TypeInfo *, void **, _BYTE *, uint64_t, uint64_t))*a1
                 + 9))(a1, a2, a3, Instance, v59, a6, a7), *((_BYTE *)a1 + 64)))
          {
            if (Instance)
              re::TypeInfo::releaseInstance((re::TypeInfo *)v59, Instance, a1[6], a1[23]);
          }
          else
          {
            if ((a7 & 1) != 0)
              return 1;
            re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v59);
            re::internal::upgradeObject(Instance, v53, a4, (uint64_t **)this, a1[6], a1[23], v54);
            if (v54[0])
              return 1;
            if ((v56 & 1) != 0)
              LOBYTE(v51) = v57[7];
            else
              v51 = v57;
            re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, a2, "%s", v46, v47, v48, v49, v50, (char)v51);
            if (!v54[0] && v55 && (v56 & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v55 + 40))();
          }
        }
        else
        {
          v35 = re::TypeInfo::name((re::TypeInfo *)a6)[1];
          re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, a2, "Unknown serialized type \"%s\" version %u. No matching runtime type found.", v41, v42, v43, v44, v45, v35);
        }
      }
      else
      {
        v33 = re::TypeInfo::name((re::TypeInfo *)a6)[1];
        re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)a6 + 96, **(_QWORD **)(a6 + 16));
        re::TypeInfo::name(this);
        re::DataArray<re::TextureAtlasTile>::tryGet(*(_QWORD *)this + 96, **((_QWORD **)this + 2));
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, a2, "Type name changed: Serialized type \"%s\" version %u, runtime type \"%s\" version %u.", v36, v37, v38, v39, v40, v33);
      }
    }
    else
    {
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, this, (re::TypeInfo *)a6);
    }
    return 0;
  }
LABEL_19:
  switch(*((_BYTE *)this + 12))
  {
    case 1:
      result = re::serializeBasic<re::EncoderBinary<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, (char *)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 2:
      result = re::serializeEnum<re::EncoderBinary<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, a4, (uint64_t)this, a6, a7);
      break;
    case 3:
      result = re::serializeOptional<re::EncoderBinary<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 4:
      result = re::serializeArray<re::EncoderBinary<re::FixedArrayInputStream>>(a1, a2, a3, (char *)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 5:
      result = re::serializeList<re::EncoderBinary<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 6:
      result = re::serializeDictionary<re::EncoderBinary<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, (uint64_t)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 7:
      result = re::serializeUnion<re::EncoderBinary<re::FixedArrayInputStream>>((uint64_t)a1, a2, a3, (char *)a4, this, (const re::TypeInfo *)a6, a7);
      break;
    case 8:
      result = re::serializeObject<re::EncoderBinary<re::FixedArrayInputStream>>((uint64_t)a1, a2, (uint64_t)a3, (uint64_t)a4, this, a6, a7);
      break;
    case 9:
      v52 = re::TypeInfo::name(this)[1];
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, a2, "Pointer type (\"%s\") needs to be handled explicitly by the serializer.", v28, v29, v30, v31, v32, v52);
      return 0;
    default:
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, a2, "Invalid type category. Value = %d", (uint64_t)a4, (uint64_t)this, a6, a7, a8, *((_BYTE *)this + 12));
      return 0;
  }
  return result;
}

uint64_t re::serializeBasic<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re::TypeInfo *this, const re::TypeInfo *a6, char a7)
{
  uint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  uint64_t v21;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  if (this != a6)
  {
    if (*(_QWORD *)this != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(this, a6, a3))
        goto LABEL_4;
LABEL_19:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, this, a6);
      return 0;
    }
    v17 = **((_QWORD **)this + 2);
    v18 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v17 != (unsigned __int16)v18)
      goto LABEL_19;
    v20 = WORD1(v17) == WORD1(v18);
    v19 = (v18 ^ v17) & 0xFFFFFF00000000;
    v20 = v20 && v19 == 0;
    if (!v20)
      goto LABEL_19;
  }
LABEL_4:
  v14 = re::TypeInfo::name(this);
  v15 = (unint64_t)*v14 >> 1;
  if (v15 > 0xCA3DEFB5)
  {
    if ((unint64_t)*v14 >> 1 > 0x18E6A9A092)
    {
      if ((unint64_t)*v14 >> 1 <= 0x303EE8780EDLL)
      {
        if (v15 != 0x18E6A9A093)
        {
          if (v15 == 0x303EE86A734)
            return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint16", a7);
          goto LABEL_48;
        }
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint8", a7);
      }
      if (v15 == 0x303EE8780EELL)
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint32", a7);
      if (v15 != 0x303EE88E58DLL)
        goto LABEL_48;
    }
    else
    {
      if ((unint64_t)*v14 >> 1 > 0x16749DFF02)
      {
        if (v15 == 0x16749DFF03)
          return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int32", a7);
        v21 = 0x16749F63A2;
        goto LABEL_34;
      }
      if (v15 != 3393056694)
      {
        v16 = 0x16749D2549;
        goto LABEL_24;
      }
    }
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint64", a7);
  }
  if ((unint64_t)*v14 >> 1 > 0x5D0225B)
  {
    if ((unint64_t)*v14 >> 1 > 0xB0F77BD0)
    {
      if (v15 != 2969009105)
      {
        if (v15 == 3111160798)
          return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int8", a7);
LABEL_48:
        v23 = re::TypeInfo::name(this);
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Unsupported basic type \"%s\".", v24, v25, v26, v27, v28, v23[1]);
        return 0;
      }
      return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"double", a7);
    }
    if (v15 == 97526364)
      return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"float", a7);
    v16 = 109413500;
LABEL_24:
    if (v15 == v16)
      return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int16", a7);
    goto LABEL_48;
  }
  if ((unint64_t)*v14 >> 1 <= 0x2E9355)
  {
    if (v15 != 104431)
    {
      if (v15 == 3029738)
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"BOOL", a7);
      goto LABEL_48;
    }
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int32", a7);
  }
  if (v15 != 3052374)
  {
    v21 = 3327612;
LABEL_34:
    if (v15 == v21)
      return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int64", a7);
    goto LABEL_48;
  }
  return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"char", a7);
}

uint64_t re::serializeEnum<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  uint64_t *v19;

  if (a5 == a6)
    return re::internal::serializeEnumAsBinary<re::EncoderBinary<re::FixedArrayInputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::internal *)a6, a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **(_QWORD **)(a5 + 16);
    v15 = **(_QWORD **)(a6 + 16);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        return re::internal::serializeEnumAsBinary<re::EncoderBinary<re::FixedArrayInputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::internal *)a6, a7);
    }
  }
  else if (re::areSameTranslatedVersion((re *)a5, (const re::TypeInfo *)a6, a3))
  {
    return re::internal::serializeEnumAsBinary<re::EncoderBinary<re::FixedArrayInputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::internal *)a6, a7);
  }
  if (*(unsigned __int8 *)(a5 + 12) == *(unsigned __int8 *)(a6 + 12))
  {
    v18 = re::TypeInfo::name((re::TypeInfo *)a5);
    v19 = re::TypeInfo::name((re::TypeInfo *)a6);
    if (re::StringID::operator==(v18, v19))
      return re::internal::serializeEnumAsBinary<re::EncoderBinary<re::FixedArrayInputStream>>(a1, a2, a3, a4, (re::internal *)a5, (re::internal *)a6, a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, (re::TypeInfo *)a5, (re::TypeInfo *)a6);
  return 0;
}

BOOL re::serializeOptional<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  re::internal *v18;
  _anonymous_namespace_ *v19;
  double v20;
  void **Instance;
  uint64_t v23;
  BOOL v24;
  char v25[32];
  _BYTE v26[32];
  _BYTE v27[8];
  uint64_t v28;
  uint64_t v29;

  if (a5 == a6)
    goto LABEL_11;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_11;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (a7)
  {
    v25[0] = 0;
    re::EncoderBinary<re::FixedArrayInputStream>::beginOptional(a1 + 24, a2, (uint64_t)a3, v25, 0);
    if (v25[0])
    {
      v18 = *(re::internal **)(a1 + 192);
      re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), v27);
      re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)&v28);
      re::internal::translateType(v18, (const re::TypeRegistry *)v26, (uint64_t)v27);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, 0, 0, v27, v27, 1);
    }
    v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  else
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), v27);
    re::TypeInfo::TypeInfo((uint64_t)v26, (uint64_t)&v28);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), v27);
    re::TypeInfo::TypeInfo((uint64_t)v25, (uint64_t)&v28);
    re::TypeInfo::TypeInfo((uint64_t)v27, (uint64_t)a5);
    v24 = (*(uint64_t (**)(uint64_t))(v29 + 80))(a4) != 0;
    v20 = re::EncoderBinary<re::FixedArrayInputStream>::beginOptional(a1 + 24, a2, (uint64_t)a3, (char *)&v24, 0);
    if (v24)
    {
      Instance = re::TypeInfo::createInstance((re::TypeInfo *)v26, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
      (*(void (**)(uint64_t, void **))(v29 + 88))(a4, Instance);
      re::TypeInfo::releaseInstance((re::TypeInfo *)v26, Instance, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
    }
    else
    {
      (*(void (**)(uint64_t, _QWORD, double))(v29 + 88))(a4, 0, v20);
    }
    if (v24)
    {
      v23 = (*(uint64_t (**)(uint64_t))(v29 + 80))(a4);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, char *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, 0, v23, v26, v25, 0);
    }
    v19 = (_anonymous_namespace_ *)(a1 + 24);
  }
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endOptional(v19);
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeArray<re::EncoderBinary<re::FixedArrayInputStream>>(re::Allocator **a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char v14;
  re::internal *v15;
  uint64_t v16;
  void (*v17)(re::Allocator **, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t);
  _QWORD *v18;
  int v19;
  unint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;
  _QWORD *v27;
  int v28;
  uint64_t v29;
  void (*v30)(re::Allocator **, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  uint64_t v31;
  int v32;
  int v33;
  _BOOL8 result;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const re::TypeInfo *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  re::TypeInfo *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  BOOL v53;
  char v54;
  unint64_t v55;
  _anonymous_namespace_ *v56;
  BOOL v57;
  char v58;
  uint64_t v59;
  char v60;
  char *v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD v65[2];
  unint64_t v66;
  _QWORD *v67[2];
  uint64_t v68;
  _BYTE v69[32];
  _QWORD v70[2];
  _BYTE v71[16];
  uint64_t v72;
  _BYTE v73[16];
  uint64_t v74;
  unint64_t v75;
  _BYTE v76[32];

  if (a5 == a6)
    goto LABEL_4;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v22 = **((_QWORD **)a5 + 2);
    v23 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v22 != (unsigned __int16)v23)
      goto LABEL_13;
    v25 = WORD1(v22) == WORD1(v23);
    v24 = (v23 ^ v22) & 0xFFFFFF00000000;
    v25 = v25 && v24 == 0;
    if (!v25)
      goto LABEL_13;
LABEL_4:
    v14 = 1;
    if (a7)
      goto LABEL_5;
LABEL_17:
    re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &v75);
    re::TypeInfo::TypeInfo((uint64_t)v71, (uint64_t)v76);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v75);
    re::TypeInfo::TypeInfo((uint64_t)v69, (uint64_t)v76);
    re::TypeInfo::TypeInfo((uint64_t)v67, (uint64_t)a5);
    v29 = (*((uint64_t (**)(re::Allocator **, _BYTE *))*a1 + 10))(a1, v71);
    if (!v29)
    {
      v46 = (re::TypeInfo *)v71;
      goto LABEL_28;
    }
    v30 = (void (*)(re::Allocator **, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v29;
    v31 = re::ArrayAccessor::size((re::ArrayAccessor *)v67, a4);
    v66 = v31;
    v32 = *(_DWORD *)(*((_QWORD *)a5 + 2) + 84) & 0xFFFFFF;
    if (v32)
      v33 = 8;
    else
      v33 = 4;
    result = re::EncoderBinary<re::FixedArrayInputStream>::beginArray((uint64_t)(a1 + 3), a2, (uint64_t)a3, (char *)&v66, v33);
    if (!result)
      return result;
    v40 = (const re::TypeInfo *)v66;
    if (v31 != v66)
    {
      if ((*(_DWORD *)(v68 + 84) & 0xFFFFFF) == 0)
      {
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, 0, "Invalid array size. Expected size = %zu, actual size = %zu", v35, v36, v37, v38, v39, v31);
        return 0;
      }
      re::TypeRegistry::typeInfo(v67[0], *(_QWORD *)(v68 + 72), &v75);
      re::TypeInfo::TypeInfo((uint64_t)v73, (uint64_t)v76);
      if (!is_mul_ok(*(unsigned int *)(v74 + 8), (unint64_t)v40))
      {
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, 0, "Size overflow during deserialization. Element size = %zu, count = %zu", v41, v42, v43, v44, v45, *(_DWORD *)(v74 + 8));
        return 0;
      }
      re::ArrayAccessor::reset((re::ArrayAccessor *)v67, (void **)a4, a1[6], v40);
      v31 = v66;
    }
    if (v32)
      v57 = v31 == 0;
    else
      v57 = 1;
    v58 = v57;
    if (!v57)
    {
      v59 = *(_QWORD *)a4;
      v65[0] = 0;
      v65[1] = 0xFFFFFFFFLL;
      (*((void (**)(re::Allocator **, uint64_t, _QWORD *))*a1 + 2))(a1, v59, v65);
      v31 = v66;
    }
    if (v71[12] == 1)
      v60 = v14;
    else
      v60 = 0;
    if ((v60 & 1) != 0)
    {
      if (v31)
      {
        v61 = (char *)re::ArrayAccessor::elementAt((re::ArrayAccessor *)v67, a4, 0);
        re::EncoderBinary<re::FixedArrayInputStream>::serializeArray((uint64_t)(a1 + 3), v61, *(unsigned int *)(v72 + 8), v66, 0);
      }
    }
    else if (v31)
    {
      v62 = 0;
      do
      {
        v63 = re::ArrayAccessor::elementAt((re::ArrayAccessor *)v67, a4, v62);
        v30(a1, 0, 0, v63, v71, v69, 0);
        ++v62;
      }
      while (v62 < v66);
    }
    if ((v58 & 1) == 0)
      (*((void (**)(re::Allocator **))*a1 + 3))(a1);
    v56 = (_anonymous_namespace_ *)(a1 + 3);
    goto LABEL_75;
  }
  if (re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_4;
LABEL_13:
  if (*((_BYTE *)a6 + 12) != 4)
    goto LABEL_45;
  v26 = *((_QWORD *)a5 + 2);
  v27 = (_QWORD *)*((_QWORD *)a6 + 2);
  v28 = *((_DWORD *)v27 + 21) & 0xFFFFFF;
  if ((*(_DWORD *)(v26 + 84) & 0xFFFFFF) != 0)
  {
    if (v28)
      goto LABEL_16;
LABEL_45:
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>((uint64_t)a1, a2, a5, a6);
    return 0;
  }
  if (v28 || *(_DWORD *)(v26 + 88) != *((_DWORD *)v27 + 22))
    goto LABEL_45;
LABEL_16:
  v14 = 0;
  if (!a7)
    goto LABEL_17;
LABEL_5:
  v15 = a1[24];
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v75);
  re::TypeInfo::TypeInfo((uint64_t)v71, (uint64_t)v76);
  re::internal::translateType(v15, (const re::TypeRegistry *)v71, (uint64_t)v73);
  v16 = (*((uint64_t (**)(re::Allocator **, _BYTE *))*a1 + 10))(a1, v73);
  if (!v16)
  {
    v46 = (re::TypeInfo *)v73;
LABEL_28:
    v64 = re::TypeInfo::name(v46)[1];
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError((uint64_t)a1, 0, "Failed to resolve serialize function for type \"%s\"", v47, v48, v49, v50, v51, v64);
    return 0;
  }
  v17 = (void (*)(re::Allocator **, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))v16;
  v18 = (_QWORD *)*((_QWORD *)a6 + 2);
  v19 = *((_DWORD *)v18 + 21) & 0xFFFFFF;
  if (v19)
  {
    v20 = 0;
    v21 = 8;
  }
  else
  {
    v20 = *((int *)v18 + 22);
    v21 = 4;
  }
  v75 = v20;
  result = re::EncoderBinary<re::FixedArrayInputStream>::beginArray((uint64_t)(a1 + 3), a2, (uint64_t)a3, (char *)&v75, v21);
  if (result)
  {
    v52 = v75;
    if (v19)
      v53 = v75 == 0;
    else
      v53 = 1;
    v54 = v53;
    if (!v53)
    {
      v70[0] = 0;
      v70[1] = 0xFFFFFFFFLL;
      (*((void (**)(re::Allocator **, _QWORD, _QWORD *))*a1 + 2))(a1, 0, v70);
      v52 = v75;
    }
    if (v73[12] == 1)
    {
      if (v52)
        re::EncoderBinary<re::FixedArrayInputStream>::serializeArray((uint64_t)(a1 + 3), 0, *(unsigned int *)(v74 + 8), v52, 1);
    }
    else if (v52)
    {
      v55 = 0;
      do
      {
        v17(a1, 0, 0, 0, v73, v73, 1);
        ++v55;
      }
      while (v55 < v75);
    }
    if ((v54 & 1) == 0)
      (*((void (**)(re::Allocator **))*a1 + 3))(a1);
    v56 = (_anonymous_namespace_ *)(a1 + 3);
LABEL_75:
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endArray(v56);
    return *((_BYTE *)a1 + 64) == 0;
  }
  return result;
}

BOOL re::serializeList<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  char v14;
  re::internal *v15;
  uint64_t v16;
  void (*v17)(uint64_t, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t);
  _BOOL4 v18;
  _BOOL8 result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  uint64_t v24;
  void (*v25)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  uint64_t v26;
  _BOOL4 v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  re::TypeInfo *v35;
  unint64_t i;
  _anonymous_namespace_ *v37;
  uint64_t v38;
  void (*v39)(uint64_t, unint64_t *, uint64_t, unint64_t);
  uint64_t (*v40)(uint64_t, _QWORD);
  char v41;
  unint64_t v42;
  char *v43;
  uint64_t (*v44)(uint64_t, _QWORD);
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  re::TypeInfo *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  _QWORD *v59[2];
  uint64_t v60;
  _BYTE v61[32];
  _BYTE v62[16];
  uint64_t v63;
  _BYTE v64[16];
  uint64_t v65;
  unint64_t v66;
  _BYTE v67[40];

  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_15:
      if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
      {
        re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
        return 0;
      }
      v14 = 0;
      if (a7)
        goto LABEL_5;
      goto LABEL_17;
    }
    v20 = **((_QWORD **)a5 + 2);
    v21 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v20 != (unsigned __int16)v21)
      goto LABEL_15;
    v23 = WORD1(v20) == WORD1(v21);
    v22 = (v21 ^ v20) & 0xFFFFFF00000000;
    v23 = v23 && v22 == 0;
    if (!v23)
      goto LABEL_15;
  }
LABEL_4:
  v14 = 1;
  if (a7)
  {
LABEL_5:
    v15 = *(re::internal **)(a1 + 192);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v66);
    re::TypeInfo::TypeInfo((uint64_t)v62, (uint64_t)v67);
    re::internal::translateType(v15, (const re::TypeRegistry *)v62, (uint64_t)v64);
    v16 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v64);
    if (v16)
    {
      v17 = (void (*)(uint64_t, _QWORD, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))v16;
      v66 = 0;
      v18 = re::EncoderBinary<re::FixedArrayInputStream>::beginArray(a1 + 24, a2, (uint64_t)a3, (char *)&v66, 0);
      result = 0;
      if (!v18)
        return result;
      if (v64[12] == 1)
      {
        if (v66)
          re::EncoderBinary<re::FixedArrayInputStream>::serializeArray(a1 + 24, 0, *(unsigned int *)(v65 + 8), v66, 1);
      }
      else if (v66)
      {
        for (i = 0; i < v66; ++i)
          v17(a1, 0, 0, 0, v64, v64, 1);
      }
      v37 = (_anonymous_namespace_ *)(a1 + 24);
      goto LABEL_54;
    }
    v35 = (re::TypeInfo *)v64;
    goto LABEL_25;
  }
LABEL_17:
  re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &v66);
  re::TypeInfo::TypeInfo((uint64_t)v62, (uint64_t)v67);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v66);
  re::TypeInfo::TypeInfo((uint64_t)v61, (uint64_t)v67);
  re::TypeInfo::TypeInfo((uint64_t)v59, (uint64_t)a5);
  v24 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v62);
  if (!v24)
  {
    v35 = (re::TypeInfo *)v62;
LABEL_25:
    v56 = re::TypeInfo::name(v35)[1];
    v34 = "Failed to resolve serialize function for type \"%s\"";
    goto LABEL_26;
  }
  v25 = (void (*)(uint64_t, _QWORD, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v24;
  v26 = (*(uint64_t (**)(uint64_t))(v60 + 80))(a4);
  v58 = v26;
  v27 = re::EncoderBinary<re::FixedArrayInputStream>::beginArray(a1 + 24, a2, (uint64_t)a3, (char *)&v58, 0);
  result = 0;
  if (!v27)
    return result;
  v28 = v58;
  if (v26 != v58)
  {
    re::TypeRegistry::typeInfo(v59[0], *(_QWORD *)(v60 + 72), &v66);
    re::TypeInfo::TypeInfo((uint64_t)v64, (uint64_t)v67);
    if (!is_mul_ok(*(unsigned int *)(v65 + 8), v28))
    {
      LODWORD(v56) = *(_DWORD *)(v65 + 8);
      v34 = "Size overflow during deserialization. Element size = %zu, count = %zu";
LABEL_26:
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, v34, v29, v30, v31, v32, v33, v56);
      return 0;
    }
    v38 = *(_QWORD *)(a1 + 48);
    v39 = *(void (**)(uint64_t, unint64_t *, uint64_t, unint64_t))(v60 + 88);
    re::TypeInfo::TypeInfo((uint64_t)&v66, (uint64_t)v59);
    v39(a4, &v66, v38, v28);
  }
  v40 = *(uint64_t (**)(uint64_t, _QWORD))(v60 + 96);
  if (v40)
  {
    if (*((_BYTE *)a5 + 12) == 5)
      v41 = v14;
    else
      v41 = 0;
    if ((v41 & 1) != 0)
    {
      v42 = v58;
      if ((*(_BYTE *)(*((_QWORD *)a5 + 2) + 48) & 8) != 0 && v62[12] == 1)
      {
        if (v58)
        {
          v43 = (char *)v40(a4, 0);
          re::EncoderBinary<re::FixedArrayInputStream>::serializeArray(a1 + 24, v43, *(unsigned int *)(v63 + 8), v58, 0);
        }
        goto LABEL_53;
      }
    }
    else
    {
      v42 = v58;
    }
    if (v42)
    {
      v48 = 0;
      do
      {
        v49 = (*(uint64_t (**)(uint64_t, unint64_t))(v60 + 96))(a4, v48);
        v25(a1, 0, 0, v49, v62, v61, 0);
        ++v48;
      }
      while (v48 < v58);
    }
    goto LABEL_53;
  }
  v44 = *(uint64_t (**)(uint64_t, _QWORD))(v60 + 104);
  if (!v44 || !*(_QWORD *)(v60 + 112) || !*(_QWORD *)(v60 + 120))
  {
    v50 = (re::TypeInfo *)re::TypeInfo::TypeInfo((uint64_t)&v66, (uint64_t)v59);
    v57 = re::TypeInfo::name(v50)[1];
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "List type \"%s\" does not provide an indexer or iterator.", v51, v52, v53, v54, v55, v57);
    return 0;
  }
  v45 = v44(a4, *(_QWORD *)(a1 + 56));
  v46 = (*(uint64_t (**)(void))(v60 + 112))();
  if (v46)
  {
    v47 = v46;
    do
    {
      v25(a1, 0, 0, v47, v62, v61, 0);
      v47 = (*(uint64_t (**)(uint64_t))(v60 + 112))(v45);
    }
    while (v47);
  }
  (*(void (**)(uint64_t, _QWORD))(v60 + 120))(v45, *(_QWORD *)(a1 + 56));
LABEL_53:
  v37 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_54:
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endArray(v37);
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::serializeDictionary<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  re::internal *v18;
  re::internal *v19;
  uint64_t v20;
  void (*v21)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t, double);
  uint64_t v22;
  void (*v23)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t);
  _anonymous_namespace_ *v24;
  _BOOL4 v25;
  _BOOL8 result;
  unint64_t i;
  double v28;
  uint64_t v29;
  void (*v30)(uint64_t, const char *, _QWORD, void **, _BYTE *, _BYTE *, _QWORD, double);
  uint64_t v31;
  void (*v32)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD);
  _BOOL4 v33;
  uint64_t v34;
  void (*v35)(uint64_t, unint64_t *, uint64_t);
  void **Instance;
  uint64_t v37;
  double v38;
  re::Allocator *v39;
  uint64_t v40;
  re::TypeInfo *v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  _BYTE v49[16];
  uint64_t v50;
  _BYTE v51[32];
  _BYTE v52[32];
  _BYTE v53[32];
  _BYTE v54[32];
  unint64_t v55;
  _BYTE v56[32];

  if (a5 == a6)
    goto LABEL_11;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_11;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_11;
  }
  if (*((unsigned __int8 *)a5 + 12) != *((unsigned __int8 *)a6 + 12))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_11:
  if (!a7)
  {
    re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v54, (uint64_t)v56);
    re::TypeRegistry::typeInfo(*(_QWORD **)a5, *(_QWORD *)(*((_QWORD *)a5 + 2) + 80), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v56);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v55);
    re::TypeInfo::TypeInfo((uint64_t)v51, (uint64_t)v56);
    re::TypeInfo::TypeInfo((uint64_t)v49, (uint64_t)a5);
    v29 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v54);
    if (v29)
    {
      v30 = (void (*)(uint64_t, const char *, _QWORD, void **, _BYTE *, _BYTE *, _QWORD, double))v29;
      v31 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v53);
      if (v31)
      {
        v32 = (void (*)(uint64_t, const char *, _QWORD, uint64_t, _BYTE *, _BYTE *, _QWORD))v31;
        v48 = (*(uint64_t (**)(uint64_t))(v50 + 88))(a4);
        v24 = (_anonymous_namespace_ *)(a1 + 24);
        v33 = re::EncoderBinary<re::FixedArrayInputStream>::beginDictionary(a1 + 24, a2, (uint64_t)a3, (char *)&v48, 0);
        result = 0;
        if (!v33)
          return result;
        v34 = *(_QWORD *)(a1 + 48);
        v35 = *(void (**)(uint64_t, unint64_t *, uint64_t))(v50 + 96);
        re::TypeInfo::TypeInfo((uint64_t)&v55, (uint64_t)v49);
        v35(a4, &v55, v34);
        if (v48)
        {
          Instance = re::TypeInfo::createInstance((re::TypeInfo *)v54, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
          if (v48)
          {
            v37 = 0;
            while (1)
            {
              v38 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 0);
              v30(a1, "key", 0, Instance, v54, v52, 0, v38);
              v39 = *(re::Allocator **)(a1 + 48);
              if (*(_BYTE *)(a1 + 64))
                break;
              v40 = (*(uint64_t (**)(uint64_t, _BYTE *, re::Allocator *, void **))(v50 + 104))(a4, v49, v39, Instance);
              v32(a1, "value", 0, v40, v53, v51, 0);
              re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
              if (++v37 >= v48)
                goto LABEL_27;
            }
            re::TypeInfo::releaseInstance((re::TypeInfo *)v54, Instance, v39, *(void **)(a1 + 184));
            return 0;
          }
LABEL_27:
          re::TypeInfo::releaseInstance((re::TypeInfo *)v54, Instance, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
        }
LABEL_28:
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionary(v24);
        return *(_BYTE *)(a1 + 64) == 0;
      }
      goto LABEL_31;
    }
LABEL_29:
    v41 = (re::TypeInfo *)v54;
LABEL_32:
    v42 = re::TypeInfo::name(v41);
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Failed to resolve serialize function for type \"%s\"", v43, v44, v45, v46, v47, v42[1]);
    return 0;
  }
  v18 = *(re::internal **)(a1 + 192);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v53, (uint64_t)v56);
  re::internal::translateType(v18, (const re::TypeRegistry *)v53, (uint64_t)v54);
  v19 = *(re::internal **)(a1 + 192);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 80), &v55);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v56);
  re::internal::translateType(v19, (const re::TypeRegistry *)v52, (uint64_t)v53);
  v20 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v54);
  if (!v20)
    goto LABEL_29;
  v21 = (void (*)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t, double))v20;
  v22 = (*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)a1 + 80))(a1, v53);
  if (!v22)
  {
LABEL_31:
    v41 = (re::TypeInfo *)v53;
    goto LABEL_32;
  }
  v23 = (void (*)(uint64_t, const char *, _QWORD, _QWORD, _BYTE *, _BYTE *, uint64_t))v22;
  v55 = 0;
  v24 = (_anonymous_namespace_ *)(a1 + 24);
  v25 = re::EncoderBinary<re::FixedArrayInputStream>::beginDictionary(a1 + 24, a2, (uint64_t)a3, (char *)&v55, 0);
  result = 0;
  if (v25)
  {
    if (v55)
    {
      for (i = 0; i < v55; ++i)
      {
        v28 = re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>::beginDictionaryEntry(a1 + 24, 1);
        v21(a1, "key", 0, 0, v54, v54, 1, v28);
        v23(a1, "value", 0, 0, v53, v53, 1);
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endDictionaryEntry((_anonymous_namespace_ *)(a1 + 24));
      }
    }
    goto LABEL_28;
  }
  return result;
}

BOOL re::serializeUnion<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  unint64_t v18[4];
  unint64_t Tag;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_19:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 != (unsigned __int16)v15)
      goto LABEL_19;
    v17 = WORD1(v14) == WORD1(v15);
    v16 = (v15 ^ v14) & 0xFFFFFF00000000;
    v17 = v17 && v16 == 0;
    if (!v17)
      goto LABEL_19;
  }
LABEL_4:
  if (a7)
  {
    if (!*(_BYTE *)(a1 + 64))
    {
      LOBYTE(v20) = 1;
      DWORD1(v20) = 16;
      *((_QWORD *)&v20 + 1) = a2;
      v21 = 0u;
      v22 = 0u;
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)(a1 + 24), &v20);
      v18[0] = 0;
      re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, "tag", 0, (char *)v18, (uint64_t)"uint64", 0);
      if (v18[0] < *(unsigned int *)(*((_QWORD *)a6 + 2) + 88))
      {
        re::TypeInfo::unionMember(a6, v18[0], (uint64_t)&v20);
        if (!*(_BYTE *)(a1 + 64))
          (*(void (**)(uint64_t, const char *, _QWORD, _QWORD, __int128 *, __int128 *, uint64_t))(*(_QWORD *)a1 + 72))(a1, "value", 0, 0, &v20, &v20, 1);
      }
LABEL_13:
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(_BYTE *)(a1 + 64) == 0;
    }
  }
  else if (!*(_BYTE *)(a1 + 64))
  {
    LOBYTE(v20) = 1;
    DWORD1(v20) = 16;
    *((_QWORD *)&v20 + 1) = a2;
    v21 = 0u;
    v22 = 0u;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)(a1 + 24), &v20);
    re::TypeInfo::TypeInfo((uint64_t)&v20, (uint64_t)a5);
    Tag = re::UnionAccessor::readTag((re::UnionAccessor *)&v20, a4);
    re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, "tag", 0, (char *)&Tag, (uint64_t)"uint64", 0);
    re::UnionAccessor::reset((re::UnionAccessor *)&v20, a4, (const re::TypeInfo *)Tag, *(re::Allocator **)(a1 + 48));
    if (Tag < *(unsigned int *)(*((_QWORD *)a5 + 2) + 88))
    {
      re::TypeInfo::unionMember(a5, Tag, (uint64_t)v18);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, char *, unint64_t *, unint64_t *, _QWORD))(*(_QWORD *)a1 + 72))(a1, "value", 0, a4, v18, v18, 0);
    }
    goto LABEL_13;
  }
  return 0;
}

uint64_t re::serializeObject<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, re::TypeInfo *this, uint64_t a6, uint64_t a7)
{
  uint64_t *v14;
  const char *v15;
  re::TypeRegistry *v17;
  re *v18;
  const re::TypeInfo *v19;
  uint64_t v20;
  const char *v21;
  const re::TypeInfo *v22;
  const re::TypeInfo *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[2];
  _BYTE v35[32];
  _OWORD v36[3];

  if (!(_DWORD)a7)
  {
LABEL_6:
    if ((*(_BYTE *)(*((_QWORD *)this + 2) + 48) & 4) != 0)
      return re::internal::serializeObjectWithOneMember<re::EncoderOPACK<re::FixedArrayInputStream>>((_BYTE *)a1, a2, a3, a4, (uint64_t *)this, (uint64_t *)a6, a7);
    if (*(_BYTE *)(a1 + 64))
      return 0;
    LOBYTE(v36[0]) = 1;
    DWORD1(v36[0]) = 0;
    *((_QWORD *)&v36[0] + 1) = a2;
    memset(&v36[1], 0, 32);
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)(a1 + 24), v36);
    if (this == (re::TypeInfo *)a6)
      goto LABEL_14;
    if (*(_QWORD *)this == *(_QWORD *)a6)
    {
      v24 = **((_QWORD **)this + 2);
      v25 = **(_QWORD **)(a6 + 16);
      if ((unsigned __int16)v24 == (unsigned __int16)v25)
      {
        v27 = WORD1(v24) == WORD1(v25);
        v26 = (v25 ^ v24) & 0xFFFFFF00000000;
        v27 = v27 && v26 == 0;
        if (v27)
          goto LABEL_14;
      }
    }
    else if (re::areSameTranslatedVersion(this, (const re::TypeInfo *)a6, v23))
    {
LABEL_14:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>((_BYTE *)a1, a4, (uint64_t *)this, a7);
LABEL_25:
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endObject((_anonymous_namespace_ *)(a1 + 24));
      return *(_BYTE *)(a1 + 64) == 0;
    }
    if (*((unsigned __int8 *)this + 12) == *(unsigned __int8 *)(a6 + 12))
    {
      re::internal::serializeMembersWithVersioning<re::EncoderBinary<re::FixedArrayInputStream>>(a1, a4, (uint64_t *)this, (uint64_t *)a6, a7);
    }
    else
    {
      v28 = re::TypeInfo::name(this)[1];
      re::TypeInfo::name((re::TypeInfo *)a6);
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v29, v30, v31, v32, v33, v28);
    }
    goto LABEL_25;
  }
  if ((*(_BYTE *)(*((_QWORD *)this + 2) + 49) & 1) != 0)
  {
    v17 = *(re::TypeRegistry **)(a1 + 192);
    v34[0] = 0x2686EB529B3EE220;
    v34[1] = "DynamicString";
    re::TypeRegistry::typeInfo(v17, (const re::StringID *)v34, v36);
    re::TypeInfo::TypeInfo((uint64_t)v35, (uint64_t)v36 + 8);
    re::StringID::destroyString((re::StringID *)v34);
    v18 = (re *)v35;
    v19 = (const re::TypeInfo *)v35;
    v20 = a1;
    v21 = a2;
    v22 = (const re::TypeInfo *)a3;
  }
  else
  {
    v14 = re::TypeInfo::name(this);
    if ((*v14 & 0xFFFFFFFFFFFFFFFELL) != 0x2686EB529B3EE220)
      goto LABEL_6;
    v15 = (const char *)v14[1];
    if (v15 != "DynamicString")
    {
      if (strcmp(v15, "DynamicString"))
        goto LABEL_6;
    }
    v20 = a1;
    v21 = a2;
    v22 = (const re::TypeInfo *)a3;
    v18 = this;
    v19 = this;
  }
  re::serializeDynamicString<re::EncoderBinary<re::FixedArrayInputStream>>(v20, v21, v22, 0, v18, v19, 1);
  return *(_BYTE *)(a1 + 64) == 0;
}

uint64_t re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<short>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  uint64_t v11;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if ((a6 & 1) != 0)
    a4 = 0;
  if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, a4, 2uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    v11 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v11 - 16);
  }
  return 1;
}

uint64_t re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  uint64_t v11;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if ((a6 & 1) != 0)
    a4 = 0;
  if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, a4, 4uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    v11 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v11 - 16);
  }
  return 1;
}

uint64_t re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(uint64_t a1, const char *a2, uint64_t a3, char *a4, uint64_t a5, char a6)
{
  uint64_t v11;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if ((a6 & 1) != 0)
    a4 = 0;
  if ((re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)a1, a4, 8uLL) & 1) == 0)
  {
    re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType((_anonymous_namespace_ *)a1, a2, a5);
    return 0;
  }
  if ((a6 & 2) == 0)
  {
    v11 = *(_QWORD *)(a1 + 128) + 48 * *(_QWORD *)(a1 + 112);
    ++*(_QWORD *)(v11 - 16);
  }
  return 1;
}

uint64_t re::internal::serializeEnumAsBinary<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, void *a4, re::internal *a5, re::internal *a6, int a7)
{
  re::internal *v11;
  uint64_t result;
  _QWORD *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  void *v21;
  int v22;
  re::internal *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  unsigned int EnumConstantIndex;
  unsigned int v31;
  re::internal::TypeTranslationTable *v32;
  const void *v33;
  int v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD v56[4];
  uint64_t __src;
  _QWORD v58[4];

  if (a7)
  {
    v11 = *(re::internal **)(a1 + 192);
    re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &__src);
    re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
    re::internal::translateType(v11, (const re::TypeRegistry *)v56, (uint64_t)&__src);
    if (!*(_BYTE *)(a1 + 64))
      return (*(uint64_t (**)(uint64_t, const char *, const re::TypeInfo *, _QWORD, uint64_t *, uint64_t *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, a3, 0, &__src, &__src, 1);
    return 0;
  }
  v15 = *(_QWORD **)a5;
  if (a5 == a6)
    goto LABEL_8;
  if (v15 == *(_QWORD **)a6)
  {
    v16 = **((_QWORD **)a5 + 2);
    v17 = (uint64_t *)*((_QWORD *)a6 + 2);
    v18 = *v17;
    if ((unsigned __int16)v16 == (unsigned __int16)*v17)
    {
      v20 = WORD1(v16) == WORD1(v18);
      v19 = (v18 ^ v16) & 0xFFFFFF00000000;
      v20 = v20 && v19 == 0;
      if (v20)
        goto LABEL_8;
    }
LABEL_21:
    v23 = *(re::internal **)(a1 + 192);
    re::TypeRegistry::typeInfo(v15, v17[9], &__src);
    re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
    re::internal::translateType(v23, (const re::TypeRegistry *)v56, (uint64_t)&__src);
    if (*(_DWORD *)(v58[1] + 8) < 9u)
    {
      v55 = 0;
      if (!*(_BYTE *)(a1 + 64)
        && (*(unsigned int (**)(uint64_t, const char *, const re::TypeInfo *, uint64_t *, uint64_t *, uint64_t *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, a3, &v55, &__src, &__src, 0))
      {
        EnumConstantIndex = re::internal::getEnumConstantIndex(a6, (const re::TypeInfo *)&v55, v29);
        if ((EnumConstantIndex & 0x80000000) != 0)
        {
          v41 = v55;
          re::TypeInfo::name(a6);
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Value %zu is not a valid enum constant of \"%s\".", v42, v43, v44, v45, v46, v41);
        }
        else
        {
          v31 = EnumConstantIndex;
          v32 = *(re::internal::TypeTranslationTable **)(*(_QWORD *)a6 + 856);
          if (v32)
          {
            v33 = (const void *)re::internal::TypeTranslationTable::translateSerializedEnum(v32, a6, v31, a5);
            if (v33)
            {
              memcpy(a4, v33, *(unsigned int *)(*((_QWORD *)a5 + 2) + 8));
              v34 = 0;
              return v34 == 0;
            }
          }
          v56[0] = re::TypeInfo::enumConstants(a6);
          v56[1] = v47;
          v48 = *(_QWORD *)(re::Slice<re::EnumConstant>::operator[](v56, v31) + 16);
          re::TypeInfo::name(a5);
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Serialized enum constant \"%s\" does not exist in runtime type \"%s\".", v49, v50, v51, v52, v53, v48);
        }
      }
    }
    else
    {
      v54 = re::TypeInfo::name((re::TypeInfo *)&__src)[1];
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Enum type \"%s\" has invalid size: %zu bytes.", v24, v25, v26, v27, v28, v54);
    }
    v34 = 1;
    return v34 == 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3))
  {
    v15 = *(_QWORD **)a6;
    v17 = (uint64_t *)*((_QWORD *)a6 + 2);
    goto LABEL_21;
  }
  v15 = *(_QWORD **)a5;
LABEL_8:
  re::TypeRegistry::typeInfo(v15, *(_QWORD *)(*((_QWORD *)a5 + 2) + 72), &__src);
  re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v58);
  __src = 0;
  if (*(_BYTE *)(a1 + 64))
    return 0;
  v22 = (*(uint64_t (**)(uint64_t, const char *, const re::TypeInfo *, uint64_t *, _QWORD *, _QWORD *, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, a3, &__src, v56, v56, 0);
  result = 0;
  if (v22)
  {
    if ((re::internal::getEnumConstantIndex(a5, (const re::TypeInfo *)&__src, v21) & 0x80000000) != 0)
    {
      v35 = __src;
      re::TypeInfo::name(a5);
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Value %zu is not a valid enum constant of \"%s\".", v36, v37, v38, v39, v40, v35);
      return 0;
    }
    memcpy(a4, &__src, *(unsigned int *)(*((_QWORD *)a5 + 2) + 8));
    return 1;
  }
  return result;
}

double re::EncoderBinary<re::FixedArrayInputStream>::beginOptional(uint64_t a1, const char *a2, uint64_t a3, char *a4, int a5)
{
  uint64_t v9;
  double result;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (!*(_BYTE *)(a1 + 40))
  {
    re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1, a2, 0, a4, (uint64_t)"BOOL", 2);
    v9 = *a4;
    LOBYTE(v11) = 3;
    DWORD1(v11) = a5;
    *((_QWORD *)&v11 + 1) = a2;
    v12 = 0;
    v14 = 0;
    v15 = 0;
    v13 = v9;
    return re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v11);
  }
  return result;
}

BOOL re::EncoderBinary<re::FixedArrayInputStream>::beginArray(uint64_t a1, const char *a2, uint64_t a3, char *a4, int a5)
{
  char v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  if ((a5 & 4) == 0)
    re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1, a2, 0, a4, (uint64_t)"uint32", 2);
  if ((a5 & 8) != 0)
  {
    if (*(_QWORD *)a4)
      v10 = 73;
    else
      v10 = 78;
    v17 = v10;
    re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1, a2, 0, &v17, (uint64_t)"uint8", 2);
  }
  v11 = *(_QWORD *)a4;
  LOBYTE(v12) = 5;
  DWORD1(v12) = a5;
  *((_QWORD *)&v12 + 1) = a2;
  v13 = 0;
  v15 = 0;
  v16 = 0;
  v14 = v11;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v12);
  return *(_BYTE *)(a1 + 40) == 0;
}

uint64_t re::EncoderBinary<re::FixedArrayInputStream>::serializeArray(uint64_t result, char *a2, uint64_t a3, uint64_t a4, char a5)
{
  _anonymous_namespace_ *v7;
  size_t v8;
  uint64_t v9;

  if (!*(_BYTE *)(result + 40))
  {
    v7 = (_anonymous_namespace_ *)result;
    v8 = a4 * a3;
    if ((a5 & 1) != 0)
      a2 = 0;
    result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)result, a2, v8);
    if ((result & 1) != 0)
    {
      if ((a5 & 2) == 0)
      {
        v9 = *((_QWORD *)v7 + 16) + 48 * *((_QWORD *)v7 + 14);
        *(_QWORD *)(v9 - 16) += a4;
      }
    }
    else
    {
      return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType(v7, 0, (uint64_t)"Array");
    }
  }
  return result;
}

BOOL re::EncoderBinary<re::FixedArrayInputStream>::beginDictionary(uint64_t a1, const char *a2, uint64_t a3, char *a4, int a5)
{
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1, a2, 0, a4, (uint64_t)"uint32", 2);
  v10 = *(_QWORD *)a4;
  LOBYTE(v11) = 6;
  DWORD1(v11) = a5;
  *((_QWORD *)&v11 + 1) = a2;
  v12 = 0;
  v14 = 0;
  v15 = 0;
  v13 = v10;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v11);
  return *(_BYTE *)(a1 + 40) == 0;
}

BOOL re::serializeDynamicString<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, _QWORD *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  char *v19;
  _BOOL4 v20;
  _BOOL8 result;
  _anonymous_namespace_ *v22;
  unint64_t v23;
  unint64_t v24;
  _BOOL4 v25;
  unint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  size_t v33;
  char *v34;
  unint64_t v35;

  if (a5 == a6)
    goto LABEL_14;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x22C6ED80D0CLL
    || (v19 = (char *)v18[1], v19 != "StringID") && strcmp(v19, "StringID"))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v35 = 0;
    v20 = re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v35, 0);
    result = 0;
    if (!v20)
      return result;
    if (v35)
      re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
    v22 = (_anonymous_namespace_ *)(a1 + 24);
    goto LABEL_34;
  }
  v23 = a4[1];
  if ((v23 & 1) != 0)
    v24 = v23 >> 1;
  else
    v24 = v23 >> 1;
  v35 = v24;
  v25 = re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v35, 0);
  result = 0;
  if (v25)
  {
    v26 = v35;
    if (v26 <= (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24)))
    {
      if (!*a4)
      {
        v33 = v35 + 1;
        *a4 = *(_QWORD *)(a1 + 48);
        re::DynamicString::setCapacity(a4, v33);
      }
      re::DynamicString::resize(a4, v35, 0);
      if (v35)
      {
        if ((a4[1] & 1) != 0)
          v34 = (char *)a4[2];
        else
          v34 = (char *)a4 + 9;
        re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, v34, 0);
      }
      v22 = (_anonymous_namespace_ *)(a1 + 24);
LABEL_34:
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString(v22);
      return *(_BYTE *)(a1 + 64) == 0;
    }
    v27 = v35;
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v28, v29, v30, v31, v32, v27);
    return 0;
  }
  return result;
}

BOOL re::EncoderBinary<re::FixedArrayInputStream>::beginString(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, int a5)
{
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (*(_BYTE *)(a1 + 40))
    return 0;
  re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1, "length", 0, a4, (uint64_t)"uint32", 2);
  v10 = *(_QWORD *)a4;
  LOBYTE(v11) = 8;
  DWORD1(v11) = a5;
  *((_QWORD *)&v11 + 1) = a2;
  v12 = 0;
  v14 = 0;
  v15 = 0;
  v13 = v10;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)a1, &v11);
  return *(_BYTE *)(a1 + 40) == 0;
}

uint64_t re::EncoderBinary<re::FixedArrayInputStream>::serializeString(uint64_t result, char *a2, char a3)
{
  _anonymous_namespace_ *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (!*(_BYTE *)(result + 40))
  {
    v4 = (_anonymous_namespace_ *)result;
    v5 = *(_QWORD *)(result + 128) + 48 * *(_QWORD *)(result + 112);
    v6 = *(_QWORD *)(v5 - 24);
    if ((a3 & 1) != 0)
      a2 = 0;
    result = re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::process<re::FixedArrayInputStream,0>((_QWORD *)result, a2, *(_QWORD *)(v5 - 24));
    if ((result & 1) != 0)
    {
      if ((a3 & 2) == 0)
      {
        v7 = *((_QWORD *)v4 + 16) + 48 * *((_QWORD *)v4 + 14);
        *(_QWORD *)(v7 - 16) += v6;
      }
    }
    else
    {
      return re::Encoder<re::EncoderOPACK<re::FixedArrayInputStream>,re::FixedArrayInputStream>::setErrorWithType(v4, 0, (uint64_t)"string");
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>(_BYTE *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t result;
  unint64_t i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  _BYTE v15[32];
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18[2];
  uint64_t v19;
  unint64_t v20;
  _BYTE v21[8];
  uint64_t v22;
  _BYTE v23[8];
  uint64_t v24;

  re::TypeRegistry::typeInfo((_QWORD *)*a3, *(_QWORD *)(a3[2] + 72), v21);
  if (v21[0])
  {
    re::TypeInfo::TypeInfo((uint64_t)v18, (uint64_t)&v22);
    if (*(_DWORD *)(v19 + 88) || (re::TypeRegistry::typeInfo(v18[0], *(_QWORD *)(v19 + 72), v23), v23[0]))
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>(a1, a2, v18, a4);
  }
  result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v18, *a3, a3[2]);
  if (v20)
  {
    for (i = 0; i < v20; ++i)
    {
      if (a1[64])
        break;
      result = (uint64_t)re::TypeMemberCollection::operator[]((uint64_t *)v18, i, (uint64_t)&v16);
      if (*(_BYTE *)(v17 + 28))
      {
        v10 = *(_QWORD *)(v17 + 16);
        if (strlen((const char *)v10) >= 3 && *(_BYTE *)v10 == 109)
          v10 += 2 * (*(_BYTE *)(v10 + 1) == 95);
        v11 = *(unsigned int *)(v17 + 32);
        v12 = a2 + *(unsigned int *)(v17 + 24);
        re::TypeRegistry::typeInfo(v16, *(_QWORD *)v17, v23);
        re::TypeInfo::TypeInfo((uint64_t)v15, (uint64_t)&v24);
        if (a1[64]
          || (result = (*(uint64_t (**)(_BYTE *, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v10, v11, v12, v15, v15, a4), (result & 1) == 0))
        {
          result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a3);
          if (v13)
          {
            v14 = (_DWORD *)(result + 16);
            while (i != *v14)
            {
              v14 += 6;
              if (!--v13)
                goto LABEL_21;
            }
            if (!a1[64])
              result = (*(uint64_t (**)(_BYTE *, _QWORD, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, *((_QWORD *)v14 - 1), v11, v12, v15, v15, a4);
          }
        }
      }
LABEL_21:
      ;
    }
  }
  return result;
}

uint64_t re::internal::serializeMembersWithVersioning<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  const re::TypeInfo *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t i;
  uint64_t v29;
  uint64_t v30;
  re *v31;
  uint64_t v32;
  uint64_t v33;
  _DWORD *v34;
  NSObject *v35;
  NSObject *v36;
  uint64_t v37;
  re::internal *v38;
  uint64_t v39;
  _BYTE v40[32];
  _BYTE v41[32];
  _QWORD *v42[2];
  uint64_t v43;
  _QWORD *v44[2];
  uint64_t v45;
  uint64_t v46[4];
  unint64_t v47;
  uint64_t v48[5];
  _BYTE v49[8];
  uint64_t v50;
  char v51;
  uint64_t *v52;
  _BYTE v53[8];
  uint64_t v54;
  char v55;
  uint64_t *v56;
  uint8_t buf[4];
  uint64_t v58;
  __int16 v59;
  uint64_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  re::TypeRegistry::typeInfo((_QWORD *)*a3, *(_QWORD *)(a3[2] + 72), v53);
  re::TypeRegistry::typeInfo((_QWORD *)*a4, *(_QWORD *)(a4[2] + 72), v49);
  if (v49[0])
  {
    if (!v53[0])
    {
      v11 = re::TypeInfo::name((re::TypeInfo *)&v50)[1];
      re::TypeInfo::name((re::TypeInfo *)a3);
      return re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Base class \"%s\" removed from type \"%s\".", v12, v13, v14, v15, v16, v11);
    }
    if (v54 == v50)
    {
      v18 = *v56;
      v19 = *v52;
      if ((unsigned __int16)*v56 == (unsigned __int16)*v52)
      {
        v21 = WORD1(v18) == WORD1(v19);
        v20 = (v19 ^ v18) & 0xFFFFFF00000000;
        v21 = v21 && v20 == 0;
        if (v21)
          goto LABEL_5;
      }
    }
    else if (re::areSameTranslatedVersion((re *)&v54, (const re::TypeInfo *)&v50, v10))
    {
LABEL_5:
      re::internal::serializeMembersWithoutVersioning<re::EncoderBinary<re::FixedArrayInputStream>>((_BYTE *)a1, a2, &v54, a5);
      goto LABEL_15;
    }
    if (v55 == v51)
    {
      re::internal::serializeMembersWithVersioning<re::EncoderBinary<re::FixedArrayInputStream>>(a1, a2, &v54, &v50, a5);
    }
    else
    {
      v22 = re::TypeInfo::name((re::TypeInfo *)&v54)[1];
      re::TypeInfo::name((re::TypeInfo *)&v50);
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Type categories of types \"%s\" (runtime) and \"%s\" (stream) don't match.", v23, v24, v25, v26, v27, v22);
    }
  }
LABEL_15:
  re::TypeMemberCollection::TypeMemberCollection((uint64_t)v48, *a3, a3[2]);
  result = re::TypeMemberCollection::TypeMemberCollection((uint64_t)v46, *a4, a4[2]);
  if (v47)
  {
    for (i = 0; i < v47; ++i)
    {
      if (*(_BYTE *)(a1 + 64))
        break;
      result = (uint64_t)re::TypeMemberCollection::operator[](v46, i, (uint64_t)v44);
      if (*(_BYTE *)(v45 + 28))
      {
        v29 = *(_QWORD *)(v45 + 16);
        if (strlen((const char *)v29) >= 3 && *(_BYTE *)v29 == 109)
          v29 += 2 * (*(_BYTE *)(v29 + 1) == 95);
        v30 = *(unsigned int *)(v45 + 32);
        v31 = *(re **)(*a4 + 856);
        if (!v31
          || (v31 = (re *)re::internal::TypeTranslationTable::translateMember(v31, (const re::TypeMemberInfo *)v44),
              (_DWORD)v31 == -1))
        {
          v35 = *re::foundationSerializationLogObjects(v31);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
          {
            v36 = v35;
            v37 = re::TypeInfo::name((re::TypeInfo *)a4)[1];
            *(_DWORD *)buf = 136315394;
            v58 = v37;
            v59 = 2080;
            v60 = v29;
            _os_log_impl(&dword_224FE9000, v36, OS_LOG_TYPE_INFO, "Skipping unknown member \"%s.%s\".", buf, 0x16u);

          }
          v38 = *(re::internal **)(a1 + 192);
          re::TypeRegistry::typeInfo(v44[0], *(_QWORD *)v45, buf);
          re::TypeInfo::TypeInfo((uint64_t)v42, (uint64_t)&v58 + 4);
          result = re::internal::translateType(v38, (const re::TypeRegistry *)v42, (uint64_t)buf);
          if (!*(_BYTE *)(a1 + 64))
            result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint8_t *, uint8_t *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, 0, buf, buf, 1);
        }
        else
        {
          re::TypeMemberCollection::operator[](v48, (int)v31, (uint64_t)v42);
          v32 = a2 + *(unsigned int *)(v43 + 24);
          re::TypeRegistry::typeInfo(v42[0], *(_QWORD *)v43, buf);
          re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v58 + 4);
          re::TypeRegistry::typeInfo(v44[0], *(_QWORD *)v45, buf);
          re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v58 + 4);
          if (*(_BYTE *)(a1 + 64)
            || (result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v29, v30, v32, v41, v40, a5), (result & 1) == 0))
          {
            result = re::TypeInfo::renamedObjectMembers((re::TypeInfo *)a4);
            if (v33)
            {
              v34 = (_DWORD *)(result + 16);
              while (i != *v34)
              {
                v34 += 6;
                if (!--v33)
                  goto LABEL_35;
              }
              v39 = *((_QWORD *)v34 - 1);
              re::TypeRegistry::typeInfo(v42[0], *(_QWORD *)v43, buf);
              re::TypeInfo::TypeInfo((uint64_t)v41, (uint64_t)&v58 + 4);
              re::TypeRegistry::typeInfo(v44[0], *(_QWORD *)v45, buf);
              result = re::TypeInfo::TypeInfo((uint64_t)v40, (uint64_t)&v58 + 4);
              if (!*(_BYTE *)(a1 + 64))
                result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, v39, v30, v32, v41, v40, a5);
            }
          }
        }
      }
LABEL_35:
      ;
    }
  }
  return result;
}

uint64_t *re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFunc(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t *result;
  BOOL v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  v5 = *(_QWORD *)(a1 + 192);
  result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v5 + 200, a2);
  if (v5)
    v7 = result == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v8 = *result;
    v10 = a3;
    v9 = v8 | 0xFFFFFFFF00000000;
    return (uint64_t *)re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1 + 208, &v9, &v10);
  }
  return result;
}

uint64_t re::serializeBool<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"BOOL", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"BOOL", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"BOOL", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeChar<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"char", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"char", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"char", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI8<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int8", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int8", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int8", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI16<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int16", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int16", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int16", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI32<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int32", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int32", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int32", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeI64<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int64", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int64", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"int64", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU8<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint8", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint8", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint8", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU16<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint16", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint16", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<short>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint16", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU32<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint32", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint32", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint32", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeU64<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint64", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint64", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"uint64", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeFloat<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"float", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"float", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"float", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

uint64_t re::serializeDouble<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, char *a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;

  if (a5 == a6)
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"double", a7);
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v15 = **((_QWORD **)a5 + 2);
    v16 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v15 == (unsigned __int16)v16)
    {
      v18 = WORD1(v15) == WORD1(v16);
      v17 = (v16 ^ v15) & 0xFFFFFF00000000;
      v18 = v18 && v17 == 0;
      if (v18)
        return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"double", a7);
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    return re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>(a1 + 24, a2, (uint64_t)a3, a4, (uint64_t)"double", a7);
  }
  re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
  return 0;
}

BOOL re::serializeCString<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, const char **a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL4 v19;
  _BOOL8 result;
  _BOOL4 v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  size_t v27;
  char *v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  size_t v44;
  int v45;
  char v46;
  size_t v47;
  int v48;

  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_22:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    v23 = **((_QWORD **)a5 + 2);
    v24 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v23 != (unsigned __int16)v24)
      goto LABEL_22;
    v26 = WORD1(v23) == WORD1(v24);
    v25 = (v24 ^ v23) & 0xFFFFFF00000000;
    v26 = v26 && v25 == 0;
    if (!v26)
      goto LABEL_22;
  }
LABEL_4:
  if (a7)
  {
    v48 = 0;
    v19 = re::EncoderBinary<re::FixedArrayInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v48, 0);
    result = 0;
    if (!v19)
      return result;
    if (!v48)
      goto LABEL_12;
    if (v48 != 1)
    {
      v47 = 0;
      if (re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, 0, (char *)&v47, 0))
      {
        if (v47)
          re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
      }
LABEL_12:
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
      goto LABEL_47;
    }
    goto LABEL_16;
  }
  v48 = 2 * (*a4 != 0);
  v21 = re::EncoderBinary<re::FixedArrayInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v48, 0);
  result = 0;
  if (!v21)
    return result;
  v22 = v48;
  if (v48)
  {
    if (v48 == 1)
    {
LABEL_16:
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Found pointer reference instead of C string.", v14, v15, v16, v17, v18, v46);
      return 0;
    }
  }
  else
  {
    if (!*a4)
      goto LABEL_44;
    (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
    *a4 = 0;
    v22 = v48;
  }
  if (v22 == 2)
  {
    v27 = *a4 ? strlen(*a4) : 0;
    v47 = v27;
    if (re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, 0, (char *)&v47, 0))
    {
      v28 = (char *)*a4;
      v29 = v47;
      if (!*a4 || v47 != v27)
      {
        if (v28)
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
          *a4 = 0;
          v29 = v47;
        }
        v30 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
        v36 = v47;
        if (v29 > v30)
        {
          (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v37, v38, v39, v40, v41, v36);
          return 0;
        }
        v42 = v47 == -1;
        v43 = v42 << 63 >> 63;
        if (v43 != v42 || v43 < 0)
        {
          re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, v47);
          return 0;
        }
        v28 = (char *)(*(uint64_t (**)(_QWORD, size_t, _QWORD))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), v47 + 1, 0);
        *a4 = v28;
        v27 = v47;
      }
      if (v27)
      {
        re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, v28, 0);
        v28 = (char *)*a4;
        v44 = v47;
      }
      else
      {
        v44 = 0;
      }
      v28[v44] = 0;
      re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    }
  }
LABEL_44:
  re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
  v45 = *(unsigned __int8 *)(a1 + 64);
  if (!*a4 || !*(_BYTE *)(a1 + 64))
    return v45 == 0;
  (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
  *a4 = 0;
LABEL_47:
  v45 = *(unsigned __int8 *)(a1 + 64);
  return v45 == 0;
}

BOOL re::serializeStringID<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t *a4, re *a5, const re::TypeInfo *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t *v18;
  char *v19;
  _BOOL4 v20;
  _BOOL8 result;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  _anonymous_namespace_ *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;

  if (a5 == a6)
    goto LABEL_14;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 == (unsigned __int16)v15)
    {
      v17 = WORD1(v14) == WORD1(v15);
      v16 = (v15 ^ v14) & 0xFFFFFF00000000;
      v17 = v17 && v16 == 0;
      if (v17)
        goto LABEL_14;
    }
  }
  else if (re::areSameTranslatedVersion(a5, a6, a3))
  {
    goto LABEL_14;
  }
  v18 = re::TypeInfo::name(a6);
  if ((unint64_t)*v18 >> 1 != 0x134375A94D9F7110
    || (v19 = (char *)v18[1], v19 != "DynamicString") && strcmp(v19, "DynamicString"))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
LABEL_14:
  if (a7)
  {
    v47 = 0;
    v20 = re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v47, 0);
    result = 0;
    if (!v20)
      return result;
    if (v47)
      re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
    goto LABEL_26;
  }
  v46 = 0;
  if (re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v46, 0))
  {
    v22 = v46;
    if (v46)
    {
      v23 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
      v29 = v46;
      if (v22 > v23)
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 24) + 64))(*(_QWORD *)(a1 + 24));
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "String size greater than stream size during deserialization. String length = %zu, Stream length = %zu", v30, v31, v32, v33, v34, v29);
        return 0;
      }
      v36 = v46 == -1;
      v37 = v36 << 63 >> 63;
      if (v37 != v36 || v37 < 0)
      {
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, a2, "Size overflow during string deserialization. String length = %zu", v24, v25, v26, v27, v28, v46);
        return 0;
      }
      v38 = (char *)(*(uint64_t (**)(_QWORD, unint64_t, _QWORD))(**(_QWORD **)(a1 + 56) + 32))(*(_QWORD *)(a1 + 56), v46 + 1, 0);
      v39 = (_anonymous_namespace_ *)re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, v38, 0);
      v38[v46] = 0;
      v44 = 0;
      v45 = &str_110;
      v40 = v44;
      v41 = (uint64_t)v45;
      v44 = 0;
      v45 = &str_110;
      v42 = *a4;
      v43 = a4[1];
      *a4 = v40;
      a4[1] = v41;
      v47 = v40 & 0xFFFFFFFFFFFFFFFELL | v42 & 1;
      v48 = v43;
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
      (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 56) + 40))(*(_QWORD *)(a1 + 56), v38);
    }
    else
    {
      v44 = 0;
      v45 = &str_110;
      v35 = a4[1];
      v47 = *a4 & 1;
      v48 = v35;
      *a4 = 0;
      a4[1] = (uint64_t)&str_110;
      re::StringID::destroyString((re::StringID *)&v47);
      re::StringID::destroyString((re::StringID *)&v44);
    }
LABEL_26:
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    return *(_BYTE *)(a1 + 64) == 0;
  }
  return 0;
}

BOOL re::serializeIntrospectionCallbackSerializer<re::EncoderBinary<re::FixedArrayInputStream>>(uint64_t a1, const char *a2, const re::TypeInfo *a3, uint64_t a4, re::TypeInfo *a5, re::TypeInfo *a6, int a7)
{
  _BOOL4 v14;
  _BOOL8 result;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  re *v24;
  NSObject *v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  uint64_t v35;
  unint64_t v36;
  _BYTE buf[22];
  __int16 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  if (a5 == a6)
    goto LABEL_4;
  if (*(_QWORD *)a5 == *(_QWORD *)a6)
  {
    v28 = **((_QWORD **)a5 + 2);
    v29 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v28 == (unsigned __int16)v29)
    {
      v31 = WORD1(v28) == WORD1(v29);
      v30 = (v29 ^ v28) & 0xFFFFFF00000000;
      v31 = v31 && v30 == 0;
      if (v31)
        goto LABEL_4;
    }
LABEL_32:
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
    return 0;
  }
  if (!re::areSameTranslatedVersion(a5, a6, a3))
    goto LABEL_32;
LABEL_4:
  if (a7)
  {
    v32 = 0;
    v14 = re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v32, 0);
    result = 0;
    if (!v14)
      return result;
    if (v32)
      re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, 0, 1);
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
  }
  else
  {
    v16 = **((_QWORD **)a5 + 2);
    v32 = *(_QWORD *)a5;
    v33 = v16;
    LODWORD(v34) = -1;
    *(_QWORD *)buf = 0x258C98EAAF29A10ALL;
    *(_QWORD *)&buf[8] = "CallbackSerializerAttribute";
    v17 = (uint64_t *)re::TypeAttributeCollection::operator[](&v32, buf);
    re::StringID::destroyString((re::StringID *)buf);
    v18 = *v17;
    v19 = *(_QWORD *)(a1 + 184);
    v36 = 0;
    result = re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, (uint64_t)a3, (char *)&v36, 0);
    if (!result)
      return result;
    v20 = *(_QWORD *)(a1 + 56);
    v34 = 0;
    v35 = 0;
    v32 = v20;
    v33 = 0;
    re::DynamicString::setCapacity(&v32, 0);
    if (v36)
    {
      re::DynamicString::resize(&v32, v36, 0);
      if ((v33 & 1) != 0)
        v21 = v34;
      else
        v21 = (char *)&v33 + 1;
      re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, v21, 0);
    }
    re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
    v22 = (char *)&v33 + 1;
    if ((v33 & 1) != 0)
      v23 = v34;
    else
      v23 = (char *)&v33 + 1;
    v24 = (re *)(*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, char *))(v18 + 80))(*(_QWORD *)(a1 + 48), v19, v18, a4, v23);
    if ((v24 & 1) == 0)
    {
      v25 = *re::foundationSerializationLogObjects(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_INFO))
      {
        if ((v33 & 1) != 0)
          v22 = v34;
        v26 = v25;
        v27 = re::TypeInfo::name(a5)[1];
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = a2;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v22;
        v38 = 2080;
        v39 = v27;
        _os_log_impl(&dword_224FE9000, v26, OS_LOG_TYPE_INFO, "Failed to parse \"%s\": \"%s\" (type %s) using deserialization callback - skipping.", buf, 0x20u);

      }
    }
    if (v32 && (v33 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v32 + 40))();
  }
  return *(_BYTE *)(a1 + 64) == 0;
}

BOOL re::EncoderBinary<re::FixedArrayInputStream>::beginPointer(_anonymous_namespace_ *a1, const char *a2, uint64_t a3, int *a4, int a5)
{
  int v10;
  uint64_t v11;
  _BYTE *v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  _BYTE v20[23];
  _OWORD v21[2];
  char v22;

  if (*((_BYTE *)a1 + 40))
    return 0;
  v22 = 78;
  re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<unsigned char>((uint64_t)a1, a2, 0, &v22, (uint64_t)"uint8", 2);
  switch(v22)
  {
    case 'I':
      v10 = 2;
      break;
    case 'N':
      v10 = 0;
      v11 = 0;
      goto LABEL_10;
    case 'R':
      v10 = 1;
      break;
    default:
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::combineLabels(a1, 0, (re::DynamicString *)&v18);
      if ((v19 & 1) != 0)
        v12 = *(_BYTE **)&v20[7];
      else
        v12 = v20;
      re::DynamicString::format((re::DynamicString *)"Failed to deserialize pointer \"%s\". Invalid tag.", (re::DynamicString *)v21, v12);
      re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::setError((uint64_t)a1, (uint64_t)v21);
      if (*(_QWORD *)&v21[0])
      {
        if ((BYTE8(v21[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v21[0] + 40))();
        memset(v21, 0, sizeof(v21));
      }
      if (v18)
      {
        if ((v19 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v18 + 40))();
      }
      return 0;
  }
  v11 = 1;
LABEL_10:
  *a4 = v10;
  LOBYTE(v13) = 9;
  DWORD1(v13) = a5;
  *((_QWORD *)&v13 + 1) = a2;
  v14 = 0;
  v16 = 0;
  v17 = 0;
  v15 = v11;
  re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState(a1, &v13);
  return *((_BYTE *)a1 + 40) == 0;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unint64_t *a2, _QWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v6 = *a2;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v7) = 0;
    goto LABEL_8;
  }
  v7 = v6 % *(unsigned int *)(a1 + 24);
  v8 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v7);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, v7, v6, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  v9 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v9 + 24 * v8 + 4) != v6)
  {
    v8 = *(_DWORD *)(v9 + 24 * v8) & 0x7FFFFFFF;
    if ((_DWORD)v8 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v10 = 3 * v8;
  *(_QWORD *)(v9 + 8 * v10 + 16) = *a3;
  ++*(_DWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 16) + 8 * v10;
  return v11 + 16;
}

uint64_t re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v11;
  int v12;
  uint64_t v13;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 24 * v8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 24 * v8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  v13 = 24 * v8;
  *(_DWORD *)(v11 + v13) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v13) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 4) = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10) & 0x80000000) != 0)
          {
            re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addEmplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10 + 4) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10 + 4), *(_QWORD *)&v13[16] + v10 + 4, *(_QWORD *)&v13[16] + v10 + 16);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

BOOL re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::serializeCString(uint64_t a1, const char *a2, const re::TypeInfo *a3, char **a4, re *a5, const re::TypeInfo *a6, char a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _anonymous_namespace_ *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  __int128 v44;
  _QWORD *v45;
  unsigned __int16 v46;
  unsigned __int16 v47;
  int v48;
  unsigned int v49;
  int v50;

  if (a5 != a6)
  {
    if (*(_QWORD *)a5 != *(_QWORD *)a6)
    {
      if (re::areSameTranslatedVersion(a5, a6, a3))
        goto LABEL_4;
LABEL_15:
      re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, a5, a6);
      return 0;
    }
    v14 = **((_QWORD **)a5 + 2);
    v15 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v14 != (unsigned __int16)v15)
      goto LABEL_15;
    v17 = WORD1(v14) == WORD1(v15);
    v16 = (v15 ^ v14) & 0xFFFFFF00000000;
    v17 = v17 && v16 == 0;
    if (!v17)
      goto LABEL_15;
  }
LABEL_4:
  v50 = 0;
  if (re::EncoderBinary<re::FixedArrayInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, (uint64_t)a3, &v50, 0))
  {
    if (v50 == 1)
    {
      v49 = 0;
      if (!*(_BYTE *)(a1 + 64))
      {
        re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, "ID", 0, (char *)&v49, (uint64_t)"Reference ID", 0);
        if (!*(_BYTE *)(a1 + 64))
        {
          if (*(_QWORD *)(a1 + 328) <= (unint64_t)v49)
          {
            re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Invalid reference ID for shared object: %u", v19, v20, v21, v22, v23, v49);
          }
          else
          {
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v49, (uint64_t)&v45);
            if (v45 == *(_QWORD **)a5)
            {
              v24 = **((_QWORD **)a5 + 2);
              if (v46 == (unsigned __int16)v24 && v47 == WORD1(v24) && ((v48 ^ HIDWORD(v24)) & 0xFFFFFF) == 0)
              {
                if ((a7 & 1) == 0)
                {
                  if (*a4)
                  {
                    v42 = *a4;
                    if (v42 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v49))
                    {
                      (*(void (**)(_QWORD, char *))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48), *a4);
                      *a4 = 0;
                    }
                  }
                  *a4 = (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v49);
                  re::internal::SharedObjectGraph::addReference((_QWORD *)(a1 + 256), v49);
                }
                goto LABEL_37;
              }
            }
            v25 = *(_anonymous_namespace_ **)(a1 + 192);
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v49, (uint64_t)&v45);
            v43 = *((_QWORD *)re::TypeRegistry::typeName(v25, &v45) + 1);
            re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Invalid reference ID for shared object. Expected type \"char *\". Actual type \"%s\".", v26, v27, v28, v29, v30, v43);
          }
        }
      }
    }
    else
    {
      if (!v50)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
            *a4 = 0;
          }
        }
LABEL_37:
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
        return *(_BYTE *)(a1 + 64) == 0;
      }
      if ((a7 & 1) == 0 && *a4)
      {
        (*(void (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 40))(*(_QWORD *)(a1 + 48));
        *a4 = 0;
      }
      v45 = 0;
      if (re::EncoderBinary<re::FixedArrayInputStream>::beginString(a1 + 24, (uint64_t)a2, 0, (char *)&v45, 0))
      {
        v36 = v45 == (_QWORD *)-1;
        v37 = v36 << 63 >> 63;
        if (v37 == v36 && (v37 & 0x8000000000000000) == 0)
        {
          v38 = (char *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 48) + 32))(*(_QWORD *)(a1 + 48), (uint64_t)v45 + 1, 0);
          v39 = (uint64_t)v38;
          if ((a7 & 1) == 0)
            *a4 = v38;
          v40 = v45;
          if (v45)
          {
            re::EncoderBinary<re::FixedArrayInputStream>::serializeString(a1 + 24, v38, 0);
            v40 = v45;
          }
          *((_BYTE *)v40 + v39) = 0;
          re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endString((_anonymous_namespace_ *)(a1 + 24));
          v41 = **((_QWORD **)a5 + 2);
          *(_QWORD *)&v44 = *(_QWORD *)a5;
          *((_QWORD *)&v44 + 1) = v41;
          re::internal::SharedObjectGraph::addObject(a1 + 256, v39, &v44);
          goto LABEL_37;
        }
        re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Size overflow during string deserialization. String length = %zu", v31, v32, v33, v34, v35, (char)v45);
      }
    }
  }
  return 0;
}

BOOL re::SerializerV1<re::EncoderBinary<re::FixedArrayInputStream>>::serializePointer(uint64_t a1, const char *a2, uint64_t a3, char **a4, re::TypeInfo *this, const re::TypeInfo *a6, int a7)
{
  const re::TypeInfo *v14;
  _BOOL4 isPointerToPolymorphicType;
  int v16;
  re *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t *v30;
  uint64_t *v31;
  char *v33;
  uint64_t v34;
  char **v35;
  void **v36;
  re::TypeRegistry *v37;
  uint64_t *v38;
  char *Instance;
  uint64_t v40;
  re *v41;
  uint64_t v42;
  _anonymous_namespace_ *v43;
  void (*v44)(uint64_t);
  uint64_t v45;
  __int128 v46;
  re *v47[2];
  re *v48[2];
  _BYTE v49[16];
  unsigned int v50;
  int v51;
  _BYTE v52[16];
  uint64_t v53;
  re *v54[2];
  _BYTE v55[32];
  _QWORD v56[2];
  re **v57;
  uint64_t v58;
  _BYTE v59[40];

  isPointerToPolymorphicType = re::TypeInfo::isPointerToPolymorphicType(this);
  if (this == a6)
    goto LABEL_4;
  if (*(_QWORD *)this == *(_QWORD *)a6)
  {
    v26 = **((_QWORD **)this + 2);
    v27 = **((_QWORD **)a6 + 2);
    if ((unsigned __int16)v26 == (unsigned __int16)v27)
    {
      v29 = WORD1(v26) == WORD1(v27);
      v28 = (v27 ^ v26) & 0xFFFFFF00000000;
      v29 = v29 && v28 == 0;
      if (v29)
        goto LABEL_4;
    }
  }
  else if (re::areSameTranslatedVersion(this, a6, v14))
  {
LABEL_4:
    v16 = 0;
    goto LABEL_5;
  }
  if (*((_BYTE *)a6 + 12) != 9
    || isPointerToPolymorphicType
    && (!re::TypeInfo::isPointerToPolymorphicType(a6)
     || (v30 = re::TypeInfo::name(this), v31 = re::TypeInfo::name(a6), !re::StringID::operator==(v30, v31))))
  {
    re::internal::setTypeMismatchError<re::EncoderOPACK<re::FixedArrayInputStream>>(a1, a2, this, a6);
    return 0;
  }
  v16 = 1;
LABEL_5:
  re::TypeRegistry::typeInfo(*(_QWORD **)this, *(_QWORD *)(*((_QWORD *)this + 2) + 72), &v58);
  re::TypeInfo::TypeInfo((uint64_t)v56, (uint64_t)v59);
  re::TypeRegistry::typeInfo(*(_QWORD **)a6, *(_QWORD *)(*((_QWORD *)a6 + 2) + 72), &v58);
  re::TypeInfo::TypeInfo((uint64_t)v55, (uint64_t)v59);
  if (!isPointerToPolymorphicType || (a7 & 1) != 0)
  {
    v17 = *v57;
    v54[0] = (re *)v56[0];
    v54[1] = v17;
    if (v56[0])
      goto LABEL_8;
LABEL_15:
    v45 = re::TypeInfo::name(this)[1];
    v23 = "Failed to get actual type of polymorphic object. Type \"%s\".";
    v24 = a1;
    v25 = a2;
LABEL_16:
    re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(v24, v25, v23, v18, v19, v20, v21, v22, v45);
    return 0;
  }
  re::internal::actualType(a4, (void **)this, v54);
  if (!v54[0])
    goto LABEL_15;
LABEL_8:
  re::TypeRegistry::typeInfo(*(re **)this, v54, &v58);
  re::TypeInfo::TypeInfo((uint64_t)v52, (uint64_t)v59);
  v51 = 0;
  if (re::EncoderBinary<re::FixedArrayInputStream>::beginPointer((_anonymous_namespace_ *)(a1 + 24), a2, a3, &v51, 0))
  {
    if (v51 != 1)
    {
      if (!v51)
      {
        if ((a7 & 1) == 0)
        {
          if (*a4)
          {
            re::TypeInfo::releaseInstance((re::TypeInfo *)v52, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
            *a4 = 0;
          }
        }
        goto LABEL_57;
      }
      if (isPointerToPolymorphicType)
      {
        re::internal::deserializePolymorphicObject<re::EncoderBinary<re::FixedArrayInputStream>,true>(a1, (uint64_t)a2, a3, (void **)a4, (re **)this, (re::TypeInfo *)v52, (re::TypeInfo *)v55, v16, a7);
        goto LABEL_57;
      }
      if (!a7)
      {
        Instance = *a4;
        if (!*a4)
          Instance = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v56, *(re::Allocator **)(a1 + 48), 0);
        v40 = 0;
        *a4 = Instance;
        goto LABEL_53;
      }
      v37 = *(re::TypeRegistry **)(a1 + 192);
      if ((re::TypeRegistry *)v56[0] != v37)
      {
        v38 = re::TypeInfo::name((re::TypeInfo *)v56);
        re::TypeRegistry::typeInfo(v37, (const re::StringID *)v38, &v58);
        if (!(_BYTE)v58)
        {
          Instance = 0;
          v40 = 1;
          goto LABEL_53;
        }
        re::TypeInfo::operator=((uint64_t)v56, (uint64_t)v59);
      }
      Instance = (char *)re::TypeInfo::createInstance((re::TypeInfo *)v56, *(re::Allocator **)(a1 + 48), 0);
      v40 = 0;
LABEL_53:
      v41 = *v57;
      *(_QWORD *)&v46 = v56[0];
      *((_QWORD *)&v46 + 1) = v41;
      re::internal::SharedObjectGraph::beginObject((_QWORD *)(a1 + 256), (uint64_t)Instance, &v46);
      if (!*(_BYTE *)(a1 + 64))
        (*(void (**)(uint64_t, const char *, _QWORD, char *, _QWORD *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, a2, 0, Instance, v56, v55, v40);
      if (*(_BYTE *)(a1 + 256))
      {
        --*(_QWORD *)(a1 + 408);
        ++*(_DWORD *)(a1 + 416);
      }
      goto LABEL_57;
    }
    v50 = 0;
    if (!*(_BYTE *)(a1 + 64))
    {
      re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<int>(a1 + 24, "ID", 0, (char *)&v50, (uint64_t)"Reference ID", 0);
      if (!*(_BYTE *)(a1 + 64))
      {
        if (*(_QWORD *)(a1 + 328) > (unint64_t)v50)
        {
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v50, (uint64_t)v49);
          if (!re::internal::areCompatible((re **)this, (uint64_t)v49))
          {
            v42 = re::TypeInfo::name((re::TypeInfo *)v56)[1];
            v43 = *(_anonymous_namespace_ **)(a1 + 192);
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v50, (uint64_t)&v58);
            LOBYTE(v45) = v42;
            re::TypeRegistry::typeName(v43, &v58);
            v23 = "Invalid reference. Objects are not compatible. Expected type \"%s\". Actual type \"%s\".";
            goto LABEL_61;
          }
          if ((a7 & 1) != 0)
          {
LABEL_57:
            re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endPointer((_anonymous_namespace_ *)(a1 + 24));
            return *(_BYTE *)(a1 + 64) == 0;
          }
          if (*a4)
          {
            v33 = *a4;
            if (v33 != (char *)re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v50))
            {
              re::TypeInfo::releaseInstance((re::TypeInfo *)v52, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
              *a4 = 0;
            }
          }
          v34 = re::internal::SharedObjectGraph::object((re::internal::SharedObjectGraph *)(a1 + 256), v50);
          v35 = (char **)v34;
          *a4 = (char *)v34;
          if ((*(_BYTE *)(v53 + 49) & 2) != 0)
          {
            v44 = *(void (**)(uint64_t))(v53 + 32);
            if (v44)
              v44(v34);
            re::internal::SharedObjectGraph::addReference((_QWORD *)(a1 + 256), v50);
          }
          else
          {
            re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v50, (uint64_t)v48);
            if (!v48[0])
            {
              LOBYTE(v45) = v50;
              v23 = "TypeID for shared object at index %d is invalid.";
              goto LABEL_61;
            }
            re::TypeRegistry::typeInfo(v48[0], v48, &v58);
            if (!(_BYTE)v58)
            {
              LOBYTE(v45) = v50;
              v23 = "No TypeInfo found for shared object at index %d.";
              goto LABEL_61;
            }
            v36 = re::TypeInfo::createInstance((re::TypeInfo *)v59, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
            *a4 = (char *)v36;
            if ((re::TypeInfo::copy((re::TypeInfo *)v59, v36, v35, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184)) & 1) == 0)
            {
              v45 = re::TypeInfo::name((re::TypeInfo *)v59)[1];
              v23 = "Failed to copy non-shareable object of type '%s'.";
LABEL_61:
              v24 = a1;
              v25 = 0;
              goto LABEL_16;
            }
          }
          re::internal::SharedObjectGraph::typeID((re::internal::SharedObjectGraph *)(a1 + 256), v50, (uint64_t)v47);
          re::TypeInfo::setActualTypeForPointer((_QWORD **)this, (uint64_t)a4, v47);
          goto LABEL_57;
        }
        LOBYTE(v45) = v50;
        v23 = "Invalid reference ID for shared object: %u";
        goto LABEL_61;
      }
    }
  }
  return 0;
}

BOOL re::internal::deserializePolymorphicObject<re::EncoderBinary<re::FixedArrayInputStream>,true>(uint64_t a1, uint64_t a2, uint64_t a3, void **a4, re **a5, re::TypeInfo *a6, re::TypeInfo *a7, int a8, char a9)
{
  _anonymous_namespace_ *v15;
  re::TypeRegistry *v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v24;
  uint64_t *v25;
  re *v26;
  re *v27;
  NSObject *v28;
  NSObject *v29;
  uint64_t v30;
  void **Instance;
  void **v32;
  _QWORD v33[2];
  re *v34[2];
  _QWORD v35[2];
  _BYTE v36[32];
  re *v37[2];
  unint64_t v38;
  __int128 buf;
  __int128 v40;
  __int128 v41;
  uint64_t v42;

  v42 = *MEMORY[0x24BDAC8D0];
  if (!*(_BYTE *)(a1 + 64))
  {
    v15 = (_anonymous_namespace_ *)(a1 + 24);
    LOBYTE(buf) = 1;
    DWORD1(buf) = 0;
    *((_QWORD *)&buf + 1) = a2;
    v40 = 0u;
    v41 = 0u;
    re::Encoder<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>,re::DynamicArrayBufferedOutputStream>::pushState((_QWORD *)(a1 + 24), &buf);
    v38 = 0;
    if ((re::EncoderBinary<re::FixedArrayInputStream>::serializeValue<long long>((uint64_t)v15, "customClassID", 1, (char *)&v38, (uint64_t)"uint64", 0) & 1) != 0)
    {
      re::TypeInfo::typeIDForCustomClassID(a7, v38, v37);
      if (v37[0])
      {
        if ((a9 & 1) == 0 && *a4)
        {
          re::TypeInfo::releaseInstance(a6, *a4, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
          *a4 = 0;
        }
        re::TypeRegistry::typeInfo(*(re **)a7, v37, &buf);
        re::TypeInfo::TypeInfo((uint64_t)v36, (uint64_t)&buf + 8);
        if (a8)
        {
          v16 = *(re::TypeRegistry **)(a1 + 192);
        }
        else
        {
          v16 = *(re::TypeRegistry **)(a1 + 192);
          if (*a5 == v16)
          {
            re::TypeInfo::operator=((uint64_t)a6, (uint64_t)v36);
            v26 = v37[0];
            v27 = v37[1];
            goto LABEL_21;
          }
        }
        v24 = re::TypeInfo::name((re::TypeInfo *)v36);
        v25 = re::TypeRegistry::typeInfo(v16, (const re::StringID *)v24, &buf);
        if (!(_BYTE)buf || !*(_BYTE *)(*((_QWORD *)&v40 + 1) + 120))
        {
          v28 = *re::foundationSerializationLogObjects((re *)v25);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            v29 = v28;
            v30 = re::TypeInfo::name((re::TypeInfo *)v36)[1];
            LODWORD(buf) = 136315138;
            *(_QWORD *)((char *)&buf + 4) = v30;
            _os_log_impl(&dword_224FE9000, v29, OS_LOG_TYPE_DEFAULT, "No matching runtime type found for serialized polymorphic type \"%s\". Skipping unknown type.", (uint8_t *)&buf, 0xCu);

          }
          v35[0] = 0;
          v35[1] = 0xFFFFFFFFLL;
          (*(void (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)a1 + 16))(a1, 0, v35);
          if (!*(_BYTE *)(a1 + 64))
            (*(void (**)(uint64_t, const char *, uint64_t, _QWORD, _BYTE *, _BYTE *, uint64_t))(*(_QWORD *)a1 + 72))(a1, "object", 10, 0, v36, v36, 1);
          goto LABEL_25;
        }
        re::TypeInfo::operator=((uint64_t)a6, (uint64_t)&buf + 8);
        v26 = *(re **)a6;
        v27 = (re *)**((_QWORD **)a6 + 2);
LABEL_21:
        Instance = re::TypeInfo::createInstance(a6, *(re::Allocator **)(a1 + 48), *(void **)(a1 + 184));
        v32 = Instance;
        if ((a9 & 1) == 0)
        {
          *a4 = Instance;
          v34[0] = v26;
          v34[1] = v27;
          re::internal::setActualType(a4, a5, v34);
        }
        v33[0] = v26;
        v33[1] = v27;
        (*(void (**)(uint64_t, void **, _QWORD *))(*(_QWORD *)a1 + 16))(a1, v32, v33);
        if (!*(_BYTE *)(a1 + 64))
          (*(void (**)(uint64_t, const char *, uint64_t, void **, re::TypeInfo *, _BYTE *, BOOL))(*(_QWORD *)a1 + 72))(a1, "object", 10, v32, a6, v36, v32 == 0);
LABEL_25:
        (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
        re::EncoderBinary<re::DynamicArrayBufferedOutputStream>::endObject(v15);
        return *(_BYTE *)(a1 + 64) == 0;
      }
      v17 = re::TypeInfo::name(a7);
      re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::setError(a1, 0, "Unknown polymorphic \"%s\" type. Custom class ID = %llu", v18, v19, v20, v21, v22, v17[1]);
    }
  }
  return 0;
}

void re::ecs2::PhysicsSimulationManager::~PhysicsSimulationManager(re::ecs2::PhysicsSimulationManager *this)
{
  re::ecs2::PhysicsSimulationManager::deinit(this);
  re::ecs2::PhysicsSimulationTracking::~PhysicsSimulationTracking((re::ecs2::PhysicsSimulationManager *)((char *)this + 16));
}

{
  re::ecs2::PhysicsSimulationManager::deinit(this);
  re::ecs2::PhysicsSimulationTracking::~PhysicsSimulationTracking((re::ecs2::PhysicsSimulationManager *)((char *)this + 16));
  JUMPOUT(0x2276933B8);
}

uint64_t re::ecs2::PhysicsSimulationManager::isMultipleSimulationEnabled(re::ecs2::PhysicsSimulationManager *this)
{
  return *((unsigned __int8 *)this + 320);
}

uint64_t re::ecs2::PhysicsSimulationManager::perEntityRootPhysicsSimulation(re::ecs2::PhysicsSimulationManager *this)
{
  return (uint64_t)this + 72;
}

uint64_t re::ecs2::PhysicsSimulationManager::physicsSimulationsForScene(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;

  if (!*(_QWORD *)(a1 + 432))
    return 0;
  v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  v3 = *(unsigned int *)(*(_QWORD *)(a1 + 440) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 456)));
  if ((_DWORD)v3 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 448);
  if (*(_QWORD *)(v5 + 88 * v3 + 16) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 88 * v3 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v3 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v5 + 88 * v3 + 16) == a2)
        return v5 + 88 * v3 + 24;
    }
    return 0;
  }
  return v5 + 88 * v3 + 24;
}

uint64_t re::ecs2::PhysicsSimulationManager::destroyPendingPhysicsSimulations(re::ecs2::PhysicsSimulationManager *this)
{
  return re::ecs2::PhysicsSimulationTracking::destroyPendingSimulations((re::ecs2::PhysicsSimulationManager *)((char *)this + 16));
}

void re::ecs2::PhysicsSimulationManager::updatePerEntityPhysicsSimulationRoot(re::ecs2::PhysicsSimulationManager *this, char a2)
{
  re::ecs2::PhysicsSimulationManager *v3;
  char *v4;

  v3 = this;
  v4 = (char *)this + 16;
  re::ecs2::PhysicsSimulationTracking::updateEnginePreferredUpdateRate((re::ecs2::PhysicsSimulationManager *)((char *)this + 16));
  v3 = (re::ecs2::PhysicsSimulationManager *)((char *)v3 + 120);
  re::ecs2::PhysicsSimulationTracking::buildPerEntityStateForDirtyEntityHierarchies((uint64_t)v4, a2, (uint64_t)v3);
  re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::clear((uint64_t)v3);
}

re *re::ecs2::PhysicsSimulationManager::registerScene(re::ecs2::PhysicsSimulationManager *this, re::ecs2::Scene *a2)
{
  return re::ecs2::PhysicsSimulationTracking::registerScene((re::ecs2::PhysicsSimulationManager *)((char *)this + 16), (unint64_t)a2);
}

re::ecs2::Scene **re::ecs2::PhysicsSimulationManager::unregisterScene(re::ecs2::PhysicsSimulationManager *this, re::ecs2::Scene *a2)
{
  return re::ecs2::PhysicsSimulationTracking::unregisterScene((re::ecs2::PhysicsSimulationManager *)((char *)this + 16), a2);
}

uint64_t re::ecs2::PhysicsSimulationManager::isDebugRenderingEnabled(re::ecs2::PhysicsSimulationManager *this)
{
  return *((unsigned __int8 *)this + 616);
}

uint64_t re::ecs2::PhysicsSimulationManager::setDebugRenderingEnabled(uint64_t this, char a2)
{
  *(_BYTE *)(this + 616) = a2;
  return this;
}

uint64_t re::ecs2::PhysicsSimulationManager::setDefaultGravity(uint64_t a1, _OWORD *a2)
{
  return re::ecs2::PhysicsSimulationTracking::setDefaultGravity(a1 + 16, a2);
}

uint64_t re::ecs2::PhysicsSimulationManager::defaultGravity(re::ecs2::PhysicsSimulationManager *this)
{
  return (uint64_t)this + 336;
}

uint64_t re::ecs2::PhysicsSimulationManager::setDefaultLinearDamping(uint64_t this, float a2)
{
  *(float *)(this + 352) = a2;
  return this;
}

float re::ecs2::PhysicsSimulationManager::defaultLinearDamping(re::ecs2::PhysicsSimulationManager *this)
{
  return *((float *)this + 88);
}

uint64_t re::ecs2::PhysicsSimulationManager::setDefaultAngularDamping(uint64_t this, float a2)
{
  *(float *)(this + 356) = a2;
  return this;
}

float re::ecs2::PhysicsSimulationManager::defaultAngularDamping(re::ecs2::PhysicsSimulationManager *this)
{
  return *((float *)this + 89);
}

uint64_t re::ecs2::PhysicsSimulationManager::setDefaultFixedTimeStep(re::ecs2::PhysicsSimulationManager *this, float a2)
{
  *((float *)this + 90) = a2;
  return re::ecs2::PhysicsSimulationTracking::updateDefaultFixedTimeStepsForPhysicsSimulations((uint64_t)this + 16);
}

float re::ecs2::PhysicsSimulationManager::defaultFixedTimeStep(re::ecs2::PhysicsSimulationManager *this)
{
  float result;

  result = *((float *)this + 90);
  if (result <= 0.0)
    return *((float *)this + 91);
  return result;
}

uint64_t re::ecs2::PhysicsSimulationManager::setDefaultMaxSubStepCount(re::ecs2::PhysicsSimulationManager *this, int a2)
{
  return re::ecs2::PhysicsSimulationTracking::setDefaultMaxSubStepCount((uint64_t)this + 16, a2);
}

uint64_t re::ecs2::PhysicsSimulationManager::defaultMaxSubStepCount(re::ecs2::PhysicsSimulationManager *this)
{
  return *((unsigned int *)this + 92);
}

uint64_t re::ecs2::PhysicsSimulationManager::legacyGlobalSimulation(re::ecs2::PhysicsSimulationManager *this)
{
  return *((_QWORD *)this + 74);
}

uint64_t re::ecs2::PhysicsSimulationManager::setAnchorShouldHaveSharedSimulationByDefault(uint64_t this, char a2)
{
  *(_BYTE *)(this + 576) = a2;
  return this;
}

uint64_t re::ecs2::PhysicsSimulationManager::anchorShouldHaveSharedSimulationByDefault(re::ecs2::PhysicsSimulationManager *this)
{
  return *((unsigned __int8 *)this + 576);
}

void re::ecs2::PhysicsSimulationTracking::~PhysicsSimulationTracking(re::ecs2::PhysicsSimulationTracking *this)
{
  uint64_t v2;
  uint64_t v3;

  *((_QWORD *)this + 37) = 0;
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 64);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 58);
  re::HashTable<re::ecs2::Scene const*,re::DataArray<re::ecs2::PhysicsSimulationData>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::deinit((uint64_t *)this + 52);
  re::BucketArray<RESubscriptionHandle,8ul>::deinit((uint64_t)this + 360);
  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 360);
  v2 = *((_QWORD *)this + 34);
  if (v2)
  {
    if (*((_QWORD *)this + 35))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 36));
      *((_QWORD *)this + 35) = 0;
      *((_QWORD *)this + 36) = 0;
    }
    *((_QWORD *)this + 34) = 0;
  }
  v3 = *((_QWORD *)this + 31);
  if (v3)
  {
    if (*((_QWORD *)this + 32))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 33));
      *((_QWORD *)this + 32) = 0;
      *((_QWORD *)this + 33) = 0;
    }
    *((_QWORD *)this + 31) = 0;
  }
  re::ecs2::HierarchyStateTracking<re::ecs2::RootPhysicsSimulationData>::~HierarchyStateTracking((uint64_t *)this);
}

{
  re::ecs2::PhysicsSimulationTracking::~PhysicsSimulationTracking(this);
  JUMPOUT(0x2276933B8);
}

uint64_t *re::ecs2::HierarchyStateTracking<re::ecs2::RootPhysicsSimulationData>::~HierarchyStateTracking(uint64_t *a1)
{
  uint64_t *v2;

  *a1 = (uint64_t)off_24ED2B038;
  v2 = a1 + 1;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 25);
  re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit(a1 + 19);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 13);
  re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit(a1 + 7);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v2);
  return a1;
}

double re::HashTable<re::ecs2::Scene const*,re::DataArray<re::ecs2::PhysicsSimulationData>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::DataArray<re::ecs2::PhysicsSimulationData>::~DataArray((_QWORD *)(v6 + 24));
          v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 88;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

_QWORD *re::DataArray<re::ecs2::PhysicsSimulationData>::~DataArray(_QWORD *a1)
{
  re::DataArray<re::ecs2::PhysicsSimulationData>::deinit((uint64_t)a1);
  if (*a1)
  {
    if (a1[4])
      (*(void (**)(_QWORD))(*(_QWORD *)*a1 + 40))(*a1);
    a1[4] = 0;
    a1[1] = 0;
    a1[2] = 0;
    *a1 = 0;
    ++*((_DWORD *)a1 + 6);
  }
  return a1;
}

uint64_t re::DataArray<re::ecs2::PhysicsSimulationData>::deinit(uint64_t result)
{
  uint64_t *v1;
  double v2;
  _QWORD *v3;

  if (*(_DWORD *)(result + 44))
  {
    v1 = (uint64_t *)result;
    v2 = re::DataArray<re::ecs2::PhysicsSimulationData>::clear((_QWORD *)result);
    if (!v1[2])
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v3 = (_QWORD *)v1[4];
    (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)*v1 + 40))(*v1, *v3, v2);
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v3[1]);
    result = *v1;
    if (*v1)
    {
      if (v1[4])
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
      v1[4] = 0;
      v1[1] = 0;
      v1[2] = 0;
      *v1 = 0;
      ++*((_DWORD *)v1 + 6);
    }
    *((_DWORD *)v1 + 11) = 0;
  }
  return result;
}

double re::DataArray<re::ecs2::PhysicsSimulationData>::clear(_QWORD *a1)
{
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double result;
  _OWORD v12[5];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)v12, (uint64_t)a1, 0);
  if (*(_QWORD **)&v12[0] != a1 || WORD4(v12[0]) != 0xFFFFLL || (DWORD2(v12[0]) & 0xFFFF0000) != 4294901760)
  {
    do
    {
      v4 = re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::handle((unsigned __int16 *)v12);
      re::DataArray<re::ecs2::PhysicsSimulationData>::destroy((uint64_t)a1, v4);
      re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(v12);
    }
    while (*(_QWORD **)&v12[0] != a1 || WORD4(v12[0]) != 0xFFFF || WORD5(v12[0]) != 0xFFFF);
  }
  v7 = a1[2];
  v8 = v7 - 1;
  if (v7 != 1)
  {
    v9 = 16 * v7;
    do
    {
      if (a1[2] <= v8)
      {
        memset(v12, 0, sizeof(v12));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v10 = a1[4] + v9;
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, *(_QWORD *)(v10 - 16));
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, *(_QWORD *)(v10 - 8));
      re::DynamicArray<re::DataArray<re::RigGraphOperatorDefinition>::ElementBlock>::removeAt((uint64_t)a1, v8);
      v9 -= 16;
      --v8;
    }
    while (v8);
  }
  result = NAN;
  a1[6] = 0xFFFFFFFF00000000;
  return result;
}

void re::DataArray<re::ecs2::PhysicsSimulationData>::destroy(uint64_t a1, unint64_t a2)
{
  int v2;
  unint64_t v4;
  id *v5;
  id *v6;

  v2 = a2;
  v4 = a2 >> 16;
  v5 = (id *)re::DataArray<re::ecs2::PhysicsSimulationData>::tryGet(a1, a2 & 0xFFFFFFFF00000000 | ((unint64_t)WORD1(a2) << 16) | (unsigned __int16)a2);
  if (v5)
  {
    v6 = v5;
    re::ecs2::PhysicsSimulationData::deinit(v5);
    objc_destroyWeak(v6 + 6);
    v6[6] = 0;
    if (*(_QWORD *)(a1 + 16) <= (unint64_t)HIWORD(v2))
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16 * HIWORD(v2) + 8) + 4 * (unsigned __int16)v2) = 0;
    *(_DWORD *)v6 = *(_DWORD *)(a1 + 52);
    *(_WORD *)(a1 + 52) = v2;
    *(_WORD *)(a1 + 54) = v4;
    --*(_DWORD *)(a1 + 40);
  }
}

uint64_t re::DataArray<re::ecs2::PhysicsSimulationData>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  BOOL v6;

  v2 = *(_QWORD *)(a1 + 16);
  if (WORD1(a2) < v2
    && ((unsigned __int16)(v2 - 1) != WORD1(a2) ? (v3 = *(_DWORD *)(a1 + 44)) : (v3 = *(_DWORD *)(a1 + 48)),
        (unsigned __int16)a2 < v3
     && ((v4 = *(_QWORD *)(a1 + 32),
          (v5 = *(_DWORD *)(*(_QWORD *)(v4 + 16 * WORD1(a2) + 8) + 4 * (unsigned __int16)a2)) != 0)
       ? (v6 = v5 == (HIDWORD(a2) & 0xFFFFFF))
       : (v6 = 0),
         v6)))
  {
    return *(_QWORD *)(v4 + 16 * WORD1(a2)) + 272 * (unsigned __int16)a2;
  }
  else
  {
    return 0;
  }
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::RootPhysicsSimulationData>::trackedComponents()
{
  return 0;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::RootPhysicsSimulationData>::trackedActivationComponents()
{
  return 0;
}

void re::ecs2::HierarchyStateTracking<re::ecs2::RootPhysicsSimulationData>::clearEntityHierarchyStateData(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[2];
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  _BYTE v17[120];

  if (*(_DWORD *)(a1 + 84))
  {
    re::StackScratchAllocator::StackScratchAllocator((re::StackScratchAllocator *)v17);
    v11[0] = 0;
    v11[1] = 0;
    v12 = 1;
    v14 = 0;
    v15 = 0;
    v13 = 0;
    v16 = 0;
    re::BucketArray<re::ecs2::Entity const*,32ul>::init((uint64_t)v11, (uint64_t)v17, 1uLL);
    *(_QWORD *)re::BucketArray<re::ecs2::Entity const*,32ul>::addUninitialized((uint64_t)v11) = a2;
    v4 = v15;
    if (v15)
    {
      v5 = a1 + 56;
      do
      {
        v10 = 0;
        v10 = *(_QWORD *)re::BucketArray<re::ecs2::Entity const*,32ul>::operator[]((uint64_t)v11, v4 - 1);
        re::BucketArray<re::ecs2::Entity const*,32ul>::operator[]((uint64_t)v11, --v15);
        ++v16;
        re::HashTable<re::ecs2::Entity const*,re::ecs2::RootPhysicsSimulationData,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::remove(v5, &v10);
        v6 = *(_QWORD *)(v10 + 328);
        if (v6)
        {
          v7 = *(uint64_t **)(v10 + 344);
          v8 = 8 * v6;
          do
          {
            v9 = *v7++;
            *(_QWORD *)re::BucketArray<re::ecs2::Entity const*,32ul>::addUninitialized((uint64_t)v11) = v9;
            v8 -= 8;
          }
          while (v8);
        }
        v4 = v15;
      }
      while (v15);
    }
    re::BucketArray<re::ecs2::Entity const*,32ul>::deinit((uint64_t)v11);
    if (v11[0])
    {
      if ((v12 & 1) == 0)
        (*(void (**)(void))(*(_QWORD *)v11[0] + 40))();
    }
    re::StackScratchAllocator::~StackScratchAllocator((re::StackScratchAllocator *)v17);
  }
}

uint64_t re::HashTable<re::ecs2::Entity const*,re::ecs2::RootPhysicsSimulationData,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int *v13;
  int v14;
  int v15;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *a2;
  v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v4 = ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(unsigned int *)(v5 + 4 * v4);
  if ((_DWORD)v6 == 0x7FFFFFFF)
    return 0;
  v8 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v8 + 56 * v6 + 16) != v2)
  {
    while (1)
    {
      v9 = v6;
      LODWORD(v6) = *(_DWORD *)(v8 + 56 * v6 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v6 == 0x7FFFFFFF)
        return 0;
      if (*(_QWORD *)(v8 + 56 * v6 + 16) == v2)
      {
        *(_DWORD *)(v8 + 56 * v9 + 8) = *(_DWORD *)(v8 + 56 * v9 + 8) & 0x80000000 | *(_DWORD *)(v8 + 56 * v6 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v8 + 56 * v6 + 8) & 0x7FFFFFFF;
LABEL_9:
  v10 = *(_QWORD *)(a1 + 16);
  v11 = v10 + 56 * v6;
  v14 = *(_DWORD *)(v11 + 8);
  v13 = (int *)(v11 + 8);
  v12 = v14;
  if (v14 < 0)
  {
    *v13 = v12 & 0x7FFFFFFF;
    v10 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v10 + 56 * v6 + 8);
  }
  v15 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v10 + 56 * v6 + 8) = *(_DWORD *)(a1 + 36) | v12 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v6;
  *(_DWORD *)(a1 + 40) = v15 + 1;
  return 1;
}

uint64_t *re::BucketArray<re::ecs2::Entity const*,32ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t *result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<re::ecs2::Entity const*,32ul>::setBucketsCapacity((uint64_t *)a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

uint64_t *re::BucketArray<re::ecs2::Entity const*,32ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*result)
  {
    if (result[5] < 32 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 256, 0);
        result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::BucketArray<re::ecs2::Entity const*,32ul>::addUninitialized(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 8);
  if (v2 + 1 > 32 * v3)
  {
    re::BucketArray<re::ecs2::Entity const*,32ul>::setBucketsCapacity((uint64_t *)a1, (v2 + 32) >> 5);
    v3 = *(_QWORD *)(a1 + 8);
  }
  if (v3 <= v2 >> 5)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v4 = a1 + 24;
  else
    v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(v4 + 8 * (v2 >> 5));
  ++*(_QWORD *)(a1 + 40);
  ++*(_DWORD *)(a1 + 48);
  return v5 + 8 * (v2 & 0x1F);
}

uint64_t re::BucketArray<re::ecs2::Entity const*,32ul>::operator[](uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2 <= a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < m_size", "operator[]", 1011, a2, v2);
    _os_crash();
    __break(1u);
LABEL_8:
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (*(_QWORD *)(a1 + 8) <= a2 >> 5)
    goto LABEL_8;
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v3 = a1 + 24;
  else
    v3 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(v3 + 8 * (a2 >> 5)) + 8 * (a2 & 0x1F);
}

uint64_t re::BucketArray<re::ecs2::Entity const*,32ul>::deinit(uint64_t a1)
{
  uint64_t v2;
  unint64_t i;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (v2)
  {
    for (i = 0; i != v2; ++i)
      re::BucketArray<re::ecs2::Entity const*,32ul>::operator[](a1, i);
  }
  while (*(_QWORD *)(a1 + 8))
    re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket((uint64_t *)a1);
  result = re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(a1);
  *(_QWORD *)(a1 + 40) = 0;
  ++*(_DWORD *)(a1 + 48);
  return result;
}

void re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_402, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 24 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 24;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

double re::ColorManager::ColorManager(re::ColorManager *this)
{
  double result;

  *(_WORD *)this = 0;
  *((_OWORD *)this + 1) = xmmword_2260E5F10;
  *((_OWORD *)this + 2) = xmmword_2260E5F20;
  *((_OWORD *)this + 3) = xmmword_2260E5F40;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_DWORD *)this + 16) = 0;
  *(_OWORD *)((char *)this + 88) = xmmword_2260F4F30;
  *(_OWORD *)((char *)this + 104) = xmmword_2260EDC60;
  *((_BYTE *)this + 120) = 0;
  __asm { FMOV            V1.2S, #1.0 }
  *(_QWORD *)((char *)this + 124) = _D1;
  *((_BYTE *)this + 132) = 0;
  *((_QWORD *)this + 17) = 0x3F80000000000000;
  *((_BYTE *)this + 144) = 0;
  *(_OWORD *)((char *)this + 148) = xmmword_2260F4F40;
  *(_QWORD *)((char *)this + 164) = 0;
  *((_BYTE *)this + 172) = 0;
  *(_WORD *)((char *)this + 173) = 257;
  *((_OWORD *)this + 779) = 0u;
  result = 0.000000381469872;
  *((_OWORD *)this + 780) = xmmword_2260F4F50;
  return result;
}

void re::RealityDataPipeFactory::~RealityDataPipeFactory(re::RealityDataPipeFactory *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::RealityDataPipeFactory::makeRenderGraphDataPipe(re *a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;

  v3 = re::globalAllocators(a1);
  v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v3[2] + 32))(v3[2], 1920, 8);
  return re::RealityDataPipe::RealityDataPipe(v4, a2);
}

void re::ecs2::RenderOptionsManager::~RenderOptionsManager(re::ecs2::RenderOptionsManager *this)
{
  re::ecs2::RenderOptionsManagerStateTracking::~RenderOptionsManagerStateTracking((re::ecs2::RenderOptionsManager *)((char *)this + 8));
}

{
  re::ecs2::RenderOptionsManagerStateTracking::~RenderOptionsManagerStateTracking((re::ecs2::RenderOptionsManager *)((char *)this + 8));
  JUMPOUT(0x2276933B8);
}

uint64_t re::ecs2::RenderOptionsManager::renderOptions(re::ecs2::RenderOptionsManager *this)
{
  uint64_t v2;

  re::ecs2::RenderOptions::RenderOptions(&v2, (_DWORD *)this + 2);
  return v2;
}

uint64_t re::ecs2::RenderOptionsManager::registerScene(re::ecs2::RenderOptionsManager *this, re::EventBus **a2)
{
  re::EventBus *v2;
  re *v3;
  re *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  re *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  re *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  re *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  re *v24;
  re *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  re *v30;
  re *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t result;
  _QWORD v38[2];
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  re::ecs2::Scene *v44;
  _BYTE v45[24];
  uint64_t v46;
  re *v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v44 = (re::ecs2::Scene *)a2;
  v2 = a2[36];
  if (!v2)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) An event bus is expected for this system to track entity state changes.", "eventBus", "registerScene", 100);
    _os_crash();
    __break(1u);
  }
  v38[0] = 0;
  v3 = (re::ecs2::RenderOptionsManager *)((char *)this + 8);
  v38[1] = 0;
  v39 = 1;
  v41 = 0;
  v42 = 0;
  v40 = 0;
  v43 = 0;
  v4 = (re *)(*(uint64_t (**)(re *))(*(_QWORD *)v3 + 16))(v3);
  if (v5)
  {
    v6 = (uint64_t *)v4;
    v7 = 8 * v5;
    do
    {
      v8 = *v6;
      v46 = re::globalAllocators(v4)[2];
      v9 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 32, 0);
      *(_QWORD *)v9 = &off_24ED29C60;
      *((_QWORD *)v9 + 1) = v3;
      *((_QWORD *)v9 + 2) = re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<REComponentDidChangeEvent>;
      *((_QWORD *)v9 + 3) = 0;
      v47 = v9;
      v10 = re::EventBus::subscribe<re::ecs2::Entity,REComponentDidChangeEvent>(v2, (uint64_t)v45, v8, 0);
      v12 = v11;
      v13 = (_QWORD *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
      *v13 = v10;
      v13[1] = v12;
      if (v47)
      {
        (**(void (***)(re *))v47)(v47);
        if (v47 != (re *)v45)
          (*(void (**)(uint64_t))(*(_QWORD *)v46 + 40))(v46);
      }
      re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::subscribeToEventToInvalidateEntityHierarchy<REComponentDidActivateEvent>(v3, v2, (uint64_t)v38, v8);
      v4 = (re *)re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::subscribeToEventToInvalidateEntityHierarchy<REComponentWillDeactivateEvent>(v3, v2, (uint64_t)v38, v8);
      ++v6;
      v7 -= 8;
    }
    while (v7);
  }
  v14 = (re *)(*(uint64_t (**)(re *))(*(_QWORD *)v3 + 24))(v3);
  if (v15)
  {
    v16 = (uint64_t *)v14;
    v17 = 8 * v15;
    do
    {
      v18 = *v16++;
      re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::subscribeToEventToInvalidateEntityHierarchy<REComponentDidActivateEvent>(v3, v2, (uint64_t)v38, v18);
      v14 = (re *)re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::subscribeToEventToInvalidateEntityHierarchy<REComponentWillDeactivateEvent>(v3, v2, (uint64_t)v38, v18);
      v17 -= 8;
    }
    while (v17);
  }
  v46 = re::globalAllocators(v14)[2];
  v19 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 32, 0);
  *(_QWORD *)v19 = &off_24ED29D68;
  *((_QWORD *)v19 + 1) = v3;
  *((_QWORD *)v19 + 2) = re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<RESceneEntityDidReparentEvent>;
  *((_QWORD *)v19 + 3) = 0;
  v47 = v19;
  v20 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidReparentEvent>(v2, (uint64_t)v45, 0, 0);
  v22 = v21;
  v23 = (_QWORD *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
  *v23 = v20;
  v23[1] = v22;
  v24 = v47;
  if (v47)
  {
    v24 = (re *)(**(uint64_t (***)(re *))v47)(v47);
    if (v47 != (re *)v45)
      v24 = (re *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v46 + 40))(v46);
  }
  v46 = re::globalAllocators(v24)[2];
  v25 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 32, 0);
  *(_QWORD *)v25 = &off_24ED29DC0;
  *((_QWORD *)v25 + 1) = v3;
  *((_QWORD *)v25 + 2) = re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<RESceneEntityDidActivateEvent>;
  *((_QWORD *)v25 + 3) = 0;
  v47 = v25;
  v26 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidActivateEvent>(v2, (uint64_t)v45, 0, 0);
  v28 = v27;
  v29 = (_QWORD *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
  *v29 = v26;
  v29[1] = v28;
  v30 = v47;
  if (v47)
  {
    v30 = (re *)(**(uint64_t (***)(re *))v47)(v47);
    if (v47 != (re *)v45)
      v30 = (re *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v46 + 40))(v46);
  }
  v46 = re::globalAllocators(v30)[2];
  v31 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 32, 0);
  *(_QWORD *)v31 = &off_24ED29E18;
  *((_QWORD *)v31 + 1) = v3;
  *((_QWORD *)v31 + 2) = re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<RESceneEntityWillDeactivateEvent>;
  *((_QWORD *)v31 + 3) = 0;
  v47 = v31;
  v32 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(v2, (uint64_t)v45, 0, 0);
  v34 = v33;
  v35 = (_QWORD *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
  *v35 = v32;
  v35[1] = v34;
  if (v47)
  {
    (**(void (***)(re *))v47)(v47);
    if (v47 != (re *)v45)
      (*(void (**)(uint64_t))(*(_QWORD *)v46 + 40))(v46);
  }
  re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::add((uint64_t)this + 160, (uint64_t *)&v44, (uint64_t)v38);
  re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::add((uint64_t)this + 16, (uint64_t *)&v44);
  re::BucketArray<RESubscriptionHandle,8ul>::deinit((uint64_t)v38);
  result = v38[0];
  if (v38[0])
  {
    if ((v39 & 1) == 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v38[0] + 40))();
  }
  return result;
}

uint64_t re::ecs2::RenderOptionsManager::unregisterScene(re::ecs2::RenderOptionsManager *this, re::ecs2::Scene *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t i;
  uint64_t v13;
  re::ecs2::Scene *v14;

  v14 = a2;
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove((uint64_t)this + 16, (uint64_t *)&v14);
  v3 = *((_QWORD *)v14 + 13);
  v4 = *(_QWORD *)(v3 + 328);
  if (v4)
  {
    v5 = *(_QWORD *)(v3 + 344);
    v6 = 8 * v4;
    do
    {
      if ((*(_BYTE *)(*(_QWORD *)v5 + 288) & 1) != 0)
        (*(void (**)(char *))(*((_QWORD *)this + 1) + 40))((char *)this + 8);
      v5 += 8;
      v6 -= 8;
    }
    while (v6);
  }
  v7 = (char *)this + 160;
  result = re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet((uint64_t)v7, (uint64_t *)&v14);
  if (result)
  {
    v9 = *((_QWORD *)v14 + 36);
    if (v9)
    {
      v10 = result;
      v11 = *(_QWORD *)(result + 40);
      if (v11)
      {
        for (i = 0; i != v11; ++i)
        {
          v13 = re::BucketArray<RESubscriptionHandle,8ul>::operator[](v10, i);
          re::EventBus::unsubscribe(v9, *(_QWORD *)v13, *(_QWORD *)(v13 + 8));
        }
      }
    }
    return re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::remove((uint64_t)v7, (uint64_t *)&v14);
  }
  return result;
}

BOOL re::ecs2::RenderOptionsManager::needsUpdate(re::ecs2::RenderOptionsManager *this)
{
  return *((_DWORD *)this + 35) != 0;
}

void re::ecs2::RenderOptionsManagerStateTracking::~RenderOptionsManagerStateTracking(re::ecs2::RenderOptionsManagerStateTracking *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 31);
  if (v2)
  {
    if (*((_QWORD *)this + 32))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 33));
      *((_QWORD *)this + 32) = 0;
      *((_QWORD *)this + 33) = 0;
    }
    *((_QWORD *)this + 31) = 0;
  }
  re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::~HierarchyStateTracking((uint64_t *)this);
}

{
  re::ecs2::RenderOptionsManagerStateTracking::~RenderOptionsManagerStateTracking(this);
  JUMPOUT(0x2276933B8);
}

uint64_t *re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::~HierarchyStateTracking(uint64_t *a1)
{
  uint64_t *v2;

  *a1 = (uint64_t)off_24ED2AFE8;
  v2 = a1 + 1;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 25);
  re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit(a1 + 19);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 13);
  re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::deinit(a1 + 7);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v2);
  return a1;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::trackedComponents()
{
  return 0;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::trackedActivationComponents()
{
  return 0;
}

void re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::clearEntityHierarchyStateData(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[2];
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  _BYTE v17[120];

  if (*(_DWORD *)(a1 + 84))
  {
    re::StackScratchAllocator::StackScratchAllocator((re::StackScratchAllocator *)v17);
    v11[0] = 0;
    v11[1] = 0;
    v12 = 1;
    v14 = 0;
    v15 = 0;
    v13 = 0;
    v16 = 0;
    re::BucketArray<re::ecs2::Entity const*,32ul>::init((uint64_t)v11, (uint64_t)v17, 1uLL);
    *(_QWORD *)re::BucketArray<re::ecs2::Entity const*,32ul>::addUninitialized((uint64_t)v11) = a2;
    v4 = v15;
    if (v15)
    {
      v5 = a1 + 56;
      do
      {
        v10 = 0;
        v10 = *(_QWORD *)re::BucketArray<re::ecs2::Entity const*,32ul>::operator[]((uint64_t)v11, v4 - 1);
        re::BucketArray<re::ecs2::Entity const*,32ul>::operator[]((uint64_t)v11, --v15);
        ++v16;
        re::HashTable<re::ecs2::Entity const*,re::ecs2::RootPhysicsSimulationData,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::remove(v5, &v10);
        v6 = *(_QWORD *)(v10 + 328);
        if (v6)
        {
          v7 = *(uint64_t **)(v10 + 344);
          v8 = 8 * v6;
          do
          {
            v9 = *v7++;
            *(_QWORD *)re::BucketArray<re::ecs2::Entity const*,32ul>::addUninitialized((uint64_t)v11) = v9;
            v8 -= 8;
          }
          while (v8);
        }
        v4 = v15;
      }
      while (v15);
    }
    re::BucketArray<re::ecs2::Entity const*,32ul>::deinit((uint64_t)v11);
    if (v11[0])
    {
      if ((v12 & 1) == 0)
        (*(void (**)(void))(*(_QWORD *)v11[0] + 40))();
    }
    re::StackScratchAllocator::~StackScratchAllocator((re::StackScratchAllocator *)v17);
  }
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::subscribeToEventToInvalidateEntityHierarchy<REComponentDidActivateEvent>(re *a1, re::EventBus *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t result;
  _BYTE v14[24];
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v15 = re::globalAllocators(a1)[2];
  v8 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 32, 0);
  *v8 = &off_24ED29CB8;
  v8[1] = a1;
  v8[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<REComponentDidActivateEvent>;
  v8[3] = 0;
  v16 = v8;
  v9 = re::EventBus::subscribe<re::ecs2::Entity,REComponentDidActivateEvent>(a2, (uint64_t)v14, a4, 0);
  v11 = v10;
  v12 = (_QWORD *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized(a3);
  *v12 = v9;
  v12[1] = v11;
  result = (uint64_t)v16;
  if (v16)
  {
    result = (**(uint64_t (***)(_BYTE *))v16)(v16);
    if (v16 != v14)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
  }
  return result;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::subscribeToEventToInvalidateEntityHierarchy<REComponentWillDeactivateEvent>(re *a1, re::EventBus *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t result;
  _BYTE v14[24];
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v15 = re::globalAllocators(a1)[2];
  v8 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 32, 0);
  *v8 = &off_24ED29D10;
  v8[1] = a1;
  v8[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<REComponentWillDeactivateEvent>;
  v8[3] = 0;
  v16 = v8;
  v9 = re::EventBus::subscribe<re::ecs2::Entity,REComponentWillDeactivateEvent>(a2, (uint64_t)v14, a4, 0);
  v11 = v10;
  v12 = (_QWORD *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized(a3);
  *v12 = v9;
  v12[1] = v11;
  result = (uint64_t)v16;
  if (v16)
  {
    result = (**(uint64_t (***)(_BYTE *))v16)(v16);
    if (v16 != v14)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
  }
  return result;
}

uint64_t re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::add(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 80 * v13;
    return v12 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 80 * v10 + 16) != v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 80 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + 80 * v10;
  return v12 + 24;
}

uint64_t re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v4 = *a2;
  v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  v7 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % v7;
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v6 % v7));
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::addAsCopy(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v11 = v10 + 24 * v9;
  return v11 + 16;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<REComponentDidChangeEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = a2;
  if (!*(_BYTE *)(a2 + 371)
    && (*(_BYTE *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
  abort();
}

uint64_t re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v4 = *a2;
  v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  v7 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % v7;
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v6 % v7));
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::addAsCopy(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v11 = v10 + 24 * v9;
  return v11 + 16;
}

uint64_t re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::addAsCopy(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, *(_QWORD *)&v13[16] + v10 + 16);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

void re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_402, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 600);
    _os_crash();
    __break(1u);
  }
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::~CallableMemFn()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::operator()(_QWORD *a1, _QWORD *a2)
{
  uint64_t (*v2)(_QWORD *, _QWORD);
  uint64_t v3;
  _QWORD *v4;

  v2 = (uint64_t (*)(_QWORD *, _QWORD))a1[2];
  v3 = a1[3];
  v4 = (_QWORD *)(a1[1] + (v3 >> 1));
  if ((v3 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *, _QWORD))(*v4 + v2);
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED29C60;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24ED29C60;
  *(_QWORD *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::size()
{
  return 32;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<REComponentDidActivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = a2;
  if (!*(_BYTE *)(a2 + 371)
    && (*(_BYTE *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::~CallableMemFn()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::operator()(_QWORD *a1, _QWORD *a2)
{
  uint64_t (*v2)(_QWORD *, _QWORD);
  uint64_t v3;
  _QWORD *v4;

  v2 = (uint64_t (*)(_QWORD *, _QWORD))a1[2];
  v3 = a1[3];
  v4 = (_QWORD *)(a1[1] + (v3 >> 1));
  if ((v3 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *, _QWORD))(*v4 + v2);
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED29CB8;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24ED29CB8;
  *(_QWORD *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::size()
{
  return 32;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<REComponentWillDeactivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = a2;
  if (!*(_BYTE *)(a2 + 371)
    && (*(_BYTE *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::~CallableMemFn()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::operator()(_QWORD *a1, _QWORD *a2)
{
  uint64_t (*v2)(_QWORD *, _QWORD);
  uint64_t v3;
  _QWORD *v4;

  v2 = (uint64_t (*)(_QWORD *, _QWORD))a1[2];
  v3 = a1[3];
  v4 = (_QWORD *)(a1[1] + (v3 >> 1));
  if ((v3 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *, _QWORD))(*v4 + v2);
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED29D10;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24ED29D10;
  *(_QWORD *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::size()
{
  return 32;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7;
  _BYTE v9[24];
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)(a2 + 24);
  v11 = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v9, a2);
  v7 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidReparentEvent>(a1, 0, (uint64_t)v9, a3, a4);
  if (v11)
  {
    (**(void (***)(_BYTE *))v11)(v11);
    if (v11 != v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
  }
  return v7;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<RESceneEntityDidReparentEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = a2;
  if (!*(_BYTE *)(a2 + 371)
    && (*(_BYTE *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  __objc2_class_ro *Type;
  unint64_t EventInfo;
  uint64_t v12;
  uint64_t (**v14[6])();
  uint64_t v15;
  uint64_t (***v16)();
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  Type = re::EventBus::getTypeId<RESceneEntityDidReparentEvent>();
  EventInfo = re::EventBus::addOrGetEventInfo(a1, (uint64_t)Type);
  re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(a3, a5, v14);
  v12 = re::EventBus::EventInfo::addSubscription(EventInfo, (uint64_t)v14, a2, a4);
  if (v16)
  {
    ((void (*)(uint64_t (***)()))**v16)(v16);
    if (v16 != v14)
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
  }
  return v12;
}

{
  __objc2_class_ro *Type;
  re *EventInfo;
  uint64_t v12;
  uint64_t v13;
  _QWORD v15[3];
  uint64_t v16;
  _QWORD *v17;
  uint64_t (**v18[6])();
  uint64_t v19;
  uint64_t (***v20)();
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  Type = re::EventBus::getTypeId<RESceneEntityDidReparentEvent>();
  EventInfo = (re *)re::EventBus::addOrGetEventInfo(a1, (uint64_t)Type);
  v12 = re::globalAllocators(EventInfo)[2];
  v15[0] = &off_24ED5DBA8;
  v15[1] = a3;
  v16 = v12;
  v17 = v15;
  re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>((uint64_t)v15, a5, v18);
  v13 = re::EventBus::EventInfo::addSubscription((unint64_t)EventInfo, (uint64_t)v18, a2, a4);
  if (v20)
  {
    ((void (*)(uint64_t (***)()))**v20)(v20);
    if (v20 != v18)
      (*(void (**)(uint64_t))(*(_QWORD *)v19 + 40))(v19);
    v20 = 0;
  }
  if (v17)
  {
    (*(void (**)(_QWORD *))*v17)(v17);
    if (v17 != v15)
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 40))(v16);
  }
  return v13;
}

uint64_t re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>@<X0>(uint64_t a1@<X2>, char a2@<W4>, uint64_t (***a3)()@<X8>)
{
  re *v4;
  uint64_t v5;
  uint64_t (**v6)();
  re *v7;
  uint64_t result;
  _BYTE v9[24];
  uint64_t (**v10)();
  _BYTE *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v10 = *(uint64_t (***)())(a1 + 24);
  v11 = 0;
  if ((a2 & 1) != 0)
  {
    v7 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v9, a1);
    v5 = re::globalAllocators(v7)[2];
    v6 = &off_24ED2B8A8;
  }
  else
  {
    v4 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v9, a1);
    v5 = re::globalAllocators(v4)[2];
    v6 = &off_24ED2B900;
  }
  a3[6] = (uint64_t (**)())v5;
  a3[7] = 0;
  *a3 = v6;
  a3[4] = v10;
  a3[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a3 + 1), (uint64_t)v9);
  a3[7] = (uint64_t (**)())a3;
  result = (uint64_t)v11;
  if (v11)
  {
    result = (**(uint64_t (***)(_BYTE *))v11)(v11);
    if (v11 != v9)
      return (*((uint64_t (**)(uint64_t (**)()))*v10 + 5))(v10);
  }
  return result;
}

__objc2_class_ro *re::EventBus::getTypeId<RESceneEntityDidReparentEvent>()
{
  unsigned __int8 v0;
  __objc2_class_ro **p_info;
  int v3;
  const char *v4;

  p_info = VideoSpillMapMetalSession.info;
  if ((v0 & 1) == 0)
  {
    p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    if (v3)
    {
      re::EventBus::getTypeId<RESceneEntityDidReparentEvent>(void)const::s_id = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"29RESceneEntityDidReparentEvent" & 0x7FFFFFFFFFFFFFFFLL), v4);
      p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    }
  }
  return p_info[509];
}

_QWORD *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(_QWORD *a1)
{
  *a1 = &off_24ED2B8A8;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(_QWORD *a1)
{
  *a1 = &off_24ED2B8A8;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v5;

  v3 = *a3;
  v5 = *a2;
  (*(void (**)(_QWORD, uint64_t *, uint64_t))(**(_QWORD **)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), &v5, v3);
  return 1;
}

_QWORD *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED2B8A8;
  a2[4] = *(_QWORD *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

_QWORD *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED2B8A8;
  a2[4] = *(_QWORD *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

_QWORD *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(_QWORD *a1)
{
  *a1 = &off_24ED2B900;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(_QWORD *a1)
{
  *a1 = &off_24ED2B900;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v5;

  v3 = *a3;
  v5 = *a2;
  return (*(uint64_t (**)(_QWORD, uint64_t *, uint64_t))(**(_QWORD **)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), &v5, v3);
}

_QWORD *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED2B900;
  a2[4] = *(_QWORD *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

_QWORD *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED2B900;
  a2[4] = *(_QWORD *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityDidReparentEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::~CallableMemFn()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::operator()(_QWORD *a1, _QWORD *a2)
{
  uint64_t (*v2)(_QWORD *, _QWORD);
  uint64_t v3;
  _QWORD *v4;

  v2 = (uint64_t (*)(_QWORD *, _QWORD))a1[2];
  v3 = a1[3];
  v4 = (_QWORD *)(a1[1] + (v3 >> 1));
  if ((v3 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *, _QWORD))(*v4 + v2);
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED29D68;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24ED29D68;
  *(_QWORD *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::size()
{
  return 32;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidActivateEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7;
  _BYTE v9[24];
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)(a2 + 24);
  v11 = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v9, a2);
  v7 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidActivateEvent>(a1, 0, (uint64_t)v9, a3, a4);
  if (v11)
  {
    (**(void (***)(_BYTE *))v11)(v11);
    if (v11 != v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
  }
  return v7;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<RESceneEntityDidActivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;

  v5 = a2;
  if (!*(_BYTE *)(a2 + 371))
  {
    v3 = a1 + 200;
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v5);
    re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove(v3, &v5);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::~CallableMemFn()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::operator()(_QWORD *a1, _QWORD *a2)
{
  uint64_t (*v2)(_QWORD *, _QWORD);
  uint64_t v3;
  _QWORD *v4;

  v2 = (uint64_t (*)(_QWORD *, _QWORD))a1[2];
  v3 = a1[3];
  v4 = (_QWORD *)(a1[1] + (v3 >> 1));
  if ((v3 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *, _QWORD))(*v4 + v2);
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED29DC0;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24ED29DC0;
  *(_QWORD *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::size()
{
  return 32;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7;
  _BYTE v9[24];
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)(a2 + 24);
  v11 = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v9, a2);
  v7 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(a1, 0, (uint64_t)v9, a3, a4);
  if (v11)
  {
    (**(void (***)(_BYTE *))v11)(v11);
    if (v11 != v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
  }
  return v7;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::invalidateEntityHierarchyEventHandler<RESceneEntityWillDeactivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;

  v5 = a2;
  v3 = a1 + 200;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove(a1 + 104, &v5);
  re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(v3, &v5);
  return 0;
}

uint64_t re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::EventBus *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t Type;
  unint64_t EventInfo;
  uint64_t v12;
  uint64_t (**v14[6])();
  uint64_t v15;
  uint64_t (***v16)();
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  Type = re::EventBus::getTypeId<RESceneEntityWillDeactivateEvent>();
  EventInfo = re::EventBus::addOrGetEventInfo(a1, Type);
  re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(a3, a5, v14);
  v12 = re::EventBus::EventInfo::addSubscription(EventInfo, (uint64_t)v14, a2, a4);
  if (v16)
  {
    ((void (*)(uint64_t (***)()))**v16)(v16);
    if (v16 != v14)
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
  }
  return v12;
}

uint64_t re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>@<X0>(uint64_t a1@<X2>, char a2@<W4>, uint64_t (***a3)()@<X8>)
{
  re *v4;
  uint64_t v5;
  uint64_t (**v6)();
  re *v7;
  uint64_t result;
  _BYTE v9[24];
  uint64_t (**v10)();
  _BYTE *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v10 = *(uint64_t (***)())(a1 + 24);
  v11 = 0;
  if ((a2 & 1) != 0)
  {
    v7 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v9, a1);
    v5 = re::globalAllocators(v7)[2];
    v6 = &off_24ED2B968;
  }
  else
  {
    v4 = (re *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v9, a1);
    v5 = re::globalAllocators(v4)[2];
    v6 = &off_24ED2B9C0;
  }
  a3[6] = (uint64_t (**)())v5;
  a3[7] = 0;
  *a3 = v6;
  a3[4] = v10;
  a3[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a3 + 1), (uint64_t)v9);
  a3[7] = (uint64_t (**)())a3;
  result = (uint64_t)v11;
  if (v11)
  {
    result = (**(uint64_t (***)(_BYTE *))v11)(v11);
    if (v11 != v9)
      return (*((uint64_t (**)(uint64_t (**)()))*v10 + 5))(v10);
  }
  return result;
}

uint64_t re::EventBus::getTypeId<RESceneEntityWillDeactivateEvent>()
{
  unsigned __int8 v0;
  _QWORD *v1;
  int v3;
  const char *v4;

  if ((v0 & 1) == 0)
  {
    if (v3)
    {
      re::EventBus::getTypeId<RESceneEntityWillDeactivateEvent>(void)const::s_id = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"32RESceneEntityWillDeactivateEvent" & 0x7FFFFFFFFFFFFFFFLL), v4);
    }
  }
  return v1[1];
}

_QWORD *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(_QWORD *a1)
{
  *a1 = &off_24ED2B968;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::~Callable(_QWORD *a1)
{
  *a1 = &off_24ED2B968;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v5;

  v3 = *a3;
  v5 = *a2;
  (*(void (**)(_QWORD, uint64_t *, uint64_t))(**(_QWORD **)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), &v5, v3);
  return 1;
}

_QWORD *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED2B968;
  a2[4] = *(_QWORD *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

_QWORD *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED2B968;
  a2[4] = *(_QWORD *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#1},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

_QWORD *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(_QWORD *a1)
{
  *a1 = &off_24ED2B9C0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  return a1;
}

void re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::~Callable(_QWORD *a1)
{
  *a1 = &off_24ED2B9C0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(a1 + 1));
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::operator()(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v5;

  v3 = *a3;
  v5 = *a2;
  return (*(uint64_t (**)(_QWORD, uint64_t *, uint64_t))(**(_QWORD **)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), &v5, v3);
}

_QWORD *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED2B9C0;
  a2[4] = *(_QWORD *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

_QWORD *re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::moveInto(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED2B9C0;
  a2[4] = *(_QWORD *)(a1 + 32);
  a2[5] = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)(a2 + 1), a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::FixedFunction<48ul,REEventHandlerResult ()(void *,void const*)> re::EventBus::createHandler<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(re::ecs2::Entity *,re::Function<REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)> const&,void const*,re::EventBus::HandlerOptions)::{lambda(void *,void const*)#2},REEventHandlerResult ()(void *,void const*)>::size()
{
  return 48;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::~CallableMemFn()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::operator()(_QWORD *a1, _QWORD *a2)
{
  uint64_t (*v2)(_QWORD *, _QWORD);
  uint64_t v3;
  _QWORD *v4;

  v2 = (uint64_t (*)(_QWORD *, _QWORD))a1[2];
  v3 = a1[3];
  v4 = (_QWORD *)(a1[1] + (v3 >> 1));
  if ((v3 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *, _QWORD))(*v4 + v2);
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED29E18;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24ED29E18;
  *(_QWORD *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityRenderOptions>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::size()
{
  return 32;
}

uint64_t re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 80 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 16) = *a4;
  v14 = *(_QWORD *)(a1 + 16) + 80 * v10;
  *(_QWORD *)(v14 + 24) = 0;
  *(_QWORD *)(v14 + 32) = 0;
  v14 += 24;
  *(_DWORD *)(v14 + 16) = 1;
  *(_QWORD *)(v14 + 32) = 0;
  *(_QWORD *)(v14 + 40) = 0;
  *(_QWORD *)(v14 + 24) = 0;
  *(_DWORD *)(v14 + 48) = 0;
  re::BucketArray<RESubscriptionHandle,8ul>::swap(v14, a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, *(_QWORD *)&v13[16] + v10 + 24);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 80;
        }
        while (v11 < v9);
      }
      re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

void re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 80 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_402, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::addAsCopy(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, *(_QWORD *)&v13[16] + v10 + 16);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v6;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *a2;
  v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v6 + 80 * v4 + 16) != v2)
  {
    while (1)
    {
      LODWORD(v4) = *(_DWORD *)(v6 + 80 * v4 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v4 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v6 + 80 * v4 + 16) == v2)
        return v6 + 80 * v4 + 24;
    }
    return 0;
  }
  return v6 + 80 * v4 + 24;
}

void re::ecs2::VisualProxyScopeManager::~VisualProxyScopeManager(re::ecs2::VisualProxyScopeManager *this)
{
  re::ecs2::VisualProxyScopeManagerStateTracking::~VisualProxyScopeManagerStateTracking((re::ecs2::VisualProxyScopeManager *)((char *)this + 8));
}

{
  re::ecs2::VisualProxyScopeManagerStateTracking::~VisualProxyScopeManagerStateTracking((re::ecs2::VisualProxyScopeManager *)((char *)this + 8));
  JUMPOUT(0x2276933B8);
}

uint64_t re::ecs2::VisualProxyScopeManager::scopeDataPerEntity(re::ecs2::VisualProxyScopeManager *this)
{
  return (uint64_t)this + 64;
}

void re::ecs2::VisualProxyScopeManager::updateScopeMaskData(re::ecs2::VisualProxyScopeManager *this)
{
  char *v1;
  char *v2;

  v1 = (char *)this + 8;
  v2 = (char *)this + 112;
  (*(void (**)(char *, char *))(*((_QWORD *)this + 1) + 32))((char *)this + 8, (char *)this + 112);
  re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::clear((uint64_t)v2);
  re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::clear((uint64_t)(v1 + 200));
}

uint64_t re::ecs2::VisualProxyScopeManager::registerScene(re::ecs2::VisualProxyScopeManager *this, re::EventBus **a2)
{
  re::EventBus *v2;
  re *v3;
  re *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  re *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  re *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  re *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  re *v24;
  re *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  re *v30;
  re *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t result;
  _QWORD v38[2];
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  re::ecs2::Scene *v44;
  _BYTE v45[24];
  uint64_t v46;
  re *v47;
  uint64_t v48;

  v48 = *MEMORY[0x24BDAC8D0];
  v44 = (re::ecs2::Scene *)a2;
  v2 = a2[36];
  if (!v2)
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) An event bus is expected for this system to track entity state changes.", "eventBus", "registerScene", 100);
    _os_crash();
    __break(1u);
  }
  v38[0] = 0;
  v3 = (re::ecs2::VisualProxyScopeManager *)((char *)this + 8);
  v38[1] = 0;
  v39 = 1;
  v41 = 0;
  v42 = 0;
  v40 = 0;
  v43 = 0;
  v4 = (re *)(*(uint64_t (**)(re *))(*(_QWORD *)v3 + 16))(v3);
  if (v5)
  {
    v6 = (uint64_t *)v4;
    v7 = 8 * v5;
    do
    {
      v8 = *v6;
      v46 = re::globalAllocators(v4)[2];
      v9 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 32, 0);
      *(_QWORD *)v9 = &off_24ED29ED8;
      *((_QWORD *)v9 + 1) = v3;
      *((_QWORD *)v9 + 2) = re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<REComponentDidChangeEvent>;
      *((_QWORD *)v9 + 3) = 0;
      v47 = v9;
      v10 = re::EventBus::subscribe<re::ecs2::Entity,REComponentDidChangeEvent>(v2, (uint64_t)v45, v8, 0);
      v12 = v11;
      v13 = (_QWORD *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
      *v13 = v10;
      v13[1] = v12;
      if (v47)
      {
        (**(void (***)(re *))v47)(v47);
        if (v47 != (re *)v45)
          (*(void (**)(uint64_t))(*(_QWORD *)v46 + 40))(v46);
      }
      re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::subscribeToEventToInvalidateEntityHierarchy<REComponentDidActivateEvent>(v3, v2, (uint64_t)v38, v8);
      v4 = (re *)re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::subscribeToEventToInvalidateEntityHierarchy<REComponentWillDeactivateEvent>(v3, v2, (uint64_t)v38, v8);
      ++v6;
      v7 -= 8;
    }
    while (v7);
  }
  v14 = (re *)(*(uint64_t (**)(re *))(*(_QWORD *)v3 + 24))(v3);
  if (v15)
  {
    v16 = (uint64_t *)v14;
    v17 = 8 * v15;
    do
    {
      v18 = *v16++;
      re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::subscribeToEventToInvalidateEntityHierarchy<REComponentDidActivateEvent>(v3, v2, (uint64_t)v38, v18);
      v14 = (re *)re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::subscribeToEventToInvalidateEntityHierarchy<REComponentWillDeactivateEvent>(v3, v2, (uint64_t)v38, v18);
      v17 -= 8;
    }
    while (v17);
  }
  v46 = re::globalAllocators(v14)[2];
  v19 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 32, 0);
  *(_QWORD *)v19 = &off_24ED29FE0;
  *((_QWORD *)v19 + 1) = v3;
  *((_QWORD *)v19 + 2) = re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<RESceneEntityDidReparentEvent>;
  *((_QWORD *)v19 + 3) = 0;
  v47 = v19;
  v20 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidReparentEvent>(v2, (uint64_t)v45, 0, 0);
  v22 = v21;
  v23 = (_QWORD *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
  *v23 = v20;
  v23[1] = v22;
  v24 = v47;
  if (v47)
  {
    v24 = (re *)(**(uint64_t (***)(re *))v47)(v47);
    if (v47 != (re *)v45)
      v24 = (re *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v46 + 40))(v46);
  }
  v46 = re::globalAllocators(v24)[2];
  v25 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 32, 0);
  *(_QWORD *)v25 = &off_24ED2A038;
  *((_QWORD *)v25 + 1) = v3;
  *((_QWORD *)v25 + 2) = re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<RESceneEntityDidActivateEvent>;
  *((_QWORD *)v25 + 3) = 0;
  v47 = v25;
  v26 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityDidActivateEvent>(v2, (uint64_t)v45, 0, 0);
  v28 = v27;
  v29 = (_QWORD *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
  *v29 = v26;
  v29[1] = v28;
  v30 = v47;
  if (v47)
  {
    v30 = (re *)(**(uint64_t (***)(re *))v47)(v47);
    if (v47 != (re *)v45)
      v30 = (re *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v46 + 40))(v46);
  }
  v46 = re::globalAllocators(v30)[2];
  v31 = (re *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v46 + 32))(v46, 32, 0);
  *(_QWORD *)v31 = &off_24ED2A090;
  *((_QWORD *)v31 + 1) = v3;
  *((_QWORD *)v31 + 2) = re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<RESceneEntityWillDeactivateEvent>;
  *((_QWORD *)v31 + 3) = 0;
  v47 = v31;
  v32 = re::EventBus::subscribe<re::ecs2::Entity,RESceneEntityWillDeactivateEvent>(v2, (uint64_t)v45, 0, 0);
  v34 = v33;
  v35 = (_QWORD *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized((uint64_t)v38);
  *v35 = v32;
  v35[1] = v34;
  if (v47)
  {
    (**(void (***)(re *))v47)(v47);
    if (v47 != (re *)v45)
      (*(void (**)(uint64_t))(*(_QWORD *)v46 + 40))(v46);
  }
  re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::add((uint64_t)this + 160, (uint64_t *)&v44, (uint64_t)v38);
  re::HashSetBase<re::ecs2::Scene const*,re::ecs2::Scene const*,re::internal::ValueAsKey<re::ecs2::Scene const*>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::add((uint64_t)this + 16, (uint64_t *)&v44);
  re::BucketArray<RESubscriptionHandle,8ul>::deinit((uint64_t)v38);
  result = v38[0];
  if (v38[0])
  {
    if ((v39 & 1) == 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v38[0] + 40))();
  }
  return result;
}

uint64_t re::ecs2::VisualProxyScopeManager::unregisterScene(re::ecs2::VisualProxyScopeManager *this, re::ecs2::Scene *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t i;
  uint64_t v13;
  re::ecs2::Scene *v14;

  v14 = a2;
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove((uint64_t)this + 16, (uint64_t *)&v14);
  v3 = *((_QWORD *)v14 + 13);
  v4 = *(_QWORD *)(v3 + 328);
  if (v4)
  {
    v5 = *(_QWORD *)(v3 + 344);
    v6 = 8 * v4;
    do
    {
      if ((*(_BYTE *)(*(_QWORD *)v5 + 288) & 1) != 0)
        (*(void (**)(char *))(*((_QWORD *)this + 1) + 40))((char *)this + 8);
      v5 += 8;
      v6 -= 8;
    }
    while (v6);
  }
  v7 = (char *)this + 160;
  result = re::HashTable<re::ecs2::Scene const*,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet((uint64_t)v7, (uint64_t *)&v14);
  if (result)
  {
    v9 = *((_QWORD *)v14 + 36);
    if (v9)
    {
      v10 = result;
      v11 = *(_QWORD *)(result + 40);
      if (v11)
      {
        for (i = 0; i != v11; ++i)
        {
          v13 = re::BucketArray<RESubscriptionHandle,8ul>::operator[](v10, i);
          re::EventBus::unsubscribe(v9, *(_QWORD *)v13, *(_QWORD *)(v13 + 8));
        }
      }
    }
    return re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::remove((uint64_t)v7, (uint64_t *)&v14);
  }
  return result;
}

void re::ecs2::VisualProxyScopeManagerStateTracking::~VisualProxyScopeManagerStateTracking(re::ecs2::VisualProxyScopeManagerStateTracking *this)
{
  uint64_t v2;

  v2 = *((_QWORD *)this + 31);
  if (v2)
  {
    if (*((_QWORD *)this + 32))
    {
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 33));
      *((_QWORD *)this + 32) = 0;
      *((_QWORD *)this + 33) = 0;
    }
    *((_QWORD *)this + 31) = 0;
  }
  re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::~HierarchyStateTracking((uint64_t *)this);
}

{
  re::ecs2::VisualProxyScopeManagerStateTracking::~VisualProxyScopeManagerStateTracking(this);
  JUMPOUT(0x2276933B8);
}

uint64_t *re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::~HierarchyStateTracking(uint64_t *a1)
{
  uint64_t *v2;

  *a1 = (uint64_t)off_24ED2B868;
  v2 = a1 + 1;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 25);
  re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit(a1 + 19);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(a1 + 13);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit(a1 + 7);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v2);
  return a1;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::trackedComponents()
{
  return 0;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::trackedActivationComponents()
{
  return 0;
}

void re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::clearEntityHierarchyStateData(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[2];
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  _BYTE v17[120];

  if (*(_DWORD *)(a1 + 84))
  {
    re::StackScratchAllocator::StackScratchAllocator((re::StackScratchAllocator *)v17);
    v11[0] = 0;
    v11[1] = 0;
    v12 = 1;
    v14 = 0;
    v15 = 0;
    v13 = 0;
    v16 = 0;
    re::BucketArray<re::ecs2::Entity const*,32ul>::init((uint64_t)v11, (uint64_t)v17, 1uLL);
    *(_QWORD *)re::BucketArray<re::ecs2::Entity const*,32ul>::addUninitialized((uint64_t)v11) = a2;
    v4 = v15;
    if (v15)
    {
      v5 = a1 + 56;
      do
      {
        v10 = 0;
        v10 = *(_QWORD *)re::BucketArray<re::ecs2::Entity const*,32ul>::operator[]((uint64_t)v11, v4 - 1);
        re::BucketArray<re::ecs2::Entity const*,32ul>::operator[]((uint64_t)v11, --v15);
        ++v16;
        re::HashTable<re::ecs2::Entity const*,re::ecs2::EntityVisualProxyScopeData,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::remove(v5, &v10);
        v6 = *(_QWORD *)(v10 + 328);
        if (v6)
        {
          v7 = *(uint64_t **)(v10 + 344);
          v8 = 8 * v6;
          do
          {
            v9 = *v7++;
            *(_QWORD *)re::BucketArray<re::ecs2::Entity const*,32ul>::addUninitialized((uint64_t)v11) = v9;
            v8 -= 8;
          }
          while (v8);
        }
        v4 = v15;
      }
      while (v15);
    }
    re::BucketArray<re::ecs2::Entity const*,32ul>::deinit((uint64_t)v11);
    if (v11[0])
    {
      if ((v12 & 1) == 0)
        (*(void (**)(void))(*(_QWORD *)v11[0] + 40))();
    }
    re::StackScratchAllocator::~StackScratchAllocator((re::StackScratchAllocator *)v17);
  }
}

uint64_t re::HashTable<re::ecs2::Entity const*,re::ecs2::EntityVisualProxyScopeData,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::remove(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int *v15;
  int v16;
  int v17;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *a2;
  v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v4 = ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  v5 = *(_QWORD *)(a1 + 8);
  v6 = *(unsigned int *)(v5 + 4 * v4);
  if ((_DWORD)v6 == 0x7FFFFFFF)
    return 0;
  v8 = *(_QWORD *)(a1 + 16);
  v9 = v8 + 32 * v6;
  if (*(_QWORD *)(v9 + 16) != v2)
  {
    while (1)
    {
      v10 = v6;
      v6 = *(_DWORD *)(v8 + 32 * v6 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v6 == 0x7FFFFFFF)
        return 0;
      v11 = v8 + 32 * v6;
      if (*(_QWORD *)(v11 + 16) == v2)
      {
        *(_DWORD *)(v8 + 32 * v10 + 8) = *(_DWORD *)(v8 + 32 * v10 + 8) & 0x80000000 | *(_DWORD *)(v11 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v9 + 8) & 0x7FFFFFFF;
LABEL_9:
  v12 = *(_QWORD *)(a1 + 16);
  v13 = v12 + 32 * v6;
  v16 = *(_DWORD *)(v13 + 8);
  v15 = (int *)(v13 + 8);
  v14 = v16;
  if (v16 < 0)
  {
    *v15 = v14 & 0x7FFFFFFF;
    v12 = *(_QWORD *)(a1 + 16);
    v14 = *(_DWORD *)(v12 + 32 * v6 + 8);
  }
  v17 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v12 + 32 * v6 + 8) = *(_DWORD *)(a1 + 36) | v14 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v6;
  *(_DWORD *)(a1 + 40) = v17 + 1;
  return 1;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::subscribeToEventToInvalidateEntityHierarchy<REComponentDidActivateEvent>(re *a1, re::EventBus *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t result;
  _BYTE v14[24];
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v15 = re::globalAllocators(a1)[2];
  v8 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 32, 0);
  *v8 = &off_24ED29F30;
  v8[1] = a1;
  v8[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<REComponentDidActivateEvent>;
  v8[3] = 0;
  v16 = v8;
  v9 = re::EventBus::subscribe<re::ecs2::Entity,REComponentDidActivateEvent>(a2, (uint64_t)v14, a4, 0);
  v11 = v10;
  v12 = (_QWORD *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized(a3);
  *v12 = v9;
  v12[1] = v11;
  result = (uint64_t)v16;
  if (v16)
  {
    result = (**(uint64_t (***)(_BYTE *))v16)(v16);
    if (v16 != v14)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
  }
  return result;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::subscribeToEventToInvalidateEntityHierarchy<REComponentWillDeactivateEvent>(re *a1, re::EventBus *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t result;
  _BYTE v14[24];
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v15 = re::globalAllocators(a1)[2];
  v8 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v15 + 32))(v15, 32, 0);
  *v8 = &off_24ED29F88;
  v8[1] = a1;
  v8[2] = re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<REComponentWillDeactivateEvent>;
  v8[3] = 0;
  v16 = v8;
  v9 = re::EventBus::subscribe<re::ecs2::Entity,REComponentWillDeactivateEvent>(a2, (uint64_t)v14, a4, 0);
  v11 = v10;
  v12 = (_QWORD *)re::BucketArray<RESubscriptionHandle,8ul>::addUninitialized(a3);
  *v12 = v9;
  v12[1] = v11;
  result = (uint64_t)v16;
  if (v16)
  {
    result = (**(uint64_t (***)(_BYTE *))v16)(v16);
    if (v16 != v14)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
  }
  return result;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<REComponentDidChangeEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = a2;
  if (!*(_BYTE *)(a2 + 371)
    && (*(_BYTE *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::~CallableMemFn()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::operator()(_QWORD *a1, _QWORD *a2)
{
  uint64_t (*v2)(_QWORD *, _QWORD);
  uint64_t v3;
  _QWORD *v4;

  v2 = (uint64_t (*)(_QWORD *, _QWORD))a1[2];
  v3 = a1[3];
  v4 = (_QWORD *)(a1[1] + (v3 >> 1));
  if ((v3 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *, _QWORD))(*v4 + v2);
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED29ED8;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24ED29ED8;
  *(_QWORD *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidChangeEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidChangeEvent const&)>::size()
{
  return 32;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<REComponentDidActivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = a2;
  if (!*(_BYTE *)(a2 + 371)
    && (*(_BYTE *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::~CallableMemFn()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::operator()(_QWORD *a1, _QWORD *a2)
{
  uint64_t (*v2)(_QWORD *, _QWORD);
  uint64_t v3;
  _QWORD *v4;

  v2 = (uint64_t (*)(_QWORD *, _QWORD))a1[2];
  v3 = a1[3];
  v4 = (_QWORD *)(a1[1] + (v3 >> 1));
  if ((v3 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *, _QWORD))(*v4 + v2);
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED29F30;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24ED29F30;
  *(_QWORD *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentDidActivateEvent const&)>::size()
{
  return 32;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<REComponentWillDeactivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = a2;
  if (!*(_BYTE *)(a2 + 371)
    && (*(_BYTE *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::~CallableMemFn()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::operator()(_QWORD *a1, _QWORD *a2)
{
  uint64_t (*v2)(_QWORD *, _QWORD);
  uint64_t v3;
  _QWORD *v4;

  v2 = (uint64_t (*)(_QWORD *, _QWORD))a1[2];
  v3 = a1[3];
  v4 = (_QWORD *)(a1[1] + (v3 >> 1));
  if ((v3 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *, _QWORD))(*v4 + v2);
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED29F88;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24ED29F88;
  *(_QWORD *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,REComponentWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,REComponentWillDeactivateEvent const&)>::size()
{
  return 32;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<RESceneEntityDidReparentEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = a2;
  if (!*(_BYTE *)(a2 + 371)
    && (*(_BYTE *)(a2 + 288) & 1) != 0
    && !re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::contains(a1 + 200, &v4))
  {
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, v4);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v4);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::~CallableMemFn()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::operator()(_QWORD *a1, _QWORD *a2)
{
  uint64_t (*v2)(_QWORD *, _QWORD);
  uint64_t v3;
  _QWORD *v4;

  v2 = (uint64_t (*)(_QWORD *, _QWORD))a1[2];
  v3 = a1[3];
  v4 = (_QWORD *)(a1[1] + (v3 >> 1));
  if ((v3 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *, _QWORD))(*v4 + v2);
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED29FE0;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24ED29FE0;
  *(_QWORD *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidReparentEvent const&)>::size()
{
  return 32;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<RESceneEntityDidActivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;

  v5 = a2;
  if (!*(_BYTE *)(a2 + 371))
  {
    v3 = a1 + 200;
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
    re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(a1 + 104, &v5);
    re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove(v3, &v5);
  }
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::~CallableMemFn()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::operator()(_QWORD *a1, _QWORD *a2)
{
  uint64_t (*v2)(_QWORD *, _QWORD);
  uint64_t v3;
  _QWORD *v4;

  v2 = (uint64_t (*)(_QWORD *, _QWORD))a1[2];
  v3 = a1[3];
  v4 = (_QWORD *)(a1[1] + (v3 >> 1));
  if ((v3 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *, _QWORD))(*v4 + v2);
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED2A038;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24ED2A038;
  *(_QWORD *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityDidActivateEvent const&)>::size()
{
  return 32;
}

uint64_t re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::invalidateEntityHierarchyEventHandler<RESceneEntityWillDeactivateEvent>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;

  v5 = a2;
  v3 = a1 + 200;
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove(a1 + 104, &v5);
  re::HashSetBase<re::ecs2::Entity const*,re::ecs2::Entity const*,re::internal::ValueAsKey<re::ecs2::Entity const*>,re::Hash<re::ecs2::Entity const*>,re::EqualTo<re::ecs2::Entity const*>,true,false>::add(v3, &v5);
  return 0;
}

void re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::~CallableMemFn()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::operator()(_QWORD *a1, _QWORD *a2)
{
  uint64_t (*v2)(_QWORD *, _QWORD);
  uint64_t v3;
  _QWORD *v4;

  v2 = (uint64_t (*)(_QWORD *, _QWORD))a1[2];
  v3 = a1[3];
  v4 = (_QWORD *)(a1[1] + (v3 >> 1));
  if ((v3 & 1) != 0)
    v2 = *(uint64_t (**)(_QWORD *, _QWORD))(*v4 + v2);
  return v2(v4, *a2);
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::cloneInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED2A090;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::moveInto(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = &off_24ED2A090;
  *(_QWORD *)(a2 + 8) = v2;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::CallableMemFn<re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>,REEventHandlerResult (re::ecs2::HierarchyStateTracking<re::ecs2::EntityVisualProxyScopeData>::*)(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&),REEventHandlerResult ()(re::ecs2::Entity *,RESceneEntityWillDeactivateEvent const&)>::size()
{
  return 32;
}

void re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_0,void ()(re::Function<void ()(void)> const&)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_0,void ()(re::Function<void ()(void)> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  _BYTE v5[24];
  uint64_t v6;
  _BYTE *v7;
  _BYTE v8[24];
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a2 + 24);
  v7 = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v5, a2);
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 832);
  v9 = v6;
  v10 = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v8, (uint64_t)v5);
  re::ResourceFetchManager::executeWithMostRecentTransportVoucher(v3, (uint64_t)v8);
  if (v10)
  {
    (**(void (***)(_BYTE *))v10)(v10);
    if (v10 != v8)
      (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
  }
  result = (uint64_t)v7;
  if (v7)
  {
    result = (**(uint64_t (***)(_BYTE *))v7)(v7);
    if (v7 != v5)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
  }
  return result;
}

_QWORD *re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_0,void ()(re::Function<void ()(void)> const&)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A0E8;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_0,void ()(re::Function<void ()(void)> const&)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A0E8;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_0,void ()(re::Function<void ()(void)> const&)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_1,void ()(unsigned long long,re::Function<void ()(void)> const&)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_1,void ()(unsigned long long,re::Function<void ()(void)> const&)>::operator()(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  _BYTE v7[24];
  uint64_t v8;
  _BYTE *v9;
  _BYTE v10[24];
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  v4 = *a2;
  v8 = *(_QWORD *)(a3 + 24);
  v9 = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v7, a3);
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 832);
  v11 = v8;
  v12 = 0;
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v10, (uint64_t)v7);
  re::ResourceFetchManager::executeWithMostRecentTransportVoucherForPeerID(v5, v4, (uint64_t)v10);
  if (v12)
  {
    (**(void (***)(_BYTE *))v12)(v12);
    if (v12 != v10)
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 40))(v11);
  }
  result = (uint64_t)v9;
  if (v9)
  {
    result = (**(uint64_t (***)(_BYTE *))v9)(v9);
    if (v9 != v7)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
  }
  return result;
}

_QWORD *re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_1,void ()(unsigned long long,re::Function<void ()(void)> const&)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A150;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_1,void ()(unsigned long long,re::Function<void ()(void)> const&)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A150;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::init(re::EngineConfiguration const&)::$_1,void ()(unsigned long long,re::Function<void ()(void)> const&)>::size()
{
  return 16;
}

uint64_t re::DynamicArray<re::Scheduler::TaskDescriptor>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = v4 << 7;
        do
        {
          v6 = *(_QWORD *)(v3 + 88);
          if (v6)
          {
            if (*(_QWORD *)(v3 + 120))
              (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
            *(_QWORD *)(v3 + 120) = 0;
            *(_QWORD *)(v3 + 96) = 0;
            *(_QWORD *)(v3 + 104) = 0;
            *(_QWORD *)(v3 + 88) = 0;
            ++*(_DWORD *)(v3 + 112);
          }
          re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v3 + 40);
          re::StringID::destroyString((re::StringID *)v3);
          v3 += 128;
          v5 -= 128;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::Scheduler::TaskDescriptor>::add(_anonymous_namespace_ *this, uint64_t *a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::Scheduler::TaskDescriptor>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + (v4 << 7);
  v6 = *a2;
  *(_QWORD *)v5 = *(_QWORD *)v5 & 0xFFFFFFFFFFFFFFFELL | *a2 & 1;
  *(_QWORD *)v5 = *a2 & 0xFFFFFFFFFFFFFFFELL | v6 & 1;
  *(_QWORD *)(v5 + 8) = a2[1];
  *a2 = 0;
  a2[1] = (uint64_t)&str_110;
  v7 = *((_OWORD *)a2 + 1);
  *(_QWORD *)(v5 + 29) = *(uint64_t *)((char *)a2 + 29);
  *(_OWORD *)(v5 + 16) = v7;
  *(_QWORD *)(v5 + 64) = a2[8];
  *(_QWORD *)(v5 + 72) = 0;
  result = re::FunctionBase<24ul,void ()(void)>::operator=<24ul>(v5 + 40, (uint64_t)(a2 + 5));
  v9 = a2[10];
  *(_QWORD *)(v5 + 120) = 0;
  *(_DWORD *)(v5 + 112) = 0;
  *(_QWORD *)(v5 + 96) = 0;
  *(_QWORD *)(v5 + 104) = 0;
  *(_QWORD *)(v5 + 80) = v9;
  *(_QWORD *)(v5 + 88) = 0;
  v10 = a2[12];
  *(_QWORD *)(v5 + 88) = a2[11];
  *(_QWORD *)(v5 + 96) = v10;
  a2[11] = 0;
  a2[12] = 0;
  v11 = *(_QWORD *)(v5 + 104);
  *(_QWORD *)(v5 + 104) = a2[13];
  a2[13] = v11;
  v12 = *(_QWORD *)(v5 + 120);
  *(_QWORD *)(v5 + 120) = a2[15];
  a2[15] = v12;
  ++*((_DWORD *)a2 + 28);
  ++*(_DWORD *)(v5 + 112);
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

_QWORD *re::DynamicArray<re::Scheduler::TaskDescriptor>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::Scheduler::TaskDescriptor>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Scheduler::TaskDescriptor>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::Scheduler::TaskDescriptor>::setCapacity(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::Scheduler::TaskDescriptor>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 57)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 128, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = a2 << 7;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, a2 << 7, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (uint64_t *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = v9 << 7;
        v11 = (uint64_t)v7;
        do
        {
          re::ObjectHelper::move<re::Scheduler::TaskDescriptor>(v8, v11);
          v8 += 16;
          v11 += 128;
          v10 -= 128;
        }
        while (v10);
        v8 = (uint64_t *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::ObjectHelper::move<re::Scheduler::TaskDescriptor>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v4 = *a1;
  *(_QWORD *)a2 = *(_QWORD *)a2 & 0xFFFFFFFFFFFFFFFELL | *a1 & 1;
  *(_QWORD *)a2 = *a1 & 0xFFFFFFFFFFFFFFFELL | v4 & 1;
  *(_QWORD *)(a2 + 8) = a1[1];
  *a1 = 0;
  a1[1] = (uint64_t)&str_110;
  v5 = *((_OWORD *)a1 + 1);
  *(_QWORD *)(a2 + 29) = *(uint64_t *)((char *)a1 + 29);
  *(_OWORD *)(a2 + 16) = v5;
  *(_QWORD *)(a2 + 64) = a1[8];
  *(_QWORD *)(a2 + 72) = 0;
  re::FunctionBase<24ul,void ()(void)>::operator=<24ul>(a2 + 40, (uint64_t)(a1 + 5));
  v6 = a1[10];
  *(_QWORD *)(a2 + 120) = 0;
  *(_DWORD *)(a2 + 112) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 104) = 0;
  *(_QWORD *)(a2 + 80) = v6;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 88) = a1[11];
  a1[11] = 0;
  v7 = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a2 + 120) = a1[15];
  v8 = a1[11];
  *(_QWORD *)(a2 + 96) = a1[12];
  a1[12] = 0;
  v9 = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = a1[13];
  ++*((_DWORD *)a1 + 28);
  ++*(_DWORD *)(a2 + 112);
  a1[13] = v9;
  a1[15] = v7;
  if (v8)
  {
    if (v7)
      (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
    a1[15] = 0;
    a1[12] = 0;
    a1[13] = 0;
    a1[11] = 0;
    ++*((_DWORD *)a1 + 28);
  }
  re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)(a1 + 5));
  re::StringID::destroyString((re::StringID *)a1);
}

void re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::operator()(re::ProfilerConfig *a1)
{
  re *isStatisticCollectionEnabled;
  re::ProfilerThreadContext *v3;
  re *v4;
  re::ProfilerThreadContext *v5;
  uint64_t result;

  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(a1);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v3 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::begin(v3, *(re::ProfilerManager **)(*((_QWORD *)a1 + 1) + 952), 1);
  }
  v4 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if ((_DWORD)v4)
  {
    v5 = (re::ProfilerThreadContext *)re::profilerThreadContext(v4);
    re::ProfilerThreadContext::pushTimeScope(v5);
  }
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  result = re::internal::enableSignposts(0, 0);
  if ((_DWORD)result)
    return kdebug_trace();
  return result;
}

_QWORD *re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A1B8;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A1B8;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::size()
{
  return 16;
}

void re::ProfilerThreadContext::pushTimeScope(re::ProfilerThreadContext *this)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t *v13;
  char *v14;
  uint64_t v15;

  if (*((_QWORD *)this + 19))
  {
    v2 = mach_absolute_time();
    v3 = v2;
    v4 = *((_QWORD *)this + 17);
    v5 = (char *)*((_QWORD *)this + 16);
    if ((unint64_t)v5 >= v4)
    {
      v7 = (char *)*((_QWORD *)this + 15);
      v8 = (v5 - v7) >> 3;
      v9 = v8 + 1;
      if ((unint64_t)(v8 + 1) >> 61)
        abort();
      v10 = v4 - (_QWORD)v7;
      if (v10 >> 2 > v9)
        v9 = v10 >> 2;
      if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
        v11 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v11 = v9;
      if (v11)
      {
        v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>((uint64_t)this + 136, v11);
        v7 = (char *)*((_QWORD *)this + 15);
        v5 = (char *)*((_QWORD *)this + 16);
      }
      else
      {
        v12 = 0;
      }
      v13 = (uint64_t *)&v12[8 * v8];
      v14 = &v12[8 * v11];
      *v13 = v3;
      v6 = v13 + 1;
      while (v5 != v7)
      {
        v15 = *((_QWORD *)v5 - 1);
        v5 -= 8;
        *--v13 = v15;
      }
      *((_QWORD *)this + 15) = v13;
      *((_QWORD *)this + 16) = v6;
      *((_QWORD *)this + 17) = v14;
      if (v7)
        operator delete(v7);
    }
    else
    {
      *(_QWORD *)v5 = v2;
      v6 = v5 + 8;
    }
    *((_QWORD *)this + 16) = v6;
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long long>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(8 * a2);
}

void re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::operator()(uint64_t a1)
{
  uint64_t v2;
  re::ProfilerConfig *v3;
  re *isStatisticCollectionEnabled;
  uint64_t v5;
  int64x2_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int64x2_t v10;

  v2 = **(_QWORD **)(a1 + 16);
  v3 = (re::ProfilerConfig *)mach_absolute_time();
  **(_QWORD **)(a1 + 16) = v3;
  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(v3);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v5 = re::profilerThreadContext(isStatisticCollectionEnabled);
    v6 = *(int64x2_t **)(v5 + 152);
    if (v6)
    {
      v7 = **(_QWORD **)(a1 + 16) - v2;
      v8 = v6[8].u64[0];
      v9 = v6[8].u64[1];
      if (v8 >= v7)
        v8 = **(_QWORD **)(a1 + 16) - v2;
      if (v9 <= v7)
        v9 = **(_QWORD **)(a1 + 16) - v2;
      v6[8].i64[0] = v8;
      v6[8].i64[1] = v9;
      v10 = vdupq_n_s64(1uLL);
      v10.i64[0] = v7;
      v6[9] = vaddq_s64(v6[9], v10);
      *(_BYTE *)(v5 + 184) = 0;
    }
  }
  return re::FrameManager::nextFrame(*(re::FrameManager **)(a1 + 8));
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2A210;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2A210;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::size()
{
  return 24;
}

int64x2_t re::ProfilerThreadContext::addStatistic(uint64_t a1, unsigned int a2, unint64_t a3)
{
  uint64_t v3;
  int64x2_t *v4;
  unint64_t v5;
  unint64_t v6;
  int64x2_t v7;
  int64x2_t result;

  v3 = *(_QWORD *)(a1 + 152);
  if (v3)
  {
    v4 = (int64x2_t *)(v3 + ((unint64_t)a2 << 6));
    v5 = v4[4].u64[0];
    v6 = v4[4].u64[1];
    if (v5 >= a3)
      v5 = a3;
    if (v6 <= a3)
      v6 = a3;
    v4[4].i64[0] = v5;
    v4[4].i64[1] = v6;
    v7 = vdupq_n_s64(1uLL);
    v7.i64[0] = a3;
    result = vaddq_s64(v4[5], v7);
    v4[5] = result;
    *(_BYTE *)(a1 + 184) = 0;
  }
  return result;
}

void re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 40))(*(_QWORD *)(a1 + 8));
}

_QWORD *re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A268;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A268;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::operator()()
{
  uint64_t v0;
  re *isStatisticCollectionEnabled;
  uint64_t v2;
  re *v3;
  re::ProfilerThreadContext *v4;

  v0 = re::internal::enableSignposts(0, 0);
  if ((_DWORD)v0)
    v0 = kdebug_trace();
  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v0);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v2 = re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::popTimeScope(v2, 2u);
  }
  v3 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if ((_DWORD)v3)
  {
    v4 = (re::ProfilerThreadContext *)re::profilerThreadContext(v3);
    re::ProfilerThreadContext::end(v4);
  }
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2A2C0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2A2C0;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::size()
{
  return 24;
}

double re::ProfilerThreadContext::popTimeScope(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  double result;

  if (*(_QWORD *)(a1 + 152))
  {
    v4 = mach_absolute_time();
    v5 = *(_QWORD *)(a1 + 128);
    v6 = v4 - *(_QWORD *)(v5 - 8);
    *(_QWORD *)(a1 + 128) = v5 - 8;
    *(_QWORD *)&result = re::ProfilerThreadContext::addStatistic(a1, a2, v6).u64[0];
  }
  return result;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::operator()(re::ProfilerConfig *a1)
{
  re *isStatisticCollectionEnabled;
  re::ProfilerThreadContext *v3;
  re *v4;
  re::ProfilerThreadContext *v5;
  uint64_t result;

  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(a1);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v3 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::begin(v3, *(re::ProfilerManager **)(*((_QWORD *)a1 + 1) + 952), 1);
  }
  v4 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if ((_DWORD)v4)
  {
    v5 = (re::ProfilerThreadContext *)re::profilerThreadContext(v4);
    re::ProfilerThreadContext::pushTimeScope(v5);
  }
  result = re::internal::enableSignposts(0, 0);
  if ((_DWORD)result)
    return kdebug_trace();
  return result;
}

_QWORD *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A318;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A318;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

double re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::operator()(uint64_t a1)
{
  uint64_t v1;
  __int128 v2;
  __int128 v3;
  double result;
  __int128 v5;
  __int128 v6;

  v1 = *(_QWORD *)(a1 + 8);
  *(_WORD *)(v1 + 8) = 0;
  v2 = *(_OWORD *)(v1 + 64);
  *(_OWORD *)(v1 + 80) = *(_OWORD *)(v1 + 48);
  *(_OWORD *)(v1 + 96) = v2;
  v3 = *(_OWORD *)(v1 + 32);
  *(_OWORD *)(v1 + 48) = *(_OWORD *)(v1 + 16);
  *(_OWORD *)(v1 + 64) = v3;
  *(_OWORD *)(v1 + 168) = *(_OWORD *)(v1 + 140);
  *(_OWORD *)(v1 + 180) = *(_OWORD *)(v1 + 152);
  *(_OWORD *)(v1 + 140) = *(_OWORD *)(v1 + 112);
  *(_OWORD *)(v1 + 152) = *(_OWORD *)(v1 + 124);
  result = 0.0;
  *(_QWORD *)(v1 + 112) = 0;
  *(_DWORD *)(v1 + 120) = 0;
  v5 = *(_OWORD *)(v1 + 216);
  *(_WORD *)(v1 + 252) = *(_WORD *)(v1 + 232);
  *(_OWORD *)(v1 + 236) = v5;
  v6 = *(_OWORD *)(v1 + 196);
  *(_WORD *)(v1 + 232) = *(_WORD *)(v1 + 212);
  *(_OWORD *)(v1 + 216) = v6;
  *(_QWORD *)(v1 + 196) = 0;
  return result;
}

_QWORD *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A370;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A370;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::operator()(uint64_t a1)
{
  re::SharedClockManager::update(*(os_unfair_lock_s **)(a1 + 8));
}

_QWORD *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A3C8;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A3C8;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::operator()(uint64_t a1, float *a2)
{
  re::TimebaseManager::beforeFrameUpdate(*(re::TimebaseManager **)(a1 + 8), *a2);
}

_QWORD *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A420;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A420;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::operator()(uint64_t a1)
{
  re::NetworkSystem::beforeFrameUpdate(*(re::NetworkSystem **)(a1 + 8));
}

_QWORD *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A478;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A478;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::operator()(uint64_t a1)
{
  re::BackgroundTaskManager::update(*(re::BackgroundTaskManager **)(a1 + 8));
}

_QWORD *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A4D0;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A4D0;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::operator()(uint64_t a1)
{
  return re::AssetManager::update(*(re::AssetManager **)(a1 + 8), 1u, 0);
}

_QWORD *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A528;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A528;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::operator()(uint64_t a1, float *a2)
{
  if (!*(_BYTE *)(*(_QWORD *)(a1 + 8) + 356))
  {
    re::AnimationManager::update(*(re::AnimationManager **)(a1 + 16), *a2);
    re::AnimationManager::applyAnimations(*(re::AnimationManager **)(a1 + 16));
  }
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2A580;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2A580;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::size()
{
  return 24;
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::operator()()
{
  uint64_t v0;
  re *isStatisticCollectionEnabled;
  uint64_t v2;
  re *v3;
  re::ProfilerThreadContext *v4;

  v0 = re::internal::enableSignposts(0, 0);
  if ((_DWORD)v0)
    v0 = kdebug_trace();
  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v0);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v2 = re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::popTimeScope(v2, 3u);
  }
  v3 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if ((_DWORD)v3)
  {
    v4 = (re::ProfilerThreadContext *)re::profilerThreadContext(v3);
    re::ProfilerThreadContext::end(v4);
  }
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2A5D8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2A5D8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configurePreparePhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::size()
{
  return 24;
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::operator()(re::ProfilerConfig *a1)
{
  re *isStatisticCollectionEnabled;
  re::ProfilerThreadContext *v3;
  re *v4;
  re::ProfilerThreadContext *v5;
  uint64_t result;

  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(a1);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v3 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::begin(v3, *(re::ProfilerManager **)(*((_QWORD *)a1 + 1) + 952), 1);
  }
  v4 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if ((_DWORD)v4)
  {
    v5 = (re::ProfilerThreadContext *)re::profilerThreadContext(v4);
    re::ProfilerThreadContext::pushTimeScope(v5);
  }
  result = re::internal::enableSignposts(0, 0);
  if ((_DWORD)result)
    return kdebug_trace();
  return result;
}

_QWORD *re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A630;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A630;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::operator()(uint64_t a1)
{
  _QWORD **v1;

  v1 = *(_QWORD ***)(a1 + 8);
  (*(void (**)(_QWORD *))(*v1[115] + 56))(v1[115]);
  return ((uint64_t (*)(_QWORD **))(*v1)[6])(v1);
}

_QWORD *re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A688;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A688;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::operator()(uint64_t a1, float *a2)
{
  re::ecs2::ThrottleManager::update(*(re::ecs2::ThrottleManager **)(a1 + 8), *a2);
}

_QWORD *re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A6E0;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A6E0;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::operator()(_QWORD *a1, float *a2)
{
  uint64_t v2;
  uint64_t v3;
  float v5;
  uint64_t *v6;
  uint64_t *v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v14;
  re::PhysicsSimulation *v15;
  uint64_t v16;
  float v17;
  uint64_t v20;
  uint64_t v21;

  v2 = a1[1];
  if (!*(_BYTE *)(v2 + 356))
  {
    v3 = *(_QWORD *)(v2 + 224);
    if (v3)
    {
      v5 = *a2;
      v6 = *(uint64_t **)(v2 + 240);
      v7 = &v6[v3];
      v8 = 3.4028e38;
      do
      {
        v9 = a1[2];
        v20 = *v6;
        v10 = re::HashTable<re::ecs2::Scene const*,re::DataArray<re::ecs2::PhysicsSimulationData>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet(v9 + 432, &v20);
        if (v10)
        {
          v11 = v10;
          re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::DataArrayIterator((uint64_t)&v20, v10, 0);
          v12 = v11 == v20 && (unsigned __int16)v21 == 0xFFFFLL;
          if (!v12 || (v21 & 0xFFFF0000) != 4294901760)
          {
            do
            {
              v14 = re::DataArray<re::ecs2::PhysicsSimulationData>::DataArrayIterator<re::ecs2::PhysicsSimulationData,re::ecs2::PhysicsSimulationData&>::operator*((unsigned __int16 *)&v20);
              v15 = *(re::PhysicsSimulation **)(v14 + 8);
              if (v15)
              {
                re::PhysicsSimulation::update(v15, v5);
                if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(v14 + 8) + 104))(*(_QWORD *)(v14 + 8)))
                {
                  v16 = *(_QWORD *)(v14 + 8);
                  v17 = *(double *)(v16 + 888);
                  if ((float)(*(float *)(v16 + 68) - v17) <= v8)
                    v8 = *(float *)(v16 + 68) - v17;
                }
              }
              re::DataArray<re::RigGraphOperatorDefinition>::DataArrayIterator<re::RigGraphOperatorDefinition,re::RigGraphOperatorDefinition&>::increment(&v20);
            }
            while (v20 != v11 || (unsigned __int16)v21 != 0xFFFF || WORD1(v21) != 0xFFFF);
          }
        }
        ++v6;
      }
      while (v6 != v7);
      if (v8 != 3.4028e38)
        re::Scheduler::enqueueTaskWithDeadline(*(re::Scheduler **)(a1[3] + 680), *(_QWORD *)(a1[3] + 216), v8);
    }
  }
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::cloneInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED2A738;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED2A738;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::size()
{
  return 32;
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::operator()()
{
  uint64_t v0;
  re *isStatisticCollectionEnabled;
  uint64_t v2;
  re *v3;
  re::ProfilerThreadContext *v4;

  v0 = re::internal::enableSignposts(0, 0);
  if ((_DWORD)v0)
    v0 = kdebug_trace();
  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v0);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v2 = re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::popTimeScope(v2, 4u);
  }
  v3 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if ((_DWORD)v3)
  {
    v4 = (re::ProfilerThreadContext *)re::profilerThreadContext(v3);
    re::ProfilerThreadContext::end(v4);
  }
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2A790;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2A790;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureSimulatePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::size()
{
  return 24;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::operator()(re::ProfilerConfig *a1)
{
  re *isStatisticCollectionEnabled;
  re::ProfilerThreadContext *v3;
  re *v4;
  re::ProfilerThreadContext *v5;
  uint64_t result;

  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(a1);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v3 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::begin(v3, *(re::ProfilerManager **)(*((_QWORD *)a1 + 1) + 952), 1);
  }
  v4 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if ((_DWORD)v4)
  {
    v5 = (re::ProfilerThreadContext *)re::profilerThreadContext(v4);
    re::ProfilerThreadContext::pushTimeScope(v5);
  }
  result = re::internal::enableSignposts(0, 0);
  if ((_DWORD)result)
    return kdebug_trace();
  return result;
}

_QWORD *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A7E8;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A7E8;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::size()
{
  return 16;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable(uint64_t a1)
{

  return a1;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable(uint64_t a1)
{

  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::operator()()
{
  return DRContextCommit();
}

_QWORD *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(void **)(a1 + 16);
  *a2 = &off_24ED2A840;
  a2[1] = v3;
  a2[2] = v4;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  __int128 v2;

  *(_QWORD *)a2 = &off_24ED2A840;
  v2 = *(_OWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_OWORD *)(a2 + 8) = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::size()
{
  return 24;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8));
}

_QWORD *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A898;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A898;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::operator()(uint64_t a1)
{
  return re::AssetManager::afterFrameUpdate(*(re::AssetManager **)(a1 + 8));
}

_QWORD *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A8F0;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A8F0;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::operator()(uint64_t a1)
{
  re::NetworkSystem::afterFrameUpdate(*(re::NetworkSystem **)(a1 + 8));
}

_QWORD *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A948;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A948;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::operator()(uint64_t a1)
{
  re::TimebaseManager::afterFrameUpdate(*(os_unfair_lock_s **)(a1 + 8));
}

_QWORD *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A9A0;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A9A0;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_5,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 48))(*(_QWORD *)(a1 + 8));
}

_QWORD *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A9F8;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2A9F8;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_6,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::operator()(uint64_t a1)
{
  re::Engine::performColorManagerAfterFrameUpdate(*(re::Engine **)(a1 + 8));
}

_QWORD *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AA50;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AA50;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_7,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::operator()()
{
  uint64_t v0;
  re *isStatisticCollectionEnabled;
  uint64_t v2;
  re *v3;
  re::ProfilerThreadContext *v4;

  v0 = re::internal::enableSignposts(0, 0);
  if ((_DWORD)v0)
    v0 = kdebug_trace();
  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v0);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v2 = re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::popTimeScope(v2, 5u);
  }
  v3 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(isStatisticCollectionEnabled);
  if ((_DWORD)v3)
  {
    v4 = (re::ProfilerThreadContext *)re::profilerThreadContext(v3);
    re::ProfilerThreadContext::end(v4);
  }
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2AAA8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2AAA8;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_8,void ()(float)>::size()
{
  return 24;
}

void re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::operator()(re::ProfilerManager **a1)
{
  re *isStatisticCollectionEnabled;
  re::ProfilerThreadContext *v3;

  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)a1);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v3 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::begin(v3, a1[1], 1);
  }
}

_QWORD *re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AB00;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AB00;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

int64x2_t re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::operator()(uint64_t a1)
{
  uint64_t v1;
  _QWORD **v2;
  re::ProfilerConfig *v3;
  int64x2_t result;
  re *isStatisticCollectionEnabled;
  uint64_t v6;
  uint64_t v7;
  int64x2_t *v8;
  uint64_t v9;
  uint64_t v10;
  int64x2_t v11;
  _BYTE v12[16];

  v2 = *(_QWORD ***)(a1 + 8);
  v3 = (re::ProfilerConfig *)(*(uint64_t (**)(_QWORD *))(*v2[115] + 104))(v2[115]);
  if (!(_DWORD)v3)
  {
    isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(v3);
    if ((_DWORD)isStatisticCollectionEnabled)
    {
      v6 = re::profilerThreadContext(isStatisticCollectionEnabled);
      if (*(_QWORD *)(v6 + 152))
        v1 = mach_absolute_time();
    }
    else
    {
      v6 = 0;
    }
    if (re::internal::enableSignposts(0, 0))
      kdebug_trace();
    re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v12, 1520, (uint64_t)v2);
    ((void (*)(_QWORD **))(*v2)[7])(v2);
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v12);
    if (v6)
    {
      if (*(_QWORD *)(v6 + 152))
      {
        v7 = mach_absolute_time();
        v8 = *(int64x2_t **)(v6 + 152);
        if (v8)
        {
          v9 = v8[28].u64[0];
          v10 = v8[28].u64[1];
          if (v9 >= v7 - v1)
            v9 = v7 - v1;
          if (v10 <= v7 - v1)
            v10 = v7 - v1;
          v8[28].i64[0] = v9;
          v8[28].i64[1] = v10;
          v11 = vdupq_n_s64(1uLL);
          v11.i64[0] = v7 - v1;
          result = vaddq_s64(v8[29], v11);
          v8[29] = result;
          *(_BYTE *)(v6 + 184) = 0;
        }
      }
    }
  }
  return result;
}

_QWORD *re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AB58;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AB58;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::operator()(re::ProfilerConfig *a1)
{
  re *isStatisticCollectionEnabled;
  re::ProfilerThreadContext *v2;

  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(a1);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v2 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::end(v2);
  }
}

_QWORD *re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  _QWORD *result;

  result = a2;
  *a2 = &off_24ED2ABB0;
  return result;
}

_QWORD *re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  _QWORD *result;

  result = a2;
  *a2 = &off_24ED2ABB0;
  return result;
}

uint64_t re::internal::Callable<re::Engine::configureRenderPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::operator()(re::ProfilerConfig *a1)
{
  re *isStatisticCollectionEnabled;
  re::ProfilerThreadContext *v2;
  uint64_t result;

  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(a1);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v2 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::pushTimeScope(v2);
  }
  result = re::internal::enableSignposts(0, 0);
  if ((_DWORD)result)
    return kdebug_trace();
  return result;
}

_QWORD *re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AC08;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AC08;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::operator()(uint64_t a1)
{
  dispatch_async(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 8) + 432), *(dispatch_block_t *)(*(_QWORD *)(a1 + 8) + 1400));
}

_QWORD *re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AC60;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AC60;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

double re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::operator()()
{
  uint64_t v0;
  re *isStatisticCollectionEnabled;
  double result;
  uint64_t v3;

  v0 = re::internal::enableSignposts(0, 0);
  if ((_DWORD)v0)
    v0 = kdebug_trace();
  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v0);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v3 = re::profilerThreadContext(isStatisticCollectionEnabled);
    return re::ProfilerThreadContext::popTimeScope(v3, 7u);
  }
  return result;
}

_QWORD *re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2ACB8;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2ACB8;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureEndTickPhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::operator()(re::ProfilerConfig *a1)
{
  re *isStatisticCollectionEnabled;
  re::ProfilerThreadContext *v3;
  uint64_t result;

  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled(a1);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v3 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::begin(v3, *(re::ProfilerManager **)(*((_QWORD *)a1 + 1) + 952), 1);
  }
  result = re::internal::enableSignposts(0, 0);
  if ((_DWORD)result)
    return kdebug_trace();
  return result;
}

_QWORD *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AD10;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AD10;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_0,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

re::FrameProfiler *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::operator()(uint64_t a1)
{
  re::FrameProfiler *result;

  result = *(re::FrameProfiler **)(a1 + 8);
  if (*((_BYTE *)result + 204))
  {
    if (!*((_BYTE *)result + 17))
      return (re::FrameProfiler *)re::FrameProfiler::frameUpdateFinished(result);
  }
  return result;
}

_QWORD *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AD68;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AD68;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_1,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::operator()(uint64_t a1)
{
  uint64_t v2;
  re *isStatisticCollectionEnabled;
  re::ProfilerThreadContext *v4;
  _OWORD v6[2];
  int v7;

  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  memset(v6, 0, sizeof(v6));
  v7 = 1065353216;
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  v2 = re::internal::enableSignposts(0, 0);
  if ((_DWORD)v2)
    v2 = kdebug_trace();
  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v2);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v4 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::end(v4);
  }
  re::ProfilerManager::process(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 952), v6);
  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  return std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)v6);
}

_QWORD *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2ADC0;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2ADC0;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_2,void ()(float)>::size()
{
  return 16;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::operator()(uint64_t a1)
{
  uint64_t v2;
  re *isStatisticCollectionEnabled;
  re::ProfilerThreadContext *v4;
  uint64_t v5;
  uint64_t result;
  _OWORD v7[2];
  int v8;

  if (re::internal::enableSignposts(0, 0))
    kdebug_trace();
  v2 = re::internal::enableSignposts(0, 0);
  if ((_DWORD)v2)
    v2 = kdebug_trace();
  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v2);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v4 = (re::ProfilerThreadContext *)re::profilerThreadContext(isStatisticCollectionEnabled);
    re::ProfilerThreadContext::end(v4);
  }
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 952);
  memset(v7, 0, sizeof(v7));
  v8 = 1065353216;
  re::ProfilerManager::process(v5, v7);
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::~__hash_table((uint64_t)v7);
  result = re::internal::enableSignposts(0, 0);
  if ((_DWORD)result)
    return kdebug_trace();
  return result;
}

_QWORD *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AE18;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AE18;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_3,void ()(float)>::size()
{
  return 16;
}

void re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::~Callable()
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::operator()(uint64_t result)
{
  *(_QWORD *)(*(_QWORD *)(result + 8) + 1176) = 0xBFF0000000000000;
  return result;
}

_QWORD *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::cloneInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AE70;
  a2[1] = v2;
  return a2;
}

_QWORD *re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::moveInto(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  *a2 = &off_24ED2AE70;
  a2[1] = v2;
  return a2;
}

uint64_t re::internal::Callable<re::Engine::configureExitFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,void ()(float)>::size()
{
  return 16;
}

uint64_t re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 8 * v4;
        do
        {
          if (*(_QWORD *)v3)
          {

            *(_QWORD *)v3 = 0;
          }
          v3 += 8;
          v5 -= 8;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::HashTable<re::ecs2::Scene const*,re::DataArray<re::ecs2::PhysicsSimulationData>,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,true,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v6;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *a2;
  v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v6 + 88 * v4 + 16) != v2)
  {
    while (1)
    {
      LODWORD(v4) = *(_DWORD *)(v6 + 88 * v4 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v4 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v6 + 88 * v4 + 16) == v2)
        return v6 + 88 * v4 + 24;
    }
    return 0;
  }
  return v6 + 88 * v4 + 24;
}

uint64_t *re::Event<re::Engine>::~Event(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *a1;
  if (v2)
  {
    if (a1[4])
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    a1[4] = 0;
    a1[1] = 0;
    a1[2] = 0;
    *a1 = 0;
    ++*((_DWORD *)a1 + 6);
  }
  v3 = a1[5];
  if (v3)
  {
    if (a1[9])
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v3 + 40))(v3);
      v4 = *a1;
    }
    else
    {
      v4 = 0;
    }
    a1[9] = 0;
    a1[6] = 0;
    a1[7] = 0;
    a1[5] = 0;
    ++*((_DWORD *)a1 + 16);
    if (v4)
    {
      if (a1[4])
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
      a1[4] = 0;
      a1[1] = 0;
      a1[2] = 0;
      *a1 = 0;
      ++*((_DWORD *)a1 + 6);
    }
  }
  return a1;
}

uint64_t re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::add(uint64_t a1, uint64_t *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unint64_t v16;
  char v17;

  v4 = re::internal::ServiceKeyHash::operator()((uint64_t)&v17, a2);
  v5 = v4;
  v6 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v6)
  {
    LODWORD(v7) = 0;
    goto LABEL_9;
  }
  v7 = v4 % v6;
  v8 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % v6));
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
LABEL_9:
    v14 = re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::addAsCopy(a1, v7, v5, (uint64_t)a2, (uint64_t)a2);
    ++*(_DWORD *)(a1 + 40);
    return *(_QWORD *)(a1 + 16) + 40 * v14 + 8;
  }
  v16 = v4 % v6;
  v9 = *a2;
  v10 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    v11 = v10 + 40 * v8;
    v13 = *(_QWORD *)(v11 + 8);
    v12 = v11 + 8;
    if (v13 == v9 && re::StringID::operator==((_QWORD *)(v12 + 8), a2 + 1))
      return v12;
    v8 = *(_DWORD *)(v10 + 40 * v8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF)
    {
      LODWORD(v7) = v16;
      goto LABEL_9;
    }
  }
}

re::ServiceRegistration *re::ServiceRegistration::ServiceRegistration(re::ServiceRegistration *this, const re::IntrospectionBase *a2, StringID *a3, void *a4)
{
  StringID v8;

  re::StringID::StringID((re::StringID *)&v8, a3);
  *(_QWORD *)this = a2;
  re::StringID::StringID((re::ServiceRegistration *)((char *)this + 8), &v8);
  re::StringID::destroyString((re::StringID *)&v8);
  *((_QWORD *)this + 3) = a4;
  return this;
}

uint64_t re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  int v9;
  uint64_t v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 40 * v8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 40 * v8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  v13 = 40 * v8;
  *(_DWORD *)(v11 + v13) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v13) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  v14 = (_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v8);
  v14[1] = *(_QWORD *)a5;
  re::StringID::StringID((re::StringID *)(v14 + 2), (const StringID *)(a5 + 8));
  v14[4] = *(_QWORD *)(a5 + 24);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

uint64_t re::internal::ServiceKeyHash::operator()(uint64_t a1, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = 0xBF58476D1CE4E5B9 * (*a2 ^ (*a2 >> 30));
  v3 = (0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) ^ ((0x94D049BB133111EBLL * (v2 ^ (v2 >> 27))) >> 31);
  v4 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * ((a2[1] >> 31) ^ (a2[1] >> 1))) ^ ((0xBF58476D1CE4E5B9 * ((a2[1] >> 31) ^ (a2[1] >> 1))) >> 27));
  return ((v4 ^ (v4 >> 31)) + (v3 << 6) + (v3 >> 2) - 0x61C8864680B583E9) ^ v3;
}

void re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  signed int v13;
  _BYTE v14[44];
  char v15;

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v14, 0, 36);
      *(_QWORD *)&v14[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::init((uint64_t)v14, v4, a2);
      v5 = *(_OWORD *)v14;
      *(_OWORD *)v14 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v14[16];
      *(_QWORD *)&v14[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v14[24];
      *(_OWORD *)&v14[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v14[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v14[16] + v10) & 0x80000000) != 0)
          {
            v12 = re::internal::ServiceKeyHash::operator()((uint64_t)&v15, (_QWORD *)(*(_QWORD *)&v14[16] + v10 + 8));
            re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::addAsMove(a1, v12 % *(unsigned int *)(a1 + 24), v12, *(_QWORD *)&v14[16] + v10 + 8, (_QWORD *)(*(_QWORD *)&v14[16] + v10 + 8));
            v9 = *(_DWORD *)&v14[32];
          }
          ++v11;
          v10 += 40;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::deinit((uint64_t *)v14);
    }
  }
  else
  {
    if (a2)
      v13 = a2;
    else
      v13 = 3;
  }
}

void re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 40 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_402, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 600);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v7;
  int v8;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;

  v7 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v7 == 0x7FFFFFFF)
  {
    v7 = *(unsigned int *)(a1 + 32);
    v8 = v7;
    if ((_DWORD)v7 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v8 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v8 + 1;
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 40 * v7);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 40 * v7);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  v12 = 40 * v7;
  *(_DWORD *)(v10 + v12) = v11 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v12) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v7) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  v13 = (_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v7);
  v13[1] = *a5;
  v14 = a5[1];
  v13[2] = v13[2] & 0xFFFFFFFFFFFFFFFELL | v14 & 1;
  v13[2] = a5[1] & 0xFFFFFFFFFFFFFFFELL | v14 & 1;
  v15 = a5[3];
  v13[3] = a5[2];
  a5[1] = 0;
  a5[2] = &str_110;
  v13[4] = v15;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v7;
  ++*(_DWORD *)(a1 + 28);
  return v7;
}

double re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2];
        v7 = *(_DWORD *)(v6 + v4);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v4) = v7 & 0x7FFFFFFF;
          re::StringID::destroyString((re::StringID *)(v6 + v4 + 16));
          v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 40;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t *re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>>::registerSerializeFuncs(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *result;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[2];
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;

  v2 = (uint64_t)(a1 + 28);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 28));
  (*(void (**)(_QWORD *))(*a1 + 64))(a1);
  v3 = a1[26];
  result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v3 + 200, a1 + 1);
  if (v3)
    v5 = result == 0;
  else
    v5 = 1;
  if (!v5)
  {
    v6 = *result;
    v7 = a1[26];
    v12[0] = v3;
    v12[1] = v6;
    re::TypeRegistry::attributesByAttributeType(v7, (uint64_t)v12, (uint64_t)&v13);
    if (v14)
    {
      v8 = (uint64_t *)(v15 + 40);
      v9 = 48 * v14;
      do
      {
        v10 = *(v8 - 2);
        v11 = *v8;
        v8 += 6;
        v17 = v11;
        v16 = v10 | 0xFFFFFFFF00000000;
        re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v2, &v16, &v17);
        v9 -= 48;
      }
      while (v9);
    }
    result = v13;
    if (v13)
    {
      if (v15)
        return (uint64_t *)(*(uint64_t (**)(void))(*v13 + 40))();
    }
  }
  return result;
}

uint64_t *re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>>::registerSerializeFuncs(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *result;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[2];
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;

  v2 = (uint64_t)(a1 + 28);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 28));
  (*(void (**)(_QWORD *))(*a1 + 64))(a1);
  v3 = a1[26];
  result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v3 + 200, a1 + 1);
  if (v3)
    v5 = result == 0;
  else
    v5 = 1;
  if (!v5)
  {
    v6 = *result;
    v7 = a1[26];
    v12[0] = v3;
    v12[1] = v6;
    re::TypeRegistry::attributesByAttributeType(v7, (uint64_t)v12, (uint64_t)&v13);
    if (v14)
    {
      v8 = (uint64_t *)(v15 + 40);
      v9 = 48 * v14;
      do
      {
        v10 = *(v8 - 2);
        v11 = *v8;
        v8 += 6;
        v17 = v11;
        v16 = v10 | 0xFFFFFFFF00000000;
        re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderOPACK<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v2, &v16, &v17);
        v9 -= 48;
      }
      while (v9);
    }
    result = v13;
    if (v13)
    {
      if (v15)
        return (uint64_t *)(*(uint64_t (**)(void))(*v13 + 40))();
    }
  }
  return result;
}

uint64_t *re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>>::registerSerializeFuncs(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *result;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[2];
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;

  v2 = (uint64_t)(a1 + 26);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 26));
  (*(void (**)(_QWORD *))(*a1 + 64))(a1);
  v3 = a1[24];
  result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v3 + 200, a1 + 1);
  if (v3)
    v5 = result == 0;
  else
    v5 = 1;
  if (!v5)
  {
    v6 = *result;
    v7 = a1[24];
    v12[0] = v3;
    v12[1] = v6;
    re::TypeRegistry::attributesByAttributeType(v7, (uint64_t)v12, (uint64_t)&v13);
    if (v14)
    {
      v8 = (uint64_t *)(v15 + 40);
      v9 = 48 * v14;
      do
      {
        v10 = *(v8 - 2);
        v11 = *v8;
        v8 += 6;
        v17 = v11;
        v16 = v10 | 0xFFFFFFFF00000000;
        re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::DynamicArrayBufferedOutputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v2, &v16, &v17);
        v9 -= 48;
      }
      while (v9);
    }
    result = v13;
    if (v13)
    {
      if (v15)
        return (uint64_t *)(*(uint64_t (**)(void))(*v13 + 40))();
    }
  }
  return result;
}

uint64_t *re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>>::registerSerializeFuncs(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *result;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[2];
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;

  v2 = (uint64_t)(a1 + 26);
  re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::clear((uint64_t)(a1 + 26));
  (*(void (**)(_QWORD *))(*a1 + 64))(a1);
  v3 = a1[24];
  result = (uint64_t *)re::HashTable<re::StringID,re::StateParameterInt *,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(v3 + 200, a1 + 1);
  if (v3)
    v5 = result == 0;
  else
    v5 = 1;
  if (!v5)
  {
    v6 = *result;
    v7 = a1[24];
    v12[0] = v3;
    v12[1] = v6;
    re::TypeRegistry::attributesByAttributeType(v7, (uint64_t)v12, (uint64_t)&v13);
    if (v14)
    {
      v8 = (uint64_t *)(v15 + 40);
      v9 = 48 * v14;
      do
      {
        v10 = *(v8 - 2);
        v11 = *v8;
        v8 += 6;
        v17 = v11;
        v16 = v10 | 0xFFFFFFFF00000000;
        re::HashTable<re::internal::SerializeFuncKey,BOOL (*)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL),re::internal::HashSerializeFuncKey,re::EqualTo<re::internal::SerializeFuncKey>,false,true>::addOrReplace<BOOL (*&)(re::Serializer<re::EncoderBinary<re::FixedArrayInputStream>> &,char const*,int,void *,re::TypeInfo const&,re::TypeInfo const&,BOOL)>(v2, &v16, &v17);
        v9 -= 48;
      }
      while (v9);
    }
    result = v13;
    if (v13)
    {
      if (v15)
        return (uint64_t *)(*(uint64_t (**)(void))(*v13 + 40))();
    }
  }
  return result;
}

__guard re::ProfilerManager::getProcessorId<re::FrameProfiler>()
{
  unsigned __int8 v0;
  __guard *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;

  if ((v0 & 1) == 0)
  {
    if (v3)
    {
      do
      {
        v4 = __ldaxr(&re::ProfilerManager::s_nextProcessorId);
        v5 = v4 + 1;
      }
      while (__stlxr(v5, &re::ProfilerManager::s_nextProcessorId));
      re::ProfilerManager::getProcessorId<re::FrameProfiler>(void)::processorId = v5;
    }
  }
  return v1[9];
}

void std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  void *v5;
  void *v6;
  uint64_t v7;
  _QWORD *v8;
  size_t v9;
  uint8x8_t v10;
  unint64_t v11;
  uint8x8_t v12;
  uint64_t v13;
  _QWORD *v14;
  size_t v15;
  void *v16;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(_QWORD *)&v4)
  {
    if (prime >= *(_QWORD *)&v4)
      return;
    v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      v11 = std::__next_prime(v11);
    }
    else
    {
      v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2)
        v11 = v13;
    }
    if (prime <= v11)
      prime = v11;
    if (prime >= *(_QWORD *)&v4)
      return;
    if (!prime)
    {
      v16 = *(void **)a1;
      *(_QWORD *)a1 = 0;
      if (v16)
        operator delete(v16);
      *(_QWORD *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  v5 = operator new(8 * prime);
  v6 = *(void **)a1;
  *(_QWORD *)a1 = v5;
  if (v6)
    operator delete(v6);
  v7 = 0;
  *(_QWORD *)(a1 + 8) = prime;
  do
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  v8 = *(_QWORD **)(a1 + 16);
  if (v8)
  {
    v9 = v8[1];
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime)
        v9 %= prime;
    }
    else
    {
      v9 &= prime - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v9) = a1 + 16;
    v14 = (_QWORD *)*v8;
    if (*v8)
    {
      do
      {
        v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime)
            v15 %= prime;
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v15))
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          *v8 = *v14;
          *v14 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v15);
          **(_QWORD **)(*(_QWORD *)a1 + 8 * v15) = v14;
          v14 = v8;
        }
        v15 = v9;
LABEL_31:
        v8 = v14;
        v14 = (_QWORD *)*v14;
        v9 = v15;
      }
      while (v14);
    }
  }
}

__guard re::ProfilerManager::getProcessorId<re::ProfilerFlameChartProcessor>()
{
  unsigned __int8 v0;
  __guard *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;

  if ((v0 & 1) == 0)
  {
    if (v3)
    {
      do
      {
        v4 = __ldaxr(&re::ProfilerManager::s_nextProcessorId);
        v5 = v4 + 1;
      }
      while (__stlxr(v5, &re::ProfilerManager::s_nextProcessorId));
      re::ProfilerManager::getProcessorId<re::ProfilerFlameChartProcessor>(void)::processorId = v5;
    }
  }
  return v1[5];
}

__guard re::ProfilerManager::getProcessorId<re::ProfilerMiniHUDProcessor>()
{
  unsigned __int8 v0;
  __guard *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;

  if ((v0 & 1) == 0)
  {
    if (v3)
    {
      do
      {
        v4 = __ldaxr(&re::ProfilerManager::s_nextProcessorId);
        v5 = v4 + 1;
      }
      while (__stlxr(v5, &re::ProfilerManager::s_nextProcessorId));
      re::ProfilerManager::getProcessorId<re::ProfilerMiniHUDProcessor>(void)::processorId = v5;
    }
  }
  return v1[3];
}

__guard re::ProfilerManager::getProcessorId<re::ProfilerDetailedHUDProcessor>()
{
  unsigned __int8 v0;
  __guard *v1;
  int v3;
  unint64_t v4;
  unint64_t v5;

  if ((v0 & 1) == 0)
  {
    if (v3)
    {
      do
      {
        v4 = __ldaxr(&re::ProfilerManager::s_nextProcessorId);
        v5 = v4 + 1;
      }
      while (__stlxr(v5, &re::ProfilerManager::s_nextProcessorId));
      re::ProfilerManager::getProcessorId<re::ProfilerDetailedHUDProcessor>(void)::processorId = v5;
    }
  }
  return v1[7];
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,re::ProfilerProcessor *>>>::find<unsigned long long>(_QWORD *a1, unint64_t *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (v3 >= *(_QWORD *)&v2)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (*(_QWORD *)&v2 - 1) & v3;
  }
  v6 = *(_QWORD **)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  result = (_QWORD *)*v6;
  if (*v6)
  {
    do
    {
      v8 = result[1];
      if (v8 == v3)
      {
        if (result[2] == v3)
          return result;
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(_QWORD *)&v2)
            v8 %= *(_QWORD *)&v2;
        }
        else
        {
          v8 &= *(_QWORD *)&v2 - 1;
        }
        if (v8 != v5)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

__objc2_class_ro *re::ProfilerManager::getProcessorId<re::ProfilerLogProcessor>()
{
  unsigned __int8 v0;
  __objc2_class_ro **p_info;
  int v3;
  unint64_t v4;
  unint64_t v5;

  p_info = VideoSpillMapMetalSession.info;
  if ((v0 & 1) == 0)
  {
    p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    if (v3)
    {
      do
      {
        v4 = __ldaxr(&re::ProfilerManager::s_nextProcessorId);
        v5 = v4 + 1;
      }
      while (__stlxr(v5, &re::ProfilerManager::s_nextProcessorId));
      re::ProfilerManager::getProcessorId<re::ProfilerLogProcessor>(void)::processorId = v5;
      p_info = VideoSpillMapMetalSession.info;
    }
  }
  return p_info[396];
}

__objc2_class_ro *re::ProfilerManager::getProcessorId<re::ProfilerCsvProcessor>()
{
  unsigned __int8 v0;
  __objc2_class_ro **p_info;
  int v3;
  unint64_t v4;
  unint64_t v5;

  p_info = VideoSpillMapMetalSession.info;
  if ((v0 & 1) == 0)
  {
    p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    if (v3)
    {
      do
      {
        v4 = __ldaxr(&re::ProfilerManager::s_nextProcessorId);
        v5 = v4 + 1;
      }
      while (__stlxr(v5, &re::ProfilerManager::s_nextProcessorId));
      re::ProfilerManager::getProcessorId<re::ProfilerCsvProcessor>(void)::processorId = v5;
      p_info = VideoSpillMapMetalSession.info;
    }
  }
  return p_info[398];
}

void re::ecs2::System::System(uint64_t a1, char a2)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = off_24ED712C0;
  *(_QWORD *)(a1 + 24) = -1;
  *(_QWORD *)(a1 + 32) = -1;
  *(_QWORD *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 48) = a2;
  *(_WORD *)(a1 + 52) = 260;
  *(_DWORD *)(a1 + 56) = 1023969417;
  *(_BYTE *)(a1 + 60) = 0;
  *(_BYTE *)(a1 + 64) = 1;
  *(_BYTE *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 84) = 0;
  *(_BYTE *)(a1 + 86) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = -1;
}

re::ecs2::DrawableQueueSyncSystem *re::ecs2::DrawableQueueSyncSystem::DrawableQueueSyncSystem(re::ecs2::DrawableQueueSyncSystem *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _anonymous_namespace_ *v8;
  _anonymous_namespace_ *v9;
  _anonymous_namespace_ *v10;
  uint64_t v12;
  char v13;

  re::ecs2::System::System((uint64_t)this, 1, 1);
  *(_QWORD *)(v2 + 152) = 0;
  *(_OWORD *)(v2 + 136) = 0u;
  *(_OWORD *)(v2 + 120) = 0u;
  *(_OWORD *)(v2 + 104) = 0u;
  *(_QWORD *)v2 = &off_24ED654B0;
  *(_QWORD *)(v2 + 176) = off_24ED65528;
  v3 = v2 + 176;
  *(_QWORD *)(v2 + 192) = 0;
  *(_QWORD *)(v2 + 184) = 0;
  v4 = v2 + 184;
  *(_DWORD *)(v2 + 200) = 1;
  *(_QWORD *)(v2 + 216) = 0;
  *(_QWORD *)(v2 + 224) = 0;
  *(_QWORD *)(v2 + 208) = 0;
  *(_DWORD *)(v2 + 232) = 0;
  v5 = (_QWORD *)(v2 + 304);
  *(_OWORD *)(v2 + 256) = 0u;
  *(_OWORD *)(v2 + 272) = 0u;
  *(_OWORD *)(v2 + 288) = 0u;
  *(_OWORD *)(v2 + 304) = 0u;
  *(_OWORD *)(v2 + 240) = 0u;
  v6 = (_QWORD *)(v2 + 240);
  *(_DWORD *)(v2 + 320) = 1;
  v7 = (_QWORD *)(v2 + 352);
  *(_OWORD *)(v2 + 328) = 0u;
  *(_OWORD *)(v2 + 344) = 0u;
  *(_QWORD *)(v2 + 360) = 0;
  *(_DWORD *)(v2 + 368) = 1;
  *(_OWORD *)(v2 + 376) = 0u;
  *(_OWORD *)(v2 + 392) = 0u;
  *(_OWORD *)(v2 + 401) = 0u;
  v10 = (_anonymous_namespace_ *)re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v5, 0);
  *((_DWORD *)this + 80) += 2;
  *((_QWORD *)this + 43) = 0;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity(v7, 0);
  *((_DWORD *)this + 92) += 2;
  *((_QWORD *)this + 49) = 0;
  *((_QWORD *)this + 50) = this;
  *((_QWORD *)this + 51) = v3;
  *((_BYTE *)this + 416) = 1;
  LOWORD(v12) = 257;
  HIDWORD(v12) = 1023969417;
  v13 = 0;
  re::ecs2::System::setTaskOptions(this, &v12);
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *((_QWORD *)this + 57) = 0x7FFFFFFF00000000;
  *((_DWORD *)this + 116) = 0;
  return this;
}

void re::ecs2::System::System(uint64_t a1, char a2, char a3)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = off_24ED712C0;
  *(_QWORD *)(a1 + 24) = -1;
  *(_QWORD *)(a1 + 32) = -1;
  *(_QWORD *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 48) = a3;
  *(_WORD *)(a1 + 52) = 260;
  *(_DWORD *)(a1 + 56) = 1023969417;
  *(_BYTE *)(a1 + 60) = 0;
  *(_BYTE *)(a1 + 64) = 1;
  *(_BYTE *)(a1 + 68) = 0;
  *(_BYTE *)(a1 + 84) = a2;
  *(_WORD *)(a1 + 85) = 0;
  *(_DWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = -1;
}

uint64_t re::BucketArray<re::ecs2::BasicComponentStateSceneData<re::ecs2::DrawableQueueSyncComponent>,4ul>::init(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result;

  *(_QWORD *)a1 = a2;
  re::DynamicOverflowArray<std::unique_ptr<void,std::function<void ()(void *)>> *,2ul>::setCapacity((_QWORD *)a1, a3);
  *(_DWORD *)(a1 + 16) += 2;
  *(_QWORD *)(a1 + 40) = 0;
  result = re::BucketArray<re::ecs2::BasicComponentStateSceneData<re::ecs2::DrawableQueueSyncComponent>,4ul>::setBucketsCapacity(a1, a3);
  ++*(_DWORD *)(a1 + 48);
  return result;
}

_QWORD *re::HashBrown<re::ecs2::Scene const*,unsigned long,re::Hash<re::ecs2::Scene const*>,re::EqualTo<re::ecs2::Scene const*>,void,false>::init(_QWORD *result, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t i;
  _QWORD *v12;

  v3 = result;
  result[7] = a2;
  v4 = 151 * a3;
  v5 = ((unint64_t)(151 * a3) >> 7) + 15;
  result[2] = v5 & 0x3FFFFFFFFFFFFF0;
  if ((v5 & 0x3FFFFFFFFFFFFF0) != 0)
  {
    v6 = v5 >> 4;
    result = (_QWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 17 * (v5 & 0x3FFFFFFFFFFFFF0), 16);
    *v3 = result;
    if (v4 >= 0x80)
    {
      v7 = 0;
      *(_QWORD *)&v8 = -1;
      *((_QWORD *)&v8 + 1) = -1;
      do
        *(_OWORD *)(*v3 + 16 * v7++) = v8;
      while (v6 != v7);
      result = (_QWORD *)*v3;
    }
    v3[1] = &result[2 * v6];
    v9 = v3[2];
    if (v9)
    {
      v10 = 0;
      for (i = 0; i < v9; ++i)
      {
        v12 = (_QWORD *)(v3[1] + v10);
        *v12 = 0;
        v12[1] = 0;
        v9 = v3[2];
        v10 += 16;
      }
    }
  }
  else
  {
    v9 = 0;
    *result = 0;
    result[1] = 0;
  }
  v3[5] = 0;
  v3[6] = 0;
  v3[3] = 0;
  v3[4] = v9;
  return result;
}

uint64_t *re::BucketArray<re::ecs2::BasicComponentStateSceneData<re::ecs2::DrawableQueueSyncComponent>,4ul>::setBucketsCapacity(uint64_t *result, unint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = result;
  if (*result)
  {
    if (result[5] < 4 * a2)
    {
      while (1)
      {
        v4 = v3[1];
        if (v4 <= a2)
          break;
        result = (uint64_t *)re::BucketArray<re::CollisionCastHit,10ul>::freeElementBucket(v3);
      }
      while (v4 < a2)
      {
        v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)*v3 + 32))(*v3, 448, 0);
        result = (uint64_t *)re::DynamicOverflowArray<RESubscriptionHandle *,2ul>::add((uint64_t)v3, &v5);
        v4 = v3[1];
      }
    }
  }
  else
  {
  }
  return result;
}

uint64_t re::introspect<re::SimulationClock>()
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FB368);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FB368))
  {
    qword_2540FB360 = re::introspect_SimulationClock(0);
    __cxa_guard_release(&qword_2540FB368);
  }
  return qword_2540FB360;
}

double re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::addSubscription(_anonymous_namespace_ *a1, uint64_t a2)
{
  double result;
  __int128 v5;
  char v6[8];
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf((uint64_t)a1, (_QWORD *)a2, (uint64_t)v6);
  if (!v6[0])
  {
    if (*((_DWORD *)a1 + 20))
    {
      v6[0] = 1;
      v5 = *(_OWORD *)(a2 + 16);
      v7 = *(_OWORD *)a2;
      v8 = v5;
      *(_QWORD *)&result = re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::add((uint64_t)a1 + 40, (uint64_t)v6).n128_u64[0];
    }
    else
    {
      *(_QWORD *)&result = re::DynamicArray<re::EvaluationRegister>::add(a1, a2).n128_u64[0];
    }
  }
  return result;
}

__n128 re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::add(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  __n128 result;
  __int128 v13;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(_QWORD *)a1)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::setCapacity((_QWORD *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::setCapacity((_QWORD *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    v5 = *(_QWORD *)(a1 + 16);
  }
  v11 = *(_QWORD *)(a1 + 32) + 40 * v5;
  result = *(__n128 *)a2;
  v13 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(v11 + 32) = *(_QWORD *)(a2 + 32);
  *(__n128 *)v11 = result;
  *(_OWORD *)(v11 + 16) = v13;
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v8;
  char v9;

  v3 = *(_QWORD *)(result + 32);
  v4 = *(_QWORD *)(result + 16);
  if (v4)
  {
    v5 = 32 * v4;
    v6 = *(_QWORD **)(result + 32);
    while (1)
    {
      if (*v6 == *a2)
      {
        result = a2[2];
        if (v6[1] == a2[1] && v6[2] == result)
          break;
      }
      v6 += 4;
      v5 -= 32;
      if (!v5)
      {
        v6 = (_QWORD *)(v3 + 32 * v4);
        break;
      }
    }
  }
  else
  {
    v6 = *(_QWORD **)(result + 32);
  }
  v8 = ((uint64_t)v6 - v3) >> 5;
  if (v8 == v4)
  {
    v9 = 0;
  }
  else
  {
    *(_QWORD *)(a3 + 8) = v8;
    v9 = 1;
  }
  *(_BYTE *)a3 = v9;
  return result;
}

_QWORD *re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void *v7;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v5)
      {
        if (!a2)
        {
          v7 = 0;
          if (!v3)
            goto LABEL_9;
          goto LABEL_8;
        }
        if (is_mul_ok(a2, 0x28uLL))
        {
          v2 = 40 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
            {
LABEL_9:
              v5[4] = v7;
              v5[1] = a2;
              return result;
            }
LABEL_8:
            memcpy(v7, (const void *)v5[4], 40 * v5[2]);
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[4]);
            goto LABEL_9;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
      }
    }
  }
  return result;
}

uint64_t re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::createSubscription<re::Engine>(re::Engine *,REEventHandlerResult (re::Engine::*)(re::SimulationTimer*,re::SimulationTimerEventArgs const&))::{lambda(re::SimulationTimer*,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription const&,re::SimulationTimerEventArgs const&)#1}::__invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t (*v3)(_QWORD *, uint64_t);
  uint64_t v4;
  _QWORD *v5;

  v3 = (uint64_t (*)(_QWORD *, uint64_t))a2[1];
  v4 = a2[2];
  v5 = (_QWORD *)(*a2 + (v4 >> 1));
  if ((v4 & 1) != 0)
    v3 = *(uint64_t (**)(_QWORD *, uint64_t))(*v5 + v3);
  return v3(v5, a1);
}

double re::ecs2::ThrottleManager::ThrottleManager(re::ecs2::ThrottleManager *this)
{
  double result;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24ED70A40;
  result = 0.0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 52) = 0u;
  *(_QWORD *)((char *)this + 68) = 0x7FFFFFFFLL;
  *((_DWORD *)this + 29) = 0;
  *((_DWORD *)this + 30) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_WORD *)this + 56) = 0;
  return result;
}

uint64_t re::ProfilerManager::getProcessorId<re::FrameAnalysisProfilerProcessor>()
{
  unsigned __int8 v0;
  unint64_t v2;
  unint64_t v3;

  v0 = atomic_load((unsigned __int8 *)&qword_2540FB378);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_2540FB378))
  {
    do
    {
      v2 = __ldaxr(&re::ProfilerManager::s_nextProcessorId);
      v3 = v2 + 1;
    }
    while (__stlxr(v3, &re::ProfilerManager::s_nextProcessorId));
    qword_2540FB370 = v3;
    __cxa_guard_release(&qword_2540FB378);
  }
  return qword_2540FB370;
}

void re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::removeSubscription(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  _BYTE v5[8];
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf(a1, a2, (uint64_t)v5);
  if (v5[0])
  {
    if (*(_DWORD *)(a1 + 80))
    {
      v5[0] = 0;
      v4 = a2[1];
      v6 = *a2;
      v7 = v4;
      re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::add(a1 + 40, (uint64_t)v5);
    }
    else
    {
      re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStable((_QWORD *)a1, a2);
    }
  }
}

BOOL re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStable(_QWORD *a1, _QWORD *a2)
{
  int v3;
  _BYTE v5[8];
  unint64_t v6;

  re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf((uint64_t)a1, a2, (uint64_t)v5);
  v3 = v5[0];
  if (v5[0])
    re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStableAt(a1, v6);
  return v3 != 0;
}

_QWORD *re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStableAt(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;

  v2 = result[2];
  if (v2 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v3 = result;
  v4 = v2 - 1;
  if (v2 - 1 > a2)
  {
    v5 = result[4];
    result = (_QWORD *)(v5 + 32 * a2);
    v6 = (char *)(v5 + 32 * v2);
    if (v6 != (char *)(result + 4))
    {
      result = memmove(result, result + 4, v6 - (char *)(result + 4));
      v4 = v3[2] - 1;
    }
  }
  v3[2] = v4;
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::HashSetBase<re::ServiceKey,re::ServiceRegistration,re::internal::ServiceKeyGetter,re::internal::ServiceKeyHash,re::internal::ServiceKeyEqualTo,false,false>::remove(uint64_t a1, uint64_t *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v18;
  uint64_t v19;
  int *v20;
  int v21;
  int v22;
  char v23;

  v4 = re::internal::ServiceKeyHash::operator()((uint64_t)&v23, a2);
  v5 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v5)
    return 0;
  v6 = v4 % v5;
  v7 = *(_QWORD *)(a1 + 8);
  v8 = *(unsigned int *)(v7 + 4 * (v4 % v5));
  if ((_DWORD)v8 == 0x7FFFFFFF)
    return 0;
  v11 = *a2;
  v9 = a2 + 1;
  v10 = v11;
  v12 = *(_QWORD *)(a1 + 16);
  v13 = 0x7FFFFFFFLL;
  while (1)
  {
    v14 = v12 + 40 * v8;
    v16 = *(_QWORD *)(v14 + 8);
    v15 = v14 + 8;
    if (v16 == v10 && re::StringID::operator==((_QWORD *)(v15 + 8), v9))
      break;
    v13 = v8;
    v8 = *(_DWORD *)(v12 + 40 * v8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF)
      return 0;
  }
  v18 = *(_DWORD *)(v12 + 40 * v8) & 0x7FFFFFFF;
  if (v13 == 0x7FFFFFFF)
    *(_DWORD *)(v7 + 4 * v6) = v18;
  else
    *(_DWORD *)(v12 + 40 * v13) = *(_DWORD *)(v12 + 40 * v13) & 0x80000000 | v18;
  v19 = *(_QWORD *)(a1 + 16);
  v20 = (int *)(v19 + 40 * v8);
  v21 = *v20;
  if (*v20 < 0)
  {
    *v20 = v21 & 0x7FFFFFFF;
    re::StringID::destroyString((re::StringID *)(v19 + 40 * v8 + 16));
    v19 = *(_QWORD *)(a1 + 16);
    v21 = *(_DWORD *)(v19 + 40 * v8);
  }
  v22 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v19 + 40 * v8) = *(_DWORD *)(a1 + 36) | v21 & 0x80000000;
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v8;
  *(_DWORD *)(a1 + 40) = v22 + 1;
  return 1;
}

double re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v6 + 24);
          v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 64;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::ecs2::EntityHandle::reset((id *)(v6 + 24));
          objc_destroyWeak((id *)(v6 + 24));
          *(_QWORD *)(v6 + 24) = 0;
          v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 48;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::ecs2::Scene *,re::DynamicArray<RESubscriptionHandle>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::ecs2::Scene *,re::DynamicArray<RESubscriptionHandle>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 64;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::HashTable<re::ecs2::Scene *,re::DynamicArray<RESubscriptionHandle>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::EntryWithHash::free(uint64_t result)
{
  int v1;
  uint64_t v2;
  _QWORD *v3;

  v1 = *(_DWORD *)(result + 8);
  if (v1 < 0)
  {
    v2 = result;
    v3 = (_QWORD *)(result + 24);
    result = *(_QWORD *)(result + 24);
    *((_DWORD *)v3 - 4) = v1 & 0x7FFFFFFF;
    if (result)
    {
      if (*(_QWORD *)(v2 + 56))
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
      *(_QWORD *)(v2 + 56) = 0;
      v3[1] = 0;
      v3[2] = 0;
      *v3 = 0;
      ++*(_DWORD *)(v2 + 48);
    }
  }
  return result;
}

double re::HashTable<re::SharedPtr<re::ecs2::Entity>,re::ecs2::RemoteEffectHoverData,re::Hash<re::SharedPtr<re::ecs2::Entity>>,re::EqualTo<re::SharedPtr<re::ecs2::Entity>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  uint64_t v8;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          v8 = *(_QWORD *)(v6 + 16);
          if (v8)
          {

            *(_QWORD *)(v6 + 16) = 0;
            v3 = *((unsigned int *)a1 + 8);
          }
        }
        v4 += 1536;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

_QWORD *re::FixedArray<re::DynamicBitset<unsigned long long,256ul>>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = result[2];
      v5 = 72 * v2;
      do
      {
        re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit(v4);
        v4 += 72;
        v5 -= 72;
      }
      while (v5);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

_QWORD *re::FixedArray<re::Function<void ()(float)>>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = result[2];
      v5 = 40 * v2;
      do
      {
        re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v4);
        v4 += 40;
        v5 -= 40;
      }
      while (v5);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

__objc2_class_ro *re::EventBus::getTypeId<REEngineDoUpdateEvent>()
{
  unsigned __int8 v0;
  __objc2_class_ro **p_info;
  int v3;
  const char *v4;

  p_info = VideoSpillMapMetalSession.info;
  if ((v0 & 1) == 0)
  {
    p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    if (v3)
    {
      re::EventBus::getTypeId<REEngineDoUpdateEvent>(void)const::s_id = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"21REEngineDoUpdateEvent" & 0x7FFFFFFFFFFFFFFFLL), v4);
      p_info = (__objc2_class_ro **)(VideoSpillMapMetalSession + 32);
    }
  }
  return p_info[446];
}

void std::__function::__func<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,std::allocator<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4>,void ()(re::Scheduler::TaskDescriptor)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

__n128 std::__function::__func<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,std::allocator<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4>,void ()(re::Scheduler::TaskDescriptor)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24ED2AEC8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,std::allocator<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4>,void ()(re::Scheduler::TaskDescriptor)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED2AEC8;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,std::allocator<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4>,void ()(re::Scheduler::TaskDescriptor)>::operator()(uint64_t a1, uint64_t a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  StringID v7;
  _BYTE v8[21];
  _BYTE v9[24];
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v4 = *(char **)(a2 + 8);
  *(_QWORD *)&v7.var0 = *(_QWORD *)a2;
  v7.var1 = v4;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = &str_110;
  *(_OWORD *)v8 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)&v8[13] = *(_QWORD *)(a2 + 29);
  v10 = *(_QWORD *)(a2 + 64);
  v11 = 0;
  re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)v9, a2 + 40);
  v5 = *(_QWORD *)(a2 + 88);
  v12 = *(_QWORD *)(a2 + 80);
  v13 = v5;
  v14 = *(_OWORD *)(a2 + 96);
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 104) = 0;
  v16 = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a2 + 120) = 0;
  ++*(_DWORD *)(a2 + 112);
  v15 = 1;
  v6 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(v6 + 120) = re::Scheduler::ScheduleDescriptor::addTask(*(_QWORD *)(a1 + 16), &v7);
  if (v13)
  {
    if (v16)
      (*(void (**)(void))(*(_QWORD *)v13 + 40))();
    v16 = 0;
    v14 = 0uLL;
    v13 = 0;
    ++v15;
  }
  if (v11)
  {
    (**(void (***)(_BYTE *))v11)(v11);
    if (v11 != v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
    v11 = 0;
  }
  re::StringID::destroyString((re::StringID *)&v7);
}

uint64_t std::__function::__func<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,std::allocator<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4>,void ()(re::Scheduler::TaskDescriptor)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4,std::allocator<re::Engine::configureEnterFramePhase(re::Scheduler::ScheduleDescriptor &)::$_4>,void ()(re::Scheduler::TaskDescriptor)>::target_type()
{
}

uint64_t re::Scheduler::ScheduleDescriptor::addTask(uint64_t a1, StringID *a2)
{
  unint64_t v4;
  uint64_t v5;
  StringID v6;
  uint64_t result;

  if (a2[4].var1)
  {
    v4 = *(_QWORD *)(a1 + 56);
    if (v4 >= *(_QWORD *)(a1 + 48))
    {
      re::DynamicArray<re::Scheduler::TaskDescriptor>::growCapacity((_QWORD *)(a1 + 40), v4 + 1);
      v4 = *(_QWORD *)(a1 + 56);
    }
    v5 = *(_QWORD *)(a1 + 72) + (v4 << 7);
    re::StringID::StringID((re::StringID *)v5, a2);
    v6 = a2[1];
    *(_QWORD *)(v5 + 29) = *(char **)((char *)&a2[1].var1 + 5);
    *(StringID *)(v5 + 16) = v6;
    *(_QWORD *)(v5 + 64) = *(_QWORD *)&a2[4].var0;
    *(_QWORD *)(v5 + 72) = 0;
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>(v5 + 40, (uint64_t)&a2[2].var1);
    *(_QWORD *)(v5 + 80) = *(_QWORD *)&a2[5].var0;
    re::DynamicArray<unsigned long>::DynamicArray(v5 + 88, (uint64_t *)&a2[5].var1);
    result = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 56) = result + 1;
    ++*(_DWORD *)(a1 + 64);
  }
  else
  {
    re::internal::assertLog((re::internal *)4, (uint64_t)a2, "assertion failure: '%s' (%s:line %i) Task Descriptor does not contain an update function", "taskDescriptor.taskFunction", "addTask", 141);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

re::EventBus::EventInfo *re::EventBus::subscriptionCountInternal<re::Engine,REEngineDoUpdateEvent>(uint64_t a1, unint64_t a2, unint64_t a3)
{
  re::EventBus::EventInfo *result;

  result = (re::EventBus::EventInfo *)re::EventBus::getEventInfo<REEngineDoUpdateEvent>(a1);
  if (result)
  {
    result = (re::EventBus::EventInfo *)re::EventBus::EventInfo::getSubscriptions(result, a2, a3);
    if (result)
      return (re::EventBus::EventInfo *)*((_QWORD *)result + 15);
  }
  return result;
}

uint64_t re::EventBus::getEventInfo<REEngineDoUpdateEvent>(uint64_t a1)
{
  uint64_t v2;
  __objc2_class_ro *Type;

  Type = re::EventBus::getTypeId<REEngineDoUpdateEvent>();
  v2 = re::HashBrown<unsigned long long,std::unique_ptr<re::EventBus::EventInfo,std::function<void ()(re::EventBus::EventInfo*)>>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,void,false>::find((_QWORD *)(a1 + 24), (uint64_t *)&Type);
  if (v2 == -1)
    return 0;
  else
    return *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48 * v2 + 8);
}

uint64_t re::EventBus::EventInfo::getSubscriptions(re::EventBus::EventInfo *this, unint64_t a2, unint64_t a3)
{
  uint64_t v4;
  _QWORD v6[2];

  if (!(a2 | a3))
    return (uint64_t)this + 88;
  v6[0] = a2;
  v6[1] = a3;
  v4 = re::HashBrown<re::Pair<void const*,void const*,true>,re::EventBus::Subscriptions,re::Hash<re::Pair<void const*,void const*,true>>,re::EqualTo<re::Pair<void const*,void const*,true>>,void,false>::find((uint64_t *)this + 27, v6);
  if (v4 == -1)
    return 0;
  else
    return *((_QWORD *)this + 28) + 144 * v4 + 16;
}

void std::__function::__func<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9,std::allocator<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9>,void ()(re::Scheduler::TaskDescriptor)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

__n128 std::__function::__func<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9,std::allocator<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9>,void ()(re::Scheduler::TaskDescriptor)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24ED2AF58;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9,std::allocator<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9>,void ()(re::Scheduler::TaskDescriptor)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED2AF58;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9,std::allocator<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9>,void ()(re::Scheduler::TaskDescriptor)>::operator()(uint64_t a1, uint64_t a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  StringID v7;
  _BYTE v8[21];
  _BYTE v9[24];
  uint64_t v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v4 = *(char **)(a2 + 8);
  *(_QWORD *)&v7.var0 = *(_QWORD *)a2;
  v7.var1 = v4;
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = &str_110;
  *(_OWORD *)v8 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)&v8[13] = *(_QWORD *)(a2 + 29);
  v10 = *(_QWORD *)(a2 + 64);
  v11 = 0;
  re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)v9, a2 + 40);
  v5 = *(_QWORD *)(a2 + 88);
  v12 = *(_QWORD *)(a2 + 80);
  v13 = v5;
  v14 = *(_OWORD *)(a2 + 96);
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 104) = 0;
  v16 = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a2 + 120) = 0;
  ++*(_DWORD *)(a2 + 112);
  v15 = 1;
  v6 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(v6 + 264) = re::Scheduler::ScheduleDescriptor::addTask(*(_QWORD *)(a1 + 16), &v7);
  if (v13)
  {
    if (v16)
      (*(void (**)(void))(*(_QWORD *)v13 + 40))();
    v16 = 0;
    v14 = 0uLL;
    v13 = 0;
    ++v15;
  }
  if (v11)
  {
    (**(void (***)(_BYTE *))v11)(v11);
    if (v11 != v9)
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
    v11 = 0;
  }
  re::StringID::destroyString((re::StringID *)&v7);
}

uint64_t std::__function::__func<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9,std::allocator<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9>,void ()(re::Scheduler::TaskDescriptor)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9,std::allocator<re::Engine::configureCommitPhase(re::Scheduler::ScheduleDescriptor &)::$_9>,void ()(re::Scheduler::TaskDescriptor)>::target_type()
{
}

_anonymous_namespace_ *re::DynamicOverflowArray<unsigned long long,5ul>::resize(_anonymous_namespace_ *result, unint64_t a2, _QWORD *a3)
{
  _anonymous_namespace_ *v4;
  unint64_t v5;
  unint64_t v7;
  char *v8;

  v4 = result;
  v5 = *((_QWORD *)result + 1);
  if (v5 >= a2)
  {
    if (v5 <= a2)
      return result;
  }
  else
  {
    result = re::DynamicOverflowArray<unsigned long long,5ul>::reserve(result, a2);
    v7 = *((_QWORD *)v4 + 1);
    if (v7 < a2)
    {
      do
      {
        v8 = (char *)v4 + 24;
        if ((*((_BYTE *)v4 + 16) & 1) == 0)
          v8 = (char *)*((_QWORD *)v4 + 4);
        *(_QWORD *)&v8[8 * v7++] = *a3;
      }
      while (a2 != v7);
    }
  }
  *((_QWORD *)v4 + 1) = a2;
  *((_DWORD *)v4 + 4) += 2;
  return result;
}

_anonymous_namespace_ *re::DynamicOverflowArray<unsigned long long,5ul>::reserve(_anonymous_namespace_ *result, unint64_t a2)
{
  _anonymous_namespace_ *v3;
  unint64_t v4;
  int v5;

  v3 = result;
  if (*(_QWORD *)result)
  {
    if ((*((_DWORD *)result + 4) & 1) == 0)
    {
LABEL_3:
      v4 = *((_QWORD *)v3 + 3);
      goto LABEL_6;
    }
  }
  else
  {
    result = (_anonymous_namespace_ *)re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity(v3, a2);
    v5 = *((_DWORD *)v3 + 4) + 2;
    *((_DWORD *)v3 + 4) = v5;
    if ((v5 & 1) == 0)
      goto LABEL_3;
  }
  v4 = 5;
LABEL_6:
  if (v4 < a2)
    return (_anonymous_namespace_ *)re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity(v3, a2);
  return result;
}

_QWORD *re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  const void *v13;
  void *v14;
  uint64_t v15;
  const void *v16;
  int v17;

  v4 = result;
  v5 = *result;
  if (a2 && !v5)
  {
    result = (_QWORD *)re::DynamicOverflowArray<unsigned long long,5ul>::setCapacity(v4, a2);
    v6 = *((_DWORD *)v4 + 4) + 2;
LABEL_4:
    *((_DWORD *)v4 + 4) = v6;
    return result;
  }
  v7 = *((_DWORD *)result + 4);
  if ((v7 & 1) != 0)
    v8 = 5;
  else
    v8 = result[3];
  if (v8 != a2)
  {
    v9 = result[1];
    if (v9 <= a2 && (a2 > 5 || (v7 & 1) == 0))
    {
      if (a2 < 6)
      {
        v14 = result + 3;
        v15 = v4[4];
        if ((v7 & 1) != 0)
          v16 = v4 + 3;
        else
          v16 = (const void *)v4[4];
        memcpy(v14, v16, 8 * v9);
        result = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, v15);
        v6 = *((_DWORD *)v4 + 4) | 1;
        goto LABEL_4;
      }
      if (a2 >> 61)
      {
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicOverflowArray<T, N>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 646, 8, a2);
        _os_crash();
        __break(1u);
      }
      else
      {
        v2 = 8 * a2;
        v10 = (void *)(*(uint64_t (**)(_QWORD, unint64_t, uint64_t))(*(_QWORD *)v5 + 32))(*result, 8 * a2, 8);
        if (v10)
        {
          v12 = v10;
          if ((v4[2] & 1) != 0)
            v13 = v4 + 3;
          else
            v13 = (const void *)v4[4];
          result = memcpy(v10, v13, 8 * v4[1]);
          v17 = *((_DWORD *)v4 + 4);
          if ((v17 & 1) == 0)
          {
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v4 + 40))(*v4, v4[4]);
            v17 = *((_DWORD *)v4 + 4);
          }
          *((_DWORD *)v4 + 4) = v17 & 0xFFFFFFFE;
          v4[3] = a2;
          v4[4] = v12;
          return result;
        }
      }
      re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 650, v2, *(_QWORD *)(*v4 + 8));
      result = (_QWORD *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

id re::internal::defaultRetain<re::Engine>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{
  return (id)(a1 + 8);
}

void re::internal::defaultRelease<re::Engine>(void)::{lambda(void *)#1}::__invoke(uint64_t a1)
{

}

void re::NetworkAssetManager::init(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  _BYTE v15[23];
  uint64_t v16;
  void *v17;
  id v18;
  _QWORD v19[2];
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)(a1 + 16) = a2;
  if (a2)
  {
    *(_QWORD *)&v20 = a1;
    *((_QWORD *)&v20 + 1) = re::NetworkAssetManager::onComponentUpdated;
    *(_QWORD *)&v21 = 0;
    *((_QWORD *)&v21 + 1) = re::Event<re::NetworkSystem,re::ecs2::Component *>::createSubscription<re::NetworkAssetManager>(re::NetworkAssetManager *,REEventHandlerResult (re::NetworkAssetManager::*)(re::NetworkSystem*,re::ecs2::Component *))::{lambda(re::NetworkSystem*,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription const&,re::ecs2::Component *&&)#1}::__invoke;
    re::Event<re::NetworkSystem,re::ecs2::Component *>::addSubscription((_DWORD *)(a2 + 352), (uint64_t)&v20);
  }
  *(_QWORD *)(a1 + 8) = a3;
  *(_BYTE *)(a1 + 216) = a4;
  re::Bundle::application(&v18);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 104))(a1);
  re::Bundle::ID(&v18, (re::DynamicString *)&v13);
  if ((v14 & 1) != 0)
    v8 = *(_BYTE **)&v15[7];
  else
    v8 = v15;
  re::DynamicString::format((re::DynamicString *)"RootAssetEntity-%llu-%s", (re::DynamicString *)&v20, v7, v8);
  re::StringID::StringID((re::StringID *)&v16, (const re::DynamicString *)&v20);
  v9 = v16;
  v10 = v17;
  v16 = 0;
  v17 = &str_110;
  v11 = *(_QWORD *)(a1 + 200);
  v12 = *(_QWORD *)(a1 + 208);
  *(_QWORD *)(a1 + 200) = v9;
  *(_QWORD *)(a1 + 208) = v10;
  v19[0] = v9 & 0xFFFFFFFFFFFFFFFELL | v11 & 1;
  v19[1] = v12;
  re::StringID::destroyString((re::StringID *)v19);
  re::StringID::destroyString((re::StringID *)&v16);
  if ((_QWORD)v20)
  {
    if ((BYTE8(v20) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v20 + 40))();
    v20 = 0u;
    v21 = 0u;
  }
  if (v13 && (v14 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v13 + 40))();

}

uint64_t re::NetworkAssetManager::onComponentUpdated(re::NetworkAssetManager *this, re::NetworkSystem *a2, re::ecs2::Component *a3)
{
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  __guard *v8;
  unsigned __int8 v9;
  uint64_t v10;
  _QWORD *v11;
  _DWORD *v12;
  __guard *v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int8 *v18;
  __guard *v19;
  unsigned __int8 v20;
  uint64_t v21;
  _QWORD *i;
  _DWORD *v23;
  __guard *v24;
  int v25;
  int v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void (***v31)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
  uint64_t v33;
  uint64_t v34;

  v5 = (*(uint64_t (**)(re::ecs2::Component *, re::NetworkSystem *))(*(_QWORD *)a3 + 40))(a3, a2);
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
  do
  {
    v9 = atomic_load(v7);
    if ((v9 & 1) == 0)
    {
      v13 = (__guard *)v7;
      v33 = v6;
      v14 = __cxa_guard_acquire((__guard *)v7);
      v15 = v14;
      v6 = v33;
      v7 = (unsigned __int8 *)v13;
      if (v15)
      {
        re::introspect<re::ecs2::NetworkAssetComponent>(void)::info = (_UNKNOWN *)re::ecs2::introspect_NetworkAssetComponent(0);
        __cxa_guard_release(v13);
        v6 = v33;
        v7 = (unsigned __int8 *)v13;
      }
    }
    if (v6 == v8[18])
    {
      v27 = *((_QWORD *)a3 + 4);
      if (!re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey((uint64_t)this + 32, v27))(*(void (**)(re::NetworkAssetManager *, unint64_t, char *, _QWORD))(*(_QWORD *)this + 136))(this, v27, (char *)a3 + 72, *((_QWORD *)a3 + 2));
      v28 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 32))(*((_QWORD *)this + 1));
      v29 = re::ServiceLocator::serviceOrNull<re::AssetService>(v28);
      (*(void (**)(uint64_t, _QWORD, char *))(*(_QWORD *)v29 + 368))(v29, *((_QWORD *)a3 + 4), (char *)a3 + 168);
      return 0;
    }
    v10 = *(unsigned int *)(v6 + 56);
    if (!(_DWORD)v10)
      break;
    v11 = *(_QWORD **)(v6 + 64);
    while (1)
    {
      v12 = (_DWORD *)*v11;
      if (*(_DWORD *)*v11 == 1 && v12[10] == 3)
        break;
      ++v11;
      if (!--v10)
        goto LABEL_14;
    }
    v6 = *((_QWORD *)v12 + 2);
  }
  while (v6);
LABEL_14:
  v16 = (*(uint64_t (**)(re::ecs2::Component *))(*(_QWORD *)a3 + 40))(a3);
  v17 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v16 + 48))(v16);
  while (1)
  {
    v20 = atomic_load(v18);
    if ((v20 & 1) == 0)
    {
      v24 = (__guard *)v18;
      v34 = v17;
      v25 = __cxa_guard_acquire((__guard *)v18);
      v26 = v25;
      v17 = v34;
      v18 = (unsigned __int8 *)v24;
      if (v26)
      {
        re::introspect<re::ecs2::AssetStateComponent>(void)::info = (_UNKNOWN *)re::ecs2::introspect_AssetStateComponent(0);
        __cxa_guard_release(v24);
        v17 = v34;
        v18 = (unsigned __int8 *)v24;
      }
    }
    if (v17 == v19[20])
      break;
    v21 = *(unsigned int *)(v17 + 56);
    if ((_DWORD)v21)
    {
      for (i = *(_QWORD **)(v17 + 64); ; ++i)
      {
        v23 = (_DWORD *)*i;
        if (*(_DWORD *)*i == 1 && v23[10] == 3)
          break;
        if (!--v21)
          return 0;
      }
      v17 = *((_QWORD *)v23 + 2);
      if (v17)
        continue;
    }
    return 0;
  }
  v30 = *((_QWORD *)a3 + 5);
  if (v30 != (*(uint64_t (**)(re::NetworkAssetManager *))(*(_QWORD *)this + 104))(this))
  {
    v31 = (void (***)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))*((_QWORD *)this + 28);
    if (v31)
      (**v31)(v31, *((_QWORD *)a3 + 4), *((_QWORD *)a3 + 5), *((unsigned __int8 *)a3 + 48), 0, 0);
  }
  return 0;
}

void re::NetworkAssetManager::deinit(re::NetworkAssetManager *this)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = (uint64_t *)((char *)this + 184);
  v2 = *((_QWORD *)this + 23);
  if (v2)
  {
    if (!*(_QWORD *)(v2 + 56)
      || (v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 104))(*((_QWORD *)this + 1)),
          re::Collection<re::SharedPtr<re::ecs2::Scene>>::remove(v4, v3),
          (v2 = *((_QWORD *)this + 23)) != 0))
    {

      *v3 = 0;
    }
  }
  v5 = *((_QWORD *)this + 3);
  if (v5)
  {

    *((_QWORD *)this + 3) = 0;
  }
  *((_QWORD *)this + 1) = 0;
  v6 = *((_QWORD *)this + 2);
  if (v6)
    re::Event<re::NetworkSystem,re::ecs2::Component *>::unsubscribe<re::NetworkAssetManager>(v6 + 352, (uint64_t)this);
  *((_QWORD *)this + 2) = 0;
}

uint64_t re::Collection<re::SharedPtr<re::ecs2::Scene>>::remove(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v17;

  v3 = *(_QWORD *)(a1 + 40);
  v4 = *(_QWORD *)(a1 + 24);
  if (v4)
  {
    v5 = 8 * v4;
    v6 = *(_QWORD **)(a1 + 40);
    while (*v6 != *a2)
    {
      ++v6;
      v5 -= 8;
      if (!v5)
      {
        v6 = (_QWORD *)(v3 + 8 * v4);
        break;
      }
    }
  }
  else
  {
    v6 = *(_QWORD **)(a1 + 40);
  }
  v7 = ((uint64_t)v6 - v3) >> 3;
  if (v7 == v4)
    return 0;
  v9 = *(_DWORD *)(a1 + 32);
  v10 = *a2;
  v17 = v10;
  if (v10)
    v11 = (id)(v10 + 8);
  (*(void (**)(uint64_t, unint64_t, uint64_t *))(*(_QWORD *)a1 + 32))(a1, v7, &v17);
  if (v9 == *(_DWORD *)(a1 + 32))
    goto LABEL_20;
  v12 = *(_QWORD *)(a1 + 40);
  v13 = *(_QWORD *)(a1 + 24);
  if (v13)
  {
    v14 = 8 * v13;
    v15 = *(_QWORD **)(a1 + 40);
    while (*v15 != v17)
    {
      ++v15;
      v14 -= 8;
      if (!v14)
      {
        v15 = (_QWORD *)(v12 + 8 * v13);
        break;
      }
    }
  }
  else
  {
    v15 = *(_QWORD **)(a1 + 40);
  }
  v7 = ((uint64_t)v15 - v12) >> 3;
  if (v7 != v13)
  {
LABEL_20:
    re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::removeAt(a1 + 8, v7);
    (*(void (**)(uint64_t, unint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, v7, &v17);
    v8 = 1;
  }
  else
  {
    v8 = 0;
  }
  if (v17)

  return v8;
}

void re::Event<re::NetworkSystem,re::ecs2::Component *>::unsubscribe<re::NetworkAssetManager>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _anonymous_namespace_ *v5;
  __int128 *v6;
  __int128 v7;
  _BYTE v8[8];
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 16))
  {
    v4 = 0;
    v5 = (_anonymous_namespace_ *)(a1 + 40);
    do
    {
      v6 = (__int128 *)(*(_QWORD *)(a1 + 32) + 32 * v4);
      if (*(_QWORD *)v6 == a2)
      {
        if (!*(_DWORD *)(a1 + 80))
        {
          re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::removeStableAt((_QWORD *)a1, v4);
          continue;
        }
        v8[0] = 0;
        v7 = v6[1];
        v9 = *v6;
        v10 = v7;
        re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription,true>>::add(v5, (uint64_t)v8);
      }
      ++v4;
    }
    while (v4 < *(_QWORD *)(a1 + 16));
  }
}

uint64_t re::NetworkAssetManager::assetLoadDescriptors@<X0>(re::NetworkAssetManager *this@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;

  result = re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a2);
  if (result
    && (result = (uint64_t)re::ecs2::EntityHandle::resolve((id *)result, *((_QWORD *)this + 1))) != 0
    && (result = re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)(result + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType)) != 0)
  {
    *a3 = 1;
    return re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray((uint64_t)(a3 + 8), (uint64_t *)(result + 72));
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  v3 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v3 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v5 + 48 * v3 + 16) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 48 * v3 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v3 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v5 + 48 * v3 + 16) == a2)
        return v5 + 48 * v3 + 24;
    }
    return 0;
  }
  return v5 + 48 * v3 + 24;
}

id *re::NetworkAssetManager::dependencyAssetId@<X0>(re::NetworkAssetManager *this@<X0>, const char *a2@<X2>, unint64_t a3@<X1>, uint64_t a4@<X8>)
{
  id *result;
  uint64_t v8;
  _QWORD *v9;
  id *v10;
  char v11;

  result = (id *)re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a3);
  if (!result)
    goto LABEL_9;
  result = (id *)re::ecs2::EntityHandle::resolve(result, *((_QWORD *)this + 1));
  if (!result)
    goto LABEL_9;
  result = (id *)re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)(result + 4), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);
  if (!result)
    goto LABEL_9;
  v8 = (uint64_t)(result + 14);
  v9 = (_QWORD *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v8, (uint64_t)&v10);
  result = v10;
  if (v10)
  {
    if ((v11 & 1) != 0)
      result = (id *)(*((uint64_t (**)(void))*v10 + 5))();
  }
  if (v9)
  {
    *(_BYTE *)a4 = 1;
    *(_QWORD *)(a4 + 8) = *v9;
  }
  else
  {
LABEL_9:
    *(_BYTE *)a4 = 0;
  }
  return result;
}

id *re::NetworkAssetManager::netComponent(re::NetworkAssetManager *this, unint64_t a2)
{
  id *result;

  result = (id *)re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a2);
  if (result)
  {
    result = (id *)re::ecs2::EntityHandle::resolve(result, *((_QWORD *)this + 1));
    if (result)
      return (id *)re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)(result + 4), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);
  }
  return result;
}

uint64_t re::NetworkAssetManager::localPeerId(re::NetworkAssetManager *this)
{
  return RESyncServiceGetLocalPeerId();
}

id *re::NetworkAssetManager::ownerPeerID@<X0>(re::NetworkAssetManager *this@<X0>, unint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  id *result;
  char *v6;

  result = (id *)re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a2);
  if (result)
  {
    v6 = re::ecs2::EntityHandle::resolve(result, *((_QWORD *)this + 1));
    return (id *)re::NetworkAssetManager::ownerPeerID(a3, this, (uint64_t)v6);
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

_BYTE *re::NetworkAssetManager::ownerPeerID(_BYTE *this, const re::ecs2::Entity *a2, uint64_t a3)
{
  _BYTE *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = this;
  if (a3 && (v4 = *(_QWORD *)(a3 + 200)) != 0)
  {
    v5 = *(_QWORD *)(a3 + 24);
    if (v5 && (*(_BYTE *)(v5 + 288) & 0x80) != 0)
      v5 = 0;
    v6 = *((_QWORD *)a2 + 3);
    if (v6 != v5 || v6 == 0)
    {
      this = *(_BYTE **)(v4 + 32);
      if (this)
        this = (_BYTE *)RESyncableGetOwnerPeerID();
    }
    else
    {
      this = (_BYTE *)RESyncServiceGetLocalPeerId();
    }
    *v3 = 1;
    *((_QWORD *)v3 + 1) = this;
  }
  else
  {
    *this = 0;
  }
  return this;
}

uint64_t re::NetworkAssetManager::fromPeerID@<X0>(re::NetworkAssetManager *this@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result;
  uint64_t v6;

  result = re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a2);
  if (result
    && (result = (uint64_t)re::ecs2::EntityHandle::resolve((id *)result, *((_QWORD *)this + 1))) != 0
    && (v6 = *(_QWORD *)(result + 200)) != 0)
  {
    result = *(_QWORD *)(v6 + 32);
    if (result)
      result = RESyncableGetFromPeerID();
    *(_BYTE *)a3 = 1;
    *(_QWORD *)(a3 + 8) = result;
  }
  else
  {
    *(_BYTE *)a3 = 0;
  }
  return result;
}

uint64_t re::NetworkAssetManager::setUseIndependentScene(uint64_t this, uint64_t a2)
{
  if (*(unsigned __int8 *)(this + 192) != (_DWORD)a2)
  {
    if (*(_QWORD *)(this + 176))
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Network asset manager has already attached to a scene", "m_activeScene == nullptr", "setUseIndependentScene", 208);
      this = _os_crash();
      __break(1u);
    }
    else
    {
      *(_BYTE *)(this + 192) = a2;
    }
  }
  return this;
}

void re::NetworkAssetManager::hackOneTimeSetUp(re::NetworkAssetManager *this)
{
  re *v2;
  NSObject *v3;
  _QWORD *v4;
  NSObject *v5;
  uint8_t v6[16];
  uint8_t buf[16];

  if (!*((_BYTE *)this + 193))
  {
    if (!*((_BYTE *)this + 192))
    {
LABEL_8:
      *((_BYTE *)this + 193) = 1;
      return;
    }
    v2 = (re *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 104))(*((_QWORD *)this + 1));
    if (*((_QWORD *)v2 + 3))
    {
      if (*((_QWORD *)this + 23))
      {
        v3 = *re::assetsLogObjects(v2);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v6 = 0;
          _os_log_impl(&dword_224FE9000, v3, OS_LOG_TYPE_DEFAULT, "Network asset one-time set up: adding asset scene to ECS service", v6, 2u);
        }
        v4 = (_QWORD *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 104))(*((_QWORD *)this + 1));
        re::Collection<re::SharedPtr<re::ecs2::Scene>>::add(v4, (uint64_t *)this + 23);
      }
      goto LABEL_8;
    }
    v5 = *re::assetsLogObjects(v2);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl(&dword_224FE9000, v5, OS_LOG_TYPE_DEBUG, "Delaying network asset one-time set up: no other scenes yet", buf, 2u);
    }
  }
}

void re::Collection<re::SharedPtr<re::ecs2::Scene>>::add(_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  id v5;
  uint64_t v6;
  uint64_t v7;

  v3 = a1[3];
  v4 = *a2;
  v7 = v4;
  if (v4)
    v5 = (id)(v4 + 8);
  (*(void (**)(_QWORD *, uint64_t, uint64_t *))(*a1 + 24))(a1, v3, &v7);
  v6 = a1[3];
  re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::add(a1 + 1, &v7);
  (*(void (**)(_QWORD *, uint64_t, uint64_t *))(*a1 + 48))(a1, v6, &v7);
  if (v7)

}

BOOL re::NetworkAssetManager::shareAsset(uint64_t a1, unint64_t a2, uint64_t *a3, const char **a4, char a5)
{
  re::ecs2::EntityFactory *v10;
  re::ecs2::EntityFactory *v11;
  re::ecs2::Scene **v13;
  uint64_t v14;
  re::ecs2::Scene *v15;
  re::ecs2::Scene *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  re::ecs2::Entity *v25;
  uint64_t v26;
  re::ecs2::Component *v27;
  const char *v28;
  re::DynamicString *v29;
  re::ecs2::Scene *v30;
  uint64_t v31;
  re::ecs2::NetworkComponent *v32;
  char *v33;
  re::ecs2::Component *v34;
  re::ecs2::Component *v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  re::ecs2::Scene *v39[2];

  v10 = (re::ecs2::EntityFactory *)re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 32, a2);
  v11 = v10;
  if (!v10)
  {
    if (*(_BYTE *)(a1 + 192))
    {
      v13 = (re::ecs2::Scene **)(a1 + 184);
      if (!*(_QWORD *)(a1 + 184))
      {
        v37 = 0x70790C8A86948A1ELL;
        v38 = "RootAssetScene";
        re::make::shared::object<re::ecs2::Scene,re::ConstStringID>((re *)&v37, v39);
        v15 = *v13;
        v16 = v39[0];
        *v13 = v39[0];
        v39[0] = v15;
        if (v15)
        {

          v16 = *v13;
        }
        v10 = (re::ecs2::EntityFactory *)re::ecs2::Scene::setHiddenFromSwiftAPI((uint64_t)v16, v14);
        if (*(_BYTE *)(a1 + 193))
        {
          v17 = (_QWORD *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 104))(*(_QWORD *)(a1 + 8));
          re::Collection<re::SharedPtr<re::ecs2::Scene>>::add(v17, (uint64_t *)(a1 + 184));
        }
        v18 = *(_QWORD *)(a1 + 24);
        v19 = *(_QWORD *)(a1 + 184);
        *(_QWORD *)(a1 + 176) = v19;
        if (v18)
          re::Collection<re::SharedPtr<re::ecs2::Scene>>::add((_QWORD *)(*(_QWORD *)(v19 + 104) + 304), (uint64_t *)(a1 + 24));
      }
    }
    v20 = (uint64_t *)(a1 + 24);
    if (!*(_QWORD *)(a1 + 24))
    {
      v21 = re::ecs2::EntityFactory::instance(v10);
      re::ecs2::EntityFactory::make((re::ecs2::EntityFactory *)v21, 4uLL, (re::ecs2::Entity **)&v37);
      v22 = *v20;
      v23 = v37;
      *v20 = v37;
      if (v22)
      {

        v23 = *v20;
      }
      *(_DWORD *)(v23 + 288) |= 0x1400u;
      re::StringID::StringID((re::StringID *)&v37, (const StringID *)(a1 + 200));
      re::StringID::operator=((unint64_t *)(v23 + 272), &v37);
      re::StringID::destroyString((re::StringID *)&v37);
      re::ecs2::EntityComponentCollection::add((re::ecs2::EntityComponentCollection *)(*(_QWORD *)(a1 + 24) + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::LinkedTLEComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);
      re::ecs2::EntityComponentCollection::add((re::ecs2::EntityComponentCollection *)(*(_QWORD *)(a1 + 24) + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
      v24 = *(_QWORD *)(a1 + 176);
      if (v24)
        re::Collection<re::SharedPtr<re::ecs2::Scene>>::add((_QWORD *)(*(_QWORD *)(v24 + 104) + 304), (uint64_t *)(a1 + 24));
    }
    v25 = (re::ecs2::Entity *)*v20;
    re::DynamicString::format((re::DynamicString *)"%s Asset:%llu", (re::DynamicString *)&v37, *a4, a2);
    v26 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                                + 7)
                                                             + 32))(*((_QWORD *)re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType+ 7), 216, 0);
    re::make::shared::inplace<re::ecs2::NetworkAssetComponent>(v26, &v35);
    v27 = v35;
    *((_QWORD *)v35 + 4) = a2;
    v28 = *a4;
    v29 = (re::ecs2::Component *)((char *)v27 + 40);
    v30 = (re::ecs2::Scene *)strlen(v28);
    v39[0] = (re::ecs2::Scene *)v28;
    v39[1] = v30;
    re::DynamicString::operator=(v29, (uint64_t)v39);
    re::DynamicArray<re::AssetLoadDescriptor>::operator=((uint64_t)v35 + 72, a3);
    v31 = v36;
    *((_BYTE *)v35 + 160) = a5;
    v32 = (re::ecs2::NetworkComponent *)re::ecs2::EntityComponentCollection::add((re::ecs2::EntityComponentCollection *)(v31 + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
    v34 = v35;
    if (v35)
      v33 = (char *)v35 + 8;
    re::ecs2::EntityComponentCollection::add(v31 + 32, (uint64_t *)&v34, 1);
    if (v34)
    {

      v34 = 0;
    }
    re::ecs2::NetworkComponent::markDirty(v32, v35);
    if (v35)

    if (v31)
    if (v37 && (v38 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v37 + 40))();
  }
  return v11 == 0;
}

void `anonymous namespace'::makeAssetEntity(_anonymous_namespace_ *this, const re::DynamicString *a2, re::ecs2::Entity *a3)
{
  uint64_t *v6;
  _anonymous_namespace_ *v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10[2];

  v6 = re::ecs2::EntityFactory::instance(this);
  v7 = re::ecs2::EntityFactory::make((re::ecs2::EntityFactory *)v6, 4uLL, (re::ecs2::Entity **)this);
  v8 = *(_QWORD *)this;
  *(_DWORD *)(v8 + 288) |= 0x1400u;
  if ((*((_QWORD *)a2 + 1) & 1) != 0)
    v9 = (const char *)*((_QWORD *)a2 + 2);
  else
    v9 = (char *)a2 + 9;
  v10[0] = 0;
  v10[1] = (uint64_t)&str_110;
  re::StringID::operator=((unint64_t *)(v8 + 272), v10);
  re::StringID::destroyString((re::StringID *)v10);
  re::ecs2::Entity::setParentInternal((re::ecs2::Entity *)v8, a3, 0xFFFFFFFFFFFFFFFFLL);
}

uint64_t re::DynamicArray<re::AssetLoadDescriptor>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::DynamicArray<re::AssetLoadDescriptor>::copy((_QWORD *)a1, (uint64_t)a2);
        ++*(_DWORD *)(a1 + 24);
      }
      else
      {
        re::DynamicArray<re::AssetLoadDescriptor>::clear((_QWORD *)a1);
      }
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<re::AssetLoadDescriptor>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<re::AssetLoadDescriptor>::copy((_QWORD *)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::NetworkAssetManager::preloadAsset(uint64_t a1, re::AssetHandle *this, uint64_t a3)
{
  re *v6;
  unint64_t v7;
  NSObject *v8;
  _BOOL4 v9;
  uint64_t result;
  const char *v11;
  NSObject *v12;
  uint32_t v13;
  re *v14;
  uint64_t v15;
  char *v16;
  re::ecs2::Entity *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  id v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  re::ecs2::EntityComponentCollection *v28;
  void *v29;
  id v30;
  re::ecs2::NetworkComponent *v31;
  uint64_t v32;
  unint64_t *v33;
  uint64_t v34;
  unint64_t v35;
  NSObject *v36;
  _BOOL4 v37;
  uint64_t v38;
  uint64_t v39;
  _BOOL4 v40;
  uint64_t v41;
  uint64_t v42;
  _BOOL4 v43;
  uint64_t v44;
  uint64_t v45;
  _BOOL4 v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char v52;
  uint8_t buf[4];
  _BYTE v54[20];
  uint64_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  v6 = (re *)re::AssetHandle::assetInfo(this);
  v7 = *((_QWORD *)v6 + 10);
  if (v7 + 1 <= 1)
  {
    v8 = *re::assetsLogObjects(v6);
    v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v9)
      return result;
    *(_WORD *)buf = 0;
    v11 = "Will not preload asset with assetID: 0.";
    v12 = v8;
    v13 = 2;
    goto LABEL_46;
  }
  if (!*(_QWORD *)(a3 + 8))
  {
    v36 = *re::assetsLogObjects(v6);
    v37 = os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v37)
      return result;
    v38 = *((_QWORD *)re::AssetHandle::assetInfo(this) + 10);
    if (v38 == -1)
      v38 = 0;
    v39 = **(_QWORD **)(*((_QWORD *)this + 1) + 264);
    *(_DWORD *)buf = 134218242;
    *(_QWORD *)v54 = v38;
    *(_WORD *)&v54[8] = 2080;
    *(_QWORD *)&v54[10] = v39;
    v11 = "Will not preload assetId:%llu, asset type: %s, because there are 0 peerIDs.";
LABEL_45:
    v12 = v36;
    v13 = 22;
LABEL_46:
    _os_log_impl(&dword_224FE9000, v12, OS_LOG_TYPE_DEFAULT, v11, buf, v13);
    return 0;
  }
  v14 = (re *)re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 32, v7);
  if (!v14)
  {
    v36 = *re::assetsLogObjects(0);
    v40 = os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v40)
      return result;
    v41 = *((_QWORD *)re::AssetHandle::assetInfo(this) + 10);
    if (v41 == -1)
      v41 = 0;
    v42 = **(_QWORD **)(*((_QWORD *)this + 1) + 264);
    *(_DWORD *)buf = 134218242;
    *(_QWORD *)v54 = v41;
    *(_WORD *)&v54[8] = 2080;
    *(_QWORD *)&v54[10] = v42;
    v11 = "Failed to preload assetId:%llu, asset type: %s, because there is no assetEntityHandle.";
    goto LABEL_45;
  }
  v15 = *(_QWORD *)(a1 + 8);
  if (!v15)
  {
    v36 = *re::assetsLogObjects(v14);
    v43 = os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v43)
      return result;
    v44 = *((_QWORD *)re::AssetHandle::assetInfo(this) + 10);
    if (v44 == -1)
      v44 = 0;
    v45 = **(_QWORD **)(*((_QWORD *)this + 1) + 264);
    *(_DWORD *)buf = 134218242;
    *(_QWORD *)v54 = v44;
    *(_WORD *)&v54[8] = 2080;
    *(_QWORD *)&v54[10] = v45;
    v11 = "Failed to preload assetId:%llu, asset type: %s, because there is no ECS Service.";
    goto LABEL_45;
  }
  v16 = re::ecs2::EntityHandle::resolve((id *)v14, v15);
  if (!v16)
  {
    v36 = *re::assetsLogObjects(0);
    v46 = os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v46)
      return result;
    v47 = *((_QWORD *)re::AssetHandle::assetInfo(this) + 10);
    if (v47 == -1)
      v47 = 0;
    v48 = **(_QWORD **)(*((_QWORD *)this + 1) + 264);
    *(_DWORD *)buf = 134218242;
    *(_QWORD *)v54 = v47;
    *(_WORD *)&v54[8] = 2080;
    *(_QWORD *)&v54[10] = v48;
    v11 = "Failed to preload assetId:%llu, asset type: %s, because there is no Asset Entity.";
    goto LABEL_45;
  }
  v17 = (re::ecs2::Entity *)v16;
  v18 = *((_QWORD *)v16 + 41);
  if (v18)
  {
    v19 = (uint64_t *)*((_QWORD *)v16 + 43);
    v20 = 8 * v18;
    do
    {
      v21 = *v19;
      if (*v19)
      {
        v22 = (void *)(v21 + 8);
        v23 = (id)(v21 + 8);
        v24 = re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)(v21 + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);

        if (v24)
          return 0;
      }
      else if (re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)0x20, (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType))
      {
        return 0;
      }
      ++v19;
      v20 -= 8;
    }
    while (v20);
  }
  re::DynamicString::format((re::DynamicString *)"AssetPreload for Asset:%llu", (re::DynamicString *)&v51, v7);
  v25 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                              + 7)
                                                           + 32))(*((_QWORD *)re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType+ 7), 56, 0);
  *(_OWORD *)v25 = 0u;
  *(_OWORD *)(v25 + 16) = 0u;
  *(_OWORD *)(v25 + 32) = 0u;
  *(_QWORD *)(v25 + 48) = 0;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v25, 0);
  *(_QWORD *)(v26 + 16) = 0;
  *(_BYTE *)(v26 + 24) = 0;
  *(_QWORD *)v26 = &off_24ED2BC30;
  *(_QWORD *)(v26 + 40) = 0;
  *(_QWORD *)(v26 + 48) = 0;
  *(_QWORD *)(v26 + 32) = 0;
  v27 = v50;
  v28 = (re::ecs2::EntityComponentCollection *)(v50 + 32);
  v49 = v26;
  v29 = (void *)(v26 + 8);
  v30 = (id)(v26 + 8);
  re::ecs2::EntityComponentCollection::add((uint64_t)v28, &v49, 1);
  if (v49)
  {

    v49 = 0;
  }
  v31 = (re::ecs2::NetworkComponent *)re::ecs2::EntityComponentCollection::add(v28, (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
  re::ecs2::NetworkComponent::setNetworkShareMode(v31, 0);
  *(_DWORD *)buf = 1;
  v57 = 0;
  *(_QWORD *)&v54[12] = 0;
  v55 = 0;
  *(_QWORD *)&v54[4] = 0;
  v56 = 0;
  v32 = *(_QWORD *)(a3 + 8);
  if (v32)
  {
    v33 = *(unint64_t **)a3;
    v34 = 8 * v32;
    do
    {
      v35 = *v33++;
      re::ecs2::SyncAccessControl::addEntry(buf, v35, 0);
      v34 -= 8;
    }
    while (v34);
  }
  re::ecs2::NetworkComponent::setAccessControl((uint64_t)v31, (uint64_t *)buf);
  re::ecs2::NetworkComponent::markDirty(v31, (const re::ecs2::Component *)v25);
  if (*(_QWORD *)&v54[4] && v57)
    (*(void (**)(void))(**(_QWORD **)&v54[4] + 40))();

  if (v27)
  if (v51)
  {
    if ((v52 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v51 + 40))();
  }
  return 1;
}

void re::NetworkAssetManager::willAddScene(re::NetworkAssetManager *this, re::ecs2::Scene *a2)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (!*((_BYTE *)this + 192) && !*((_QWORD *)this + 22) && !*((_QWORD *)a2 + 47))
  {
    v4 = (uint64_t *)((char *)this + 24);
    v3 = *((_QWORD *)this + 3);
    *((_QWORD *)this + 22) = a2;
    if (!v3)
      goto LABEL_8;
    do
    {
      v5 = v3;
      v3 = *(_QWORD *)(v3 + 24);
    }
    while (v3);
    if (!*(_QWORD *)(v5 + 16))
    {
      v8 = *re::assetsLogObjects(this);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *((_QWORD *)a2 + 5);
        v10 = 136315138;
        v11 = v9;
        _os_log_impl(&dword_224FE9000, v8, OS_LOG_TYPE_DEFAULT, "Adding asset root entity to scene '%s'", (uint8_t *)&v10, 0xCu);
      }
      re::Collection<re::SharedPtr<re::ecs2::Scene>>::add((_QWORD *)(*((_QWORD *)a2 + 13) + 304), v4);
    }
    else
    {
LABEL_8:
      v6 = *re::assetsLogObjects(this);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *((_QWORD *)a2 + 5);
        v10 = 136315138;
        v11 = v7;
        _os_log_impl(&dword_224FE9000, v6, OS_LOG_TYPE_DEFAULT, "Asset root entity will be attached to scene '%s'", (uint8_t *)&v10, 0xCu);
      }
    }
  }
}

void re::NetworkAssetManager::willRemoveScene(re::NetworkAssetManager *this, re::ecs2::Scene *a2)
{
  re::ecs2::Entity *v4;
  re *v5;
  uint64_t v6;
  re::ecs2::Scene **v7;
  re::ecs2::Scene **v8;
  re::ecs2::Scene *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint8_t buf[4];
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  if (!*((_BYTE *)this + 192) && *((re::ecs2::Scene **)this + 22) == a2)
  {
    v4 = (re::ecs2::Entity *)*((_QWORD *)this + 3);
    if (v4)
      re::ecs2::Entity::removeFromSceneOrParent(v4);
    *((_QWORD *)this + 22) = 0;
    v5 = (re *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 104))(*((_QWORD *)this + 1));
    v6 = *((_QWORD *)v5 + 3);
    if (v6)
    {
      v7 = (re::ecs2::Scene **)*((_QWORD *)v5 + 5);
      v8 = &v7[v6];
      do
      {
        v9 = *v7;
        if (*v7 != a2 && !*((_QWORD *)v9 + 47))
        {
          *((_QWORD *)this + 22) = v9;
          v10 = *((_QWORD *)this + 3);
          if (v10)
          {
            do
            {
              v11 = v10;
              v10 = *(_QWORD *)(v10 + 24);
            }
            while (v10);
            if (!*(_QWORD *)(v11 + 16))
            {
              v12 = *re::assetsLogObjects(v5);
              if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
              {
                v13 = *((_QWORD *)a2 + 5);
                v14 = *(_QWORD *)(*((_QWORD *)this + 22) + 40);
                *(_DWORD *)buf = 136315394;
                v18 = v13;
                v19 = 2080;
                v20 = v14;
                _os_log_impl(&dword_224FE9000, v12, OS_LOG_TYPE_DEFAULT, "Moving asset root entity from scene '%s' to '%s'", buf, 0x16u);
              }
              re::Collection<re::SharedPtr<re::ecs2::Scene>>::add((_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 22) + 104) + 304), (uint64_t *)this + 3);
            }
          }
        }
        ++v7;
      }
      while (v7 != v8);
    }
    if (!*((_QWORD *)this + 22))
    {
      v15 = *re::assetsLogObjects(v5);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        v16 = *((_QWORD *)a2 + 5);
        *(_DWORD *)buf = 136315138;
        v18 = v16;
        _os_log_impl(&dword_224FE9000, v15, OS_LOG_TYPE_DEFAULT, "Detached asset root entity from removed scene '%s'", buf, 0xCu);
      }
    }
  }
}

uint64_t re::NetworkAssetManager::unshareAsset(re::NetworkAssetManager *this, unint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  result = (*(uint64_t (**)(re::NetworkAssetManager *))(*(_QWORD *)this + 112))(this);
  if ((_DWORD)result)
  {
    result = re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a2);
    if (result)
    {
      result = (uint64_t)re::ecs2::EntityHandle::resolve((id *)result, *((_QWORD *)this + 1));
      if (result)
      {
        v5 = *(_QWORD *)(result + 24);
        if (v5 && (*(_BYTE *)(v5 + 288) & 0x80) != 0)
          v5 = 0;
        if (*((_QWORD *)this + 3) == v5)
        {
          re::ecs2::Entity::removeFromSceneOrParent((re::ecs2::Entity *)result);
          re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this + 32, a2);
          return 1;
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

void re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int *v13;
  int v14;
  uint64_t v15;
  int v16;

  if (*(_QWORD *)a1)
  {
    v3 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    v4 = (v3 ^ (v3 >> 31)) % *(unsigned int *)(a1 + 24);
    v5 = *(_QWORD *)(a1 + 8);
    v6 = *(unsigned int *)(v5 + 4 * v4);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a1 + 16);
      if (*(_QWORD *)(v7 + 48 * v6 + 16) == a2)
      {
        *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v7 + 48 * v6 + 8) & 0x7FFFFFFF;
LABEL_8:
        v10 = *(_QWORD *)(a1 + 16);
        v11 = v10 + 48 * v6;
        v14 = *(_DWORD *)(v11 + 8);
        v13 = (int *)(v11 + 8);
        v12 = v14;
        if (v14 < 0)
        {
          *v13 = v12 & 0x7FFFFFFF;
          v15 = v10 + 48 * v6;
          re::ecs2::EntityHandle::reset((id *)(v15 + 24));
          objc_destroyWeak((id *)(v15 + 24));
          *(_QWORD *)(v15 + 24) = 0;
          v10 = *(_QWORD *)(a1 + 16);
          v12 = *(_DWORD *)(v10 + 48 * v6 + 8);
        }
        v16 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(v10 + 48 * v6 + 8) = *(_DWORD *)(a1 + 36) | v12 & 0x80000000;
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v6;
        *(_DWORD *)(a1 + 40) = v16 + 1;
      }
      else
      {
        while (1)
        {
          v8 = v6;
          v9 = *(_DWORD *)(v7 + 48 * v6 + 8);
          v6 = v9 & 0x7FFFFFFF;
          if ((v9 & 0x7FFFFFFF) == 0x7FFFFFFF)
            break;
          if (*(_QWORD *)(v7 + 48 * v6 + 16) == a2)
          {
            *(_DWORD *)(v7 + 48 * v8 + 8) = *(_DWORD *)(v7 + 48 * v8 + 8) & 0x80000000 | *(_DWORD *)(v7 + 48 * v6 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
}

uint64_t re::NetworkAssetManager::setAssetChangeCallback(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 224) = a2;
  return result;
}

uint64_t re::NetworkAssetManager::updateAssetState(const re::ecs2::Entity *a1, unint64_t a2, char a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  const re::ecs2::Component *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  re::ecs2::NetworkComponent *v18;
  re::ecs2::Entity *v19;
  _anonymous_namespace_ *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  id v25;
  re::ecs2::NetworkComponent *v26;
  re::ecs2::NetworkComponent *v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  _BYTE v37[23];
  _BYTE v38[8];
  unint64_t v39;

  if (!*((_BYTE *)a1 + 216))
    return 0;
  result = re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)a1 + 32, a2);
  if (result)
  {
    result = (uint64_t)re::ecs2::EntityHandle::resolve((id *)result, *((_QWORD *)a1 + 1));
    if (result)
    {
      v7 = result;
      v8 = *(_QWORD *)(result + 328);
      if (v8)
      {
        v9 = *(_QWORD **)(result + 344);
        v10 = 8 * v8;
        while (1)
        {
          v11 = (_QWORD *)*v9;
          if (*v9)
            v12 = v11 + 1;
          v13 = re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)(v11 + 4), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);
          if (v13)
          {
            v14 = (const re::ecs2::Component *)v13;
            v15 = *(_QWORD *)(v13 + 40);
            if (v15 == (*(uint64_t (**)(const re::ecs2::Entity *))(*(_QWORD *)a1 + 104))(a1))
              break;
          }
          if (v11)

          ++v9;
          v10 -= 8;
          if (!v10)
            goto LABEL_13;
        }
        *((_BYTE *)v14 + 48) = a3;
        v18 = (re::ecs2::NetworkComponent *)v11[25];
        if (v18)
          re::ecs2::NetworkComponent::markDirty(v18, v14);

        return 1;
      }
LABEL_13:
      v16 = (*(uint64_t (**)(const re::ecs2::Entity *))(*(_QWORD *)a1 + 104))(a1);
      re::NetworkAssetManager::ownerPeerID(v38, a1, v7);
      if (v38[0])
      {
        v17 = v39;
        if (v39 != v16)
        {
          v19 = re::ecs2::EntityChildCollection::add((re::ecs2::EntityChildCollection *)(v7 + 304));
          v20 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"AssetState for Asset:%llu, Peer:%llu", (re::DynamicString *)&v35, a2, v16);
          if ((v36 & 1) != 0)
            v21 = *(const char **)&v37[7];
          else
            v21 = v37;
          v28 = 0;
          v29 = &str_110;
          re::StringID::operator=((unint64_t *)v19 + 34, &v28);
          re::StringID::destroyString((re::StringID *)&v28);
          v22 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**((_QWORD **)re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
                                                                      + 7)
                                                                   + 32))(*((_QWORD *)re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType+ 7), 56, 0);
          *(_OWORD *)v22 = 0u;
          *(_OWORD *)(v22 + 16) = 0u;
          *(_OWORD *)(v22 + 32) = 0u;
          *(_QWORD *)(v22 + 48) = 0;
          ArcSharedObject::ArcSharedObject((ArcSharedObject *)v22, 0);
          *(_QWORD *)(v23 + 16) = 0;
          *(_BYTE *)(v23 + 24) = 0;
          *(_QWORD *)v23 = &off_24ED2BCB0;
          *(_QWORD *)(v23 + 32) = a2;
          *(_QWORD *)(v23 + 40) = v16;
          v34 = v23;
          v24 = (void *)(v23 + 8);
          v25 = (id)(v23 + 8);
          re::ecs2::EntityComponentCollection::add((uint64_t)v19 + 32, &v34, 1);
          if (v34)
          {

            v34 = 0;
          }
          v26 = (re::ecs2::NetworkComponent *)re::ecs2::EntityComponentCollection::add((re::ecs2::Entity *)((char *)v19 + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
          re::ecs2::NetworkComponent::setNetworkShareMode(v26, 0);
          LODWORD(v28) = 1;
          v33 = 0;
          v30 = 0;
          v31 = 0;
          v29 = 0;
          v32 = 0;
          re::ecs2::SyncAccessControl::addEntry(&v28, v17, 0);
          re::ecs2::NetworkComponent::setAccessControl((uint64_t)v26, &v28);
          *(_BYTE *)(v22 + 48) = a3;
          v27 = (re::ecs2::NetworkComponent *)*((_QWORD *)v19 + 25);
          if (v27)
            re::ecs2::NetworkComponent::markDirty(v27, (const re::ecs2::Component *)v22);
          if (v29 && v33)
            (*(void (**)(void))(*(_QWORD *)v29 + 40))();

          if (v35)
          {
            if ((v36 & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v35 + 40))();
          }
          return 1;
        }
      }
      return 0;
    }
  }
  return result;
}

BOOL re::NetworkAssetManager::clearAssetDescriptors(re::NetworkAssetManager *this, unint64_t a2)
{
  id *v3;
  id *v4;
  char *v5;
  const re::ecs2::Component *v6;
  uint64_t v7;
  re::ecs2::NetworkComponent *v8;

  v3 = (id *)re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a2);
  v4 = v3;
  if (v3)
  {
    v5 = re::ecs2::EntityHandle::resolve(v3, *((_QWORD *)this + 1));
    v6 = (const re::ecs2::Component *)re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)(v5 + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);
    re::DynamicArray<re::AssetLoadDescriptor>::clear((_QWORD *)v6 + 9);
    v7 = *((_QWORD *)v6 + 2);
    if (v7)
    {
      v8 = *(re::ecs2::NetworkComponent **)(v7 + 200);
      if (v8)
        re::ecs2::NetworkComponent::markDirty(v8, v6);
    }
  }
  return v4 != 0;
}

_QWORD *re::DynamicArray<re::AssetLoadDescriptor>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v1 = result;
  v2 = result[2];
  result[2] = 0;
  if (v2)
  {
    v3 = result[4] + 64;
    v4 = 144 * v2;
    do
    {
      v5 = *(_QWORD *)(v3 + 48);
      if (v5)
      {
        if ((*(_BYTE *)(v3 + 56) & 1) != 0)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *(_QWORD *)(v3 + 64));
        *(_OWORD *)(v3 + 48) = 0u;
        *(_OWORD *)(v3 + 64) = 0u;
      }
      v6 = *(_QWORD *)(v3 + 8);
      if (v6)
      {
        if (*(_QWORD *)(v3 + 40))
          (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
        *(_QWORD *)(v3 + 40) = 0;
        *(_QWORD *)(v3 + 16) = 0;
        *(_QWORD *)(v3 + 24) = 0;
        *(_QWORD *)(v3 + 8) = 0;
        ++*(_DWORD *)(v3 + 32);
      }
      v7 = *(_QWORD *)(v3 - 32);
      if (v7)
      {
        if (*(_QWORD *)v3)
          (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
        *(_QWORD *)v3 = 0;
        *(_QWORD *)(v3 - 24) = 0;
        *(_QWORD *)(v3 - 16) = 0;
        *(_QWORD *)(v3 - 32) = 0;
        ++*(_DWORD *)(v3 - 8);
      }
      result = *(_QWORD **)(v3 - 64);
      if (result)
      {
        if ((*(_BYTE *)(v3 - 56) & 1) != 0)
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, _QWORD))(*result + 40))(result, *(_QWORD *)(v3 - 48));
        *(_OWORD *)(v3 - 64) = 0u;
        *(_OWORD *)(v3 - 48) = 0u;
      }
      v3 += 144;
      v4 -= 144;
    }
    while (v4);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

BOOL re::NetworkAssetManager::setAssetDependencies(re::NetworkAssetManager *a1, unint64_t a2, uint64_t a3)
{
  id *v4;
  id *v5;
  id v6;
  re::ecs2::NetworkComponent *v7;

  v4 = re::NetworkAssetManager::netComponent(a1, a2);
  v5 = v4;
  if (v4)
  {
    re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=((uint64_t)(v4 + 14), a3);
    v6 = v5[2];
    if (v6)
    {
      v7 = (re::ecs2::NetworkComponent *)*((_QWORD *)v6 + 25);
      if (v7)
        re::ecs2::NetworkComponent::markDirty(v7, (const re::ecs2::Component *)v5);
    }
  }
  return v5 != 0;
}

uint64_t re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  signed int v5;

  if (a1 != a2)
  {
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 40);
      }
      else
      {
        re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
      }
    }
    else if (v4)
    {
      if (*(_DWORD *)(a2 + 28) <= 3u)
        v5 = 3;
      else
        v5 = *(_DWORD *)(a2 + 28);
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init(a1, v4, v5);
      re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(a1, a2);
    }
  }
  return a1;
}

void re::NetworkAssetManager::updateSharedMetadata(re::NetworkAssetManager *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6;
  id *v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  id v18;
  re::ecs2::NetworkComponent *v19;
  _QWORD v20[2];

  (*(void (**)(_QWORD *__return_ptr))(*(_QWORD *)a1 + 120))(v20);
  if (LOBYTE(v20[0]))
  {
    v6 = v20[1];
    if (v6 == (*(uint64_t (**)(re::NetworkAssetManager *))(*(_QWORD *)a1 + 104))(a1))
    {
      v7 = re::NetworkAssetManager::netComponent(a1, a2);
      re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear((uint64_t)(v7 + 21));
      v8 = *(unsigned int *)(a3 + 32);
      if ((_DWORD)v8)
      {
        v9 = 0;
        v10 = *(int **)(a3 + 16);
        while (1)
        {
          v11 = *v10;
          v10 += 16;
          if (v11 < 0)
            break;
          if (v8 == ++v9)
          {
            LODWORD(v9) = *(_DWORD *)(a3 + 32);
            break;
          }
        }
      }
      else
      {
        LODWORD(v9) = 0;
      }
      if ((_DWORD)v8 != (_DWORD)v9)
      {
        v12 = v9;
        v13 = *(_QWORD *)(a3 + 16);
        v14 = *(_DWORD *)(a3 + 32);
        do
        {
          v15 = v13 + (v12 << 6);
          if (*(_BYTE *)(v15 + 24))
          {
            re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add<re::DynamicString&>((uint64_t)(v7 + 21), (StringID *)(v15 + 8), (const re::DynamicString *)(v15 + 32));
            v14 = *(_DWORD *)(a3 + 32);
            v13 = *(_QWORD *)(a3 + 16);
          }
          if (v14 <= (int)v9 + 1)
            v16 = v9 + 1;
          else
            v16 = v14;
          while (1)
          {
            v12 = (v9 + 1);
            if (v16 - 1 == (_DWORD)v9)
              break;
            LODWORD(v9) = v9 + 1;
            v17 = v12;
            if ((*(_DWORD *)(v13 + (v12 << 6)) & 0x80000000) != 0)
              goto LABEL_20;
          }
          v17 = v16;
LABEL_20:
          LODWORD(v9) = v17;
        }
        while ((_DWORD)v8 != v17);
      }
      v18 = v7[2];
      if (v18)
      {
        v19 = (re::ecs2::NetworkComponent *)*((_QWORD *)v18 + 25);
        if (v19)
          re::ecs2::NetworkComponent::markDirty(v19, (const re::ecs2::Component *)v7);
      }
    }
  }
}

void re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_2260EB7B0, 4 * v2);
    if (*(_DWORD *)(a1 + 32))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::EntryWithoutHash::free(*(_QWORD *)(a1 + 16) + v3);
        ++v4;
        v3 += 56;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

uint64_t re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::add<re::DynamicString&>(uint64_t a1, StringID *a2, const re::DynamicString *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;

  v6 = 0xBF58476D1CE4E5B9 * ((*(_QWORD *)&a2->var0 >> 31) ^ (*(_QWORD *)&a2->var0 >> 1));
  v7 = (0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v7 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v11 = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<re::DynamicString&>(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 56 * v11;
    return v12 + 24;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (!re::StringID::operator==((_QWORD *)(v10 + 56 * v9 + 8), a2))
  {
    v9 = *(_DWORD *)(v10 + 56 * v9) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v10 + 56 * v9;
  return v12 + 24;
}

re::DynamicString *re::NetworkAssetManager::getSharedMetadataString@<X0>(re::NetworkAssetManager *this@<X0>, const re::StringID *a2@<X2>, unint64_t a3@<X1>, _BYTE *a4@<X8>)
{
  re::DynamicString *result;

  result = (re::DynamicString *)re::NetworkAssetManager::netComponent(this, a3);
  if (result
    && (result = (re::DynamicString *)re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet((uint64_t)result + 168, a2)) != 0)
  {
    *a4 = 1;
    return re::DynamicString::DynamicString((re::DynamicString *)(a4 + 8), result);
  }
  else
  {
    *a4 = 0;
  }
  return result;
}

uint64_t re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(uint64_t a1, _QWORD *a2)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!*(_QWORD *)a1)
    return 0;
  v3 = 0xBF58476D1CE4E5B9 * ((*a2 >> 31) ^ (*a2 >> 1));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  while (!re::StringID::operator==((_QWORD *)(v5 + 56 * v4 + 8), a2))
  {
    v4 = *(_DWORD *)(v5 + 56 * v4) & 0x7FFFFFFF;
    if (v4 == 0x7FFFFFFF)
      return 0;
  }
  return v5 + 56 * v4 + 24;
}

id *re::NetworkAssetManager::tryGetSharedMetadata(re::NetworkAssetManager *this, unint64_t a2)
{
  id *v2;

  v2 = re::NetworkAssetManager::netComponent(this, a2);
  if (v2)
    return v2 + 21;
  else
    return 0;
}

id *re::NetworkAssetManager::copySharedMetadata(re::NetworkAssetManager *a1, unint64_t a2, uint64_t a3)
{
  id *result;

  result = re::NetworkAssetManager::netComponent(a1, a2);
  if (result)
    return (id *)re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=(a3, (uint64_t)(result + 21));
  return result;
}

uint64_t re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  signed int v5;

  if (a1 != a2)
  {
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
      {
        re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(a1, a2);
        ++*(_DWORD *)(a1 + 40);
      }
      else
      {
        re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(a1);
      }
    }
    else if (v4)
    {
      if (*(_DWORD *)(a2 + 28) <= 3u)
        v5 = 3;
      else
        v5 = *(_DWORD *)(a2 + 28);
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init(a1, v4, v5);
      re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(a1, a2);
    }
  }
  return a1;
}

void re::NetworkAssetManager::copySharedMetadata(re::NetworkAssetManager *this, unint64_t a2, __CFDictionary **a3)
{
  id *v4;
  id *v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  CFStringRef v13;
  const char *v14;
  CFStringRef v15;
  unsigned int v16;
  unsigned int v17;

  v4 = re::NetworkAssetManager::netComponent(this, a2);
  if (v4)
  {
    v5 = v4;
    v6 = *((unsigned int *)v4 + 50);
    if ((_DWORD)v6)
    {
      v7 = 0;
      v8 = (int *)v4[23];
      while (1)
      {
        v9 = *v8;
        v8 += 14;
        if (v9 < 0)
          break;
        if (v6 == ++v7)
        {
          LODWORD(v7) = *((_DWORD *)v4 + 50);
          break;
        }
      }
    }
    else
    {
      LODWORD(v7) = 0;
    }
    if ((_DWORD)v6 != (_DWORD)v7)
    {
      v10 = v7;
      do
      {
        v11 = v5[23];
        v12 = &v11[7 * v10];
        v13 = CFStringCreateWithCString(0, (const char *)v12[2], 0x8000100u);
        if ((v12[4] & 1) != 0)
          v14 = (const char *)v11[7 * v10 + 5];
        else
          v14 = (char *)&v11[7 * v10 + 4] + 1;
        v15 = CFStringCreateWithCString(0, v14, 0x8000100u);
        CFDictionaryAddValue(*a3, v13, v15);
        CFRelease(v13);
        CFRelease(v15);
        v16 = *((_DWORD *)v5 + 50);
        if (v16 <= (int)v7 + 1)
          v16 = v7 + 1;
        while (1)
        {
          v10 = (v7 + 1);
          if (v16 - 1 == (_DWORD)v7)
            break;
          LODWORD(v7) = v7 + 1;
          v17 = v10;
          if ((*((_DWORD *)v5[23] + 14 * v10) & 0x80000000) != 0)
            goto LABEL_19;
        }
        v17 = v16;
LABEL_19:
        LODWORD(v7) = v17;
      }
      while ((_DWORD)v6 != v17);
    }
  }
}

BOOL re::NetworkAssetManager::onAdd(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  _BOOL4 v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  re::EventBus *v17;
  re *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  re *v24;
  uint64_t *v25;
  _QWORD *v26;
  unsigned __int8 v27;
  unint64_t v28;
  const char *v29;
  NSObject *v30;
  _BOOL4 v31;
  uint64_t v32;
  __guard Type;
  _BOOL4 v35;
  _QWORD v37[2];
  unint64_t v38;
  int v39;
  uint64_t v40;
  _QWORD v41[2];
  __int128 location;
  unint64_t v43;
  _QWORD v44[3];
  int v45;
  uint64_t v46;
  _QWORD v47[3];
  int v48;
  uint64_t v49;
  _QWORD v50[4];
  int v51;
  const char *v52;
  __int16 v53;
  int v54;
  __int16 v55;
  unint64_t v56;
  __int16 v57;
  unint64_t v58;
  _QWORD v59[14];

  v59[11] = *MEMORY[0x24BDAC8D0];
  v41[0] = a2;
  v7 = (_QWORD *)(a1 + 32);
  v8 = re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(a1 + 32, a2);
  if (v8)
    return !v8;
  re::ecs2::EntityHandle::EntityHandle((uint64_t)&location, a4);
  v9 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  v10 = v9 ^ (v9 >> 31);
  if (*v7)
  {
    v11 = v10 % *(unsigned int *)(a1 + 56);
    v12 = *(unsigned int *)(*(_QWORD *)(a1 + 40) + 4 * v11);
    if ((_DWORD)v12 != 0x7FFFFFFF)
    {
      v13 = *(_QWORD *)(a1 + 48);
      if (*(_QWORD *)(v13 + 48 * v12 + 16) == a2)
        goto LABEL_10;
      while (1)
      {
        LODWORD(v12) = *(_DWORD *)(v13 + 48 * v12 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v12 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v13 + 48 * v12 + 16) == a2)
          goto LABEL_10;
      }
    }
  }
  else
  {
    LODWORD(v11) = 0;
  }
  re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove((uint64_t)v7, v11, v10, v41, (uint64_t)&location);
  ++*(_DWORD *)(a1 + 72);
LABEL_10:
  re::ecs2::EntityHandle::reset((id *)&location);
  objc_destroyWeak((id *)&location);
  v14 = re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 80, a2);
  if (v14)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v14 + 32) + 16))(*(_QWORD *)(v14 + 32));
    re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t (***)(_QWORD))(a1 + 80), a2);
  }
  v15 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8));
  v16 = re::ServiceLocator::serviceOrNull<re::EventBus>(v15);
  if (v16)
  {
    v17 = (re::EventBus *)v16;
    v35 = v8;
    v40 = 0;
    v37[1] = 0;
    v38 = 0;
    v37[0] = 0;
    v39 = 0;
    re::DynamicArray<re::SharedPtr<re::Shareable<re::AssetLoadDescriptor>>>::resize((uint64_t)v37, *(_QWORD *)(a3 + 16));
    v19 = *(_QWORD *)(a3 + 16);
    if (v19)
    {
      v20 = 0;
      v21 = 0;
      v22 = *(uint64_t **)(a3 + 32);
      v23 = 144 * v19;
      while (1)
      {
        re::DynamicString::DynamicString((re::DynamicString *)&location, (const re::DynamicString *)v22);
        re::DynamicArray<BOOL>::DynamicArray((uint64_t)v44, v22 + 4);
        re::DynamicArray<BOOL>::DynamicArray((uint64_t)v47, v22 + 9);
        v24 = re::DynamicString::DynamicString((re::DynamicString *)v50, (const re::DynamicString *)(v22 + 14));
        v25 = re::globalAllocators(v24);
        v26 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v25[2] + 32))(v25[2], 168, 8);
        v59[0] = re::Shareable<re::AssetLoadDescriptor>::Shareable<re::AssetLoadDescriptor&>(v26, (uint64_t *)&location);
        v27 = atomic_load((unsigned __int8 *)&qword_2540FB488);
        if ((v27 & 1) == 0 && __cxa_guard_acquire(&qword_2540FB488))
        {
          _MergedGlobals_34 = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"41RENetworkNewAssetLoadDescriptorAddedEvent" & 0x7FFFFFFFFFFFFFFFLL), v29);
          __cxa_guard_release(&qword_2540FB488);
        }
        re::EventBus::publish(v17, a4, _MergedGlobals_34, (uint64_t)v59, 8uLL, 0);
        v28 = v38;
        if (v38 <= v21)
          break;
        re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)(v40 + v20), (uint64_t)v26);
        if (v26)

        if (v50[0])
        {
          if ((v50[1] & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v50[0] + 40))();
          memset(v50, 0, sizeof(v50));
        }
        if (v47[0])
        {
          if (v49)
            (*(void (**)(void))(*(_QWORD *)v47[0] + 40))();
          v49 = 0;
          memset(v47, 0, sizeof(v47));
          ++v48;
        }
        if (v44[0])
        {
          if (v46)
            (*(void (**)(void))(*(_QWORD *)v44[0] + 40))();
          v46 = 0;
          memset(v44, 0, sizeof(v44));
          ++v45;
        }
        v18 = (re *)location;
        if ((_QWORD)location && (BYTE8(location) & 1) != 0)
          v18 = (re *)(*(uint64_t (**)(void))(*(_QWORD *)location + 40))();
        v22 += 18;
        v20 += 8;
        ++v21;
        v23 -= 144;
        if (!v23)
          goto LABEL_38;
      }
      v41[1] = 0;
      v17 = (re::EventBus *)&v51;
      memset(v59, 0, 80);
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v51 = 136315906;
      v52 = "operator[]";
      v53 = 1024;
      v54 = 789;
      v55 = 2048;
      v56 = v21;
      v57 = 2048;
      v58 = v28;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
LABEL_38:
      if (re::assetsHighFrequencyLoggingEnabled(void)::onceToken == -1)
      {
LABEL_39:
        if (re::assetsHighFrequencyLoggingEnabled(void)::shouldLog)
        {
          v30 = *re::assetsLogObjects(v18);
          v31 = os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
          v32 = v41[0];
          if (v31)
          {
            LODWORD(location) = 134217984;
            *(_QWORD *)((char *)&location + 4) = v41[0];
            _os_log_impl(&dword_224FE9000, v30, OS_LOG_TYPE_DEFAULT, "AssetId %llu added over network", (uint8_t *)&location, 0xCu);
          }
        }
        else
        {
          v32 = v41[0];
        }
        *(_QWORD *)&location = v32;
        *((_QWORD *)&location + 1) = v40;
        v43 = v38;
        Type = re::EventBus::getTypeId<RENetworkAssetAddedEvent>();
        re::EventBus::publish(v17, a4, Type, (uint64_t)&location, 0x18uLL, 0);
        re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)v37);
        v8 = v35;
        return !v8;
      }
    }
    dispatch_once(&re::assetsHighFrequencyLoggingEnabled(void)::onceToken, &__block_literal_global_1);
    goto LABEL_39;
  }
  return !v8;
}

BOOL re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  _BOOL8 result;
  uint64_t v5;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  v3 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v3 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v5 + 48 * v3 + 16) == a2)
    return 1;
  do
  {
    LODWORD(v3) = *(_DWORD *)(v5 + 48 * v3 + 8) & 0x7FFFFFFF;
    result = (_DWORD)v3 != 0x7FFFFFFF;
  }
  while ((_DWORD)v3 != 0x7FFFFFFF && *(_QWORD *)(v5 + 48 * v3 + 16) != a2);
  return result;
}

uint64_t re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  v3 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v3 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v5 + (v3 << 6) + 16) != a2)
  {
    while (1)
    {
      v3 = *(_DWORD *)(v5 + (v3 << 6) + 8) & 0x7FFFFFFF;
      if ((_DWORD)v3 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v5 + (v3 << 6) + 16) == a2)
        return v5 + (v3 << 6) + 24;
    }
    return 0;
  }
  return v5 + (v3 << 6) + 24;
}

uint64_t (***re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(uint64_t (***result)(_QWORD), unint64_t a2))(_QWORD)
{
  uint64_t (***v2)(_QWORD);
  unint64_t v3;
  unint64_t v4;
  uint64_t (**v5)(_QWORD);
  uint64_t v6;
  uint64_t (**v7)(_QWORD);
  uint64_t (**v8)(_QWORD);
  unsigned int v9;
  int v10;
  uint64_t (**v11)(_QWORD);
  uint64_t (**v12)(_QWORD);
  uint64_t (**v13)(_QWORD);
  int v14;
  int *v15;
  int v16;
  int v17;

  if (*result)
  {
    v2 = result;
    v3 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    v4 = (v3 ^ (v3 >> 31)) % *((unsigned int *)result + 6);
    v5 = result[1];
    v6 = *((unsigned int *)v5 + v4);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = result[2];
      v8 = &v7[8 * v6];
      if (v8[2] == (uint64_t (*)(_QWORD))a2)
      {
        *((_DWORD *)v5 + v4) = (_DWORD)v8[1] & 0x7FFFFFFF;
LABEL_8:
        v12 = result[2];
        v13 = &v12[8 * v6];
        v16 = *((_DWORD *)v13 + 2);
        v15 = (int *)(v13 + 1);
        v14 = v16;
        if (v16 < 0)
        {
          *v15 = v14 & 0x7FFFFFFF;
          result = re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable((uint64_t)&v12[8 * v6 + 3]);
          v12 = v2[2];
          v14 = (int)v12[8 * v6 + 1];
        }
        v17 = *((_DWORD *)v2 + 10);
        LODWORD(v12[8 * v6 + 1]) = *((_DWORD *)v2 + 9) | v14 & 0x80000000;
        --*((_DWORD *)v2 + 7);
        *((_DWORD *)v2 + 9) = v6;
        *((_DWORD *)v2 + 10) = v17 + 1;
      }
      else
      {
        while (1)
        {
          v9 = v6;
          v10 = (int)v7[8 * v6 + 1];
          v6 = v10 & 0x7FFFFFFF;
          if ((v10 & 0x7FFFFFFF) == 0x7FFFFFFF)
            break;
          v11 = &v7[8 * v6];
          if (v11[2] == (uint64_t (*)(_QWORD))a2)
          {
            LODWORD(v7[8 * (unint64_t)v9 + 1]) = (uint64_t)v7[8 * (unint64_t)v9 + 1] & 0x80000000 | (_DWORD)v11[1] & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
  return result;
}

void re::DynamicArray<re::SharedPtr<re::Shareable<re::AssetLoadDescriptor>>>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v4 = *(_QWORD *)(a1 + 16);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return;
    v5 = a2;
    do
    {
      v6 = *(_QWORD *)(a1 + 32);
      v7 = *(_QWORD *)(v6 + 8 * v5);
      if (v7)
      {

        *(_QWORD *)(v6 + 8 * v5) = 0;
        v4 = *(_QWORD *)(a1 + 16);
      }
      ++v5;
    }
    while (v5 < v4);
  }
  else
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity((_QWORD *)a1, a2);
      v4 = *(_QWORD *)(a1 + 16);
    }
    if (a2 > v4)
      bzero((void *)(*(_QWORD *)(a1 + 32) + 8 * v4), 8 * (a2 - v4));
  }
  *(_QWORD *)(a1 + 16) = a2;
  ++*(_DWORD *)(a1 + 24);
}

BOOL re::NetworkAssetManager::isAssetIdLocal(re::NetworkAssetManager *this)
{
  uint64_t v2;
  _QWORD v4[2];

  (*(void (**)(_QWORD *__return_ptr))(*(_QWORD *)this + 120))(v4);
  if (!LOBYTE(v4[0]))
    return 1;
  v2 = (*(uint64_t (**)(re::NetworkAssetManager *))(*(_QWORD *)this + 104))(this);
  return v2 == v4[1];
}

uint64_t re::NetworkAssetManager::onRemove(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  re *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  re *v15;
  uint64_t *v16;
  _QWORD *v17;
  unint64_t v18;
  NSObject *v19;
  __guard Type;
  re::EventBus *v22;
  _QWORD v23[2];
  unint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  __int128 buf;
  unint64_t v29;
  _QWORD v30[3];
  int v31;
  uint64_t v32;
  _QWORD v33[3];
  int v34;
  uint64_t v35;
  _QWORD v36[4];
  int v37;
  const char *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  unint64_t v42;
  __int16 v43;
  unint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;

  v4 = a2;
  v50 = *MEMORY[0x24BDAC8D0];
  re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(a1 + 32, a2);
  v6 = re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 128, v4);
  if (v6)
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(v6 + 32) + 16))(*(_QWORD *)(v6 + 32));
    re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t (***)(_QWORD))(a1 + 128), v4);
  }
  v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8));
  v8 = re::ServiceLocator::serviceOrNull<re::EventBus>(v7);
  if (v8)
  {
    v22 = (re::EventBus *)v8;
    v23[0] = 0;
    v26 = 0;
    v23[1] = 0;
    v24 = 0;
    v25 = 0;
    re::DynamicArray<re::SharedPtr<re::Shareable<re::AssetLoadDescriptor>>>::resize((uint64_t)v23, *(_QWORD *)(a3 + 16));
    v10 = *(_QWORD *)(a3 + 16);
    if (v10)
    {
      v11 = 0;
      v12 = 0;
      v13 = *(uint64_t **)(a3 + 32);
      v14 = 144 * v10;
      while (1)
      {
        re::DynamicString::DynamicString((re::DynamicString *)&buf, (const re::DynamicString *)v13);
        re::DynamicArray<BOOL>::DynamicArray((uint64_t)v30, v13 + 4);
        re::DynamicArray<BOOL>::DynamicArray((uint64_t)v33, v13 + 9);
        v15 = re::DynamicString::DynamicString((re::DynamicString *)v36, (const re::DynamicString *)(v13 + 14));
        v16 = re::globalAllocators(v15);
        v17 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v16[2] + 32))(v16[2], 168, 8);
        re::Shareable<re::AssetLoadDescriptor>::Shareable<re::AssetLoadDescriptor&>(v17, (uint64_t *)&buf);
        v18 = v24;
        if (v24 <= v12)
          break;
        re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)(v26 + v11), (uint64_t)v17);
        if (v17)

        if (v36[0])
        {
          if ((v36[1] & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v36[0] + 40))();
          memset(v36, 0, sizeof(v36));
        }
        if (v33[0])
        {
          if (v35)
            (*(void (**)(void))(*(_QWORD *)v33[0] + 40))();
          v35 = 0;
          memset(v33, 0, sizeof(v33));
          ++v34;
        }
        if (v30[0])
        {
          if (v32)
            (*(void (**)(void))(*(_QWORD *)v30[0] + 40))();
          v32 = 0;
          memset(v30, 0, sizeof(v30));
          ++v31;
        }
        v9 = (re *)buf;
        if ((_QWORD)buf && (BYTE8(buf) & 1) != 0)
          v9 = (re *)(*(uint64_t (**)(void))(*(_QWORD *)buf + 40))();
        v13 += 18;
        v11 += 8;
        ++v12;
        v14 -= 144;
        if (!v14)
          goto LABEL_25;
      }
      v27 = 0;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v45 = 0u;
      v4 = MEMORY[0x24BDACB70];
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v37 = 136315906;
      v38 = "operator[]";
      v39 = 1024;
      v40 = 789;
      v41 = 2048;
      v42 = v12;
      v43 = 2048;
      v44 = v18;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    else
    {
LABEL_25:
      if (re::assetsHighFrequencyLoggingEnabled(void)::onceToken == -1)
        goto LABEL_26;
    }
    dispatch_once(&re::assetsHighFrequencyLoggingEnabled(void)::onceToken, &__block_literal_global_1);
LABEL_26:
    if (re::assetsHighFrequencyLoggingEnabled(void)::shouldLog)
    {
      v19 = *re::assetsLogObjects(v9);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(_QWORD *)((char *)&buf + 4) = v4;
        _os_log_impl(&dword_224FE9000, v19, OS_LOG_TYPE_DEFAULT, "AssetId %llu removed over network", (uint8_t *)&buf, 0xCu);
      }
    }
    *(_QWORD *)&buf = v4;
    *((_QWORD *)&buf + 1) = v26;
    v29 = v24;
    Type = re::EventBus::getTypeId<RENetworkAssetRemovedEvent>();
    re::EventBus::publish(v22, 0, Type, (uint64_t)&buf, 0x18uLL, 0);
    re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)v23);
  }
  return 1;
}

uint64_t re::NetworkAssetManager::onAddedCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<re::Function<void ()(void)>&>(a1 + 80, &v4, a3);
}

uint64_t re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<re::Function<void ()(void)>&>(uint64_t result, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;

  v5 = result;
  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (*(_QWORD *)result)
  {
    v9 = v8 % *(unsigned int *)(result + 24);
    v10 = *(unsigned int *)(*(_QWORD *)(result + 8) + 4 * v9);
    if ((_DWORD)v10 != 0x7FFFFFFF)
    {
      v11 = *(_QWORD *)(result + 16);
      if (*(_QWORD *)(v11 + (v10 << 6) + 16) == v6)
        return result;
      while (1)
      {
        v10 = *(_DWORD *)(v11 + (v10 << 6) + 8) & 0x7FFFFFFF;
        if ((_DWORD)v10 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v11 + (v10 << 6) + 16) == v6)
          return result;
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  v12 = *(unsigned int *)(result + 36);
  if ((_DWORD)v12 == 0x7FFFFFFF)
  {
    v12 = *(unsigned int *)(result + 32);
    v13 = v12;
    if ((_DWORD)v12 == *(_DWORD *)(result + 24))
    {
      re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(result, 2 * *(_DWORD *)(result + 28));
      LODWORD(v9) = v8 % *(unsigned int *)(v5 + 24);
      v13 = *(_DWORD *)(v5 + 32);
      v6 = *a2;
    }
    *(_DWORD *)(v5 + 32) = v13 + 1;
    v14 = *(_QWORD *)(v5 + 16);
    v15 = *(_DWORD *)(v14 + (v12 << 6) + 8);
  }
  else
  {
    v14 = *(_QWORD *)(result + 16);
    v15 = *(_DWORD *)(v14 + (v12 << 6) + 8);
    *(_DWORD *)(result + 36) = v15 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v14 + (v12 << 6) + 8) = v15 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(v5 + 16) + (v12 << 6) + 8) = *(_DWORD *)(*(_QWORD *)(v5 + 16) + (v12 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(v5 + 8) + 4 * v9);
  *(_QWORD *)(*(_QWORD *)(v5 + 16) + (v12 << 6)) = v8;
  *(_QWORD *)(*(_QWORD *)(v5 + 16) + (v12 << 6) + 16) = v6;
  v16 = *(_QWORD *)(v5 + 16) + (v12 << 6);
  *(_QWORD *)(v16 + 48) = *(_QWORD *)(a3 + 24);
  *(_QWORD *)(v16 + 56) = 0;
  result = re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>(v16 + 24, a3);
  *(_DWORD *)(*(_QWORD *)(v5 + 8) + 4 * v9) = v12;
  ++*(_DWORD *)(v5 + 28);
  ++*(_DWORD *)(v5 + 40);
  return result;
}

uint64_t re::NetworkAssetManager::onRemovedCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<re::Function<void ()(void)>&>(a1 + 128, &v4, a3);
}

uint64_t re::ServiceLocator::serviceOrNull<re::AssetService>(uint64_t a1)
{
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE v6[16];

  if ((v2 & 1) == 0
  {
    re::introspect<re::AssetService>(void)::info = re::introspect_AssetService(0);
  }
  v3 = re::introspect<re::AssetService>(void)::info;
  re::StringID::invalid((re::StringID *)v6);
  v4 = (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *))(*(_QWORD *)a1 + 16))(a1, v3, v6);
  re::StringID::destroyString((re::StringID *)v6);
  return v4;
}

void re::NetworkAssetManager::hackSetAssetRootEntity(re::NetworkAssetManager *this, re::ecs2::Entity *a2)
{
  NSObject *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7[2];

  if (*(_QWORD *)(*((_QWORD *)this + 3) + 328))
  {
    v4 = *re::assetsLogObjects(this);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEFAULT, "hackSetAssetRootEntity called when a m_localAssetRootEntity already exists. This may result in previously loaded assets not syncing over the network. Please call hackSetAssetRootEntity before any assets are loaded.", (uint8_t *)v7, 2u);
    }
  }
  if (a2)
  {
    if (!*((_QWORD *)a2 + 25))
      re::ecs2::EntityComponentCollection::add((re::ecs2::Entity *)((char *)a2 + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::NetworkComponent,(re::ecs2::ComponentTypeBase::Flags)4>::s_componentType);
    re::StringID::StringID((re::StringID *)v7, (const StringID *)((char *)this + 200));
    re::StringID::operator=((unint64_t *)a2 + 34, v7);
    re::StringID::destroyString((re::StringID *)v7);
    v5 = (char *)a2 + 8;
  }
  v6 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = a2;
  if (v6)

}

void re::NetworkAssetManager::getAssetState(re::NetworkAssetManager *this@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  id *v7;
  char *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  id v13;
  uint64_t v14;
  int v15;

  v7 = (id *)re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 32, a3);
  if (v7
    && (v8 = re::ecs2::EntityHandle::resolve(v7, *((_QWORD *)this + 1))) != 0
    && (v9 = *((_QWORD *)v8 + 41)) != 0)
  {
    v10 = (uint64_t *)*((_QWORD *)v8 + 43);
    v11 = 8 * v9;
    while (1)
    {
      v12 = *v10;
      if (*v10)
        v13 = (id)(v12 + 8);
      v14 = re::ecs2::EntityComponentCollection::get((re::ecs2::EntityComponentCollection *)(v12 + 32), (const re::ecs2::ComponentTypeBase *)re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType);
      if (v14)
      {
        if (*(_QWORD *)(v14 + 40) == a2)
          break;
      }
      if (v12)

      ++v10;
      v11 -= 8;
      if (!v11)
        goto LABEL_12;
    }
    v15 = *(unsigned __int8 *)(v14 + 48);
    *(_BYTE *)a4 = 1;
    *(_DWORD *)(a4 + 4) = v15;
    if (v12)

  }
  else
  {
LABEL_12:
    *(_BYTE *)a4 = 0;
  }
}

uint64_t re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::AssetLoadDescriptor>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::AssetLoadDescriptor>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

uint64_t re::DynamicArray<re::AssetLoadDescriptor>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  char v22;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= a1[2])
  {
    re::DynamicArray<re::AssetLoadDescriptor>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::AssetLoadDescriptor *,re::AssetLoadDescriptor *,re::AssetLoadDescriptor *>((uint64_t)&v22, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 144 * a1[2], a1[4]);
    v16 = a1[2];
    if (v16 != v4)
    {
      v17 = *(_QWORD *)(a2 + 32);
      v18 = a1[4];
      v19 = 144 * v16;
      v20 = 144 * v4;
      do
      {
        re::DynamicString::DynamicString((re::DynamicString *)(v18 + v19), (const re::DynamicString *)(v17 + v19));
        re::DynamicArray<BOOL>::DynamicArray(v18 + v19 + 32, (uint64_t *)(v17 + v19 + 32));
        re::DynamicArray<BOOL>::DynamicArray(v18 + v19 + 72, (uint64_t *)(v17 + v19 + 72));
        result = (uint64_t)re::DynamicString::DynamicString((re::DynamicString *)(v18 + v19 + 112), (const re::DynamicString *)(v17 + v19 + 112));
        v17 += 144;
        v20 -= 144;
        v18 += 144;
      }
      while (v19 != v20);
    }
  }
  else
  {
    result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::AssetLoadDescriptor *,re::AssetLoadDescriptor *,re::AssetLoadDescriptor *>((uint64_t)&v21, *(_QWORD *)(a2 + 32), *(_QWORD *)(a2 + 32) + 144 * v4, a1[4]);
    v6 = a1[2];
    if (v4 != v6)
    {
      v7 = a1[4];
      v8 = 144 * v4;
      v9 = 144 * v6;
      do
      {
        v10 = v7 + v8;
        v11 = *(_QWORD *)(v7 + v8 + 112);
        if (v11)
        {
          if ((*(_BYTE *)(v10 + 120) & 1) != 0)
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 40))(v11, *(_QWORD *)(v7 + v8 + 128));
          *(_OWORD *)(v7 + v8 + 112) = 0u;
          *(_OWORD *)(v7 + v8 + 128) = 0u;
        }
        v12 = *(_QWORD *)(v10 + 72);
        if (v12)
        {
          v13 = v7 + v8;
          if (*(_QWORD *)(v7 + v8 + 104))
            (*(void (**)(uint64_t))(*(_QWORD *)v12 + 40))(v12);
          *(_QWORD *)(v13 + 104) = 0;
          *(_QWORD *)(v10 + 80) = 0;
          *(_QWORD *)(v10 + 88) = 0;
          *(_QWORD *)(v10 + 72) = 0;
          ++*(_DWORD *)(v13 + 96);
        }
        v14 = v7 + v8;
        v15 = *(_QWORD *)(v7 + v8 + 32);
        if (v15)
        {
          if (*(_QWORD *)(v14 + 64))
            (*(void (**)(uint64_t))(*(_QWORD *)v15 + 40))(v15);
          *(_QWORD *)(v14 + 64) = 0;
          *(_QWORD *)(v7 + v8 + 40) = 0;
          *(_QWORD *)(v7 + v8 + 48) = 0;
          *(_QWORD *)(v7 + v8 + 32) = 0;
          ++*(_DWORD *)(v7 + v8 + 56);
        }
        result = *(_QWORD *)v10;
        if (*(_QWORD *)v10)
        {
          if ((*(_BYTE *)(v7 + v8 + 8) & 1) != 0)
            result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 40))(result, *(_QWORD *)(v7 + v8 + 16));
          *(_OWORD *)v10 = 0u;
          *(_OWORD *)(v10 + 16) = 0u;
        }
        v7 += 144;
        v9 -= 144;
      }
      while (v8 != v9);
    }
  }
  a1[2] = v4;
  return result;
}

_QWORD *re::DynamicArray<re::AssetLoadDescriptor>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::AssetLoadDescriptor>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x90uLL))
        {
          v2 = 144 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 144 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 144, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (_QWORD *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 144 * v9;
        v11 = (uint64_t)v7;
        do
        {
          re::ObjectHelper::move<re::AssetLoadDescriptor>(v8, v11);
          v8 += 18;
          v11 += 144;
          v10 -= 144;
        }
        while (v10);
        v8 = (_QWORD *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

double re::ObjectHelper::move<re::AssetLoadDescriptor>(_QWORD *a1, uint64_t a2)
{
  double result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  result = 0.0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)(a2 + 24) = a1[3];
  v4 = a1[1];
  *(_QWORD *)a2 = *a1;
  *a1 = 0;
  v5 = a1[2];
  a1[3] = 0;
  v7 = *(_QWORD *)(a2 + 8);
  v6 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = v4;
  *(_QWORD *)(a2 + 16) = v5;
  a1[1] = v7;
  a1[2] = v6;
  *(_QWORD *)(a2 + 64) = 0;
  *(_DWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  v8 = a1 + 4;
  v9 = a1[5];
  *(_QWORD *)(a2 + 32) = a1[4];
  a1[4] = 0;
  *(_QWORD *)(a2 + 40) = v9;
  a1[5] = 0;
  v10 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = a1[6];
  a1[6] = v10;
  v11 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = a1[8];
  a1[8] = v11;
  ++*((_DWORD *)a1 + 14);
  ++*(_DWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 104) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 72) = 0;
  *(_DWORD *)(a2 + 96) = 0;
  v12 = a1 + 9;
  v13 = a1[10];
  *(_QWORD *)(a2 + 72) = a1[9];
  a1[9] = 0;
  *(_QWORD *)(a2 + 80) = v13;
  a1[10] = 0;
  v14 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a2 + 88) = a1[11];
  a1[11] = v14;
  v15 = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = a1[13];
  a1[13] = v15;
  ++*((_DWORD *)a1 + 24);
  ++*(_DWORD *)(a2 + 96);
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 128) = 0u;
  v16 = a1 + 14;
  *(_QWORD *)(a2 + 112) = a1[14];
  a1[14] = 0;
  v17 = a1[16];
  *(_QWORD *)(a2 + 136) = a1[17];
  a1[17] = 0;
  v18 = *(_QWORD *)(a2 + 120);
  v19 = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a2 + 128) = v17;
  v20 = a1[14];
  *(_QWORD *)(a2 + 120) = v16[1];
  v16[1] = v18;
  v16[2] = v19;
  if (v20)
  {
    if ((v18 & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v20 + 40))(v20, a1[16]);
    result = 0.0;
    *(_OWORD *)v16 = 0u;
    *((_OWORD *)v16 + 1) = 0u;
  }
  if (*v12)
  {
    if (a1[13])
      (*(void (**)(_QWORD))(*(_QWORD *)*v12 + 40))(*v12);
    a1[13] = 0;
    v12[1] = 0;
    v12[2] = 0;
    *v12 = 0;
    ++*((_DWORD *)a1 + 24);
  }
  if (*v8)
  {
    if (a1[8])
      (*(void (**)(_QWORD))(*(_QWORD *)*v8 + 40))(*v8);
    a1[8] = 0;
    v8[1] = 0;
    v8[2] = 0;
    *v8 = 0;
    ++*((_DWORD *)a1 + 14);
  }
  if (*a1)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::AssetLoadDescriptor *,re::AssetLoadDescriptor *,re::AssetLoadDescriptor *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;

  if (a2 == a3)
    return a2;
  v6 = a3;
  v7 = 0;
  do
  {
    re::DynamicString::operator=((re::DynamicString *)(a4 + v7), (re::DynamicString *)(a2 + v7));
    re::DynamicArray<BOOL>::operator=(a4 + v7 + 32, (uint64_t *)(a2 + v7 + 32));
    re::DynamicArray<BOOL>::operator=(a4 + v7 + 72, (uint64_t *)(a2 + v7 + 72));
    re::DynamicString::operator=((re::DynamicString *)(a4 + v7 + 112), (re::DynamicString *)(a2 + v7 + 112));
    v7 += 144;
  }
  while (a2 + v7 != v6);
  return v6;
}

double re::Event<re::NetworkSystem,re::ecs2::Component *>::addSubscription(_DWORD *a1, uint64_t a2)
{
  double result;
  __int128 v5;
  char v6[8];
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  re::DynamicArray<re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription>::indexOf((uint64_t)a1, (_QWORD *)a2, (uint64_t)v6);
  if (!v6[0])
  {
    if (a1[20])
    {
      v6[0] = 1;
      v5 = *(_OWORD *)(a2 + 16);
      v7 = *(_OWORD *)a2;
      v8 = v5;
      *(_QWORD *)&result = re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription,true>>::add((_anonymous_namespace_ *)(a1 + 10), (uint64_t)v6).n128_u64[0];
    }
    else
    {
      *(_QWORD *)&result = re::DynamicArray<re::EvaluationRegister>::add((_anonymous_namespace_ *)a1, a2).n128_u64[0];
    }
  }
  return result;
}

__n128 re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription,true>>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription,true>>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 40 * v4;
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(v5 + 32) = *(_QWORD *)(a2 + 32);
  *(__n128 *)v5 = result;
  *(_OWORD *)(v5 + 16) = v7;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

_QWORD *re::DynamicArray<re::Pair<BOOL,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription,true>>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Pair<BOOL,re::Event<re::SimulationTimer,re::SimulationTimerEventArgs const&>::Subscription,true>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::Event<re::NetworkSystem,re::ecs2::Component *>::createSubscription<re::NetworkAssetManager>(re::NetworkAssetManager *,REEventHandlerResult (re::NetworkAssetManager::*)(re::NetworkSystem*,re::ecs2::Component *))::{lambda(re::NetworkSystem*,re::Event<re::NetworkSystem,re::ecs2::Component *>::Subscription const&,re::ecs2::Component *&&)#1}::__invoke(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t (*v4)(_QWORD *, uint64_t, _QWORD);
  uint64_t v5;
  _QWORD *v6;

  v4 = (uint64_t (*)(_QWORD *, uint64_t, _QWORD))a2[1];
  v5 = a2[2];
  v6 = (_QWORD *)(*a2 + (v5 >> 1));
  if ((v5 & 1) != 0)
    v4 = *(uint64_t (**)(_QWORD *, uint64_t, _QWORD))(*v6 + v4);
  return v4(v6, a1, *a3);
}

void re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::removeAt(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  v4 = v2 - 1;
  if (v2 - 1 > a2)
  {
    v5 = *(_QWORD *)(a1 + 32);
    v6 = v5 + 8 * v2;
    v7 = *(_QWORD *)(v5 + 8 * a2);
    *(_QWORD *)(v5 + 8 * a2) = *(_QWORD *)(v6 - 8);
    *(_QWORD *)(v6 - 8) = v7;
  }
  v8 = *(_QWORD *)(a1 + 32) + 8 * v2;
  v9 = *(_QWORD *)(v8 - 8);
  if (v9)
  {

    *(_QWORD *)(v8 - 8) = 0;
    v4 = *(_QWORD *)(a1 + 16) - 1;
  }
  *(_QWORD *)(a1 + 16) = v4;
  ++*(_DWORD *)(a1 + 24);
}

_QWORD *re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::add(_QWORD *this, uint64_t *a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  v5 = *a2;
  *(_QWORD *)(v3[4] + 8 * v4) = *a2;
  if (v5)
  {
    this = (id)(v5 + 8);
    v4 = v3[2];
  }
  v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return this;
}

_QWORD *re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_15;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_15:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 8 * v9;
        v11 = v7;
        v12 = (_QWORD *)v5[4];
        do
        {
          *v11++ = *v12;
          *v12++ = 0;
          v10 -= 8;
        }
        while (v10);
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_15;
    }
  }
  return result;
}

void re::make::shared::object<re::ecs2::Scene,re::ConstStringID>(re *a1@<X0>, re::ecs2::Scene **a2@<X8>)
{
  uint64_t *v4;
  re::ecs2::Scene *v5;
  char *v6;
  StringID v7;

  v4 = re::globalAllocators(a1);
  v5 = (re::ecs2::Scene *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4[2] + 32))(v4[2], 384, 8);
  v6 = (char *)*((_QWORD *)a1 + 1);
  *(_QWORD *)&v7.var0 = 2 * *(_QWORD *)a1;
  v7.var1 = v6;
  *a2 = re::ecs2::Scene::Scene(v5, &v7);
  re::StringID::destroyString((re::StringID *)&v7);
}

double re::make::shared::inplace<re::ecs2::NetworkAssetComponent>@<D0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  _QWORD *v5;
  double result;

  *(_QWORD *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)(v4 + 16) = 0;
  *(_BYTE *)(v4 + 24) = 0;
  *(_QWORD *)v4 = off_24ED2BBB0;
  *(_OWORD *)(v4 + 56) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  v5 = (_QWORD *)(v4 + 40);
  re::DynamicString::setCapacity(v5, 0);
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 132) = 0u;
  *(_QWORD *)&result = 0x7FFFFFFFLL;
  *(_QWORD *)(a1 + 148) = 0x7FFFFFFFLL;
  *(_BYTE *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_DWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 204) = 0x7FFFFFFFLL;
  *a2 = a1;
  return result;
}

void re::ecs2::NetworkAssetComponent::~NetworkAssetComponent(re::ecs2::NetworkAssetComponent *this)
{
  char *v2;
  double v3;
  uint64_t v4;

  *(_QWORD *)this = off_24ED2BBB0;
  v2 = (char *)this + 72;
  v3 = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 21);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 14, v3);
  re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)v2);
  v4 = *((_QWORD *)this + 5);
  if (v4)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 7));
    *(_OWORD *)((char *)this + 40) = 0u;
    *(_OWORD *)((char *)this + 56) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  char *v2;
  double v3;
  uint64_t v4;

  *(_QWORD *)this = off_24ED2BBB0;
  v2 = (char *)this + 72;
  v3 = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 21);
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 14, v3);
  re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)v2);
  v4 = *((_QWORD *)this + 5);
  if (v4)
  {
    if ((*((_BYTE *)this + 48) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 7));
    *(_OWORD *)((char *)this + 40) = 0u;
    *(_OWORD *)((char *)this + 56) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::allocator()
{
  return *((_QWORD *)re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::NetworkAssetComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
}

double re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::EntryWithoutHash::free(a1[2] + v3);
        ++v4;
        v3 += 56;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::EntryWithoutHash::free(uint64_t a1)
{
  double result;
  uint64_t v3;

  if ((*(_DWORD *)a1 & 0x80000000) != 0)
  {
    *(_DWORD *)a1 &= ~0x80000000;
    re::StringID::destroyString((re::StringID *)(a1 + 8));
    v3 = *(_QWORD *)(a1 + 24);
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 32) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 40));
      result = 0.0;
      *(_OWORD *)(a1 + 24) = 0u;
      *(_OWORD *)(a1 + 40) = 0u;
    }
  }
  return result;
}

uint64_t re::DynamicArray<re::AssetLoadDescriptor>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = v3 + 64;
        v6 = 144 * v4;
        do
        {
          v7 = *(_QWORD *)(v5 + 48);
          if (v7)
          {
            if ((*(_BYTE *)(v5 + 56) & 1) != 0)
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, *(_QWORD *)(v5 + 64));
            *(_OWORD *)(v5 + 48) = 0u;
            *(_OWORD *)(v5 + 64) = 0u;
          }
          v8 = *(_QWORD *)(v5 + 8);
          if (v8)
          {
            if (*(_QWORD *)(v5 + 40))
              (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
            *(_QWORD *)(v5 + 40) = 0;
            *(_QWORD *)(v5 + 16) = 0;
            *(_QWORD *)(v5 + 24) = 0;
            *(_QWORD *)(v5 + 8) = 0;
            ++*(_DWORD *)(v5 + 32);
          }
          v9 = *(_QWORD *)(v5 - 32);
          if (v9)
          {
            if (*(_QWORD *)v5)
              (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
            *(_QWORD *)v5 = 0;
            *(_QWORD *)(v5 - 24) = 0;
            *(_QWORD *)(v5 - 16) = 0;
            *(_QWORD *)(v5 - 32) = 0;
            ++*(_DWORD *)(v5 - 8);
          }
          v10 = *(_QWORD *)(v5 - 64);
          if (v10)
          {
            if ((*(_BYTE *)(v5 - 56) & 1) != 0)
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 40))(v10, *(_QWORD *)(v5 - 48));
            *(_OWORD *)(v5 - 64) = 0u;
            *(_OWORD *)(v5 - 48) = 0u;
          }
          v5 += 144;
          v6 -= 144;
        }
        while (v6);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::ecs2::AssetPreloadComponent::~AssetPreloadComponent(re::ecs2::AssetPreloadComponent *this)
{
  *(_QWORD *)this = &off_24ED2BC30;
  re::AssetHandle::~AssetHandle((re::ecs2::AssetPreloadComponent *)((char *)this + 32));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED2BC30;
  re::AssetHandle::~AssetHandle((re::ecs2::AssetPreloadComponent *)((char *)this + 32));
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::allocator()
{
  return *((_QWORD *)re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::AssetPreloadComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
}

void re::ecs2::AssetStateComponent::~AssetStateComponent(re::ecs2::AssetStateComponent *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::allocator()
{
  return *((_QWORD *)re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType
         + 7);
}

uint64_t re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::commonComponentIndex()
{
  return -1;
}

void *re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::componentType()
{
  return re::ecs2::ComponentImpl<re::ecs2::AssetStateComponent,(re::ecs2::ComponentTypeBase::Flags)2>::s_componentType;
}

void re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;

  re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, *(_QWORD *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)v8, (re::DynamicString *)(v8 + 16), (_QWORD *)(v8 + 48));
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 56;
    }
  }
}

void re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  __n128 v6;
  uint64_t v7;
  __n128 *v8;
  int v9;
  uint64_t v10;
  __n128 *v11;
  uint64_t v12;
  int v13;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &unk_2260EB7B0, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 0;
      v6 = 0uLL;
      do
      {
        v7 = *(_QWORD *)(a1 + 16);
        v8 = (__n128 *)(v7 + v4);
        v9 = *(_DWORD *)(v7 + v4 + 8);
        if (v9 < 0)
        {
          v8->n128_u32[2] = v9 & 0x7FFFFFFF;
          v12 = v8[1].n128_i64[0];
          v11 = v8 + 1;
          v10 = v12;
          if (v12)
          {
            if ((*(_BYTE *)(v7 + v4 + 24) & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v10 + 40))(v10, *(_QWORD *)(v7 + v4 + 32), v6);
              v6 = 0uLL;
            }
            *v11 = v6;
            v11[1] = v6;
            v3 = *(unsigned int *)(a1 + 32);
          }
        }
        ++v5;
        v4 += 56;
      }
      while (v5 < v3);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v13 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v13;
  }
}

void re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_OWORD *)&v13[24];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = DWORD2(v7);
      if (DWORD2(v7))
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (re::DynamicString *)(*(_QWORD *)&v13[16] + v10 + 16));
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 56;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13, *(double *)&v7);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, _QWORD *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 56 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 56 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 56 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v10) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 56 * v10 + 16), a4);
  v14 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v10 + 48) = *a5;
  *(_DWORD *)(v14 + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<re::DynamicString&>(uint64_t a1, unsigned int a2, unint64_t a3, StringID *a4, const re::DynamicString *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 56 * v9);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 56 * v9);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  v14 = 56 * v9;
  *(_DWORD *)(v12 + v14) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v9) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  re::StringID::StringID((re::StringID *)(*(_QWORD *)(a1 + 16) + 56 * v9 + 8), a4);
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 56 * v9 + 24), a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  signed int v14;
  _BYTE v15[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v15, 0, 36);
      *(_QWORD *)&v15[36] = 0x7FFFFFFFLL;
      re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init((uint64_t)v15, v4, a2);
      v5 = *(_OWORD *)v15;
      *(_OWORD *)v15 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v15[16];
      *(_QWORD *)&v15[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v15[24];
      *(_OWORD *)&v15[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v15[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v15[16] + v10) & 0x80000000) != 0)
          {
            v12 = 0xBF58476D1CE4E5B9
                * ((*(_QWORD *)(*(_QWORD *)&v15[16] + v10 + 8) >> 31) ^ (*(_QWORD *)(*(_QWORD *)&v15[16] + v10 + 8) >> 1));
            v13 = (0x94D049BB133111EBLL * (v12 ^ (v12 >> 27))) ^ ((0x94D049BB133111EBLL * (v12 ^ (v12 >> 27))) >> 31);
            re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsMove(a1, v13 % *(unsigned int *)(a1 + 24), v13, (StringID *)(*(_QWORD *)&v15[16] + v10 + 8));
            v9 = *(_DWORD *)&v15[32];
          }
          ++v11;
          v10 += 56;
        }
        while (v11 < v9);
      }
      re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)v15);
    }
  }
  else
  {
    if (a2)
      v14 = a2;
    else
      v14 = 3;
  }
}

uint64_t re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, StringID *a4, _QWORD *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 56 * v9);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 56 * v9);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  v14 = 56 * v9;
  *(_DWORD *)(v12 + v14) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v9) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  re::StringID::StringID((re::StringID *)(*(_QWORD *)(a1 + 16) + 56 * v9 + 8), a4);
  v15 = *(_QWORD *)(a1 + 16) + 56 * v9;
  *(_OWORD *)(v15 + 40) = 0u;
  *(_OWORD *)(v15 + 24) = 0u;
  *(_QWORD *)(v15 + 48) = a5[3];
  v16 = a5[1];
  *(_QWORD *)(v15 + 24) = *a5;
  *a5 = 0;
  v17 = a5[2];
  a5[3] = 0;
  v19 = *(_QWORD *)(v15 + 32);
  v18 = *(_QWORD *)(v15 + 40);
  *(_QWORD *)(v15 + 32) = v16;
  *(_QWORD *)(v15 + 40) = v17;
  a5[1] = v19;
  a5[2] = v18;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;

  re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16);
      if ((*(_DWORD *)(v8 + v6) & 0x80000000) != 0)
      {
        v9 = 0xBF58476D1CE4E5B9 * ((*(_QWORD *)(v8 + v6 + 8) >> 31) ^ (*(_QWORD *)(v8 + v6 + 8) >> 1));
        v10 = (0x94D049BB133111EBLL * (v9 ^ (v9 >> 27))) ^ ((0x94D049BB133111EBLL * (v9 ^ (v9 >> 27))) >> 31);
        re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addEmplace<re::DynamicString&>(a1, v10 % *(unsigned int *)(a1 + 24), v10, (StringID *)(v8 + v6 + 8), (const re::DynamicString *)(v8 + v6 + 24));
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 56;
    }
  }
}

uint64_t re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  int v12;
  signed int v13;
  uint64_t v14;
  BOOL v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  __int128 v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  signed int v26;
  uint64_t result;
  _BYTE v28[44];

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      v12 = *(_DWORD *)(a1 + 28);
      v13 = 2 * v12;
      v14 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v13)
          v15 = (_DWORD)v10 == v13;
        else
          v15 = 1;
        if (!v15 && (v12 & 0x80000000) == 0)
        {
          memset(v28, 0, 36);
          *(_QWORD *)&v28[36] = 0x7FFFFFFFLL;
          re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v28, v14, v13);
          v16 = *(_OWORD *)v28;
          *(_OWORD *)v28 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v16;
          v17 = *(_QWORD *)&v28[16];
          v18 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v28[16] = v18;
          *(_QWORD *)(a1 + 16) = v17;
          v20 = *(_OWORD *)&v28[24];
          *(_OWORD *)&v28[24] = *(_OWORD *)(a1 + 24);
          v19 = *(_DWORD *)&v28[32];
          *(_OWORD *)(a1 + 24) = v20;
          v21 = v19;
          if (v19)
          {
            v22 = 0;
            v23 = v18 + 16;
            do
            {
              if ((*(_DWORD *)(v23 - 8) & 0x80000000) != 0)
                re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(_QWORD *)(v23 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v23 - 16), v23, v23 + 8);
              ++v22;
              v23 += 48;
            }
            while (v22 < v21);
          }
          re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v28);
        }
      }
      else
      {
        if (v13)
          v26 = 2 * v12;
        else
          v26 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v24 = *(_QWORD *)(a1 + 16);
    v25 = *(_DWORD *)(v24 + 48 * v10 + 8);
  }
  else
  {
    v24 = *(_QWORD *)(a1 + 16);
    v25 = *(_DWORD *)(v24 + 48 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v25 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v24 + 48 * v10 + 8) = v25 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 48 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 48 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * v10) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * v10 + 16) = *a4;
  result = re::ecs2::EntityHandle::EntityHandle(*(_QWORD *)(a1 + 16) + 48 * v10 + 24, a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

void re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 48 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_2260EB7B0, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

_QWORD *re::Shareable<re::AssetLoadDescriptor>::Shareable<re::AssetLoadDescriptor&>(_QWORD *a1, uint64_t *a2)
{
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *a1 = off_24ED2BB68;
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 3), (const re::DynamicString *)a2);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)(a1 + 7), a2 + 4);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)(a1 + 12), a2 + 9);
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 17), (const re::DynamicString *)(a2 + 14));
  return a1;
}

uint64_t re::Shareable<re::AssetLoadDescriptor>::~Shareable(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)a1 = off_24ED2BB68;
  v3 = (_OWORD *)(a1 + 136);
  v2 = *(_QWORD *)(a1 + 136);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 144) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 152));
    *v3 = 0u;
    v3[1] = 0u;
  }
  v4 = *(_QWORD *)(a1 + 96);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 128))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 96) = 0;
    ++*(_DWORD *)(a1 + 120);
  }
  v5 = *(_QWORD *)(a1 + 56);
  if (v5)
  {
    if (*(_QWORD *)(a1 + 88))
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
    *(_QWORD *)(a1 + 88) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 72) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    ++*(_DWORD *)(a1 + 80);
  }
  v6 = *(_QWORD *)(a1 + 24);
  if (v6)
  {
    if ((*(_BYTE *)(a1 + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *(_QWORD *)(a1 + 40));
    *(_OWORD *)(a1 + 24) = 0u;
    *(_OWORD *)(a1 + 40) = 0u;
  }
  *(_QWORD *)a1 = &off_24ED426B8;
  objc_destructInstance((id)(a1 + 8));
  return a1;
}

void re::Shareable<re::AssetLoadDescriptor>::~Shareable(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)a1 = off_24ED2BB68;
  v3 = (_OWORD *)(a1 + 136);
  v2 = *(_QWORD *)(a1 + 136);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 144) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 152));
    *v3 = 0u;
    v3[1] = 0u;
  }
  v4 = *(_QWORD *)(a1 + 96);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 128))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 96) = 0;
    ++*(_DWORD *)(a1 + 120);
  }
  v5 = *(_QWORD *)(a1 + 56);
  if (v5)
  {
    if (*(_QWORD *)(a1 + 88))
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
    *(_QWORD *)(a1 + 88) = 0;
    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 72) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    ++*(_DWORD *)(a1 + 80);
  }
  v6 = *(_QWORD *)(a1 + 24);
  if (v6)
  {
    if ((*(_BYTE *)(a1 + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *(_QWORD *)(a1 + 40));
    *(_OWORD *)(a1 + 24) = 0u;
    *(_OWORD *)(a1 + 40) = 0u;
  }
  *(_QWORD *)a1 = &off_24ED426B8;
  objc_destructInstance((id)(a1 + 8));
  JUMPOUT(0x2276933B8);
}

__guard re::EventBus::getTypeId<RENetworkAssetAddedEvent>()
{
  unsigned __int8 v0;
  __guard *v1;
  int v3;
  const char *v4;

  if ((v0 & 1) == 0)
  {
    if (v3)
    {
      re::EventBus::getTypeId<RENetworkAssetAddedEvent>(void)const::s_id = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"24RENetworkAssetAddedEvent" & 0x7FFFFFFFFFFFFFFFLL), v4);
    }
  }
  return v1[14];
}

__guard re::EventBus::getTypeId<RENetworkAssetRemovedEvent>()
{
  unsigned __int8 v0;
  __guard *v1;
  int v3;
  const char *v4;

  if ((v0 & 1) == 0)
  {
    if (v3)
    {
      re::EventBus::getTypeId<RENetworkAssetRemovedEvent>(void)const::s_id = re::EventBus::typeStringToId((re::EventBus *)((unint64_t)"26RENetworkAssetRemovedEvent" & 0x7FFFFFFFFFFFFFFFLL), v4);
    }
  }
  return v1[16];
}

void re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  signed int v23;
  _BYTE v24[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v24, 0, 36);
      *(_QWORD *)&v24[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v24, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v24;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v24[8];
      *(_OWORD *)v24 = v5;
      *(_QWORD *)&v24[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v24[24];
      *(_OWORD *)&v24[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v24[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = DWORD1(v9);
        v13 = v7;
        v14 = v6 + 24;
        do
        {
          if ((*(_DWORD *)(v14 - 16) & 0x80000000) != 0)
          {
            v15 = *(_QWORD *)(v14 - 24);
            v16 = *(unsigned int *)(a1 + 24);
            v17 = v15 % v16;
            v18 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v18 == 0x7FFFFFFF)
            {
              v18 = *(unsigned int *)(a1 + 32);
              v19 = v18;
              if ((_DWORD)v18 == (_DWORD)v16)
              {
                re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, (2 * v12));
                v17 = v15 % *(unsigned int *)(a1 + 24);
                v19 = *(_DWORD *)(a1 + 32);
                v13 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + (v18 << 6) + 8);
            }
            else
            {
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + (v18 << 6) + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + (v18 << 6) + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v18 << 6) + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v18 << 6) + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * v17);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v18 << 6)) = v15;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v18 << 6) + 16) = *(_QWORD *)(v14 - 8);
            v22 = *(_QWORD *)(a1 + 16) + (v18 << 6);
            *(_QWORD *)(v22 + 48) = *(_QWORD *)(v14 + 24);
            *(_QWORD *)(v22 + 56) = 0;
            re::FunctionBase<24ul,void ()(void)>::operator=<24ul>(v22 + 24, v14);
            v13 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v13 + 4 * v17) = v18;
            v12 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v12;
          }
          ++v11;
          v14 += 64;
        }
        while (v11 < v10);
      }
      re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v24);
    }
  }
  else
  {
    if (a2)
      v23 = a2;
    else
      v23 = 3;
  }
}

void re::HashTable<unsigned long long,re::Function<void ()(void)>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + (v10 << 6), 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &unk_2260EB7B0, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::EntitlementManager::~EntitlementManager(re::EntitlementManager *this)
{
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 20);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 14);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 8);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 2);
}

{
  re::EntitlementManager::~EntitlementManager(this);
  JUMPOUT(0x2276933B8);
}

void re::EntitlementManager::init(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  _anonymous_namespace_ *v5;
  _anonymous_namespace_ *v6;
  _anonymous_namespace_ *v7;
  re *v8;
  NSObject *v9;
  uint8_t v10[16];

  v4 = a1 + 16;
  *(_QWORD *)(a1 + 208) = *a2;
  *(_BYTE *)(a1 + 8) = 1;
  v9 = *re::assetsLogObjects(v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v10 = 0;
    _os_log_impl(&dword_224FE9000, v9, OS_LOG_TYPE_DEFAULT, "EntitlementManager initialized", v10, 2u);
  }
}

void re::EntitlementManager::deinit(re::EntitlementManager *this)
{
  re *v2;
  NSObject *v3;
  uint8_t v4[16];

  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 8);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 2);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 14);
  re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 20);
  *((_QWORD *)this + 26) = 0;
  *((_BYTE *)this + 8) = 0;
  v3 = *re::assetsLogObjects(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_224FE9000, v3, OS_LOG_TYPE_DEFAULT, "EntitlementManager uninitialized", v4, 2u);
  }
}

void re::EntitlementManager::setAllowAnyShaderLibraryForPeer(re::EntitlementManager *this, uint64_t a2, int a3)
{
  char *v3;
  re *v4;
  NSObject *v5;
  const char *v6;
  re *v7;
  uint64_t v8;
  uint8_t buf[4];
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v8 = a2;
  if (a2)
  {
    v3 = (char *)this + 16;
    if (a3)
    {
      v4 = (re *)re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v3, &v8);
      v5 = *re::assetsLogObjects(v4);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 134217984;
      v10 = v8;
      v6 = "EntitlementManager - Peer (peerID=%llu) is trusted to execute any shader library";
    }
    else
    {
      v7 = (re *)re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)v3, &v8);
      v5 = *re::assetsLogObjects(v7);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 134217984;
      v10 = v8;
      v6 = "EntitlementManager - Peer (peerID=%llu) is NOT trusted to execute any shader library";
    }
    _os_log_impl(&dword_224FE9000, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 0xCu);
  }
}

void re::EntitlementManager::setAllowLimitedRenderAssetsForPeer(re::EntitlementManager *this, uint64_t a2, int a3)
{
  char *v3;
  re *v4;
  NSObject *v5;
  const char *v6;
  re *v7;
  uint64_t v8;
  uint8_t buf[4];
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v8 = a2;
  if (a2)
  {
    v3 = (char *)this + 64;
    if (a3)
    {
      v4 = (re *)re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v3, &v8);
      v5 = *re::assetsLogObjects(v4);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 134217984;
      v10 = v8;
      v6 = "EntitlementManager - Peer (peerID=%llu) is entitled to load limited render assets";
    }
    else
    {
      v7 = (re *)re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)v3, &v8);
      v5 = *re::assetsLogObjects(v7);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 134217984;
      v10 = v8;
      v6 = "EntitlementManager - Peer (peerID=%llu) is NOT entitled to load limited render assets";
    }
    _os_log_impl(&dword_224FE9000, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 0xCu);
  }
}

void re::EntitlementManager::setAllowRenderOnTopSPIForPeer(re::EntitlementManager *this, uint64_t a2, int a3)
{
  char *v3;
  re *v4;
  NSObject *v5;
  const char *v6;
  re *v7;
  uint64_t v8;
  uint8_t buf[4];
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v8 = a2;
  if (a2)
  {
    v3 = (char *)this + 112;
    if (a3)
    {
      v4 = (re *)re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v3, &v8);
      v5 = *re::assetsLogObjects(v4);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 134217984;
      v10 = v8;
      v6 = "EntitlementManager - Peer (peerID=%llu) is entitled to use render on top SPI";
    }
    else
    {
      v7 = (re *)re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)v3, &v8);
      v5 = *re::assetsLogObjects(v7);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 134217984;
      v10 = v8;
      v6 = "EntitlementManager - Peer (peerID=%llu) is NOT entitled to use render on top SPI";
    }
    _os_log_impl(&dword_224FE9000, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 0xCu);
  }
}

void re::EntitlementManager::setAllowCARESyncBackForPeer(re::EntitlementManager *this, uint64_t a2, int a3)
{
  char *v3;
  re *v4;
  NSObject *v5;
  const char *v6;
  re *v7;
  uint64_t v8;
  uint8_t buf[4];
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v8 = a2;
  if (a2)
  {
    v3 = (char *)this + 160;
    if (a3)
    {
      buf[0] = 1;
      v4 = (re *)re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add((uint64_t)v3, &v8, buf);
      v5 = *re::assetsLogObjects(v4);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 134217984;
      v10 = v8;
      v6 = "EntitlementManager - Peer (peerID=%llu) is entitled to be sent owned CARE component data";
    }
    else
    {
      buf[0] = 0;
      v7 = (re *)re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add((uint64_t)v3, &v8, buf);
      v5 = *re::assetsLogObjects(v7);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 134217984;
      v10 = v8;
      v6 = "EntitlementManager - Peer (peerID=%llu) is NOT entitled to be sent owned CARE component data";
    }
    _os_log_impl(&dword_224FE9000, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 0xCu);
  }
}

uint64_t re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add(uint64_t result, uint64_t *a2, _BYTE *a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = result;
  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (*(_QWORD *)result)
  {
    v9 = v8 % *(unsigned int *)(result + 24);
    v10 = *(unsigned int *)(*(_QWORD *)(result + 8) + 4 * v9);
    if ((_DWORD)v10 != 0x7FFFFFFF)
    {
      v11 = *(_QWORD *)(result + 16);
      if (*(_QWORD *)(v11 + 32 * v10 + 16) == v6)
        return result;
      while (1)
      {
        v10 = *(_DWORD *)(v11 + 32 * v10 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v10 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v11 + 32 * v10 + 16) == v6)
          return result;
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  result = re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(result, v9, v8, a2, a3);
  ++*(_DWORD *)(v5 + 40);
  return result;
}

void re::EntitlementManager::removePeer(re::EntitlementManager *this, unint64_t a2)
{
  re *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int *v15;
  int v16;
  int v17;
  NSObject *v18;
  unint64_t v19;
  uint8_t buf[4];
  unint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v19 = a2;
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this + 16, (uint64_t *)&v19);
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this + 64, (uint64_t *)&v19);
  v3 = (re *)re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this + 112, (uint64_t *)&v19);
  if (*((_QWORD *)this + 20))
  {
    v4 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (v19 ^ (v19 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v19 ^ (v19 >> 30))) >> 27));
    v5 = (v4 ^ (v4 >> 31)) % *((unsigned int *)this + 46);
    v6 = *((_QWORD *)this + 21);
    v7 = *(unsigned int *)(v6 + 4 * v5);
    if ((_DWORD)v7 != 0x7FFFFFFF)
    {
      v8 = *((_QWORD *)this + 22);
      v9 = v8 + 32 * v7;
      if (*(_QWORD *)(v9 + 16) == v19)
      {
        *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 8) & 0x7FFFFFFF;
LABEL_8:
        v12 = *((_QWORD *)this + 22);
        v13 = v12 + 32 * v7;
        v16 = *(_DWORD *)(v13 + 8);
        v15 = (int *)(v13 + 8);
        v14 = v16;
        if (v16 < 0)
        {
          *v15 = v14 & 0x7FFFFFFF;
          v12 = *((_QWORD *)this + 22);
          v14 = *(_DWORD *)(v12 + 32 * v7 + 8);
        }
        *(_DWORD *)(v12 + 32 * v7 + 8) = *((_DWORD *)this + 49) | v14 & 0x80000000;
        --*((_DWORD *)this + 47);
        v17 = *((_DWORD *)this + 50) + 1;
        *((_DWORD *)this + 49) = v7;
        *((_DWORD *)this + 50) = v17;
      }
      else
      {
        while (1)
        {
          v10 = v7;
          v7 = *(_DWORD *)(v8 + 32 * v7 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v7 == 0x7FFFFFFF)
            break;
          v11 = v8 + 32 * v7;
          if (*(_QWORD *)(v11 + 16) == v19)
          {
            *(_DWORD *)(v8 + 32 * v10 + 8) = *(_DWORD *)(v8 + 32 * v10 + 8) & 0x80000000 | *(_DWORD *)(v11 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
  v18 = *re::assetsLogObjects(v3);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    v21 = v19;
    _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "EntitlementManager - Peer (peerID=%llu) has been removed from the entitlement manager", buf, 0xCu);
  }
}

uint64_t re::EntitlementManager::isPeerAllowedAnyShader(re::EntitlementManager *this)
{
  return 1;
}

uint64_t re::EntitlementManager::isPeerAllowedLimitedRenderAssets(re::EntitlementManager *this)
{
  return 1;
}

uint64_t re::EntitlementManager::isPeerAllowedRenderOnTopSPI(re::EntitlementManager *this)
{
  return 1;
}

uint64_t re::EntitlementManager::peerCARESyncBackPermission(re::EntitlementManager *this)
{
  return 0;
}

uint64_t re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _BYTE *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 32 * v9 + 8) = v12 | 0x80000000;
  v13 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(v13 + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(_BYTE *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(v13 + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,re::DataArrayHandle<re::RigGraphNode>,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned long long,BOOL,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, *(_QWORD *)&v13[16] + v10 + 24);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 32;
        }
        while (v11 < v9);
      }
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t *re::resourceSharingLogObjects(re *this)
{
  unsigned __int8 v1;

  {
    re::resourceSharingLogObjects(void)::logObjects = (uint64_t)os_log_create("com.apple.re", "ResourceSharing");
    qword_2558271C0 = (uint64_t)os_log_create("com.apple.re", "ResourceFetch");
  }
  return &re::resourceSharingLogObjects(void)::logObjects;
}

uint64_t *re::allocInfo_AssetPathLoadDescriptorParameters(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_35);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_35))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FB4B8, 0);
    *(uint64_t *)((char *)&qword_2540FB4C8 + 6) = 0;
    qword_2540FB4C8 = 0;
    qword_2540FB4D8 = 0;
    qword_2540FB4E0 = 0xFFFFFFFFLL;
    qword_2540FB4B8 = (uint64_t)&off_24ED7DAA8;
    qword_2540FB4E8 = (uint64_t)"AssetPathLoadDescriptorParameters";
    dword_2540FB4F0 = 0;
    unk_2540FB4F8 = 0u;
    unk_2540FB508 = 0u;
    unk_2540FB518 = 0u;
    qword_2540FB528 = 0;
    __cxa_guard_release(&_MergedGlobals_35);
  }
  return &qword_2540FB4B8;
}

void re::initInfo_AssetPathLoadDescriptorParameters(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  uint64_t *v14;
  const re::IntrospectionBase *v15;
  void *v16;
  uint64_t v17;
  __int128 v18;
  _QWORD v19[2];
  __int128 v20;

  v19[0] = 0xAF839740F16039E8;
  v19[1] = "AssetPathLoadDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v19);
  *((_OWORD *)this + 2) = v20;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FB498);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FB498);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<re::DynamicString>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "scheme";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FB4A0 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::IntrospectionInfo<re::DynamicString>::get(1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "root";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x2000000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_2540FB4A8 = v13;
      v14 = re::introspectionAllocator((re *)v13);
      v16 = re::IntrospectionInfo<re::DynamicString>::get(1, v15);
      v17 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v14 + 32))(v14, 72, 8);
      *(_DWORD *)v17 = 1;
      *(_QWORD *)(v17 + 8) = "subpath";
      *(_QWORD *)(v17 + 16) = v16;
      *(_QWORD *)(v17 + 24) = 0;
      *(_QWORD *)(v17 + 32) = 0x4000000003;
      *(_DWORD *)(v17 + 40) = 0;
      *(_QWORD *)(v17 + 48) = 0;
      *(_QWORD *)(v17 + 56) = 0;
      *(_DWORD *)(v17 + 64) = 0;
      qword_2540FB4B0 = v17;
      __cxa_guard_release(&qword_2540FB498);
    }
  }
  *((_QWORD *)this + 2) = 0x6000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 3;
  *((_QWORD *)this + 8) = &qword_2540FB4A0;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::AssetPathLoadDescriptorParameters>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::AssetPathLoadDescriptorParameters>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::AssetPathLoadDescriptorParameters>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::AssetPathLoadDescriptorParameters>;
  re::IntrospectionRegistry::add(this, v3);
  v18 = v20;
}

void *re::IntrospectionInfo<re::DynamicString>::get(int a1, const re::IntrospectionBase *a2)
{
  unsigned __int8 v2;
  int v3;
  re *v4;
  std::__shared_mutex_base *v5;
  re *v6;
  const re::IntrospectionBase *v7;
  std::__shared_mutex_base *v8;
  int v10;
  int v11;
  __int128 v12;

  if ((v2 & 1) == 0)
  {
    v10 = a1;
    a1 = v10;
    if (v11)
    {
      re::IntrospectionDynamicString::IntrospectionDynamicString((re::IntrospectionDynamicString *)&re::IntrospectionInfo<re::DynamicString>::get(BOOL)::info);
      a1 = v10;
    }
  }
  if (a1)
  {
    if (!re::IntrospectionInfo<re::DynamicString>::get(BOOL)::isInitialized)
    {
      re::IntrospectionInfo<re::DynamicString>::get(BOOL)::isInitialized = 1;
      re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::IntrospectionInfo<re::DynamicString>::get(BOOL)::info, a2);
      xmmword_2558000F8 = v12;
    }
  }
  else
  {
    re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v12);
    v3 = re::IntrospectionInfo<re::DynamicString>::get(BOOL)::isInitialized;
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v12);
    if (!v3)
    {
      v5 = re::introspectionSharedMutex(v4);
      std::__shared_mutex_base::lock(v5);
      if (!re::IntrospectionInfo<re::DynamicString>::get(BOOL)::isInitialized)
      {
        re::IntrospectionInfo<re::DynamicString>::get(BOOL)::isInitialized = 1;
        re::IntrospectionRegistry::add((re::IntrospectionRegistry *)&re::IntrospectionInfo<re::DynamicString>::get(BOOL)::info, v7);
        xmmword_2558000F8 = v12;
      }
      v8 = re::introspectionSharedMutex(v6);
      std::__shared_mutex_base::unlock(v8);
    }
  }
  return &re::IntrospectionInfo<re::DynamicString>::get(BOOL)::info;
}

_QWORD *re::internal::defaultConstruct<re::AssetPathLoadDescriptorParameters>(_anonymous_namespace_ *a1, uint64_t a2, _OWORD *a3)
{
  _OWORD *v3;
  _anonymous_namespace_ *v4;
  _anonymous_namespace_ *v5;

  v3 = a3;
  *a3 = 0u;
  a3[1] = 0u;
  v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v3, 0);
  v3[3] = 0u;
  v3[2] = 0u;
  v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)v3 + 4, 0);
  v3[4] = 0u;
  v3[5] = 0u;
  v3 += 4;
  return re::DynamicString::setCapacity(v3, 0);
}

double re::internal::defaultDestruct<re::AssetPathLoadDescriptorParameters>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  _OWORD *v5;
  double result;
  uint64_t v7;

  v5 = a3 + 8;
  v4 = a3[8];
  if (v4)
  {
    if ((a3[9] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, a3[10]);
    result = 0.0;
    *v5 = 0u;
    v5[1] = 0u;
  }
  v7 = a3[4];
  if (v7)
  {
    if ((a3[5] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 40))(v7, a3[6]);
    result = 0.0;
    *((_OWORD *)a3 + 2) = 0u;
    *((_OWORD *)a3 + 3) = 0u;
  }
  if (*a3)
  {
    if ((a3[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a3 + 40))(*a3, a3[2]);
    result = 0.0;
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
  }
  return result;
}

_QWORD *re::internal::defaultConstructV2<re::AssetPathLoadDescriptorParameters>(_anonymous_namespace_ *a1)
{
  _anonymous_namespace_ *v1;
  _anonymous_namespace_ *v2;
  _anonymous_namespace_ *v3;

  v1 = a1;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  v2 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v1, 0);
  *((_OWORD *)v1 + 3) = 0u;
  *((_OWORD *)v1 + 2) = 0u;
  v3 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)v1 + 4, 0);
  *((_OWORD *)v1 + 4) = 0u;
  *((_OWORD *)v1 + 5) = 0u;
  v1 = (_anonymous_namespace_ *)((char *)v1 + 64);
  return re::DynamicString::setCapacity(v1, 0);
}

double re::internal::defaultDestructV2<re::AssetPathLoadDescriptorParameters>(_QWORD *a1)
{
  uint64_t v2;
  _OWORD *v3;
  double result;
  uint64_t v5;

  v3 = a1 + 8;
  v2 = a1[8];
  if (v2)
  {
    if ((a1[9] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, a1[10]);
    result = 0.0;
    *v3 = 0u;
    v3[1] = 0u;
  }
  v5 = a1[4];
  if (v5)
  {
    if ((a1[5] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, a1[6]);
    result = 0.0;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
  }
  if (*a1)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

_anonymous_namespace_ *re::FallbackAssetProvider::FallbackAssetProvider(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 v8;
  __guard *v9;
  int v11;

  ArcSharedObject::ArcSharedObject(a1, 0);
  *(_QWORD *)a1 = &off_24ED2BDC0;
  *((_QWORD *)a1 + 3) = 0;
  *((_QWORD *)a1 + 4) = 0;
  *((_QWORD *)a1 + 5) = 0;
  if ((v8 & 1) == 0)
  {
    if (v11)
    {
      re::introspect<re::AssetPathLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"AssetPathLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_AssetPathLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_AssetPathLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AssetPathLoadDescriptorParameters>, 0);
    }
  }
  re::FallbackAssetProvider::s_loadDescriptorParametersIntrospect = v9[25];
  *((_QWORD *)a1 + 4) = a3;
  *((_QWORD *)a1 + 5) = a4;
  *((_QWORD *)a1 + 3) = a2;
  return a1;
}

void re::FallbackAssetProvider::~FallbackAssetProvider(re::FallbackAssetProvider *this)
{
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t *re::FallbackAssetProvider::getAssetPath(re::FallbackAssetProvider *this, re::AssetPath *a2, const re::AssetLoadDescriptor *a3, re::AssetLoadDescriptor *a4)
{
  _anonymous_namespace_ *v8;
  _anonymous_namespace_ *v9;
  unsigned __int8 v10;
  __guard *v11;
  uint64_t IntrospectableData;
  _anonymous_namespace_ *v13;
  _BYTE *v14;
  __int128 v15;
  __int128 v16;
  char *v17;
  _anonymous_namespace_ *v18;
  __n128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *result;
  int v23;
  __int128 v24;
  __int128 v25;
  char v26;
  uint64_t v27;
  char v28;
  __n128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  _BYTE v34[23];
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;

  v36 = 0;
  v37 = 0;
  v38 = 0;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v35, 0);
  *((_QWORD *)&v39 + 1) = 0;
  v40 = 0uLL;
  v9 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v39, 0);
  *((_QWORD *)&v41 + 1) = 0;
  v42 = 0uLL;
  re::DynamicString::setCapacity(&v41, 0);
  if ((v10 & 1) == 0)
  {
    if (v23)
    {
      re::introspect<re::AssetPathLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"AssetPathLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_AssetPathLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_AssetPathLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AssetPathLoadDescriptorParameters>, 0);
    }
  }
  IntrospectableData = re::AssetLoadDescriptor::getIntrospectableData(a4, (re **)v11[25], &v35, 0);
  if ((IntrospectableData & 1) != 0)
  {
    v13 = (_anonymous_namespace_ *)re::DynamicString::operator+((re::DynamicString *)&v35, ":", (re::DynamicString *)&v29);
    v14 = (_BYTE *)v40;
    if ((BYTE8(v39) & 1) == 0)
      v14 = (char *)&v39 + 9;
    if (*v14)
    {
      re::DynamicString::operator+((re::DynamicString *)&v39, "/", (re::DynamicString *)&v27);
    }
    else
    {
    }
    re::DynamicString::operator+((re::DynamicString *)&v29, (uint64_t)&v27, (re::DynamicString *)&v24);
    re::DynamicString::operator+((re::DynamicString *)&v24, (uint64_t)&v41, (re::DynamicString *)&v32);
    if ((_QWORD)v24)
    {
      if ((BYTE8(v24) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v24 + 40))();
      v24 = 0u;
      v25 = 0u;
    }
    if (v27 && (v28 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v27 + 40))();
    if (v29.n128_u64[0] && (v29.n128_u8[8] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v29.n128_u64[0] + 40))();
    if ((v33 & 1) != 0)
      v17 = *(char **)&v34[7];
    else
      v17 = v34;
    v19.n128_f64[0] = re::AssetPath::parse(a3, v17, 0, *((const re::internal::AssetTypeRegistry **)a2 + 3), *((os_unfair_lock_s **)a2 + 5), &v24);
    if ((_BYTE)v24)
    {
      *(_BYTE *)this = 1;
    }
    else
    {
      re::DynamicString::operator+((re::DynamicString *)&v27, (uint64_t)&v25 + 8, (re::DynamicString *)&v29);
      v19 = v29;
      v29 = 0uLL;
      v20 = v30;
      v21 = v31;
      v30 = 0;
      v31 = 0;
      *(_BYTE *)this = 0;
      *(__n128 *)((char *)this + 8) = v19;
      *((_QWORD *)this + 3) = v20;
      *((_QWORD *)this + 4) = v21;
      if (v27 && (v28 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v27 + 40))();
      if (!(_BYTE)v24 && *((_QWORD *)&v25 + 1) && (v26 & 1) != 0)
        (*(void (**)(void))(**((_QWORD **)&v25 + 1) + 40))();
    }
    if (v32 && (v33 & 1) != 0)
      (*(void (**)(__n128))(*(_QWORD *)v32 + 40))(v19);
  }
  else
  {
    v15 = v24;
    v16 = v25;
    *(_BYTE *)this = 0;
    *(_OWORD *)((char *)this + 8) = v15;
    *(_OWORD *)((char *)this + 24) = v16;
  }
  if ((_QWORD)v41)
  {
    if ((BYTE8(v41) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v41 + 40))();
    v41 = 0u;
    v42 = 0u;
  }
  if ((_QWORD)v39)
  {
    if ((BYTE8(v39) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v39 + 40))();
    v39 = 0u;
    v40 = 0u;
  }
  result = v35;
  if (v35)
  {
    if ((v36 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v35 + 40))();
  }
  return result;
}

uint64_t re::FallbackAssetProvider::makeDescriptor(re::FallbackAssetProvider *this, const char ***a2)
{
  _anonymous_namespace_ *v4;
  size_t v5;
  const char **v6;
  char *v7;
  _anonymous_namespace_ *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;
  __int128 v17;
  __int128 v18;
  _QWORD v19[4];
  _QWORD v20[4];
  uint64_t v21;
  char v22;
  char v23[8];
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _BYTE v31[8];
  size_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(this, 0);
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_DWORD *)this + 24) = 0;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *((_QWORD *)this + 17) = 0;
  re::DynamicString::setCapacity((_QWORD *)this + 14, 0);
  *(_QWORD *)v23 = "AssetPath";
  v24 = 9;
  re::DynamicString::operator=(this, (uint64_t)v23);
  v5 = strlen(*a2[9]);
  *(_QWORD *)v23 = *a2[9];
  v24 = v5;
  re::DynamicString::operator=((re::FallbackAssetProvider *)((char *)this + 112), (uint64_t)v23);
  v6 = a2[1];
  v35 = 0;
  v36 = 0;
  v33 = (uint64_t)v6;
  v34 = 0;
  re::DynamicString::setCapacity(&v33, 0);
  re::AssetPath::fullAssetPath((re::DynamicString *)a2, (re::DynamicString *)&v33);
  v23[0] = 58;
  v7 = re::DynamicString::find((re::DynamicString *)&v33, v23, 1, 0, (uint64_t)v31);
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v23, 0);
  *((_QWORD *)&v27 + 1) = 0;
  v28 = 0uLL;
  v9 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v27, 0);
  *((_QWORD *)&v29 + 1) = 0;
  v30 = 0uLL;
  re::DynamicString::setCapacity(&v29, 0);
  re::DynamicString::substr((re::DynamicString *)&v33, 0, v32, (re::DynamicString *)&v21);
  re::DynamicString::operator=((re::DynamicString *)v23, (re::DynamicString *)&v21);
  if (v21 && (v22 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v21 + 40))();
  re::DynamicString::operator=((re::DynamicString *)&v27, (re::DynamicString *)(a2 + 1));
  re::DynamicString::operator=((re::DynamicString *)&v29, (re::DynamicString *)(a2 + 5));
  re::DynamicString::DynamicString((re::DynamicString *)&v17, (const re::DynamicString *)v23);
  re::DynamicString::DynamicString((re::DynamicString *)v19, (const re::DynamicString *)&v27);
  re::DynamicString::DynamicString((re::DynamicString *)v20, (const re::DynamicString *)&v29);
  re::AssetLoadDescriptor::setIntrospectableData((char **)this, (const re::IntrospectionBase *)re::FallbackAssetProvider::s_loadDescriptorParametersIntrospect, (const re::IntrospectionBase **)&v17, 0);
  if (v20[0])
  {
    if ((v20[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v20[0] + 40))();
    memset(v20, 0, sizeof(v20));
  }
  if (v19[0])
  {
    if ((v19[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v19[0] + 40))();
    memset(v19, 0, sizeof(v19));
  }
  if ((_QWORD)v17)
  {
    if ((BYTE8(v17) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v17 + 40))();
    v17 = 0u;
    v18 = 0u;
  }
  if ((_QWORD)v29)
  {
    if ((BYTE8(v29) & 1) != 0)
      (*(void (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v29 + 40))(v29, v30, v10, v11, v12, v13, v14, v15, v17, *((_QWORD *)&v17 + 1), v18, *((_QWORD *)&v18 + 1));
    v29 = 0u;
    v30 = 0u;
  }
  if ((_QWORD)v27)
  {
    if ((BYTE8(v27) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v27 + 40))();
    v27 = 0u;
    v28 = 0u;
  }
  if (*(_QWORD *)v23 && (v24 & 1) != 0)
    (*(void (**)(void))(**(_QWORD **)v23 + 40))();
  result = v33;
  if (v33)
  {
    if ((v34 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v33 + 40))();
  }
  return result;
}

re::DynamicString *re::FallbackAssetProvider::load@<X0>(re::internal::AssetTypeRegistry **this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  const char *v9;
  _anonymous_namespace_ *v10;
  re::DynamicString *result;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _anonymous_namespace_ *v15;
  uint64_t *AssetPath;
  uint64_t v17;
  char *v18;
  uint64_t *v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  __int128 v34;
  uint64_t v35;
  char v36[8];
  uint64_t *v37;
  char v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;

  if ((*((_BYTE *)a2 + 8) & 1) != 0)
    v9 = (const char *)*((_QWORD *)a2 + 2);
  else
    v9 = (char *)a2 + 9;
  v10 = (_anonymous_namespace_ *)strcmp(v9, "AssetPath");
  if ((_DWORD)v10)
  {
    v12 = v40;
    v13 = v41;
    v14 = v42;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v12;
    *(_QWORD *)(a4 + 24) = v13;
    *(_QWORD *)(a4 + 32) = v14;
    return result;
  }
  LODWORD(v40) = 0;
  v42 = 0;
  v43 = 0;
  v41 = 0;
  v15 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)&v40 + 1, 0);
  *((_QWORD *)&v44 + 1) = 0;
  v45 = 0uLL;
  re::DynamicString::setCapacity(&v44, 0);
  v46 = 0;
  AssetPath = re::FallbackAssetProvider::getAssetPath((re::FallbackAssetProvider *)v36, (re::AssetPath *)this, (const re::AssetLoadDescriptor *)&v40, a2);
  if (v36[0])
  {
    v34 = 0uLL;
    v35 = 0;
    re::DynamicString::setCapacity(&v33, 0);
    v17 = re::AssetPath::filePathToAsset((re::AssetPath *)&v40, (re::DynamicString *)&v33, 1, 0);
    if ((v17 & 1) != 0)
    {
      if ((*((_BYTE *)a2 + 120) & 1) != 0)
        v18 = (char *)*((_QWORD *)a2 + 16);
      else
        v18 = (char *)a2 + 121;
      re::loadCompiledOrSourceFile((char *)&v33, v18, this + 3, (uint64_t)a3, a4);
    }
    else
    {
      v26 = 0;
      v27 = 0;
      v24 = *((_QWORD *)&v40 + 1);
      v25 = 0;
      re::DynamicString::setCapacity(&v24, 0);
      re::AssetPath::fullAssetPath((re::DynamicString *)&v40, (re::DynamicString *)&v24);
      re::DynamicString::operator+((re::DynamicString *)&v28, (uint64_t)&v24, (re::DynamicString *)&v30);
      v21 = v30;
      v30 = 0uLL;
      v22 = v31;
      v23 = v32;
      v31 = 0;
      v32 = 0;
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(a4 + 8) = v21;
      *(_QWORD *)(a4 + 24) = v22;
      *(_QWORD *)(a4 + 32) = v23;
      if (v24 && (v25 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v24 + 40))();
      if (v28 && (v29 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v28 + 40))();
    }
    v19 = v33;
    if (!v33 || (v34 & 1) == 0)
      goto LABEL_26;
    v20 = *((_QWORD *)&v34 + 1);
  }
  else
  {
    re::DynamicString::DynamicString((re::DynamicString *)&v33, (const re::DynamicString *)&v37);
    *(_BYTE *)a4 = 0;
    *(_QWORD *)(a4 + 8) = v33;
    *(_QWORD *)(a4 + 32) = v35;
    *(_OWORD *)(a4 + 16) = v34;
    v19 = v37;
    if (!v37 || (v38 & 1) == 0)
      goto LABEL_26;
    v20 = v39;
  }
  (*(void (**)(uint64_t *, uint64_t))(*v19 + 40))(v19, v20);
LABEL_26:
  if ((_QWORD)v44)
  {
    if ((BYTE8(v44) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v44 + 40))();
    v44 = 0u;
    v45 = 0u;
  }
  result = (re::DynamicString *)*((_QWORD *)&v40 + 1);
  if (*((_QWORD *)&v40 + 1))
  {
    if ((v41 & 1) != 0)
      return (re::DynamicString *)(*(uint64_t (**)(void))(**((_QWORD **)&v40 + 1) + 40))();
  }
  return result;
}

uint64_t re::FallbackAssetProvider::resolveChild@<X0>(re::FallbackAssetProvider *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, char *a3@<X2>, char *a4@<X3>, uint64_t a5@<X8>)
{
  const char *v10;
  _anonymous_namespace_ *v11;
  uint64_t result;
  __int128 v13;
  __int128 v14;
  _anonymous_namespace_ *v15;
  uint64_t *AssetPath;
  _anonymous_namespace_ *v17;
  _anonymous_namespace_ *v18;
  uint64_t v19;
  __n128 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  int v28;
  __int128 v29;
  __int128 v30;
  int v31;
  _BYTE v32[24];
  __int128 v33;
  _BYTE v34[40];
  __int128 v35;
  int v36;
  __int128 v37;
  __int128 v38;
  int v39;
  _BYTE v40[24];
  __int128 v41;
  _BYTE v42[24];
  uint64_t v43;
  char v44;
  const char **v45;
  _QWORD v46[4];
  __int128 v47;
  __int128 v48;
  uint64_t v49;
  _BYTE v50[8];
  uint64_t v51;
  char v52;
  int v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;

  if ((*((_BYTE *)a2 + 8) & 1) != 0)
    v10 = (const char *)*((_QWORD *)a2 + 2);
  else
    v10 = (char *)a2 + 9;
  v11 = (_anonymous_namespace_ *)strcmp(v10, "AssetPath");
  if ((_DWORD)v11)
  {
    result = re::DynamicString::format((re::DynamicString *)"Scheme %s does not match scheme %s.", (re::DynamicString *)v34, v10, "AssetPath");
    v13 = *(_OWORD *)v34;
    v14 = *(_OWORD *)&v34[16];
    *(_BYTE *)a5 = 0;
    *(_OWORD *)(a5 + 8) = v13;
    *(_OWORD *)(a5 + 24) = v14;
    return result;
  }
  v53 = 0;
  v56 = 0;
  v57 = 0;
  v55 = 0;
  v15 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v54, 0);
  *((_QWORD *)&v58 + 1) = 0;
  v59 = 0uLL;
  re::DynamicString::setCapacity(&v58, 0);
  v60 = 0;
  AssetPath = re::FallbackAssetProvider::getAssetPath((re::FallbackAssetProvider *)v50, this, (const re::AssetLoadDescriptor *)&v53, a2);
  if (v50[0])
  {
    LODWORD(v45) = 0;
    memset(v46, 0, sizeof(v46));
    v17 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v46, 0);
    v48 = 0u;
    v47 = 0u;
    re::DynamicString::setCapacity(&v47, 0);
    v49 = 0;
    re::AssetPath::parse((re::AssetPath *)&v45, a3, (const re::AssetPath *)&v53, *((const re::internal::AssetTypeRegistry **)this + 3), *((os_unfair_lock_s **)this + 5), v42);
    if (v42[0])
    {
      v49 = re::internal::AssetTypeRegistry::assetTypeWithName(*((re::internal::AssetTypeRegistry **)this + 3), a4);
      re::FallbackAssetProvider::makeDescriptor((re::FallbackAssetProvider *)&v24, &v45);
      v19 = v24;
      v24 = 0;
      *(_QWORD *)v34 = v19;
      *(_OWORD *)&v34[24] = v26;
      v26 = 0u;
      *(_OWORD *)&v34[8] = v25;
      v25 = 0u;
      v35 = v27;
      v27 = 0u;
      ++v28;
      v36 = 1;
      v37 = v29;
      v38 = v30;
      v29 = 0u;
      v30 = 0u;
      ++v31;
      v39 = 1;
      *(_OWORD *)v40 = *(_OWORD *)v32;
      memset(v32, 0, sizeof(v32));
      v41 = v33;
      *(_QWORD *)&v40[16] = *(_QWORD *)&v32[16];
      v33 = 0uLL;
      v20.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional(a5, (uint64_t)v34);
      if (*(_QWORD *)&v40[8])
      {
        if ((v40[16] & 1) != 0)
          (*(void (**)(double))(**(_QWORD **)&v40[8] + 40))(v20.n128_f64[0]);
        v20 = 0uLL;
        *(_OWORD *)&v40[8] = 0u;
        v41 = 0u;
      }
      if (*((_QWORD *)&v37 + 1))
      {
        if (*(_QWORD *)v40)
          (*(void (**)(__n128))(**((_QWORD **)&v37 + 1) + 40))(v20);
        *(_QWORD *)v40 = 0;
        v38 = 0uLL;
        *((_QWORD *)&v37 + 1) = 0;
        ++v39;
      }
      if (*(_QWORD *)&v34[32])
      {
        if ((_QWORD)v37)
          (*(void (**)(__n128))(**(_QWORD **)&v34[32] + 40))(v20);
        *(_QWORD *)&v37 = 0;
        v35 = 0uLL;
        *(_QWORD *)&v34[32] = 0;
        ++v36;
      }
      if (*(_QWORD *)v34)
      {
        if ((v34[8] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)v34 + 40))(v20);
        v20 = 0uLL;
        memset(v34, 0, 32);
      }
      if (*(_QWORD *)&v32[8])
      {
        if ((v32[16] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)&v32[8] + 40))(v20);
        v20 = 0uLL;
        *(_OWORD *)&v32[8] = 0u;
        v33 = 0u;
      }
      if (*((_QWORD *)&v29 + 1))
      {
        if (*(_QWORD *)v32)
          (*(void (**)(__n128))(**((_QWORD **)&v29 + 1) + 40))(v20);
        *(_QWORD *)v32 = 0;
        v30 = 0uLL;
        *((_QWORD *)&v29 + 1) = 0;
        ++v31;
      }
      if (*((_QWORD *)&v26 + 1))
      {
        if ((_QWORD)v29)
          (*(void (**)(__n128))(**((_QWORD **)&v26 + 1) + 40))(v20);
        *(_QWORD *)&v29 = 0;
        v27 = 0uLL;
        *((_QWORD *)&v26 + 1) = 0;
        ++v28;
      }
    }
    else
    {
      re::DynamicString::operator+((re::DynamicString *)&v24, (uint64_t)&v43, (re::DynamicString *)v34);
      v20 = *(__n128 *)v34;
      memset(v34, 0, 32);
      v22 = *(_QWORD *)&v34[16];
      v23 = *(_QWORD *)&v34[24];
      *(_BYTE *)a5 = 0;
      *(__n128 *)(a5 + 8) = v20;
      *(_QWORD *)(a5 + 24) = v22;
      *(_QWORD *)(a5 + 32) = v23;
    }
    if (v24 && (v25 & 1) != 0)
      (*(void (**)(__n128))(*(_QWORD *)v24 + 40))(v20);
    if (!v42[0] && v43 && (v44 & 1) != 0)
      (*(void (**)(__n128))(*(_QWORD *)v43 + 40))(v20);
    if ((_QWORD)v47)
    {
      if ((BYTE8(v47) & 1) != 0)
        (*(void (**)(__n128))(*(_QWORD *)v47 + 40))(v20);
      v20 = 0uLL;
      v47 = 0u;
      v48 = 0u;
    }
    if (v46[0] && (v46[1] & 1) != 0)
      (*(void (**)(__n128))(*(_QWORD *)v46[0] + 40))(v20);
    if (v50[0])
      goto LABEL_54;
  }
  else
  {
    re::DynamicString::DynamicString((re::DynamicString *)v34, (const re::DynamicString *)&v51);
    *(_BYTE *)a5 = 0;
    v21 = *(_QWORD *)&v34[24];
    *(_QWORD *)(a5 + 8) = *(_QWORD *)v34;
    *(_QWORD *)(a5 + 32) = v21;
    v20 = *(__n128 *)&v34[8];
    *(_OWORD *)(a5 + 16) = *(_OWORD *)&v34[8];
  }
  if (v51 && (v52 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v51 + 40))();
LABEL_54:
  if ((_QWORD)v58)
  {
    if ((BYTE8(v58) & 1) != 0)
      (*(void (**)(__n128))(*(_QWORD *)v58 + 40))(v20);
    v20 = 0uLL;
    v58 = 0u;
    v59 = 0u;
  }
  result = (uint64_t)v54;
  if (v54)
  {
    if ((v55 & 1) != 0)
      return (*(uint64_t (**)(__n128))(*v54 + 40))(v20);
  }
  return result;
}

uint64_t *re::FallbackAssetProvider::getDescription(re::FallbackAssetProvider *this, const re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  _anonymous_namespace_ *v6;
  const char *v7;
  uint64_t v8;
  uint64_t *result;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14[8];
  const char *v15;
  char v16;
  uint64_t v17;
  int v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v18 = 0;
  v21 = 0;
  v22 = 0;
  v20 = 0;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v19, 0);
  *((_QWORD *)&v23 + 1) = 0;
  v24 = 0uLL;
  re::DynamicString::setCapacity(&v23, 0);
  v25 = 0;
  re::FallbackAssetProvider::getAssetPath((re::FallbackAssetProvider *)v14, this, (const re::AssetLoadDescriptor *)&v18, a2);
  if (v14[0])
  {
    v12 = 0;
    v13 = 0;
    v10 = (const char *)v19;
    v11 = 0;
    re::DynamicString::setCapacity(&v10, 0);
    re::AssetPath::fullAssetPath((re::DynamicString *)&v18, (re::DynamicString *)&v10);
    re::DynamicString::operator=(a3, (re::DynamicString *)&v10);
    v7 = v10;
    if (v10 && (v11 & 1) != 0)
    {
      v8 = v12;
LABEL_8:
      (*(void (**)(const char *, uint64_t))(*(_QWORD *)v7 + 40))(v7, v8);
    }
  }
  else
  {
    v10 = "mangled";
    v11 = 7;
    re::DynamicString::operator=(a3, (uint64_t)&v10);
    v7 = v15;
    if (v15 && (v16 & 1) != 0)
    {
      v8 = v17;
      goto LABEL_8;
    }
  }
  if ((_QWORD)v23)
  {
    if ((BYTE8(v23) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v23 + 40))();
    v23 = 0u;
    v24 = 0u;
  }
  result = v19;
  if (v19)
  {
    if ((v20 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v19 + 40))();
  }
  return result;
}

uint64_t re::FallbackAssetProvider::getAssetPathForRelease@<X0>(_anonymous_namespace_ *a1@<X0>, re::AssetLoadDescriptor *a2@<X1>, uint64_t a3@<X8>)
{
  _anonymous_namespace_ *v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  _BYTE v14[8];
  uint64_t v15;
  char v16;
  int v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v17 = 0;
  v20 = 0;
  v21 = 0;
  v19 = 0;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v18, 0);
  *((_QWORD *)&v22 + 1) = 0;
  v23 = 0uLL;
  re::DynamicString::setCapacity(&v22, 0);
  v24 = 0;
  re::FallbackAssetProvider::getAssetPath((re::FallbackAssetProvider *)v14, a1, (const re::AssetLoadDescriptor *)&v17, a2);
  if (!v14[0] && v15 && (v16 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  v12 = 0;
  v13 = 0;
  v11 = (unint64_t)v18;
  re::DynamicString::setCapacity(&v11, 0);
  re::AssetPath::fullAssetPath((re::DynamicString *)&v17, (re::DynamicString *)&v11);
  v7 = v11;
  v8 = v12;
  v9 = v13;
  *(_BYTE *)a3 = 1;
  *(_OWORD *)(a3 + 8) = v7;
  *(_QWORD *)(a3 + 24) = v8;
  *(_QWORD *)(a3 + 32) = v9;
  if ((_QWORD)v22)
  {
    if ((BYTE8(v22) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v22 + 40))();
    v22 = 0u;
    v23 = 0u;
  }
  result = (uint64_t)v18;
  if (v18)
  {
    if ((v19 & 1) != 0)
      return (*(uint64_t (**)(void))(*v18 + 40))();
  }
  return result;
}

uint64_t re::FallbackAssetProvider::makeDescriptorFromAssetPath@<X0>(const char ***a1@<X1>, uint64_t a2@<X8>)
{
  __n128 v4;
  uint64_t result;
  uint64_t v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;

  re::FallbackAssetProvider::makeDescriptor((re::FallbackAssetProvider *)&v6, a1);
  v4.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional(a2, (uint64_t)&v6);
  if ((_QWORD)v18)
  {
    if ((BYTE8(v18) & 1) != 0)
      (*(void (**)(double))(*(_QWORD *)v18 + 40))(v4.n128_f64[0]);
    v4 = 0uLL;
    v18 = 0u;
    v19 = 0u;
  }
  if (v13)
  {
    if (v17)
      (*(void (**)(__n128))(*(_QWORD *)v13 + 40))(v4);
    v17 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 0;
    ++v16;
  }
  if (v8)
  {
    if (v12)
      (*(void (**)(__n128))(*(_QWORD *)v8 + 40))(v4);
    v12 = 0;
    v9 = 0;
    v10 = 0;
    v8 = 0;
    ++v11;
  }
  result = v6;
  if (v6)
  {
    if ((v7 & 1) != 0)
      return (*(uint64_t (**)(__n128))(*(_QWORD *)v6 + 40))(v4);
  }
  return result;
}

const char *re::FallbackAssetProvider::schemeName(re::FallbackAssetProvider *this)
{
  return "AssetPath";
}

uint64_t re::AssetProvider::transformDescriptor@<X0>(_BYTE *a1@<X8>)
{
  _BYTE v2[152];
  unsigned __int8 v3[152];

  v2[0] = 0;
  v3[0] = 0;
  *a1 = 1;
  re::Optional<re::AssetLoadDescriptor>::Optional((uint64_t)(a1 + 8), v3);
  re::Optional<re::AssetLoadDescriptor>::~Optional((uint64_t)v3);
  return re::Optional<re::AssetLoadDescriptor>::~Optional((uint64_t)v2);
}

void re::AssetProvider::getSource(_BYTE *a1@<X8>)
{
  *a1 = 1;
  a1[8] = 0;
}

uint64_t re::AssetProvider::isDeviceAssetForRelease()
{
  return 0;
}

double re::Optional<re::AssetLoadDescriptor>::Optional(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  *(_BYTE *)a1 = 1;
  result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 24);
  v3 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)a2;
  *(_QWORD *)a2 = 0;
  v4 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 24) = 0;
  v6 = *(_QWORD *)(a1 + 16);
  v5 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a1 + 16) = v3;
  *(_QWORD *)(a1 + 24) = v4;
  *(_QWORD *)(a2 + 8) = v6;
  *(_QWORD *)(a2 + 16) = v5;
  *(_QWORD *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  v7 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 48) = v7;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  v8 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = v8;
  v9 = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a2 + 64) = v9;
  ++*(_DWORD *)(a2 + 56);
  ++*(_DWORD *)(a1 + 64);
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  v10 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a1 + 88) = v10;
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 80) = 0;
  v11 = *(_QWORD *)(a1 + 96);
  *(_QWORD *)(a1 + 96) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a2 + 88) = v11;
  v12 = *(_QWORD *)(a1 + 112);
  *(_QWORD *)(a1 + 112) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = v12;
  ++*(_DWORD *)(a2 + 96);
  ++*(_DWORD *)(a1 + 104);
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 136);
  v13 = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 120) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a2 + 112) = 0;
  v14 = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a2 + 136) = 0;
  v16 = *(_QWORD *)(a1 + 128);
  v15 = *(_QWORD *)(a1 + 136);
  *(_QWORD *)(a1 + 128) = v13;
  *(_QWORD *)(a1 + 136) = v14;
  *(_QWORD *)(a2 + 120) = v16;
  *(_QWORD *)(a2 + 128) = v15;
  return result;
}

double re::Optional<re::AssetLoadDescriptor>::Optional(uint64_t a1, unsigned __int8 *a2)
{
  int v2;
  double result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v2 = *a2;
  *(_BYTE *)a1 = v2;
  if (v2)
  {
    result = 0.0;
    *(_OWORD *)(a1 + 24) = 0u;
    *(_OWORD *)(a1 + 8) = 0u;
    *(_QWORD *)(a1 + 32) = *((_QWORD *)a2 + 4);
    v4 = *((_QWORD *)a2 + 2);
    *(_QWORD *)(a1 + 8) = *((_QWORD *)a2 + 1);
    *((_QWORD *)a2 + 1) = 0;
    v5 = *((_QWORD *)a2 + 3);
    *((_QWORD *)a2 + 4) = 0;
    v7 = *(_QWORD *)(a1 + 16);
    v6 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 16) = v4;
    *(_QWORD *)(a1 + 24) = v5;
    *((_QWORD *)a2 + 2) = v7;
    *((_QWORD *)a2 + 3) = v6;
    *(_QWORD *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 40) = 0;
    v8 = *((_QWORD *)a2 + 6);
    *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 5);
    *(_QWORD *)(a1 + 48) = v8;
    *((_QWORD *)a2 + 5) = 0;
    *((_QWORD *)a2 + 6) = 0;
    v9 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 56) = *((_QWORD *)a2 + 7);
    *((_QWORD *)a2 + 7) = v9;
    v10 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)(a1 + 72) = *((_QWORD *)a2 + 9);
    *((_QWORD *)a2 + 9) = v10;
    ++*((_DWORD *)a2 + 16);
    ++*(_DWORD *)(a1 + 64);
    *(_QWORD *)(a1 + 112) = 0;
    *(_QWORD *)(a1 + 88) = 0;
    *(_QWORD *)(a1 + 96) = 0;
    *(_QWORD *)(a1 + 80) = 0;
    *(_DWORD *)(a1 + 104) = 0;
    v11 = *((_QWORD *)a2 + 11);
    *(_QWORD *)(a1 + 80) = *((_QWORD *)a2 + 10);
    *(_QWORD *)(a1 + 88) = v11;
    *((_QWORD *)a2 + 10) = 0;
    *((_QWORD *)a2 + 11) = 0;
    v12 = *(_QWORD *)(a1 + 96);
    *(_QWORD *)(a1 + 96) = *((_QWORD *)a2 + 12);
    *((_QWORD *)a2 + 12) = v12;
    v13 = *(_QWORD *)(a1 + 112);
    *(_QWORD *)(a1 + 112) = *((_QWORD *)a2 + 14);
    *((_QWORD *)a2 + 14) = v13;
    ++*((_DWORD *)a2 + 26);
    ++*(_DWORD *)(a1 + 104);
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 136) = 0u;
    *(_QWORD *)(a1 + 144) = *((_QWORD *)a2 + 18);
    v14 = *((_QWORD *)a2 + 16);
    *(_QWORD *)(a1 + 120) = *((_QWORD *)a2 + 15);
    *((_QWORD *)a2 + 15) = 0;
    v15 = *((_QWORD *)a2 + 17);
    *((_QWORD *)a2 + 18) = 0;
    v17 = *(_QWORD *)(a1 + 128);
    v16 = *(_QWORD *)(a1 + 136);
    *(_QWORD *)(a1 + 128) = v14;
    *(_QWORD *)(a1 + 136) = v15;
    *((_QWORD *)a2 + 16) = v17;
    *((_QWORD *)a2 + 17) = v16;
  }
  return result;
}

uint64_t re::Optional<re::AssetLoadDescriptor>::~Optional(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  if (*(_BYTE *)a1)
  {
    v3 = (_OWORD *)(a1 + 120);
    v2 = *(_QWORD *)(a1 + 120);
    if (v2)
    {
      if ((*(_BYTE *)(a1 + 128) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 136));
      *v3 = 0u;
      *(_OWORD *)(a1 + 136) = 0u;
    }
    v4 = (_QWORD *)(a1 + 8);
    v5 = *(_QWORD *)(a1 + 80);
    if (v5)
    {
      if (*(_QWORD *)(a1 + 112))
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 80) = 0;
      ++*(_DWORD *)(a1 + 104);
    }
    v6 = *(_QWORD *)(a1 + 40);
    if (v6)
    {
      if (*(_QWORD *)(a1 + 72))
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
      *(_QWORD *)(a1 + 72) = 0;
      *(_QWORD *)(a1 + 48) = 0;
      *(_QWORD *)(a1 + 56) = 0;
      *(_QWORD *)(a1 + 40) = 0;
      ++*(_DWORD *)(a1 + 64);
    }
    if (*v4)
    {
      if ((*(_BYTE *)(a1 + 16) & 1) != 0)
        (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v4 + 40))(*v4, *(_QWORD *)(a1 + 24));
      *(_OWORD *)v4 = 0u;
      *(_OWORD *)(a1 + 24) = 0u;
    }
  }
  return a1;
}

void re::CustomAssetRegistrationParameters::~CustomAssetRegistrationParameters(re::CustomAssetRegistrationParameters *this)
{
  const void *v2;
  const void *v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24ED2BE60;
  v2 = (const void *)*((_QWORD *)this + 7);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 7) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 8);
  if (v3)
  {
    CFRelease(v3);
    *((_QWORD *)this + 8) = 0;
  }
  v4 = *((_QWORD *)this + 3);
  if (v4)
  {
    if ((*((_BYTE *)this + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 5));
    *(_OWORD *)((char *)this + 24) = 0u;
    *(_OWORD *)((char *)this + 40) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::CustomAssetRegistrationParameters::~CustomAssetRegistrationParameters(this);
  JUMPOUT(0x2276933B8);
}

void re::CustomAssetRegistrationParameters::setAssetEncoder(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = *(CFTypeRef *)(a1 + 56);
  if (v3 != cf)
  {
    if (v3)
      CFRelease(v3);
    *(_QWORD *)(a1 + 56) = cf;
    if (cf)
      CFRetain(cf);
  }
}

void re::CustomAssetRegistrationParameters::setAssetDecoder(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = *(CFTypeRef *)(a1 + 64);
  if (v3 != cf)
  {
    if (v3)
      CFRelease(v3);
    *(_QWORD *)(a1 + 64) = cf;
    if (cf)
      CFRetain(cf);
  }
}

void re::CustomAssetRegistrationParameters::validate(re::CustomAssetRegistrationParameters *this@<X0>, char *a2@<X8>)
{
  unint64_t v3;
  unint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;

  v3 = *((_QWORD *)this + 4);
  if ((v3 & 1) != 0)
    v4 = v3 >> 1;
  else
    v4 = v3 >> 1;
  if (v4)
  {
    v5 = 1;
    a2[8] = 1;
  }
  else
  {
    re::WrappedError::make((re::WrappedError *)CFSTR("REAssetTypeRegistrationErrorDomain"), (const __CFString *)1, 0, &v7);
    v6 = v7;
    v7 = 0;
    *((_QWORD *)a2 + 1) = v6;

    v5 = 0;
  }
  *a2 = v5;
}

void re::CustomAsset::setRuntimeObject(re::CustomAsset *this, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = (CFTypeRef)*((_QWORD *)this + 1);
  if (v3 != cf)
  {
    if (v3)
      CFRelease(v3);
    *((_QWORD *)this + 1) = cf;
    if (cf)
      CFRetain(cf);
  }
}

void re::CustomAsset::~CustomAsset(re::CustomAsset *this)
{
  const void *v2;

  *(_QWORD *)this = &off_24ED2BE90;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 1) = 0;
  }
}

{
  const void *v2;

  *(_QWORD *)this = &off_24ED2BE90;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 1) = 0;
  }
  JUMPOUT(0x2276933B8);
}

uint64_t ___ZN2re17CustomAssetLoaderC2EU13block_pointerFPK8__CFDataPKvPP9__CFErrorEU13block_pointerFS5_S3_S8_E_block_invoke(re *a1, uint64_t a2, CFErrorRef *a3)
{
  NSObject *v4;
  uint8_t v6[16];

  v4 = *re::assetTypesLogObjects(a1);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v6 = 0;
    _os_log_error_impl(&dword_224FE9000, v4, OS_LOG_TYPE_ERROR, "Asset encoding failed because no data encoder callback is registered for this custom asset type.", v6, 2u);
    if (!a3)
      return 0;
    goto LABEL_3;
  }
  if (a3)
LABEL_3:
    *a3 = CFErrorCreate(0, CFSTR("REAssetTypeRegistrationErrorDomain"), 4, 0);
  return 0;
}

uint64_t ___ZN2re17CustomAssetLoaderC2EU13block_pointerFPK8__CFDataPKvPP9__CFErrorEU13block_pointerFS5_S3_S8_E_block_invoke_1(re *a1, uint64_t a2, CFErrorRef *a3)
{
  NSObject *v4;
  uint8_t v6[16];

  v4 = *re::assetTypesLogObjects(a1);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v6 = 0;
    _os_log_error_impl(&dword_224FE9000, v4, OS_LOG_TYPE_ERROR, "Asset decoding failed because no data decoder callback is registered for this custom asset type.", v6, 2u);
    if (!a3)
      return 0;
    goto LABEL_3;
  }
  if (a3)
LABEL_3:
    *a3 = CFErrorCreate(0, CFSTR("REAssetTypeRegistrationErrorDomain"), 3, 0);
  return 0;
}

void re::CustomAssetLoader::~CustomAssetLoader(CFTypeRef *this)
{
  *this = &off_24ED2BEB0;
  CFRelease(this[1]);
  CFRelease(this[2]);
}

{
  *this = &off_24ED2BEB0;
  CFRelease(this[1]);
  CFRelease(this[2]);
  JUMPOUT(0x2276933B8);
}

re *re::CustomAssetLoader::unloadAsset(re *this, void (***a2)(_QWORD))
{
  uint64_t v3;

  if (a2)
  {
    v3 = re::globalAllocators(this)[2];
    (**a2)(a2);
    return (re *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v3 + 40))(v3, a2);
  }
  return this;
}

uint64_t re::CustomAssetLoader::createRuntimeData(uint64_t a1, re::CustomAsset *a2, uint64_t a3)
{
  re *v5;
  NSObject *v6;
  uint64_t v7;
  re *v8;
  CFTypeRef cf;
  id v11;
  uint64_t v12;
  re::Data *v13;
  const void *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint8_t buf[4];
  CFTypeRef v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v20 = 0;
  v17 = 0;
  v18 = 0;
  v16 = 0;
  v19 = 0;
  v13 = 0;
  v14 = 0;
  v12 = a3;
  v15 = 0;
  if (re::SeekableInputStreamBufferedReader::readNext((re::SeekableInputStreamBufferedReader *)&v12, 0xFFFFFFFFFFFFFFFFLL))
  {
    re::Data::makeDataWithBytesNoCopy(v13, v14, &v11);
    cf = 0;
    v5 = (re *)(*(uint64_t (**)(_QWORD, id, CFTypeRef *))(*(_QWORD *)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16), v11, &cf);
    if (cf)
    {
      v6 = *re::assetTypesLogObjects(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138412290;
        v22 = cf;
        _os_log_error_impl(&dword_224FE9000, v6, OS_LOG_TYPE_ERROR, "Failed to decode custom asset. Error = %@", buf, 0xCu);
      }
      CFRelease(cf);
    }
    else
    {
      v8 = v5;
      if (v5)
      {
        re::CustomAsset::setRuntimeObject(a2, v5);
        CFRelease(v8);
        v7 = 1;
        goto LABEL_10;
      }
    }
    v7 = 0;
LABEL_10:

    goto LABEL_11;
  }
  v7 = 1;
LABEL_11:
  re::SeekableInputStreamBufferedReader::~SeekableInputStreamBufferedReader((re::SeekableInputStreamBufferedReader *)&v12);
  return v7;
}

uint64_t re::CustomAssetLoader::serializeAssetBlob(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const __CFData *v4;
  const __CFData *v5;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a3 + 8))
  {
    v4 = (const __CFData *)(*(uint64_t (**)(void))(*(_QWORD *)(a1 + 8) + 16))();
    v5 = v4;
    if (v4)
    {
      BytePtr = CFDataGetBytePtr(v4);
      Length = CFDataGetLength(v5);
      (*(void (**)(uint64_t, const UInt8 *, CFIndex))(*(_QWORD *)a2 + 16))(a2, BytePtr, Length);
      CFRelease(v5);
    }
  }
  return 1;
}

uint64_t re::CustomAssetLoader::isSupportedSourceExtension(re::CustomAssetLoader *this, const char *a2)
{
  return 0;
}

uint64_t re::CustomAssetLoader::introspectionType(re::CustomAssetLoader *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&qword_2540FB548);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&qword_2540FB548))
  {
    qword_2540FB540 = re::internal::getOrCreateInfo((re::internal *)"CustomAsset", (uint64_t (*)(re::internal *))re::allocInfo_CustomAsset, (re::IntrospectionBase *(*)(void))re::initInfo_CustomAsset, (void (*)(re::IntrospectionBase *))&unk_2540FB538, 0);
    __cxa_guard_release(&qword_2540FB548);
  }
  return qword_2540FB540;
}

uint64_t *re::allocInfo_CustomAsset(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_36);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_36))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FB550, 0);
    *(uint64_t *)((char *)&qword_2540FB560 + 6) = 0;
    qword_2540FB560 = 0;
    qword_2540FB570 = 0;
    qword_2540FB578 = 0xFFFFFFFFLL;
    qword_2540FB550 = (uint64_t)&off_24ED7DAA8;
    qword_2540FB580 = (uint64_t)"CustomAsset";
    dword_2540FB588 = 0;
    xmmword_2540FB590 = 0u;
    unk_2540FB5A0 = 0u;
    xmmword_2540FB5B0 = 0u;
    qword_2540FB5C0 = 0;
    __cxa_guard_release(&_MergedGlobals_36);
  }
  return &qword_2540FB550;
}

void re::initInfo_CustomAsset(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x19CE54DEF9F2BBELL;
  v5[1] = "CustomAsset";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x1000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_CustomAsset(re::IntrospectionBase *)::structureAttributes;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::CustomAsset>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::CustomAsset>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::CustomAsset>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::CustomAsset>;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

void re::internal::defaultConstruct<re::CustomAsset>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  *a3 = &off_24ED2BE90;
  a3[1] = 0;
}

uint64_t re::internal::defaultDestruct<re::CustomAsset>(uint64_t a1, uint64_t a2, uint64_t (***a3)(_QWORD))
{
  return (**a3)(a3);
}

_QWORD *re::internal::defaultConstructV2<re::CustomAsset>(_QWORD *result)
{
  *result = &off_24ED2BE90;
  result[1] = 0;
  return result;
}

uint64_t re::internal::defaultDestructV2<re::CustomAsset>(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t re::AssetLoader::deferUnregister(re::AssetLoader *this, void *a2)
{
  return 0;
}

uint64_t re::AssetLoader::prepareAssetForSerialization(re::AssetLoader *this, void *a2)
{
  return 0;
}

uint64_t re::AssetLoader::defaultAssetCompileOptions(re::AssetLoader *this)
{
  return 0;
}

uint64_t re::AssetLoader::hasShareableCapability(re::AssetLoader *this)
{
  return 1;
}

void re::SeekableInputStreamBufferedReader::~SeekableInputStreamBufferedReader(re::SeekableInputStreamBufferedReader *this)
{
  uint64_t v2;

  if (*((_DWORD *)this + 6))
  {
    (*(void (**)(void))(**(_QWORD **)this + 24))();
    *((_DWORD *)this + 6) = 0;
  }
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    if (*((_QWORD *)this + 8))
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 40))(v2);
    *((_QWORD *)this + 8) = 0;
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)this + 6) = 0;
    *((_QWORD *)this + 4) = 0;
    ++*((_DWORD *)this + 14);
  }
}

uint64_t zip_entry_data_offset(_QWORD **a1)
{
  _DWORD v4[6];
  unsigned __int16 v5;
  unsigned __int16 v6;

  ((void (*)(_QWORD, _QWORD *, _QWORD))(*a1)[1])(**a1, a1[4], 0);
  if (((uint64_t (*)(_QWORD, _DWORD *, uint64_t))(*a1)[2])(**a1, v4, 30) == 30 && v4[0] == 67324752)
    return (uint64_t)a1[4] + v5 + v6 + 30;
  else
    return 0;
}

BOOL zip_entry_is_alignment(uint64_t a1)
{
  uint64_t *v1;
  int v2;
  int v3;
  int v4;

  v1 = (uint64_t *)(a1 + 8);
  v2 = *(char *)(a1 + 31);
  if (v2 < 0)
  {
    if (*(_QWORD *)(a1 + 16) != 7)
      return 0;
    v1 = (uint64_t *)*v1;
  }
  else if (v2 != 7)
  {
    return 0;
  }
  v3 = *(_DWORD *)v1;
  v4 = *(_DWORD *)((char *)v1 + 3);
  return v3 == 1768710446 && v4 == 795764585;
}

uint64_t zip_entry_load_data_begin(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  int v8;
  int v9;
  unsigned int v10;

  v2 = zip_entry_data_offset((_QWORD **)a1);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = operator new();
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *(_QWORD *)(v4 + 72) = 0;
  v5 = *(_QWORD **)a1;
  *(_DWORD *)v4 = 0;
  *(_QWORD *)(v4 + 8) = v5;
  *(_QWORD *)(v4 + 16) = v3;
  v6 = *(_QWORD *)(a1 + 48) + v3;
  *(_QWORD *)(v4 + 24) = v3;
  *(_QWORD *)(v4 + 32) = v6;
  if (*(_WORD *)(a1 + 92))
  {
    v7 = work_buffer_size;
    *(_QWORD *)(v4 + 56) = work_buffer_size;
    *(_QWORD *)(v4 + 48) = malloc_type_malloc(v7, 0x1F4F629FuLL);
    v8 = *(unsigned __int16 *)(a1 + 92);
    if (v8 == 14)
      v9 = 4;
    else
      v9 = v8 == 8;
    if (v8 == 99)
      v10 = 2;
    else
      v10 = v9;
    *(_QWORD *)(v4 + 40) = reality_compression_stream_begin(v10, 1);
  }
  return v4;
}

unint64_t zip_entry_load_data_read(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t chunk;
  uint64_t v8;
  unint64_t v9;
  _BOOL4 v10;
  int v11;
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;

  v3 = 0;
  if (a2 && *(_DWORD *)a3 != 1)
  {
    if (!*(_QWORD *)(a3 + 40))
      return zip_entry_load_chunk(a1, a2, a3);
    v3 = 0;
    chunk = *(_QWORD *)(a3 + 72);
    while (1)
    {
      if (!chunk)
      {
        v8 = *(_QWORD *)(a3 + 48);
        v9 = *(_QWORD *)(a3 + 56);
        *(_QWORD *)(a3 + 64) = v8;
        chunk = zip_entry_load_chunk(v8, v9, a3);
        *(_QWORD *)(a3 + 72) = chunk;
      }
      v10 = *(_QWORD *)(a3 + 24) == *(_QWORD *)(a3 + 32);
      v16 = *(_QWORD *)(a3 + 64);
      v17 = chunk;
      v18 = v3 + a1;
      v19 = a2 - v3;
      v15 = 0;
      v13 = 0u;
      v14 = 0u;
      reality_compression_process_stream_chunk(v10, (uint64_t)&v16, *(_QWORD *)(a3 + 40), (uint64_t)&v13);
      v11 = v13;
      if (!(_DWORD)v13)
        break;
      chunk = v17;
      *(_QWORD *)(a3 + 64) = v16;
      *(_QWORD *)(a3 + 72) = chunk;
      v3 += v14;
      if (v11 == 1 || v3 >= a2)
        return v3;
    }
    v3 = 0;
    *(_DWORD *)a3 = 1;
  }
  return v3;
}

unint64_t zip_entry_load_chunk(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v5;
  unint64_t v6;

  v5 = *(_QWORD *)(a3 + 24);
  if (*(_QWORD *)(a3 + 32) - v5 >= a2)
    v6 = a2;
  else
    v6 = *(_QWORD *)(a3 + 32) - v5;
  (*(void (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a3 + 8) + 8))(**(_QWORD **)(a3 + 8), *(_QWORD *)(a3 + 24), 0);
  if ((*(uint64_t (**)(_QWORD, uint64_t, unint64_t))(*(_QWORD *)(a3 + 8) + 16))(**(_QWORD **)(a3 + 8), a1, v6) == v6)
  {
    *(_QWORD *)(a3 + 24) += v6;
  }
  else
  {
    v6 = 0;
    *(_DWORD *)a3 = 1;
  }
  return v6;
}

BOOL zip_entry_load_data_end(int *a1)
{
  compression_stream **v2;
  int v3;

  v2 = (compression_stream **)*((_QWORD *)a1 + 5);
  if (v2)
    reality_compression_stream_end(v2);
  v3 = *a1;
  MEMORY[0x2276933B8](a1, 0x10E0C402484923FLL);
  return v3 == 0;
}

uint64_t zip_entry_save_data_begin(_WORD *a1)
{
  uint64_t v2;
  char *v3;
  char *v4;
  uint64_t v5;
  char *v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  size_t v10;

  v2 = *(_QWORD *)a1;
  *(_BYTE *)(v2 + 137) = *(_BYTE *)(*(_QWORD *)a1 + 137) & 0xFC;
  *((_QWORD *)a1 + 4) = *(_QWORD *)(v2 + 48);
  v3 = (char *)zip_write_file_header((uint64_t)a1, *(_QWORD *)(v2 + 96), 3);
  if (v3)
  {
    v4 = v3;
    v5 = operator new();
    *(_OWORD *)v5 = 0u;
    *(_OWORD *)(v5 + 16) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 96) = 0u;
    *(_OWORD *)(v5 + 112) = 0u;
    *(_OWORD *)(v5 + 128) = 0u;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_QWORD *)(v5 + 160) = 0;
    CC_SHA256_Init((CC_SHA256_CTX *)(v5 + 24));
    *(_QWORD *)(v5 + 152) = 0;
    *(_QWORD *)(v5 + 160) = 0;
    *(_QWORD *)(v5 + 8) = *(_QWORD *)a1;
    *(_QWORD *)(v5 + 16) = a1;
    v6 = &v4[*((_QWORD *)a1 + 4)];
    *(_QWORD *)(v5 + 128) = v6;
    *(_QWORD *)(v5 + 136) = v6;
    *(_QWORD *)(v5 + 144) = 0;
    *((_QWORD *)a1 + 5) = 0;
    *((_QWORD *)a1 + 6) = 0;
    v7 = crc32(0, 0, 0);
    v8 = 0;
    *(_DWORD *)(*(_QWORD *)(v5 + 16) + 56) = v7;
    v9 = (unsigned __int16)a1[46];
    if (v9 > 0xD)
    {
      if (v9 == 14)
      {
        v8 = 4;
      }
      else if (v9 == 99)
      {
        v8 = 2;
      }
    }
    else
    {
      if (!a1[46])
      {
LABEL_11:
        *(_QWORD *)(*(_QWORD *)a1 + 48) = *(_QWORD *)(v5 + 136);
        return v5;
      }
      v8 = v9 == 8;
    }
    *(_QWORD *)(v5 + 144) = reality_compression_stream_begin(v8, 0);
    v10 = work_buffer_size;
    *(_QWORD *)(v5 + 160) = work_buffer_size;
    *(_QWORD *)(v5 + 152) = malloc_type_malloc(v10, 0xEC564B16uLL);
    goto LABEL_11;
  }
  return 0;
}

unint64_t zip_entry_save_data_write(Bytef *buf, unint64_t len, uint64_t a3)
{
  unint64_t v3;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  _QWORD v21[4];

  if (*(_DWORD *)a3 != 1)
  {
    v7 = crc32(*(unsigned int *)(*(_QWORD *)(a3 + 16) + 56), buf, len);
    v8 = *(_QWORD *)(a3 + 16);
    *(_DWORD *)(v8 + 56) = v7;
    *(_QWORD *)(v8 + 40) += len;
    CC_SHA256_Update((CC_SHA256_CTX *)(a3 + 24), buf, len);
    if (!*(_QWORD *)(a3 + 144))
    {
      (*(void (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a3 + 8) + 8))(**(_QWORD **)(a3 + 8), *(_QWORD *)(a3 + 136), 0);
      v16 = *(_QWORD *)(a3 + 8);
      v3 = (*(uint64_t (**)(_QWORD, Bytef *, unint64_t))(v16 + 24))(*(_QWORD *)v16, buf, len);
      *(_QWORD *)(v16 + 112) += v3;
      *(_QWORD *)(a3 + 136) += v3;
      return v3;
    }
    if (len)
    {
      v3 = 0;
      while (1)
      {
        v21[0] = &buf[v3];
        v21[1] = len - v3;
        v9 = *(_QWORD *)(a3 + 160);
        v10 = *(_QWORD *)(a3 + 144);
        v21[2] = *(_QWORD *)(a3 + 152);
        v21[3] = v9;
        v20 = 0;
        v18 = 0u;
        v19 = 0u;
        reality_compression_process_stream_chunk(0, (uint64_t)v21, v10, (uint64_t)&v18);
        if (!(_DWORD)v18)
          break;
        v11 = *(_QWORD *)(a3 + 152);
        v13 = *((_QWORD *)&v18 + 1);
        v12 = v19;
        (*(void (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a3 + 8) + 8))(**(_QWORD **)(a3 + 8), *(_QWORD *)(a3 + 136), 0);
        v14 = *(_QWORD *)(a3 + 8);
        v15 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(v14 + 24))(*(_QWORD *)v14, v11, v12);
        *(_QWORD *)(v14 + 112) += v15;
        *(_QWORD *)(a3 + 136) += v15;
        if (v15 != (_QWORD)v19)
          return 0;
        v3 += v13;
        if (v3 >= len)
          return v3;
      }
      *(_DWORD *)a3 = 1;
    }
  }
  return 0;
}

uint64_t zip_entry_save_data_end(uint64_t a1)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD v14[4];
  unsigned __int8 md[16];
  __int128 v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)a1 == 1)
  {
LABEL_2:
    free(*(void **)(a1 + 152));
    MEMORY[0x2276933B8](a1, 0x10A0C40AB5B8B32);
    return 0;
  }
  if (*(_QWORD *)(a1 + 144))
  {
    while (1)
    {
      v14[0] = 0;
      v14[1] = 0;
      v3 = *(_QWORD *)(a1 + 160);
      v4 = *(_QWORD *)(a1 + 144);
      v14[2] = *(_QWORD *)(a1 + 152);
      v14[3] = v3;
      v17 = 0;
      *(_OWORD *)md = 0u;
      v16 = 0u;
      reality_compression_process_stream_chunk(1, (uint64_t)v14, v4, (uint64_t)md);
      if (!*(_DWORD *)md)
        break;
      v5 = *(_QWORD *)(a1 + 152);
      v6 = v16;
      (*(void (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 8) + 8))(**(_QWORD **)(a1 + 8), *(_QWORD *)(a1 + 136), 0);
      v7 = *(_QWORD *)(a1 + 8);
      v8 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(v7 + 24))(*(_QWORD *)v7, v5, v6);
      *(_QWORD *)(v7 + 112) += v8;
      *(_QWORD *)(a1 + 136) += v8;
      if (v8 != (_QWORD)v16)
        break;
      if (*(_DWORD *)md != 2)
        reality_compression_stream_end(*(compression_stream ***)(a1 + 144));
    }
    goto LABEL_2;
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48) = *(_QWORD *)(a1 + 136) - *(_QWORD *)(a1 + 128);
  CC_SHA256_Final(md, (CC_SHA256_CTX *)(a1 + 24));
  v9 = *(_QWORD *)(a1 + 16);
  v10 = *(_OWORD *)md;
  *(_OWORD *)(v9 + 76) = v16;
  *(_OWORD *)(v9 + 60) = v10;
  v11 = *(_QWORD *)(a1 + 16);
  v12 = (_QWORD *)(v11 + 8);
  if ((*(char *)(v11 + 31) & 0x80000000) == 0)
  {
    v13 = *(unsigned __int8 *)(v11 + 31);
    if (!*(_BYTE *)(v11 + 31))
      goto LABEL_15;
LABEL_13:
    if (*((_BYTE *)v12 + v13 - 1) == 47)
    {
      *(_OWORD *)(v11 + 76) = 0u;
      *(_OWORD *)(v11 + 60) = 0u;
      v11 = *(_QWORD *)(a1 + 16);
    }
    goto LABEL_15;
  }
  v13 = *(_QWORD *)(v11 + 16);
  if (v13)
  {
    v12 = (_QWORD *)*v12;
    goto LABEL_13;
  }
LABEL_15:
  zip_write_file_header(v11, *(_QWORD *)(*(_QWORD *)(a1 + 8) + 96), 3);
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 48) = *(_QWORD *)(a1 + 136);
  MEMORY[0x2276933B8](a1, 0x10A0C40AB5B8B32);
  return 1;
}

uint64_t zip_entry_save_data(_WORD *a1, Bytef *a2, unint64_t a3)
{
  uint64_t result;
  uint64_t v6;
  unint64_t v7;

  result = zip_entry_save_data_begin(a1);
  if (result)
  {
    v6 = result;
    v7 = zip_entry_save_data_write(a2, a3, result);
    LODWORD(result) = zip_entry_save_data_end(v6);
    if (v7 == a3)
      return result;
    else
      return 0;
  }
  return result;
}

id *re::internal::EngineQueueCheck::init(void *key, dispatch_queue_t *a2)
{
  dispatch_queue_set_specific(*a2, key, key, 0);
  return re::ObjCObject::operator=((id *)key, (id *)a2);
}

void **re::internal::EngineQueueCheck::deinit(dispatch_queue_t *this)
{
  dispatch_queue_set_specific(*this, this, 0, 0);
  return re::ObjCObject::operator=((void **)this, 0);
}

uint64_t *re::allocInfo_FrameworkLoadDescriptorParameters(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_37);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_37))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FB5E8, 0);
    *(uint64_t *)((char *)&qword_2540FB5F8 + 6) = 0;
    qword_2540FB5F8 = 0;
    qword_2540FB608 = 0;
    qword_2540FB610 = 0xFFFFFFFFLL;
    qword_2540FB5E8 = (uint64_t)&off_24ED7DAA8;
    qword_2540FB618 = (uint64_t)"FrameworkLoadDescriptorParameters";
    dword_2540FB620 = 0;
    xmmword_2540FB628 = 0u;
    unk_2540FB638 = 0u;
    xmmword_2540FB648 = 0u;
    qword_2540FB658 = 0;
    __cxa_guard_release(&_MergedGlobals_37);
  }
  return &qword_2540FB5E8;
}

void re::initInfo_FrameworkLoadDescriptorParameters(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  uint64_t *v10;
  const re::IntrospectionBase *v11;
  void *v12;
  uint64_t v13;
  __int128 v14;
  _QWORD v15[2];
  __int128 v16;

  v15[0] = 0x1FF348E7C469717ALL;
  v15[1] = "FrameworkLoadDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v15);
  *((_OWORD *)this + 2) = v16;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FB5D0);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FB5D0);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<re::DynamicString>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "framework";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FB5D8 = v9;
      v10 = re::introspectionAllocator((re *)v9);
      v12 = re::IntrospectionInfo<re::DynamicString>::get(1, v11);
      v13 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v10 + 32))(v10, 72, 8);
      *(_DWORD *)v13 = 1;
      *(_QWORD *)(v13 + 8) = "resource";
      *(_QWORD *)(v13 + 16) = v12;
      *(_QWORD *)(v13 + 24) = 0;
      *(_QWORD *)(v13 + 32) = 0x2000000002;
      *(_DWORD *)(v13 + 40) = 0;
      *(_QWORD *)(v13 + 48) = 0;
      *(_QWORD *)(v13 + 56) = 0;
      *(_DWORD *)(v13 + 64) = 0;
      qword_2540FB5E0 = v13;
      __cxa_guard_release(&qword_2540FB5D0);
    }
  }
  *((_QWORD *)this + 2) = 0x4000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 2;
  *((_QWORD *)this + 8) = &qword_2540FB5D8;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::FrameworkLoadDescriptorParameters>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::FrameworkLoadDescriptorParameters>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::FrameworkLoadDescriptorParameters>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::FrameworkLoadDescriptorParameters>;
  re::IntrospectionRegistry::add(this, v3);
  v14 = v16;
}

_QWORD *re::internal::defaultConstruct<re::FrameworkLoadDescriptorParameters>(_anonymous_namespace_ *a1, uint64_t a2, _OWORD *a3)
{
  _OWORD *v3;
  _anonymous_namespace_ *v4;

  v3 = a3;
  *a3 = 0u;
  a3[1] = 0u;
  v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v3, 0);
  v3[2] = 0u;
  v3[3] = 0u;
  v3 += 2;
  return re::DynamicString::setCapacity(v3, 0);
}

double re::internal::defaultDestruct<re::FrameworkLoadDescriptorParameters>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  _OWORD *v5;
  double result;

  v5 = a3 + 4;
  v4 = a3[4];
  if (v4)
  {
    if ((a3[5] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, a3[6]);
    result = 0.0;
    *v5 = 0u;
    v5[1] = 0u;
  }
  if (*a3)
  {
    if ((a3[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a3 + 40))(*a3, a3[2]);
    result = 0.0;
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
  }
  return result;
}

_QWORD *re::internal::defaultConstructV2<re::FrameworkLoadDescriptorParameters>(_anonymous_namespace_ *a1)
{
  _anonymous_namespace_ *v1;
  _anonymous_namespace_ *v2;

  v1 = a1;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  v2 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v1, 0);
  *((_OWORD *)v1 + 2) = 0u;
  *((_OWORD *)v1 + 3) = 0u;
  v1 = (_anonymous_namespace_ *)((char *)v1 + 32);
  return re::DynamicString::setCapacity(v1, 0);
}

double re::internal::defaultDestructV2<re::FrameworkLoadDescriptorParameters>(_QWORD *a1)
{
  uint64_t v2;
  _OWORD *v3;
  double result;

  v3 = a1 + 4;
  v2 = a1[4];
  if (v2)
  {
    if ((a1[5] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, a1[6]);
    result = 0.0;
    *v3 = 0u;
    v3[1] = 0u;
  }
  if (*a1)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

_anonymous_namespace_ *re::FrameworkAssetProvider::FrameworkAssetProvider(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned __int8 v10;
  __guard *v11;
  int v13;

  ArcSharedObject::ArcSharedObject(a1, 0);
  *(_QWORD *)a1 = &off_24ED2C0B0;
  *((_QWORD *)a1 + 3) = 0;
  *((_QWORD *)a1 + 4) = 0;
  *((_QWORD *)a1 + 5) = 0;
  if ((v10 & 1) == 0)
  {
    if (v13)
    {
      re::introspect<re::FrameworkLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"FrameworkLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_FrameworkLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_FrameworkLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::FrameworkLoadDescriptorParameters>, 0);
    }
  }
  re::FrameworkAssetProvider::s_loadDescriptorParametersIntrospect = v11[37];
  *((_QWORD *)a1 + 3) = a3;
  *((_QWORD *)a1 + 4) = a4;
  *((_QWORD *)a1 + 5) = a2;
  *((_QWORD *)a1 + 6) = a5;
  return a1;
}

void re::FrameworkAssetProvider::~FrameworkAssetProvider(re::FrameworkAssetProvider *this)
{
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::FrameworkAssetProvider::makeDescriptor@<X0>(_anonymous_namespace_ *a1@<X0>, re::DynamicString *a2@<X1>, re::DynamicString *a3@<X2>, uint64_t a4@<X8>)
{
  _anonymous_namespace_ *v8;
  _anonymous_namespace_ *v9;
  _anonymous_namespace_ *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  _OWORD v18[2];
  _QWORD v19[4];
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;

  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  *(_QWORD *)(a4 + 24) = 0;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a4, 0);
  *(_QWORD *)(a4 + 32) = 0;
  *(_QWORD *)(a4 + 40) = 0;
  *(_DWORD *)(a4 + 56) = 0;
  *(_QWORD *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 64) = 0u;
  *(_OWORD *)(a4 + 80) = 0u;
  *(_DWORD *)(a4 + 96) = 0;
  *(_OWORD *)(a4 + 104) = 0u;
  *(_OWORD *)(a4 + 120) = 0u;
  *(_QWORD *)(a4 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a4 + 112), 0);
  v20 = (uint64_t *)"Framework";
  v21 = 9;
  re::DynamicString::operator=((re::DynamicString *)a4, (uint64_t)&v20);
  v9 = re::DynamicString::operator=((re::DynamicString *)(a4 + 112), a3);
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v10 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v20, 0);
  *((_QWORD *)&v24 + 1) = 0;
  v25 = 0uLL;
  re::DynamicString::setCapacity(&v24, 0);
  re::DynamicString::operator=((re::DynamicString *)&v20, a1);
  re::DynamicString::operator=((re::DynamicString *)&v24, a2);
  re::DynamicString::DynamicString((re::DynamicString *)v18, (const re::DynamicString *)&v20);
  re::DynamicString::DynamicString((re::DynamicString *)v19, (const re::DynamicString *)&v24);
  re::AssetLoadDescriptor::setIntrospectableData((char **)a4, (const re::IntrospectionBase *)re::FrameworkAssetProvider::s_loadDescriptorParametersIntrospect, (const re::IntrospectionBase **)v18, 0);
  if (v19[0])
  {
    if ((v19[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v19[0] + 40))();
    memset(v19, 0, sizeof(v19));
  }
  if (*(_QWORD *)&v18[0])
  {
    if ((BYTE8(v18[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v18[0] + 40))();
    memset(v18, 0, sizeof(v18));
  }
  if ((_QWORD)v24)
  {
    if ((BYTE8(v24) & 1) != 0)
      (*(void (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v24 + 40))(v24, v25, v11, v12, v13, v14, v15, v16);
    v24 = 0u;
    v25 = 0u;
  }
  result = (uint64_t)v20;
  if (v20)
  {
    if ((v21 & 1) != 0)
      return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*v20 + 40))(v20, v22, v11, v12, v13, v14, v15, v16);
  }
  return result;
}

uint64_t re::FrameworkAssetProvider::recoverAssetPath(re::FrameworkAssetProvider *this, const re::AssetLoadDescriptor *a2, int a3)
{
  const char *v6;
  uint64_t result;
  _anonymous_namespace_ *v8;
  const char *v9;
  char *v10;
  uint64_t v11;
  char *v12;
  char *v13;
  const char *v14;
  char *v15;
  char *v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;

  if ((*((_QWORD *)a2 + 1) & 1) != 0)
    v6 = (const char *)*((_QWORD *)a2 + 2);
  else
    v6 = (char *)a2 + 9;
  result = strcmp(v6, "Framework");
  if ((_DWORD)result)
  {
LABEL_5:
    *(_BYTE *)this = 0;
    return result;
  }
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v20, 0);
  *((_QWORD *)&v24 + 1) = 0;
  v25 = 0uLL;
  re::DynamicString::setCapacity(&v24, 0);
  if (!re::AssetLoadDescriptor::getIntrospectableData<re::FrameworkLoadDescriptorParameters>(a2, &v20, 0))goto LABEL_38;
  v10 = v22;
  v11 = v21 & 1;
  if ((v21 & 1) != 0)
    v12 = v22;
  else
    v12 = (char *)&v21 + 1;
  if (!re::isEngineFrameworkIdentifier((re *)v12, v9))
  {
    if (!a3)
      goto LABEL_24;
    if (!strcmp(v12, "com.apple.SystemEnvironments"))
    {
      re::Defaults::BOOLValue((re::Defaults *)"allowAssetReferencesToSysEnvFramework", v14, (char *)&v17);
      if ((_BYTE)v17 && BYTE1(v17))
      {
        v10 = v22;
        v11 = v21 & 1;
        goto LABEL_24;
      }
    }
    else if (!strcmp(v12, "com.apple.vfx") || !strcmp(v12, "com.apple.VFXAssets"))
    {
LABEL_24:
      if (v11)
        v15 = v10;
      else
        v15 = (char *)&v21 + 1;
      if ((BYTE8(v24) & 1) != 0)
        v16 = (char *)v25;
      else
        v16 = (char *)&v24 + 9;
      re::DynamicString::format((re::DynamicString *)"framework:%s/%s", (re::DynamicString *)&v17, v15, v16);
      goto LABEL_31;
    }
LABEL_38:
    if ((_QWORD)v24)
    {
      if ((BYTE8(v24) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v24 + 40))();
      v24 = 0u;
      v25 = 0u;
    }
    result = (uint64_t)v20;
    if (v20 && (v21 & 1) != 0)
      result = (*(uint64_t (**)(void))(*v20 + 40))();
    goto LABEL_5;
  }
  if ((BYTE8(v24) & 1) != 0)
    v13 = (char *)v25;
  else
    v13 = (char *)&v24 + 9;
  re::DynamicString::format((re::DynamicString *)"engine:%s", (re::DynamicString *)&v17, v13);
LABEL_31:
  *(_BYTE *)this = 1;
  *((_QWORD *)this + 1) = v17;
  *((_QWORD *)this + 4) = v19;
  *((_OWORD *)this + 1) = v18;
  if ((_QWORD)v24)
  {
    if ((BYTE8(v24) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v24 + 40))();
    v24 = 0u;
    v25 = 0u;
  }
  result = (uint64_t)v20;
  if (v20)
  {
    if ((v21 & 1) != 0)
      return (*(uint64_t (**)(void))(*v20 + 40))();
  }
  return result;
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<re::FrameworkLoadDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2, re::Allocator *a3)
{
  uint64_t **v4;
  unsigned __int8 v5;
  __guard *v6;
  int v8;
  int v9;
  re::Allocator *v11;
  re::AssetLoadDescriptor *v12;

  v4 = a2;
  if ((v5 & 1) == 0)
  {
    v12 = a1;
    v11 = a3;
    v4 = a2;
    a3 = v11;
    v9 = v8;
    a1 = v12;
    if (v9)
    {
      re::introspect<re::FrameworkLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"FrameworkLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_FrameworkLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_FrameworkLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::FrameworkLoadDescriptorParameters>, 0);
      a1 = v12;
      v4 = a2;
      a3 = v11;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)v6[37], v4, a3);
}

uint64_t re::FrameworkAssetProvider::isEngineAssetDescriptor(re::FrameworkAssetProvider *this, const re::AssetLoadDescriptor *a2)
{
  const char *v3;
  _anonymous_namespace_ *v4;
  _anonymous_namespace_ *v6;
  const char *v7;
  re *v8;
  uint64_t *v9;
  uint64_t v10;
  re *v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;

  if ((*((_QWORD *)this + 1) & 1) != 0)
    v3 = (const char *)*((_QWORD *)this + 2);
  else
    v3 = (char *)this + 9;
  v4 = (_anonymous_namespace_ *)strcmp(v3, "Framework");
  if ((_DWORD)v4)
    return 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v9, 0);
  *((_QWORD *)&v13 + 1) = 0;
  v14 = 0uLL;
  re::DynamicString::setCapacity(&v13, 0);
  if (!re::AssetLoadDescriptor::getIntrospectableData<re::FrameworkLoadDescriptorParameters>(this, &v9, 0)|| ((v10 & 1) != 0 ? (v8 = v11) : (v8 = (re *)((char *)&v10 + 1)), !re::isEngineFrameworkIdentifier(v8, v7)))
  {
    if ((_QWORD)v13)
    {
      if ((BYTE8(v13) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v13 + 40))();
      v13 = 0u;
      v14 = 0u;
    }
    if (v9 && (v10 & 1) != 0)
      (*(void (**)(void))(*v9 + 40))();
    return 0;
  }
  if ((_QWORD)v13)
  {
    if ((BYTE8(v13) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v13 + 40))();
    v13 = 0u;
    v14 = 0u;
  }
  if (v9)
  {
    if ((v10 & 1) != 0)
      (*(void (**)(void))(*v9 + 40))();
  }
  return 1;
}

re::DynamicString *re::FrameworkAssetProvider::load@<X0>(re::internal::AssetTypeRegistry **this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  const char *v9;
  _anonymous_namespace_ *v10;
  const char *v11;
  re::DynamicString *result;
  __int128 v13;
  re *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  _anonymous_namespace_ *v18;
  unint64_t v19;
  _anonymous_namespace_ *v20;
  uint64_t Descriptor;
  os_unfair_lock_s *v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  uint64_t v26;
  re::path *v27;
  const char *v28;
  size_t v29;
  const char *v30;
  const char *v31;
  BOOL v32;
  const char *v33;
  _BOOL8 v34;
  re *v35;
  _BOOL8 isEngineFrameworkIdentifier;
  _anonymous_namespace_ *LocalCompiledOrSourceAsset;
  char v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  const char *v43;
  __int128 v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  __int128 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  os_unfair_lock_s *v54;
  void *v55;
  id v56;
  uint64_t v57;
  __int128 v58;
  uint64_t v59;
  _BYTE v60[24];
  uint64_t v61;
  __int128 v62;
  char v63;
  char v64[16];
  char v65[8];
  uint64_t v66;
  char v67;
  uint64_t v68;
  __int128 v69;
  __int128 v70;
  _QWORD v71[4];
  _QWORD v72[5];
  id v73;
  __int128 v74;
  re *v75;
  uint64_t v76;
  __int128 v77;
  __int128 v78;

  if ((*((_BYTE *)a2 + 8) & 1) != 0)
    v9 = (const char *)*((_QWORD *)a2 + 2);
  else
    v9 = (char *)a2 + 9;
  v10 = (_anonymous_namespace_ *)strcmp(v9, "Framework");
  if ((_DWORD)v10)
  {
    v11 = "FrameworkAssetProvider called with invalid scheme name.";
LABEL_6:
    v13 = v74;
    v14 = v75;
    v15 = v76;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v13;
    *(_QWORD *)(a4 + 24) = v14;
    *(_QWORD *)(a4 + 32) = v15;
    return result;
  }
  v16 = (char *)(this + 3);
  if ((*((_BYTE *)a2 + 120) & 1) != 0)
    v17 = (char *)*((_QWORD *)a2 + 16);
  else
    v17 = (char *)a2 + 121;
  v18 = (_anonymous_namespace_ *)re::internal::AssetTypeRegistry::assetTypeWithName(this[3], v17);
  if (!v18)
  {
    v11 = "Unknown asset type";
    goto LABEL_6;
  }
  v19 = (unint64_t)v18;
  *((_QWORD *)&v74 + 1) = 0;
  v75 = 0;
  v76 = 0;
  v20 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v74, 0);
  *((_QWORD *)&v77 + 1) = 0;
  v78 = 0uLL;
  re::DynamicString::setCapacity(&v77, 0);
  Descriptor = re::AssetLoadDescriptor::getIntrospectableData<re::FrameworkLoadDescriptorParameters>(a2, (uint64_t **)&v74, 0);
  if ((Descriptor & 1) != 0)
  {
    v22 = (os_unfair_lock_s *)this[6];
    re::DynamicString::DynamicString((re::DynamicString *)v72, (const re::DynamicString *)&v74);
    re::BundleFilePathRegistry::findWithBundleID(v22, (uint64_t)v72, &v73);
    v23 = v72[0];
    if (v72[0])
    {
      if ((v72[1] & 1) != 0)
        v23 = (*(uint64_t (**)(void))(*(_QWORD *)v72[0] + 40))();
      memset(v72, 0, 32);
    }
    if (!v73)
    {
      v43 = (BYTE8(v74) & 1) != 0 ? (const char *)v75 : (char *)&v74 + 9;
      v23 = strcmp(v43, "com.apple.vfx");
      if ((_DWORD)v23)
        goto LABEL_48;
      v54 = (os_unfair_lock_s *)this[6];
      re::BundleFilePathRegistry::findWithBundleID(v54, (uint64_t)v71, (id *)v60);
      v55 = *(void **)v60;
      *(_QWORD *)v60 = 0;
      v56 = v73;
      v73 = v55;

      v23 = v71[0];
      if (v71[0])
      {
        if ((v71[1] & 1) != 0)
          v23 = (*(uint64_t (**)(void))(*(_QWORD *)v71[0] + 40))();
        memset(v71, 0, sizeof(v71));
      }
      if (!v73)
      {
LABEL_48:
        re::DynamicString::operator+((re::DynamicString *)&v57, (uint64_t)&v74, (re::DynamicString *)v60);
        v44 = *(_OWORD *)v60;
        memset(v60, 0, sizeof(v60));
        v45 = *(_QWORD *)&v60[16];
        v46 = v61;
        v61 = 0;
        *(_BYTE *)a4 = 0;
        *(_OWORD *)(a4 + 8) = v44;
        *(_QWORD *)(a4 + 24) = v45;
        *(_QWORD *)(a4 + 32) = v46;
        v47 = v57;
        if (!v57 || (v58 & 1) == 0)
          goto LABEL_64;
        v48 = *((_QWORD *)&v58 + 1);
        goto LABEL_63;
      }
    }
    v69 = 0u;
    v70 = 0u;
    re::DynamicString::setCapacity(&v69, 0);
    v25 = (const char *)v78;
    v26 = BYTE8(v77) & 1;
    if ((BYTE8(v77) & 1) != 0)
      v27 = (re::path *)v78;
    else
      v27 = (re::path *)((char *)&v77 + 9);
    v28 = (const char *)re::path::ext(v27, v24);
    if (strlen(v28) >= 2 && *(const char **)(v19 + 8) != v28 + 1)
    {
      re::DynamicString::DynamicString((re::DynamicString *)v60, (const re::DynamicString *)&v77);
      re::DynamicString::append((re::DynamicString *)v60, ".", 1uLL);
      v29 = strlen(*(const char **)(v19 + 8));
      re::DynamicString::append((re::DynamicString *)v60, *(const char **)(v19 + 8), v29);
      if ((v60[8] & 1) != 0)
        v30 = *(const char **)&v60[16];
      else
        v30 = &v60[9];
      v32 = re::Bundle::pathForResource(&v73, v30, (re::DynamicString *)&v69);
      if (*(_QWORD *)v60 && (v60[8] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)v60 + 40))();
      if (v32)
        goto LABEL_35;
      v25 = (const char *)v78;
      v26 = BYTE8(v77) & 1;
    }
    if (v26)
      v33 = v25;
    else
      v33 = (char *)&v77 + 9;
    v34 = re::Bundle::pathForResource(&v73, v33, (re::DynamicString *)&v69);
    if (!v34)
    {
      re::DynamicString::operator+((re::DynamicString *)&v57, (uint64_t)&v77, (re::DynamicString *)v60);
      v49 = *(_OWORD *)v60;
      memset(v60, 0, sizeof(v60));
      v50 = *(_QWORD *)&v60[16];
      v51 = v61;
      v61 = 0;
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(a4 + 8) = v49;
      *(_QWORD *)(a4 + 24) = v50;
      *(_QWORD *)(a4 + 32) = v51;
      v52 = v57;
      if (!v57 || (v58 & 1) == 0)
        goto LABEL_60;
      v53 = *((_QWORD *)&v58 + 1);
LABEL_59:
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v52 + 40))(v52, v53);
LABEL_60:
      v47 = v69;
      if (!(_QWORD)v69 || (BYTE8(v69) & 1) == 0)
        goto LABEL_64;
      v48 = v70;
LABEL_63:
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v47 + 40))(v47, v48);
LABEL_64:

      goto LABEL_65;
    }
LABEL_35:
    if ((BYTE8(v74) & 1) != 0)
      v35 = v75;
    else
      v35 = (re *)((char *)&v74 + 9);
    isEngineFrameworkIdentifier = re::isEngineFrameworkIdentifier(v35, v31);
    v64[0] = 0;
    LocalCompiledOrSourceAsset = (_anonymous_namespace_ *)re::AssetUtilities::loadLocalCompiledOrSourceAsset((char *)&v69, (uint64_t)v16, v19, (uint64_t)a3, v64, isEngineFrameworkIdentifier, (uint64_t)v65);
    if (v65[0])
    {
      *(_QWORD *)&v60[8] = 0;
      *(_QWORD *)&v60[16] = 0;
      v61 = 0;
      re::DynamicString::setCapacity(v60, 0);
      BYTE8(v62) = 0;
      v63 = 0;
      *(_QWORD *)&v62 = v66;
      re::DynamicString::operator=((re::DynamicString *)v60, (const re::AssetLoadDescriptor *)((char *)a2 + 112));
      re::DynamicString::DynamicString((re::DynamicString *)&v57, (const re::DynamicString *)v60);
      v38 = v63;
      v39 = v62;
      *(_BYTE *)a4 = 1;
      *(_QWORD *)(a4 + 8) = v57;
      *(_QWORD *)(a4 + 32) = v59;
      *(_OWORD *)(a4 + 16) = v58;
      *(_OWORD *)(a4 + 40) = v39;
      *(_BYTE *)(a4 + 56) = v38;
      if (*(_QWORD *)v60 && (v60[8] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)v60 + 40))();
    }
    else
    {
      re::DynamicString::DynamicString((re::DynamicString *)v60, (const re::DynamicString *)&v66);
      *(_BYTE *)a4 = 0;
      *(_QWORD *)(a4 + 8) = *(_QWORD *)v60;
      *(_QWORD *)(a4 + 32) = v61;
      *(_OWORD *)(a4 + 16) = *(_OWORD *)&v60[8];
    }
    if (v65[0])
      goto LABEL_60;
    v52 = v66;
    if (!v66 || (v67 & 1) == 0)
      goto LABEL_60;
    v53 = v68;
    goto LABEL_59;
  }
  v40 = *(_OWORD *)v60;
  v41 = *(_QWORD *)&v60[16];
  v42 = v61;
  *(_BYTE *)a4 = 0;
  *(_OWORD *)(a4 + 8) = v40;
  *(_QWORD *)(a4 + 24) = v41;
  *(_QWORD *)(a4 + 32) = v42;
LABEL_65:
  if ((_QWORD)v77)
  {
    if ((BYTE8(v77) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v77 + 40))();
    v77 = 0u;
    v78 = 0u;
  }
  result = (re::DynamicString *)v74;
  if ((_QWORD)v74)
  {
    if ((BYTE8(v74) & 1) != 0)
      return (re::DynamicString *)(*(uint64_t (**)(void))(*(_QWORD *)v74 + 40))();
  }
  return result;
}

uint64_t *re::FrameworkAssetProvider::resolveChild@<X0>(const re::AssetLoadDescriptor *a1@<X1>, re::AssetProvider *a2@<X2>, const char *a3@<X3>, uint64_t a4@<X8>)
{
  const char *v9;
  _anonymous_namespace_ *v10;
  uint64_t *result;
  __int128 v12;
  __int128 v13;
  _anonymous_namespace_ *v14;
  uint64_t v15;
  re::PathBuffer *v16;
  _anonymous_namespace_ *v17;
  uint64_t v18;
  __n128 v19;
  uint64_t v20;
  uint64_t v21;
  _OWORD v22[2];
  _BYTE v23[40];
  __int128 v24;
  int v25;
  __int128 v26;
  __int128 v27;
  int v28;
  _BYTE v29[24];
  __int128 v30;
  _BYTE v31[40];
  __int128 v32;
  int v33;
  __int128 v34;
  __int128 v35;
  int v36;
  _BYTE v37[24];
  __int128 v38;
  uint64_t v39;
  char v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  __int128 v46;

  if ((*((_BYTE *)a1 + 8) & 1) != 0)
    v9 = (const char *)*((_QWORD *)a1 + 2);
  else
    v9 = (char *)a1 + 9;
  v10 = (_anonymous_namespace_ *)strcmp(v9, "Framework");
  if ((_DWORD)v10)
  {
    result = (uint64_t *)re::DynamicString::format((re::DynamicString *)"Scheme %s does not match scheme %s.", (re::DynamicString *)v31, v9, "Framework");
    v12 = *(_OWORD *)v31;
    v13 = *(_OWORD *)&v31[16];
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v12;
    *(_OWORD *)(a4 + 24) = v13;
  }
  else
  {
    v42 = 0;
    v43 = 0;
    v44 = 0;
    v14 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v41, 0);
    *((_QWORD *)&v45 + 1) = 0;
    v46 = 0uLL;
    re::DynamicString::setCapacity(&v45, 0);
    v15 = re::AssetLoadDescriptor::getIntrospectableData<re::FrameworkLoadDescriptorParameters>(a1, &v41, 0);
    if ((v15 & 1) != 0)
    {
      if ((BYTE8(v45) & 1) != 0)
        v16 = (re::PathBuffer *)v46;
      else
        v16 = (re::PathBuffer *)((char *)&v45 + 9);
      v17 = (_anonymous_namespace_ *)re::AssetProvider::resolveChildPath(a2, v16, &v39);
      re::FrameworkAssetProvider::makeDescriptor((_anonymous_namespace_ *)&v41, (re::DynamicString *)&v39, (re::DynamicString *)v22, (uint64_t)v23);
      v18 = *(_QWORD *)v23;
      memset(v23, 0, sizeof(v23));
      *(_QWORD *)v31 = v18;
      *(_OWORD *)&v31[24] = *(_OWORD *)&v23[24];
      *(_OWORD *)&v31[8] = *(_OWORD *)&v23[8];
      v32 = v24;
      v24 = 0u;
      ++v25;
      v33 = 1;
      v34 = v26;
      v35 = v27;
      v26 = 0u;
      v27 = 0u;
      ++v28;
      v36 = 1;
      *(_OWORD *)v37 = *(_OWORD *)v29;
      memset(v29, 0, sizeof(v29));
      v38 = v30;
      *(_QWORD *)&v37[16] = *(_QWORD *)&v29[16];
      v30 = 0uLL;
      v19.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional(a4, (uint64_t)v31);
      if (*(_QWORD *)&v37[8])
      {
        if ((v37[16] & 1) != 0)
          (*(void (**)(double))(**(_QWORD **)&v37[8] + 40))(v19.n128_f64[0]);
        v19 = 0uLL;
        *(_OWORD *)&v37[8] = 0u;
        v38 = 0u;
      }
      if (*((_QWORD *)&v34 + 1))
      {
        if (*(_QWORD *)v37)
          (*(void (**)(__n128))(**((_QWORD **)&v34 + 1) + 40))(v19);
        *(_QWORD *)v37 = 0;
        v35 = 0uLL;
        *((_QWORD *)&v34 + 1) = 0;
        ++v36;
      }
      if (*(_QWORD *)&v31[32])
      {
        if ((_QWORD)v34)
          (*(void (**)(__n128))(**(_QWORD **)&v31[32] + 40))(v19);
        *(_QWORD *)&v34 = 0;
        v32 = 0uLL;
        *(_QWORD *)&v31[32] = 0;
        ++v33;
      }
      if (*(_QWORD *)v31)
      {
        if ((v31[8] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)v31 + 40))(v19);
        v19 = 0uLL;
        memset(v31, 0, 32);
      }
      if (*(_QWORD *)&v29[8])
      {
        if ((v29[16] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)&v29[8] + 40))(v19);
        v19 = 0uLL;
        *(_OWORD *)&v29[8] = 0u;
        v30 = 0u;
      }
      if (*((_QWORD *)&v26 + 1))
      {
        if (*(_QWORD *)v29)
          (*(void (**)(__n128))(**((_QWORD **)&v26 + 1) + 40))(v19);
        *(_QWORD *)v29 = 0;
        v27 = 0uLL;
        *((_QWORD *)&v26 + 1) = 0;
        ++v28;
      }
      if (*(_QWORD *)&v23[32])
      {
        if ((_QWORD)v26)
          (*(void (**)(__n128))(**(_QWORD **)&v23[32] + 40))(v19);
        *(_QWORD *)&v26 = 0;
        v24 = 0uLL;
        *(_QWORD *)&v23[32] = 0;
        ++v25;
      }
      if (*(_QWORD *)v23)
      {
        if ((v23[8] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)v23 + 40))(v19);
        v19 = 0uLL;
        memset(v23, 0, 32);
      }
      if (*(_QWORD *)&v22[0])
      {
        if ((BYTE8(v22[0]) & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)&v22[0] + 40))(v19);
        v19 = 0uLL;
        memset(v22, 0, sizeof(v22));
      }
      if (v39 && (v40 & 1) != 0)
        (*(void (**)(__n128))(*(_QWORD *)v39 + 40))(v19);
    }
    else
    {
      v19 = *(__n128 *)v31;
      v20 = *(_QWORD *)&v31[16];
      v21 = *(_QWORD *)&v31[24];
      *(_BYTE *)a4 = 0;
      *(__n128 *)(a4 + 8) = v19;
      *(_QWORD *)(a4 + 24) = v20;
      *(_QWORD *)(a4 + 32) = v21;
    }
    if ((_QWORD)v45)
    {
      if ((BYTE8(v45) & 1) != 0)
        (*(void (**)(__n128))(*(_QWORD *)v45 + 40))(v19);
      v19 = 0uLL;
      v45 = 0u;
      v46 = 0u;
    }
    result = v41;
    if (v41)
    {
      if ((v42 & 1) != 0)
        return (uint64_t *)(*(uint64_t (**)(__n128))(*v41 + 40))(v19);
    }
  }
  return result;
}

uint64_t *re::FrameworkAssetProvider::getDescription(re::FrameworkAssetProvider *this, const re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  _anonymous_namespace_ *v5;
  re::DynamicString *v6;
  const char *v7;
  size_t v8;
  uint64_t *result;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  _QWORD v16[2];

  v11 = 0;
  v12 = 0;
  v13 = 0;
  v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v10, 0);
  *((_QWORD *)&v14 + 1) = 0;
  v15 = 0uLL;
  re::DynamicString::setCapacity(&v14, 0);
  if (re::AssetLoadDescriptor::getIntrospectableData<re::FrameworkLoadDescriptorParameters>(a2, &v10, 0))
  {
    v6 = re::DynamicString::operator=(a3, (re::DynamicString *)&v10);
    re::DynamicString::append(v6, "/", 1uLL);
    if ((BYTE8(v14) & 1) != 0)
      v7 = (const char *)v15;
    else
      v7 = (char *)&v14 + 9;
    if ((BYTE8(v14) & 1) != 0)
      v8 = *((_QWORD *)&v14 + 1) >> 1;
    else
      v8 = BYTE8(v14) >> 1;
    re::DynamicString::append(a3, v7, v8);
  }
  else
  {
    v16[0] = "mangled";
    v16[1] = 7;
    re::DynamicString::operator=(a3, (uint64_t)v16);
  }
  if ((_QWORD)v14)
  {
    if ((BYTE8(v14) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v14 + 40))();
    v14 = 0u;
    v15 = 0u;
  }
  result = v10;
  if (v10)
  {
    if ((v11 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v10 + 40))();
  }
  return result;
}

BOOL re::FrameworkAssetProvider::isDeviceAssetForRelease(uint64_t a1, const re::AssetLoadDescriptor *a2)
{
  int v2;
  _BYTE v4[8];
  uint64_t v5;
  char v6;

  re::FrameworkAssetProvider::recoverAssetPath((re::FrameworkAssetProvider *)v4, a2, 1);
  v2 = v4[0];
  if (v4[0] && v5 && (v6 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v5 + 40))();
  return v2 != 0;
}

__n128 re::FrameworkAssetProvider::getAssetPathForRelease@<Q0>(char *a1@<X1>, re::internal::AssetTypeRegistry *a2@<X2>, unsigned int a3@<W4>, uint64_t a4@<X8>)
{
  _anonymous_namespace_ *v8;
  char *v9;
  uint64_t v10;
  __n128 result;
  uint64_t v12;
  uint64_t v13;
  _BYTE v14[24];
  uint64_t v15;
  _BYTE v16[8];
  uint64_t v17;
  char v18;

  v8 = (_anonymous_namespace_ *)re::FrameworkAssetProvider::recoverAssetPath((re::FrameworkAssetProvider *)v16, (const re::AssetLoadDescriptor *)a1, a3 - 10 < 0xFFFFFFF5);
  if (v16[0])
  {
    if (a3 <= 9)
    {
      if ((*((_QWORD *)a1 + 15) & 1) != 0)
        v9 = (char *)*((_QWORD *)a1 + 16);
      else
        v9 = a1 + 121;
      v10 = re::internal::AssetTypeRegistry::assetTypeWithName(a2, v9);
      re::AssetPath::updateWithCompiledExtension((char *)&v17, v10);
    }
    re::DynamicString::DynamicString((re::DynamicString *)v14, (const re::DynamicString *)&v17);
    *(_BYTE *)a4 = 1;
    *(_QWORD *)(a4 + 8) = *(_QWORD *)v14;
    *(_QWORD *)(a4 + 32) = v15;
    result = *(__n128 *)&v14[8];
    *(_OWORD *)(a4 + 16) = *(_OWORD *)&v14[8];
    if (v16[0] && v17 && (v18 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v17 + 40))();
  }
  else
  {
    result = *(__n128 *)v14;
    v12 = *(_QWORD *)&v14[16];
    v13 = v15;
    *(_BYTE *)a4 = 0;
    *(__n128 *)(a4 + 8) = result;
    *(_QWORD *)(a4 + 24) = v12;
    *(_QWORD *)(a4 + 32) = v13;
  }
  return result;
}

uint64_t re::FrameworkAssetProvider::makeDescriptorFromAssetPath@<X0>(re::FrameworkAssetProvider *this@<X0>, const re::AssetPath *a2@<X1>, uint64_t a3@<X8>)
{
  _anonymous_namespace_ *v4;
  re::DynamicString *v5;
  const char *v6;
  __n128 v7;
  uint64_t result;
  uint64_t v9;
  char v10;
  _OWORD v11[2];
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;

  v4 = (const re::AssetPath *)((char *)a2 + 8);
  v5 = (const re::AssetPath *)((char *)a2 + 40);
  v6 = (const char *)**((_QWORD **)a2 + 9);
  re::FrameworkAssetProvider::makeDescriptor(v4, v5, (re::DynamicString *)&v9, (uint64_t)v11);
  v7.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional(a3, (uint64_t)v11);
  if ((_QWORD)v22)
  {
    if ((BYTE8(v22) & 1) != 0)
      (*(void (**)(double))(*(_QWORD *)v22 + 40))(v7.n128_f64[0]);
    v7 = 0uLL;
    v22 = 0u;
    v23 = 0u;
  }
  if (v17)
  {
    if (v21)
      (*(void (**)(__n128))(*(_QWORD *)v17 + 40))(v7);
    v21 = 0;
    v18 = 0;
    v19 = 0;
    v17 = 0;
    ++v20;
  }
  if (v12)
  {
    if (v16)
      (*(void (**)(__n128))(*(_QWORD *)v12 + 40))(v7);
    v16 = 0;
    v13 = 0;
    v14 = 0;
    v12 = 0;
    ++v15;
  }
  if (*(_QWORD *)&v11[0])
  {
    if ((BYTE8(v11[0]) & 1) != 0)
      (*(void (**)(__n128))(**(_QWORD **)&v11[0] + 40))(v7);
    v7 = 0uLL;
    memset(v11, 0, sizeof(v11));
  }
  result = v9;
  if (v9)
  {
    if ((v10 & 1) != 0)
      return (*(uint64_t (**)(__n128))(*(_QWORD *)v9 + 40))(v7);
  }
  return result;
}

const char *re::FrameworkAssetProvider::schemeName(re::FrameworkAssetProvider *this)
{
  return "Framework";
}

double zip_file_create(const char *a1)
{
  FILE *v1;
  double result;
  FILE *v3;
  uint64_t v4;

  v1 = fopen(a1, "wb+");
  if (v1)
  {
    v3 = v1;
    v4 = operator new();
    result = 0.0;
    *(_OWORD *)(v4 + 48) = 0u;
    *(_OWORD *)(v4 + 64) = 0u;
    *(_OWORD *)(v4 + 80) = 0u;
    *(int64x2_t *)(v4 + 96) = vdupq_n_s64(1uLL);
    *(_QWORD *)(v4 + 120) = 0;
    *(_QWORD *)(v4 + 128) = 0;
    *(_QWORD *)(v4 + 112) = 0;
    *(_WORD *)(v4 + 136) = 768;
    *(_OWORD *)(v4 + 144) = 0u;
    *(_OWORD *)(v4 + 160) = 0u;
    *(_OWORD *)(v4 + 176) = 0u;
    *(_DWORD *)(v4 + 192) = 0;
    *(_QWORD *)v4 = v3;
    *(_QWORD *)(v4 + 8) = file_seek;
    *(_QWORD *)(v4 + 16) = file_read;
    *(_QWORD *)(v4 + 24) = file_write;
    *(_QWORD *)(v4 + 32) = file_close;
    *(_QWORD *)(v4 + 40) = file_swap;
  }
  return result;
}

uint64_t zip_file_open(const char *a1)
{
  FILE *v1;
  FILE *v2;
  uint64_t v3;

  v1 = fopen(a1, "rb");
  if (!v1)
    return 0;
  v2 = v1;
  v3 = operator new();
  *(_OWORD *)(v3 + 48) = 0u;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  *(int64x2_t *)(v3 + 96) = vdupq_n_s64(1uLL);
  *(_QWORD *)(v3 + 120) = 0;
  *(_QWORD *)(v3 + 128) = 0;
  *(_QWORD *)(v3 + 112) = 0;
  *(_WORD *)(v3 + 136) = 768;
  *(_OWORD *)(v3 + 144) = 0u;
  *(_OWORD *)(v3 + 160) = 0u;
  *(_OWORD *)(v3 + 176) = 0u;
  *(_DWORD *)(v3 + 192) = 0;
  *(_QWORD *)v3 = v2;
  *(_QWORD *)(v3 + 8) = file_seek;
  *(_QWORD *)(v3 + 16) = file_read;
  *(_QWORD *)(v3 + 24) = file_write;
  *(_QWORD *)(v3 + 32) = file_close;
  *(_QWORD *)(v3 + 40) = file_swap;
  if (!zip_load_all_from_central_directory((_QWORD *)v3))
  {
    while (zip_load_entry_from_file_header((_QWORD *)v3))
      ;
  }
  return v3;
}

uint64_t zip_file_read(FILE *__stream)
{
  uint64_t v2;
  __int16 __ptr;

  if (!__stream)
    return 0;
  __ptr = 0;
  if (fread(&__ptr, 1uLL, 2uLL, __stream) != 2)
    return 0;
  fseek(__stream, 0, 0);
  if (__ptr == 80 || (v2 = 0, HIBYTE(__ptr) == 75))
  {
    v2 = operator new();
    *(_OWORD *)(v2 + 48) = 0u;
    *(_OWORD *)(v2 + 64) = 0u;
    *(_OWORD *)(v2 + 80) = 0u;
    *(int64x2_t *)(v2 + 96) = vdupq_n_s64(1uLL);
    *(_QWORD *)(v2 + 120) = 0;
    *(_QWORD *)(v2 + 128) = 0;
    *(_QWORD *)(v2 + 112) = 0;
    *(_WORD *)(v2 + 136) = 768;
    *(_OWORD *)(v2 + 144) = 0u;
    *(_OWORD *)(v2 + 160) = 0u;
    *(_OWORD *)(v2 + 176) = 0u;
    *(_DWORD *)(v2 + 192) = 0;
    *(_QWORD *)v2 = __stream;
    *(_QWORD *)(v2 + 8) = file_seek;
    *(_QWORD *)(v2 + 16) = file_read;
    *(_QWORD *)(v2 + 24) = file_write;
    *(_QWORD *)(v2 + 32) = 0;
    *(_QWORD *)(v2 + 40) = file_swap;
    if (!zip_load_all_from_central_directory((_QWORD *)v2))
    {
      while (zip_load_entry_from_file_header((_QWORD *)v2))
        ;
    }
  }
  return v2;
}

uint64_t *re::allocInfo_NamedAssetLoadDescriptorParameters(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_38);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_38))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FB678, 0);
    *(uint64_t *)((char *)&qword_2540FB688 + 6) = 0;
    qword_2540FB688 = 0;
    qword_2540FB698 = 0;
    qword_2540FB6A0 = 0xFFFFFFFFLL;
    qword_2540FB678 = (uint64_t)&off_24ED7DAA8;
    qword_2540FB6A8 = (uint64_t)"NamedAssetLoadDescriptorParameters";
    dword_2540FB6B0 = 0;
    unk_2540FB6B8 = 0u;
    unk_2540FB6C8 = 0u;
    unk_2540FB6D8 = 0u;
    qword_2540FB6E8 = 0;
    __cxa_guard_release(&_MergedGlobals_38);
  }
  return &qword_2540FB678;
}

void re::initInfo_NamedAssetLoadDescriptorParameters(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  __int128 v10;
  _QWORD v11[2];
  __int128 v12;

  v11[0] = 0x52794AE899614E6CLL;
  v11[1] = "NamedAssetLoadDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FB670);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FB670);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<re::DynamicString>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "assetName";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FB668 = v9;
      __cxa_guard_release(&qword_2540FB670);
    }
  }
  *((_QWORD *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((_QWORD *)this + 8) = &qword_2540FB668;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::NamedAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::NamedAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::NamedAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::NamedAssetLoadDescriptorParameters>;
  re::IntrospectionRegistry::add(this, v3);
  v10 = v12;
}

_QWORD *re::internal::defaultConstruct<re::NamedAssetLoadDescriptorParameters>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  return re::DynamicString::setCapacity((_QWORD *)a3, 0);
}

double re::internal::defaultDestruct<re::NamedAssetLoadDescriptorParameters>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  double result;

  if (*a3)
  {
    if ((a3[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a3 + 40))(*a3, a3[2]);
    result = 0.0;
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
  }
  return result;
}

_QWORD *re::internal::defaultConstructV2<re::NamedAssetLoadDescriptorParameters>(_anonymous_namespace_ *a1)
{
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  return re::DynamicString::setCapacity(a1, 0);
}

double re::internal::defaultDestructV2<re::NamedAssetLoadDescriptorParameters>(uint64_t *a1)
{
  uint64_t v2;
  double result;

  v2 = *a1;
  if (v2)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

_anonymous_namespace_ *re::NamedAssetProvider::NamedAssetProvider(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 v8;
  __guard *v9;
  int v11;

  ArcSharedObject::ArcSharedObject(a1, 0);
  *(_QWORD *)a1 = &off_24ED2C150;
  *((_QWORD *)a1 + 3) = 0;
  *((_QWORD *)a1 + 4) = 0;
  *((_QWORD *)a1 + 5) = 0;
  if ((v8 & 1) == 0)
  {
    if (v11)
    {
      re::introspect<re::NamedAssetLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"NamedAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_NamedAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_NamedAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::NamedAssetLoadDescriptorParameters>, 0);
    }
  }
  re::NamedAssetProvider::s_loadDescriptorParametersIntrospect = v9[40];
  *((_QWORD *)a1 + 4) = a3;
  *((_QWORD *)a1 + 5) = a4;
  *((_QWORD *)a1 + 3) = a2;
  return a1;
}

void re::NamedAssetProvider::~NamedAssetProvider(re::NamedAssetProvider *this)
{
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::NamedAssetProvider::makeDescriptor@<X0>(_anonymous_namespace_ *a1@<X0>, re::DynamicString *a2@<X1>, uint64_t a3@<X8>)
{
  _anonymous_namespace_ *v6;
  _anonymous_namespace_ *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  _OWORD v11[2];
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a3, 0);
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 40) = 0;
  *(_DWORD *)(a3 + 56) = 0;
  *(_QWORD *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_DWORD *)(a3 + 96) = 0;
  *(_OWORD *)(a3 + 104) = 0u;
  *(_OWORD *)(a3 + 120) = 0u;
  *(_QWORD *)(a3 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a3 + 112), 0);
  v12 = (uint64_t *)"NamedAsset";
  v13 = 10;
  re::DynamicString::operator=((re::DynamicString *)a3, (uint64_t)&v12);
  v7 = re::DynamicString::operator=((re::DynamicString *)(a3 + 112), a2);
  v13 = 0;
  v14 = 0;
  v15 = 0;
  re::DynamicString::setCapacity(&v12, 0);
  re::DynamicString::operator=((re::DynamicString *)&v12, a1);
  re::DynamicString::DynamicString((re::DynamicString *)v11, (const re::DynamicString *)&v12);
  re::AssetLoadDescriptor::setIntrospectableData((char **)a3, (const re::IntrospectionBase *)re::NamedAssetProvider::s_loadDescriptorParametersIntrospect, (const re::IntrospectionBase **)v11, 0);
  if (*(_QWORD *)&v11[0])
  {
    if ((BYTE8(v11[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v11[0] + 40))();
    memset(v11, 0, sizeof(v11));
  }
  result = (uint64_t)v12;
  if (v12)
  {
    if ((v13 & 1) != 0)
      return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(*v12 + 40))(v12, v14, v8, v9);
  }
  return result;
}

__n128 re::NamedAssetProvider::load@<Q0>(_anonymous_namespace_ *a1@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;
  uint64_t v7;
  uint64_t v8;

  result = v6;
  v4 = v7;
  v5 = v8;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v4;
  *(_QWORD *)(a2 + 32) = v5;
  return result;
}

__n128 re::NamedAssetProvider::resolveChild@<Q0>(re::NamedAssetProvider *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result;
  uint64_t v7;
  uint64_t v8;
  __n128 v9;
  uint64_t v10;
  uint64_t v11;

  result = v9;
  v7 = v10;
  v8 = v11;
  *(_BYTE *)a2 = 0;
  *(__n128 *)(a2 + 8) = result;
  *(_QWORD *)(a2 + 24) = v7;
  *(_QWORD *)(a2 + 32) = v8;
  return result;
}

uint64_t *re::NamedAssetProvider::getDescription(re::NamedAssetProvider *this, const re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  unsigned __int8 v5;
  re *IntrospectableData;
  NSObject *v7;
  uint64_t *result;
  char *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 buf;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v11 = 0;
  v12 = 0;
  v13 = 0;
  re::DynamicString::setCapacity(&v10, 0);
  if ((v5 & 1) == 0
  {
    re::introspect<re::NamedAssetLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"NamedAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_NamedAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_NamedAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::NamedAssetLoadDescriptorParameters>, 0);
  }
  IntrospectableData = (re *)re::AssetLoadDescriptor::getIntrospectableData(a2, (re **)re::introspect<re::NamedAssetLoadDescriptorParameters>(void)::info, &v10, 0);
  if ((_DWORD)IntrospectableData)
  {
    re::DynamicString::operator=(a3, (re::DynamicString *)&v10);
  }
  else
  {
    v7 = *re::assetsLogObjects(IntrospectableData);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      if ((*((_BYTE *)a2 + 8) & 1) != 0)
        v9 = (char *)*((_QWORD *)a2 + 2);
      else
        v9 = (char *)a2 + 9;
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v9;
      _os_log_error_impl(&dword_224FE9000, v7, OS_LOG_TYPE_ERROR, "NamedAssetProvider Failed to get introspectable data for %s", (uint8_t *)&buf, 0xCu);
    }
    *(_QWORD *)&buf = "mangled";
    *((_QWORD *)&buf + 1) = 7;
    re::DynamicString::operator=(a3, (uint64_t)&buf);
  }
  result = v10;
  if (v10)
  {
    if ((v11 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v10 + 40))();
  }
  return result;
}

const char *re::NamedAssetProvider::schemeName(re::NamedAssetProvider *this)
{
  return "NamedAsset";
}

void re::AssetProvider::makeDescriptorFromAssetPath(_BYTE *a1@<X8>)
{
  *a1 = 0;
}

uint64_t *re::AssetAPIUtilities::copyToPropertyBag@<X0>(re::AssetAPIUtilities *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v5;
  const re::IntrospectionBase *v6;
  double v7;
  unsigned int *v9[6];

  v9[5] = *(unsigned int **)MEMORY[0x24BDAC8D0];
  v5 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 1) + 24) + 1104), *(_QWORD *)(*((_QWORD *)this + 1) + 264));
  v6 = (const re::IntrospectionBase *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 112))(v5);
  re::AssetHandle::serializableAsset(this, v9);
  re::PropertyBagHelper::makeWithIntrospectedData(v6, v9[0], 0, a2, v7);
  return std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100]((uint64_t *)v9);
}

uint64_t re::AssetAPIUtilities::loadFromPropertyBag(_anonymous_namespace_ *a1, id *a2)
{
  uint64_t v4;
  unint64_t v5;
  os_unfair_lock_s *v6;
  re *v7;
  uint64_t v8;
  re *v9;
  uint64_t **v10;
  char v11;
  re *v12;
  uint64_t v13;
  NSObject *v14;
  _QWORD *v15;
  char *v16;
  const char *v17;
  _QWORD *v19;
  char *v20;
  id v21;
  uint8_t buf[4];
  char *v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)a1 + 1);
  v5 = *(_QWORD *)(v4 + 264);
  v6 = *(os_unfair_lock_s **)(v4 + 24);
  if (!v5)
  {
    v14 = *re::assetsLogObjects(v7);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      return 0;
    v15 = re::AssetHandle::assetInfo(a1);
    if ((v15[17] & 1) != 0)
      v16 = (char *)v15[18];
    else
      v16 = (char *)v15 + 137;
    *(_DWORD *)buf = 136315138;
    v23 = v16;
    v17 = "loadFromPropertyBag asset doesn't have a type '%s'";
LABEL_16:
    _os_log_error_impl(&dword_224FE9000, v14, OS_LOG_TYPE_ERROR, v17, buf, 0xCu);
    return 0;
  }
  v8 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(*(_QWORD *)(v4 + 24) + 1104), v5);
  v9 = (re *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 112))(v8);
  re::AssetHandle::internalForceUnloadAsync(a1);
  v10 = (uint64_t **)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v8 + 120))(v8);
  v21 = *a2;

  if ((v11 & 1) == 0)
  {
    v14 = *re::assetsLogObjects(v12);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      return 0;
    v19 = re::AssetHandle::assetInfo(a1);
    if ((v19[17] & 1) != 0)
      v20 = (char *)v19[18];
    else
      v20 = (char *)v19 + 137;
    *(_DWORD *)buf = 136315138;
    v23 = v20;
    v17 = "copyToIntrospectedData failed on '%s'";
    goto LABEL_16;
  }
  v13 = 1;
  re::AssetManager::setAssetPointerForExistingAsset(v6, v10, a1, 0, 1);
  return v13;
}

uint64_t re::AssetManager::shouldPreloadEngineAssets(re::AssetManager *this)
{
  return *((unsigned __int8 *)this + 1442);
}

uint64_t re::AssetManager::shouldPreloadAssetsOnResourceSharingClients(re::AssetManager *this)
{
  return *((unsigned __int8 *)this + 1443);
}

void re::AssetManager::assetHandle(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  re *v12;
  unint64_t v13;
  re::AssetLoadDescriptor *v14;
  uint64_t v15;
  const char *v16;
  uint64_t *v17;
  uint64_t v18;
  NSObject *v19;
  const char *v20;
  unint64_t v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v6 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  if (!a2[2])
  {
LABEL_28:
    uuid_generate_random((unsigned __int8 *)&v22);
    v13 = (*((_QWORD *)&v22 + 1) + ((_QWORD)v22 << 6) + ((unint64_t)v22 >> 2) - 0x61C8864680B583E9) ^ v22;
    goto LABEL_29;
  }
  v7 = re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::tryGet(a1 + 168, a2[4]);
  v8 = a2[2];
  if (v8 >= 2)
  {
    v9 = 1;
    v10 = 144;
    while (1)
    {
      v11 = re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::tryGet(a1 + 168, a2[4] + v10);
      if (v7 | v11)
      {
        if (!v7 || !v11 || *(_QWORD *)v7 != *(_QWORD *)v11)
          break;
      }
      ++v9;
      v8 = a2[2];
      v10 += 144;
      if (v9 >= v8)
        goto LABEL_9;
    }
    if (v7)
      v17 = (uint64_t *)v7;
    else
      v17 = (uint64_t *)v11;
    v18 = *v17;
    v19 = *re::assetsLogObjects((re *)v11);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      goto LABEL_26;
    LODWORD(v22) = 134217984;
    *(_QWORD *)((char *)&v22 + 4) = v18;
    v20 = "Can't create a new asset with the requested asset descriptors. An existing asset (%llu) matches some, but not "
          "all, of the the asset descriptors.";
    goto LABEL_32;
  }
LABEL_9:
  if (!v7)
  {
    if (v8)
    {
      v14 = (re::AssetLoadDescriptor *)a2[4];
      v15 = 144 * v8;
      while (1)
      {
        v16 = (*((_QWORD *)v14 + 1) & 1) != 0 ? (const char *)*((_QWORD *)v14 + 2) : (char *)v14 + 9;
        if (!strcmp(v16, "NetworkAsset"))
          break;
        v14 = (re::AssetLoadDescriptor *)((char *)v14 + 144);
        v15 -= 144;
        if (!v15)
          goto LABEL_28;
      }
      re::AssetLoadDescriptor::getIntrospectableData<re::NetworkAssetLoadDescriptorParameters>(v14, (uint64_t **)&v22, 0);
      v13 = v22;
      if ((_QWORD)v22)
        goto LABEL_29;
    }
    goto LABEL_28;
  }
  *(_QWORD *)&v22 = *(_QWORD *)v7;
  v12 = (re *)re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 120, (uint64_t *)&v22);
  if (*((_QWORD *)v12 + 2) == a2[2])
  {
    v13 = *(_QWORD *)v7;
LABEL_29:
    re::AssetManager::assetHandle_assetTablesLocked((_QWORD *)a1, a2, v13, (uint64_t *)&v22);
    *(_BYTE *)a3 = 1;
    *(_OWORD *)(a3 + 8) = v22;
    v22 = 0uLL;
    *(_QWORD *)(a3 + 24) = v23;
    v23 = 0;
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v22);
    goto LABEL_30;
  }
  v19 = *re::assetsLogObjects(v12);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    v21 = *(_QWORD *)v7;
    LODWORD(v22) = 134217984;
    *(_QWORD *)((char *)&v22 + 4) = v21;
    v20 = "Can't create a new asset with the requested asset descriptors (registeredDescriptors size does not match loadD"
          "escriptors's). An existing asset (%llu) matches some, but not all, of the the asset descriptors.";
LABEL_32:
    _os_log_error_impl(&dword_224FE9000, v19, OS_LOG_TYPE_ERROR, v20, (uint8_t *)&v22, 0xCu);
  }
LABEL_26:
  *(_BYTE *)a3 = 0;
LABEL_30:
  os_unfair_lock_unlock(v6);
}

BOOL re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::contains(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  _BOOL8 result;
  uint64_t v8;
  uint64_t v9;

  v2 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v2)
    return 0;
  v3 = *(_QWORD *)(a2 + 8);
  v4 = v3 ? *(_QWORD *)(v3 + 664) : 0;
  v5 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v3 ^ (v3 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v3 ^ (v3 >> 30))) >> 27));
  v6 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v4 ^ (v5 >> 31) ^ v5) % v2));
  if ((_DWORD)v6 == 0x7FFFFFFF)
    return 0;
  v8 = *(_QWORD *)(a1 + 16);
  do
  {
    v9 = *(_QWORD *)(v8 + 40 * v6 + 24);
    result = v9 == v3;
    if (v9 == v3)
      break;
    v6 = *(_DWORD *)(v8 + 40 * v6 + 8) & 0x7FFFFFFF;
  }
  while (v6 != 0x7FFFFFFF);
  return result;
}

re::AssetHandle *re::DynamicArray<re::AssetHandle>::add(_anonymous_namespace_ *this, re::AssetHandle *a2)
{
  unint64_t v4;
  re::AssetHandle *result;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::AssetHandle>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  result = re::AssetHandle::AssetHandle((re::AssetHandle *)(*((_QWORD *)this + 4) + 24 * v4), a2);
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(uint64_t a1, re::AssetHandle *a2)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;

  v4 = *((_QWORD *)a2 + 1);
  if (v4)
    v5 = *(_QWORD *)(v4 + 664);
  else
    v5 = 0;
  v6 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v4 ^ (v4 >> 30))) >> 27));
  v7 = v5 ^ (v6 >> 31) ^ v6;
  v8 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v8)
  {
    LODWORD(v9) = 0;
    goto LABEL_11;
  }
  v9 = v7 % v8;
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v7 % v8));
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_11:
    v12 = re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::addAsCopy(a1, v9, v7, (int)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    v13 = *(_QWORD *)(a1 + 16) + 40 * v12;
    return v13 + 16;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 40 * v10 + 24) != v4)
  {
    v10 = *(_DWORD *)(v11 + 40 * v10 + 8) & 0x7FFFFFFF;
    if (v10 == 0x7FFFFFFF)
      goto LABEL_11;
  }
  v13 = v11 + 40 * v10;
  return v13 + 16;
}

void re::AssetManager::getAssetDependenciesFromAssetProvidersRecursive(uint64_t a1@<X0>, _anonymous_namespace_ *a2@<X1>, uint64_t a3@<X2>, re::AssetHandle *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  unint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t *v14;
  int v15;
  _BYTE *v16;
  uint64_t v17;
  const char *v18;
  uint64_t ProviderForScheme;
  NSObject *v20;
  uint64_t v21;
  const __CFString *Domain;
  uint64_t v23;
  _BYTE *v24;
  re *v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  id v34;
  id v35;
  _QWORD v36[3];
  id location;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  _BYTE buf[12];
  _BYTE *v44;
  _BYTE v45[38];
  uint64_t *v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  v11 = *((_QWORD *)a2 + 2);
  v12 = re::AssetHandle::assetInfo(a4);
  if (v12[10] == -1)
    v13 = 0;
  else
    v13 = v12[10];
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  *(_QWORD *)&v38 = v13;
  v14 = (uint64_t *)re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 120, (uint64_t *)&v38);
  if (v14)
  {
    LOBYTE(v38) = 1;
    re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray((uint64_t)&v38 + 8, v14);
  }
  else
  {
    LOBYTE(v38) = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 64));
  if (!(_BYTE)v38 || !*((_QWORD *)&v39 + 1))
  {
    re::DynamicString::format((re::DynamicString *)"Failed to find AssetLoadDescriptors registered for assetId %llu.", (re::DynamicString *)v45, v13);
    if ((v45[8] & 1) != 0)
      v16 = *(_BYTE **)&v45[16];
    else
      v16 = &v45[9];
    re::WrappedError::make((re::WrappedError *)CFSTR("REAssetRefErrorDomain"), (const __CFString *)4, (uint64_t)v16, buf);
    v13 = *(_QWORD *)buf;
    *(_QWORD *)buf = 0;

    if (*(_QWORD *)v45 && (v45[8] & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)v45 + 40))();
    v15 = 0;
    goto LABEL_65;
  }
  if (*((_QWORD *)&v39 + 1) != 1 && (a5 & 1) != 0)
  {
    v15 = 1;
    goto LABEL_65;
  }
  location = 0;
  v13 = *((_QWORD *)&v40 + 1);
  v17 = 144 * *((_QWORD *)&v39 + 1);
  v33 = 136315138;
  while (1)
  {
    if ((*(_BYTE *)(v13 + 8) & 1) != 0)
      v18 = *(const char **)(v13 + 16);
    else
      v18 = (const char *)(v13 + 9);
    ProviderForScheme = re::AssetProviderRegistry::tryGetProviderForScheme(*(os_unfair_lock_s **)(a1 + 1192), v18);
    if (!ProviderForScheme)
    {
      v20 = *re::assetsLogObjects(0);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        if ((*(_BYTE *)(v13 + 8) & 1) != 0)
          v21 = *(_QWORD *)(v13 + 16);
        else
          v21 = v13 + 9;
        *(_DWORD *)v45 = 136315138;
        *(_QWORD *)&v45[4] = v21;
        _os_log_impl(&dword_224FE9000, v20, OS_LOG_TYPE_DEFAULT, "Failed to find a registered AssetProvider for scheme %s.", v45, 0xCu);
      }
      goto LABEL_49;
    }
    v36[1] = 0;
    v36[2] = 0;
    v36[0] = *(_QWORD *)(a1 + 1104);
    (*(void (**)(_BYTE *__return_ptr, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)ProviderForScheme + 88))(v45, ProviderForScheme, v13, v36);
    if (!v45[0])
    {
      Domain = CFErrorGetDomain((CFErrorRef)objc_retainAutorelease(*(id *)&v45[8]));
      if (CFStringCompare(Domain, CFSTR("REAssetProviderErrorDomain"), 0)
        || objc_msgSend(*(id *)&v45[8], "code") != 1)
      {
        if ((*(_BYTE *)(v13 + 8) & 1) != 0)
          v23 = *(_QWORD *)(v13 + 16);
        else
          v23 = v13 + 9;
        re::DynamicString::format((re::DynamicString *)"AssetProvider for scheme '%s' encountered an error while trying to get dependencies for an asset load descriptor.", (re::DynamicString *)buf, v23);
        if ((buf[8] & 1) != 0)
          v24 = v44;
        else
          v24 = &buf[9];
        v34 = *(id *)&v45[8];
        re::WrappedError::make(0x24EDA2210, 4, (uint64_t)v24, &v34, &v35);

        v25 = *(re **)buf;
        if (*(_QWORD *)buf && (buf[8] & 1) != 0)
          v25 = (re *)(*(uint64_t (**)(void))(**(_QWORD **)buf + 40))();
        v26 = *re::assetsLogObjects(v25);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          v27 = re::WrappedError::localizedDescription(&v35);
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v27;
          _os_log_impl(&dword_224FE9000, v26, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
        }
        if (!location)
          re::ObjCObject::operator=(&location, &v35);

      }
      goto LABEL_46;
    }
    if (*(_QWORD *)&v45[24])
      break;
LABEL_46:
    re::Result<re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>,re::WrappedError>::~Result(v45);
LABEL_49:
    v13 += 144;
    v17 -= 144;
    if (!v17)
    {
      if (location)
      {
        *(_QWORD *)buf = location;
        re::WrappedError::make(0x24EDA2210, 4, (uint64_t)"At least one AssetProvider encountered an error while trying to get asset dependencies, and no AssetProvider succeeded.", (id *)buf, v45);
        v13 = *(_QWORD *)v45;
        *(_QWORD *)v45 = 0;

        v15 = 0;
      }
      else
      {
        v15 = 1;
      }
      goto LABEL_64;
    }
  }
  v28 = v46;
  v29 = 40 * *(_QWORD *)&v45[24];
  while (1)
  {
    re::AssetManager::assetHandle(a1, v28, (uint64_t)buf);
    v15 = buf[0];
    if (buf[0])
    {
      if (!re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::contains(a3, (uint64_t)&buf[8]))
      {
        re::DynamicArray<re::AssetHandle>::add(a2, (re::AssetHandle *)&buf[8]);
        re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(a3, (re::AssetHandle *)&buf[8]);
      }
    }
    else
    {
      re::WrappedError::make((re::WrappedError *)CFSTR("REAssetRefErrorDomain"), (const __CFString *)4, (uint64_t)"Failed to make an AssetHandle for dependency AssetLoadDescriptors.", &v35);
      v33 = (uint64_t)v35;
      v35 = 0;

    }
    if (buf[0])
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&buf[8]);
    if (!v15)
      break;
    v28 += 5;
    v29 -= 40;
    if (!v29)
    {
      re::Result<re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>,re::WrappedError>::~Result(v45);
      v15 = 1;
      goto LABEL_63;
    }
  }
  re::Result<re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>,re::WrappedError>::~Result(v45);
LABEL_63:
  v13 = v33;
LABEL_64:

LABEL_65:
  if ((_BYTE)v38)
    re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)&v38 + 8);
  if (v15)
  {
    v30 = *((_QWORD *)a2 + 2);
    if (v11 >= v30)
    {
LABEL_73:
      *(_BYTE *)a6 = 1;
    }
    else
    {
      v31 = 24 * v11;
      while (1)
      {
        v32 = *((_QWORD *)a2 + 2);
        if (v32 <= v11)
        {
          *(_QWORD *)buf = 0;
          v41 = 0u;
          v42 = 0u;
          v39 = 0u;
          v40 = 0u;
          v38 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v45 = 136315906;
          *(_QWORD *)&v45[4] = "operator[]";
          *(_WORD *)&v45[12] = 1024;
          *(_DWORD *)&v45[14] = 789;
          *(_WORD *)&v45[18] = 2048;
          *(_QWORD *)&v45[20] = v11;
          *(_WORD *)&v45[28] = 2048;
          *(_QWORD *)&v45[30] = v32;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        re::AssetManager::getAssetDependenciesFromAssetProvidersRecursive(a1, a2, a3, *((_QWORD *)a2 + 4) + v31, a5);
        if (!*(_BYTE *)a6)
          break;
        ++v11;
        v31 += 24;
        if (v30 == v11)
          goto LABEL_73;
      }
    }
  }
  else
  {
    *(_BYTE *)a6 = 0;
    *(_QWORD *)(a6 + 8) = v13;
  }
}

double re::AssetManager::AssetManager(re::AssetManager *this)
{
  double result;

  *(_QWORD *)this = &off_24ED2C1F0;
  *((_QWORD *)this + 1) = &unk_24ED2C3C8;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 2) = &unk_24ED2C3E0;
  *((_QWORD *)this + 3) = 0;
  result = 0.0;
  *((_OWORD *)this + 2) = 0u;
  *((_DWORD *)this + 12) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 0;
  *(_QWORD *)((char *)this + 108) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((_DWORD *)this + 38) = 0;
  *(_QWORD *)((char *)this + 156) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((_DWORD *)this + 50) = 0;
  *(_QWORD *)((char *)this + 204) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *((_DWORD *)this + 62) = 0;
  *(_QWORD *)((char *)this + 252) = 0x7FFFFFFFLL;
  *((_DWORD *)this + 74) = 0;
  *((_DWORD *)this + 86) = 0;
  *((_QWORD *)this + 47) = 0;
  *((_DWORD *)this + 96) = 0;
  *((_DWORD *)this + 112) = 0;
  *((_QWORD *)this + 61) = 0;
  *((_DWORD *)this + 120) = 0;
  *((_QWORD *)this + 59) = 0;
  *((_DWORD *)this + 128) = 0;
  *((_QWORD *)this + 69) = 0;
  *((_QWORD *)this + 67) = 0;
  *((_DWORD *)this + 136) = 0;
  *((_BYTE *)this + 576) = 0;
  *((_QWORD *)this + 73) = 0;
  *((_DWORD *)this + 160) = 0;
  *((_QWORD *)this + 86) = 0;
  *((_DWORD *)this + 170) = 0;
  *((_BYTE *)this + 704) = 0;
  *((_DWORD *)this + 208) = 0;
  *((_QWORD *)this + 109) = 0;
  *((_DWORD *)this + 216) = 0;
  *((_QWORD *)this + 107) = 0;
  *((_QWORD *)this + 112) = 0;
  *((_DWORD *)this + 240) = 0;
  *((_QWORD *)this + 125) = 0;
  *((_DWORD *)this + 248) = 0;
  *((_QWORD *)this + 123) = 0;
  *((_DWORD *)this + 256) = 0;
  *((_QWORD *)this + 133) = 0;
  *((_DWORD *)this + 264) = 0;
  *((_QWORD *)this + 131) = 0;
  *((_DWORD *)this + 272) = 0;
  *((_DWORD *)this + 294) = 0;
  *((_DWORD *)this + 336) = 0;
  *((_QWORD *)this + 173) = 0;
  *((_DWORD *)this + 344) = 0;
  *((_QWORD *)this + 171) = 0;
  *((_WORD *)this + 704) = 0;
  *((_BYTE *)this + 1410) = 0;
  *((_QWORD *)this + 177) = 0;
  *((_BYTE *)this + 1424) = 0;
  *((_QWORD *)this + 163) = 0;
  *((_QWORD *)this + 179) = -1;
  *((_BYTE *)this + 1444) = 0;
  *((_DWORD *)this + 360) = 0;
  *((_QWORD *)this + 181) = -1;
  *((_WORD *)this + 728) = 0;
  *((_BYTE *)this + 1458) = 0;
  *((_QWORD *)this + 183) = 1000;
  *((_QWORD *)this + 184) = 0;
  *((_BYTE *)this + 1480) = 0;
  *((_BYTE *)this + 1488) = 0;
  *((_DWORD *)this + 390) = 0;
  *((_QWORD *)this + 201) = 0;
  *((_DWORD *)this + 400) = 0;
  *((_QWORD *)this + 199) = 0;
  *((_DWORD *)this + 416) = 0;
  *((_DWORD *)this + 422) = 1;
  *((_OWORD *)this + 106) = 0u;
  *((_QWORD *)this + 216) = 0;
  *((_QWORD *)this + 218) = -1;
  *((_QWORD *)this + 217) = -1;
  *((_WORD *)this + 876) = 260;
  *((_DWORD *)this + 439) = 1023969417;
  *((_BYTE *)this + 1760) = 0;
  *((_WORD *)this + 892) = 0;
  *((_BYTE *)this + 1808) = 0;
  *((_OWORD *)this + 112) = 0u;
  *((_DWORD *)this + 16) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_QWORD *)((char *)this + 300) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_QWORD *)((char *)this + 348) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 420) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_QWORD *)((char *)this + 436) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *(_OWORD *)((char *)this + 648) = 0u;
  *(_OWORD *)((char *)this + 664) = 0u;
  *(_OWORD *)((char *)this + 840) = 0u;
  *(_OWORD *)((char *)this + 968) = 0u;
  *(_OWORD *)((char *)this + 1032) = 0u;
  *(_OWORD *)((char *)this + 712) = 0u;
  *(_OWORD *)((char *)this + 1144) = 0u;
  *(_OWORD *)((char *)this + 1160) = 0u;
  *(_OWORD *)((char *)this + 1112) = 0u;
  *(_OWORD *)((char *)this + 1128) = 0u;
  *(_OWORD *)((char *)this + 1096) = 0u;
  *(_QWORD *)((char *)this + 1180) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 1352) = 0u;
  *(_OWORD *)((char *)this + 1272) = 0u;
  *(_OWORD *)((char *)this + 1288) = 0u;
  *(_OWORD *)((char *)this + 1240) = 0u;
  *(_OWORD *)((char *)this + 1256) = 0u;
  *(_OWORD *)((char *)this + 1208) = 0u;
  *(_OWORD *)((char *)this + 1224) = 0u;
  *(_OWORD *)((char *)this + 1192) = 0u;
  *(_QWORD *)((char *)this + 1564) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 1528) = 0u;
  *(_OWORD *)((char *)this + 1544) = 0u;
  *(_OWORD *)((char *)this + 1496) = 0u;
  *(_OWORD *)((char *)this + 1512) = 0u;
  *(_OWORD *)((char *)this + 1576) = 0u;
  *(_OWORD *)((char *)this + 1672) = 0u;
  *(_OWORD *)((char *)this + 1768) = 0u;
  return result;
}

void re::AssetManager::~AssetManager(re::AssetManager *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;

  std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100]((uint64_t)this + 1792);

  re::DynamicOverflowArray<re::CollisionCastHit *,2ul>::deinit((uint64_t)this + 1672);
  v2 = *((_QWORD *)this + 197);
  if (v2)
  {
    v3 = *((_QWORD *)this + 201);
    if (v3)
    {
      v4 = *((_QWORD *)this + 199);
      if (v4)
      {
        v5 = 40 * v4;
        do
        {
          re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v3);
          v3 += 40;
          v5 -= 40;
        }
        while (v5);
        v2 = *((_QWORD *)this + 197);
        v3 = *((_QWORD *)this + 201);
      }
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, v3);
    }
    *((_QWORD *)this + 201) = 0;
    *((_QWORD *)this + 198) = 0;
    *((_QWORD *)this + 199) = 0;
    *((_QWORD *)this + 197) = 0;
    ++*((_DWORD *)this + 400);
  }
  v6 = re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)this + 191);
  v7 = *((_QWORD *)this + 169);
  if (v7)
  {
    if (*((_QWORD *)this + 173))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v7 + 40))(v7, v6);
    *((_QWORD *)this + 173) = 0;
    *((_QWORD *)this + 170) = 0;
    *((_QWORD *)this + 171) = 0;
    *((_QWORD *)this + 169) = 0;
    ++*((_DWORD *)this + 344);
  }
  v8 = *((_QWORD *)this + 161);
  if (v8)
  {

    *((_QWORD *)this + 161) = 0;
  }
  v9 = *((_QWORD *)this + 160);
  if (v9)
  {

    *((_QWORD *)this + 160) = 0;
  }
  v10 = *((_QWORD *)this + 158);
  if (v10)
  {

    *((_QWORD *)this + 158) = 0;
  }
  v11 = *((_QWORD *)this + 157);
  if (v11)
  {

    *((_QWORD *)this + 157) = 0;
  }
  v12 = *((_QWORD *)this + 156);
  if (v12)
  {

    *((_QWORD *)this + 156) = 0;
  }
  v13 = *((_QWORD *)this + 154);
  if (v13)
  {

    *((_QWORD *)this + 154) = 0;
  }
  v14 = *((_QWORD *)this + 150);
  if (v14)
  {

    *((_QWORD *)this + 150) = 0;
  }
  v15 = re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::deinit((uint64_t *)this + 143);
  v16 = *((_QWORD *)this + 129);
  if (v16)
  {
    if (*((_QWORD *)this + 133))
      (*(void (**)(uint64_t, double))(*(_QWORD *)v16 + 40))(v16, v15);
    *((_QWORD *)this + 133) = 0;
    *((_QWORD *)this + 130) = 0;
    *((_QWORD *)this + 131) = 0;
    *((_QWORD *)this + 129) = 0;
    ++*((_DWORD *)this + 264);
  }
  re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::deinit((uint64_t)this + 968);

  re::DynamicArray<re::NetworkActionQueue::Action>::deinit((uint64_t)this + 840);
  v17 = *((_QWORD *)this + 90);
  if (v17)
  {

    *((_QWORD *)this + 90) = 0;
  }
  re::Queue<re::SharedPtr<re::AssetLoadRequest::Data>>::deinit((uint64_t *)this + 81);

  v18 = *((_QWORD *)this + 65);
  if (v18)
  {
    if (*((_QWORD *)this + 69))
      (*(void (**)(uint64_t))(*(_QWORD *)v18 + 40))(v18);
    *((_QWORD *)this + 69) = 0;
    *((_QWORD *)this + 66) = 0;
    *((_QWORD *)this + 67) = 0;
    *((_QWORD *)this + 65) = 0;
    ++*((_DWORD *)this + 136);
  }
  v19 = *((_QWORD *)this + 57);
  if (!v19)
    goto LABEL_50;
  v20 = (_QWORD *)*((_QWORD *)this + 61);
  if (!v20)
    goto LABEL_49;
  v21 = *((_QWORD *)this + 59);
  if (!v21)
    goto LABEL_48;
  v22 = 32 * v21;
  do
  {
    v23 = (_QWORD *)v20[3];
    if (v20 == v23)
    {
      v23 = v20;
      v24 = 4;
    }
    else
    {
      if (!v23)
        goto LABEL_46;
      v24 = 5;
    }
    (*(void (**)(void))(*v23 + 8 * v24))();
LABEL_46:
    v20 += 4;
    v22 -= 32;
  }
  while (v22);
  v19 = *((_QWORD *)this + 57);
  v20 = (_QWORD *)*((_QWORD *)this + 61);
LABEL_48:
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v19 + 40))(v19, v20);
LABEL_49:
  *((_QWORD *)this + 61) = 0;
  *((_QWORD *)this + 58) = 0;
  *((_QWORD *)this + 59) = 0;
  *((_QWORD *)this + 57) = 0;
  ++*((_DWORD *)this + 120);
LABEL_50:
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 50);
  re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)this + 360);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)this + 39);
  re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 33);
  re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::deinit((uint64_t *)this + 27);
  re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::deinit((uint64_t *)this + 21);
  re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 15);
  re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 9);
  re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)this + 24);
}

void re::AssetManager::init(uint64_t a1, uint64_t a2)
{
  re::AssetUtilities *v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  unsigned __int8 v7;
  const char *v8;
  char v9;
  BOOL v10;
  const char *v11;
  uint8_t v12;
  const char *v13;
  uint8_t v14;
  const char *v15;
  uint8_t v16;
  const char *v17;
  uint8_t v18;
  uint64_t v19;
  uint64_t v20;
  _anonymous_namespace_ *v21;
  _anonymous_namespace_ *v22;
  _anonymous_namespace_ *v23;
  re *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t (***v29)();
  uint64_t *v30;
  uint64_t v31;
  _anonymous_namespace_ *v32;
  uint64_t v33;
  re *v34;
  uint64_t *v35;
  _QWORD *v36;
  NSObject *v37;
  re *Request;
  uint64_t *v39;
  _anonymous_namespace_ *v40;
  _anonymous_namespace_ *v41;
  uint64_t v42;
  os_unfair_lock_s *v43;
  char *v44;
  uint64_t v45;
  _BOOL8 v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t *v49;
  _anonymous_namespace_ *v50;
  _anonymous_namespace_ *v51;
  uint64_t v52;
  os_unfair_lock_s *v53;
  char *v54;
  uint64_t v55;
  _BOOL8 v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t *v59;
  _anonymous_namespace_ *v60;
  _anonymous_namespace_ *v61;
  uint64_t v62;
  os_unfair_lock_s *v63;
  char *v64;
  uint64_t v65;
  _BOOL8 v66;
  uint64_t *v67;
  _anonymous_namespace_ *v68;
  _anonymous_namespace_ *v69;
  uint64_t v70;
  os_unfair_lock_s *v71;
  char *v72;
  uint64_t v73;
  _BOOL8 v74;
  uint64_t *v75;
  uint64_t v76;
  re *v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  os_unfair_lock_s *v82;
  id v83;
  uint64_t v84;
  _BOOL8 v85;
  uint64_t *v86;
  _anonymous_namespace_ *v87;
  _anonymous_namespace_ *v88;
  uint64_t v89;
  os_unfair_lock_s *v90;
  char *v91;
  uint64_t v92;
  _BOOL8 v93;
  uint64_t *v94;
  _anonymous_namespace_ *v95;
  _anonymous_namespace_ *v96;
  uint64_t v97;
  os_unfair_lock_s *v98;
  char *v99;
  uint64_t v100;
  _BOOL8 v101;
  uint64_t *v102;
  _QWORD *v103;
  unsigned __int8 v104;
  os_unfair_lock_s *v105;
  void *v106;
  id v107;
  re *v108;
  uint64_t *v109;
  uint64_t v110;
  re::PeerAssetProvider *v111;
  os_unfair_lock_s *v112;
  id v113;
  re::internal::AssetTypeRegistry *v114;
  re *v115;
  uint64_t *v116;
  re::internal::AssetBackgroundLoader *v117;
  const char *v118;
  re::internal::AssetBackgroundLoader *v119;
  re *v120;
  uint64_t *v121;
  uint64_t v122;
  uint64_t v123;
  unsigned __int8 v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  id v132;
  void **v133;
  id v134;
  void *v135;
  NSObject *v136;
  void *v137;
  _QWORD *v138;
  std::__shared_weak_count *v139;
  unint64_t *p_shared_owners;
  unint64_t v141;
  const re::IntrospectionBase *v142;
  _QWORD v143[3];
  uint64_t v144;
  re::PeerAssetProvider *v145;
  _QWORD *v146;
  _anonymous_namespace_ *v147;
  _anonymous_namespace_ *v148;
  uint64_t v149;
  _anonymous_namespace_ *v150;
  _anonymous_namespace_ *v151;
  _anonymous_namespace_ *v152;
  _anonymous_namespace_ *v153;
  id v154;
  uint8_t buf[8];
  uint64_t v156;

  dispatch_assert_queue_V2(*(dispatch_queue_t *)a2);
  if ((v5 & 1) == 0)
  {
    if ((_DWORD)v4)
    {
      re::introspect<re::AssetMap>(void)::info = (_UNKNOWN *)re::introspect_AssetMap(0);
    }
  }
  if ((v6 & 1) == 0)
  {
    if ((_DWORD)v4)
    {
      re::introspect<re::DeduplicationInformation>(void)::info = (_UNKNOWN *)re::introspect_DeduplicationInformation(0);
    }
  }
  if ((v7 & 1) == 0)
  {
    if ((_DWORD)v4)
    {
      re::introspect<re::RealityFileHeader>(void)::info = (_UNKNOWN *)re::introspect_RealityFileHeader(0);
    }
  }
  re::AssetUtilities::init(v4);
  *(_BYTE *)(a1 + 1424) = *(_BYTE *)(a2 + 40);
  *(_QWORD *)(a1 + 1432) = *(_QWORD *)(a2 + 48);
  *(_BYTE *)(a1 + 1440) = *(_BYTE *)(a2 + 68);
  if (*(_BYTE *)(a2 + 64))
  {
    v9 = 1;
  }
  else
  {
    re::Defaults::BOOLValue((re::Defaults *)"calculateAssetNonSharedDataSize", v8, (char *)buf);
    if (buf[0])
      v10 = buf[1] == 0;
    else
      v10 = 1;
    v9 = !v10;
  }
  *(_BYTE *)(a1 + 1441) = v9;
  *(_BYTE *)(a1 + 1442) = *(_BYTE *)(a2 + 67);
  re::Defaults::BOOLValue((re::Defaults *)"preloadAssetsOnResourceSharingClients", v8, (char *)buf);
  if (buf[0])
    v12 = buf[1];
  else
    v12 = 0;
  *(_BYTE *)(a1 + 1443) = v12;
  re::Defaults::BOOLValue((re::Defaults *)"useXPCAssetPushLoading", v11, (char *)buf);
  if (buf[0])
    v14 = buf[1];
  else
    v14 = 1;
  *(_BYTE *)(a1 + 1444) = v14;
  if (*(_BYTE *)(a2 + 66))
    *(_BYTE *)(a1 + 1444) = 0;
  re::Defaults::BOOLValue((re::Defaults *)"loadPeerAssetsOnlyFromDirectPeers", v13, (char *)buf);
  if (buf[0])
    v16 = buf[1];
  else
    v16 = 0;
  *(_BYTE *)(a1 + 1456) = v16;
  re::Defaults::BOOLValue((re::Defaults *)"loadPayloadOnEngineQueue", v15, (char *)buf);
  if (buf[0])
    v18 = buf[1];
  else
    v18 = 0;
  *(_BYTE *)(a1 + 1457) = v18;
  re::Defaults::uint64Value((re::Defaults *)"longRegistrationLogThresholdMilliseconds", v17, (uint64_t)buf);
  v19 = 1000;
  if (buf[0])
    v19 = v156;
  *(_QWORD *)(a1 + 1464) = v19;
  v20 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 1272) = v20;
  re::ObjCObject::operator=((id *)(a1 + 584), (id *)a2);
  v154 = *(id *)(a1 + 584);
  re::internal::EngineQueueCheck::init((void *)(a1 + 896), (dispatch_queue_t *)&v154);

  v22 = (_anonymous_namespace_ *)re::Queue<re::SharedPtr<re::AssetLoadRequest::Data>>::setCapacity((_QWORD *)(a1 + 648), 0x20uLL);
  *(_QWORD *)(a1 + 672) = 0;
  *(_QWORD *)(a1 + 664) = 0;
  *(_DWORD *)(a1 + 680) = 0;
  v23 = (_anonymous_namespace_ *)re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::setCapacity((_QWORD *)(a1 + 968), 0x20uLL);
  ++*(_DWORD *)(a1 + 992);
  v24 = (re *)re::DynamicArray<float *>::setCapacity((_QWORD *)(a1 + 1352), 0x10uLL);
  ++*(_DWORD *)(a1 + 1376);
  v25 = re::globalAllocators(v24);
  v26 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v25[2] + 32))(v25[2], 136, 8);
  *(_OWORD *)(v26 + 96) = 0u;
  *(_OWORD *)(v26 + 112) = 0u;
  *(_OWORD *)v26 = 0u;
  *(_OWORD *)(v26 + 16) = 0u;
  *(_OWORD *)(v26 + 32) = 0u;
  *(_OWORD *)(v26 + 48) = 0u;
  *(_OWORD *)(v26 + 64) = 0u;
  *(_OWORD *)(v26 + 80) = 0u;
  *(_DWORD *)(v26 + 36) = 0x7FFFFFFF;
  *(_QWORD *)(v26 + 80) = 0x7FFFFFFF00000000;
  *(_QWORD *)(v26 + 128) = 0;
  *(_QWORD *)(v26 + 96) = 0;
  *(_QWORD *)(v26 + 104) = 0;
  *(_DWORD *)(v26 + 120) = 0;
  *(_QWORD *)(v26 + 112) = 0;
  *(_QWORD *)(a1 + 1104) = v26;
  v27 = re::globalAllocators((re *)v26);
  v28 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v27[2] + 32))(v27[2], 96, 8);
  *(_OWORD *)(v28 + 64) = 0u;
  *(_OWORD *)(v28 + 80) = 0u;
  *(_OWORD *)(v28 + 32) = 0u;
  *(_OWORD *)(v28 + 48) = 0u;
  *(_QWORD *)v28 = &off_24ED7F1E8;
  *(_QWORD *)(v28 + 8) = 0;
  *(_QWORD *)(v28 + 16) = 0;
  *(_QWORD *)(v28 + 24) = 0;
  *(_DWORD *)(v28 + 32) = 0;
  *(_OWORD *)(v28 + 68) = 0u;
  *(_OWORD *)(v28 + 56) = 0u;
  *(_OWORD *)(v28 + 40) = 0u;
  *(_DWORD *)(v28 + 84) = 0x7FFFFFFF;
  *(_QWORD *)(a1 + 1112) = v28;
  v29 = re::AssetHelper::registerDefaultAssetCompilers((re *)v28, v20, *(_BYTE *)(a2 + 24));
  v30 = re::globalAllocators((re *)v29);
  v31 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v30[2] + 32))(v30[2], 192, 64);
  *(_OWORD *)(v31 + 128) = 0u;
  *(_OWORD *)(v31 + 144) = 0u;
  *(_OWORD *)(v31 + 96) = 0u;
  *(_OWORD *)(v31 + 112) = 0u;
  *(_OWORD *)(v31 + 160) = 0u;
  *(_OWORD *)(v31 + 176) = 0u;
  *(_OWORD *)(v31 + 64) = 0u;
  *(_OWORD *)(v31 + 80) = 0u;
  *(_OWORD *)(v31 + 32) = 0u;
  *(_OWORD *)(v31 + 48) = 0u;
  *(_OWORD *)v31 = 0u;
  *(_OWORD *)(v31 + 16) = 0u;
  *(_DWORD *)(v31 + 108) = 0x7FFFFFFF;
  *(_OWORD *)(v31 + 136) = 0u;
  *(_QWORD *)(v31 + 152) = 0x7FFFFFFF00000000;
  *(_OWORD *)(v31 + 120) = 0u;
  *(_QWORD *)(a1 + 1192) = v31;
  *(_OWORD *)v31 = *(_OWORD *)(a1 + 1104);
  *(_QWORD *)(v31 + 16) = v31;
  v32 = (_anonymous_namespace_ *)re::ServiceLocator::serviceOrNull<re::ResourceFetchService>(v20);
  *(_QWORD *)(a1 + 1128) = v32;
  v33 = *(_QWORD *)(a2 + 56);
  if (!v33)
  {
    if (v32)
      v33 = 10000000;
    else
      v33 = 500000000;
  }
  *(_QWORD *)(a1 + 1448) = v33;
  *(_QWORD *)(a1 + 1224) = *(_QWORD *)(a2 + 32);
  v34 = (re *)re::ServiceLocator::serviceOrNull<re::NetworkAssetService>(v20);
  *(_QWORD *)(a1 + 1208) = v34;
  if (v34)
  {
    v35 = re::globalAllocators(v34);
    v36 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v35[2] + 32))(v35[2], 16, 8);
    *v36 = &off_24ED2C5A0;
    v36[1] = a1;
    *(_QWORD *)(a1 + 712) = v36;
    (*(void (**)(_QWORD, _QWORD *))(**(_QWORD **)(a1 + 1208) + 208))(*(_QWORD *)(a1 + 1208), v36);
  }
  else
  {
    v37 = *re::assetsLogObjects(0);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_224FE9000, v37, OS_LOG_TYPE_DEFAULT, "No NetworkAssetService available! Cannot share dependencies over network.", buf, 2u);
    }
  }
  Request = (re *)re::ServiceLocator::serviceOrNull<re::NetworkSendBlockingAssetLoadRequestService>(v20);
  *(_QWORD *)(a1 + 1216) = Request;
  v39 = re::globalAllocators(Request);
  v40 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v39[2] + 32))(v39[2], 48, 8);
  v41 = re::NetworkAssetProvider::NetworkAssetProvider(v40, *(_QWORD *)(a1 + 1208), *(_QWORD *)(a1 + 1192), *(_QWORD *)(a1 + 1104));
  v42 = *(_QWORD *)(a1 + 1200);
  *(_QWORD *)(a1 + 1200) = v41;
  if (v42)
  {

    v41 = *(_anonymous_namespace_ **)(a1 + 1200);
  }
  v43 = *(os_unfair_lock_s **)(a1 + 1192);
  v153 = v41;
  if (v41)
  {
    v44 = (char *)v41 + 8;
    v45 = (uint64_t)v153;
    v46 = re::AssetProviderRegistry::registerAssetProvider(v43, (uint64_t *)&v153);
    if (v45)
    {

      v153 = 0;
    }
  }
  else
  {
    v46 = re::AssetProviderRegistry::registerAssetProvider(v43, (uint64_t *)&v153);
  }
  v47 = re::globalAllocators((re *)v46);
  v48 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v47[2] + 32))(v47[2], 64, 64);
  *(_OWORD *)v48 = 0u;
  *(_OWORD *)(v48 + 16) = 0u;
  *(_OWORD *)(v48 + 32) = 0u;
  *(_OWORD *)(v48 + 48) = 0u;
  *(_DWORD *)(v48 + 44) = 0x7FFFFFFF;
  *(_QWORD *)(a1 + 1304) = v48;
  v49 = re::globalAllocators((re *)v48);
  v50 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v49[2] + 32))(v49[2], 56, 8);
  v51 = re::FrameworkAssetProvider::FrameworkAssetProvider(v50, *(_QWORD *)(a1 + 1192), *(_QWORD *)(a1 + 1104), *(_QWORD *)(a1 + 1112), *(_QWORD *)(a1 + 1304));
  v52 = *(_QWORD *)(a1 + 1232);
  *(_QWORD *)(a1 + 1232) = v51;
  if (v52)
  {

    v51 = *(_anonymous_namespace_ **)(a1 + 1232);
  }
  v53 = *(os_unfair_lock_s **)(a1 + 1192);
  v152 = v51;
  if (v51)
  {
    v54 = (char *)v51 + 8;
    v55 = (uint64_t)v152;
    v56 = re::AssetProviderRegistry::registerAssetProvider(v53, (uint64_t *)&v152);
    if (v55)
    {

      v152 = 0;
    }
  }
  else
  {
    v56 = re::AssetProviderRegistry::registerAssetProvider(v53, (uint64_t *)&v152);
  }
  v57 = re::globalAllocators((re *)v56);
  v58 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v57[2] + 32))(v57[2], 64, 64);
  *(_OWORD *)v58 = 0u;
  *(_OWORD *)(v58 + 16) = 0u;
  *(_OWORD *)(v58 + 32) = 0u;
  *(_OWORD *)(v58 + 48) = 0u;
  *(_DWORD *)(v58 + 44) = 0x7FFFFFFF;
  *(_QWORD *)(a1 + 1296) = v58;
  v59 = re::globalAllocators((re *)v58);
  v60 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v59[2] + 32))(v59[2], 56, 8);
  v61 = re::NamedFileAssetProvider::NamedFileAssetProvider(v60, *(_QWORD *)(a1 + 1296), *(_QWORD *)(a1 + 1104), *(_QWORD *)(a1 + 1112), *(_QWORD *)(a1 + 1192));
  v62 = *(_QWORD *)(a1 + 1288);
  *(_QWORD *)(a1 + 1288) = v61;
  if (v62)
  {

    v61 = *(_anonymous_namespace_ **)(a1 + 1288);
  }
  v63 = *(os_unfair_lock_s **)(a1 + 1192);
  v151 = v61;
  if (v61)
  {
    v64 = (char *)v61 + 8;
    v65 = (uint64_t)v151;
    v66 = re::AssetProviderRegistry::registerAssetProvider(v63, (uint64_t *)&v151);
    if (v65)
    {

      v151 = 0;
    }
  }
  else
  {
    v66 = re::AssetProviderRegistry::registerAssetProvider(v63, (uint64_t *)&v151);
  }
  v67 = re::globalAllocators((re *)v66);
  v68 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v67[2] + 32))(v67[2], 48, 8);
  v69 = re::NamedAssetProvider::NamedAssetProvider(v68, *(_QWORD *)(a1 + 1104), *(_QWORD *)(a1 + 1112), *(_QWORD *)(a1 + 1192));
  v70 = *(_QWORD *)(a1 + 1280);
  *(_QWORD *)(a1 + 1280) = v69;
  if (v70)
  {

    v69 = *(_anonymous_namespace_ **)(a1 + 1280);
  }
  v71 = *(os_unfair_lock_s **)(a1 + 1192);
  v150 = v69;
  if (v69)
  {
    v72 = (char *)v69 + 8;
    v73 = (uint64_t)v150;
    v74 = re::AssetProviderRegistry::registerAssetProvider(v71, (uint64_t *)&v150);
    if (v73)
    {

      v150 = 0;
    }
  }
  else
  {
    v74 = re::AssetProviderRegistry::registerAssetProvider(v71, (uint64_t *)&v150);
  }
  v75 = re::globalAllocators((re *)v74);
  v76 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v75[2] + 32))(v75[2], 136, 8);
  *(_OWORD *)v76 = 0u;
  *(_OWORD *)(v76 + 16) = 0u;
  *(_OWORD *)(v76 + 32) = 0u;
  *(_OWORD *)(v76 + 48) = 0u;
  *(_OWORD *)(v76 + 96) = 0u;
  *(_OWORD *)(v76 + 112) = 0u;
  *(_OWORD *)(v76 + 64) = 0u;
  *(_OWORD *)(v76 + 80) = 0u;
  *(_QWORD *)(v76 + 128) = 0;
  *(_QWORD *)(v76 + 8) = v76 + 8;
  *(_QWORD *)(v76 + 16) = v76 + 8;
  *(_OWORD *)(v76 + 52) = 0u;
  *(_OWORD *)(v76 + 40) = 0u;
  *(_OWORD *)(v76 + 24) = 0u;
  *(_DWORD *)(v76 + 68) = 0x7FFFFFFF;
  *(_OWORD *)(v76 + 108) = 0u;
  *(_DWORD *)(v76 + 124) = 0x7FFFFFFF;
  *(_QWORD *)(a1 + 1240) = v76;
  re::RealityFileRegistry::init((void **)v76);
  v78 = re::globalAllocators(v77);
  v79 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v78[2] + 32))(v78[2], 280, 8);
  v80 = re::RealityFileAssetProvider::RealityFileAssetProvider(v79, *(_QWORD *)(a1 + 1240), *(_QWORD *)(a1 + 1104), *(_QWORD *)(a1 + 1192), *(_QWORD *)(a1 + 1296), *(_QWORD *)(a1 + 1304));
  v81 = *(_QWORD *)(a1 + 1248);
  *(_QWORD *)(a1 + 1248) = v80;
  if (v81)
  {

    v80 = *(_QWORD *)(a1 + 1248);
  }
  v82 = *(os_unfair_lock_s **)(a1 + 1192);
  v149 = v80;
  if (v80)
  {
    v83 = (id)(v80 + 8);
    v84 = v149;
    v85 = re::AssetProviderRegistry::registerAssetProvider(v82, &v149);
    if (v84)
    {

      v149 = 0;
    }
  }
  else
  {
    v85 = re::AssetProviderRegistry::registerAssetProvider(v82, &v149);
  }
  v86 = re::globalAllocators((re *)v85);
  v87 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v86[2] + 32))(v86[2], 48, 8);
  v88 = re::FileAssetProvider::FileAssetProvider(v87, *(_QWORD *)(a1 + 1104), *(_QWORD *)(a1 + 1112), *(_QWORD *)(a1 + 1192));
  v89 = *(_QWORD *)(a1 + 1256);
  *(_QWORD *)(a1 + 1256) = v88;
  if (v89)
  {

    v88 = *(_anonymous_namespace_ **)(a1 + 1256);
  }
  v90 = *(os_unfair_lock_s **)(a1 + 1192);
  v148 = v88;
  if (v88)
  {
    v91 = (char *)v88 + 8;
    v92 = (uint64_t)v148;
    v93 = re::AssetProviderRegistry::registerAssetProvider(v90, (uint64_t *)&v148);
    if (v92)
    {

      v148 = 0;
    }
  }
  else
  {
    v93 = re::AssetProviderRegistry::registerAssetProvider(v90, (uint64_t *)&v148);
  }
  v94 = re::globalAllocators((re *)v93);
  v95 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v94[2] + 32))(v94[2], 48, 8);
  v96 = re::FallbackAssetProvider::FallbackAssetProvider(v95, *(_QWORD *)(a1 + 1104), *(_QWORD *)(a1 + 1112), *(_QWORD *)(a1 + 1192));
  v97 = *(_QWORD *)(a1 + 1264);
  *(_QWORD *)(a1 + 1264) = v96;
  if (v97)
  {

    v96 = *(_anonymous_namespace_ **)(a1 + 1264);
  }
  v98 = *(os_unfair_lock_s **)(a1 + 1192);
  v147 = v96;
  if (v96)
  {
    v99 = (char *)v96 + 8;
    v100 = (uint64_t)v147;
    v101 = re::AssetProviderRegistry::registerAssetProvider(v98, (uint64_t *)&v147);
    if (v100)
    {

      v147 = 0;
    }
  }
  else
  {
    v101 = re::AssetProviderRegistry::registerAssetProvider(v98, (uint64_t *)&v147);
  }
  v102 = re::globalAllocators((re *)v101);
  v103 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v102[2] + 32))(v102[2], 24, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v103, 0);
  *v103 = &off_24ED2C730;
  if ((v104 & 1) == 0
  {
    re::introspect<re::DynamicString>(void)::info = (uint64_t)re::IntrospectionInfo<re::DynamicString>::get(0, v142);
  }
  MemoryAssetProvider::s_loadDescriptorParametersIntrospect = re::introspect<re::DynamicString>(void)::info;
  v105 = *(os_unfair_lock_s **)(a1 + 1192);
  v146 = v103;
  v106 = v103 + 1;
  v107 = v106;
  re::AssetProviderRegistry::registerAssetProvider(v105, (uint64_t *)&v146);

  v146 = 0;
  v109 = re::globalAllocators(v108);
  v110 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v109[2] + 32))(v109[2], 24, 8);
  v111 = re::PeerAssetProvider::PeerAssetProvider((re::PeerAssetProvider *)v110);
  v112 = *(os_unfair_lock_s **)(a1 + 1192);
  v145 = v111;
  if (v111)
  {
    v113 = (id)(v110 + 8);
    re::AssetProviderRegistry::registerAssetProvider(v112, (uint64_t *)&v145);

    v145 = 0;
  }
  else
  {
    re::AssetProviderRegistry::registerAssetProvider(v112, (uint64_t *)&v145);
  }
  re::MeshPrimitiveProvider::init(*(re::MeshPrimitiveProvider **)(a1 + 1192), *(re::AssetProviderRegistry **)(a1 + 1104), v114);
  v116 = re::globalAllocators(v115);
  v117 = (re::internal::AssetBackgroundLoader *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v116[2] + 32))(v116[2], 448, 64);
  v119 = re::internal::AssetBackgroundLoader::AssetBackgroundLoader(v117, v118);
  *(_QWORD *)(a1 + 1096) = v119;
  v120 = (re *)re::internal::AssetBackgroundLoader::init((uint64_t)v119, *(_QWORD *)(a1 + 1104), a1 + 8, *(_QWORD *)(a1 + 1192), *(_QWORD *)(a1 + 1224), a1 + 16);
  if (*(_QWORD *)(a2 + 16))
  {
    v121 = re::globalAllocators(v120);
    v122 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v121[2] + 32))(v121[2], 320, 64);
    *(_OWORD *)v122 = 0u;
    *(_OWORD *)(v122 + 16) = 0u;
    *(_OWORD *)(v122 + 32) = 0u;
    *(_OWORD *)(v122 + 48) = 0u;
    *(_OWORD *)(v122 + 64) = 0u;
    *(_OWORD *)(v122 + 80) = 0u;
    *(_OWORD *)(v122 + 96) = 0u;
    *(_OWORD *)(v122 + 112) = 0u;
    *(_OWORD *)(v122 + 160) = 0u;
    *(_OWORD *)(v122 + 176) = 0u;
    *(_OWORD *)(v122 + 192) = 0u;
    *(_OWORD *)(v122 + 208) = 0u;
    *(_OWORD *)(v122 + 224) = 0u;
    *(_OWORD *)(v122 + 240) = 0u;
    *(_OWORD *)(v122 + 256) = 0u;
    *(_OWORD *)(v122 + 272) = 0u;
    *(_OWORD *)(v122 + 288) = 0u;
    *(_OWORD *)(v122 + 304) = 0u;
    *(_DWORD *)(v122 + 100) = 0x7FFFFFFF;
    *(_OWORD *)(v122 + 112) = 0u;
    *(_OWORD *)(v122 + 128) = 0u;
    *(_OWORD *)(v122 + 128) = 0u;
    *(_OWORD *)(v122 + 144) = 0u;
    *(_QWORD *)(v122 + 144) = 0x7FFFFFFF00000000;
    *(_QWORD *)(v122 + 232) = 0;
    *(_QWORD *)(v122 + 208) = 0;
    *(_QWORD *)(v122 + 216) = 0;
    *(_QWORD *)(v122 + 200) = 0;
    *(_DWORD *)(v122 + 224) = 0;
    *(_QWORD *)(a1 + 1120) = v122;
    v123 = *(_QWORD *)(a2 + 16);
    if ((v124 & 1) == 0
    {
      re::introspect<re::NetworkAssetSerializationService>(void)::info = re::introspect_NetworkAssetSerializationService(0);
    }
    v125 = re::introspect<re::NetworkAssetSerializationService>(void)::info;
    re::StringID::invalid((re::StringID *)buf);
    v126 = (*(uint64_t (**)(uint64_t, uint64_t, uint8_t *))(*(_QWORD *)v20 + 16))(v20, v125, buf);
    re::StringID::destroyString((re::StringID *)buf);
    v120 = (re *)re::internal::AssetNetworkLoader::init(v122, a1, v123, v126);
  }
  *(_BYTE *)(a1 + 1408) = *(_BYTE *)(a2 + 24);
  if (*(_QWORD *)(a1 + 1128))
  {
    v127 = re::globalAllocators(v120);
    v128 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v127[2] + 32))(v127[2], 88, 8);
    v129 = *(_QWORD *)(a1 + 1128);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)v128, 0);
    *(_QWORD *)v128 = &off_24ED2D058;
    *(_OWORD *)(v128 + 24) = 0u;
    *(_OWORD *)(v128 + 40) = 0u;
    *(_DWORD *)(v128 + 56) = 0;
    *(_QWORD *)(v128 + 60) = 0x7FFFFFFFLL;
    *(_QWORD *)(v128 + 72) = a1;
    *(_QWORD *)(v128 + 80) = v129;
    v130 = *(_QWORD *)(a1 + 720);
    *(_QWORD *)(a1 + 720) = v128;
    if (v130)
    {

      v128 = *(_QWORD *)(a1 + 720);
      v131 = *(_QWORD *)(a1 + 1128);
      v144 = v128;
      if (!v128)
      {
LABEL_91:
        (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v131 + 104))(v131, &v144);
        if (v144)
        {

          v144 = 0;
        }
        goto LABEL_93;
      }
    }
    else
    {
      v131 = *(_QWORD *)(a1 + 1128);
      v144 = v128;
    }
    v132 = (id)(v128 + 8);
    goto LABEL_91;
  }
LABEL_93:
  *(_BYTE *)(a1 + 768) = re::ServiceLocator::serviceOrNull<re::NetworkAssetService>(v20) != 0;
  v143[1] = 0;
  v143[2] = 0;
  v143[0] = 5;
  re::dispatch::Queue::make("com.apple.CoreRE.asset-manager-scheduler-queue", (int *)v143, (NSObject **)buf);
  v133 = (void **)(a1 + 1768);
  if ((uint8_t *)(a1 + 1768) != buf)
  {
    v134 = *(id *)buf;
    *(_QWORD *)buf = 0;
    v135 = *v133;
    *v133 = v134;

  }
  v136 = dispatch_group_create();

  v137 = *(void **)(a1 + 1776);
  *(_QWORD *)(a1 + 1776) = v136;

  v138 = (_QWORD *)operator new();
  *v138 = &off_24ED2C7D0;
  v138[1] = 0;
  v138[2] = 0;
  v138[3] = a1;
  *(_QWORD *)(a1 + 1792) = a1;
  v139 = *(std::__shared_weak_count **)(a1 + 1800);
  *(_QWORD *)(a1 + 1800) = v138;
  if (v139)
  {
    p_shared_owners = (unint64_t *)&v139->__shared_owners_;
    do
      v141 = __ldaxr(p_shared_owners);
    while (__stlxr(v141 - 1, p_shared_owners));
    if (!v141)
    {
      ((void (*)(std::__shared_weak_count *))v139->__on_zero_shared)(v139);
      std::__shared_weak_count::__release_weak(v139);
    }
  }
  if (v110)

}

uint64_t re::ServiceLocator::serviceOrNull<re::ResourceFetchService>(uint64_t a1)
{
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE v6[16];

  if ((v2 & 1) == 0
  {
    re::introspect<re::ResourceFetchService>(void)::info = re::introspect_ResourceFetchService(0);
  }
  v3 = re::introspect<re::ResourceFetchService>(void)::info;
  re::StringID::invalid((re::StringID *)v6);
  v4 = (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *))(*(_QWORD *)a1 + 16))(a1, v3, v6);
  re::StringID::destroyString((re::StringID *)v6);
  return v4;
}

uint64_t re::ServiceLocator::serviceOrNull<re::NetworkAssetService>(uint64_t a1)
{
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE v6[16];

  if ((v2 & 1) == 0
  {
    re::introspect<re::NetworkAssetService>(void)::info = re::introspect_NetworkAssetService(0);
  }
  v3 = re::introspect<re::NetworkAssetService>(void)::info;
  re::StringID::invalid((re::StringID *)v6);
  v4 = (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *))(*(_QWORD *)a1 + 16))(a1, v3, v6);
  re::StringID::destroyString((re::StringID *)v6);
  return v4;
}

uint64_t re::ServiceLocator::serviceOrNull<re::NetworkSendBlockingAssetLoadRequestService>(uint64_t a1)
{
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t v4;
  _BYTE v6[16];

  if ((v2 & 1) == 0
  {
    re::introspect<re::NetworkSendBlockingAssetLoadRequestService>(void)::info = re::introspect_NetworkSendBlockingAssetLoadRequestService(0);
  }
  v3 = re::introspect<re::NetworkSendBlockingAssetLoadRequestService>(void)::info;
  re::StringID::invalid((re::StringID *)v6);
  v4 = (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *))(*(_QWORD *)a1 + 16))(a1, v3, v6);
  re::StringID::destroyString((re::StringID *)v6);
  return v4;
}

void re::AssetManager::deinit(re::AssetManager *this)
{
  re *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  _anonymous_namespace_ *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  void *v16;
  _anonymous_namespace_ *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  id v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  id v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  re::internal::AssetNetworkLoader *v34;
  re *v35;
  uint64_t v36;
  uint64_t v37;
  double v38;
  __n128 v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  re::AssetHandle *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int *v55;
  int v56;
  unint64_t v57;
  _QWORD *v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  id *v64;
  uint64_t v65;
  char v66;
  id WeakRetained;
  void *v68;
  BOOL v69;
  BOOL v70;
  uint64_t v71;
  _anonymous_namespace_ *v72;
  _QWORD *v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  int v77;
  int v78;
  unint64_t v79;
  _QWORD *v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unsigned int v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  uint64_t i;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _QWORD *v106;
  uint64_t v107;
  _QWORD *v108;
  uint64_t v109;
  _QWORD *v110;
  uint64_t v111;
  double v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t *v117;
  re *v118;
  uint64_t v119;
  uint64_t v120;
  double v121;
  uint64_t v122;
  os_unfair_lock_s *v123;
  re *v124;
  uint64_t v125;
  uint64_t v126;
  double v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  os_unfair_lock_s *v131;
  re *v132;
  uint64_t v133;
  uint64_t v134;
  double v135;
  uint64_t v136;
  re *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  double v145;
  re *v146;
  uint64_t v147;
  uint64_t v148;
  double v149;
  __n128 v150;
  uint64_t v151;
  uint64_t *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  re *v156;
  uint64_t v157;
  uint64_t v158;
  double v159;
  re *v160;
  re::internal::AssetTypeRegistry *v161;
  uint64_t v162;
  std::__shared_weak_count *v163;
  unint64_t *p_shared_owners;
  unint64_t v165;
  os_unfair_lock_s *v166;
  int v167;
  unsigned int v168;
  os_unfair_lock_s *v169;
  os_unfair_lock_s *lock;
  int v171;
  int v172;
  uint64_t v173;
  _QWORD *v174;
  int v175;
  unint64_t v176;
  _QWORD *v177;
  _QWORD v178[3];
  uint64_t *v179;
  unint64_t v180;
  unint64_t v181;
  int v182;
  _QWORD *v183;
  __int128 v184;
  __int128 v185;
  _BYTE v186[12];
  uint64_t v187;
  _QWORD block[6];

  atomic_store(1u, (unsigned __int8 *)this + 1409);
  v2 = (re *)*((_QWORD *)this + 151);
  if (v2)
    v2 = (re *)(*(uint64_t (**)(re *, _QWORD))(*(_QWORD *)v2 + 208))(v2, 0);
  v3 = *((_QWORD *)this + 89);
  if (v3)
  {
    v4 = re::globalAllocators(v2);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v4[2] + 40))(v4[2], v3);
    *((_QWORD *)this + 89) = 0;
  }
  *((_QWORD *)this + 151) = 0;
  *((_QWORD *)this + 153) = 0;
  while (1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 128);
    v5 = *((_QWORD *)this + 67);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 128);
    if (!v5)
      break;
    re::AssetManager::processDeferredPointerUnload((os_unfair_lock_s *)this);
  }
  *(_QWORD *)v186 = 0;
  *((_QWORD *)&v184 + 1) = 0;
  *(_QWORD *)&v185 = 0;
  DWORD2(v185) = 0;
  lock = (os_unfair_lock_s *)((char *)this + 64);
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  v6 = *((unsigned int *)this + 25);
  re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(&v184, v6);
  v8 = ++DWORD2(v185);
  v9 = *((unsigned int *)this + 26);
  if ((_DWORD)v9)
  {
    v10 = 0;
    v11 = (int *)(*((_QWORD *)this + 11) + 8);
    while (1)
    {
      v12 = *v11;
      v11 += 14;
      if (v12 < 0)
        break;
      if (v9 == ++v10)
      {
        LODWORD(v10) = *((_DWORD *)this + 26);
        break;
      }
    }
  }
  else
  {
    LODWORD(v10) = 0;
  }
  if ((_DWORD)v9 != (_DWORD)v10)
  {
    v13 = v10;
    v14 = *((_DWORD *)this + 26);
    do
    {
      v15 = *(_QWORD *)(*((_QWORD *)this + 11) + 56 * v13 + 48);
      if (v15)
      {
        v16 = (void *)(v15 + 8);
        v17 = (_anonymous_namespace_ *)(id)(v15 + 8);
        v18 = v185;
        if ((unint64_t)v185 >= *((_QWORD *)&v184 + 1))
        {
          v19 = v185 + 1;
          if (*((_QWORD *)&v184 + 1) < (unint64_t)(v185 + 1))
          {
            if ((_QWORD)v184)
            {
              if (*((_QWORD *)&v184 + 1))
                v20 = 2 * *((_QWORD *)&v184 + 1);
              else
                v20 = 8;
              if (v20 <= v19)
                v21 = v185 + 1;
              else
                v21 = v20;
              re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(&v184, v21);
              v8 = DWORD2(v185);
            }
            else
            {
              re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(&v184, v19);
              v8 = DWORD2(v185) + 1;
            }
          }
          v18 = v185;
        }
        *(_QWORD *)(*(_QWORD *)v186 + 8 * v18) = v15;
        v22 = v16;
        *(_QWORD *)&v185 = v18 + 1;
        DWORD2(v185) = ++v8;

        v14 = *((_DWORD *)this + 26);
      }
      if (v14 <= (int)v10 + 1)
        v23 = v10 + 1;
      else
        v23 = v14;
      while (1)
      {
        v13 = (v10 + 1);
        if (v23 - 1 == (_DWORD)v10)
          break;
        LODWORD(v10) = v10 + 1;
        v24 = v13;
        if ((*(_DWORD *)(*((_QWORD *)this + 11) + 56 * v13 + 8) & 0x80000000) != 0)
          goto LABEL_37;
      }
      v24 = v23;
LABEL_37:
      LODWORD(v10) = v24;
    }
    while ((_DWORD)v9 != v24);
  }
  os_unfair_lock_unlock(lock);
  v25 = *(_QWORD *)v186;
  if (!(_QWORD)v185)
  {
    v31 = v184;
    if (!(_QWORD)v184 || !*(_QWORD *)v186)
      goto LABEL_62;
    goto LABEL_61;
  }
  v26 = 0;
  v27 = 8 * v185;
  do
  {
    v28 = *(_QWORD *)(v25 + v26);
    if (v28)
    {
      v29 = (id)(v28 + 8);
      os_unfair_lock_lock((os_unfair_lock_t)(v28 + 384));
      v30 = *(_QWORD *)(v28 + 400);
      if (v30 && !*(_DWORD *)(v30 + 16) && !*(_QWORD *)(v28 + 720))
        atomic_store(1u, (unsigned __int8 *)(*(_QWORD *)(v30 + 48) + 24));
      os_unfair_lock_unlock((os_unfair_lock_t)(v28 + 384));

    }
    else
    {
      os_unfair_lock_lock((os_unfair_lock_t)0x180);
      if (MEMORY[0x190] && !*(_DWORD *)(MEMORY[0x190] + 16) && !MEMORY[0x2D0])
        atomic_store(1u, (unsigned __int8 *)(*(_QWORD *)(MEMORY[0x190] + 48) + 24));
      os_unfair_lock_unlock((os_unfair_lock_t)0x180);
    }
    v26 += 8;
  }
  while (v27 != v26);
  v31 = v184;
  if ((_QWORD)v184 && v25)
  {
    v32 = v25;
    do
    {
      if (*(_QWORD *)v32)
      {

        *(_QWORD *)v32 = 0;
      }
      v32 += 8;
      v27 -= 8;
    }
    while (v27);
LABEL_61:
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v31 + 40))(v31, v25);
  }
LABEL_62:
  while (1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)this + 336);
    v33 = *((_QWORD *)this + 171);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 336);
    if (!v33)
      break;
    re::internal::AssetBackgroundLoader::waitForActiveLoadItemsToComplete(*((re::internal::AssetBackgroundLoader **)this
                                                                          + 137));
    re::AssetManager::update(this, 0, 0);
  }
  if (!*((_BYTE *)this + 1410))
  {
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 0x40000000;
    block[2] = ___ZN2re12AssetManager6deinitEv_block_invoke;
    block[3] = &__block_descriptor_tmp_0;
    block[4] = this;
    dispatch_sync(*((dispatch_queue_t *)this + 221), block);
    if (!*((_QWORD *)this + 112) || dispatch_get_specific((char *)this + 896) != (char *)this + 896)
      dispatch_group_wait(*((dispatch_group_t *)this + 222), 0xFFFFFFFFFFFFFFFFLL);
    v34 = (re::internal::AssetNetworkLoader *)*((_QWORD *)this + 140);
    if (v34)
    {
      v35 = (re *)re::internal::AssetNetworkLoader::deinit(v34);
      v36 = *((_QWORD *)this + 140);
      if (v36)
      {
        v37 = re::globalAllocators(v35)[2];

        re::DynamicArray<re::internal::AssetNetworkLoader::SerializedAssetResponse>::deinit(v36 + 200);
        re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::FragmentedNetworkAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v36 + 112), v38);
        v39.n128_f64[0] = re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::PendingRequestedAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v36 + 64));
        v40 = *(_QWORD *)(v36 + 24);
        if (v40)
        {
          v41 = *(_QWORD *)(v36 + 56);
          if (v41)
          {
            v42 = *(_QWORD *)(v36 + 40);
            if (v42)
            {
              v43 = v42 << 6;
              v44 = (re::AssetHandle *)(v41 + 40);
              do
              {
                re::AssetHandle::~AssetHandle(v44);
                v45 = *((_QWORD *)v44 - 4);
                if (v45)
                {
                  if ((*((_BYTE *)v44 - 24) & 1) != 0)
                    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v45 + 40))(v45, *((_QWORD *)v44 - 2));
                  v39 = 0uLL;
                  *((_OWORD *)v44 - 2) = 0u;
                  *((_OWORD *)v44 - 1) = 0u;
                }
                v44 = (re::AssetHandle *)((char *)v44 + 64);
                v43 -= 64;
              }
              while (v43);
              v40 = *(_QWORD *)(v36 + 24);
              v41 = *(_QWORD *)(v36 + 56);
            }
            (*(void (**)(uint64_t, uint64_t, __n128))(*(_QWORD *)v40 + 40))(v40, v41, v39);
          }
          *(_QWORD *)(v36 + 56) = 0;
          *(_QWORD *)(v36 + 32) = 0;
          *(_QWORD *)(v36 + 40) = 0;
          *(_QWORD *)(v36 + 24) = 0;
          ++*(_DWORD *)(v36 + 48);
        }
        (*(void (**)(uint64_t, uint64_t, __n128))(*(_QWORD *)v37 + 40))(v37, v36, v39);
      }
      *((_QWORD *)this + 140) = 0;
    }
    v46 = *((_QWORD *)this + 141);
    if (v46)
    {
      v187 = 0;
      (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v46 + 104))(v46, &v187);
      if (v187)
      {

        v187 = 0;
      }
    }
    v47 = *((_QWORD *)this + 90);
    if (v47)
    {

      *((_QWORD *)this + 90) = 0;
    }
    os_unfair_lock_lock(lock);
    *((_QWORD *)this + 142) = 0;
    v48 = *((_QWORD *)this + 5);
    *((_QWORD *)this + 5) = 0;
    if (v48)
    {
      v49 = *((_QWORD *)this + 7);
      v50 = 8 * v48;
      do
      {
        if (*(_QWORD *)v49)
        {

          *(_QWORD *)v49 = 0;
        }
        v49 += 8;
        v50 -= 8;
      }
      while (v50);
    }
    v171 = 0;
    v51 = 0;
    v168 = 0;
    v52 = 0;
    ++*((_DWORD *)this + 12);
    *(_DWORD *)v186 = 0;
    v184 = 0u;
    v185 = 0u;
    *(_QWORD *)&v186[4] = 0x7FFFFFFFLL;
    v169 = (os_unfair_lock_s *)((char *)this + 640);
    do
    {
      v183 = 0;
      v180 = 0;
      v181 = 0;
      v179 = 0;
      v182 = 0;
      v53 = *((unsigned int *)this + 26);
      if ((_DWORD)v53)
      {
        v54 = 0;
        v55 = (int *)(*((_QWORD *)this + 11) + 8);
        while (1)
        {
          v56 = *v55;
          v55 += 14;
          if (v56 < 0)
            break;
          if (v53 == ++v54)
          {
            LODWORD(v54) = *((_DWORD *)this + 26);
            break;
          }
        }
      }
      else
      {
        LODWORD(v54) = 0;
      }
      v167 = v51;
      if ((_DWORD)v53 == (_DWORD)v54)
      {
        v57 = 0;
        v58 = 0;
      }
      else
      {
        v59 = 0;
        v173 = v52;
        v174 = 0;
        v57 = 0;
        v60 = v54;
        v172 = *((_DWORD *)this + 26);
        do
        {
          v61 = *((_QWORD *)this + 11) + 56 * v60;
          v62 = *(_QWORD *)(v61 + 48);
          if (v62
            && !re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::contains((uint64_t)&v184, *(_QWORD *)(v61 + 48)))
          {
            v63 = *(_QWORD *)(v62 + 288);
            if (!v63)
              goto LABEL_112;
            v175 = v59;
            v176 = v57;
            v64 = *(id **)(v62 + 304);
            v65 = 8 * v63 - 8;
            v66 = 1;
            do
            {
              WeakRetained = objc_loadWeakRetained(v64);
              if (WeakRetained)
              {
                v68 = WeakRetained;
                v69 = re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::contains((uint64_t)&v184, (unint64_t)WeakRetained - 8);
                v70 = !v69;
                v66 &= v69;

                if (v70)
                  break;
              }
              ++v64;
              v71 = v65;
              v65 -= 8;
            }
            while (v71);
            LODWORD(v53) = v172;
            v52 = v173;
            v57 = v176;
            v59 = v175;
            if ((v66 & 1) != 0)
            {
LABEL_112:
              re::AssetManager::unloadAssetAsync((uint64_t)this, v62, 0);
              re::internal::AssetEntry::removeFromAssetManager((os_unfair_lock_s *)v62);
              if (v57 >= v180)
              {
                v74 = v57 + 1;
                if (v180 < v74)
                {
                  if (v179)
                  {
                    v75 = 8;
                    if (v180)
                      v75 = 2 * v180;
                    if (v75 <= v74)
                      v76 = v74;
                    else
                      v76 = v75;
                    re::DynamicArray<float *>::setCapacity(&v179, v76);
                    v59 = v182;
                  }
                  else
                  {
                    re::DynamicArray<float *>::setCapacity(&v179, v74);
                    v59 = v182 + 1;
                  }
                }
                v57 = v181;
                v73 = v183;
              }
              else
              {
                v73 = v174;
              }
              v174 = v73;
              v73[v57++] = v62;
              v181 = v57;
              v182 = ++v59;
            }
          }
          if (*((_DWORD *)this + 26) <= (v54 + 1))
            v77 = v54 + 1;
          else
            v77 = *((_DWORD *)this + 26);
          while (1)
          {
            v60 = (v54 + 1);
            if (v77 - 1 == (_DWORD)v54)
              break;
            LODWORD(v54) = v54 + 1;
            v78 = v60;
            if ((*(_DWORD *)(*((_QWORD *)this + 11) + 56 * v60 + 8) & 0x80000000) != 0)
              goto LABEL_132;
          }
          v78 = v77;
LABEL_132:
          LODWORD(v54) = v78;
        }
        while ((_DWORD)v53 != v78);
        v58 = v183;
      }
      os_unfair_lock_unlock(lock);
      v178[0] = dispatch_time(0, 0);
      v178[1] = -1;
      v178[2] = -1;
      re::AssetManager::processUnreferencedUnloadRequests((uint64_t)this, (uint64_t)v178);
      re::AssetManager::waitForLoadQueueToComplete((uint64_t)this, 0);
      v79 = v57;
      v80 = &v58[v57];
      v177 = v58;
      v81 = v171;
      v51 = v167;
      v82 = v168;
      if (v79)
      {
        do
        {
          v83 = *v58;
          v84 = 0xBF58476D1CE4E5B9 * (*v58 ^ (*v58 >> 30));
          v85 = (0x94D049BB133111EBLL * (v84 ^ (v84 >> 27))) ^ ((0x94D049BB133111EBLL * (v84 ^ (v84 >> 27))) >> 31);
          if ((_DWORD)v52)
          {
            v86 = v85 % v52;
            v87 = *(unsigned int *)(*((_QWORD *)&v184 + 1) + 4 * v86);
            if ((_DWORD)v87 != 0x7FFFFFFF)
            {
              while (*(_QWORD *)(v185 + 24 * v87 + 16) != v83)
              {
                LODWORD(v87) = *(_DWORD *)(v185 + 24 * v87 + 8) & 0x7FFFFFFF;
                if ((_DWORD)v87 == 0x7FFFFFFF)
                  goto LABEL_141;
              }
              goto LABEL_147;
            }
          }
          else
          {
            v86 = 0;
          }
LABEL_141:
          v88 = *(_DWORD *)&v186[4];
          if (*(_DWORD *)&v186[4] == 0x7FFFFFFF)
          {
            v89 = v82;
            if ((_DWORD)v82 == (_DWORD)v52)
            {
              re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::setCapacity((uint64_t)&v184, 2 * v81);
              v52 = DWORD2(v185);
              v81 = HIDWORD(v185);
              v86 = v85 % DWORD2(v185);
              v83 = *v58;
              v89 = *(_DWORD *)v186;
              v51 = *(_DWORD *)&v186[8];
            }
            v90 = (v89 + 1);
            *(_DWORD *)v186 = v90;
            v91 = v185;
            v88 = v82;
            v92 = *(_DWORD *)(v185 + 24 * v82 + 8);
          }
          else
          {
            v91 = v185;
            v92 = *(_DWORD *)(v185 + 24 * *(unsigned int *)&v186[4] + 8);
            *(_DWORD *)&v186[4] = v92 & 0x7FFFFFFF;
            v90 = v82;
            LODWORD(v82) = v88;
          }
          v93 = v91 + 24 * v88;
          *(_DWORD *)(v93 + 8) = v92 | 0x80000000;
          v94 = *((_QWORD *)&v184 + 1);
          *(_DWORD *)(v93 + 8) = *(_DWORD *)(*((_QWORD *)&v184 + 1) + 4 * v86) | 0x80000000;
          *(_QWORD *)v93 = v85;
          *(_QWORD *)(v93 + 16) = v83;
          *(_DWORD *)(v94 + 4 * v86) = v82;
          ++v81;
          ++v51;
          HIDWORD(v185) = v81;
          *(_DWORD *)&v186[8] = v51;
          v82 = v90;
LABEL_147:
          ++v58;
        }
        while (v58 != v80);
      }
      v168 = v82;
      v171 = v81;
      v95 = v52;
      os_unfair_lock_lock(v169);
      v96 = *((_QWORD *)this + 83);
      if (v96)
      {
        v97 = 0;
        for (i = 0; i != v96; ++i)
        {
          v99 = (unint64_t)(i + *((_QWORD *)this + 84)) % *((_QWORD *)this + 82);
          v100 = *((_QWORD *)this + 86);
          if (re::AssetLoadRequest::Data::tryStopRequest(*(os_unfair_lock_s **)(v100 + 8 * v99)))
            *(_QWORD *)(*(_QWORD *)(v100 + 8 * v99) + 24) = 0;
          else
            v97 = 1;
        }
      }
      else
      {
        v97 = 0;
      }
      os_unfair_lock_unlock(v169);
      os_unfair_lock_lock(lock);
      if (v179 && v177)
        (*(void (**)(void))(*v179 + 40))();
      v52 = v95;
    }
    while (v171 != *((_DWORD *)this + 25) || v97);
    re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::deinit((uint64_t)this + 968);
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v184);
    v101 = *((_QWORD *)this + 199);
    *((_QWORD *)this + 199) = 0;
    if (v101)
    {
      v102 = *((_QWORD *)this + 201);
      v103 = 40 * v101;
      do
      {
        re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v102);
        v102 += 40;
        v103 -= 40;
      }
      while (v103);
    }
    ++*((_DWORD *)this + 400);
    os_unfair_lock_lock(v169);
    re::Queue<re::SharedPtr<re::AssetLoadRequest::Data>>::deinit((uint64_t *)this + 81);
    os_unfair_lock_unlock(v169);
    os_unfair_lock_lock((os_unfair_lock_t)this + 112);
    v104 = *((_QWORD *)this + 59);
    if (v104)
    {
      v105 = 32 * v104;
      v106 = (_QWORD *)(*((_QWORD *)this + 61) + 24);
      do
      {
        if (!*v106)
        {
          v166 = (os_unfair_lock_s *)std::__throw_bad_function_call[abi:nn180100]();
          re::AssetManager::processDeferredPointerUnload(v166);
          return;
        }
        (*(void (**)(_QWORD))(*(_QWORD *)*v106 + 48))(*v106);
        v106 += 4;
        v105 -= 32;
      }
      while (v105);
      v107 = *((_QWORD *)this + 59);
      v108 = (_QWORD *)*((_QWORD *)this + 61);
      *((_QWORD *)this + 59) = 0;
      if (v107)
      {
        v109 = 32 * v107;
        while (1)
        {
          v110 = (_QWORD *)v108[3];
          if (v108 == v110)
            break;
          if (v110)
          {
            v111 = 5;
LABEL_174:
            (*(void (**)(void))(*v110 + 8 * v111))();
          }
          v108 += 4;
          v109 -= 32;
          if (!v109)
            goto LABEL_178;
        }
        v110 = v108;
        v111 = 4;
        goto LABEL_174;
      }
    }
    else
    {
      *((_QWORD *)this + 59) = 0;
    }
LABEL_178:
    ++*((_DWORD *)this + 120);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 112);
    os_unfair_lock_lock((os_unfair_lock_t)this + 208);
    re::DynamicArray<re::NetworkActionQueue::Action>::clear((uint64_t)this + 840);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 208);
    v112 = re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 9);
    *((_QWORD *)this + 141) = 0;
    v113 = *((_QWORD *)this + 158);
    if (v113)
    {

      *((_QWORD *)this + 158) = 0;
    }
    v114 = *((_QWORD *)this + 157);
    if (v114)
    {

      *((_QWORD *)this + 157) = 0;
    }
    v115 = *((_QWORD *)this + 156);
    if (v115)
    {

      *((_QWORD *)this + 156) = 0;
    }
    v116 = *((_QWORD *)this + 155);
    v117 = (uint64_t *)(v116 + 8);
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v116 + 32), v112);
    std::__list_imp<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>>::clear(v117);
    v119 = *((_QWORD *)this + 155);
    if (v119)
    {
      v120 = re::globalAllocators(v118)[2];
      v121 = re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)(v119 + 88));
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v119 + 32), v121);
      std::__list_imp<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>>::clear((uint64_t *)(v119 + 8));

      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v120 + 40))(v120, v119);
    }
    *((_QWORD *)this + 155) = 0;
    v122 = *((_QWORD *)this + 161);
    if (v122)
    {

      *((_QWORD *)this + 161) = 0;
    }
    v123 = (os_unfair_lock_s *)*((_QWORD *)this + 162);
    os_unfair_lock_lock(v123);
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear((uint64_t)&v123[2]);
    os_unfair_lock_unlock(v123);
    v125 = *((_QWORD *)this + 162);
    if (v125)
    {
      v126 = re::globalAllocators(v124)[2];
      v127 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v125 + 8));
      (*(void (**)(uint64_t, uint64_t, double))(*(_QWORD *)v126 + 40))(v126, v125, v127);
    }
    *((_QWORD *)this + 162) = 0;
    v128 = *((_QWORD *)this + 160);
    if (v128)
    {

      *((_QWORD *)this + 160) = 0;
    }
    v129 = *((_QWORD *)this + 150);
    if (v129)
    {

      *((_QWORD *)this + 150) = 0;
    }
    v130 = *((_QWORD *)this + 154);
    if (v130)
    {

      *((_QWORD *)this + 154) = 0;
    }
    v131 = (os_unfair_lock_s *)*((_QWORD *)this + 163);
    os_unfair_lock_lock(v131);
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear((uint64_t)&v131[2]);
    os_unfair_lock_unlock(v131);
    v133 = *((_QWORD *)this + 163);
    if (v133)
    {
      v134 = re::globalAllocators(v132)[2];
      v135 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v133 + 8));
      (*(void (**)(uint64_t, uint64_t, double))(*(_QWORD *)v134 + 40))(v134, v133, v135);
    }
    *((_QWORD *)this + 163) = 0;
    v136 = *((_QWORD *)this + 169);
    if (v136)
    {
      if (*((_QWORD *)this + 173))
        (*(void (**)(uint64_t))(*(_QWORD *)v136 + 40))(v136);
      *((_QWORD *)this + 173) = 0;
      *((_QWORD *)this + 170) = 0;
      *((_QWORD *)this + 171) = 0;
      *((_QWORD *)this + 169) = 0;
      ++*((_DWORD *)this + 344);
    }
    v137 = (re *)dispatch_group_wait(*(dispatch_group_t *)(*((_QWORD *)this + 137) + 384), 0xFFFFFFFFFFFFFFFFLL);
    v138 = *((_QWORD *)this + 137);
    if (v138)
    {
      v139 = re::globalAllocators(v137)[2];

      v140 = *(_QWORD *)(v138 + 264);
      if (v140)
      {
        if (*(_QWORD *)(v138 + 304))
          (*(void (**)(uint64_t))(*(_QWORD *)v140 + 40))(v140);
        *(_QWORD *)(v138 + 304) = 0;
        *(_OWORD *)(v138 + 264) = 0u;
        *(_OWORD *)(v138 + 280) = 0u;
        *(_DWORD *)(v138 + 296) = 0;
      }
      v141 = *(_QWORD *)(v138 + 200);
      if (v141)
      {
        if (*(_QWORD *)(v138 + 232))
          (*(void (**)(uint64_t))(*(_QWORD *)v141 + 40))(v141);
        *(_QWORD *)(v138 + 232) = 0;
        *(_QWORD *)(v138 + 208) = 0;
        *(_QWORD *)(v138 + 216) = 0;
        *(_QWORD *)(v138 + 200) = 0;
        ++*(_DWORD *)(v138 + 224);
      }
      v142 = *(_QWORD *)(v138 + 136);
      if (v142)
      {
        if (*(_QWORD *)(v138 + 176))
          (*(void (**)(uint64_t))(*(_QWORD *)v142 + 40))(v142);
        *(_QWORD *)(v138 + 176) = 0;
        *(_OWORD *)(v138 + 136) = 0u;
        *(_OWORD *)(v138 + 152) = 0u;
        *(_DWORD *)(v138 + 168) = 0;
      }
      v143 = *(_QWORD *)(v138 + 72);
      if (v143)
      {
        if (*(_QWORD *)(v138 + 112))
          (*(void (**)(uint64_t))(*(_QWORD *)v143 + 40))(v143);
        *(_QWORD *)(v138 + 112) = 0;
        *(_OWORD *)(v138 + 72) = 0u;
        *(_OWORD *)(v138 + 88) = 0u;
        *(_DWORD *)(v138 + 104) = 0;
      }
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v139 + 40))(v139, v138);
    }
    *((_QWORD *)this + 137) = 0;
    v144 = *((_QWORD *)this + 139);
    re::DynamicArray<std::unique_ptr<re::AssetCompiler,std::function<void ()(re::AssetCompiler*)>>>::clear((uint64_t *)(v144 + 8));
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(v144 + 48);
    re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v144 + 48), v145);
    v147 = *((_QWORD *)this + 139);
    if (v147)
    {
      v148 = re::globalAllocators(v146)[2];
      *(_QWORD *)v147 = &off_24ED7F1E8;
      v150.n128_f64[0] = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v147 + 48), v149);
      v151 = *(_QWORD *)(v147 + 8);
      if (v151)
      {
        v152 = *(uint64_t **)(v147 + 40);
        if (v152)
        {
          v153 = *(_QWORD *)(v147 + 24);
          if (v153)
          {
            v154 = 40 * v153;
            do
            {
              std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](v152);
              v152 += 5;
              v154 -= 40;
            }
            while (v154);
            v151 = *(_QWORD *)(v147 + 8);
            v152 = *(uint64_t **)(v147 + 40);
          }
          (*(void (**)(uint64_t, uint64_t *, __n128))(*(_QWORD *)v151 + 40))(v151, v152, v150);
        }
        *(_QWORD *)(v147 + 40) = 0;
        *(_QWORD *)(v147 + 16) = 0;
        *(_QWORD *)(v147 + 24) = 0;
        *(_QWORD *)(v147 + 8) = 0;
        ++*(_DWORD *)(v147 + 32);
      }
      (*(void (**)(uint64_t, uint64_t, __n128))(*(_QWORD *)v148 + 40))(v148, v147, v150);
    }
    *((_QWORD *)this + 139) = 0;
    v155 = *((_QWORD *)this + 149);
    re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(v155 + 72);
    re::HashTable<re::DynamicString,re::SharedPtr<re::AssetProvider>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(v155 + 120);
    v157 = *((_QWORD *)this + 149);
    if (v157)
    {
      v158 = re::globalAllocators(v156)[2];
      re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v157 + 120));
      v159 = re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v157 + 72));
      (*(void (**)(uint64_t, uint64_t, double))(*(_QWORD *)v158 + 40))(v158, v157, v159);
    }
    *((_QWORD *)this + 149) = 0;
    re::internal::AssetTypeRegistry::deinit(*((re::internal::AssetTypeRegistry **)this + 138));
    v161 = (re::internal::AssetTypeRegistry *)*((_QWORD *)this + 138);
    if (v161)
    {
      v162 = re::globalAllocators(v160)[2];
      re::internal::AssetTypeRegistry::~AssetTypeRegistry(v161);
      (*(void (**)(uint64_t, re::internal::AssetTypeRegistry *))(*(_QWORD *)v162 + 40))(v162, v161);
    }
    *((_QWORD *)this + 138) = 0;
    v163 = (std::__shared_weak_count *)*((_QWORD *)this + 225);
    *((_OWORD *)this + 112) = 0u;
    if (v163)
    {
      p_shared_owners = (unint64_t *)&v163->__shared_owners_;
      do
        v165 = __ldaxr(p_shared_owners);
      while (__stlxr(v165 - 1, p_shared_owners));
      if (!v165)
      {
        ((void (*)(std::__shared_weak_count *))v163->__on_zero_shared)(v163);
        std::__shared_weak_count::__release_weak(v163);
      }
    }
    re::internal::EngineQueueCheck::deinit((dispatch_queue_t *)this + 112);
    os_unfair_lock_unlock(lock);
  }
}

uint64_t re::AssetManager::processDeferredPointerUnload(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  _anonymous_namespace_ *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned int v7;
  re *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  BOOL v22;
  uint64_t result;
  uint64_t v24;
  __int128 v25;
  int v26;
  uint64_t *v27;
  uint64_t v28;
  __int128 v29;
  int v30;
  _QWORD *v31;
  uint64_t v32;

  v2 = this + 128;
  os_unfair_lock_lock(this + 128);
  v3 = (_anonymous_namespace_ *)&this[130];
  v27 = 0;
  v28 = 0;
  v24 = 0;
  v29 = 0u;
  v25 = 0u;
  v31 = 0;
  v26 = 1;
  v30 = 1;
  re::DynamicArray<re::internal::DeferredUnregister *>::operator=((uint64_t)&v24, (uint64_t)&this[130]);
  re::DynamicArray<re::internal::DeferredUnregister *>::operator=((uint64_t)&this[130], (uint64_t)&v28);
  if (v28 && v31)
    (*(void (**)(void))(*(_QWORD *)v28 + 40))();
  os_unfair_lock_unlock(v2);
  if (*((_QWORD *)&v25 + 1))
  {
    v31 = 0;
    v29 = 0uLL;
    v28 = 0;
    v30 = 0;
    v4 = 8 * *((_QWORD *)&v25 + 1);
    v5 = v27;
    do
    {
      v6 = *v5;
      v32 = v6;
      v7 = *(_DWORD *)(v6 + 240) + 1;
      *(_DWORD *)(v6 + 240) = v7;
      if (v7 < 2)
      {
        re::DynamicArray<re::RigDataValue *>::add((_anonymous_namespace_ *)&v28, &v32);
      }
      else
      {
        re::AssetManager::internalUnloadSharedAssetPointer((re::AssetManager *)this, *(void **)v6, (const re::ExistingAssetInformation *)(v6 + 8), *(const re::AssetType **)(v6 + 232));
        v9 = re::globalAllocators(v8)[2];
        v10 = *(_QWORD *)(v6 + 200);
        if (v10)
        {
          if ((*(_BYTE *)(v6 + 208) & 1) != 0)
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 40))(v10, *(_QWORD *)(v6 + 216));
          *(_OWORD *)(v6 + 200) = 0u;
          *(_OWORD *)(v6 + 216) = 0u;
        }
        v11 = *(_QWORD *)(v6 + 168);
        if (v11)
        {
          if ((*(_BYTE *)(v6 + 176) & 1) != 0)
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v11 + 40))(v11, *(_QWORD *)(v6 + 184));
          *(_OWORD *)(v6 + 168) = 0u;
          *(_OWORD *)(v6 + 184) = 0u;
        }
        v12 = *(_QWORD *)(v6 + 136);
        if (v12)
        {
          if ((*(_BYTE *)(v6 + 144) & 1) != 0)
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 40))(v12, *(_QWORD *)(v6 + 152));
          *(_OWORD *)(v6 + 136) = 0u;
          *(_OWORD *)(v6 + 152) = 0u;
        }
        v13 = *(_QWORD *)(v6 + 104);
        if (v13)
        {
          if ((*(_BYTE *)(v6 + 112) & 1) != 0)
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 40))(v13, *(_QWORD *)(v6 + 120));
          *(_OWORD *)(v6 + 104) = 0u;
          *(_OWORD *)(v6 + 120) = 0u;
        }
        v14 = *(_QWORD *)(v6 + 48);
        if (v14)
        {
          if ((*(_BYTE *)(v6 + 56) & 1) != 0)
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v14 + 40))(v14, *(_QWORD *)(v6 + 64));
          *(_OWORD *)(v6 + 48) = 0u;
          *(_OWORD *)(v6 + 64) = 0u;
        }
        v15 = *(_QWORD *)(v6 + 16);
        if (v15)
        {
          if ((*(_BYTE *)(v6 + 24) & 1) != 0)
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v15 + 40))(v15, *(_QWORD *)(v6 + 32));
          *(_OWORD *)(v6 + 16) = 0u;
          *(_OWORD *)(v6 + 32) = 0u;
        }
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 40))(v9, v6);
      }
      ++v5;
      v4 -= 8;
    }
    while (v4);
    os_unfair_lock_lock(v2);
    v16 = *((_QWORD *)&v29 + 1);
    v17 = *((_QWORD *)&v29 + 1) + *(_QWORD *)&this[134]._os_unfair_lock_opaque;
    if (*(_QWORD *)&this[132]._os_unfair_lock_opaque < v17)
      re::DynamicArray<float *>::setCapacity(&this[130]._os_unfair_lock_opaque, v17);
    v18 = v31;
    if (v16)
    {
      v19 = 8 * v16;
      v20 = v31;
      do
      {
        v21 = *v20++;
        v32 = v21;
        re::DynamicArray<re::RigDataValue *>::add(v3, &v32);
        v19 -= 8;
      }
      while (v19);
    }
    os_unfair_lock_unlock(v2);
    if (v28)
      v22 = v18 == 0;
    else
      v22 = 1;
    if (!v22)
      (*(void (**)(void))(*(_QWORD *)v28 + 40))();
  }
  result = v24;
  if (v24)
  {
    if (v27)
      return (*(uint64_t (**)(void))(*(_QWORD *)v24 + 40))();
  }
  return result;
}

_QWORD *re::AssetManager::update(re::AssetManager *this, unsigned int a2, int a3)
{
  uint64_t v3;
  _QWORD *result;
  uint64_t v5;
  _QWORD v6[3];
  _QWORD *v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v3 = 256;
  if (!a3)
    v3 = 0;
  v6[0] = &off_24ED2C830;
  v6[1] = this;
  v6[2] = v3 | a2;
  v7 = v6;
  re::runInLocalAutoreleasePool((uint64_t)v6);
  result = v7;
  if (v7 == v6)
  {
    v5 = 4;
    result = v6;
  }
  else
  {
    if (!v7)
      return result;
    v5 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v5))();
}

uint64_t ___ZN2re12AssetManager6deinitEv_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 32) + 1410) = 1;
  return result;
}

BOOL re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::contains(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;

  v2 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v2)
    return 0;
  v3 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v3 ^ (v3 >> 31)) % v2));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v6 + 24 * v4 + 16) == a2)
    return 1;
  do
  {
    LODWORD(v4) = *(_DWORD *)(v6 + 24 * v4 + 8) & 0x7FFFFFFF;
    result = (_DWORD)v4 != 0x7FFFFFFF;
  }
  while ((_DWORD)v4 != 0x7FFFFFFF && *(_QWORD *)(v6 + 24 * v4 + 16) != a2);
  return result;
}

void re::AssetManager::unloadAssetAsync(uint64_t a1, uint64_t a2, int a3)
{
  os_unfair_lock_s *v6;
  _anonymous_namespace_ *v7;
  unsigned int v8;
  unsigned __int8 v9;
  uint64_t v10;
  re *v11;
  unsigned __int8 v12;
  unsigned __int8 v13;
  _OWORD v14[2];

  v6 = (os_unfair_lock_s *)(a2 + 384);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 384));
  v8 = atomic_load((unsigned int *)(a2 + 704));
  if (v8 != 3)
  {
    if (v8 == 2)
    {
      v13 = atomic_load((unsigned __int8 *)(a1 + 1409));
      if ((v13 & 1) == 0 && !*(_BYTE *)(a1 + 1410))
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 584));
    }
    else
    {
      if (v8 != 1)
        goto LABEL_23;
      v9 = atomic_load((unsigned __int8 *)(a1 + 1409));
      if ((v9 & 1) == 0 && !*(_BYTE *)(a1 + 1410))
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 584));
      if (!*(_BYTE *)(a2 + 416))
      {
        if (*(_BYTE *)(a2 + 417))
        {
          v10 = *(_QWORD *)(a2 + 400);
          if (v10)
          {
            *(_DWORD *)(v10 + 16) = 1;
            *(_QWORD *)(a2 + 400) = 0;
          }
          re::AssetManager::putEntryInFailedState_entryStateLocked(v11, a2, 302, (uint64_t)v14);
          if (*(_QWORD *)&v14[0])
          {
            if ((BYTE8(v14[0]) & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)&v14[0] + 40))();
            memset(v14, 0, sizeof(v14));
          }
        }
        else
        {
          re::AssetManager::cancelLoadingAsset_entryStateLocked((os_unfair_lock_s *)a1, (re::internal::AssetEntry *)a2, a3);
        }
        goto LABEL_23;
      }
    }
    re::AssetManager::unloadAssetEntry_entryStateLocked((os_unfair_lock_s *)a1, (re::internal::AssetEntry *)a2, a3);
    goto LABEL_23;
  }
  v12 = atomic_load((unsigned __int8 *)(a1 + 1409));
  if ((v12 & 1) == 0 && !*(_BYTE *)(a1 + 1410))
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 584));
  re::internal::AssetEntry::LoadState::clearLoadFailure_locked((re::internal::AssetEntry::LoadState *)(a2 + 704));
LABEL_23:
  os_unfair_lock_unlock(v6);
}

uint64_t re::AssetManager::processUnreferencedUnloadRequests(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  _anonymous_namespace_ *v5;
  _anonymous_namespace_ *v6;
  uint64_t v7;
  id *v8;
  id *v9;
  id *v10;
  id *v11;
  id *v12;
  id WeakRetained;
  _anonymous_namespace_ *v14;
  const char *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  id *v29;
  uint64_t v30;
  os_unfair_lock_s *lock;
  id to;
  _QWORD v34[2];
  uint64_t v35;
  int v36;
  _QWORD *v37;
  uint64_t v38;
  __int128 v39;
  int v40;
  id *from;
  uint64_t v42;
  int v43;
  const char *v44;
  __int16 v45;
  int v46;
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  uint64_t v50;
  _OWORD v51[2];
  __int128 v52;
  __int128 v53;
  __int128 v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  atomic_load((unsigned __int8 *)(a1 + 1409));
  from = 0;
  v39 = 0uLL;
  v38 = 0;
  v40 = 0;
  v4 = (os_unfair_lock_s *)(a1 + 960);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 960));
  v5 = (_anonymous_namespace_ *)(a1 + 968);
  if (*(_QWORD *)(a1 + 984))
  {
    memset(v51, 0, 24);
    v38 = 0;
    v39 = 0u;
    *(_QWORD *)&v52 = 0;
    from = 0;
    v40 = 1;
    DWORD2(v51[1]) = 1;
    re::DynamicArray<re::internal::DeferredUnregister *>::operator=((uint64_t)&v38, a1 + 968);
    re::DynamicArray<re::internal::DeferredUnregister *>::operator=(a1 + 968, (uint64_t)v51);
    v6 = (_anonymous_namespace_ *)re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::deinit((uint64_t)v51);
    re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::setCapacity((_QWORD *)(a1 + 968), 0x20uLL);
    ++*(_DWORD *)(a1 + 992);
  }
  lock = v4;
  os_unfair_lock_unlock(v4);
  v37 = 0;
  v34[1] = 0;
  v35 = 0;
  v34[0] = 0;
  v36 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  while (*((_QWORD *)&v39 + 1))
  {
    if (dispatch_time(0, 0) >= *(_QWORD *)(a2 + 8))
      break;
    to = 0;
    objc_moveWeak(&to, from);
    v7 = *((_QWORD *)&v39 + 1);
    if (*((_QWORD *)&v39 + 1) != 1)
    {
      if (!*((_QWORD *)&v39 + 1))
      {
        v42 = 0;
        v53 = 0u;
        v54 = 0u;
        v52 = 0u;
        memset(v51, 0, sizeof(v51));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v43 = 136315906;
        v44 = "removeAt";
        v45 = 1024;
        v46 = 931;
        v47 = 2048;
        v48 = 0;
        v49 = 2048;
        v50 = 0;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v8 = from;
      v9 = &from[*((_QWORD *)&v39 + 1) - 1];
      if (v9 != from)
      {
        objc_destroyWeak(from);
        *v8 = 0;
        objc_moveWeak(v8, v9);
        v7 = *((_QWORD *)&v39 + 1);
      }
    }
    v10 = &from[v7];
    objc_destroyWeak(v10 - 1);
    *(v10 - 1) = 0;
    --*((_QWORD *)&v39 + 1);
    ++v40;
    v11 = (id *)objc_loadWeakRetained(&to);
    if (v11)
    {
      v12 = v11;
      WeakRetained = objc_loadWeakRetained(v11 + 103);
      if (WeakRetained)
      {

      }
      else if (v12[2])
      {
        re::AssetManager::unloadAssetAsync(a1, (uint64_t)(v12 - 1), 0);
        re::internal::AssetEntry::removeFromAssetManager((os_unfair_lock_s *)v12 - 2);
        if (((unint64_t)v12[16] & 1) != 0)
          v15 = (const char *)v12[17];
        else
          v15 = (char *)v12 + 129;
        v16 = re::Hash<re::DynamicString>::operator()((uint64_t)&v43, (uint64_t)v51);
        if (*(_QWORD *)(a1 + 72))
        {
          v17 = v16 % *(unsigned int *)(a1 + 96);
          v18 = *(_QWORD *)(a1 + 80);
          v19 = *(unsigned int *)(v18 + 4 * v17);
          if ((_DWORD)v19 != 0x7FFFFFFF)
          {
            v20 = *(_QWORD *)(a1 + 88);
            if (re::DynamicString::operator==(v20 + 56 * v19 + 16, (uint64_t)v51))
            {
              *(_DWORD *)(v18 + 4 * v17) = *(_DWORD *)(v20 + 56 * v19 + 8) & 0x7FFFFFFF;
LABEL_26:
              re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 88) + 56 * v19);
              *(_DWORD *)(*(_QWORD *)(a1 + 88) + 56 * v19 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 88) + 56 * v19 + 8) & 0x80000000 | *(_DWORD *)(a1 + 108);
              --*(_DWORD *)(a1 + 100);
              v22 = *(_DWORD *)(a1 + 112) + 1;
              *(_DWORD *)(a1 + 108) = v19;
              *(_DWORD *)(a1 + 112) = v22;
            }
            else
            {
              while (1)
              {
                v21 = v19;
                v19 = *(_DWORD *)(v20 + 56 * v19 + 8) & 0x7FFFFFFF;
                if (v19 == 0x7FFFFFFF)
                  break;
                if (re::DynamicString::operator==(v20 + 56 * v19 + 16, (uint64_t)v51))
                {
                  *(_DWORD *)(v20 + 56 * v21 + 8) = *(_DWORD *)(v20 + 56 * v21 + 8) & 0x80000000 | *(_DWORD *)(v20 + 56 * v19 + 8) & 0x7FFFFFFF;
                  goto LABEL_26;
                }
              }
            }
          }
        }
        if (*(_QWORD *)&v51[0] && (BYTE8(v51[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v51[0] + 40))();
        if (*((_DWORD *)v12 + 28) == 8)
        {
          v23 = (unint64_t)v12[13];
          if (v23 + 1 >= 2)
            re::internal::AssetIdLoadDescriptorTable::remove((re::internal::AssetIdLoadDescriptorTable *)(a1 + 120), v23);
        }
        if ((unint64_t)v12[13] + 1 >= 2)
        {
          *(_QWORD *)&v51[0] = v12[13];
          re::DynamicArray<re::TransitionCondition *>::add(v34, v51);
        }
      }

    }
    objc_destroyWeak(&to);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 64));
  if (v35)
  {
    v24 = v37;
    v25 = 8 * v35;
    do
    {
      v26 = *v24;
      v27 = *(_QWORD *)(a1 + 1208);
      if (v27)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v27 + 8))(v27, *v24);
      v28 = *(_QWORD *)(a1 + 1136);
      if (v28 && *(_BYTE *)(a1 + 1444))
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v28 + 32))(v28, v26);
      ++v24;
      v25 -= 8;
    }
    while (v25);
  }
  if (*((_QWORD *)&v39 + 1))
  {
    os_unfair_lock_lock(lock);
    if (*((_QWORD *)&v39 + 1))
    {
      v29 = from;
      v30 = 8 * *((_QWORD *)&v39 + 1);
      do
      {
        re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::add(v5, v29++);
        v30 -= 8;
      }
      while (v30);
    }
    os_unfair_lock_unlock(lock);
  }
  if (v34[0] && v37)
    (*(void (**)(void))(*(_QWORD *)v34[0] + 40))();
  return re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::deinit((uint64_t)&v38);
}

void re::AssetManager::waitForLoadQueueToComplete(uint64_t a1, int a2)
{
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t v6;

  v4 = atomic_load((unsigned __int8 *)(a1 + 1409));
  if ((v4 & 1) == 0 && !*(_BYTE *)(a1 + 1410))
  {
    if (a2 == 1)
    {
      dispatch_assert_queue_not_V2(*(dispatch_queue_t *)(a1 + 584));
    }
    else if (!a2)
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 584));
    }
  }
  while (1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1344));
    v5 = *(_QWORD *)(a1 + 1368);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 1344));
    if (!v5)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
      v6 = *(_QWORD *)(a1 + 376);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 64));
      if (!v6 && !*(_QWORD *)(a1 + 40))
        break;
    }
    re::internal::AssetBackgroundLoader::waitForActiveLoadItemsToComplete(*(re::internal::AssetBackgroundLoader **)(a1 + 1096));
    if (a2)
      usleep(0x3E8u);
    else
      re::AssetManager::update((re::AssetManager *)a1, 0, 0);
  }
}

uint64_t re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::deinit(uint64_t a1)
{
  uint64_t result;
  id *v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(id **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 8 * v4;
        do
        {
          objc_destroyWeak(v3);
          *v3++ = 0;
          v5 -= 8;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(id **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, id *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

double re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 56;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::AssetManager::assertOnEngineQueue(re::AssetManager *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)this + 1409);
  if ((v1 & 1) == 0 && !*((_BYTE *)this + 1410))
    dispatch_assert_queue_V2(*((dispatch_queue_t *)this + 73));
}

void re::AssetManager::updateLoadRequests(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v2;
  os_unfair_lock_s *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;

  v2 = atomic_load((unsigned __int8 *)(a1 + 704));
  if ((v2 & 1) != 0)
  {
    atomic_store(0, (unsigned __int8 *)(a1 + 704));
    atomic_load((unsigned __int8 *)(a1 + 1409));
    v5 = (os_unfair_lock_s *)(a1 + 640);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 640));
    v6 = *(_QWORD *)(a1 + 664);
    if (v6)
    {
      while (1)
      {
        if (dispatch_time(0, 0) >= *(_QWORD *)(a2 + 8))
        {
          atomic_store(1u, (unsigned __int8 *)(a1 + 704));
          goto LABEL_16;
        }
        v8 = *(_QWORD *)(a1 + 664);
        if (!v8)
          break;
        v9 = *(_QWORD *)(a1 + 688);
        v10 = *(_QWORD *)(a1 + 672);
        v11 = *(_QWORD *)(v9 + 8 * v10);
        *(_QWORD *)(v9 + 8 * v10) = 0;
        if ((unint64_t)(v10 + 1) < *(_QWORD *)(a1 + 656))
          v12 = v10 + 1;
        else
          v12 = 0;
        *(_QWORD *)(a1 + 672) = v12;
        *(_QWORD *)(a1 + 664) = v8 - 1;
        ++*(_DWORD *)(a1 + 680);
        os_unfair_lock_lock((os_unfair_lock_t)(v11 + 192));
        v13 = *(unsigned __int8 *)(v11 + 355);
        os_unfair_lock_unlock((os_unfair_lock_t)(v11 + 192));
        if (v13)
        {

        }
        else
        {
          os_unfair_lock_unlock(v5);
          re::AssetLoadRequest::Data::update((os_unfair_lock_s *)v11);
          os_unfair_lock_lock(v5);
          v14 = *(_QWORD *)(a1 + 664);
          v15 = v14 + 1;
          v16 = *(_QWORD *)(a1 + 656);
          if (v14 + 1 >= v16)
          {
            re::Queue<re::SharedPtr<re::AssetLoadRequest::Data>>::growCapacity((_QWORD *)(a1 + 648), v15);
            v14 = *(_QWORD *)(a1 + 664);
            v16 = *(_QWORD *)(a1 + 656);
            v15 = v14 + 1;
          }
          *(_QWORD *)(*(_QWORD *)(a1 + 688) + 8 * ((*(_QWORD *)(a1 + 672) + v14) % v16)) = v11;
          *(_QWORD *)(a1 + 664) = v15;
          ++*(_DWORD *)(a1 + 680);
        }
        if (!--v6)
          goto LABEL_16;
      }
      re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Queue<T> is empty", "m_size > 0", "dequeue", 569);
      _os_crash();
      __break(1u);
    }
    else
    {
LABEL_16:
      os_unfair_lock_unlock(v5);
    }
  }
}

uint64_t re::AssetManager::afterFrameUpdate(re::AssetManager *this)
{
  uint64_t v2;
  std::chrono::steady_clock::time_point v3;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v5;
  uint64_t v6;
  re *v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  size_t v15;
  unsigned int v16;
  int v17;
  int v18;
  NSObject *v19;
  uint64_t v20;
  double v21;
  uint64_t v22;
  double v23;
  uint64_t v24;
  unint64_t v25;
  _BYTE *v26;
  uint64_t v28;
  char v29;
  _BYTE v30[23];
  _BYTE buf[24];
  double v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  double v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  double v40;
  __int16 v41;
  _BYTE *v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 184);
  v3.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  rep = v3.__d_.__rep_;
  if (v2)
  {
    if (*((_BYTE *)this + 1488))
    {
      v5 = *((_QWORD *)this + 185);
    }
    else
    {
      *((_BYTE *)this + 1488) = 1;
      *((std::chrono::steady_clock::time_point *)this + 185) = v3;
      v5 = v3.__d_.__rep_;
    }
    v6 = v3.__d_.__rep_ - v5;
    if (v3.__d_.__rep_ - v5 >= 1000000000)
    {
      v8 = *((unsigned int *)this + 390);
      if ((_DWORD)v8)
      {
        v9 = 0;
        v10 = (int *)(*((_QWORD *)this + 193) + 8);
        while (1)
        {
          v11 = *v10;
          v10 += 10;
          if (v11 < 0)
            break;
          if (v8 == ++v9)
          {
            LODWORD(v9) = *((_DWORD *)this + 390);
            break;
          }
        }
      }
      else
      {
        LODWORD(v9) = 0;
      }
      if ((_DWORD)v8 != (_DWORD)v9)
      {
        v12 = v9;
        do
        {
          re::DynamicString::format((re::DynamicString *)"Registering Entries[%s]: num: %zu, time spent: %0.1f ms\n", (re::DynamicString *)buf, **(_QWORD **)(*((_QWORD *)this + 193) + 40 * v12 + 16), *(_QWORD *)(*((_QWORD *)this + 193) + 40 * v12 + 24), (float)((float)*(unint64_t *)(*((_QWORD *)this + 193) + 40 * v12 + 32) / 1000000.0));
          v13 = buf[8] & 1;
          if ((buf[8] & 1) != 0)
            v14 = *(const char **)&buf[16];
          else
            v14 = &buf[9];
          if ((buf[8] & 1) != 0)
            v15 = *(_QWORD *)&buf[8] >> 1;
          else
            v15 = buf[8] >> 1;
          re::DynamicString::append((re::DynamicString *)&v28, v14, v15);
          v7 = *(re **)buf;
          if (*(_QWORD *)buf && v13)
            v7 = (re *)(*(uint64_t (**)(void))(**(_QWORD **)buf + 40))();
          v16 = *((_DWORD *)this + 390);
          if (v16 <= (int)v9 + 1)
            v17 = v9 + 1;
          else
            v17 = *((_DWORD *)this + 390);
          while (1)
          {
            v12 = (v9 + 1);
            if (v17 - 1 == (_DWORD)v9)
              break;
            LODWORD(v9) = v9 + 1;
            v18 = v12;
            if ((*(_DWORD *)(*((_QWORD *)this + 193) + 40 * v12 + 8) & 0x80000000) != 0)
              goto LABEL_33;
          }
          v18 = v17;
LABEL_33:
          LODWORD(v9) = v18;
        }
        while (v16 != v18);
      }
      v19 = *re::assetsLogObjects(v7);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        v20 = *((_QWORD *)this + 184);
        v21 = (float)((float)*((unint64_t *)this + 181) / 1000000.0);
        v22 = *((_QWORD *)this + 187);
        v23 = (float)((float)*((unint64_t *)this + 188) / 1000000.0);
        v24 = *((_QWORD *)this + 189);
        v25 = *((_QWORD *)this + 190);
        *(_DWORD *)buf = 134219778;
        *(_QWORD *)&buf[4] = v20;
        *(_WORD *)&buf[12] = 2048;
        *(double *)&buf[14] = (float)((float)v6 / 1000000000.0);
        *(_WORD *)&buf[22] = 2048;
        v32 = v21;
        v33 = 2048;
        v34 = v22;
        v35 = 2048;
        v36 = v23;
        v26 = v30;
        v37 = 2048;
        v38 = v24;
        if ((v29 & 1) != 0)
          v26 = *(_BYTE **)&v30[7];
        v39 = 2048;
        v40 = (float)((float)v25 / 1000000.0);
        v41 = 2080;
        v42 = v26;
        _os_log_impl(&dword_224FE9000, v19, OS_LOG_TYPE_DEFAULT, "Asset Manager is overloaded: Asset Manager update timed out %zu times in the last %0.1f seconds (deadline is %0.1f ms).  Asset loading may be slower than usual due to increased load. Showing stats for timed out updates only:\nProcessed load items: %zu, time spent: %0.1f ms\nProcessed Resource Requests: %zu, time spent: %0.1f ms\n%s", buf, 0x52u);
      }
      if (!*((_BYTE *)this + 1488))
        *((_BYTE *)this + 1488) = 1;
      *((_QWORD *)this + 185) = rep;
      *((_QWORD *)this + 184) = 0;
      *(_OWORD *)((char *)this + 1496) = 0u;
      *(_OWORD *)((char *)this + 1512) = 0u;
      re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::clear((uint64_t)this + 1528);
      if (v28 && (v29 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v28 + 40))();
    }
  }
  else
  {
    if (!*((_BYTE *)this + 1488))
      *((_BYTE *)this + 1488) = 1;
    *((std::chrono::steady_clock::time_point *)this + 185) = v3;
  }
  return re::AssetManager::processDeferredPointerUnload((os_unfair_lock_s *)this);
}

void re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_155, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 40 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 40;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

_anonymous_namespace_ *re::DynamicArray<re::SharedPtr<re::AssetLoadRequest>>::add(_anonymous_namespace_ *result, uint64_t *a2)
{
  _anonymous_namespace_ *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;

  v3 = result;
  v5 = *((_QWORD *)result + 1);
  v4 = *((_QWORD *)result + 2);
  if (v4 >= v5)
  {
    v6 = v4 + 1;
    if (v5 < v4 + 1)
    {
      if (*(_QWORD *)result)
      {
        v7 = 2 * v5;
        if (!v5)
          v7 = 8;
        if (v7 <= v6)
          v8 = v6;
        else
          v8 = v7;
        result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(result, v8);
      }
      else
      {
        result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(v3, v6);
        ++*((_DWORD *)v3 + 6);
      }
    }
    v4 = *((_QWORD *)v3 + 2);
  }
  v9 = *a2;
  *(_QWORD *)(*((_QWORD *)v3 + 4) + 8 * v4) = *a2;
  if (v9)
  {
    result = (_anonymous_namespace_ *)(id)(v9 + 8);
    v4 = *((_QWORD *)v3 + 2);
  }
  *((_QWORD *)v3 + 2) = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return result;
}

void re::AssetManager::loadNow(unsigned __int8 *a1, os_unfair_lock_s *a2, int a3)
{
  re::AssetLoadRequest *v5;
  _BYTE v6[24];
  re::AssetLoadRequest *v7;

  if (a3)
  {
    os_unfair_lock_lock(a2 + 96);
    re::AssetManager::loadAssetAsync_entryStateLocked(a1, (re::internal::AssetEntry *)a2, 0);
    os_unfair_lock_unlock(a2 + 96);
    re::AssetManager::makeLoadRequest((re::AssetManager *)a1, &v7);
    v5 = v7;
    re::AssetHandle::AssetHandle((re::AssetHandle *)v6, (re::internal::AssetEntry *)a2);
    re::AssetLoadRequest::addAsset((re::AssetLoadRequest::Data **)v5, (const re::AssetHandle *)v6);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v6);
    re::AssetLoadRequest::Data::waitForCompletion(*((_QWORD *)v5 + 3), 1);

  }
  else
  {
    re::AssetManager::loadNow((re::AssetManager *)a1, a2);
  }
}

uint64_t re::AssetManager::loadNow(re::AssetManager *this, os_unfair_lock_s *a2)
{
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  re::internal::AssetLoadItem *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t result;
  _QWORD v22[2];
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t *v30;

  v4 = atomic_load((unsigned __int8 *)this + 1409);
  if ((v4 & 1) == 0 && !*((_BYTE *)this + 1410))
    dispatch_assert_queue_V2(*((dispatch_queue_t *)this + 73));
  os_unfair_lock_lock(a2 + 96);
  re::AssetManager::loadAssetAsync_entryStateLocked((unsigned __int8 *)this, (re::internal::AssetEntry *)a2, 1);
  os_unfair_lock_unlock(a2 + 96);
  v26 = 0;
  v27 = 0;
  v28 = 1;
  v29 = 0;
  v30 = 0;
  re::DynamicOverflowArray<re::internal::AssetEntry *,32ul>::ensureCapacity((_anonymous_namespace_ *)&v26);
  if ((v28 & 1) != 0)
    v5 = &v29;
  else
    v5 = v30;
  v6 = v27;
  v5[v27] = (uint64_t)a2;
  v27 = v6 + 1;
  v28 += 2;
  v7 = atomic_load(&a2[176]._os_unfair_lock_opaque);
  if (v7 == 1)
  {
    do
    {
      v25 = 0;
      if (v27)
      {
        v8 = v30;
        if ((v28 & 1) != 0)
          v8 = &v29;
        v9 = v8[--v27];
        v28 += 2;
        os_unfair_lock_lock((os_unfair_lock_t)this + 336);
        os_unfair_lock_lock((os_unfair_lock_t)(v9 + 384));
        v10 = *(_QWORD *)(v9 + 400);
        os_unfair_lock_unlock((os_unfair_lock_t)(v9 + 384));
        if (v10)
        {
          v11 = *(re::internal::AssetLoadItem **)(v10 + 8);
          os_unfair_lock_unlock((os_unfair_lock_t)this + 336);
          if (v11)
            re::internal::AssetBackgroundLoader::loadNow(*((os_unfair_lock_s **)this + 137), v11, 1);
        }
        else
        {
          os_unfair_lock_unlock((os_unfair_lock_t)this + 336);
        }
        re::AssetManager::update(this, 0, 0);
        if (re::internal::AssetEntry::hasLoadingAssetPointer((re::internal::AssetEntry *)v9))
          v12 = *(_QWORD *)(v9 + 720);
        else
          v12 = *(_QWORD *)(v9 + 712);
        re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(&v25, v12);
      }
      else
      {
        re::AssetManager::update(this, 0, 0);
        v9 = 0;
      }
      v13 = v25;
      if (v25)
      {
        v14 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*((_QWORD *)this + 138), *(_QWORD *)(v9 + 264));
        (*(void (**)(_QWORD *__return_ptr, uint64_t, _QWORD))(*(_QWORD *)v14 + 168))(v22, v14, *(_QWORD *)(v13 + 24));
        if (v23)
        {
          v15 = (uint64_t *)(v24 + 8);
          v16 = 24 * v23;
          do
          {
            v17 = *v15;
            if (*v15)
            {
              re::DynamicOverflowArray<re::internal::AssetEntry *,32ul>::ensureCapacity((_anonymous_namespace_ *)&v26);
              if ((v28 & 1) != 0)
                v18 = &v29;
              else
                v18 = v30;
              v19 = v27;
              v18[v27] = v17;
              v27 = v19 + 1;
              v28 += 2;
            }
            v15 += 3;
            v16 -= 24;
          }
          while (v16);
        }
        re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v22);
        if (v25)

      }
      v20 = atomic_load(&a2[176]._os_unfair_lock_opaque);
    }
    while (v20 == 1);
  }
  result = v26;
  if (v26)
  {
    if ((v28 & 1) == 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v26 + 40))();
  }
  return result;
}

void re::AssetManager::loadAssetAsync(re::AssetManager *this, os_unfair_lock_s *a2, BOOL a3)
{
  os_unfair_lock_s *v6;

  v6 = a2 + 96;
  os_unfair_lock_lock(a2 + 96);
  re::AssetManager::loadAssetAsync_entryStateLocked(this, (re::internal::AssetEntry *)a2, a3);
  os_unfair_lock_unlock(v6);
}

void re::AssetManager::makeLoadRequest(re::AssetManager *this@<X0>, re::AssetLoadRequest **a2@<X8>)
{
  uint64_t *v4;
  re::AssetLoadRequest *Request;
  void *v6;
  char *v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD v14[5];
  std::__shared_weak_count *v15;

  Request = re::AssetLoadRequest::AssetLoadRequest((re::AssetLoadRequest *)v4);
  *a2 = Request;
  v6 = (char *)Request + 8;
  *(_QWORD *)(v4[3] + 24) = this;
  v7 = (char *)Request + 8;
  os_unfair_lock_lock((os_unfair_lock_t)this + 160);
  re::Queue<re::SharedPtr<re::AssetLoadRequest::Data>>::enqueue((_QWORD *)this + 81, v4 + 3);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 160);

  if (*((_QWORD *)this + 112) && dispatch_get_specific((char *)this + 896) == (char *)this + 896)
  {
    re::AssetManager::updateScheduler(this);
  }
  else
  {
    dispatch_group_enter(*((dispatch_group_t *)this + 222));
    v8 = *((_QWORD *)this + 224);
    v9 = (std::__shared_weak_count *)*((_QWORD *)this + 225);
    if (v9)
    {
      p_shared_weak_owners = (unint64_t *)&v9->__shared_weak_owners_;
      do
        v11 = __ldxr(p_shared_weak_owners);
      while (__stxr(v11 + 1, p_shared_weak_owners));
    }
    v14[0] = MEMORY[0x24BDAC760];
    v14[1] = 1174405120;
    v14[2] = ___ZN2re12AssetManager15makeLoadRequestEv_block_invoke;
    v14[3] = &__block_descriptor_tmp_62;
    v14[4] = v8;
    v15 = v9;
    if (v9)
    {
      v12 = (unint64_t *)&v9->__shared_weak_owners_;
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }
    dispatch_async(*((dispatch_queue_t *)this + 73), v14);
    if (v15)
      std::__shared_weak_count::__release_weak(v15);
    if (v9)
      std::__shared_weak_count::__release_weak(v9);
  }
}

void re::AssetManager::updateScheduler(re::AssetManager *this)
{
  unsigned __int8 v2;
  _BOOL4 v3;
  uint64_t v4;
  char v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_weak_owners;
  unint64_t v11;
  dispatch_time_t v12;
  unint64_t *v13;
  unint64_t v14;
  _QWORD v15[5];
  std::__shared_weak_count *v16;

  v2 = atomic_load((unsigned __int8 *)this + 1409);
  if ((v2 & 1) == 0 && !*((_BYTE *)this + 1410))
    dispatch_assert_queue_V2(*((dispatch_queue_t *)this + 73));
  if (*((_QWORD *)this + 216))
  {
    v3 = *((unsigned __int8 *)this + 1752) == 3;
    os_unfair_lock_lock((os_unfair_lock_t)this + 160);
    v4 = *((_QWORD *)this + 83);
    os_unfair_lock_unlock((os_unfair_lock_t)this + 160);
    if (((v3 ^ (v4 == 0)) & 1) == 0)
    {
      if (v4)
        v5 = 3;
      else
        v5 = 4;
      *((_BYTE *)this + 1752) = v5;
      *((_BYTE *)this + 1753) = 1;
      *((_DWORD *)this + 439) = 1023969417;
      *((_BYTE *)this + 1760) = 0;
      v6 = *((_QWORD *)this + 217);
      if (v6 != -1)
        re::Scheduler::setTaskOptions(*((re::Scheduler **)this + 216), v6, (float *)this + 438);
      v7 = *((_QWORD *)this + 218);
      if (v7 != -1)
        re::Scheduler::setTaskOptions(*((re::Scheduler **)this + 216), v7, (float *)this + 438);
    }
    if (v4 && !*((_BYTE *)this + 1784))
    {
      dispatch_group_enter(*((dispatch_group_t *)this + 222));
      *((_WORD *)this + 892) = 257;
      v8 = *((_QWORD *)this + 224);
      v9 = (std::__shared_weak_count *)*((_QWORD *)this + 225);
      if (v9)
      {
        p_shared_weak_owners = (unint64_t *)&v9->__shared_weak_owners_;
        do
          v11 = __ldxr(p_shared_weak_owners);
        while (__stxr(v11 + 1, p_shared_weak_owners));
      }
      v12 = dispatch_time(0, 13000000);
      v15[0] = MEMORY[0x24BDAC760];
      v15[1] = 1174405120;
      v15[2] = ___ZN2re12AssetManager15updateSchedulerEv_block_invoke;
      v15[3] = &__block_descriptor_tmp_15;
      v15[4] = v8;
      v16 = v9;
      if (v9)
      {
        v13 = (unint64_t *)&v9->__shared_weak_owners_;
        do
          v14 = __ldxr(v13);
        while (__stxr(v14 + 1, v13));
      }
      dispatch_after(v12, *((dispatch_queue_t *)this + 73), v15);
      if (v16)
        std::__shared_weak_count::__release_weak(v16);
      if (v9)
        std::__shared_weak_count::__release_weak(v9);
    }
  }
}

void ___ZN2re12AssetManager15updateSchedulerEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v13[5];
  std::__shared_weak_count *v14;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5)
      {
        *(_BYTE *)(v5 + 1784) = 0;
        v13[0] = MEMORY[0x24BDAC760];
        v13[1] = 1174405120;
        v13[2] = ___ZN2re12AssetManager15updateSchedulerEv_block_invoke_2;
        v13[3] = &__block_descriptor_tmp_14;
        v13[4] = v5;
        v14 = v3;
        p_shared_owners = (unint64_t *)&v3->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
        dispatch_sync(*(dispatch_queue_t *)(v5 + 1768), v13);
        dispatch_group_leave(*(dispatch_group_t *)(v5 + 1776));
        v8 = v14;
        if (v14)
        {
          v9 = (unint64_t *)&v14->__shared_owners_;
          do
            v10 = __ldaxr(v9);
          while (__stlxr(v10 - 1, v9));
          if (!v10)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
      v11 = (unint64_t *)&v4->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

uint64_t __copy_helper_block_8_32c45_ZTSNSt3__110shared_ptrIN2re12AssetManagerEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

uint64_t __destroy_helper_block_8_32c45_ZTSNSt3__110shared_ptrIN2re12AssetManagerEEE(uint64_t a1)
{
  return std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100](a1 + 32);
}

uint64_t __copy_helper_block_8_32c42_ZTSNSt3__18weak_ptrIN2re12AssetManagerEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_8_32c42_ZTSNSt3__18weak_ptrIN2re12AssetManagerEEE(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

uint64_t re::AssetManager::canShareAssetOverNetwork(os_unfair_lock_s *this, const re::AssetHandle *a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t v6;
  os_unfair_lock_s *v7;
  int v8;
  uint64_t v10;

  v4 = this + 16;
  os_unfair_lock_lock(this + 16);
  v5 = *((_QWORD *)re::AssetHandle::assetInfo(a2) + 10);
  if (v5 == -1)
    v5 = 0;
  v10 = v5;
  v6 = re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)&this[30], &v10);
  os_unfair_lock_unlock(v4);
  v7 = (os_unfair_lock_s *)(*((_QWORD *)a2 + 1) + 384);
  os_unfair_lock_lock(v7);
  v8 = *(_DWORD *)(*((_QWORD *)a2 + 1) + 420);
  os_unfair_lock_unlock(v7);
  return re::AssetManager::canShareAssetOverNetwork((os_unfair_lock_s **)this, a2, v6, v8);
}

uint64_t re::AssetManager::canShareAssetOverNetwork(os_unfair_lock_s **a1, re::AssetHandle *a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  uint64_t result;
  uint64_t ProviderForScheme;
  NSObject *v12;
  _BOOL4 v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if (!a3)
  {
    v12 = *re::assetsLogObjects((re *)a1);
    v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v13)
      return result;
    v14 = *((_QWORD *)re::AssetHandle::assetInfo(a2) + 10);
    if (v14 == -1)
      v14 = 0;
    v15 = 134217984;
    v16 = v14;
    _os_log_impl(&dword_224FE9000, v12, OS_LOG_TYPE_DEFAULT, "Cannot share assetId:%llu over the network, cannot find entry in the asset tables (asset was probably unloaded).", (uint8_t *)&v15, 0xCu);
    return 0;
  }
  if (a4 == 2)
    return 0;
  if (a4)
    return 1;
  v4 = *(_QWORD *)(a3 + 16);
  if (!v4)
    return 1;
  v6 = *(_QWORD *)(a3 + 32);
  v7 = 144 * v4;
  while (1)
  {
    v8 = (*(_QWORD *)(v6 + 8) & 1) != 0 ? *(const char **)(v6 + 16) : (const char *)(v6 + 9);
    result = strcmp(v8, "NetworkAsset");
    if (!(_DWORD)result)
      break;
    ProviderForScheme = re::AssetProviderRegistry::tryGetProviderForScheme(a1[149], v8);
    if (ProviderForScheme
      && ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)ProviderForScheme + 96))(ProviderForScheme, v6, 12) & 1) != 0)
    {
      return 0;
    }
    v6 += 144;
    v7 -= 144;
    if (!v7)
      return 1;
  }
  return result;
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<re::RealityFileAssetLoadDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2, re::Allocator *a3)
{
  uint64_t **v4;
  unsigned __int8 v5;
  __guard *v6;
  int v8;
  int v9;
  re::Allocator *v11;
  re::AssetLoadDescriptor *v12;

  v4 = a2;
  if ((v5 & 1) == 0)
  {
    v12 = a1;
    v11 = a3;
    v4 = a2;
    a3 = v11;
    v9 = v8;
    a1 = v12;
    if (v9)
    {
      re::introspect<re::RealityFileAssetLoadDescriptorParameters>(void)::info = re::introspect_RealityFileAssetLoadDescriptorParameters(0);
      a1 = v12;
      v4 = a2;
      a3 = v11;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)v6[54], v4, a3);
}

re::AssetLoadDescriptor *re::AssetLoadDescriptor::AssetLoadDescriptor(re::AssetLoadDescriptor *this, const re::AssetLoadDescriptor *a2)
{
  re::DynamicString *v4;

  v4 = re::DynamicString::DynamicString(this, a2);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)v4 + 32, (uint64_t *)a2 + 4);
  re::DynamicArray<BOOL>::DynamicArray((uint64_t)this + 72, (uint64_t *)a2 + 9);
  re::DynamicString::DynamicString((re::AssetLoadDescriptor *)((char *)this + 112), (const re::AssetLoadDescriptor *)((char *)a2 + 112));
  return this;
}

re::DynamicString *re::DynamicArray<re::AssetLoadDescriptor>::add(_anonymous_namespace_ *this, re::DynamicString *a2)
{
  unint64_t v4;
  uint64_t v5;
  re::DynamicString *result;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::AssetLoadDescriptor>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 144 * v4;
  re::DynamicString::DynamicString((re::DynamicString *)v5, a2);
  re::DynamicArray<BOOL>::DynamicArray(v5 + 32, (uint64_t *)a2 + 4);
  re::DynamicArray<BOOL>::DynamicArray(v5 + 72, (uint64_t *)a2 + 9);
  result = re::DynamicString::DynamicString((re::DynamicString *)(v5 + 112), (re::DynamicString *)((char *)a2 + 112));
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void re::AssetLoadDescriptor::~AssetLoadDescriptor(re::AssetLoadDescriptor *this)
{
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = (_OWORD *)((char *)this + 112);
  v2 = *((_QWORD *)this + 14);
  if (v2)
  {
    if ((*((_BYTE *)this + 120) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 16));
    *v3 = 0u;
    v3[1] = 0u;
  }
  v4 = *((_QWORD *)this + 9);
  if (v4)
  {
    if (*((_QWORD *)this + 13))
      (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
    *((_QWORD *)this + 13) = 0;
    *((_QWORD *)this + 10) = 0;
    *((_QWORD *)this + 11) = 0;
    *((_QWORD *)this + 9) = 0;
    ++*((_DWORD *)this + 24);
  }
  v5 = *((_QWORD *)this + 4);
  if (v5)
  {
    if (*((_QWORD *)this + 8))
      (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
    *((_QWORD *)this + 8) = 0;
    *((_QWORD *)this + 5) = 0;
    *((_QWORD *)this + 6) = 0;
    *((_QWORD *)this + 4) = 0;
    ++*((_DWORD *)this + 14);
  }
  if (*(_QWORD *)this)
  {
    if ((*((_BYTE *)this + 8) & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)this + 40))(*(_QWORD *)this, *((_QWORD *)this + 2));
    *(_OWORD *)this = 0u;
    *((_OWORD *)this + 1) = 0u;
  }
}

_QWORD *re::AssetManager::convertToLoadDescriptor@<X0>(_QWORD *this@<X0>, const re::AssetPath *a2@<X1>, _BYTE *a3@<X8>)
{
  _QWORD *v4;
  uint64_t ProviderForScheme;
  os_unfair_lock_s *v7;
  const char *v8;
  re::AssetProviderRegistry *v9;
  const re::DynamicString *v10;
  const char *v11;
  __n128 v12;
  uint64_t v13;
  char v14;
  _QWORD *v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;

  v4 = this;
  switch(*(_DWORD *)a2)
  {
    case 0:
    case 8:
      *a3 = 0;
      return this;
    case 2:
      ProviderForScheme = this[154];
      if (ProviderForScheme)
        goto LABEL_31;
      return (_QWORD *)(*(uint64_t (**)(_QWORD, const re::AssetPath *))(*(_QWORD *)v4[158] + 112))(v4[158], a2);
    case 3:
      v7 = (os_unfair_lock_s *)this[149];
      v8 = "MemoryAsset";
      goto LABEL_30;
    case 4:
      v7 = (os_unfair_lock_s *)this[149];
      v8 = "PeerAsset";
      goto LABEL_30;
    case 5:
      ProviderForScheme = this[157];
      if (!ProviderForScheme)
        return (_QWORD *)(*(uint64_t (**)(_QWORD, const re::AssetPath *))(*(_QWORD *)v4[158] + 112))(v4[158], a2);
      goto LABEL_31;
    case 6:
      v9 = (const re::AssetPath *)((char *)a2 + 8);
      v10 = (const re::AssetPath *)((char *)a2 + 40);
      v11 = (const char *)**((_QWORD **)a2 + 9);
      re::AssetProviderRegistry::makeDescriptorForResolver(v9, v10, (const re::DynamicString *)&v13, (uint64_t)&v15);
      if (v13 && (v14 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v13 + 40))();
      v12.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional((uint64_t)a3, (uint64_t)&v15);
      if ((_QWORD)v27)
      {
        if ((BYTE8(v27) & 1) != 0)
          (*(void (**)(double))(*(_QWORD *)v27 + 40))(v12.n128_f64[0]);
        v12 = 0uLL;
        v27 = 0u;
        v28 = 0u;
      }
      if (v22)
      {
        if (v26)
          (*(void (**)(__n128))(*(_QWORD *)v22 + 40))(v12);
        v26 = 0;
        v23 = 0;
        v24 = 0;
        v22 = 0;
        ++v25;
      }
      if (v17)
      {
        if (v21)
          (*(void (**)(__n128))(*(_QWORD *)v17 + 40))(v12);
        v21 = 0;
        v18 = 0;
        v19 = 0;
        v17 = 0;
        ++v20;
      }
      this = v15;
      if (v15)
      {
        if ((v16 & 1) != 0)
          return (_QWORD *)(*(uint64_t (**)(__n128))(*v15 + 40))(v12);
      }
      return this;
    case 9:
      v7 = (os_unfair_lock_s *)this[149];
      if ((*((_QWORD *)a2 + 2) & 1) != 0)
        v8 = (const char *)*((_QWORD *)a2 + 3);
      else
        v8 = (char *)a2 + 17;
LABEL_30:
      ProviderForScheme = re::AssetProviderRegistry::tryGetProviderForScheme(v7, v8);
      if (!ProviderForScheme)
        return (_QWORD *)(*(uint64_t (**)(_QWORD, const re::AssetPath *))(*(_QWORD *)v4[158] + 112))(v4[158], a2);
LABEL_31:
      this = (_QWORD *)(*(uint64_t (**)(uint64_t, const re::AssetPath *))(*(_QWORD *)ProviderForScheme + 112))(ProviderForScheme, a2);
      if (!*a3)
      {
        re::Optional<re::AssetLoadDescriptor>::~Optional((uint64_t)a3);
        return (_QWORD *)(*(uint64_t (**)(_QWORD, const re::AssetPath *))(*(_QWORD *)v4[158] + 112))(v4[158], a2);
      }
      return this;
    default:
      return (_QWORD *)(*(uint64_t (**)(_QWORD, const re::AssetPath *))(*(_QWORD *)v4[158] + 112))(v4[158], a2);
  }
}

__n128 re::AssetManager::convertToAssetPath@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  os_unfair_lock_s *v8;
  uint64_t v9;
  const char *v10;
  uint64_t ProviderForScheme;
  __n128 result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __n128 v16;
  uint64_t v17;
  uint64_t v18;

  v8 = *(os_unfair_lock_s **)(a1 + 1192);
  v9 = a2 + 9;
  if ((*(_QWORD *)(a2 + 8) & 1) != 0)
    v10 = *(const char **)(a2 + 16);
  else
    v10 = (const char *)(a2 + 9);
  ProviderForScheme = re::AssetProviderRegistry::tryGetProviderForScheme(v8, v10);
  if (ProviderForScheme)
  {
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)ProviderForScheme + 104))(ProviderForScheme, a2, *(_QWORD *)(a1 + 1104), *(_QWORD *)(a1 + 1192), a3);
  }
  else
  {
    if ((*(_QWORD *)(a2 + 8) & 1) != 0)
      v13 = *(_QWORD *)(a2 + 16);
    else
      v13 = v9;
    re::DynamicString::format((re::DynamicString *)"Unsupported AssetLoadDescriptor type '%s'", (re::DynamicString *)&v16, v13);
    result = v16;
    v14 = v17;
    v15 = v18;
    *(_BYTE *)a4 = 0;
    *(__n128 *)(a4 + 8) = result;
    *(_QWORD *)(a4 + 24) = v14;
    *(_QWORD *)(a4 + 32) = v15;
  }
  return result;
}

uint64_t re::AssetManager::testingGetAssetPathString@<X0>(re::AssetManager *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;
  _BYTE v5[8];
  uint64_t v6;
  char v7;

  re::AssetManager::convertToAssetPath((uint64_t)this, (uint64_t)a2, 0xFFFFFFFFLL, (uint64_t)v5);
  if (v5[0])
  {
    *a3 = 1;
    re::DynamicString::DynamicString((re::DynamicString *)(a3 + 8), (const re::DynamicString *)&v6);
  }
  else
  {
    *a3 = 0;
  }
  result = v6;
  if (v6)
  {
    if ((v7 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v6 + 40))();
  }
  return result;
}

void re::AssetManager::tryGetImmutableRealityFileAsset(re::AssetManager *this@<X0>, const re::DynamicString *a2@<X1>, const re::DynamicString *a3@<X2>, uint64_t a4@<X8>)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  uint64_t v8;
  int *v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  const char *v15;
  _anonymous_namespace_ *v16;
  _anonymous_namespace_ *v17;
  _anonymous_namespace_ *v18;
  const char *v19;
  const char *v20;
  __n128 v21;
  char *v22;
  const char *v23;
  const char *v24;
  unsigned int v25;
  os_unfair_lock_s *v26;
  char *v27;
  os_unfair_lock_s *v28;
  __int128 v31;
  uint64_t v32;
  char v33[8];
  char v34;
  _BYTE v35[9];
  _BYTE v36[23];
  uint64_t *v37;
  _QWORD v38[4];
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  char v43;
  uint64_t v44;

  v6 = (os_unfair_lock_s *)((char *)this + 64);
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  v7 = *((unsigned int *)this + 50);
  v28 = v6;
  v8 = 0;
  if ((_DWORD)v7)
  {
    v9 = (int *)(*((_QWORD *)this + 23) + 8);
    while (1)
    {
      v10 = *v9;
      v9 += 42;
      if (v10 < 0)
        break;
      if (v7 == ++v8)
      {
        LODWORD(v8) = *((_DWORD *)this + 50);
        break;
      }
    }
  }
  if (!*((_DWORD *)this + 49))
  {
LABEL_49:
    v26 = v28;
    *(_BYTE *)a4 = 0;
    goto LABEL_50;
  }
  v11 = 0;
  v12 = v8;
  while (1)
  {
    v13 = *((_QWORD *)this + 23);
    v14 = (_QWORD *)(v13 + 168 * v12);
    v15 = (v14[3] & 1) != 0 ? (const char *)v14[4] : (char *)v14 + 25;
    v16 = (_anonymous_namespace_ *)strcmp(v15, "RealityFileAsset");
    if (!(_DWORD)v16)
      break;
LABEL_45:
    ++v11;
    v25 = v12 + 1;
    do
    {
      v12 = v25;
      if (v25 >= v7)
        break;
      ++v25;
    }
    while ((*(_DWORD *)(*((_QWORD *)this + 23) + 168 * v12 + 8) & 0x80000000) == 0);
    if (v11 >= *((_DWORD *)this + 49))
      goto LABEL_49;
  }
  memset(v38, 0, sizeof(v38));
  v17 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v38, 0);
  v39 = 0u;
  v40 = 0u;
  v18 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v39, 0);
  v41 = 0u;
  v42 = 0u;
  re::DynamicString::setCapacity(&v41, 0);
  v43 = 0;
  v44 = 1;
  if (!re::AssetLoadDescriptor::getIntrospectableData<re::RealityFileAssetLoadDescriptorParameters>((re::AssetLoadDescriptor *)(v14 + 2), &v37, 0))goto LABEL_33;
  v19 = (BYTE8(v41) & 1) != 0 ? (const char *)v42 : (char *)&v41 + 9;
  v20 = (*((_QWORD *)a3 + 1) & 1) != 0 ? (const char *)*((_QWORD *)a3 + 2) : (char *)a3 + 9;
  if (strcmp(v19, v20))
    goto LABEL_33;
  v21.n128_f64[0] = re::RealityFileAssetProvider::getFileName(*((re::RealityFileAssetProvider **)this + 156), (uint64_t)v33);
  v22 = &v34;
  if (!v33[0])
    goto LABEL_29;
  if ((v35[8] & 1) != 0)
    v23 = *(const char **)&v36[7];
  else
    v23 = v36;
  if ((*((_QWORD *)a2 + 1) & 1) != 0)
    v24 = (const char *)*((_QWORD *)a2 + 2);
  else
    v24 = (char *)a2 + 9;
  if (strcmp(v23, v24))
  {
    v22 = v35;
    if (v34)
    {
LABEL_29:
      if (*(_QWORD *)v22)
      {
        if ((v22[8] & 1) != 0)
          (*(void (**)(_QWORD, _QWORD, __n128))(**(_QWORD **)v22 + 40))(*(_QWORD *)v22, *((_QWORD *)v22 + 2), v21);
        *(_OWORD *)v22 = 0u;
        *((_OWORD *)v22 + 1) = 0u;
      }
    }
LABEL_33:
    if ((_QWORD)v41)
    {
      if ((BYTE8(v41) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v41 + 40))();
      v41 = 0u;
      v42 = 0u;
    }
    if ((_QWORD)v39)
    {
      if ((BYTE8(v39) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v39 + 40))();
      v39 = 0u;
      v40 = 0u;
    }
    if (v38[0] && (v38[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v38[0] + 40))();
    LODWORD(v7) = *((_DWORD *)this + 50);
    goto LABEL_45;
  }
  re::AssetManager::assetHandleFromId_assetTablesLocked(this, (const re::DynamicString *)(v13 + 168 * v12 + 128), *(_QWORD *)(*((_QWORD *)this + 23) + 168 * v12 + 160), (uint64_t *)&v31);
  *(_BYTE *)a4 = 1;
  *(_OWORD *)(a4 + 8) = v31;
  v31 = 0uLL;
  *(_QWORD *)(a4 + 24) = v32;
  v32 = 0;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v31);
  v26 = v28;
  v27 = &v34;
  if (!v33[0] || (v27 = v35, v34))
  {
    if (*(_QWORD *)v27)
    {
      if ((v27[8] & 1) != 0)
        (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)v27 + 40))(*(_QWORD *)v27, *((_QWORD *)v27 + 2));
      *(_OWORD *)v27 = 0u;
      *((_OWORD *)v27 + 1) = 0u;
    }
  }
  if ((_QWORD)v41)
  {
    if ((BYTE8(v41) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v41 + 40))();
    v41 = 0u;
    v42 = 0u;
  }
  if ((_QWORD)v39)
  {
    if ((BYTE8(v39) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v39 + 40))();
    v39 = 0u;
    v40 = 0u;
  }
  if (v38[0] && (v38[1] & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v38[0] + 40))();
LABEL_50:
  os_unfair_lock_unlock(v26);
}

uint64_t *re::AssetManager::assetHandleFromId_assetTablesLocked@<X0>(re::AssetManager *this@<X0>, const re::DynamicString *a2@<X2>, uint64_t a3@<X1>, uint64_t *a4@<X8>)
{
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  size_t v11;
  unint64_t v12;
  const char *v13;
  size_t v14;
  unint64_t v15;
  char *v16;
  char v17;
  char *v18;
  uint64_t *result;
  uint64_t *v20;
  unint64_t v21;
  char *v22;
  uint64_t v23;
  char __str[22];
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v8 = *((_QWORD *)a2 + 1);
  if ((v8 & 1) != 0)
    v9 = v8 >> 1;
  else
    v9 = v8 >> 1;
  v10 = v9 + 39;
  v22 = 0;
  v23 = 0;
  v21 = 0;
  re::DynamicString::setCapacity(&v20, v10);
  re::DynamicString::append((re::DynamicString *)&v20, "assetId:", 8uLL);
  snprintf(__str, 0x16uLL, "%llu", a3);
  v11 = strlen(__str);
  re::DynamicString::append((re::DynamicString *)&v20, __str, v11);
  re::DynamicString::append((re::DynamicString *)&v20, ".compiled", 9uLL);
  if ((v21 & 1) != 0)
    v12 = v21 >> 1;
  else
    v12 = v21 >> 1;
  if ((*((_QWORD *)a2 + 1) & 1) != 0)
    v13 = (const char *)*((_QWORD *)a2 + 2);
  else
    v13 = (char *)a2 + 9;
  v14 = strlen(v13);
  re::DynamicString::append((re::DynamicString *)&v20, v13, v14);
  while (1)
  {
    v15 = v21 >> 1;
    if ((v21 & 1) != 0)
      v15 = v21 >> 1;
    if (v12 >= v15)
      break;
    v16 = (char *)re::DynamicString::operator[]((uint64_t)&v20, v12);
    v17 = __tolower(*v16);
    *(_BYTE *)re::DynamicString::operator[]((uint64_t)&v20, v12++) = v17;
  }
  if ((v21 & 1) != 0)
    v18 = v22;
  else
    v18 = (char *)&v21 + 1;
  re::AssetManager::assetHandle(this, v18, 0, 0, a4);
  result = v20;
  if (v20)
  {
    if ((v21 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v20 + 40))();
  }
  return result;
}

os_unfair_lock_s *re::AssetManager::assetHandle@<X0>(os_unfair_lock_s *result@<X0>, const re::AssetPath *a2@<X1>, int a3@<W2>, uint64_t *a4@<X8>)
{
  os_unfair_lock_s *v7;
  os_unfair_lock_s *v8;
  _BYTE v9[8];
  _BYTE v10[144];

  if (!*(_DWORD *)a2)
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    return result;
  }
  v7 = result;
  re::AssetManager::convertToLoadDescriptor(result, a2, v9);
  if (v9[0])
  {
    if (!a3)
    {
      re::AssetManager::assetHandle_assetTablesLocked((re::AssetManager *)v7, (const re::AssetLoadDescriptor *)v10);
      return (os_unfair_lock_s *)re::Optional<re::AssetLoadDescriptor>::~Optional((uint64_t)v9);
    }
    v8 = v7 + 16;
    os_unfair_lock_lock(v7 + 16);
    re::AssetManager::assetHandle_assetTablesLocked((re::AssetManager *)v7, (const re::AssetLoadDescriptor *)v10);
  }
  else
  {
    if (!a3)
    {
      re::AssetManager::getOrAddAssetEntry_assetTablesLocked((_anonymous_namespace_ *)v7, a2, 0, 0, a4);
      return (os_unfair_lock_s *)re::Optional<re::AssetLoadDescriptor>::~Optional((uint64_t)v9);
    }
    v8 = v7 + 16;
    os_unfair_lock_lock(v7 + 16);
    re::AssetManager::getOrAddAssetEntry_assetTablesLocked((_anonymous_namespace_ *)v7, a2, 0, 0, a4);
  }
  os_unfair_lock_unlock(v8);
  return (os_unfair_lock_s *)re::Optional<re::AssetLoadDescriptor>::~Optional((uint64_t)v9);
}

uint64_t re::AssetManager::assetHandle_assetTablesLocked@<X0>(re::AssetManager *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t *v6;
  const char *v8;
  unint64_t v9;
  unint64_t v10[2];

  v6 = (uint64_t *)re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::tryGet((uint64_t)this + 168, (uint64_t)a2);
  if (v6)
    return re::AssetManager::assetHandle_assetTablesLocked(this, a2, *v6, a3);
  if ((*((_QWORD *)a2 + 1) & 1) != 0)
    v8 = (const char *)*((_QWORD *)a2 + 2);
  else
    v8 = (char *)a2 + 9;
  if (!strcmp(v8, "NetworkAsset"))
  {
    re::AssetLoadDescriptor::getIntrospectableData<re::NetworkAssetLoadDescriptorParameters>(a2, (uint64_t **)v10, 0);
    v9 = v10[0];
  }
  else
  {
    uuid_generate_random((unsigned __int8 *)v10);
    v9 = (v10[1] + (v10[0] << 6) + (v10[0] >> 2) - 0x61C8864680B583E9) ^ v10[0];
  }
  return re::AssetManager::assetHandle_assetTablesLocked(this, a2, v9, a3);
}

void re::AssetManager::assetHandle(os_unfair_lock_s *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, uint64_t *a3@<X8>)
{
  os_unfair_lock_s *v6;

  v6 = this + 16;
  os_unfair_lock_lock(this + 16);
  re::AssetManager::assetHandle_assetTablesLocked((re::AssetManager *)this, a2, a3);
  os_unfair_lock_unlock(v6);
}

uint64_t re::AssetManager::getOrAddAssetEntry_assetTablesLocked@<X0>(_anonymous_namespace_ *a1@<X0>, re::DynamicString *a2@<X1>, char a3@<W2>, int a4@<W3>, uint64_t *a5@<X8>)
{
  uint64_t v10;
  re::internal::AssetEntry **v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  const char *v18;
  const char *v19;
  _anonymous_namespace_ *v20;
  const char *v21;
  re::internal::AssetEntry **v22;
  uint64_t result;
  unint64_t v24;
  char v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;

  v10 = (uint64_t)a1 + 72;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  re::DynamicString::setCapacity(&v28, 0);
  re::AssetPath::fullAssetPath(a2, (re::DynamicString *)&v28);
  v11 = (re::internal::AssetEntry **)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v10, (uint64_t)&v28);
  if (v11)
  {
    re::AssetHandle::AssetHandle(a5, *v11);
  }
  else
  {
    v26 = 0;
    v27 = re::internal::AssetEntry::AssetEntry(v12, 1, a4);
    re::AssetPath::getAssetId(a2, &v26);
    v24 = v26;
    v13 = re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)a1 + 120, (uint64_t *)&v24);
    if (v13)
    {
      v14 = v13;
      v15 = *(_QWORD *)(v13 + 32);
      v16 = *(_QWORD *)(v15 + 8);
      v17 = *(const char **)(v15 + 16);
      v18 = (const char *)(v15 + 9);
      if ((v16 & 1) != 0)
        v19 = v17;
      else
        v19 = v18;
      *(_BYTE *)(v12 + 312) = strcmp(v19, "MemoryAsset") == 0;
      re::AssetManager::assignInitialMetadata((uint64_t)a1, (os_unfair_lock_s *)v12, v14);
    }
    re::internal::AssetEntry::addToAssetManager_assetTablesLocked((re::internal::AssetEntry *)v12, a1, a2, a3);
    if ((v29 & 1) != 0)
      v21 = v30;
    else
      v21 = (char *)&v29 + 1;
    v22 = (re::internal::AssetEntry **)re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::SharedPtr<re::internal::AssetEntry>&>(v10, (const re::DynamicString *)&v24, &v27);
    re::AssetHandle::AssetHandle(a5, *v22);
    if (v24 && (v25 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v24 + 40))();
    if (v12)

  }
  result = (uint64_t)v28;
  if (v28)
  {
    if ((v29 & 1) != 0)
      return (*(uint64_t (**)(void))(*v28 + 40))();
  }
  return result;
}

os_unfair_lock_s *re::AssetManager::assetHandle@<X0>(os_unfair_lock_s *this@<X0>, const re::AssetPath *a2@<X1>, uint64_t *a3@<X8>)
{
  return re::AssetManager::assetHandle(this, a2, 1, a3);
}

uint64_t re::AssetManager::assetHandle@<X0>(re::AssetManager *a1@<X0>, char *a2@<X1>, int a3@<W2>, int a4@<W3>, uint64_t *a5@<X8>)
{
  uint64_t *v9;
  NSObject *v10;
  _BYTE *v12;
  _BYTE v13[8];
  _BYTE v14[25];
  _BYTE v15[55];
  uint8_t buf[4];
  char *v17;
  __int16 v18;
  _BYTE *v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v9 = re::AssetManager::parseAssetPath(a1, a2, 0, a4, (uint64_t)v13);
  if (v13[0])
  {
    re::AssetManager::assetHandle((os_unfair_lock_s *)a1, (const re::AssetPath *)v14, a3, a5);
  }
  else
  {
    v10 = *re::assetsLogObjects((re *)v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      if ((v14[24] & 1) != 0)
        v12 = *(_BYTE **)&v15[7];
      else
        v12 = v15;
      *(_DWORD *)buf = 136315394;
      v17 = a2;
      v18 = 2080;
      v19 = v12;
      _os_log_error_impl(&dword_224FE9000, v10, OS_LOG_TYPE_ERROR, "asset string '%s' parse failed: %s", buf, 0x16u);
    }
    *a5 = 0;
    a5[1] = 0;
    a5[2] = 0;
  }
  return re::Result<re::AssetPath,re::DetailedError>::~Result((uint64_t)v13);
}

uint64_t *re::AssetManager::parseAssetPath@<X0>(re::AssetManager *this@<X0>, char *a2@<X1>, const re::AssetPath *a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  _anonymous_namespace_ *v10;
  const char *v11;
  re *v12;
  char *v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *result;
  uint64_t v23;
  const char *v24;
  uint64_t *v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  char v29[8];
  __int128 v30;
  uint64_t v31;
  char v32;
  int v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  _BYTE buf[40];
  _QWORD v42[2];
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  v33 = 0;
  v36 = 0;
  v37 = 0;
  v35 = 0;
  v10 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v34, 0);
  *((_QWORD *)&v38 + 1) = 0;
  v39 = 0uLL;
  re::DynamicString::setCapacity(&v38, 0);
  v40 = 0;
  re::AssetPath::parse((re::AssetPath *)&v33, a2, a3, *((const re::internal::AssetTypeRegistry **)this + 138), *((os_unfair_lock_s **)this + 149), v29);
  if (!v29[0])
  {
    *(_OWORD *)buf = v30;
    re::DynamicString::DynamicString((re::DynamicString *)&buf[16], (const re::DynamicString *)&v31);
    *(_BYTE *)a5 = 0;
    *(_OWORD *)(a5 + 8) = *(_OWORD *)buf;
    v21 = v42[0];
    *(_QWORD *)(a5 + 24) = *(_QWORD *)&buf[16];
    *(_QWORD *)(a5 + 48) = v21;
    *(_OWORD *)(a5 + 32) = *(_OWORD *)&buf[24];
    goto LABEL_16;
  }
  if (!a4 || !*((_BYTE *)this + 576))
    goto LABEL_14;
  v27 = 0;
  v28 = 0;
  v25 = v34;
  v26 = 0;
  re::DynamicString::setCapacity(&v25, 0);
  re::AssetPath::fullAssetPath((re::DynamicString *)&v33, (re::DynamicString *)&v25);
  if ((v26 & 1) != 0)
    v11 = v27;
  else
    v11 = (char *)&v26 + 1;
  v12 = (re *)re::AssetManager::remapDeserializedAssetPath(this, v11);
  if (!v12)
    goto LABEL_12;
  v13 = (char *)v12;
  v14 = *re::assetsLogObjects(v12);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
  {
    if ((v26 & 1) != 0)
      v24 = v27;
    else
      v24 = (char *)&v26 + 1;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v24;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v13;
  }
  re::AssetPath::parse((re::AssetPath *)&v33, v13, 0, *((const re::internal::AssetTypeRegistry **)this + 138), *((os_unfair_lock_s **)this + 149), buf);
  re::Result<re::Unit,re::DetailedError>::operator=((uint64_t)v29, (uint64_t)buf);
  if (!buf[0] && *(_QWORD *)&buf[24] && (buf[32] & 1) != 0)
    (*(void (**)(void))(**(_QWORD **)&buf[24] + 40))();
  if (v29[0])
  {
LABEL_12:
    if (v25 && (v26 & 1) != 0)
      (*(void (**)(void))(*v25 + 40))();
LABEL_14:
    *(_DWORD *)buf = v33;
    re::DynamicString::DynamicString((re::DynamicString *)&buf[8], (const re::DynamicString *)&v34);
    re::DynamicString::DynamicString((re::DynamicString *)v42, (const re::DynamicString *)&v38);
    v15 = v40;
    *(_BYTE *)a5 = 1;
    *(_DWORD *)(a5 + 8) = *(_DWORD *)buf;
    v16 = *(_QWORD *)&buf[32];
    *(_QWORD *)(a5 + 16) = *(_QWORD *)&buf[8];
    *(_OWORD *)(a5 + 24) = *(_OWORD *)&buf[16];
    memset(&buf[8], 0, 32);
    v17 = v42[0];
    v18 = v42[1];
    *(_QWORD *)(a5 + 40) = v16;
    *(_QWORD *)(a5 + 48) = v17;
    v19 = v43;
    v20 = v44;
    v42[0] = 0;
    v43 = 0;
    v44 = 0;
    v45 = v15;
    *(_QWORD *)(a5 + 56) = v18;
    *(_QWORD *)(a5 + 64) = v19;
    *(_QWORD *)(a5 + 72) = v20;
    *(_QWORD *)(a5 + 80) = v15;
    goto LABEL_16;
  }
  *(_OWORD *)buf = v30;
  re::DynamicString::DynamicString((re::DynamicString *)&buf[16], (const re::DynamicString *)&v31);
  *(_BYTE *)a5 = 0;
  *(_OWORD *)(a5 + 8) = *(_OWORD *)buf;
  v23 = v42[0];
  *(_QWORD *)(a5 + 24) = *(_QWORD *)&buf[16];
  *(_QWORD *)(a5 + 48) = v23;
  *(_OWORD *)(a5 + 32) = *(_OWORD *)&buf[24];
  if (v25 && (v26 & 1) != 0)
    (*(void (**)(void))(*v25 + 40))();
LABEL_16:
  if (!v29[0] && v31 && (v32 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v31 + 40))();
  if ((_QWORD)v38)
  {
    if ((BYTE8(v38) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v38 + 40))();
    v38 = 0u;
    v39 = 0u;
  }
  result = v34;
  if (v34)
  {
    if ((v35 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v34 + 40))();
  }
  return result;
}

uint64_t re::AssetManager::assetHandle@<X0>(re::AssetManager *this@<X0>, char *a2@<X1>, uint64_t *a3@<X8>)
{
  return re::AssetManager::assetHandle(this, a2, 1, 0, a3);
}

uint64_t re::AssetManager::assetHandleWithParentAssetPath@<X0>(re::AssetManager *this@<X0>, char *a2@<X1>, const re::AssetPath *a3@<X2>, int a4@<W3>, uint64_t *a5@<X8>)
{
  uint64_t *v10;
  const char *v11;
  const char *v12;
  re::AssetType *v13;
  NSObject *v14;
  re::AssetLoadDescriptor *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t result;
  _BYTE *v22;
  NSObject *v23;
  char *v24;
  const char *v25;
  char *v26;
  char *v27;
  re *v28;
  NSObject *v29;
  _BYTE *v30;
  _BYTE *v31;
  uint64_t *v32[3];
  uint64_t v33;
  char v34;
  _BYTE v35[23];
  char v36[8];
  __int128 v37;
  _BYTE v38[24];
  __int128 v39;
  __int128 v40;
  re::AssetType *v41;
  int v42;
  uint64_t v43;
  char v44;
  _BYTE v45[23];
  __int128 v46;
  __int128 v47;
  uint8_t v48[4];
  char *v49;
  __int16 v50;
  const char *v51;
  uint8_t v52[4];
  char *v53;
  __int16 v54;
  _BYTE *v55;
  __int16 v56;
  _BYTE *v57;
  uint64_t v58;
  uint8_t buf[4];
  _BYTE v60[20];
  _BYTE v61[24];
  __int128 v62;
  uint64_t v63;
  uint64_t v64;
  re::AssetType *v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  re::AssetPath::invalidAssetPath(this, (uint64_t)&v42);
  v10 = re::AssetManager::parseAssetPath(this, a2, (const re::AssetPath *)&v42, 0, (uint64_t)v36);
  if (!v36[0])
  {
    v14 = *re::assetsLogObjects((re *)v10);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      if ((v38[8] & 1) != 0)
        v22 = *(_BYTE **)&v38[16];
      else
        v22 = &v38[9];
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)v60 = a2;
      *(_WORD *)&v60[8] = 2080;
      *(_QWORD *)&v60[10] = v22;
      _os_log_error_impl(&dword_224FE9000, v14, OS_LOG_TYPE_ERROR, "asset string '%s' unparsable: %s", buf, 0x16u);
    }
    goto LABEL_16;
  }
  if ((_DWORD)v37 != v42
    || ((v38[0] & 1) != 0 ? (v11 = *(const char **)&v38[8]) : (v11 = &v38[1]),
        (v44 & 1) != 0 ? (v12 = *(const char **)&v45[7]) : (v12 = v45),
        strcmp(v11, v12)))
  {
    if (!a4 || !*((_BYTE *)this + 576))
      goto LABEL_42;
    re::AssetManager::parseAssetPath(this, a2, 0, 1, (uint64_t)buf);
    if (v36[0])
    {
      if (!buf[0])
      {
        if ((_QWORD)v39)
        {
          if ((BYTE8(v39) & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v39 + 40))();
          v39 = 0u;
          v40 = 0u;
        }
        if (*((_QWORD *)&v37 + 1) && (v38[0] & 1) != 0)
          (*(void (**)(void))(**((_QWORD **)&v37 + 1) + 40))();
        v36[0] = 0;
        v37 = *(_OWORD *)&v60[4];
        *(_QWORD *)v38 = *(_QWORD *)v61;
        *(_QWORD *)&v39 = v62;
        *(_OWORD *)&v38[8] = *(_OWORD *)&v61[8];
        *(_QWORD *)&v62 = 0;
        memset(v61, 0, sizeof(v61));
        goto LABEL_41;
      }
      LODWORD(v37) = *(_DWORD *)&v60[4];
      re::DynamicString::operator=((re::DynamicString *)((char *)&v37 + 8), (re::DynamicString *)&v60[12]);
      re::DynamicString::operator=((re::DynamicString *)&v39, (re::DynamicString *)&v62);
      v13 = v65;
    }
    else
    {
      if (!buf[0])
      {
        v37 = *(_OWORD *)&v60[4];
        re::DynamicString::operator=((re::DynamicString *)v38, (re::DynamicString *)v61);
        goto LABEL_41;
      }
      if (*(_QWORD *)v38 && (v38[8] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)v38 + 40))();
      v36[0] = 1;
      LODWORD(v37) = *(_DWORD *)&v60[4];
      v17 = *(_QWORD *)&v61[16];
      *((_QWORD *)&v37 + 1) = *(_QWORD *)&v60[12];
      *(_OWORD *)v38 = *(_OWORD *)v61;
      *(_QWORD *)&v60[12] = 0;
      memset(v61, 0, sizeof(v61));
      *(_QWORD *)&v38[16] = v17;
      v39 = v62;
      v18 = v63;
      v19 = v64;
      v63 = 0;
      v64 = 0;
      *(_QWORD *)&v40 = v18;
      v62 = 0uLL;
      v13 = v65;
      *((_QWORD *)&v40 + 1) = v19;
    }
    v41 = v13;
LABEL_41:
    re::Result<re::AssetPath,re::DetailedError>::~Result((uint64_t)buf);
LABEL_42:
    re::AssetManager::assetHandle((os_unfair_lock_s *)this, (const re::AssetPath *)&v37, 1, a5);
    goto LABEL_43;
  }
  if (*(_DWORD *)a3 == 8)
  {
    re::AssetManager::resolveChildLoadDescriptors(this, a2, v41, a3, (uint64_t)buf);
    if (buf[0])
    {
      re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray((uint64_t)v52, (uint64_t *)&v60[4]);
      LOBYTE(v33) = 0;
      v15 = (re::AssetLoadDescriptor *)v58;
      if ((*(_QWORD *)(v58 + 8) & 1) != 0)
        v16 = *(const char **)(v58 + 16);
      else
        v16 = (const char *)(v58 + 9);
      if (!strcmp(v16, "NetworkAsset"))
      {
        re::AssetLoadDescriptor::getIntrospectableData<re::NetworkAssetLoadDescriptorParameters>(v15, v32, 0);
        re::AssetManager::assetHandle((uint64_t)this, (uint64_t *)v52, (uint64_t)v32[0], (uint64_t)v48);
      }
      else
      {
        re::AssetManager::assetHandle((uint64_t)this, (uint64_t *)v52, (uint64_t)v48);
      }
      re::Optional<re::AssetHandle>::operator=((uint64_t)&v33, v48);
      if (v48[0])
        re::AssetHandle::~AssetHandle((re::AssetHandle *)((char *)&v49 + 4));
      if (a4 && *((_BYTE *)this + 576))
      {
        if (!(_BYTE)v33)
          goto LABEL_77;
        v24 = (char *)re::AssetHandle::assetInfo((re::AssetHandle *)&v34);
        if ((*((_QWORD *)v24 + 13) & 1) != 0)
          v25 = (const char *)*((_QWORD *)v24 + 14);
        else
          v25 = v24 + 105;
        v26 = (char *)re::AssetManager::remapDeserializedAssetPath(this, v25);
        if (v26)
        {
          v27 = v26;
          v28 = (re *)re::AssetManager::assetHandle(this, v26, 1, 0, (uint64_t *)v32);
          if (v32[1])
          {
            v48[0] = 1;
            re::AssetHandle::AssetHandle((re::AssetHandle *)((char *)&v49 + 4), (const re::AssetHandle *)v32);
            re::Optional<re::AssetHandle>::operator=((uint64_t)&v33, v48);
            if (v48[0])
              re::AssetHandle::~AssetHandle((re::AssetHandle *)((char *)&v49 + 4));
          }
          else
          {
            v29 = *re::assetsLogObjects(v28);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v48 = 136315394;
              v49 = v27;
              v50 = 2080;
              v51 = v25;
              _os_log_error_impl(&dword_224FE9000, v29, OS_LOG_TYPE_ERROR, "Asset not found: '%s', remapped from '%s'", v48, 0x16u);
            }
          }
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v32);
        }
      }
      if ((_BYTE)v33)
      {
        re::AssetHandle::AssetHandle((re::AssetHandle *)a5, (const re::AssetHandle *)&v34);
        if ((_BYTE)v33)
          re::AssetHandle::~AssetHandle((re::AssetHandle *)&v34);
        goto LABEL_78;
      }
LABEL_77:
      *a5 = 0;
      a5[1] = 0;
      a5[2] = 0;
LABEL_78:
      re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)v52);
      if (buf[0])
        re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)&v60[4]);
      goto LABEL_43;
    }
LABEL_16:
    *a5 = 0;
    a5[1] = 0;
    a5[2] = 0;
    goto LABEL_43;
  }
  v20 = re::AssetManager::parseAssetPath(this, a2, a3, a4, (uint64_t)buf);
  if (buf[0])
  {
    re::AssetManager::assetHandle((os_unfair_lock_s *)this, (const re::AssetPath *)&v60[4], 1, a5);
  }
  else
  {
    v23 = *re::assetsLogObjects((re *)v20);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      re::AssetPath::fullAssetPath(a3, (re::DynamicString *)&v33);
      v30 = (v34 & 1) != 0 ? *(_BYTE **)&v35[7] : v35;
      v31 = (v61[8] & 1) != 0 ? *(_BYTE **)&v61[16] : &v61[9];
      *(_DWORD *)v52 = 136315650;
      v53 = a2;
      v54 = 2080;
      v55 = v30;
      v56 = 2080;
      v57 = v31;
      _os_log_error_impl(&dword_224FE9000, v23, OS_LOG_TYPE_ERROR, "asset string '%s' parent '%s' parse failed: %s", v52, 0x20u);
      if (v33)
      {
        if ((v34 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v33 + 40))();
      }
    }
    *a5 = 0;
    a5[1] = 0;
    a5[2] = 0;
  }
  re::Result<re::AssetPath,re::DetailedError>::~Result((uint64_t)buf);
LABEL_43:
  re::Result<re::AssetPath,re::DetailedError>::~Result((uint64_t)v36);
  if ((_QWORD)v46)
  {
    if ((BYTE8(v46) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v46 + 40))();
    v46 = 0u;
    v47 = 0u;
  }
  result = v43;
  if (v43)
  {
    if ((v44 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v43 + 40))();
  }
  return result;
}

uint64_t re::AssetManager::assetHandleWithParentAssetHandle@<X0>(re::AssetManager *this@<X0>, char *a2@<X1>, const re::AssetHandle *a3@<X2>, uint64_t *a4@<X8>)
{
  const re::AssetPath *v7;

  v7 = (const re::AssetPath *)re::AssetHandle::legacy_assetPath(a3);
  return re::AssetManager::assetHandleWithParentAssetPath(this, a2, v7, 0, a4);
}

uint64_t re::AssetManager::assetHandleWithParentAssetPath@<X0>(re::AssetManager *this@<X0>, char *a2@<X1>, const re::AssetPath *a3@<X2>, uint64_t *a4@<X8>)
{
  return re::AssetManager::assetHandleWithParentAssetPath(this, a2, a3, 0, a4);
}

void re::AssetManager::resolveChildLoadDescriptors(re::AssetManager *this@<X0>, const char *a2@<X1>, const re::AssetType *a3@<X2>, const re::AssetPath *a4@<X3>, uint64_t a5@<X8>)
{
  _BOOL8 AssetId;
  uint64_t v10;
  re *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t ProviderForScheme;
  re *v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  _BYTE *v21;
  NSObject *v22;
  const char *v23;
  NSObject *v24;
  uint32_t v25;
  NSObject *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;
  int v32;
  uint64_t v33;
  unint64_t v34;
  uint8_t buf[4];
  _BYTE *v36;
  _BYTE v37[12];
  char v38;
  _BYTE v39[143];
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v34 = 0;
  AssetId = re::AssetPath::getAssetId(a4, &v34);
  if (!AssetId)
  {
    v22 = *re::assetsLogObjects((re *)AssetId);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
LABEL_27:
      *(_BYTE *)a5 = 0;
      return;
    }
    *(_WORD *)v37 = 0;
    v23 = "Failed to get assetId from an asset path with type kAssetId.";
    v24 = v22;
    v25 = 2;
LABEL_30:
    _os_log_error_impl(&dword_224FE9000, v24, OS_LOG_TYPE_ERROR, v23, v37, v25);
    goto LABEL_27;
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  *(_QWORD *)v37 = v34;
  v10 = re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 120, (uint64_t *)v37);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 16);
  if (!v10 || (v12 = *(_QWORD *)(v10 + 16)) == 0)
  {
    v26 = *re::assetsLogObjects(v11);
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      goto LABEL_27;
    *(_DWORD *)v37 = 134217984;
    *(_QWORD *)&v37[4] = v34;
    v23 = "Failed to find AssetLoadDescriptors registered for assetId %llu.";
    v24 = v26;
    v25 = 12;
    goto LABEL_30;
  }
  v33 = 0;
  v31 = 0uLL;
  v30 = 0;
  v32 = 0;
  v13 = *(_QWORD *)(v10 + 32);
  v14 = 144 * v12;
  do
  {
    if ((*(_BYTE *)(v13 + 8) & 1) != 0)
      v15 = *(const char **)(v13 + 16);
    else
      v15 = (const char *)(v13 + 9);
    ProviderForScheme = re::AssetProviderRegistry::tryGetProviderForScheme(*((os_unfair_lock_s **)this + 149), v15);
    if (ProviderForScheme)
    {
      v17 = (re *)(*(_QWORD *(**)(_BYTE *__return_ptr, uint64_t, uint64_t, const char *, _QWORD))(*(_QWORD *)ProviderForScheme + 48))(v37, ProviderForScheme, v13, a2, *(_QWORD *)a3);
      if (v37[0])
      {
        re::DynamicArray<re::AssetLoadDescriptor>::add((_anonymous_namespace_ *)&v30, (re::DynamicString *)&v37[8]);
      }
      else
      {
        v20 = *re::assetsLogObjects(v17);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          if ((v38 & 1) != 0)
            v21 = *(_BYTE **)&v39[7];
          else
            v21 = v39;
          *(_DWORD *)buf = 136315138;
          v36 = v21;
          _os_log_error_impl(&dword_224FE9000, v20, OS_LOG_TYPE_ERROR, "Failed to resolve child AssetLoadDescriptor with error: %s.", buf, 0xCu);
        }
      }
      re::Result<re::AssetLoadDescriptor,re::DynamicString>::~Result((uint64_t)v37);
    }
    else
    {
      v18 = *re::assetsLogObjects(0);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        if ((*(_BYTE *)(v13 + 8) & 1) != 0)
          v19 = *(_QWORD *)(v13 + 16);
        else
          v19 = v13 + 9;
        *(_DWORD *)v37 = 136315138;
        *(_QWORD *)&v37[4] = v19;
        _os_log_error_impl(&dword_224FE9000, v18, OS_LOG_TYPE_ERROR, "Failed to find a registered AssetProvider for scheme %s.", v37, 0xCu);
      }
    }
    v13 += 144;
    v14 -= 144;
  }
  while (v14);
  v27 = v32;
  v28 = v33;
  v29 = v30;
  *(_BYTE *)a5 = 1;
  *(_QWORD *)(a5 + 8) = v29;
  *(_OWORD *)(a5 + 16) = v31;
  v30 = 0;
  v31 = 0uLL;
  *(_QWORD *)(a5 + 40) = v28;
  v33 = 0;
  v32 = v27 + 1;
  *(_DWORD *)(a5 + 32) = 1;
  re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)&v30);
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<re::NetworkAssetLoadDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2, re::Allocator *a3)
{
  uint64_t **v4;
  unsigned __int8 v5;
  __guard *v6;
  int v8;
  int v9;
  re::Allocator *v11;
  re::AssetLoadDescriptor *v12;

  v4 = a2;
  if ((v5 & 1) == 0)
  {
    v12 = a1;
    v11 = a3;
    v4 = a2;
    a3 = v11;
    v9 = v8;
    a1 = v12;
    if (v9)
    {
      re::introspect<re::NetworkAssetLoadDescriptorParameters>(void)::info = re::introspect_NetworkAssetLoadDescriptorParameters(0);
      a1 = v12;
      v4 = a2;
      a3 = v11;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)v6[50], v4, a3);
}

void re::AssetManager::assetHandle(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  os_unfair_lock_s *v8;
  __int128 v9;
  uint64_t v10;

  v8 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  re::AssetManager::assetHandle_assetTablesLocked((_QWORD *)a1, a2, a3, (uint64_t *)&v9);
  *(_BYTE *)a4 = 1;
  *(_OWORD *)(a4 + 8) = v9;
  v9 = 0uLL;
  *(_QWORD *)(a4 + 24) = v10;
  v10 = 0;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v9);
  os_unfair_lock_unlock(v8);
}

uint64_t re::Optional<re::AssetHandle>::operator=(uint64_t a1, _QWORD *a2)
{
  int v3;
  BOOL v4;
  BOOL v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = *(unsigned __int8 *)a2;
  if (*(_BYTE *)a1)
    v4 = 0;
  else
    v4 = v3 == 0;
  if (!v4)
  {
    if (*(_BYTE *)a1)
      v5 = v3 == 0;
    else
      v5 = 0;
    if (v5)
    {
      re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 8));
      *(_BYTE *)a1 = 0;
    }
    else
    {
      if (*(_BYTE *)a1)
        v6 = 1;
      else
        v6 = v3 == 0;
      if (v6)
      {
        v7 = *(_QWORD *)(a1 + 16);
        *(_QWORD *)(a1 + 16) = a2[2];
        a2[2] = v7;
      }
      else
      {
        *(_BYTE *)a1 = 1;
        *(_QWORD *)(a1 + 16) = 0;
        *(_QWORD *)(a1 + 24) = 0;
        *(_QWORD *)(a1 + 8) = 0;
        *(_QWORD *)(a1 + 16) = a2[2];
        a2[2] = 0;
      }
      v8 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 8) = 0;
      *(_QWORD *)(a1 + 8) = a2[1];
      a2[1] = v8;
      v9 = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(a1 + 24) = a2[3];
      a2[3] = v9;
    }
  }
  return a1;
}

uint64_t re::AssetManager::remapDeserializedAssetPath(re::AssetManager *this, const char *a2)
{
  os_unfair_lock_s *v4;
  _anonymous_namespace_ *v5;
  uint64_t v6;
  uint64_t v8;
  char v9;

  if (!*((_BYTE *)this + 576))
    return 0;
  v4 = (os_unfair_lock_s *)((char *)this + 64);
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  v6 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)this + 400, (uint64_t)&v8);
  if (v8 && (v9 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v8 + 40))();
  if (v6)
  {
    if ((*(_BYTE *)(v6 + 8) & 1) != 0)
      v6 = *(_QWORD *)(v6 + 16);
    else
      v6 += 9;
  }
  os_unfair_lock_unlock(v4);
  return v6;
}

uint64_t *re::AssetManager::parseAssetPath@<X0>(re::AssetManager *this@<X0>, char *a2@<X1>, const re::AssetPath *a3@<X2>, uint64_t a4@<X8>)
{
  return re::AssetManager::parseAssetPath(this, a2, a3, 0, a4);
}

void re::AssetManager::assetHandle(os_unfair_lock_s *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  os_unfair_lock_s *v8;

  v8 = this + 16;
  os_unfair_lock_lock(this + 16);
  re::AssetManager::assetHandle_assetTablesLocked((re::AssetManager *)this, a2, a3, a4);
  os_unfair_lock_unlock(v8);
}

uint64_t re::AssetManager::assetHandle_assetTablesLocked@<X0>(re::AssetManager *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v8[3];
  int v9;
  uint64_t v10;

  v10 = 0;
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  re::DynamicArray<re::AssetLoadDescriptor>::add((_anonymous_namespace_ *)v8, a2);
  re::AssetManager::assetHandle_assetTablesLocked(this, v8, a3, a4);
  return re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)v8);
}

uint64_t *re::AssetManager::assetHandle_assetTablesLocked@<X0>(_QWORD *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>)
{
  re::internal::AssetIdLoadDescriptorTable *v8;
  uint64_t v9;
  uint64_t v11;

  v8 = (re::internal::AssetIdLoadDescriptorTable *)(a1 + 15);
  v9 = a2[4];
  v11 = a3;
  if (!re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey((uint64_t)(a1 + 15), &v11))
  {
    re::internal::AssetIdLoadDescriptorTable::addNewImmutable(v8, a3, a2);
    if (a1[151])
      re::NetworkActionQueue::queueSyncActionShareAsset((uint64_t)(a1 + 96), a3, 0);
  }
  return re::AssetManager::assetHandleFromId_assetTablesLocked((re::AssetManager *)a1, (const re::DynamicString *)(v9 + 112), a3, a4);
}

uint64_t re::internal::AssetIdLoadDescriptorTable::addNewImmutable(re::internal::AssetIdLoadDescriptorTable *a1, unint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  re::DynamicString *v10;
  uint64_t v11;
  unint64_t v12;

  v12 = a2;
  if (re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey((uint64_t)a1, (uint64_t *)&v12))
  {
    return 0;
  }
  v6 = a3[2];
  if (v6)
  {
    v7 = a3[4];
    v8 = 144 * v6;
    while (!re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::containsKey((uint64_t)a1 + 48, v7))
    {
      v7 += 144;
      v8 -= 144;
      if (!v8)
      {
        v9 = a3[2];
        if (v9)
        {
          v10 = (re::DynamicString *)a3[4];
          v11 = 144 * v9;
          do
          {
            re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::add<unsigned long long &>((uint64_t)a1 + 48, v10, &v12);
            v10 = (re::DynamicString *)((char *)v10 + 144);
            v11 -= 144;
          }
          while (v11);
        }
        goto LABEL_10;
      }
    }
    return 0;
  }
LABEL_10:
  re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add((uint64_t)a1, (uint64_t *)&v12, a3);
  re::internal::AssetIdLoadDescriptorTable::markDependenciesDirty(a1, v12);
  return 1;
}

uint64_t re::AssetManager::createNewImmutableAssetHandle@<X0>(os_unfair_lock_s *a1@<X0>, re::DynamicString *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v8[3];
  int v9;
  uint64_t v10;
  uuid_t out;

  v10 = 0;
  memset(v8, 0, sizeof(v8));
  v9 = 0;
  re::DynamicArray<re::AssetLoadDescriptor>::add((_anonymous_namespace_ *)v8, a2);
  uuid_generate_random(out);
  re::AssetManager::createNewImmutableAssetHandle(a1, v8, (*(_QWORD *)&out[8] + (*(_QWORD *)out << 6) + (*(_QWORD *)out >> 2) - 0x61C8864680B583E9) ^ *(_QWORD *)out, a3, a4);
  return re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)v8);
}

void re::AssetManager::createNewImmutableAssetHandle(os_unfair_lock_s *a1@<X0>, uint64_t *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  _QWORD v8[2];

  uuid_generate_random((unsigned __int8 *)v8);
  re::AssetManager::createNewImmutableAssetHandle(a1, a2, (v8[1] + (v8[0] << 6) + (v8[0] >> 2) - 0x61C8864680B583E9) ^ v8[0], a3, a4);
}

void re::AssetManager::createNewImmutableAssetHandle(os_unfair_lock_s *a1@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  os_unfair_lock_s *v10;
  _BOOL8 v11;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BOOL8 v18;
  NSObject *v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  if (!a2[2])
  {
    *(_BYTE *)a5 = 0;
    return;
  }
  v10 = a1 + 16;
  os_unfair_lock_lock(a1 + 16);
  *(_QWORD *)&v21 = a3;
  v11 = re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey((uint64_t)&a1[30], (uint64_t *)&v21);
  if (v11)
  {
    v12 = *re::assetsLogObjects((re *)v11);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
LABEL_17:
      *(_BYTE *)a5 = 0;
      goto LABEL_18;
    }
    LODWORD(v21) = 134217984;
    *(_QWORD *)((char *)&v21 + 4) = a3;
    v13 = "Can't create new immutable asset. AssetId:%llu already exists.";
    v14 = v12;
LABEL_16:
    _os_log_error_impl(&dword_224FE9000, v14, OS_LOG_TYPE_ERROR, v13, (uint8_t *)&v21, 0xCu);
    goto LABEL_17;
  }
  v15 = a2[2];
  if (v15)
  {
    v16 = a2[4];
    v17 = 144 * v15;
    while (1)
    {
      v18 = re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::containsKey((uint64_t)&a1[42], v16);
      if (v18)
        break;
      v16 += 144;
      v17 -= 144;
      if (!v17)
        goto LABEL_10;
    }
    v19 = *re::assetsLogObjects((re *)v18);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      goto LABEL_17;
    if ((*(_BYTE *)(v16 + 8) & 1) != 0)
      v20 = *(_QWORD *)(v16 + 16);
    else
      v20 = v16 + 9;
    LODWORD(v21) = 136315138;
    *(_QWORD *)((char *)&v21 + 4) = v20;
    v13 = "Can't create new immutable asset. An asset with specified load descriptor %s already exists.";
    v14 = v19;
    goto LABEL_16;
  }
LABEL_10:
  re::AssetManager::addNewAssetEntry_assetTablesLocked((uint64_t *)&v21, (uint64_t)a1, a2, a3, 0, a4);
  *(_BYTE *)a5 = 1;
  *(_OWORD *)(a5 + 8) = v21;
  v21 = 0uLL;
  *(_QWORD *)(a5 + 24) = v22;
  v22 = 0;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v21);
LABEL_18:
  os_unfair_lock_unlock(v10);
}

uint64_t re::AssetManager::createNewImmutableAssetHandle@<X0>(os_unfair_lock_s *a1@<X0>, re::DynamicString *a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v10[3];
  int v11;
  uint64_t v12;

  v12 = 0;
  memset(v10, 0, sizeof(v10));
  v11 = 0;
  re::DynamicArray<re::AssetLoadDescriptor>::add((_anonymous_namespace_ *)v10, a2);
  re::AssetManager::createNewImmutableAssetHandle(a1, v10, a3, a4, a5);
  return re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)v10);
}

void re::AssetManager::addNewAssetEntry_assetTablesLocked(uint64_t *a1, uint64_t a2, uint64_t *a3, unint64_t a4, int a5, int a6)
{
  re::internal::AssetIdLoadDescriptorTable *v12;
  _BOOL8 v13;
  NSObject *v14;
  _anonymous_namespace_ *v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  _anonymous_namespace_ *v19;
  const char *v20;
  uint64_t v21;
  re *v22;
  NSObject *v23;
  _anonymous_namespace_ *v24;
  _BYTE *v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  const char *v29;
  const char *v30;
  _anonymous_namespace_ *v31;
  const char *v32;
  re::internal::AssetEntry **v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  uint64_t v40;
  _BYTE v41[12];
  _BYTE buf[24];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  v12 = (re::internal::AssetIdLoadDescriptorTable *)(a2 + 120);
  *(_QWORD *)buf = a4;
  v13 = re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(a2 + 120, (uint64_t *)buf);
  if (v13)
  {
    v14 = *re::assetsLogObjects((re *)v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = a4;
      _os_log_error_impl(&dword_224FE9000, v14, OS_LOG_TYPE_ERROR, "Can't add new assetEntry. AssetId:%llu already exists.", buf, 0xCu);
    }
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
  else
  {
    v35 = a2 + 72;
    *(_DWORD *)buf = 0;
    *(_OWORD *)&buf[8] = 0u;
    v43 = 0u;
    v15 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&buf[8], 0);
    v45 = 0u;
    v44 = 0u;
    re::DynamicString::setCapacity(&v44, 0);
    v46 = 0;
    v16 = a3[4];
    if ((*(_BYTE *)(v16 + 120) & 1) != 0)
      v17 = *(char **)(v16 + 128);
    else
      v17 = (char *)(v16 + 121);
    v18 = re::internal::AssetTypeRegistry::assetTypeWithName(*(re::internal::AssetTypeRegistry **)(a2 + 1104), v17);
    re::AssetPath::initAssetIdAssetPath((uint64_t)buf, a4, v18);
    v39 = 0;
    v40 = 0;
    v37 = *(_QWORD *)&buf[8];
    v38 = 0;
    re::DynamicString::setCapacity(&v37, 0);
    v19 = re::AssetPath::fullAssetPath((re::DynamicString *)buf, (re::DynamicString *)&v37);
    if ((v38 & 1) != 0)
      v20 = v39;
    else
      v20 = (char *)&v38 + 1;
    v21 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v35, (uint64_t)v41);
    v22 = *(re **)v41;
    if (*(_QWORD *)v41 && (v41[8] & 1) != 0)
      v22 = (re *)(*(uint64_t (**)(void))(**(_QWORD **)v41 + 40))();
    if (v21)
    {
      v23 = *re::assetsLogObjects(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        if ((v38 & 1) != 0)
          v34 = v39;
        else
          v34 = (char *)&v38 + 1;
        *(_DWORD *)v41 = 136315138;
        *(_QWORD *)&v41[4] = v34;
        _os_log_error_impl(&dword_224FE9000, v23, OS_LOG_TYPE_ERROR, "Can't create new immutable asset. An immutable asset %s already exists.", v41, 0xCu);
      }
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    else
    {
      if (a5)
        v24 = (_anonymous_namespace_ *)re::internal::AssetIdLoadDescriptorTable::addNewMutable((uint64_t)v12, a4, (uint64_t)a3);
      else
        v24 = (_anonymous_namespace_ *)re::internal::AssetIdLoadDescriptorTable::addNewImmutable(v12, a4, a3);
      if (*(_QWORD *)(a2 + 1208))
        re::NetworkActionQueue::queueSyncActionShareAsset(a2 + 768, a4, a6);
      v36 = re::internal::AssetEntry::AssetEntry((uint64_t)v25, 1, a6);
      v26 = a3[4];
      v27 = *(_QWORD *)(v26 + 8);
      v28 = *(const char **)(v26 + 16);
      v29 = (const char *)(v26 + 9);
      if ((v27 & 1) != 0)
        v30 = v28;
      else
        v30 = v29;
      v25[312] = strcmp(v30, "MemoryAsset") == 0;
      re::internal::AssetEntry::addToAssetManager_assetTablesLocked((re::internal::AssetEntry *)v25, (re::AssetManager *)a2, (const re::AssetPath *)buf, a5);
      re::AssetManager::assignInitialMetadata(a2, (os_unfair_lock_s *)v25, (uint64_t)a3);
      re::internal::AssetIdLoadDescriptorTable::markDependenciesDirty(v12, a4);
      if ((v38 & 1) != 0)
        v32 = v39;
      else
        v32 = (char *)&v38 + 1;
      v33 = (re::internal::AssetEntry **)re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::SharedPtr<re::internal::AssetEntry>&>(v35, (const re::DynamicString *)v41, &v36);
      re::AssetHandle::AssetHandle(a1, *v33);
      if (*(_QWORD *)v41 && (v41[8] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)v41 + 40))();

    }
    if (v37 && (v38 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v37 + 40))();
    if ((_QWORD)v44)
    {
      if ((BYTE8(v44) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v44 + 40))();
      v44 = 0u;
      v45 = 0u;
    }
    if (*(_QWORD *)&buf[8] && (buf[16] & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&buf[8] + 40))();
  }
}

void re::AssetManager::existingImmutableAssetHandle(re::AssetManager *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, uint64_t a3@<X8>)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  uint64_t *v8;
  char *v9;
  char *v10;
  _anonymous_namespace_ *v11;
  _anonymous_namespace_ *v12;
  _anonymous_namespace_ *v13;
  const char *v14;
  re::internal::AssetEntry **v15;
  char v16;
  __int128 v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  int v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;

  v6 = (os_unfair_lock_s *)((char *)this + 64);
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  v7 = re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::tryGet((uint64_t)this + 168, (uint64_t)a2);
  if (v7)
  {
    v8 = (uint64_t *)v7;
    v9 = (char *)this + 72;
    if ((*((_BYTE *)a2 + 120) & 1) != 0)
      v10 = (char *)*((_QWORD *)a2 + 16);
    else
      v10 = (char *)a2 + 121;
    v11 = (_anonymous_namespace_ *)re::internal::AssetTypeRegistry::assetTypeWithName(*((re::internal::AssetTypeRegistry **)this + 138), v10);
    v23 = 0;
    v26 = 0;
    v27 = 0;
    v25 = 0;
    v12 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v24, 0);
    *((_QWORD *)&v28 + 1) = 0;
    v29 = 0uLL;
    re::DynamicString::setCapacity(&v28, 0);
    v30 = 0;
    re::AssetPath::initAssetIdAssetPath((uint64_t)&v23, *v8, (uint64_t)v11);
    v21 = 0;
    v22 = 0;
    v19 = v24;
    v20 = 0;
    re::DynamicString::setCapacity(&v19, 0);
    v13 = re::AssetPath::fullAssetPath((re::DynamicString *)&v23, (re::DynamicString *)&v19);
    if ((v20 & 1) != 0)
      v14 = v21;
    else
      v14 = (char *)&v20 + 1;
    v15 = (re::internal::AssetEntry **)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)v9, (uint64_t)&v17);
    if ((_QWORD)v17 && (BYTE8(v17) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v17 + 40))();
    if (v15)
    {
      re::AssetHandle::AssetHandle((uint64_t *)&v17, *v15);
      *(_OWORD *)(a3 + 8) = v17;
      v17 = 0uLL;
      *(_QWORD *)(a3 + 24) = v18;
      v18 = 0;
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&v17);
      v16 = 1;
    }
    else
    {
      v16 = 0;
    }
    *(_BYTE *)a3 = v16;
    if (v19 && (v20 & 1) != 0)
      (*(void (**)(void))(*v19 + 40))();
    if ((_QWORD)v28)
    {
      if ((BYTE8(v28) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v28 + 40))();
      v28 = 0u;
      v29 = 0u;
    }
    if (v24 && (v25 & 1) != 0)
      (*(void (**)(void))(*v24 + 40))();
  }
  else
  {
    *(_BYTE *)a3 = 0;
  }
  os_unfair_lock_unlock(v6);
}

uint64_t re::AssetManager::createNewMutableAssetHandle@<X0>(os_unfair_lock_s *a1@<X0>, re::DynamicString *a2@<X1>, int a3@<W2>, re::AssetHandle *a4@<X8>)
{
  return re::AssetManager::createNewMutableAssetHandle(a1, a2, a3, 1, a4);
}

uint64_t re::AssetManager::createNewMutableAssetHandle@<X0>(os_unfair_lock_s *a1@<X0>, re::DynamicString *a2@<X1>, int a3@<W2>, int a4@<W3>, re::AssetHandle *a5@<X8>)
{
  __int128 v10;
  uint64_t v11;
  char v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15[3];
  int v16;
  uint64_t v17;

  v17 = 0;
  memset(v15, 0, sizeof(v15));
  v16 = 0;
  re::DynamicArray<re::AssetLoadDescriptor>::add((_anonymous_namespace_ *)v15, a2);
  re::AssetManager::createNewMutableAssetHandle(a1, v15, a3, a4, (re::AssetHandle *)&v10);
  v12 = 1;
  v13 = v10;
  v10 = 0uLL;
  v14 = v11;
  v11 = 0;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v10);
  re::AssetHandle::AssetHandle(a5, (const re::AssetHandle *)&v13);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v13);
  return re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)v15);
}

void re::AssetManager::createNewMutableAssetHandle(os_unfair_lock_s *a1@<X0>, uint64_t *a2@<X1>, int a3@<W2>, int a4@<W3>, re::AssetHandle *a5@<X8>)
{
  unint64_t v10;
  _QWORD v11[3];

  uuid_generate_random((unsigned __int8 *)&v10);
  re::AssetManager::createNewMutableAssetHandle(a1, a2, (v11[0] + (v10 << 6) + (v10 >> 2) - 0x61C8864680B583E9) ^ v10, a3, a4, (uint64_t)&v10);
  re::AssetHandle::AssetHandle(a5, (const re::AssetHandle *)v11);
  if ((_BYTE)v10)
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v11);
}

void re::AssetManager::createNewMutableAssetHandle(os_unfair_lock_s *a1@<X0>, uint64_t *a2@<X1>, int a3@<W2>, re::AssetHandle *a4@<X8>)
{
  re::AssetManager::createNewMutableAssetHandle(a1, a2, a3, 1, a4);
}

void re::AssetManager::createNewMutableAssetHandle(os_unfair_lock_s *a1@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, int a5@<W4>, uint64_t a6@<X8>)
{
  os_unfair_lock_s *v11;
  _BOOL8 v12;
  NSObject *v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  if (!a2[2])
  {
    *(_BYTE *)a6 = 0;
    return;
  }
  if (a5)
  {
    v11 = a1 + 16;
    os_unfair_lock_lock(a1 + 16);
  }
  else
  {
    v11 = 0;
  }
  *(_QWORD *)&v14 = a3;
  v12 = re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey((uint64_t)&a1[30], (uint64_t *)&v14);
  if (!v12)
  {
    re::AssetManager::addNewAssetEntry_assetTablesLocked((uint64_t *)&v14, (uint64_t)a1, a2, a3, 1, a4);
    *(_BYTE *)a6 = 1;
    *(_OWORD *)(a6 + 8) = v14;
    v14 = 0uLL;
    *(_QWORD *)(a6 + 24) = v15;
    v15 = 0;
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v14);
    if (!v11)
      return;
    goto LABEL_12;
  }
  v13 = *re::assetsLogObjects((re *)v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    LODWORD(v14) = 134217984;
    *(_QWORD *)((char *)&v14 + 4) = a3;
    _os_log_error_impl(&dword_224FE9000, v13, OS_LOG_TYPE_ERROR, "Can't create new mutable asset. AssetId:%llu already exists.", (uint8_t *)&v14, 0xCu);
  }
  *(_BYTE *)a6 = 0;
  if (v11)
LABEL_12:
    os_unfair_lock_unlock(v11);
}

uint64_t re::AssetManager::createNewMutableAssetHandle@<X0>(os_unfair_lock_s *a1@<X0>, re::DynamicString *a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  uint64_t v10[3];
  int v11;
  uint64_t v12;

  v12 = 0;
  memset(v10, 0, sizeof(v10));
  v11 = 0;
  re::DynamicArray<re::AssetLoadDescriptor>::add((_anonymous_namespace_ *)v10, a2);
  re::AssetManager::createNewMutableAssetHandle(a1, v10, a3, a4, 1, a5);
  return re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)v10);
}

void re::AssetManager::createNewMutableAssetHandle(os_unfair_lock_s *a1@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  re::AssetManager::createNewMutableAssetHandle(a1, a2, a3, a4, 1, a5);
}

void re::AssetManager::existingMutableAssetHandles(os_unfair_lock_s *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, re::AssetManager *a3@<X8>)
{
  os_unfair_lock_s *v6;

  v6 = this + 16;
  os_unfair_lock_lock(this + 16);
  re::AssetManager::existingMutableAssetHandles_assetTablesLocked(a3, (re::internal::AssetTypeRegistry **)this, (uint64_t)a2);
  os_unfair_lock_unlock(v6);
}

uint64_t re::AssetManager::existingMutableAssetHandles_assetTablesLocked(re::AssetManager *this, re::internal::AssetTypeRegistry **a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  char *v8;
  _anonymous_namespace_ *v9;
  _anonymous_namespace_ *v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  int v14;
  char *v15;
  uint64_t v16;
  _anonymous_namespace_ *v17;
  const char *v18;
  re::internal::AssetEntry **v19;
  unsigned int v20;
  int v21;
  int v22;
  uint64_t v23;
  char v24;
  uint64_t *v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  int v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  result = re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::tryGet((uint64_t)(a2 + 27), a3);
  if (result)
  {
    v7 = result;
    if ((*(_BYTE *)(a3 + 120) & 1) != 0)
      v8 = *(char **)(a3 + 128);
    else
      v8 = (char *)(a3 + 121);
    v9 = (_anonymous_namespace_ *)re::internal::AssetTypeRegistry::assetTypeWithName(a2[138], v8);
    v29 = 0;
    v32 = 0;
    v33 = 0;
    v31 = 0;
    v10 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v30, 0);
    *((_QWORD *)&v34 + 1) = 0;
    v35 = 0uLL;
    re::DynamicString::setCapacity(&v34, 0);
    v36 = 0;
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
    *(_QWORD *)this = 0;
    *((_DWORD *)this + 6) = 0;
    v11 = *(unsigned int *)(v7 + 32);
    v12 = 0;
    if ((_DWORD)v11)
    {
      v13 = (int *)(*(_QWORD *)(v7 + 16) + 8);
      while (1)
      {
        v14 = *v13;
        v13 += 6;
        if (v14 < 0)
          break;
        if (v11 == ++v12)
        {
          LODWORD(v12) = *(_DWORD *)(v7 + 32);
          break;
        }
      }
    }
    if ((_DWORD)v11 != (_DWORD)v12)
    {
      v15 = (char *)(a2 + 9);
      v16 = v12;
      do
      {
        re::AssetPath::initAssetIdAssetPath((uint64_t)&v29, *(_QWORD *)(*(_QWORD *)(v7 + 16) + 24 * v16 + 16), (uint64_t)v9);
        v27 = 0;
        v28 = 0;
        v26 = 0;
        v25 = v30;
        re::DynamicString::setCapacity(&v25, 0);
        v17 = re::AssetPath::fullAssetPath((re::DynamicString *)&v29, (re::DynamicString *)&v25);
        if ((v26 & 1) != 0)
          v18 = v27;
        else
          v18 = (char *)&v26 + 1;
        v19 = (re::internal::AssetEntry **)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)v15, (uint64_t)&v23);
        if (v23 && (v24 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v23 + 40))();
        if (v19)
        {
          re::AssetHandle::AssetHandle(&v23, *v19);
          re::DynamicArray<re::AssetHandle>::add(this, &v23);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)&v23);
        }
        v20 = *(_DWORD *)(v7 + 32);
        if (v20 <= (int)v12 + 1)
          v21 = v12 + 1;
        else
          v21 = *(_DWORD *)(v7 + 32);
        v22 = v12;
        while (1)
        {
          v16 = (v22 + 1);
          if (v21 - 1 == v22)
            break;
          ++v22;
          LODWORD(v12) = v16;
          if ((*(_DWORD *)(*(_QWORD *)(v7 + 16) + 24 * v16 + 8) & 0x80000000) != 0)
            goto LABEL_29;
        }
        LODWORD(v12) = v21;
LABEL_29:
        if (v25 && (v26 & 1) != 0)
        {
          (*(void (**)(void))(*v25 + 40))();
          v20 = *(_DWORD *)(v7 + 32);
        }
      }
      while (v20 != (_DWORD)v12);
    }
    if ((_QWORD)v34)
    {
      if ((BYTE8(v34) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v34 + 40))();
      v34 = 0u;
      v35 = 0u;
    }
    result = (uint64_t)v30;
    if (v30)
    {
      if ((v31 & 1) != 0)
        return (*(uint64_t (**)(void))(*v30 + 40))();
    }
  }
  else
  {
    *((_QWORD *)this + 4) = 0;
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
    *(_QWORD *)this = 0;
    *((_DWORD *)this + 6) = 0;
  }
  return result;
}

_QWORD *re::DynamicArray<re::AssetHandle>::add(_QWORD *this, uint64_t *a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v3 = this;
  v4 = this[2];
  if (v4 >= this[1])
  {
    this = re::DynamicArray<re::AssetHandle>::growCapacity(this, v4 + 1);
    v4 = v3[2];
  }
  v5 = (uint64_t *)(v3[4] + 24 * v4);
  *v5 = 0;
  v5[1] = 0;
  v5[2] = 0;
  v5[1] = a2[1];
  a2[1] = 0;
  v6 = *v5;
  *v5 = 0;
  *v5 = *a2;
  *a2 = v6;
  v7 = v5[2];
  v5[2] = a2[2];
  a2[2] = v7;
  ++v3[2];
  ++*((_DWORD *)v3 + 6);
  return this;
}

uint64_t re::AssetManager::convertToMutable(os_unfair_lock_s *this, const re::AssetHandle *a2, int a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  os_unfair_lock_s *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  const re::AssetLoadDescriptor *v13;
  re *isEngineAssetDescriptor;
  os_unfair_lock_s *v15;
  os_unfair_lock_s *v16;
  __int128 v17;
  os_unfair_lock_s *v18;
  int v19;
  uint64_t v20;
  int *v21;
  __int128 v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  int v29;
  re::AssetHandle *v30;
  re::AssetHandle *v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  re::AssetHandle *v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  int *v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int *v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  int v57;
  int v58;
  unsigned int v59;
  unsigned int v60;
  uint64_t os_unfair_lock_opaque;
  uint64_t v62;
  int *v63;
  int v64;
  uint64_t v65;
  char v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int *v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  int v77;
  int v78;
  uint32_t v79;
  uint32_t v80;
  unsigned int v81;
  uint64_t v82;
  int *v83;
  int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  _anonymous_namespace_ *v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int v96;
  unsigned int v97;
  uint64_t v98;
  re::internal::AssetIdLoadDescriptorTable *v99;
  uint64_t v100;
  os_unfair_lock_s *v101;
  _QWORD *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  re::AssetHandle *v112;
  uint64_t v113;
  NSObject *v115;
  uint64_t *v116;
  re::internal::AssetIdLoadDescriptorTable *v117;
  os_unfair_lock_s *lock;
  uint64_t v119;
  uint64_t v120[2];
  uint64_t v121;
  unsigned int v122;
  unsigned int v123;
  __int128 v124;
  __int128 v125;
  unsigned int v126;
  uint64_t v127;
  uint64_t v128;
  __int128 v129;
  int v130;
  re::AssetHandle *v131;
  __int128 v132;
  _BYTE v133[32];
  __int128 v134;
  _BYTE v135[36];
  _BYTE v136[44];
  uint64_t v137;
  uint8_t buf[16];
  _BYTE v139[28];
  uint64_t v140;

  v140 = *MEMORY[0x24BDAC8D0];
  v3 = *((_QWORD *)a2 + 1);
  if (v3)
  {
    if (!*(_BYTE *)(v3 + 257))
    {
      v6 = *(_QWORD *)(v3 + 112);
      if ((unint64_t)(v6 + 1) >= 2)
        v7 = v6;
      else
        v7 = 0;
      v8 = this + 16;
      os_unfair_lock_lock(this + 16);
      *(_QWORD *)&v132 = v7;
      v117 = (re::internal::AssetIdLoadDescriptorTable *)&this[30];
      v9 = re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)&this[30], (uint64_t *)&v132);
      lock = v8;
      os_unfair_lock_unlock(v8);
      if (v9)
      {
        v10 = *(_QWORD *)(v9 + 16);
        if (v10)
        {
          v11 = *(uint64_t **)(v9 + 32);
          v12 = 144 * v10;
          while (1)
          {
            re::DynamicString::DynamicString((re::DynamicString *)&v132, (const re::DynamicString *)v11);
            re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v133[16], v11 + 4);
            re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v135[8], v11 + 9);
            re::DynamicString::DynamicString((re::DynamicString *)&v136[8], (const re::DynamicString *)(v11 + 14));
            isEngineAssetDescriptor = (re *)re::FrameworkAssetProvider::isEngineAssetDescriptor((re::FrameworkAssetProvider *)&v132, v13);
            if ((_DWORD)isEngineAssetDescriptor)
              break;
            if (*(_QWORD *)&v136[8])
            {
              if ((v136[16] & 1) != 0)
                (*(void (**)(void))(**(_QWORD **)&v136[8] + 40))();
              memset(&v136[8], 0, 32);
            }
            if (*(_QWORD *)&v135[8])
            {
              if (*(_QWORD *)v136)
                (*(void (**)(void))(**(_QWORD **)&v135[8] + 40))();
              *(_QWORD *)v136 = 0;
              memset(&v135[8], 0, 24);
              ++*(_DWORD *)&v135[32];
            }
            if (*(_QWORD *)&v133[16])
            {
              if (*(_QWORD *)v135)
                (*(void (**)(void))(**(_QWORD **)&v133[16] + 40))();
              *(_QWORD *)v135 = 0;
              *(_QWORD *)&v133[24] = 0;
              *(_QWORD *)&v134 = 0;
              *(_QWORD *)&v133[16] = 0;
              ++DWORD2(v134);
            }
            if ((_QWORD)v132 && (BYTE8(v132) & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v132 + 40))();
            v11 += 18;
            v12 -= 144;
            if (!v12)
              goto LABEL_26;
          }
          v115 = *re::assetsLogObjects(isEngineAssetDescriptor);
          if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_224FE9000, v115, OS_LOG_TYPE_DEFAULT, "Engine assets cannot be mutated.", buf, 2u);
          }
          if (*(_QWORD *)&v136[8])
          {
            if ((v136[16] & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)&v136[8] + 40))();
            memset(&v136[8], 0, 32);
          }
          if (*(_QWORD *)&v135[8])
          {
            if (*(_QWORD *)v136)
              (*(void (**)(void))(**(_QWORD **)&v135[8] + 40))();
            *(_QWORD *)v136 = 0;
            memset(&v135[8], 0, 24);
            ++*(_DWORD *)&v135[32];
          }
          if (*(_QWORD *)&v133[16])
          {
            if (*(_QWORD *)v135)
              (*(void (**)(void))(**(_QWORD **)&v133[16] + 40))();
            *(_QWORD *)v135 = 0;
            *(_QWORD *)&v133[24] = 0;
            *(_QWORD *)&v134 = 0;
            *(_QWORD *)&v133[16] = 0;
            ++DWORD2(v134);
          }
          if ((_QWORD)v132 && (BYTE8(v132) & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v132 + 40))();
          return 0;
        }
      }
LABEL_26:
      *(_QWORD *)buf = v7;
      *(_QWORD *)&v132 = buf;
      *((_QWORD *)&v132 + 1) = 1;
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)v120, (uint64_t)&v132);
      v15 = v8;
      if (a3)
      {
        v116 = (uint64_t *)&this[78];
        v16 = this + 66;
        v17 = 0uLL;
        while (1)
        {
          while (1)
          {
            *(_DWORD *)&v139[16] = 0;
            *(_OWORD *)buf = v17;
            *(_OWORD *)v139 = v17;
            *(_QWORD *)&v139[20] = 0x7FFFFFFFLL;
            os_unfair_lock_lock(v15);
            v18 = v15;
            if (this[85]._os_unfair_lock_opaque)
            {
              *(_DWORD *)&v133[24] = 0;
              v132 = 0u;
              *(_OWORD *)buf = 0u;
              *(_QWORD *)v133 = 0;
              *(_QWORD *)v139 = 0;
              *(_OWORD *)&v133[8] = xmmword_2260F5A80;
              *(_OWORD *)&v139[8] = xmmword_2260F5A80;
              re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=((uint64_t)buf, v116);
              re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=((uint64_t)v116, (uint64_t *)&v132);
              re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v132);
              os_unfair_lock_unlock(v15);
              v131 = 0;
              v128 = 0;
              v129 = 0u;
              v130 = 0;
              re::DynamicArray<re::AssetHandle>::setCapacity(&v128, *(unsigned int *)&v139[12]);
              v19 = *(_DWORD *)&v139[16];
              if (*(_DWORD *)&v139[16])
              {
                v20 = 0;
                v21 = (int *)(*(_QWORD *)v139 + 8);
                v22 = 0uLL;
                while (1)
                {
                  v23 = *v21;
                  v21 += 6;
                  if (v23 < 0)
                    break;
                  if (*(unsigned int *)&v139[16] == ++v20)
                  {
                    LODWORD(v20) = *(_DWORD *)&v139[16];
                    break;
                  }
                }
              }
              else
              {
                LODWORD(v20) = 0;
                v22 = 0uLL;
              }
              if (*(_DWORD *)&v139[16] != (_DWORD)v20)
              {
                v24 = v20;
                v25 = *(_QWORD *)v139;
                do
                {
                  v26 = *(_QWORD *)(v25 + 24 * v24 + 16);
                  os_unfair_lock_lock(v18);
                  re::AssetManager::lookupExistingAsset_assetTablesLocked((re::internal::AssetTypeRegistry **)this, v26, &v132);
                  os_unfair_lock_unlock(v18);
                  if ((_BYTE)v132)
                  {
                    if (!*(_QWORD *)v133)
                      goto LABEL_43;
                    v27 = atomic_load((unsigned int *)(*(_QWORD *)v133 + 704));
                    if (v27 == 2)
                      re::DynamicArray<re::AssetHandle>::add((_anonymous_namespace_ *)&v128, (re::AssetHandle *)((char *)&v132 + 8));
                    if ((_BYTE)v132)
LABEL_43:
                      re::AssetHandle::~AssetHandle((re::AssetHandle *)((char *)&v132 + 8));
                  }
                  v25 = *(_QWORD *)v139;
                  if (*(_DWORD *)&v139[16] <= (v20 + 1))
                    v28 = v20 + 1;
                  else
                    v28 = *(_DWORD *)&v139[16];
                  v22 = 0uLL;
                  while (1)
                  {
                    v24 = (v20 + 1);
                    if (v28 - 1 == (_DWORD)v20)
                      break;
                    LODWORD(v20) = v20 + 1;
                    v29 = v24;
                    if ((*(_DWORD *)(*(_QWORD *)v139 + 24 * v24 + 8) & 0x80000000) != 0)
                      goto LABEL_52;
                  }
                  v29 = v28;
LABEL_52:
                  LODWORD(v20) = v29;
                }
                while (v19 != v29);
              }
              v126 = 0;
              v124 = v22;
              v125 = v22;
              v127 = 0x7FFFFFFFLL;
              v30 = v131;
              *(_QWORD *)&v132 = this;
              *((_QWORD *)&v132 + 1) = &v124;
              memset(v133, 0, 28);
              v134 = v22;
              *(_OWORD *)v135 = v22;
              *(_OWORD *)&v135[12] = v22;
              *(_QWORD *)&v135[28] = 0x7FFFFFFFLL;
              *(_OWORD *)v136 = v22;
              *(_OWORD *)&v136[16] = v22;
              *(_DWORD *)&v136[32] = 0;
              *(_QWORD *)&v136[36] = 0x7FFFFFFFLL;
              v137 = 0;
              if (*((_QWORD *)&v129 + 1))
              {
                v31 = (re::AssetHandle *)((char *)v131 + 24 * *((_QWORD *)&v129 + 1));
                do
                {
                  v32 = *((_QWORD *)v30 + 1);
                  if (v32)
                  {
                    if (!*(_BYTE *)(v32 + 257))
                    {
                      v33 = re::AssetHandle::assetInfo(v30);
                      if (!re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::contains((uint64_t)v136, (unint64_t)v33))
                      {
                        v34 = *(_QWORD *)&v133[16];
                        *(_QWORD *)&v133[16] = 0;
                        if (v34)
                        {
                          v35 = (re::AssetHandle *)v134;
                          v36 = 24 * v34;
                          do
                          {
                            re::AssetHandle::~AssetHandle(v35);
                            v35 = (re::AssetHandle *)(v37 + 24);
                            v36 -= 24;
                          }
                          while (v36);
                        }
                        ++*(_DWORD *)&v133[24];
                        re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear((uint64_t)&v134 + 8);
                      }
                    }
                  }
                  v30 = (re::AssetHandle *)((char *)v30 + 24);
                }
                while (v30 != v31);
              }
              re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v136);
              re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v134 + 1);
              re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v133);
              if (HIDWORD(v125))
              {
                os_unfair_lock_lock(v18);
                v38 = v126;
                if (v126)
                {
                  v39 = 0;
                  v40 = (int *)(v125 + 8);
                  while (1)
                  {
                    v41 = *v40;
                    v40 += 18;
                    if (v41 < 0)
                      break;
                    if (v126 == ++v39)
                    {
                      LODWORD(v39) = v126;
                      break;
                    }
                  }
                }
                else
                {
                  LODWORD(v39) = 0;
                }
                if (v126 != (_DWORD)v39)
                {
                  v42 = v39;
                  v43 = v125;
                  do
                  {
                    v44 = v43 + 72 * v42;
                    v46 = *(_QWORD *)(v44 + 16);
                    v45 = v44 + 16;
                    v47 = v45 + 8;
                    v48 = re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)v16, v46);
                    if (v48)
                    {
                      v49 = v48;
                      v50 = *(unsigned int *)(v45 + 40);
                      if ((_DWORD)v50)
                      {
                        v51 = 0;
                        v52 = (int *)(*(_QWORD *)(v47 + 16) + 8);
                        while (1)
                        {
                          v53 = *v52;
                          v52 += 6;
                          if (v53 < 0)
                            break;
                          if (v50 == ++v51)
                          {
                            LODWORD(v51) = *(_DWORD *)(v47 + 32);
                            break;
                          }
                        }
                      }
                      else
                      {
                        LODWORD(v51) = 0;
                      }
                      if ((_DWORD)v50 != (_DWORD)v51)
                      {
                        v54 = v51;
                        v55 = *(_QWORD *)(v47 + 16);
                        do
                        {
                          re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(v49, (uint64_t *)(v55 + 24 * v54 + 16));
                          v56 = *(_DWORD *)(v47 + 32);
                          v55 = *(_QWORD *)(v47 + 16);
                          if (v56 <= (int)v51 + 1)
                            v57 = v51 + 1;
                          else
                            v57 = *(_DWORD *)(v47 + 32);
                          v58 = v51;
                          while (1)
                          {
                            v54 = (v58 + 1);
                            if (v57 - 1 == v58)
                              break;
                            ++v58;
                            LODWORD(v51) = v54;
                            if ((*(_DWORD *)(v55 + 24 * v54 + 8) & 0x80000000) != 0)
                              goto LABEL_90;
                          }
                          LODWORD(v51) = v57;
LABEL_90:
                          ;
                        }
                        while (v56 != (_DWORD)v51);
                      }
                    }
                    else
                    {
                      re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>&>((uint64_t)v16, (uint64_t *)v45, v45 + 8);
                    }
                    v43 = v125;
                    if (v126 <= (int)v39 + 1)
                      v59 = v39 + 1;
                    else
                      v59 = v126;
                    while (1)
                    {
                      v42 = (v39 + 1);
                      if (v59 - 1 == (_DWORD)v39)
                        break;
                      LODWORD(v39) = v39 + 1;
                      v60 = v42;
                      if ((*(_DWORD *)(v125 + 72 * v42 + 8) & 0x80000000) != 0)
                        goto LABEL_98;
                    }
                    v60 = v59;
LABEL_98:
                    LODWORD(v39) = v60;
                  }
                  while (v38 != v60);
                }
                v18 = lock;
                os_unfair_lock_unlock(lock);
              }
              re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)&v124);
              re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v128);
            }
            else
            {
              os_unfair_lock_unlock(v15);
            }
            re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)buf);
            os_unfair_lock_lock(v18);
            if (!this[85]._os_unfair_lock_opaque)
              break;
            os_unfair_lock_unlock(v18);
            v15 = v18;
            v17 = 0uLL;
          }
          v132 = 0u;
          memset(v133, 0, 20);
          *(_QWORD *)&v133[20] = 0x7FFFFFFFLL;
          os_unfair_lock_opaque = this[74]._os_unfair_lock_opaque;
          if ((_DWORD)os_unfair_lock_opaque)
          {
            v62 = 0;
            v63 = (int *)(*(_QWORD *)&this[70]._os_unfair_lock_opaque + 8);
            while (1)
            {
              v64 = *v63;
              v63 += 18;
              if (v64 < 0)
                break;
              if (os_unfair_lock_opaque == ++v62)
              {
                LODWORD(v62) = this[74];
                break;
              }
            }
          }
          else
          {
            LODWORD(v62) = 0;
          }
          if ((_DWORD)os_unfair_lock_opaque == (_DWORD)v62)
            break;
          v65 = v62;
          v66 = 1;
          do
          {
            v67 = *(_QWORD *)&this[70]._os_unfair_lock_opaque + 72 * v65;
            v68 = (uint64_t *)(v67 + 16);
            if (!re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)v120, (uint64_t *)(v67 + 16)))
            {
              v69 = v67 + 24;
              re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear((uint64_t)&v132);
              v70 = *(unsigned int *)(v67 + 56);
              if ((_DWORD)v70)
              {
                v71 = 0;
                v72 = (int *)(*(_QWORD *)(v69 + 16) + 8);
                while (1)
                {
                  v73 = *v72;
                  v72 += 6;
                  if (v73 < 0)
                    break;
                  if (v70 == ++v71)
                  {
                    LODWORD(v71) = *(_DWORD *)(v69 + 32);
                    break;
                  }
                }
              }
              else
              {
                LODWORD(v71) = 0;
              }
              if ((_DWORD)v70 != (_DWORD)v71)
              {
                v74 = v71;
                v75 = *(_QWORD *)(v69 + 16);
                do
                {
                  if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)v120, (uint64_t *)(v75 + 24 * v74 + 16)))
                  {
                    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)&v132, (uint64_t *)(*(_QWORD *)(v69 + 16) + 24 * v74 + 16));
                  }
                  v76 = *(_DWORD *)(v69 + 32);
                  v75 = *(_QWORD *)(v69 + 16);
                  if (v76 <= (int)v71 + 1)
                    v77 = v71 + 1;
                  else
                    v77 = *(_DWORD *)(v69 + 32);
                  while (1)
                  {
                    v74 = (v71 + 1);
                    if (v77 - 1 == (_DWORD)v71)
                      break;
                    LODWORD(v71) = v71 + 1;
                    v78 = v74;
                    if ((*(_DWORD *)(v75 + 24 * v74 + 8) & 0x80000000) != 0)
                      goto LABEL_129;
                  }
                  v78 = v77;
LABEL_129:
                  LODWORD(v71) = v78;
                }
                while (v76 != v78);
              }
              v16 = this + 66;
              if (*(_DWORD *)&v133[12])
              {
                re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v120, v68);
                v66 = 0;
              }
            }
            if (this[74]._os_unfair_lock_opaque <= (v62 + 1))
              v79 = v62 + 1;
            else
              v79 = this[74]._os_unfair_lock_opaque;
            while (1)
            {
              v65 = (v62 + 1);
              if (v79 - 1 == (_DWORD)v62)
                break;
              LODWORD(v62) = v62 + 1;
              v80 = v65;
              if ((*(_DWORD *)(*(_QWORD *)&this[70]._os_unfair_lock_opaque + 72 * v65 + 8) & 0x80000000) != 0)
                goto LABEL_139;
            }
            v80 = v79;
LABEL_139:
            LODWORD(v62) = v80;
          }
          while ((_DWORD)os_unfair_lock_opaque != v80);
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v132);
          v15 = lock;
          os_unfair_lock_unlock(lock);
          v17 = 0uLL;
          if ((v66 & 1) != 0)
            goto LABEL_143;
        }
        re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v132);
        os_unfair_lock_unlock(v18);
      }
LABEL_143:
      *(_QWORD *)&v133[16] = 0;
      *(_QWORD *)v133 = 0;
      v132 = 0uLL;
      *(_DWORD *)&v133[8] = 0;
      re::DynamicArray<re::Pair<unsigned long long,re::AssetHandle,true>>::setCapacity(&v132, v122);
      v81 = v123;
      if (v123)
      {
        v82 = 0;
        v83 = (int *)(v121 + 8);
        while (1)
        {
          v84 = *v83;
          v83 += 6;
          if (v84 < 0)
            break;
          if (v123 == ++v82)
          {
            LODWORD(v82) = v123;
            break;
          }
        }
      }
      else
      {
        LODWORD(v82) = 0;
      }
      if (v123 != (_DWORD)v82)
      {
        v85 = v82;
        v86 = v121;
        do
        {
          v87 = *(_QWORD *)(v86 + 24 * v85 + 16);
          os_unfair_lock_lock(lock);
          re::AssetManager::lookupExistingAsset_assetTablesLocked((re::internal::AssetTypeRegistry **)this, v87, buf);
          os_unfair_lock_unlock(lock);
          if (buf[0])
          {
            *(_QWORD *)&v124 = v87;
            v88 = re::AssetHandle::AssetHandle((re::AssetHandle *)((char *)&v124 + 8), (const re::AssetHandle *)&buf[8]);
            v89 = *(_QWORD *)v133;
            if (*(_QWORD *)v133 >= *((_QWORD *)&v132 + 1))
            {
              v90 = *(_QWORD *)v133 + 1;
              if (*((_QWORD *)&v132 + 1) < (unint64_t)(*(_QWORD *)v133 + 1))
              {
                if ((_QWORD)v132)
                {
                  v91 = 2 * *((_QWORD *)&v132 + 1);
                  if (!*((_QWORD *)&v132 + 1))
                    v91 = 8;
                  if (v91 <= v90)
                    v92 = *(_QWORD *)v133 + 1;
                  else
                    v92 = v91;
                  re::DynamicArray<re::Pair<unsigned long long,re::AssetHandle,true>>::setCapacity(&v132, v92);
                }
                else
                {
                  re::DynamicArray<re::Pair<unsigned long long,re::AssetHandle,true>>::setCapacity(&v132, v90);
                  ++*(_DWORD *)&v133[8];
                }
              }
              v89 = *(_QWORD *)v133;
            }
            v93 = (_QWORD *)(*(_QWORD *)&v133[16] + 32 * v89);
            *v93 = v124;
            v93[1] = 0;
            v93[2] = 0;
            v93[3] = 0;
            v93[2] = v125;
            *(_QWORD *)&v125 = 0;
            v94 = v93[1];
            v93[1] = 0;
            v93[1] = *((_QWORD *)&v124 + 1);
            *((_QWORD *)&v124 + 1) = v94;
            v95 = v93[3];
            v93[3] = *((_QWORD *)&v125 + 1);
            *((_QWORD *)&v125 + 1) = v95;
            *(_QWORD *)v133 = v89 + 1;
            ++*(_DWORD *)&v133[8];
            re::AssetHandle::~AssetHandle((re::AssetHandle *)((char *)&v124 + 8));
            if (buf[0])
              re::AssetHandle::~AssetHandle((re::AssetHandle *)&buf[8]);
          }
          v86 = v121;
          if (v123 <= (int)v82 + 1)
            v96 = v82 + 1;
          else
            v96 = v123;
          while (1)
          {
            v85 = (v82 + 1);
            if (v96 - 1 == (_DWORD)v82)
              break;
            LODWORD(v82) = v82 + 1;
            v97 = v85;
            if ((*(_DWORD *)(v121 + 24 * v85 + 8) & 0x80000000) != 0)
              goto LABEL_172;
          }
          v97 = v96;
LABEL_172:
          LODWORD(v82) = v97;
        }
        while (v81 != v97);
      }
      os_unfair_lock_lock(lock);
      v98 = *(_QWORD *)&v133[16];
      v99 = (re::internal::AssetIdLoadDescriptorTable *)&this[30];
      v119 = *(_QWORD *)v133;
      if (*(_QWORD *)v133)
      {
        v100 = *(_QWORD *)&v133[16] + 32 * *(_QWORD *)v133;
        v101 = this + 42;
        v102 = *(_QWORD **)&v133[16];
        do
        {
          *(_QWORD *)buf = *v102;
          re::AssetHandle::AssetHandle((re::AssetHandle *)&buf[8], (const re::AssetHandle *)(v102 + 1));
          v103 = *(_QWORD *)buf;
          *(_QWORD *)&v124 = *(_QWORD *)buf;
          v104 = re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)v99, (uint64_t *)&v124);
          v105 = *(uint64_t **)(v104 + 32);
          v106 = *(_QWORD *)(v104 + 16);
          if (v106)
          {
            v107 = v104;
            v108 = 144 * v106;
            do
            {
              re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::remove((uint64_t)v101, (uint64_t)v105);
              v105 += 18;
              v108 -= 144;
            }
            while (v108);
            v109 = *(_QWORD *)(v107 + 16);
            v105 = *(uint64_t **)(v107 + 32);
          }
          else
          {
            v109 = 0;
          }
          v99 = v117;
          re::internal::AssetIdLoadDescriptorTable::insertIntoMutableTables((uint64_t)v117, v103, v109, v105);
          re::internal::AssetIdLoadDescriptorTable::markDependenciesDirty(v117, v103);
          *(_BYTE *)(*(_QWORD *)v139 + 257) = 1;
          re::AssetHandle::~AssetHandle((re::AssetHandle *)&buf[8]);
          v102 += 4;
        }
        while (v102 != (_QWORD *)v100);
      }
      os_unfair_lock_unlock(lock);
      v110 = v132;
      if ((_QWORD)v132 && v98)
      {
        if (v119)
        {
          v111 = 32 * v119;
          v112 = (re::AssetHandle *)(v98 + 8);
          do
          {
            re::AssetHandle::~AssetHandle(v112);
            v112 = (re::AssetHandle *)(v113 + 32);
            v111 -= 32;
          }
          while (v111);
          v110 = v132;
          v98 = *(_QWORD *)&v133[16];
        }
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v110 + 40))(v110, v98);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v120);
    }
    return 1;
  }
  return 0;
}

_QWORD *re::DynamicArray<re::Pair<unsigned long long,re::AssetHandle,true>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  re::AssetHandle *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::Pair<unsigned long long,re::AssetHandle,true>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 32 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = v8 + 32 * v9;
        v11 = (re::AssetHandle *)(v8 + 8);
        v12 = v7;
        do
        {
          *v12 = *((_QWORD *)v11 - 1);
          v12[1] = 0;
          v12[2] = 0;
          v12[3] = 0;
          v12[2] = *((_QWORD *)v11 + 1);
          *((_QWORD *)v11 + 1) = 0;
          v13 = v12[1];
          v12[1] = 0;
          v12[1] = *(_QWORD *)v11;
          *(_QWORD *)v11 = v13;
          v14 = v12[3];
          v12[3] = *((_QWORD *)v11 + 2);
          *((_QWORD *)v11 + 2) = v14;
          re::AssetHandle::~AssetHandle(v11);
          v16 = v15 + 24;
          v11 = (re::AssetHandle *)(v15 + 32);
          v12 += 4;
        }
        while (v16 != v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::AssetManager::lookupExistingAsset(os_unfair_lock_s *this@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  os_unfair_lock_s *v6;

  v6 = this + 16;
  os_unfair_lock_lock(this + 16);
  re::AssetManager::lookupExistingAsset_assetTablesLocked((re::internal::AssetTypeRegistry **)this, a2, a3);
  os_unfair_lock_unlock(v6);
}

BOOL re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  _BOOL8 result;
  uint64_t v7;

  v2 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v2)
    return 0;
  v3 = *a2;
  v4 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v5 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
                        % v2));
  if ((_DWORD)v5 == 0x7FFFFFFF)
    return 0;
  v7 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v7 + 24 * v5 + 16) == v3)
    return 1;
  do
  {
    LODWORD(v5) = *(_DWORD *)(v7 + 24 * v5 + 8) & 0x7FFFFFFF;
    result = (_DWORD)v5 != 0x7FFFFFFF;
  }
  while ((_DWORD)v5 != 0x7FFFFFFF && *(_QWORD *)(v7 + 24 * v5 + 16) != v3);
  return result;
}

double re::internal::AssetIdLoadDescriptorTable::markDependenciesDirty(re::internal::AssetIdLoadDescriptorTable *this, const re::AssetHandle *a2)
{
  uint64_t v3;
  double result;

  v3 = *((_QWORD *)re::AssetHandle::assetInfo(a2) + 10);
  if ((unint64_t)(v3 + 1) >= 2)
    return re::internal::AssetIdLoadDescriptorTable::markDependenciesDirty(this, v3);
  return result;
}

_QWORD *re::DynamicArray<re::AssetHandle>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  uint64_t *v7;
  re::AssetHandle *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::AssetHandle>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x18uLL))
        {
          v2 = 24 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 24 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 24, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (re::AssetHandle *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 24 * v9;
        v11 = v7;
        do
        {
          *v11 = 0;
          v11[1] = 0;
          v11[2] = 0;
          v11[1] = *((_QWORD *)v8 + 1);
          *((_QWORD *)v8 + 1) = 0;
          v12 = *v11;
          *v11 = 0;
          *v11 = *(_QWORD *)v8;
          *(_QWORD *)v8 = v12;
          v13 = v11[2];
          v11[2] = *((_QWORD *)v8 + 2);
          *((_QWORD *)v8 + 2) = v13;
          re::AssetHandle::~AssetHandle(v8);
          v8 = (re::AssetHandle *)((char *)v8 + 24);
          v11 += 3;
          v10 -= 24;
        }
        while (v10);
        v8 = (re::AssetHandle *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, re::AssetHandle *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v5;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  v3 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v2 ^ (v2 >> 31)) % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v3 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v5 + 72 * v3 + 16) != a2)
  {
    while (1)
    {
      LODWORD(v3) = *(_DWORD *)(v5 + 72 * v3 + 8) & 0x7FFFFFFF;
      if ((_DWORD)v3 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v5 + 72 * v3 + 16) == a2)
        return v5 + 72 * v3 + 24;
    }
    return 0;
  }
  return v5 + 72 * v3 + 24;
}

uint64_t re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>&>(uint64_t result, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;

  v5 = result;
  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (*(_QWORD *)result)
  {
    v9 = v8 % *(unsigned int *)(result + 24);
    v10 = *(unsigned int *)(*(_QWORD *)(result + 8) + 4 * v9);
    if ((_DWORD)v10 != 0x7FFFFFFF)
    {
      v11 = *(_QWORD *)(result + 16);
      if (*(_QWORD *)(v11 + 72 * v10 + 16) == v6)
        return result;
      while (1)
      {
        LODWORD(v10) = *(_DWORD *)(v11 + 72 * v10 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v10 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v11 + 72 * v10 + 16) == v6)
          return result;
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  v12 = *(unsigned int *)(result + 36);
  if ((_DWORD)v12 == 0x7FFFFFFF)
  {
    v12 = *(unsigned int *)(result + 32);
    v13 = v12;
    if ((_DWORD)v12 == *(_DWORD *)(result + 24))
    {
      re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(result, 2 * *(_DWORD *)(result + 28));
      LODWORD(v9) = v8 % *(unsigned int *)(v5 + 24);
      v13 = *(_DWORD *)(v5 + 32);
      v6 = *a2;
    }
    *(_DWORD *)(v5 + 32) = v13 + 1;
    v14 = *(_QWORD *)(v5 + 16);
    v15 = *(_DWORD *)(v14 + 72 * v12 + 8);
  }
  else
  {
    v14 = *(_QWORD *)(result + 16);
    v15 = *(_DWORD *)(v14 + 72 * v12 + 8);
    *(_DWORD *)(result + 36) = v15 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v14 + 72 * v12 + 8) = v15 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(v5 + 16) + 72 * v12 + 8) = *(_DWORD *)(*(_QWORD *)(v5 + 16) + 72 * v12 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(v5 + 8) + 4 * v9);
  *(_QWORD *)(*(_QWORD *)(v5 + 16) + 72 * v12) = v8;
  *(_QWORD *)(*(_QWORD *)(v5 + 16) + 72 * v12 + 16) = v6;
  result = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase(*(_QWORD *)(v5 + 16) + 72 * v12 + 24, a3);
  *(_DWORD *)(*(_QWORD *)(v5 + 8) + 4 * v9) = v12;
  ++*(_DWORD *)(v5 + 28);
  ++*(_DWORD *)(v5 + 40);
  return result;
}

uint64_t re::AssetManager::lookupExistingAsset_assetTablesLocked@<X0>(re::internal::AssetTypeRegistry **this@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t result;
  uint64_t v7;
  char *v8;
  _anonymous_namespace_ *v9;
  _anonymous_namespace_ *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;

  v15 = a2;
  result = re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)(this + 15), &v15);
  if (result && *(_QWORD *)(result + 16))
  {
    v7 = *(_QWORD *)(result + 32);
    if ((*(_BYTE *)(v7 + 120) & 1) != 0)
      v8 = *(char **)(v7 + 128);
    else
      v8 = (char *)(v7 + 121);
    v9 = (_anonymous_namespace_ *)re::internal::AssetTypeRegistry::assetTypeWithName(this[138], v8);
    LODWORD(v15) = 0;
    v18 = 0;
    v19 = 0;
    v17 = 0;
    v10 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v16, 0);
    *((_QWORD *)&v20 + 1) = 0;
    v21 = 0uLL;
    re::DynamicString::setCapacity(&v20, 0);
    v22 = 0;
    re::AssetPath::initAssetIdAssetPath((uint64_t)&v15, a2, (uint64_t)v9);
    v13 = 0;
    v14 = 0;
    v11 = v16;
    v12 = 0;
    re::DynamicString::setCapacity(&v11, 0);
    re::AssetPath::fullAssetPath((re::DynamicString *)&v15, (re::DynamicString *)&v11);
    re::AssetManager::lookupExistingAsset_assetTablesLocked((re::AssetManager *)this, (const re::DynamicString *)&v11, (uint64_t)a3);
    if (v11 && (v12 & 1) != 0)
      (*(void (**)(void))(*v11 + 40))();
    if ((_QWORD)v20)
    {
      if ((BYTE8(v20) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v20 + 40))();
      v20 = 0u;
      v21 = 0u;
    }
    result = (uint64_t)v16;
    if (v16)
    {
      if ((v17 & 1) != 0)
        return (*(uint64_t (**)(void))(*v16 + 40))();
    }
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

void re::AssetManager::lookupExistingAsset_assetTablesLocked(re::AssetManager *this@<X0>, const re::DynamicString *a2@<X1>, uint64_t a3@<X8>)
{
  re::internal::AssetEntry **v4;
  char v5;
  __int128 v6;
  uint64_t v7;

  v4 = (re::internal::AssetEntry **)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)this + 72, (uint64_t)a2);
  if (v4)
  {
    re::AssetHandle::AssetHandle((uint64_t *)&v6, *v4);
    *(_OWORD *)(a3 + 8) = v6;
    v6 = 0uLL;
    *(_QWORD *)(a3 + 24) = v7;
    v7 = 0;
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v6);
    v5 = 1;
  }
  else
  {
    v5 = 0;
  }
  *(_BYTE *)a3 = v5;
}

void re::AssetManager::lookupExistingAsset(re::AssetManager *this, os_unfair_lock_s *a2, re::DynamicString *a3)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v6 = a2 + 16;
  os_unfair_lock_lock(a2 + 16);
  v7 = *((_QWORD *)a3 + 1);
  v10 = 0;
  v11 = 0;
  v8 = v7;
  v9 = 0;
  re::DynamicString::setCapacity(&v8, 0);
  re::AssetPath::fullAssetPath(a3, (re::DynamicString *)&v8);
  re::AssetManager::lookupExistingAsset_assetTablesLocked((re::AssetManager *)a2, (const re::DynamicString *)&v8, (uint64_t)this);
  if (v8 && (v9 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v8 + 40))();
  os_unfair_lock_unlock(v6);
}

void re::AssetManager::lookupExistingAsset(os_unfair_lock_s *this@<X0>, const re::DynamicString *a2@<X1>, uint64_t a3@<X8>)
{
  os_unfair_lock_s *v6;

  v6 = this + 16;
  os_unfair_lock_lock(this + 16);
  re::AssetManager::lookupExistingAsset_assetTablesLocked((re::AssetManager *)this, a2, a3);
  os_unfair_lock_unlock(v6);
}

void re::AssetManager::lookupExistingImmutableAssetId(os_unfair_lock_s *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;

  if (*(_QWORD *)(a2 + 16))
  {
    v6 = a1 + 16;
    os_unfair_lock_lock(a1 + 16);
    v7 = *(_QWORD *)(a2 + 16);
    if (v7)
    {
      v8 = *(_QWORD *)(a2 + 32);
      v9 = (uint64_t)&a1[42];
      v10 = 144 * v7;
      while (1)
      {
        v11 = (_QWORD *)re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::tryGet(v9, v8);
        if (v11)
          break;
        v8 += 144;
        v10 -= 144;
        if (!v10)
          goto LABEL_6;
      }
      *(_BYTE *)a3 = 1;
      *(_QWORD *)(a3 + 8) = *v11;
    }
    else
    {
LABEL_6:
      *(_BYTE *)a3 = 0;
    }
    os_unfair_lock_unlock(v6);
  }
  else
  {
    *(_BYTE *)a3 = 0;
  }
}

void re::AssetManager::loadDescriptorsFromAssetId(os_unfair_lock_s *this@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  os_unfair_lock_s *v6;
  uint64_t *v7;
  uint64_t v8;

  v6 = this + 16;
  os_unfair_lock_lock(this + 16);
  v8 = a2;
  v7 = (uint64_t *)re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)&this[30], &v8);
  os_unfair_lock_unlock(v6);
  if (v7)
  {
    *a3 = 1;
    re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray((uint64_t)(a3 + 8), v7);
  }
  else
  {
    *a3 = 0;
  }
}

void re::AssetManager::lookupLoadDescriptors(os_unfair_lock_s *this@<X0>, const re::AssetHandle *a2@<X1>, _BYTE *a3@<X8>)
{
  uint64_t v5;
  os_unfair_lock_s *v6;
  uint64_t *v7;
  uint64_t v8;

  v5 = *((_QWORD *)re::AssetHandle::assetInfo(a2) + 10);
  if ((unint64_t)(v5 + 1) > 1
    && (v6 = this + 16,
        os_unfair_lock_lock(this + 16),
        v8 = v5,
        v7 = (uint64_t *)re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)&this[30], &v8), os_unfair_lock_unlock(v6), v7))
  {
    *a3 = 1;
    re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray((uint64_t)(a3 + 8), v7);
  }
  else
  {
    *a3 = 0;
  }
}

void re::internal::AssetIdLoadDescriptorTable::remove(re::internal::AssetIdLoadDescriptorTable *this, unint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  char v24;
  unint64_t v25;
  char v26;
  char v27;
  char v28;
  char v29;

  v25 = a2;
  if (re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey((uint64_t)this, (uint64_t *)&v25))
  {
    v3 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (v25 ^ (v25 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v25 ^ (v25 >> 30))) >> 27));
    v4 = (v3 ^ (v3 >> 31)) % *((unsigned int *)this + 6);
    v5 = *((_QWORD *)this + 2);
    for (i = *(unsigned int *)(*((_QWORD *)this + 1) + 4 * v4);
          *(_QWORD *)(v5 + (i << 6) + 16) != v25;
    v7 = v5 + (i << 6);
    v8 = *(_QWORD *)(v7 + 40);
    if (v8)
    {
      v24 = 0;
      v9 = *(_QWORD *)(v7 + 56);
      v10 = v9 + 144 * v8;
      do
      {
        v11 = re::Hash<re::AssetLoadDescriptor>::operator()((uint64_t)&v26, v9);
        if (*((_QWORD *)this + 6))
        {
          v12 = *(unsigned int *)(*((_QWORD *)this + 7) + 4 * (v11 % *((unsigned int *)this + 18)));
          if ((_DWORD)v12 != 0x7FFFFFFF)
          {
            v13 = *((_QWORD *)this + 8);
            while (1)
            {
              v14 = re::EqualTo<re::AssetLoadDescriptor>::operator()((uint64_t)&v27, v13 + 168 * v12 + 16, v9);
              v13 = *((_QWORD *)this + 8);
              if (v14)
                break;
              v12 = *(_DWORD *)(v13 + 168 * v12 + 8) & 0x7FFFFFFF;
              if (v12 == 0x7FFFFFFF)
                goto LABEL_15;
            }
            if (*(_QWORD *)(v13 + 168 * v12 + 160) == v25)
            {
              re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::remove((uint64_t)this + 48, v9);
              v24 = 1;
            }
          }
        }
LABEL_15:
        v15 = re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::tryGet((uint64_t)this + 96, v9);
        if (v15)
        {
          v16 = v15;
          if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains(v15, (uint64_t *)&v25))
          {
            re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(v16, (uint64_t *)&v25);
            if (!*(_DWORD *)(v16 + 28))
            {
              v17 = re::Hash<re::AssetLoadDescriptor>::operator()((uint64_t)&v28, v9);
              if (*((_QWORD *)this + 12))
              {
                v18 = v17 % *((unsigned int *)this + 30);
                v19 = *(unsigned int *)(*((_QWORD *)this + 13) + 4 * v18);
                if ((_DWORD)v19 != 0x7FFFFFFF)
                {
                  if (re::EqualTo<re::AssetLoadDescriptor>::operator()((uint64_t)&v29, *((_QWORD *)this + 14) + 208 * v19 + 16, v9))
                  {
                    *(_DWORD *)(*((_QWORD *)this + 13) + 4 * v18) = *(_DWORD *)(*((_QWORD *)this + 14)
                                                                              + 208 * v19
                                                                              + 8) & 0x7FFFFFFF;
LABEL_27:
                    re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::EntryWithHash::free(*((_QWORD *)this + 14) + 208 * v19);
                    v22 = *((_QWORD *)this + 14) + 208 * v19;
                    v23 = *((_DWORD *)this + 34);
                    *(_DWORD *)(v22 + 8) = *(_DWORD *)(v22 + 8) & 0x80000000 | *((_DWORD *)this + 33);
                    --*((_DWORD *)this + 31);
                    *((_DWORD *)this + 33) = v19;
                    *((_DWORD *)this + 34) = v23 + 1;
                  }
                  else
                  {
                    while (1)
                    {
                      v20 = v19;
                      v21 = *((_QWORD *)this + 14);
                      v19 = *(_DWORD *)(v21 + 208 * v19 + 8) & 0x7FFFFFFF;
                      if (v19 == 0x7FFFFFFF)
                        break;
                      if (re::EqualTo<re::AssetLoadDescriptor>::operator()((uint64_t)&v29, v21 + 208 * v19 + 16, v9))
                      {
                        *(_DWORD *)(*((_QWORD *)this + 14) + 208 * v20 + 8) = *(_DWORD *)(*((_QWORD *)this + 14)
                                                                                        + 208 * v20
                                                                                        + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)this + 14) + 208 * v19 + 8) & 0x7FFFFFFF;
                        goto LABEL_27;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        v9 += 144;
      }
      while (v9 != v10);
      re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this, v25);
      if ((v24 & 1) != 0)
        re::internal::AssetIdLoadDescriptorTable::markDependenciesDirty(this, v25);
    }
    else
    {
      re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)this, v25);
    }
  }
}

unint64_t re::internal::AssetIdLoadDescriptorTable::addNewMutable(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t result;
  uint64_t v6;

  v6 = a2;
  result = re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(a1, &v6);
  if ((result & 1) == 0)
  {
    re::internal::AssetIdLoadDescriptorTable::insertIntoMutableTables(a1, v6, *(_QWORD *)(a3 + 16), *(uint64_t **)(a3 + 32));
    return re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add(a1, &v6, (uint64_t *)a3);
  }
  return result;
}

void re::AssetManager::assetTypeFromString(os_unfair_lock_s *this@<X0>, char *a2@<X1>, uint64_t a3@<X8>)
{
  os_unfair_lock_s *v6;
  _anonymous_namespace_ *v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  _QWORD v17[8];

  v6 = this + 16;
  os_unfair_lock_lock(this + 16);
  v8 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&this[18], (uint64_t)&v15);
  if (v15 && (v16 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  os_unfair_lock_unlock(v6);
  if (v8)
  {
    v9 = *(_QWORD *)(*(_QWORD *)v8 + 264);
    *(_BYTE *)a3 = 1;
    *(_QWORD *)(a3 + 8) = v9;
  }
  else
  {
    re::AssetManager::parseAssetPath((re::AssetManager *)this, a2, 0, 0, (uint64_t)&v15);
    if ((_BYTE)v15)
    {
      *(_QWORD *)(a3 + 8) = v17[7];
      v10 = 1;
    }
    else
    {
      v11 = v16;
      re::DynamicString::DynamicString((re::DynamicString *)&v12, (const re::DynamicString *)v17);
      v10 = 0;
      *(_OWORD *)(a3 + 8) = v11;
      *(_QWORD *)(a3 + 24) = v12;
      *(_QWORD *)(a3 + 48) = v14;
      *(_OWORD *)(a3 + 32) = v13;
    }
    *(_BYTE *)a3 = v10;
    re::Result<re::AssetPath,re::DetailedError>::~Result((uint64_t)&v15);
  }
}

double re::AssetManager::assignInitialMetadata(uint64_t a1, os_unfair_lock_s *a2, uint64_t a3)
{
  uint64_t v4;
  os_unfair_lock_s *v5;
  const char *v6;
  uint64_t ProviderForScheme;
  double result;
  unsigned int v9;
  uint64_t v10;
  int *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  const re::StringID *v17;
  unsigned int v18;
  unsigned int v19;
  __int128 v20;
  __int128 v21;
  unsigned int v22;
  uint64_t v23;

  if (a3 && *(_QWORD *)(a3 + 16))
  {
    v4 = *(_QWORD *)(a3 + 32);
    v5 = *(os_unfair_lock_s **)(a1 + 1192);
    v6 = (*(_BYTE *)(v4 + 8) & 1) != 0 ? *(const char **)(v4 + 16) : (const char *)(v4 + 9);
    ProviderForScheme = re::AssetProviderRegistry::tryGetProviderForScheme(v5, v6);
    if (ProviderForScheme)
    {
      v22 = 0;
      v20 = 0u;
      v21 = 0u;
      v23 = 0x7FFFFFFFLL;
      (*(void (**)(uint64_t, uint64_t, __int128 *))(*(_QWORD *)ProviderForScheme + 80))(ProviderForScheme, v4, &v20);
      v9 = v22;
      if (v22)
      {
        v10 = 0;
        v11 = (int *)v21;
        while (1)
        {
          v12 = *v11;
          v11 += 14;
          if (v12 < 0)
            break;
          if (v22 == ++v10)
          {
            LODWORD(v10) = v22;
            break;
          }
        }
      }
      else
      {
        LODWORD(v10) = 0;
      }
      if (v22 != (_DWORD)v10)
      {
        v13 = v10;
        v14 = v21;
        do
        {
          v15 = v14 + 56 * v13;
          if ((*(_BYTE *)(v15 + 32) & 1) != 0)
            v16 = *(const char **)(v14 + 56 * v13 + 40);
          else
            v16 = (const char *)(v14 + 56 * v13 + 33);
          v17 = (const re::StringID *)(v15 + 8);
          os_unfair_lock_lock(a2 + 96);
          re::internal::AssetEntry::setOrClearMetadata_stateLocked((re::internal::AssetEntry *)a2, v17, v16);
          os_unfair_lock_unlock(a2 + 96);
          v14 = v21;
          if (v22 <= (int)v10 + 1)
            v18 = v10 + 1;
          else
            v18 = v22;
          while (1)
          {
            v13 = (v10 + 1);
            if (v18 - 1 == (_DWORD)v10)
              break;
            LODWORD(v10) = v10 + 1;
            v19 = v13;
            if ((*(_DWORD *)(v21 + 56 * v13) & 0x80000000) != 0)
              goto LABEL_25;
          }
          v19 = v18;
LABEL_25:
          LODWORD(v10) = v19;
        }
        while (v9 != v19);
      }
      return re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v20);
    }
  }
  return result;
}

double re::internal::AssetIdLoadDescriptorTable::markDependenciesDirty(re::internal::AssetIdLoadDescriptorTable *this, uint64_t a2)
{
  int v3;
  uint64_t v4;
  int *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int *v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  int v31;
  __int128 v33;
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  int v41;
  _OWORD v42[2];
  int v43;
  uint64_t v44;
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)&v42[0] = a2;
  *(_QWORD *)&v36 = v42;
  *((_QWORD *)&v36 + 1) = 1;
  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)&v33, (uint64_t)&v36);
  v43 = 0;
  memset(v42, 0, sizeof(v42));
  v44 = 0x7FFFFFFFLL;
  while (DWORD1(v35))
  {
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear((uint64_t)v42);
    v3 = DWORD2(v35);
    if (DWORD2(v35))
    {
      v4 = 0;
      v5 = (int *)(v34 + 8);
      while (1)
      {
        v6 = *v5;
        v5 += 6;
        if (v6 < 0)
          break;
        if (DWORD2(v35) == ++v4)
        {
          LODWORD(v4) = DWORD2(v35);
          break;
        }
      }
    }
    else
    {
      LODWORD(v4) = 0;
    }
    if (DWORD2(v35) == (_DWORD)v4)
    {
      v7 = v34;
      v8 = DWORD2(v35);
    }
    else
    {
      v9 = v4;
      v7 = v34;
      do
      {
        *(_QWORD *)&v36 = 0;
        *(_QWORD *)&v36 = *(_QWORD *)(v7 + 24 * v9 + 16);
        if (!re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)this + 192, (uint64_t *)&v36))
        {
          re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)this + 192, (uint64_t *)&v36);
          if (*((_QWORD *)this + 18))
          {
            v10 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v36 ^ ((unint64_t)v36 >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                                    * ((unint64_t)v36 ^ ((unint64_t)v36 >> 30))) >> 27));
            v11 = (v10 ^ (v10 >> 31)) % *((unsigned int *)this + 42);
            v12 = *((_QWORD *)this + 19);
            v13 = *(unsigned int *)(v12 + 4 * v11);
            if ((_DWORD)v13 != 0x7FFFFFFF)
            {
              v14 = *((_QWORD *)this + 20);
              if (*(_QWORD *)(v14 + 72 * v13 + 16) == (_QWORD)v36)
              {
                *(_DWORD *)(v12 + 4 * v11) = *(_DWORD *)(v14 + 72 * v13 + 8) & 0x7FFFFFFF;
LABEL_19:
                v16 = *((_QWORD *)this + 20);
                v17 = v16 + 72 * v13;
                v20 = *(_DWORD *)(v17 + 8);
                v19 = (int *)(v17 + 8);
                v18 = v20;
                if (v20 < 0)
                {
                  *v19 = v18 & 0x7FFFFFFF;
                  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)(v16 + 72 * v13 + 24));
                  v16 = *((_QWORD *)this + 20);
                  v18 = *(_DWORD *)(v16 + 72 * v13 + 8);
                }
                *(_DWORD *)(v16 + 72 * v13 + 8) = *((_DWORD *)this + 45) | v18 & 0x80000000;
                --*((_DWORD *)this + 43);
                v21 = *((_DWORD *)this + 46) + 1;
                *((_DWORD *)this + 45) = v13;
                *((_DWORD *)this + 46) = v21;
              }
              else
              {
                while (1)
                {
                  v15 = v13;
                  v13 = *(_DWORD *)(v14 + 72 * v13 + 8) & 0x7FFFFFFF;
                  if (v13 == 0x7FFFFFFF)
                    break;
                  if (*(_QWORD *)(v14 + 72 * v13 + 16) == (_QWORD)v36)
                  {
                    *(_DWORD *)(v14 + 72 * v15 + 8) = *(_DWORD *)(v14 + 72 * v15 + 8) & 0x80000000 | *(_DWORD *)(v14 + 72 * v13 + 8) & 0x7FFFFFFF;
                    goto LABEL_19;
                  }
                }
              }
            }
          }
          v22 = *((unsigned int *)this + 44);
          if ((_DWORD)v22)
          {
            v23 = 0;
            v24 = (int *)(*((_QWORD *)this + 20) + 8);
            while (1)
            {
              v25 = *v24;
              v24 += 18;
              if (v25 < 0)
                break;
              if (v22 == ++v23)
              {
                LODWORD(v23) = *((_DWORD *)this + 44);
                break;
              }
            }
          }
          else
          {
            LODWORD(v23) = 0;
          }
          if ((_DWORD)v22 != (_DWORD)v23)
          {
            v26 = v23;
            do
            {
              v27 = *((_QWORD *)this + 20);
              if (re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains(v27 + 72 * v26 + 24, (uint64_t *)&v36))
              {
                re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew((uint64_t)v42, (uint64_t *)(v27 + 72 * v26 + 16));
              }
              v28 = *((_DWORD *)this + 44);
              if (v28 <= (int)v23 + 1)
                v28 = v23 + 1;
              while (1)
              {
                v26 = (v23 + 1);
                if (v28 - 1 == (_DWORD)v23)
                  break;
                LODWORD(v23) = v23 + 1;
                v29 = v26;
                if ((*(_DWORD *)(*((_QWORD *)this + 20) + 72 * v26 + 8) & 0x80000000) != 0)
                  goto LABEL_38;
              }
              v29 = v28;
LABEL_38:
              LODWORD(v23) = v29;
            }
            while ((_DWORD)v22 != v29);
          }
        }
        v8 = DWORD2(v35);
        v7 = v34;
        if (DWORD2(v35) <= (v4 + 1))
          v30 = v4 + 1;
        else
          v30 = DWORD2(v35);
        while (1)
        {
          v9 = (v4 + 1);
          if (v30 - 1 == (_DWORD)v4)
            break;
          LODWORD(v4) = v4 + 1;
          v31 = v9;
          if ((*(_DWORD *)(v34 + 24 * v9 + 8) & 0x80000000) != 0)
            goto LABEL_46;
        }
        v31 = v30;
LABEL_46:
        LODWORD(v4) = v31;
      }
      while (v3 != v31);
    }
    v36 = v33;
    v33 = 0uLL;
    v37 = v7;
    v34 = 0;
    v38 = v35;
    v39 = v8;
    v40 = HIDWORD(v35);
    v41 = 0;
    v35 = xmmword_2260F5A80;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=((uint64_t)&v33, (uint64_t *)v42);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=((uint64_t)v42, (uint64_t *)&v36);
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v36);
  }
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v42);
  return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v33);
}

uint64_t re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::SharedPtr<re::internal::AssetEntry>&>(uint64_t a1, const re::DynamicString *a2, uint64_t *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  id v16;
  uint64_t v17;
  char v19;

  v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v19, (uint64_t)a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v11 = *(unsigned int *)(a1 + 36);
    if ((_DWORD)v11 == 0x7FFFFFFF)
    {
      v11 = *(unsigned int *)(a1 + 32);
      v12 = v11;
      if ((_DWORD)v11 == *(_DWORD *)(a1 + 24))
      {
        re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
        LODWORD(v8) = v7 % *(unsigned int *)(a1 + 24);
        v12 = *(_DWORD *)(a1 + 32);
      }
      *(_DWORD *)(a1 + 32) = v12 + 1;
      v13 = *(_QWORD *)(a1 + 16);
      v14 = *(_DWORD *)(v13 + 56 * v11 + 8);
    }
    else
    {
      v13 = *(_QWORD *)(a1 + 16);
      v14 = *(_DWORD *)(v13 + 56 * v11 + 8);
      *(_DWORD *)(a1 + 36) = v14 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v13 + 56 * v11 + 8) = v14 | 0x80000000;
    *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v11 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v11 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v8);
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v11) = v7;
    re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 56 * v11 + 16), a2);
    v15 = *a3;
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v11 + 48) = *a3;
    if (v15)
      v16 = (id)(v15 + 8);
    *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v8) = v11;
    ++*(_DWORD *)(a1 + 28);
    ++*(_DWORD *)(a1 + 40);
    v17 = *(_QWORD *)(a1 + 16) + 56 * v11;
    return v17 + 48;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (!re::DynamicString::operator==(v10 + 56 * v9 + 16, (uint64_t)a2))
  {
    v9 = *(_DWORD *)(v10 + 56 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v17 = v10 + 56 * v9;
  return v17 + 48;
}

uint64_t re::AssetManager::assignCompiledAssetDataToAssetHandle(uint64_t a1, void *a2, uint64_t *a3, int a4)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  _anonymous_namespace_ *v16;
  re *v17;
  _OWORD v19[2];
  _anonymous_namespace_ *v20[2];

  v8 = a3[1];
  if (atomic_load((unsigned int *)(v8 + 704)))
    re::AssetManager::unloadAssetAsync(a1, a3[1], 1);
  v10 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(a1 + 1104), *(_QWORD *)(v8 + 264));
  os_unfair_lock_lock((os_unfair_lock_t)(v8 + 384));
  re::internal::AssetEntry::setIsLoading_locked((re::internal::AssetEntry *)v8, 1);
  os_unfair_lock_unlock((os_unfair_lock_t)(v8 + 384));
  re::AssetManager::processAssetPointer((re::AssetManager *)a1, a2, (re::internal::AssetEntry *)v8);
  if (*(_QWORD *)(v8 + 112) == -1)
    v11 = 0;
  else
    v11 = *(_QWORD *)(v8 + 112);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v20, 2056, v11, **(const char ***)(a3[1] + 264));
  v12 = (*(uint64_t (**)(uint64_t, void *, _QWORD, _QWORD))(*(_QWORD *)v10 + 24))(v10, a2, 0, 0);
  if ((v12 & 1) != 0)
  {
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v20);
    os_unfair_lock_lock((os_unfair_lock_t)(v8 + 384));
    re::internal::SharedAssetPointer::makeSharedAssetPointer((re::internal::SharedAssetPointer *)a2, v20);
    if (*(_QWORD *)(v8 + 112) == -1)
      v13 = 0;
    else
      v13 = *(_QWORD *)(v8 + 112);
    re::internal::AssetEntry::LoadState::setLoadingAssetPointer_locked(v8 + 704, (uint64_t *)v20, v13);
    if (v20[0])

    if (a4)
      re::AssetManager::queueEntryForRegistration_entryStateLocked((os_unfair_lock_s *)a1, (std::chrono::system_clock::time_point *)v8);
    else
      re::AssetManager::entryReadyForRegistration_entryStateLocked((os_unfair_lock_s *)a1, (re::internal::AssetEntry *)v8, v14, v15);
    os_unfair_lock_unlock((os_unfair_lock_t)(v8 + 384));
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
    re::internal::AssetIdLoadDescriptorTable::markDependenciesDirty((re::internal::AssetIdLoadDescriptorTable *)(a1 + 120), (const re::AssetHandle *)a3);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 64));
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)(v8 + 384));
    v16 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, void *))(*(_QWORD *)v10 + 16))(v10, a2);
    re::AssetManager::putEntryInFailedState_entryStateLocked(v17, v8, 303, (uint64_t)v19);
    if (*(_QWORD *)&v19[0])
    {
      if ((BYTE8(v19[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v19[0] + 40))();
      memset(v19, 0, sizeof(v19));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(v8 + 384));
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v20);
  }
  return v12;
}

uint64_t re::AssetManager::processAssetPointer(re::AssetManager *this, void *a2, re::internal::AssetEntry *a3)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  re::AssetHandle **v8;
  re::AssetHandle *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t **v22;
  double v23;
  re::AssetManager *v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  char *v28;
  const re::AssetPath *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  re *v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  double v42;
  unsigned int v43;
  uint64_t v44;
  int *v45;
  int v46;
  NSObject *v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  re::AssetHandle **v53;
  uint64_t v54;
  re::DynamicString *v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int v62;
  unsigned int v63;
  const re::AssetHandle *v64;
  uint64_t v65;
  double v66;
  double v67;
  uint64_t result;
  uint64_t v70;
  void *v71;
  uint64_t v73;
  unsigned int v74;
  re::AssetHandle **v75;
  _QWORD v76[3];
  __int128 v77;
  __int128 v78;
  unsigned int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  re::AssetHandle **v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  __int128 buf;
  __int128 v88;
  _BYTE v89[12];
  char v90[17];

  v70 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*((_QWORD *)this + 138), *((_QWORD *)a3 + 33));
  v71 = a2;
  (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v70 + 160))(&v81);
  v79 = 0;
  v77 = 0u;
  v78 = 0u;
  v80 = 0x7FFFFFFFLL;
  if (v82)
  {
    v73 = 0;
    v74 = 0;
    v4 = 0;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = v83;
    v75 = &v83[v82];
    while (1)
    {
      v9 = *v8;
      re::AssetHandle::getOrBuildSerializationString(*v8, (re::DynamicString *)&buf);
      if ((BYTE8(buf) & 1) != 0)
        v10 = *((_QWORD *)&buf + 1) >> 1;
      else
        v10 = BYTE8(buf) >> 1;
      if (v10)
      {
        v11 = re::Hash<re::DynamicString>::operator()((uint64_t)&v84, (uint64_t)&buf);
        v12 = v11;
        if ((_QWORD)v77)
        {
          v13 = v11 % v74;
          v14 = *(unsigned int *)(v4 + 4 * v13);
          if ((_DWORD)v14 != 0x7FFFFFFF)
          {
            while (!re::DynamicString::operator==(v7 + 56 * v14 + 16, (uint64_t)&buf))
            {
              v14 = *(_DWORD *)(v7 + 56 * v14 + 8) & 0x7FFFFFFF;
              if (v14 == 0x7FFFFFFF)
                goto LABEL_13;
            }
            goto LABEL_19;
          }
        }
        else
        {
          v13 = 0;
        }
LABEL_13:
        v15 = v80;
        if ((_DWORD)v80 == 0x7FFFFFFF)
        {
          v16 = v6;
          v74 = DWORD2(v78);
          if ((_DWORD)v6 == DWORD2(v78))
          {
            re::HashTable<re::DynamicString,re::AssetHandle const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity((uint64_t)&v77, 2 * v5);
            v16 = v79;
            v13 = v12 % DWORD2(v78);
            v7 = v78;
            v73 = *((_QWORD *)&v77 + 1);
            v74 = DWORD2(v78);
          }
          v17 = v16 + 1;
          v79 = v16 + 1;
          v15 = v6;
          v18 = *(_DWORD *)(v7 + 56 * v6 + 8);
          v4 = v73;
        }
        else
        {
          v18 = *(_DWORD *)(v7 + 56 * v80 + 8);
          LODWORD(v80) = v18 & 0x7FFFFFFF;
          v17 = v6;
          LODWORD(v6) = v15;
        }
        v19 = 56 * v15;
        *(_DWORD *)(v7 + v19 + 8) = v18 | 0x80000000;
        v7 = v78;
        v20 = v78 + v19;
        *(_DWORD *)(v20 + 8) = *(_DWORD *)(v78 + v19 + 8) & 0x80000000 | *(_DWORD *)(v4 + 4 * v13);
        *(_QWORD *)v20 = v12;
        re::DynamicString::DynamicString((re::DynamicString *)(v20 + 16), (const re::DynamicString *)&buf);
        *(_QWORD *)(v20 + 48) = v9;
        *(_DWORD *)(v4 + 4 * v13) = v6;
        v5 = ++HIDWORD(v78);
        ++HIDWORD(v80);
        v6 = v17;
      }
LABEL_19:
      if ((_QWORD)buf && (BYTE8(buf) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)buf + 40))();
      if (++v8 == v75)
        goto LABEL_25;
    }
  }
  v5 = 0;
LABEL_25:
  v21 = v5;
  re::AssetHandle::AssetHandle((re::AssetHandle *)v76, a3);
  v22 = (uint64_t **)v83;
  *(_DWORD *)v89 = 0;
  v23 = 0.0;
  buf = 0u;
  v88 = 0u;
  *(_QWORD *)&v89[4] = 0x7FFFFFFFLL;
  v24 = this;
  if (v82)
  {
    v25 = 8 * v82;
    do
    {
      v26 = *v22;
      if (!(*v22)[1])
      {
        v27 = v26[2];
        if (v27)
        {
          if ((*(_BYTE *)(v27 + 8) & 1) != 0)
            v28 = *(char **)(v27 + 16);
          else
            v28 = (char *)(v27 + 9);
          v29 = (const re::AssetPath *)re::AssetHandle::legacy_assetPath((re::AssetHandle *)v76);
          re::AssetManager::assetHandleWithParentAssetPath(this, v28, v29, 1, &v84);
          v30 = v26[1];
          v31 = v26[2];
          v26[1] = v85;
          v85 = v30;
          v32 = *v26;
          *v26 = 0;
          *v26 = v84;
          v26[2] = v86;
          v84 = v32;
          v86 = v31;
          re::AssetHandle::~AssetHandle((re::AssetHandle *)&v84);
        }
      }
      ++v22;
      v25 -= 8;
    }
    while (v25);
  }
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&buf, v23);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v76);
  re::AssetHandle::AssetHandle((re::AssetHandle *)&v84, a3);
  if (!*((_QWORD *)this + 151))
    goto LABEL_81;
  v33 = (re *)re::AssetHandle::assetInfo((re::AssetHandle *)&v84);
  if (*((_DWORD *)v33 + 22) != 8)
  {
    v47 = *re::assetsLogObjects(v33);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl(&dword_224FE9000, v47, OS_LOG_TYPE_DEFAULT, "Cannot share dependencies over network. Only supported for AssetId based assets.", (uint8_t *)&buf, 2u);
    }
    goto LABEL_81;
  }
  if (!v21)
    goto LABEL_81;
  v34 = re::AssetHandle::assetInfo((re::AssetHandle *)&v84);
  if ((unint64_t)(v34[10] + 1) >= 2)
    v35 = v34[10];
  else
    v35 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  *(_QWORD *)&buf = v35;
  v36 = re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 120, (uint64_t *)&buf);
  if (v36)
  {
    v37 = *(_QWORD *)(v36 + 32);
    v38 = *(_QWORD *)(v37 + 8);
    v39 = *(_QWORD *)(v37 + 16);
    v40 = v37 + 9;
    v41 = (const char *)((v38 & 1) != 0 ? v39 : v40);
    if (!strcmp(v41, "NetworkAsset"))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)this + 16);
      goto LABEL_81;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 16);
  *(_DWORD *)v89 = 0;
  v42 = 0.0;
  buf = 0u;
  v88 = 0u;
  *(_QWORD *)&v89[4] = 0x7FFFFFFFLL;
  v43 = v79;
  if (v79)
  {
    v44 = 0;
    v45 = (int *)(v78 + 8);
    while (1)
    {
      v46 = *v45;
      v45 += 14;
      if (v46 < 0)
        break;
      if (v79 == ++v44)
      {
        LODWORD(v44) = v79;
        break;
      }
    }
  }
  else
  {
    LODWORD(v44) = 0;
  }
  if (v79 == (_DWORD)v44)
    goto LABEL_79;
  v48 = v44;
  v49 = v78;
  v50 = v79;
  do
  {
    v51 = v49 + 56 * v48;
    v54 = *(_QWORD *)(v51 + 48);
    v53 = (re::AssetHandle **)(v51 + 48);
    v52 = v54;
    if (!v54 || !*(_QWORD *)(v52 + 8) || re::AssetManager::isDeviceAsset((uint64_t)v24, v52, 12))
      goto LABEL_69;
    v55 = (re::DynamicString *)(v53 - 4);
    v56 = *((_QWORD *)re::AssetHandle::assetInfo(*v53) + 10);
    if (v56 == -1)
      v56 = 0;
    v76[0] = v56;
    v57 = re::Hash<re::DynamicString>::operator()((uint64_t)v90, (uint64_t)(v53 - 4));
    v58 = v57;
    if ((_QWORD)buf)
    {
      v59 = v57 % DWORD2(v88);
      v60 = *(unsigned int *)(*((_QWORD *)&buf + 1) + 4 * v59);
      if ((_DWORD)v60 != 0x7FFFFFFF)
      {
        v61 = v88;
        while (!re::DynamicString::operator==(v61 + 56 * v60 + 16, (uint64_t)v55))
        {
          v60 = *(_DWORD *)(v61 + 56 * v60 + 8) & 0x7FFFFFFF;
          if (v60 == 0x7FFFFFFF)
            goto LABEL_67;
        }
        goto LABEL_68;
      }
    }
    else
    {
      LODWORD(v59) = 0;
    }
LABEL_67:
    re::HashTable<re::DynamicString,unsigned long long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy((uint64_t)&buf, v59, v58, v55, v76);
    ++*(_DWORD *)&v89[8];
LABEL_68:
    v50 = v79;
    v49 = v78;
    v24 = this;
LABEL_69:
    if (v50 <= (int)v44 + 1)
      v62 = v44 + 1;
    else
      v62 = v50;
    while (1)
    {
      v48 = (v44 + 1);
      if (v62 - 1 == (_DWORD)v44)
        break;
      LODWORD(v44) = v44 + 1;
      v63 = v48;
      if ((*(_DWORD *)(v49 + 56 * v48 + 8) & 0x80000000) != 0)
        goto LABEL_76;
    }
    v63 = v62;
LABEL_76:
    LODWORD(v44) = v63;
  }
  while (v43 != v63);
  if (HIDWORD(v88))
    re::NetworkActionQueue::queueSyncActionShareDependencies((uint64_t)v24 + 768, v35, (uint64_t)&buf);
LABEL_79:
  re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&buf, v42);
LABEL_81:
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v84);
  (*(void (**)(__int128 *__return_ptr, uint64_t, void *))(*(_QWORD *)v70 + 168))(&buf, v70, v71);
  if ((_QWORD)v88)
  {
    v64 = *(const re::AssetHandle **)v89;
    v65 = 24 * v88;
    do
    {
      re::AssetHandle::AssetHandle((re::AssetHandle *)&v84, v64);
      re::AssetHandle::loadAsync((re::AssetHandle *)&v84);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&v84);
      v64 = (const re::AssetHandle *)((char *)v64 + 24);
      v65 -= 24;
    }
    while (v65);
  }
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&buf);
  v67 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)&v77, v66);
  result = v81;
  if (v81)
  {
    if (v83)
      return (*(uint64_t (**)(double))(*(_QWORD *)v81 + 40))(v67);
  }
  return result;
}

void re::AssetManager::putEntryInFailedState_entryStateLocked(re *a1, uint64_t a2, int a3, uint64_t a4)
{
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v7 = *re::assetsLogObjects(a1);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    v8 = *(_QWORD *)(a2 + 176);
    if ((*(_BYTE *)(a2 + 168) & 1) == 0)
      v8 = a2 + 169;
    if ((*(_BYTE *)(a4 + 8) & 1) != 0)
      v9 = *(_QWORD *)(a4 + 16);
    else
      v9 = a4 + 9;
    v10 = 136315394;
    v11 = v8;
    v12 = 2080;
    v13 = v9;
    _os_log_error_impl(&dword_224FE9000, v7, OS_LOG_TYPE_ERROR, "Asset %s failure: %s", (uint8_t *)&v10, 0x16u);
  }
  *(_BYTE *)(a2 + 417) = 0;
  re::internal::AssetEntry::LoadState::setLoadFailure_locked(a2 + 704, a3, (re::DynamicString *)a4);
  re::internal::AssetEntry::setIsLoading_locked((re::internal::AssetEntry *)a2, 0);
  re::internal::AssetEntry::cancelResourceRequest_stateLocked((re::internal::AssetEntry *)a2);
}

void re::AssetManager::queueEntryForRegistration_entryStateLocked(os_unfair_lock_s *this, std::chrono::system_clock::time_point *a2)
{
  NSObject *v4;
  const char *v5;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v6;
  const char **v7;
  const char *v8;
  char *rep;
  _BYTE v10[24];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  v4 = *re::assetsLogObjects((re *)this);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    if ((a2[21].__d_.__rep_ & 1) != 0)
      rep = (char *)a2[22].__d_.__rep_;
    else
      rep = (char *)&a2[21].__d_.__rep_ + 1;
    *(_DWORD *)v10 = 136315138;
    *(_QWORD *)&v10[4] = rep;
    _os_log_debug_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEBUG, "Asset '%s' queued for registration.", v10, 0xCu);
  }
  if (a2[14].__d_.__rep_ == -1)
    LODWORD(v6) = 0;
  else
    v6 = a2[14].__d_.__rep_;
  v7 = (const char **)a2[33].__d_.__rep_;
  if (v7)
    v8 = *v7;
  else
    v8 = 0;
  re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x810, v6, v8, v5);
  a2[51].__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  LOBYTE(a2[52].__d_.__rep_) = 1;
  os_unfair_lock_lock(this + 16);
  re::internal::AssetEntry::makeAssetReference((re::internal::AssetEntry *)a2, (re::internal::AssetReference **)v10);
  re::DynamicArray<re::SharedPtr<re::internal::AssetReference>>::add((_anonymous_namespace_ *)&this[90], v10);
  if (*(_QWORD *)v10)

  os_unfair_lock_unlock(this + 16);
}

void re::AssetManager::entryReadyForRegistration_entryStateLocked(os_unfair_lock_s *this, re::internal::AssetEntry *a2, uint64_t a3, const char *a4)
{
  NSObject *v6;
  uint64_t v7;
  const char **v8;
  const char *v9;
  char *v10;
  _BYTE v11[24];
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  if (re::assetsHighFrequencyLoggingEnabled(void)::onceToken != -1)
    dispatch_once(&re::assetsHighFrequencyLoggingEnabled(void)::onceToken, &__block_literal_global_1);
  if (re::assetsHighFrequencyLoggingEnabled(void)::shouldLog)
  {
    v6 = *re::assetsLogObjects((re *)this);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      if ((*((_QWORD *)a2 + 21) & 1) != 0)
        v10 = (char *)*((_QWORD *)a2 + 22);
      else
        v10 = (char *)a2 + 169;
      *(_DWORD *)v11 = 136315138;
      *(_QWORD *)&v11[4] = v10;
      _os_log_debug_impl(&dword_224FE9000, v6, OS_LOG_TYPE_DEBUG, "Registering asset '%s'", v11, 0xCu);
    }
  }
  if (*((_QWORD *)a2 + 14) == -1)
    LODWORD(v7) = 0;
  else
    v7 = *((_QWORD *)a2 + 14);
  v8 = (const char **)*((_QWORD *)a2 + 33);
  if (v8)
    v9 = *v8;
  else
    v9 = 0;
  re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x810, v7, v9, a4);
  re::AssetManager::processAssetRegistration_entryStateLocked((re::AssetManager *)this, a2);
  if (*((_BYTE *)a2 + 416))
  {
    os_unfair_lock_lock(this + 16);
    re::internal::AssetEntry::makeAssetReference(a2, (re::internal::AssetReference **)v11);
    re::DynamicArray<re::SharedPtr<re::internal::AssetReference>>::add((_anonymous_namespace_ *)&this[90], v11);
    if (*(_QWORD *)v11)

    os_unfair_lock_unlock(this + 16);
  }
}

void re::AssetManager::createAssetEntryForNamedAsset(os_unfair_lock_s *this@<X0>, void *a2@<X1>, const re::AssetPath *a3@<X3>, uint64_t *a4@<X8>)
{
  uint64_t v8[3];

  re::AssetManager::assetHandle(this, a3, 1, a4);
  re::AssetHandle::AssetHandle((re::AssetHandle *)v8, (const re::AssetHandle *)a4);
  re::AssetManager::assignCompiledAssetDataToAssetHandle((uint64_t)this, a2, v8, 0);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v8);
}

void re::AssetManager::setAssetPointerForExistingAsset(os_unfair_lock_s *this, void *a2, const re::AssetHandle *a3, int a4, int a5)
{
  unint64_t v10;
  char *v11;
  re::internal::AssetIdLoadDescriptorTable *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  os_unfair_lock_s *v18;
  os_unfair_lock_s *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  NSObject *v24;
  os_unfair_lock_s *lock;
  uint64_t v26[3];
  int v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  uint64_t v31[3];
  _BYTE buf[12];
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;

  v45 = *MEMORY[0x24BDAC8D0];
  re::AssetHandle::AssetHandle((re::AssetHandle *)v31, a3);
  re::AssetManager::assignCompiledAssetDataToAssetHandle((uint64_t)this, a2, v31, a4);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v31);
  if (a5)
  {
    v10 = *((_QWORD *)re::AssetHandle::assetInfo(a3) + 10);
    v11 = (char *)re::AssetHandle::legacy_assetPath(a3);
    re::DynamicString::DynamicString((re::DynamicString *)&v29, (const re::DynamicString *)(v11 + 40));
    lock = this + 16;
    os_unfair_lock_lock(this + 16);
    v12 = (re::internal::AssetIdLoadDescriptorTable *)&this[30];
    *(_QWORD *)buf = v10;
    v13 = re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)&this[30], (uint64_t *)buf);
    v14 = *(_QWORD *)(v13 + 16);
    if (v14)
    {
      v15 = *(_QWORD *)(v13 + 32);
      v16 = v15 + 144 * v14;
      while (1)
      {
        if (*(_BYTE *)(*((_QWORD *)a3 + 1) + 312))
        {
          v17 = (*(_QWORD *)(v15 + 8) & 1) != 0 ? *(const char **)(v15 + 16) : (const char *)(v15 + 9);
          if (!strcmp(v17, "MemoryAsset"))
            break;
        }
        v18 = *(os_unfair_lock_s **)&this[298]._os_unfair_lock_opaque;
        v19 = v18 + 16;
        os_unfair_lock_lock(v18 + 16);
        LOBYTE(v18) = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey((uint64_t)&v18[30], v15);
        os_unfair_lock_unlock(v19);
        if ((v18 & 1) != 0)
          break;
        v20 = *(_QWORD *)(v15 + 8);
        v21 = *(_QWORD *)(v15 + 16);
        v22 = v15 + 9;
        v23 = (const char *)((v20 & 1) != 0 ? v21 : v22);
        v13 = strcmp(v23, "NamedAsset");
        if (!(_DWORD)v13)
          break;
        v15 = v22 + 135;
        if (v15 == v16)
          goto LABEL_15;
      }
    }
    else
    {
LABEL_15:
      if (*(_BYTE *)(*((_QWORD *)a3 + 1) + 312))
      {
        v24 = *re::assetsLogObjects((re *)v13);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 134217984;
          *(_QWORD *)&buf[4] = v10;
          _os_log_error_impl(&dword_224FE9000, v24, OS_LOG_TYPE_ERROR, "No memory load descriptor for MemoryAsset with id:%llu", buf, 0xCu);
        }
      }
      re::internal::AssetIdLoadDescriptorTable::remove(v12, v10);
      MemoryAssetProvider::makeDescriptor((MemoryAssetProvider *)&v29, **(const re::DynamicString ***)(*((_QWORD *)a3 + 1) + 264), (uint64_t)buf);
      v28 = 0;
      memset(v26, 0, sizeof(v26));
      v27 = 0;
      re::DynamicArray<re::AssetLoadDescriptor>::add((_anonymous_namespace_ *)v26, (re::DynamicString *)buf);
      if (*(_BYTE *)(*((_QWORD *)a3 + 1) + 257))
        re::internal::AssetIdLoadDescriptorTable::addNewMutable((uint64_t)v12, v10, (uint64_t)v26);
      else
        re::internal::AssetIdLoadDescriptorTable::addNewImmutable(v12, v10, v26);
      re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)v26);
      if ((_QWORD)v43)
      {
        if ((BYTE8(v43) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v43 + 40))();
        v43 = 0u;
        v44 = 0u;
      }
      if (v38)
      {
        if (v42)
          (*(void (**)(void))(*(_QWORD *)v38 + 40))();
        v42 = 0;
        v39 = 0;
        v40 = 0;
        v38 = 0;
        ++v41;
      }
      if (v33)
      {
        if (v37)
          (*(void (**)(void))(*(_QWORD *)v33 + 40))();
        v37 = 0;
        v34 = 0;
        v35 = 0;
        v33 = 0;
        ++v36;
      }
      if (*(_QWORD *)buf && (buf[8] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)buf + 40))();
    }
    os_unfair_lock_unlock(lock);
    if (v29)
    {
      if ((v30 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v29 + 40))();
    }
  }
}

const re::IntrospectionBase *MemoryAssetProvider::makeDescriptor@<X0>(MemoryAssetProvider *this@<X0>, const re::DynamicString *a2@<X1>, uint64_t a3@<X8>)
{
  _anonymous_namespace_ *v7;
  size_t v8;
  const re::IntrospectionBase *result;
  const re::IntrospectionBase *v10;
  char v11;
  const char *v12;
  uint64_t v13;

  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  v7 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a3, 0);
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 40) = 0;
  *(_DWORD *)(a3 + 56) = 0;
  *(_QWORD *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_DWORD *)(a3 + 96) = 0;
  *(_OWORD *)(a3 + 104) = 0u;
  *(_OWORD *)(a3 + 120) = 0u;
  *(_QWORD *)(a3 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a3 + 112), 0);
  v12 = "MemoryAsset";
  v13 = 11;
  re::DynamicString::operator=((re::DynamicString *)a3, (uint64_t)&v12);
  v8 = strlen((const char *)a2);
  v12 = (const char *)a2;
  v13 = v8;
  re::DynamicString::operator=((re::DynamicString *)(a3 + 112), (uint64_t)&v12);
  re::DynamicString::DynamicString((re::DynamicString *)&v10, this);
  re::AssetLoadDescriptor::setIntrospectableData((char **)a3, (const re::IntrospectionBase *)MemoryAssetProvider::s_loadDescriptorParametersIntrospect, &v10, 0);
  result = v10;
  if (v10)
  {
    if ((v11 & 1) != 0)
      return (const re::IntrospectionBase *)(*(uint64_t (**)(void))(*(_QWORD *)v10 + 40))();
  }
  return result;
}

void re::AssetManager::createNewImmutableAssetHandleFromExistingAssetData(uint64_t a1@<X0>, uint64_t *a2@<X1>, int a3@<W2>, re::AssetHandle *a4@<X3>, int a5@<W4>, _BYTE *a6@<X8>)
{
  re *v12;
  re::AssetHandle *v13;
  unsigned __int8 v14;
  NSObject *v15;
  NSObject *v16;
  _QWORD *v17;
  char *v18;
  _QWORD *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(*((_QWORD *)a4 + 1) + 312))
  {
    uuid_generate_random((unsigned __int8 *)&v21);
    re::AssetManager::createNewImmutableAssetHandle((os_unfair_lock_s *)a1, a2, (*((_QWORD *)&v21 + 1) + ((_QWORD)v21 << 6) + ((unint64_t)v21 >> 2) - 0x61C8864680B583E9) ^ v21, a3, (uint64_t)a6);
    if (*a6)
    {
      v13 = (re::AssetHandle *)(a6 + 8);
      re::AssetManager::transferAssetHandleDataToEmptyAssetHandle((re::AssetManager *)a1, a4, v13);
      if (a5)
      {
        v14 = atomic_load((unsigned __int8 *)(a1 + 1409));
        if ((v14 & 1) == 0 && !*(_BYTE *)(a1 + 1410))
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 584));
        re::AssetHandle::internalRegisterAsset(v13);
      }
    }
    else
    {
      v16 = *re::assetsLogObjects(v12);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        v19 = re::AssetHandle::assetInfo(a4);
        if ((v19[17] & 1) != 0)
          v20 = (char *)v19[18];
        else
          v20 = (char *)v19 + 137;
        LODWORD(v21) = 136315138;
        *(_QWORD *)((char *)&v21 + 4) = v20;
        _os_log_error_impl(&dword_224FE9000, v16, OS_LOG_TYPE_ERROR, "Failed to create new immutable handle from given existingAsset '%s'", (uint8_t *)&v21, 0xCu);
      }
    }
  }
  else
  {
    v15 = *re::assetsLogObjects((re *)a1);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v17 = re::AssetHandle::assetInfo(a4);
      if ((v17[17] & 1) != 0)
        v18 = (char *)v17[18];
      else
        v18 = (char *)v17 + 137;
      LODWORD(v21) = 136315138;
      *(_QWORD *)((char *)&v21 + 4) = v18;
      _os_log_error_impl(&dword_224FE9000, v15, OS_LOG_TYPE_ERROR, "Can't create new immutable handle from given non memory asset '%s'", (uint8_t *)&v21, 0xCu);
    }
    *a6 = 0;
  }
}

void re::AssetManager::transferAssetHandleDataToEmptyAssetHandle(re::AssetManager *this, re::AssetHandle *a2, re::AssetHandle *a3)
{
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  os_unfair_lock_s *v10;
  re::internal::AssetIdLoadDescriptorTable *v11;

  re::AssetManager::copyAssetHandleDataToEmptyAssetHandle(this, a2, a3);
  re::AssetHandle::internalUnregisterAsset(a2);
  v6 = *((_QWORD *)a2 + 1);
  if (v6)
    v7 = *(_QWORD *)(v6 + 264);
  else
    v7 = 0;
  v8 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*((_QWORD *)this + 138), v7);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 384));
  v9 = re::internal::AssetEntry::LoadState::clearAndReturnAssetPointer_locked((re::internal::AssetEntry::LoadState *)(v6 + 704));
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 16))(v8, v9);
  v10 = (os_unfair_lock_s *)((char *)this + 64);
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  v11 = (re::AssetManager *)((char *)this + 120);
  re::internal::AssetIdLoadDescriptorTable::markDependenciesDirty(v11, a2);
  os_unfair_lock_unlock(v10);
  os_unfair_lock_lock(v10);
  re::internal::AssetIdLoadDescriptorTable::markDependenciesDirty(v11, a3);
  os_unfair_lock_unlock(v10);
  os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 384));
}

void re::AssetManager::copyNewImmutableAssetHandleFromExistingAssetData(uint64_t a1@<X0>, uint64_t *a2@<X1>, int a3@<W2>, re::AssetHandle *a4@<X3>, _BYTE *a5@<X8>)
{
  unsigned __int8 v10;
  re *v11;
  re::AssetHandle *v12;
  NSObject *v13;
  _QWORD *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v10 = atomic_load((unsigned __int8 *)(a1 + 1409));
  if ((v10 & 1) == 0 && !*(_BYTE *)(a1 + 1410))
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 584));
  uuid_generate_random((unsigned __int8 *)&v16);
  re::AssetManager::createNewImmutableAssetHandle((os_unfair_lock_s *)a1, a2, (*((_QWORD *)&v16 + 1) + ((_QWORD)v16 << 6) + ((unint64_t)v16 >> 2) - 0x61C8864680B583E9) ^ v16, a3, (uint64_t)a5);
  if (*a5)
  {
    v12 = (re::AssetHandle *)(a5 + 8);
    re::AssetManager::copyAssetHandleDataToEmptyAssetHandle((re::AssetManager *)a1, a4, v12);
    re::AssetHandle::internalRegisterAsset(v12);
  }
  else
  {
    v13 = *re::assetsLogObjects(v11);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v14 = re::AssetHandle::assetInfo(a4);
      if ((v14[17] & 1) != 0)
        v15 = (char *)v14[18];
      else
        v15 = (char *)v14 + 137;
      LODWORD(v16) = 136315138;
      *(_QWORD *)((char *)&v16 + 4) = v15;
      _os_log_error_impl(&dword_224FE9000, v13, OS_LOG_TYPE_ERROR, "Failed to create new immutable handle from given existingAsset '%s'", (uint8_t *)&v16, 0xCu);
    }
  }
}

void re::AssetManager::copyAssetHandleDataToEmptyAssetHandle(re::AssetManager *this, re::AssetHandle *a2, re::AssetHandle *a3)
{
  os_unfair_lock_s *v5;
  uint64_t v6;
  re::AssetLoader *v7;
  void *v8;
  re::internal::SharedAssetPointer *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  re *v13;
  NSObject *v14;
  _BYTE *v15;
  _anonymous_namespace_ *v16;
  char v17;
  _BYTE v18[23];
  uint8_t v19[16];
  uint8_t buf[4];
  _BYTE *v21;
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  v5 = (os_unfair_lock_s *)*((_QWORD *)a2 + 1);
  os_unfair_lock_lock(v5 + 96);
  v6 = *((_QWORD *)a3 + 1);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 384));
  v7 = (re::AssetLoader *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*((_QWORD *)this + 138), *(_QWORD *)(v6 + 264));
  v8 = (void *)re::internal::AssetEntry::assetPointer((re::internal::AssetEntry *)v5);
  v9 = (re::internal::SharedAssetPointer *)re::AssetLoader::cloneAsset(v7, v8);
  v10 = re::internal::AssetEntry::LoadState::clearAndReturnAssetPointer_locked((re::internal::AssetEntry::LoadState *)(v6 + 704));
  if (v10)
    (*(void (**)(re::AssetLoader *, uint64_t))(*(_QWORD *)v7 + 16))(v7, v10);
  re::internal::SharedAssetPointer::makeSharedAssetPointer(v9, &v16);
  re::internal::AssetEntry::LoadState::setAssetPointer_locked(v6 + 704, (uint64_t *)&v16);
  if (v16)

  if (*(_QWORD *)(v6 + 112) == -1)
    v11 = 0;
  else
    v11 = *(_QWORD *)(v6 + 112);
  re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v19, 2056, v11, **(const char ***)(v6 + 264));
  if (((*(uint64_t (**)(re::AssetLoader *, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v7 + 24))(v7, *(_QWORD *)(*(_QWORD *)(v6 + 712) + 24), 0, 0) & 1) == 0)
  {
    if ((*(_BYTE *)(v6 + 168) & 1) != 0)
      v12 = *(_QWORD *)(v6 + 176);
    else
      v12 = v6 + 169;
    v13 = (re *)re::DynamicString::format((re::DynamicString *)"Failed to create runtime data for asset '%s'", (re::DynamicString *)&v16, v12);
    v14 = *re::assetsLogObjects(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      if ((v17 & 1) != 0)
        v15 = *(_BYTE **)&v18[7];
      else
        v15 = v18;
      *(_DWORD *)buf = 136315138;
      v21 = v15;
      _os_log_error_impl(&dword_224FE9000, v14, OS_LOG_TYPE_ERROR, "%s", buf, 0xCu);
    }
    if (v16 && (v17 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v16 + 40))();
  }
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v19);
  os_unfair_lock_unlock((os_unfair_lock_t)(v6 + 384));
  os_unfair_lock_unlock(v5 + 96);
}

uint64_t re::AssetManager::createNewMutableAssetHandleFromExistingAssetData@<X0>(os_unfair_lock_s *a1@<X0>, uint64_t *a2@<X1>, int a3@<W2>, re::AssetHandle *a4@<X3>, re::AssetHandle *a5@<X8>)
{
  re::AssetManager::createNewMutableAssetHandle(a1, a2, a3, 1, a5);
  re::AssetManager::transferAssetHandleDataToEmptyAssetHandle((re::AssetManager *)a1, a4, a5);
  return re::AssetHandle::internalRegisterAsset(a5);
}

uint64_t re::AssetManager::assetHandleMemoryPath@<X0>(os_unfair_lock_s *this@<X0>, const char *a2@<X1>, const re::DynamicString **a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t result;
  uint64_t v9;
  char v10;
  uint64_t v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;

  MemoryAssetProvider::makeDescriptor((MemoryAssetProvider *)&v9, *a3, (uint64_t)&v11);
  if (v9 && (v10 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v9 + 40))();
  os_unfair_lock_lock(this + 16);
  re::AssetManager::assetHandle_assetTablesLocked((re::AssetManager *)this, (const re::AssetLoadDescriptor *)&v11, a4);
  os_unfair_lock_unlock(this + 16);
  if ((_QWORD)v23)
  {
    if ((BYTE8(v23) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v23 + 40))();
    v23 = 0u;
    v24 = 0u;
  }
  if (v18)
  {
    if (v22)
      (*(void (**)(void))(*(_QWORD *)v18 + 40))();
    v22 = 0;
    v19 = 0;
    v20 = 0;
    v18 = 0;
    ++v21;
  }
  if (v13)
  {
    if (v17)
      (*(void (**)(void))(*(_QWORD *)v13 + 40))();
    v17 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 0;
    ++v16;
  }
  result = v11;
  if (v11)
  {
    if ((v12 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v11 + 40))();
  }
  return result;
}

uint64_t re::AssetManager::createOrUpdateAssetEntryForNamedAssetDescriptor@<X0>(uint64_t a1@<X0>, void *a2@<X1>, const char **a3@<X2>, const char *a4@<X3>, int a5@<W4>, int a6@<W5>, char a7@<W6>, uint64_t *a8@<X8>)
{
  _anonymous_namespace_ *v15;
  const char *v16;
  re *v17;
  uint64_t v18;
  NSObject *v19;
  re *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t result;
  __int128 v26;
  uint64_t v27;
  _OWORD v28[2];
  uint64_t v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  uint8_t buf[4];
  _DWORD v44[7];
  _BYTE v45[12];
  __int16 v46;
  _BYTE v47[10];
  uint64_t *v48;
  uint64_t v49;

  v49 = *MEMORY[0x24BDAC8D0];
  *a8 = 0;
  a8[1] = 0;
  a8[2] = 0;
  v16 = *a3;
  re::NamedAssetProvider::makeDescriptor((_anonymous_namespace_ *)v45, (re::DynamicString *)v28, (uint64_t)&v29);
  if (*(_QWORD *)&v28[0])
  {
    if ((BYTE8(v28[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v28[0] + 40))();
    memset(v28, 0, sizeof(v28));
  }
  if (*(_QWORD *)v45 && (v45[8] & 1) != 0)
    (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)v45 + 40))(*(_QWORD *)v45, *(_QWORD *)&v47[2]);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  v17 = (re *)re::AssetManager::existingMutableAssetHandles_assetTablesLocked((re::AssetManager *)v45, (re::internal::AssetTypeRegistry **)a1, (uint64_t)&v29);
  v18 = *(_QWORD *)&v47[2];
  if (*(_QWORD *)&v47[2])
  {
    if (*(_QWORD *)&v47[2] != 1)
    {
      v19 = *re::assetsLogObjects(v17);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)v44 = a4;
        _os_log_impl(&dword_224FE9000, v19, OS_LOG_TYPE_DEFAULT, "createOrUpdateAssetEntryForNamedAssetDescriptor found more than one existing asset registered with name '%s'.", buf, 0xCu);
      }
    }
    re::AssetHandle::operator=(a8, v48);
  }
  else
  {
    re::AssetManager::createNewMutableAssetHandle((os_unfair_lock_s *)a1, (re::DynamicString *)&v29, a5, 0, (re::AssetHandle *)&v26);
    buf[0] = 1;
    *(_OWORD *)&v44[1] = v26;
    v26 = 0uLL;
    *(_QWORD *)&v44[5] = v27;
    v27 = 0;
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v26);
    re::AssetHandle::operator=(a8, (uint64_t *)&v44[1]);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v44[1]);
  }
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v45);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 64));
  if (v18 && (a7 & 1) != 0)
  {
    v21 = *re::assetsLogObjects(v20);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      v22 = *((_QWORD *)re::AssetHandle::assetInfo((re::AssetHandle *)a8) + 10);
      if (v22 == -1)
        v22 = 0;
      *(_DWORD *)v45 = 134218242;
      *(_QWORD *)&v45[4] = v22;
      v46 = 2080;
      *(_QWORD *)v47 = a4;
      _os_log_impl(&dword_224FE9000, v21, OS_LOG_TYPE_DEFAULT, "Not replacing contents of asset '%llu' with named asset descriptor value '%s' because preserveOriginalInNameCollision was set.", v45, 0x16u);
    }
    v23 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(a1 + 1104), (unint64_t)a3);
    (*(void (**)(uint64_t, void *))(*(_QWORD *)v23 + 16))(v23, a2);
  }
  else
  {
    re::AssetManager::setAssetPointerForExistingAsset((os_unfair_lock_s *)a1, a2, (const re::AssetHandle *)a8, a6, 0);
  }
  if ((_QWORD)v41)
  {
    if ((BYTE8(v41) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v41 + 40))();
    v41 = 0u;
    v42 = 0u;
  }
  if (v36)
  {
    if (v40)
      (*(void (**)(void))(*(_QWORD *)v36 + 40))();
    v40 = 0;
    v37 = 0;
    v38 = 0;
    v36 = 0;
    ++v39;
  }
  if (v31)
  {
    if (v35)
      (*(void (**)(void))(*(_QWORD *)v31 + 40))();
    v35 = 0;
    v32 = 0;
    v33 = 0;
    v31 = 0;
    ++v34;
  }
  result = v29;
  if (v29)
  {
    if ((v30 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v29 + 40))();
  }
  return result;
}

uint64_t re::AssetManager::newAssetEntryForNamedMemoryAsset@<X0>(os_unfair_lock_s *a1@<X0>, void *a2@<X1>, const re::DynamicString **a3@<X2>, const char *a4@<X3>, int a5@<W4>, int a6@<W5>, int a7@<W6>, uint64_t *a8@<X8>)
{
  re *NewImmutableAssetHandle;
  uint64_t result;
  NSObject *v18;
  uint64_t *v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  uint8_t buf[16];
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  *a8 = 0;
  a8[1] = 0;
  a8[2] = 0;
  MemoryAssetProvider::makeDescriptor((MemoryAssetProvider *)&v20, *a3, (uint64_t)&v23);
  if (v20 && (v21 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v20 + 40))();
  if (a5)
  {
    re::AssetManager::createNewMutableAssetHandle(a1, (re::DynamicString *)&v23, a6, 1, (re::AssetHandle *)buf);
    LOBYTE(v20) = 1;
    v21 = *(_OWORD *)buf;
    memset(buf, 0, sizeof(buf));
    v22 = v38;
    v38 = 0;
    re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
LABEL_7:
    re::AssetHandle::operator=(a8, (uint64_t *)&v21);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v21);
    goto LABEL_8;
  }
  NewImmutableAssetHandle = (re *)re::AssetManager::createNewImmutableAssetHandle(a1, (re::DynamicString *)&v23, a6, (uint64_t)&v20);
  if ((_BYTE)v20)
    goto LABEL_7;
  v18 = *re::assetsLogObjects(NewImmutableAssetHandle);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = a4;
    _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "Failed to create new Immutable Memory Asset with '%s' path.", buf, 0xCu);
  }
  os_unfair_lock_lock(a1 + 16);
  v19 = (uint64_t *)re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::tryGet((uint64_t)&a1[42], (uint64_t)&v23);
  if (v19)
  {
    re::AssetManager::lookupExistingAsset_assetTablesLocked((re::internal::AssetTypeRegistry **)a1, *v19, buf);
    if (buf[0])
    {
      re::AssetHandle::operator=(a8, (uint64_t *)&buf[8]);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&buf[8]);
    }
  }
  os_unfair_lock_unlock(a1 + 16);
LABEL_8:
  re::AssetManager::setAssetPointerForExistingAsset(a1, a2, (const re::AssetHandle *)a8, a7, 0);
  if ((_QWORD)v35)
  {
    if ((BYTE8(v35) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v35 + 40))();
    v35 = 0u;
    v36 = 0u;
  }
  if (v30)
  {
    if (v34)
      (*(void (**)(void))(*(_QWORD *)v30 + 40))();
    v34 = 0;
    v31 = 0;
    v32 = 0;
    v30 = 0;
    ++v33;
  }
  if (v25)
  {
    if (v29)
      (*(void (**)(void))(*(_QWORD *)v25 + 40))();
    v29 = 0;
    v26 = 0;
    v27 = 0;
    v25 = 0;
    ++v28;
  }
  result = v23;
  if (v23)
  {
    if ((v24 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v23 + 40))();
  }
  return result;
}

uint64_t re::AssetManager::newAssetEntryForMemoryAsset@<X0>(os_unfair_lock_s *a1@<X0>, void *a2@<X1>, re **a3@<X2>, int a4@<W3>, int a5@<W4>, int a6@<W5>, uint64_t *a7@<X8>)
{
  unsigned int *p_os_unfair_lock_opaque;
  uint64_t v15;
  _BYTE *v16;
  const char *v17;
  uint64_t result;
  uint64_t v19;
  char v20;
  _BYTE v21[23];
  uint64_t v22;
  char v23;
  _BYTE v24[23];

  re::stringToLowerCase(*a3, (re::DynamicString *)&v22);
  p_os_unfair_lock_opaque = &a1[272]._os_unfair_lock_opaque;
  do
    v15 = __ldaxr(p_os_unfair_lock_opaque);
  while (__stlxr(v15 + 1, p_os_unfair_lock_opaque));
  if ((v23 & 1) != 0)
    v16 = *(_BYTE **)&v24[7];
  else
    v16 = v24;
  re::DynamicString::format((re::DynamicString *)"asset%d.compiled%s", (re::DynamicString *)&v19, v15, v16);
  if ((v20 & 1) != 0)
    v17 = *(const char **)&v21[7];
  else
    v17 = v21;
  re::AssetManager::newAssetEntryForNamedMemoryAsset(a1, a2, a3, v17, a4, a5, a6, a7);
  if (v19 && (v20 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v19 + 40))();
  result = v22;
  if (v22)
  {
    if ((v23 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v22 + 40))();
  }
  return result;
}

uint64_t re::AssetManager::generateRootAssetPathForImportedAsset@<X0>(re::AssetManager *this@<X0>, re **a2@<X1>, const char *a3@<X2>, _QWORD *a4@<X8>)
{
  _anonymous_namespace_ *v8;
  unsigned int *v9;
  uint64_t v10;
  _BYTE *v11;
  _BYTE *v12;
  _anonymous_namespace_ *v13;
  const char *v14;
  _anonymous_namespace_ *v15;
  uint64_t result;
  uint64_t v17;
  char v18;
  _BYTE v19[23];
  uint64_t v20;
  char v21;
  _BYTE v22[23];
  uint64_t v23;
  char v24;
  _BYTE v25[23];

  v8 = (_anonymous_namespace_ *)re::stringToLowerCase(*a2, (re::DynamicString *)&v23);
  if (a3)
  {
    if (*a3)
    {
      re::DynamicString::format((re::DynamicString *)"%s/", (re::DynamicString *)&v17, a3);
      re::DynamicString::operator=((re::DynamicString *)&v20, (re::DynamicString *)&v17);
      if (v17)
      {
        if ((v18 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v17 + 40))();
      }
    }
  }
  v9 = (unsigned int *)((char *)this + 1088);
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 + 1, v9));
  if ((v21 & 1) != 0)
    v11 = *(_BYTE **)&v22[7];
  else
    v11 = v22;
  if ((v24 & 1) != 0)
    v12 = *(_BYTE **)&v25[7];
  else
    v12 = v25;
  v13 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"imported%s%d/%sroot.compiled%s", (re::DynamicString *)&v17, *a2, v10, v11, v12);
  if ((v18 & 1) != 0)
    v14 = *(const char **)&v19[7];
  else
    v14 = v19;
  *(_DWORD *)a4 = 0;
  a4[3] = 0;
  a4[4] = 0;
  a4[2] = 0;
  v15 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(a4 + 1, 0);
  a4[6] = 0;
  a4[7] = 0;
  a4[8] = 0;
  re::DynamicString::setCapacity(a4 + 5, 0);
  a4[9] = 0;
  re::AssetPath::initMemoryAssetPath(a4, v14, (uint64_t)a2);
  if (v17 && (v18 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v17 + 40))();
  if (v20 && (v21 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v20 + 40))();
  result = v23;
  if (v23)
  {
    if ((v24 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v23 + 40))();
  }
  return result;
}

void re::NetworkAssetSerialization::~NetworkAssetSerialization(re::NetworkAssetSerialization *this)
{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)this = off_24ED2D398;
  v3 = (_OWORD *)((char *)this + 104);
  v2 = *((_QWORD *)this + 13);
  if (v2)
  {
    if ((*((_BYTE *)this + 112) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 15));
    *v3 = 0u;
    v3[1] = 0u;
  }
  *(_QWORD *)this = &off_24ED2D3D0;
  re::Optional<re::AssetPath>::~Optional((uint64_t)this + 8);
}

{
  uint64_t v2;
  _OWORD *v3;

  *(_QWORD *)this = off_24ED2D398;
  v3 = (_OWORD *)((char *)this + 104);
  v2 = *((_QWORD *)this + 13);
  if (v2)
  {
    if ((*((_BYTE *)this + 112) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 15));
    *v3 = 0u;
    v3[1] = 0u;
  }
  *(_QWORD *)this = &off_24ED2D3D0;
  re::Optional<re::AssetPath>::~Optional((uint64_t)this + 8);
  JUMPOUT(0x2276933B8);
}

void re::AssetManager::processLoadedAsset_entryStateLocked(os_unfair_lock_s *this, re::internal::AssetEntry *a2, void *a3)
{
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  _anonymous_namespace_ *v9[3];

  if (re::AssetManager::checkAssetTrust_entryStateLocked((re::AssetManager *)this, a2, a3, 1))
  {
    re::AssetManager::processAssetPointer((re::AssetManager *)this, a3, a2);
    re::internal::SharedAssetPointer::makeSharedAssetPointer((re::internal::SharedAssetPointer *)a3, v9);
    if (*((_QWORD *)a2 + 14) == -1)
      v6 = 0;
    else
      v6 = *((_QWORD *)a2 + 14);
    re::internal::AssetEntry::LoadState::setLoadingAssetPointer_locked((__uint64_t)a2 + 704, (uint64_t *)v9, v6);
    if (v9[0])

    re::AssetManager::entryReadyForRegistration_entryStateLocked(this, a2, v7, v8);
    re::AssetHandle::AssetHandle((re::AssetHandle *)v9, a2);
    os_unfair_lock_lock(this + 16);
    re::internal::AssetIdLoadDescriptorTable::markDependenciesDirty((re::internal::AssetIdLoadDescriptorTable *)&this[30], (const re::AssetHandle *)v9);
    os_unfair_lock_unlock(this + 16);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v9);
  }
}

void re::AssetManager::unloadAssetPointer(re::AssetManager *this, const re::AssetType *a2, void *a3, const char *a4, uint64_t a5)
{
  uint64_t *v10;
  _QWORD *v11;
  uint64_t v12;
  re::internal::AssetLoadItem *v13;
  _QWORD *v14;

  v10 = re::globalAllocators(this);
  v11 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10[2] + 32))(v10[2], 56, 8);
  *(_OWORD *)v11 = 0u;
  *((_OWORD *)v11 + 1) = 0u;
  *((_OWORD *)v11 + 2) = 0u;
  v11[6] = 0;
  re::CancellationTokenSource::CancellationTokenSource((re::CancellationTokenSource *)(v11 + 3));
  v14 = v11;
  *v11 = a5;
  os_unfair_lock_lock((os_unfair_lock_t)this + 336);
  re::DynamicArray<re::RigDataValue *>::add((re::AssetManager *)((char *)this + 1352), &v14);
  *((_DWORD *)v11 + 4) = 2;
  re::internal::AssetBackgroundLoader::unloadAssetAsync(*((re::internal::AssetBackgroundLoader **)this + 137), v11, a2, a3, a4, &v13);
  v12 = v11[1];
  v11[1] = v13;
  if (v12)

  os_unfair_lock_unlock((os_unfair_lock_t)this + 336);
}

void re::AssetManager::onUnloadComplete(os_unfair_lock_s *this, uint64_t a2)
{
  os_unfair_lock_s *v3;
  uint64_t v4;

  v3 = this + 256;
  v4 = a2;
  os_unfair_lock_lock(this + 256);
  re::DynamicArray<re::TransitionCondition *>::add(&this[258]._os_unfair_lock_opaque, &v4);
  os_unfair_lock_unlock(v3);
}

uint64_t re::DynamicArray<re::Function<void ()(re::DynamicArray<unsigned long long>)>>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t result;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::Function<void ()(re::DynamicArray<unsigned long long>)>>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 40 * v4;
  *(_QWORD *)(v5 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(v5 + 32) = 0;
  result = re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>(v5, a2);
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void re::AssetManager::setMetadataIntoAssetEntry(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 v6;
  _BYTE v7[8];
  uint64_t v8[3];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v6 = atomic_load((unsigned __int8 *)(a1 + 1409));
  if ((v6 & 1) == 0 && !*(_BYTE *)(a1 + 1410))
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 584));
  v9 = 0;
  v10 = 0;
  v11 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  re::AssetManager::lookupExistingAsset_assetTablesLocked((re::internal::AssetTypeRegistry **)a1, a2, v7);
  if (v7[0])
  {
    re::AssetHandle::operator=(&v9, v8);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v8);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 64));
  if (v10)
    re::internal::AssetEntry::setMetadata(v10, a3);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v9);
}

void re::AssetManager::addResourceSharingClientPeerID(os_unfair_lock_s *this, uint64_t a2)
{
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  uint64_t v5;
  _BYTE v6[16];

  v3 = this + 416;
  v5 = a2;
  os_unfair_lock_lock(this + 416);
  v4 = this + 418;
  re::DynamicOverflowArray<unsigned long long,1ul>::indexOf((uint64_t)v4, &v5, (uint64_t)v6);
  if (!v6[0])
    re::DynamicOverflowArray<unsigned long long,1ul>::add((uint64_t)v4, &v5);
  os_unfair_lock_unlock(v3);
}

void re::AssetManager::removeResourceSharingClientPeerID(re::AssetManager *this, uint64_t a2)
{
  os_unfair_lock_s *v3;
  unint64_t v4;
  unint64_t v5;
  char *v6;
  int v7;
  uint64_t v8;
  char v9[8];
  unint64_t v10;
  uint64_t v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  unint64_t v17;
  __int16 v18;
  unint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v3 = (os_unfair_lock_s *)((char *)this + 1664);
  v8 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)this + 416);
  re::DynamicOverflowArray<unsigned long long,1ul>::indexOf((uint64_t)this + 1672, &v8, (uint64_t)v9);
  if (v9[0])
  {
    v4 = v10;
    v5 = *((_QWORD *)this + 210);
    if (v5 <= v10)
    {
      v11 = 0;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v20 = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v12 = 136315906;
      v13 = "removeAt";
      v14 = 1024;
      v15 = 1000;
      v16 = 2048;
      v17 = v4;
      v18 = 2048;
      v19 = v5;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v5 - 1 > v10)
    {
      if ((*((_BYTE *)this + 1688) & 1) != 0)
        v6 = (char *)this + 1696;
      else
        v6 = (char *)*((_QWORD *)this + 213);
      *(_QWORD *)&v6[8 * v10] = *(_QWORD *)&v6[8 * v5 - 8];
    }
    v7 = *((_DWORD *)this + 422);
    *((_QWORD *)this + 210) = v5 - 1;
    *((_DWORD *)this + 422) = v7 + 2;
  }
  os_unfair_lock_unlock(v3);
  atomic_store(1u, (unsigned __int8 *)this + 704);
}

void re::AssetManager::getAssetsReceivedFromPeer(re::AssetManager *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  os_unfair_lock_s *v7;
  uint64_t v8;
  char *v9;
  unint64_t v10;
  re::internal::AssetEntry **v11;
  NSObject *v12;
  uint64_t v13[3];
  uint8_t buf[4];
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v6 = *((_QWORD *)this + 141);
  if (v6)
  {
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    *(_DWORD *)(a3 + 24) = 0;
    (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v6 + 48))(buf, v6, a2);
    if (v16)
      re::DynamicArray<re::AssetHandle>::setCapacity((_QWORD *)a3, v16);
    v7 = (os_unfair_lock_s *)((char *)this + 64);
    os_unfair_lock_lock((os_unfair_lock_t)this + 16);
    if (v16)
    {
      v8 = v17;
      v9 = (char *)this + 72;
      v10 = 32 * v16;
      do
      {
        v11 = (re::internal::AssetEntry **)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)v9, v8);
        if (v11)
        {
          re::AssetHandle::AssetHandle(v13, *v11);
          re::DynamicArray<re::AssetHandle>::add((_QWORD *)a3, v13);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v13);
        }
        v8 += 32;
        v10 -= 32;
      }
      while (v10);
    }
    os_unfair_lock_unlock(v7);
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)buf);
  }
  else
  {
    v12 = *re::assetsLogObjects(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      v15 = a2;
      _os_log_error_impl(&dword_224FE9000, v12, OS_LOG_TYPE_ERROR, "Cannot get assets received from PeerID %llu, ResourceFetchService not found!", buf, 0xCu);
    }
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    *(_DWORD *)(a3 + 24) = 0;
  }
}

void re::AssetManager::receiveAssetLoadState(re::AssetManager *this, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6)
{
  os_unfair_lock_s *v12;
  unsigned __int8 v13;
  unsigned __int8 v14[4];
  int v15;
  _BYTE v16[8];
  uint64_t v17;
  uint64_t v18;

  v12 = (os_unfair_lock_s *)((char *)this + 64);
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  re::AssetManager::lookupExistingAsset_assetTablesLocked((re::internal::AssetTypeRegistry **)this, a2, v16);
  os_unfair_lock_unlock(v12);
  if (v16[0])
  {
    if (v18)
    {
      if (a6)
      {
        v15 = a6;
        v13 = 1;
      }
      else
      {
        v13 = 0;
      }
      v14[0] = v13;
      re::internal::AssetEntry::setResourceClientLoadState(v18, a3, a4, a5, v14);
      atomic_store(1u, (unsigned __int8 *)this + 704);
    }
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v17);
  }
}

uint64_t re::AssetManager::getCombinedLoadState(uint64_t a1, re::AssetHandle *this, int a3, unsigned int a4, uint64_t a5)
{
  BOOL v7;
  uint64_t result;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  os_unfair_lock_s *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  uint64_t v25;

  if (*(_QWORD *)(a5 + 8))
    v7 = *(_QWORD *)(a1 + 1208) == 0;
  else
    v7 = 1;
  if (!v7 && (unint64_t)(*((_QWORD *)re::AssetHandle::assetInfo(this) + 10) + 1) >= 2 && a3 != 0)
  {
    v17 = (os_unfair_lock_s *)(*((_QWORD *)this + 1) + 384);
    os_unfair_lock_lock(v17);
    v18 = *((_QWORD *)this + 1);
    if (*(_DWORD *)(v18 + 420) != 2)
    {
      v19 = *(_QWORD *)(a5 + 8);
      if (v19)
      {
        v12 = 0;
        v13 = 0;
        v14 = 0;
        v15 = 0;
        v16 = 0;
        v20 = *(_QWORD **)a5;
        v21 = *(_QWORD *)a5 + 8 * v19;
        v22 = *(_QWORD *)(v18 + 528);
        do
        {
          v23 = v18 + 544;
          if ((*(_DWORD *)(v18 + 536) & 1) == 0)
            v23 = *(_QWORD *)(v18 + 552);
          if (v22)
          {
            v24 = (_DWORD *)(v23 + 8);
            v25 = 32 * v22;
            while (*((_QWORD *)v24 - 1) != *v20)
            {
              v24 += 8;
              v25 -= 32;
              if (!v25)
                goto LABEL_35;
            }
            switch(*v24)
            {
              case 0:
                v16 = 1;
                break;
              case 1:
                v12 = 1;
                break;
              case 2:
                ++v13;
                break;
              case 3:
                v14 = 1;
                break;
              default:
                break;
            }
          }
          else
          {
LABEL_35:
            v15 = 1;
          }
          ++v20;
        }
        while (v20 != (_QWORD *)v21);
      }
      else
      {
        v16 = 0;
        v15 = 0;
        v14 = 0;
        v13 = 0;
        v12 = 0;
      }
      os_unfair_lock_unlock(v17);
      goto LABEL_13;
    }
    os_unfair_lock_unlock(v17);
  }
  if (a4 < 4)
    return dword_2260F5A90[a4];
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
LABEL_13:
  result = 2;
  switch(a4)
  {
    case 0u:
      v16 = 1;
      if (v14)
        goto LABEL_18;
      goto LABEL_20;
    case 1u:
      v12 = 1;
      goto LABEL_17;
    case 2u:
      ++v13;
      if (!v14)
        goto LABEL_20;
      goto LABEL_18;
    case 3u:
      return result;
    default:
LABEL_17:
      if (v14)
      {
LABEL_18:
        result = 2;
      }
      else
      {
LABEL_20:
        result = 0;
        if (!v15 && !v16 && !v12)
          result = *(_QWORD *)(a5 + 8) + 1 == v13;
      }
      break;
  }
  return result;
}

uint64_t re::AssetManager::getNetworkAssetService(re::AssetManager *this)
{
  return *((_QWORD *)this + 151);
}

void re::AssetManager::ownerPeerID(os_unfair_lock_s *this@<X1>, uint64_t a2@<X0>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char v12[8];
  unint64_t v13;

  atomic_load((unsigned __int8 *)(a2 + 1409));
  re::internal::AssetEntry::ownerPeerID((uint64_t)this, (uint64_t)v12);
  if (v12[0])
  {
LABEL_2:
    *(_BYTE *)a4 = 1;
    *(_QWORD *)(a4 + 8) = v13;
    return;
  }
  if (this[30]._os_unfair_lock_opaque == 8)
  {
    v8 = *(_QWORD *)(a2 + 1208);
    if (v8)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v8 + 120))(&v10);
      if ((_BYTE)v10)
      {
        v9 = v11;
        v13 = v11;
        if (a3)
          os_unfair_lock_lock(this + 96);
        re::internal::AssetEntry::ownerPeerID((uint64_t)this, (uint64_t)&v10);
        if (!(_BYTE)v10 || v11 != v9)
          re::internal::AssetEntry::setOwnerPeerID((re::internal::AssetEntry *)this, v9);
        if (a3)
          os_unfair_lock_unlock(this + 96);
        goto LABEL_2;
      }
    }
  }
  *(_BYTE *)a4 = 0;
}

BOOL re::AssetManager::checkAssetTrust_entryStateLocked(re::AssetManager *this, re::internal::AssetEntry *a2, uint64_t a3, void *a4, int a5)
{
  uint64_t v10;
  re *v11;
  re *v12;
  uint64_t v13;
  re *v14;
  int v15;
  NSObject *v16;
  const char *v17;
  NSObject *v18;
  NSObject *v19;
  const char *v20;
  NSObject *v21;
  re *v22;
  re *v23;
  NSObject *v24;
  _BOOL8 result;
  NSObject *v26;
  _OWORD v27[2];
  _BYTE v28[2];
  uint8_t v29[4];
  re *v30;
  uint8_t buf[4];
  _BYTE v32[12];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v10 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*((_QWORD *)this + 138), *((_QWORD *)a2 + 33));
  re::AssetManager::ownerPeerID((os_unfair_lock_s *)a2, (uint64_t)this, 0, (uint64_t)buf);
  if (!buf[0])
    goto LABEL_18;
  v12 = *(re **)&v32[4];
  v11 = (re *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 151) + 104))(*((_QWORD *)this + 151));
  if (v12 == v11)
    goto LABEL_18;
  v13 = atomic_load((unsigned int *)a2 + 172);
  v14 = (re *)(*(_QWORD *(**)(_BYTE *__return_ptr, uint64_t, void *, char *, re *, uint64_t))(*(_QWORD *)v10 + 264))(v28, v10, a4, (char *)a2 + 32, v12, v13);
  if (v28[0])
  {
    v15 = v28[1];
    v16 = *re::assetsLogObjects(v14);
    if (v15)
    {
      v11 = (re *)os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)v11)
      {
        *(_DWORD *)v29 = 134217984;
        v30 = v12;
        v17 = "Asset Entitlement success. Registration completed for asset owned by %llu.";
        v18 = v16;
LABEL_25:
        _os_log_debug_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEBUG, v17, v29, 0xCu);
        goto LABEL_18;
      }
      goto LABEL_18;
    }
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      goto LABEL_11;
    *(_DWORD *)v29 = 134217984;
    v30 = v12;
    v20 = "Asset Entitlement fail. Asset owned by %llu will not be registered due to not being trustworthy.";
    v21 = v16;
LABEL_23:
    _os_log_error_impl(&dword_224FE9000, v21, OS_LOG_TYPE_ERROR, v20, v29, 0xCu);
    goto LABEL_11;
  }
  v19 = *re::assetsLogObjects(v14);
  if (!a5)
  {
    v11 = (re *)os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)v11)
    {
      *(_DWORD *)v29 = 134217984;
      v30 = v12;
      v17 = "Asset Entitlement indeterminate. Asset owned by %llu will be allowed to load and will be checked again.";
      v18 = v19;
      goto LABEL_25;
    }
LABEL_18:
    v26 = *re::assetsLogObjects(v11);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)v32 = a3;
      _os_log_debug_impl(&dword_224FE9000, v26, OS_LOG_TYPE_DEBUG, "checkAssetTrust - Asset entitlement check succeeded. Asset owned by %llu is trustworthy", buf, 0xCu);
    }
    return 1;
  }
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)v29 = 134217984;
    v30 = v12;
    v20 = "Asset Entitlement fail. Asset owned by %llu will not be registered due to no result from credential check.";
    v21 = v19;
    goto LABEL_23;
  }
LABEL_11:
  v22 = (re *)re::DynamicString::format((re::DynamicString *)"Asset originating from (ownerPeer:%llu), does not have the appropriateentitlements.", (re::DynamicString *)v27, a3);
  re::AssetManager::putEntryInFailedState_entryStateLocked(v22, (uint64_t)a2, 302, (uint64_t)v27);
  v23 = *(re **)&v27[0];
  if (*(_QWORD *)&v27[0])
  {
    if ((BYTE8(v27[0]) & 1) != 0)
      v23 = (re *)(*(uint64_t (**)(void))(**(_QWORD **)&v27[0] + 40))();
    memset(v27, 0, sizeof(v27));
  }
  v24 = *re::assetsLogObjects(v23);
  result = os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)v32 = a3;
    _os_log_error_impl(&dword_224FE9000, v24, OS_LOG_TYPE_ERROR, "checkAssetTrust - Asset entitlement check FAIL. Asset owned by %llu is not trustworthy", buf, 0xCu);
    return 0;
  }
  return result;
}

uint64_t re::AssetManager::isAssetEntryShareableAndFetchable_entryStateLocked(re::AssetManager *this, re::internal::AssetEntry *a2)
{
  BOOL v2;
  int v4;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v11;
  char v12;
  _BYTE v13[23];
  _BYTE v14[8];
  uint64_t v15;

  if (*((_QWORD *)this + 141))
    v2 = *((_DWORD *)a2 + 105) == 2;
  else
    v2 = 1;
  if (v2)
    return 0;
  v4 = *((_DWORD *)a2 + 30);
  if (v4 != 8 && v4 != 4)
    return 0;
  v7 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*((_QWORD *)this + 138), *((_QWORD *)a2 + 33));
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v7 + 192))(v7))
    return 0;
  re::AssetManager::fromPeerID((uint64_t)v14, (uint64_t)this, (os_unfair_lock_s *)a2, 0);
  if (!v14[0] || !v15)
    return 0;
  re::DynamicString::format((re::DynamicString *)"%llu", (re::DynamicString *)&v11, v15);
  if ((v12 & 1) != 0)
    v8 = *(_BYTE **)&v13[7];
  else
    v8 = v13;
  v9 = (*(uint64_t (**)(_QWORD, _BYTE *))(**((_QWORD **)this + 141) + 32))(*((_QWORD *)this + 141), v8);
  if (v11 && (v12 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v11 + 40))();
  return v9;
}

void re::AssetManager::fromPeerID(uint64_t a1, uint64_t a2, os_unfair_lock_s *this, int a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char v12[8];
  unint64_t v13;

  atomic_load((unsigned __int8 *)(a2 + 1409));
  re::internal::AssetEntry::fromPeerID((uint64_t)this, (uint64_t)v12);
  if (v12[0])
  {
LABEL_2:
    *(_BYTE *)a1 = 1;
    *(_QWORD *)(a1 + 8) = v13;
    return;
  }
  if (this[30]._os_unfair_lock_opaque == 8)
  {
    v8 = *(_QWORD *)(a2 + 1208);
    if (v8)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(_QWORD *)v8 + 128))(&v10);
      if ((_BYTE)v10)
      {
        v9 = v11;
        v13 = v11;
        if (a4)
          os_unfair_lock_lock(this + 96);
        re::internal::AssetEntry::fromPeerID((uint64_t)this, (uint64_t)&v10);
        if (!(_BYTE)v10 || v11 != v9)
          re::internal::AssetEntry::setFromPeerID((re::internal::AssetEntry *)this, v9);
        if (a4)
          os_unfair_lock_unlock(this + 96);
        goto LABEL_2;
      }
    }
  }
  *(_BYTE *)a1 = 0;
}

uint64_t re::AssetManager::tryReuseExistingAsset_locked(os_unfair_lock_s *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  os_unfair_lock_s *v11;
  uint64_t *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  const re::AssetHandle *v31;
  int v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  _anonymous_namespace_ *v36;
  const char *v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  const char *v42;
  const char *v43;
  const char *v44;
  unsigned int v45;
  re::AssetLoadRequest *v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  os_unfair_lock_s *v54;
  uint64_t *v55;
  uint64_t *v56;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61[5];
  os_unfair_lock_s *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  re::AssetLoadRequest *v66;
  char v67;
  uint64_t v68[3];
  _anonymous_namespace_ *v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  const re::AssetHandle *v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  __int128 v83;
  __int128 v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  const re::AssetHandle *v89;
  _BYTE v90[24];
  _BYTE *v91;
  uint64_t v92;

  v92 = *MEMORY[0x24BDAC8D0];
  v54 = a1 + 16;
  os_unfair_lock_lock(a1 + 16);
  v55 = (uint64_t *)a3;
  v5 = *(_QWORD *)(a3 + 16);
  if (v5)
  {
    v6 = *(uint64_t **)(a3 + 32);
    v7 = 144 * v5;
    while (1)
    {
      re::DynamicString::DynamicString((re::DynamicString *)&v69, (const re::DynamicString *)v6);
      re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v73, v6 + 4);
      re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v78, v6 + 9);
      re::DynamicString::DynamicString((re::DynamicString *)&v83, (const re::DynamicString *)(v6 + 14));
      v8 = (uint64_t *)re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::tryGet((uint64_t)&a1[42], (uint64_t)&v69);
      if (v8)
      {
        v9 = *v8;
        v10 = *(_QWORD *)(a2 + 112);
        if (v10 == -1)
          v10 = 0;
        if (v9 != v10)
          break;
      }
      if ((_QWORD)v83)
      {
        if ((BYTE8(v83) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v83 + 40))();
        v83 = 0u;
        v84 = 0u;
      }
      if (v78)
      {
        if (v82)
          (*(void (**)(void))(*(_QWORD *)v78 + 40))();
        v82 = 0;
        v79 = 0;
        v80 = 0;
        v78 = 0;
        ++v81;
      }
      if (v73)
      {
        if (v77)
          (*(void (**)(void))(*(_QWORD *)v73 + 40))();
        v77 = 0;
        v74 = 0;
        v75 = 0;
        v73 = 0;
        ++v76;
      }
      if (v69 && (v70 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v69 + 40))();
      v6 += 18;
      v7 -= 144;
      if (!v7)
        goto LABEL_23;
    }
    if ((_QWORD)v83)
    {
      if ((BYTE8(v83) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v83 + 40))();
      v83 = 0u;
      v84 = 0u;
    }
    if (v78)
    {
      if (v82)
        (*(void (**)(void))(*(_QWORD *)v78 + 40))();
      v82 = 0;
      v79 = 0;
      v80 = 0;
      v78 = 0;
      ++v81;
    }
    v12 = v55;
    if (v73)
    {
      if (v77)
        (*(void (**)(void))(*(_QWORD *)v73 + 40))();
      v77 = 0;
      v74 = 0;
      v75 = 0;
      v73 = 0;
      ++v76;
    }
    v36 = v69;
    if (v69 && (v70 & 1) != 0)
      v36 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v69 + 40))();
    v37 = **(const char ***)(a2 + 264);
    re::AssetManager::assetHandleFromId_assetTablesLocked((re::AssetManager *)a1, (const re::DynamicString *)&v69, v9, &v63);
    v11 = v54;
    if (v69 && (v70 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v69 + 40))();
  }
  else
  {
LABEL_23:
    v63 = 0;
    v64 = 0;
    v65 = 0;
    v11 = v54;
    v12 = v55;
  }
  os_unfair_lock_unlock(v11);
  if (v64)
  {
    v13 = atomic_load((unsigned int *)(v64 + 704));
    if (v13 == 2)
      goto LABEL_99;
  }
  os_unfair_lock_lock(v11);
  v89 = 0;
  v86 = 0;
  v87 = 0;
  v85 = 0;
  v88 = 0;
  v14 = v12[2];
  if (v14)
  {
    v15 = (uint64_t *)v12[4];
    v56 = &v15[18 * v14];
    do
    {
      re::DynamicString::DynamicString((re::DynamicString *)&v69, (const re::DynamicString *)v15);
      re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v73, v15 + 4);
      re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v78, v15 + 9);
      re::DynamicString::DynamicString((re::DynamicString *)&v83, (const re::DynamicString *)(v15 + 14));
      v16 = re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::tryGet((uint64_t)&a1[54], (uint64_t)&v69);
      if (v16)
      {
        v17 = v16;
        v18 = *(unsigned int *)(v16 + 32);
        if ((_DWORD)v18)
        {
          v19 = 0;
          v20 = (int *)(*(_QWORD *)(v16 + 16) + 8);
          while (1)
          {
            v21 = *v20;
            v20 += 6;
            if (v21 < 0)
              break;
            if (v18 == ++v19)
            {
              LODWORD(v19) = *(_DWORD *)(v16 + 32);
              break;
            }
          }
        }
        else
        {
          LODWORD(v19) = 0;
        }
        if ((_DWORD)v18 != (_DWORD)v19)
        {
          v22 = v19;
          v23 = *(_DWORD *)(v16 + 32);
          do
          {
            v24 = *(_QWORD *)(*(_QWORD *)(v17 + 16) + 24 * v22 + 16);
            v25 = *(_QWORD *)(a2 + 112);
            if (v25 == -1)
              v25 = 0;
            if (v24 != v25)
            {
              v26 = **(const char ***)(a2 + 264);
              re::AssetManager::assetHandleFromId_assetTablesLocked((re::AssetManager *)a1, (const re::DynamicString *)&v66, v24, v68);
              if (v66 && (v67 & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v66 + 40))();
              re::DynamicArray<re::AssetHandle>::add((_anonymous_namespace_ *)&v85, (re::AssetHandle *)v68);
              re::AssetHandle::~AssetHandle((re::AssetHandle *)v68);
              v23 = *(_DWORD *)(v17 + 32);
            }
            if (v23 <= (int)v19 + 1)
              v27 = v19 + 1;
            else
              v27 = v23;
            while (1)
            {
              v22 = (v19 + 1);
              if (v27 - 1 == (_DWORD)v19)
                break;
              LODWORD(v19) = v19 + 1;
              v28 = v22;
              if ((*(_DWORD *)(*(_QWORD *)(v17 + 16) + 24 * v22 + 8) & 0x80000000) != 0)
                goto LABEL_51;
            }
            v28 = v27;
LABEL_51:
            LODWORD(v19) = v28;
          }
          while ((_DWORD)v18 != v28);
        }
      }
      if ((_QWORD)v83)
      {
        if ((BYTE8(v83) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v83 + 40))();
        v83 = 0u;
        v84 = 0u;
      }
      if (v78)
      {
        if (v82)
          (*(void (**)(void))(*(_QWORD *)v78 + 40))();
        v82 = 0;
        v79 = 0;
        v80 = 0;
        v78 = 0;
        ++v81;
      }
      if (v73)
      {
        if (v77)
          (*(void (**)(void))(*(_QWORD *)v73 + 40))();
        v77 = 0;
        v74 = 0;
        v75 = 0;
        v73 = 0;
        ++v76;
      }
      if (v69 && (v70 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v69 + 40))();
      v15 += 18;
    }
    while (v15 != v56);
    v29 = v85;
    v14 = v86;
    v30 = v87;
    v31 = v89;
    v32 = v88 + 1;
    v11 = v54;
    v12 = v55;
  }
  else
  {
    v31 = 0;
    v30 = 0;
    v29 = 0;
    v32 = 1;
  }
  v69 = (_anonymous_namespace_ *)v29;
  v70 = v14;
  v71 = v30;
  v86 = 0;
  v87 = 0;
  v85 = 0;
  v73 = v31;
  v89 = 0;
  v88 = v32;
  v72 = 1;
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v85);
  os_unfair_lock_unlock(v11);
  if (!v30)
    goto LABEL_98;
  v33 = 24 * v30;
  while (1)
  {
    re::AssetHandle::AssetHandle((re::AssetHandle *)&v85, v31);
    if (v86)
      break;
LABEL_78:
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v85);
    v31 = (const re::AssetHandle *)((char *)v31 + 24);
    v33 -= 24;
    if (!v33)
      goto LABEL_98;
  }
  v34 = atomic_load((unsigned int *)(v86 + 704));
  if (v34 != 2 || *(_BYTE *)(v86 + 256))
  {
    v35 = atomic_load((unsigned int *)(v86 + 704));
    if (v35 == 1)
      re::AssetHandle::operator=(&v63, &v85);
    goto LABEL_78;
  }
  re::AssetHandle::operator=(&v63, &v85);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v85);
LABEL_98:
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v69);
LABEL_99:
  if (v64 && (v38 = atomic_load((unsigned int *)(v64 + 704)), v38 == 2))
  {
    re::AssetManager::findDependencies((re::AssetManager *)a1, (const re::AssetHandle *)&v63, (uint64_t)&v69);
  }
  else
  {
    v73 = 0;
    v70 = 0;
    v71 = 0;
    v69 = 0;
    v72 = 0;
  }
  if (!v64)
    goto LABEL_115;
  v39 = atomic_load((unsigned int *)(v64 + 704));
  if (v39 == 2)
  {
    if (!v71
      || ((v40 = v12[4],
           v41 = *(_QWORD *)(v40 + 8),
           v42 = *(const char **)(v40 + 16),
           v43 = (const char *)(v40 + 9),
           (v41 & 1) != 0)
        ? (v44 = v42)
        : (v44 = v43),
          !strcmp(v44, "AssetPath")))
    {
      re::internal::AssetEntry::LoadState::setAssetPointer_locked(a2 + 704, (uint64_t *)(v64 + 712));
      re::internal::AssetEntry::setIsLoading_locked((re::internal::AssetEntry *)a2, 0);
      goto LABEL_121;
    }
  }
  if (v64 && (v45 = atomic_load((unsigned int *)(v64 + 704)), v45 == 1))
  {
    re::AssetManager::makeLoadRequest((re::AssetManager *)a1, &v66);
    v46 = v66;
    re::AssetLoadRequest::addAsset((re::AssetLoadRequest::Data **)v66, (const re::AssetHandle *)&v63);
    re::AssetHandle::AssetHandle((re::AssetHandle *)&v85, (re::internal::AssetEntry *)a2);
    re::AssetHandle::AssetHandle((re::AssetHandle *)&v58, (const re::AssetHandle *)&v85);
    re::AssetHandle::AssetHandle((re::AssetHandle *)((char *)&v59 + 8), (const re::AssetHandle *)&v63);
    re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray((uint64_t)v61, v12);
    v62 = a1;
    v47 = (char *)operator new(0x68uLL);
    v48 = *((_QWORD *)&v58 + 1);
    *((_QWORD *)v47 + 1) = v58;
    *((_QWORD *)v47 + 2) = v48;
    *(_QWORD *)v47 = &off_24ED2C950;
    *(_OWORD *)(v47 + 24) = v59;
    v58 = 0u;
    v59 = 0u;
    v49 = *((_QWORD *)&v60 + 1);
    *((_QWORD *)v47 + 5) = v60;
    *((_QWORD *)v47 + 6) = v49;
    v60 = 0u;
    re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray((uint64_t)(v47 + 56), v61);
    *((_QWORD *)v47 + 12) = v62;
    v91 = v47;
    re::AssetLoadRequest::setCompletionHandler((uint64_t)v46, (uint64_t)v90, 0);
    v50 = v91;
    if (v91 == v90)
    {
      v51 = 4;
      v50 = v90;
LABEL_118:
      (*(void (**)(void))(*v50 + 8 * v51))();
    }
    else if (v91)
    {
      v51 = 5;
      goto LABEL_118;
    }
    re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)v61);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)((char *)&v59 + 8));
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v58);
    re::DynamicArray<re::SharedPtr<re::AssetLoadRequest>>::add((_anonymous_namespace_ *)&a1[6], (uint64_t *)&v66);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v85);
    if (v46)

LABEL_121:
    v52 = 1;
  }
  else
  {
LABEL_115:
    v52 = 0;
  }
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v69);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v63);
  return v52;
}

uint64_t re::DynamicArray<re::AssetLoadDescriptor>::slice(unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  __int128 v5;

  if (a1 + 1 <= 1)
  {
    v4 = 0;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v5) = 136315906;
    *(_QWORD *)((char *)&v5 + 4) = "slice";
    WORD6(v5) = 1024;
    HIWORD(v5) = 1119;
    _os_log_send_and_compose_impl();
    a1 = _os_crash_msg();
    __break(1u);
    goto LABEL_6;
  }
  if (a3 == -1)
  {
LABEL_6:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::slice(size_t,size_t). index, %zu, count = %zu, array size = %zu", "!overflow", "slice", 1125, 1, a3, a1, v4, v5);
    a1 = _os_crash();
    __break(1u);
LABEL_7:
    re::internal::assertLog((re::internal *)7, a2, "assertion failure: '%s' (%s:line %i) Invalid count. index = %zu, count = %zu, array size = %zu", "endIndexExclusive <= m_size", "slice", 1129, 1, a3, a1);
    _os_crash();
    __break(1u);
  }
  if (a3 + 1 > a1)
    goto LABEL_7;
  return a2 + 144;
}

_anonymous_namespace_ *re::DynamicArray<re::AssetLoadDescriptor>::operator=(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;

  v4 = *(_QWORD *)(a2 + 8);
  if (*(_QWORD *)this)
  {
    if (v4)
    {
      re::DynamicArray<re::AssetLoadDescriptor>::copy(this, *(re::DynamicString **)a2, v4);
      re::DynamicArray<re::AssetLoadDescriptor>::resize(this, *(_QWORD *)(a2 + 8));
    }
    else
    {
      re::DynamicArray<re::AssetLoadDescriptor>::clear(this);
    }
  }
  else if (v4)
  {
    re::DynamicArray<re::AssetLoadDescriptor>::setCapacity(this, v4);
    ++*((_DWORD *)this + 6);
    re::DynamicArray<re::AssetLoadDescriptor>::copy(this, *(re::DynamicString **)a2, *(_QWORD *)(a2 + 8));
  }
  return this;
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<re::PeerAssetLoadDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2, re::Allocator *a3)
{
  uint64_t **v4;
  unsigned __int8 v5;
  __guard *v6;
  int v8;
  int v9;
  re::Allocator *v11;
  re::AssetLoadDescriptor *v12;

  v4 = a2;
  if ((v5 & 1) == 0)
  {
    v12 = a1;
    v11 = a3;
    v4 = a2;
    a3 = v11;
    v9 = v8;
    a1 = v12;
    if (v9)
    {
      re::introspect<re::PeerAssetLoadDescriptorParameters>(void)::info = re::introspect_PeerAssetLoadDescriptorParameters(0);
      a1 = v12;
      v4 = a2;
      a3 = v11;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)v6[52], v4, a3);
}

void re::AssetManager::reuseExistingOrLoadNewAsset_locked(os_unfair_lock_s *a1, _QWORD *a2, uint64_t *a3)
{
  if ((re::AssetManager::tryReuseExistingAsset_locked(a1, (uint64_t)a2, (uint64_t)a3) & 1) == 0)
    re::AssetManager::loadAssetFromDescriptorsOnBackgroundTask_entryStateLocked((uint64_t)a1, a2, a3);
}

uint64_t re::AssetManager::assetNonSharedDataByteSize_entryStateLocked(re::AssetManager *this, re::internal::AssetEntry *a2)
{
  unsigned int v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;

  v2 = atomic_load((unsigned int *)a2 + 176);
  if (v2 != 2)
    return 0;
  v4 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*((_QWORD *)this + 138), *((_QWORD *)a2 + 33));
  if (!*((_BYTE *)a2 + 352))
  {
    v5 = re::internal::AssetEntry::assetPointer(a2);
    v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 40))(v4, v5);
    if (!*((_BYTE *)a2 + 352))
      *((_BYTE *)a2 + 352) = 1;
    *((_QWORD *)a2 + 45) = v6;
  }
  if (*((_BYTE *)a2 + 336))
  {
    v7 = *((_QWORD *)a2 + 43);
  }
  else
  {
    v9 = re::internal::AssetEntry::assetPointer(a2);
    v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 48))(v4, v9);
    if (!*((_BYTE *)a2 + 336))
      *((_BYTE *)a2 + 336) = 1;
    *((_QWORD *)a2 + 43) = v7;
  }
  return *((_QWORD *)a2 + 45) + v7;
}

void re::AssetManager::internalUnloadSharedAssetPointer(re::AssetManager *this, void *a2, const re::ExistingAssetInformation *a3, const re::AssetType *a4)
{
  uint64_t v8;
  const char *v9;
  uint64_t v10;

  v8 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*((_QWORD *)this + 138), (unint64_t)a4);
  (*(void (**)(uint64_t, void *, const re::ExistingAssetInformation *))(*(_QWORD *)v8 + 88))(v8, a2, a3);
  if ((*((_QWORD *)a3 + 17) & 1) != 0)
    v9 = (const char *)*((_QWORD *)a3 + 18);
  else
    v9 = (char *)a3 + 137;
  if (*((_QWORD *)a3 + 10) == -1)
    v10 = 0;
  else
    v10 = *((_QWORD *)a3 + 10);
  re::AssetManager::unloadAssetPointer(this, a4, a2, v9, v10);
}

void re::AssetManager::internalAssetEntryUnloadAssetPointer_entryStateLocked(re::AssetManager *this, re::internal::AssetEntry *a2)
{
  uint64_t v4;
  unsigned __int8 v5;
  uint64_t v6;
  uint64_t v7;
  re *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  int v16;
  _QWORD v17[4];
  _QWORD v18[4];
  uint64_t v19;
  uint64_t v20;
  int v21;
  _QWORD v22[4];
  _QWORD v23[4];
  _QWORD v24[4];
  _QWORD v25[4];
  uint64_t v26;

  if (!re::internal::AssetEntry::hasAssetPointer(a2))
  {
LABEL_36:
    re::internal::AssetEntry::LoadState::resetAssetPointer_locked((re::internal::AssetEntry *)((char *)a2 + 704));
    return;
  }
  atomic_load((unsigned __int8 *)this + 1409);
  if (objc_isUniquelyReferenced())
  {
    v4 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*((_QWORD *)this + 138), *((_QWORD *)a2 + 33));
    v5 = atomic_load((unsigned __int8 *)this + 1409);
    if ((v5 & 1) != 0
      || (v6 = v4,
          v7 = re::internal::AssetEntry::assetPointer(a2),
          !(*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 72))(v6, v7)))
    {
      v14 = (void *)re::internal::AssetEntry::assetPointer(a2);
      re::AssetManager::internalUnloadSharedAssetPointer(this, v14, (re::internal::AssetEntry *)((char *)a2 + 32), *((const re::AssetType **)a2 + 33));
    }
    else
    {
      v8 = (re *)re::internal::AssetEntry::assetPointer(a2);
      v15 = *((_QWORD *)a2 + 33);
      v9 = re::globalAllocators(v8);
      v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9[2] + 32))(v9[2], 248, 8);
      v16 = *((_DWORD *)a2 + 8);
      re::DynamicString::DynamicString((re::DynamicString *)v17, (re::internal::AssetEntry *)((char *)a2 + 40));
      re::DynamicString::DynamicString((re::DynamicString *)v18, (re::internal::AssetEntry *)((char *)a2 + 72));
      v11 = *((_QWORD *)a2 + 14);
      v19 = *((_QWORD *)a2 + 13);
      v20 = v11;
      v21 = *((_DWORD *)a2 + 30);
      re::DynamicString::DynamicString((re::DynamicString *)v22, (re::internal::AssetEntry *)((char *)a2 + 128));
      re::DynamicString::DynamicString((re::DynamicString *)v23, (re::internal::AssetEntry *)((char *)a2 + 160));
      re::DynamicString::DynamicString((re::DynamicString *)v24, (re::internal::AssetEntry *)((char *)a2 + 192));
      re::DynamicString::DynamicString((re::DynamicString *)v25, (re::internal::AssetEntry *)((char *)a2 + 224));
      *(_DWORD *)(v10 + 8) = v16;
      re::DynamicString::DynamicString((re::DynamicString *)(v10 + 16), (const re::DynamicString *)v17);
      re::DynamicString::DynamicString((re::DynamicString *)(v10 + 48), (const re::DynamicString *)v18);
      *(_QWORD *)(v10 + 80) = v19;
      v12 = v21;
      *(_QWORD *)(v10 + 88) = v20;
      *(_DWORD *)(v10 + 96) = v12;
      re::DynamicString::DynamicString((re::DynamicString *)(v10 + 104), (const re::DynamicString *)v22);
      re::DynamicString::DynamicString((re::DynamicString *)(v10 + 136), (const re::DynamicString *)v23);
      re::DynamicString::DynamicString((re::DynamicString *)(v10 + 168), (const re::DynamicString *)v24);
      re::DynamicString::DynamicString((re::DynamicString *)(v10 + 200), (const re::DynamicString *)v25);
      if (v25[0])
      {
        if ((v25[1] & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v25[0] + 40))();
        memset(v25, 0, sizeof(v25));
      }
      if (v24[0])
      {
        if ((v24[1] & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v24[0] + 40))();
        memset(v24, 0, sizeof(v24));
      }
      if (v23[0])
      {
        if ((v23[1] & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v23[0] + 40))();
        memset(v23, 0, sizeof(v23));
      }
      if (v22[0])
      {
        if ((v22[1] & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v22[0] + 40))();
        memset(v22, 0, sizeof(v22));
      }
      if (v18[0])
      {
        if ((v18[1] & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v18[0] + 40))();
        memset(v18, 0, sizeof(v18));
      }
      if (v17[0])
      {
        if ((v17[1] & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v17[0] + 40))();
        memset(v17, 0, sizeof(v17));
      }
      v26 = v10;
      *(_QWORD *)v10 = v8;
      *(_QWORD *)(v10 + 232) = v15;
      *(_DWORD *)(v10 + 240) = 0;
      os_unfair_lock_lock((os_unfair_lock_t)this + 128);
      re::DynamicArray<re::RigDataValue *>::add((re::AssetManager *)((char *)this + 520), &v26);
      os_unfair_lock_unlock((os_unfair_lock_t)this + 128);
    }
    re::internal::AssetEntry::LoadState::clearAndResetAssetPointer_locked((re::internal::AssetEntry *)((char *)a2 + 704));
    goto LABEL_36;
  }
  re::internal::AssetEntry::LoadState::resetAssetPointer_locked((re::internal::AssetEntry *)((char *)a2 + 704));
  if (*((_QWORD *)a2 + 14) == -1)
    v13 = 0;
  else
    v13 = *((_QWORD *)a2 + 14);
  re::AssetManager::onUnloadComplete((os_unfair_lock_s *)this, v13);
}

void re::AssetManager::internalAssetEntryUnloadLoadingAssetPointer_entryStateLocked(re::AssetManager *this, re::internal::AssetEntry *a2)
{
  if (re::internal::AssetEntry::hasLoadingAssetPointer(a2))
  {
    atomic_load((unsigned __int8 *)this + 1409);
    if (objc_isUniquelyReferenced())
    {
      re::AssetManager::internalUnloadSharedAssetPointer(this, *(void **)(*((_QWORD *)a2 + 90) + 24), (re::internal::AssetEntry *)((char *)a2 + 32), *((const re::AssetType **)a2 + 33));
      re::internal::AssetEntry::LoadState::clearAndResetLoadingAssetPointer_locked((re::internal::AssetEntry *)((char *)a2 + 704));
    }
  }
  re::internal::AssetEntry::LoadState::resetLoadingAssetPointer_locked((re::internal::AssetEntry *)((char *)a2 + 704));
}

uint64_t re::AssetManager::processAssetRegistration_entryStateLocked(re::AssetManager *this, re::internal::AssetEntry *a2)
{
  uint64_t v4;
  int v5;
  BOOL v6;
  int v7;
  uint64_t result;
  const char *v9;
  const char *v10;
  uint64_t v11;
  _anonymous_namespace_ *v12;
  re *v13;
  re *refreshed;
  std::chrono::system_clock::time_point v15;
  unint64_t v16;
  NSObject *v17;
  char *v18;
  int v19;
  NSObject *v20;
  char *v21;
  const char *v22;
  NSObject *v23;
  uint32_t v24;
  NSObject *v25;
  int v26;
  std::string *v27;
  std::string *v28;
  re *v29;
  NSObject *v30;
  uint64_t v31;
  const char **v32;
  const char *v33;
  char *v34;
  char *v35;
  _QWORD v36[2];
  _OWORD v37[2];
  std::string buf;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  v4 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*((_QWORD *)this + 138), *((_QWORD *)a2 + 33));
  v5 = *((unsigned __int8 *)this + 1458);
  if (*((_BYTE *)this + 1458))
    v6 = *((_BYTE *)a2 + 416) == 0;
  else
    v6 = 0;
  if (v6 && re::internal::enableSignposts(0, 0))
    kdebug_trace();
  if (re::internal::enableSignposts(0, 0) && re::internal::enableHighFrequencyTracing(0, 0))
    kdebug_trace();
  v7 = (*(uint64_t (**)(uint64_t, _QWORD, char *))(*(_QWORD *)v4 + 80))(v4, *(_QWORD *)(*((_QWORD *)a2 + 90) + 24), (char *)a2 + 32);
  result = re::internal::enableSignposts(0, 0);
  if ((_DWORD)result)
  {
    result = re::internal::enableHighFrequencyTracing(0, 0);
    if ((_DWORD)result)
      result = kdebug_trace();
  }
  if (!v7)
  {
    re::AssetManager::internalAssetEntryUnloadAssetPointer_entryStateLocked(this, a2);
    *(int8x16_t *)((char *)a2 + 712) = vextq_s8(*(int8x16_t *)((char *)a2 + 712), *(int8x16_t *)((char *)a2 + 712), 8uLL);
    refreshed = (re *)re::internal::AssetEntry::LoadState::refreshLoadState_locked((__uint64_t)a2 + 704);
    if (*((_BYTE *)a2 + 416))
    {
      v15.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
      v16 = (v15.__d_.__rep_ - *((_QWORD *)a2 + 51)) / 1000;
      if (v16 > *((_QWORD *)this + 183))
      {
        v17 = *re::assetsLogObjects((re *)v15.__d_.__rep_);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          if ((*((_QWORD *)a2 + 21) & 1) != 0)
            v18 = (char *)*((_QWORD *)a2 + 22);
          else
            v18 = (char *)a2 + 169;
          LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v18;
          WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
          *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v16;
          _os_log_impl(&dword_224FE9000, v17, OS_LOG_TYPE_DEFAULT, "Registration completed for asset '%s' in %llu milliseconds.", (uint8_t *)&buf, 0x16u);
        }
        goto LABEL_59;
      }
      if (re::assetsHighFrequencyLoggingEnabled(void)::onceToken != -1)
        dispatch_once(&re::assetsHighFrequencyLoggingEnabled(void)::onceToken, &__block_literal_global_1);
      if (!re::assetsHighFrequencyLoggingEnabled(void)::shouldLog)
        goto LABEL_59;
      v25 = *re::assetsLogObjects((re *)v15.__d_.__rep_);
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
        goto LABEL_59;
      if ((*((_QWORD *)a2 + 21) & 1) != 0)
        v35 = (char *)*((_QWORD *)a2 + 22);
      else
        v35 = (char *)a2 + 169;
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v35;
      WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
      *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = v16;
      v22 = "Registration completed for asset '%s' in %llu milliseconds.";
      v23 = v25;
      v24 = 22;
    }
    else
    {
      if (re::assetsHighFrequencyLoggingEnabled(void)::onceToken != -1)
        dispatch_once(&re::assetsHighFrequencyLoggingEnabled(void)::onceToken, &__block_literal_global_1);
      if (!re::assetsHighFrequencyLoggingEnabled(void)::shouldLog)
        goto LABEL_59;
      v20 = *re::assetsLogObjects(refreshed);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        goto LABEL_59;
      if ((*((_QWORD *)a2 + 21) & 1) != 0)
        v21 = (char *)*((_QWORD *)a2 + 22);
      else
        v21 = (char *)a2 + 169;
      LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v21;
      v22 = "Registration completed for asset '%s'";
      v23 = v20;
      v24 = 12;
    }
    _os_log_debug_impl(&dword_224FE9000, v23, OS_LOG_TYPE_DEBUG, v22, (uint8_t *)&buf, v24);
LABEL_59:
    *((_BYTE *)a2 + 416) = 0;
    re::internal::AssetEntry::setIsLoading_locked(a2, 0);
    if (*((_BYTE *)this + 1424))
    {
      v26 = re::AssetManager::assetByteSize_entryLocked(this, a2);
      v27 = std::to_string(&buf, v26);
      v36[0] = 0;
      v36[1] = &str_110;
      v28 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &buf
          : (std::string *)buf.__r_.__value_.__r.__words[0];
      re::internal::AssetEntry::setOrClearMetadata_stateLocked(a2, (const re::StringID *)v36, (const char *)v28);
      re::StringID::destroyString((re::StringID *)v36);
      re::internal::AssetEntry::updateMetadata(a2, 1);
      if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
        operator delete(buf.__r_.__value_.__l.__data_);
    }
    if (v5)
    {
      if (!*((_BYTE *)this + 1424))
        re::AssetManager::assetByteSize_entryLocked(this, a2);
      if (re::internal::enableSignposts(0, 0))
        kdebug_trace();
    }
    if (*((_BYTE *)this + 1441))
    {
      v29 = (re *)re::AssetManager::assetNonSharedDataByteSize_entryStateLocked(this, a2);
      v30 = *re::assetsLogObjects(v29);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
      {
        if ((*((_QWORD *)a2 + 21) & 1) != 0)
          v34 = (char *)*((_QWORD *)a2 + 22);
        else
          v34 = (char *)a2 + 169;
        LODWORD(buf.__r_.__value_.__l.__data_) = 136315394;
        *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v34;
        WORD2(buf.__r_.__value_.__r.__words[1]) = 2048;
        *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v29;
        _os_log_debug_impl(&dword_224FE9000, v30, OS_LOG_TYPE_DEBUG, "Asset: %s has Non shared data size of %zu bytes", (uint8_t *)&buf, 0x16u);
      }
    }
LABEL_72:
    if (*((_QWORD *)a2 + 14) == -1)
      LODWORD(v31) = 0;
    else
      v31 = *((_QWORD *)a2 + 14);
    v32 = (const char **)*((_QWORD *)a2 + 33);
    if (v32)
      v33 = *v32;
    else
      v33 = 0;
    return re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x811, v31, v33, v9);
  }
  if (v7 != 1)
  {
    if (v7 == 2)
    {
      if ((*((_QWORD *)a2 + 21) & 1) != 0)
        v10 = (const char *)*((_QWORD *)a2 + 22);
      else
        v10 = (char *)a2 + 169;
      if (*((_QWORD *)a2 + 14) == -1)
        v11 = 0;
      else
        v11 = *((_QWORD *)a2 + 14);
      re::AssetManager::unloadAssetPointer(this, *((const re::AssetType **)a2 + 33), *(void **)(*((_QWORD *)a2 + 90) + 24), v10, v11);
      re::internal::AssetEntry::LoadState::clearAndResetLoadingAssetPointer_locked((re::internal::AssetEntry *)((char *)a2 + 704));
      re::AssetManager::internalAssetEntryUnloadAssetPointer_entryStateLocked(this, a2);
      *((_BYTE *)a2 + 416) = 0;
      re::internal::AssetEntry::setIsLoading_locked(a2, 0);
      re::AssetManager::putEntryInFailedState_entryStateLocked(v13, (uint64_t)a2, 304, (uint64_t)v37);
      if (*(_QWORD *)&v37[0])
      {
        if ((BYTE8(v37[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v37[0] + 40))();
        memset(v37, 0, sizeof(v37));
      }
      if (v5 && re::internal::enableSignposts(0, 0))
        kdebug_trace();
    }
    else if ((v7 & 0xFFFFFFFD) != 0)
    {
      return result;
    }
    goto LABEL_72;
  }
  v19 = *((unsigned __int8 *)a2 + 416);
  if (v5 && !*((_BYTE *)a2 + 416))
  {
    result = re::internal::enableSignposts(0, 0);
    if ((_DWORD)result)
      result = kdebug_trace();
    v19 = *((unsigned __int8 *)a2 + 416);
  }
  if (!v19)
  {
    result = std::chrono::system_clock::now().__d_.__rep_;
    *((_QWORD *)a2 + 51) = result;
  }
  *((_BYTE *)a2 + 416) = 1;
  return result;
}

uint64_t re::AssetManager::assetByteSize_entryLocked(re::AssetManager *this, re::internal::AssetEntry *a2)
{
  uint64_t result;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;

  if (*((_BYTE *)a2 + 320))
    return *((_QWORD *)a2 + 41);
  v4 = atomic_load((unsigned int *)a2 + 176);
  if (v4 != 2)
    return 0;
  v5 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*((_QWORD *)this + 138), *((_QWORD *)a2 + 33));
  v6 = re::internal::AssetEntry::assetPointer(a2);
  result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 32))(v5, v6);
  if (!*((_BYTE *)a2 + 320))
    *((_BYTE *)a2 + 320) = 1;
  *((_QWORD *)a2 + 41) = result;
  return result;
}

BOOL re::AssetManager::isDeviceAsset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  _BYTE v5[8];
  uint64_t v6;
  char v7;

  re::AssetManager::deviceAssetPath(a1, a2, 0, a3, v5);
  v3 = v5[0];
  if (v5[0] && v6 && (v7 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v6 + 40))();
  return v3 != 0;
}

BOOL re::AssetManager::checkAssetTrust_entryStateLocked(re::AssetManager *this, re::internal::AssetEntry *a2, void *a3, int a4)
{
  _BYTE v9[8];
  unint64_t v10;

  if (*((_DWORD *)a2 + 30) == 8
    && (re::AssetManager::ownerPeerID((os_unfair_lock_s *)a2, (uint64_t)this, 0, (uint64_t)v9), v9[0])
    && v10)
  {
    return re::AssetManager::checkAssetTrust_entryStateLocked(this, a2, v10, a3, a4);
  }
  else
  {
    return 1;
  }
}

uint64_t re::AssetManager::putEntryInLoadingState_entryStateLocked(re::AssetManager *this, const re::AssetType **a2, char a3)
{
  _anonymous_namespace_ *Entry;
  unsigned int v7;
  int v8;
  _anonymous_namespace_ *isAssetEntryShareableAndFetchable_entryStateLocked;
  uint64_t v10;
  char *v11;
  re *inited;
  unsigned int *v13;
  uint64_t v14;
  const char *v15;
  re *v16;
  uint64_t v17;
  re *v18;
  uint64_t *v19;
  _QWORD *v20;
  uint64_t v21;
  _anonymous_namespace_ *v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  const char *v26;
  _anonymous_namespace_ *v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  uint64_t *v31;
  re *v32;
  _anonymous_namespace_ *v33;
  const re::AssetLoadDescriptor *v34;
  const char *v35;
  _anonymous_namespace_ *v36;
  _anonymous_namespace_ *v37;
  re *v38;
  uint64_t result;
  re *v40;
  re *v41;
  _OWORD v42[2];
  _OWORD v43[2];
  _BYTE v44[144];
  _OWORD v45[2];
  _OWORD v46[2];
  _QWORD *v47;
  uint64_t v48;
  char *v49;
  int v50;
  uint64_t v51;
  _OWORD v52[2];
  _OWORD v53[2];
  id location;
  re::AssetManager *v55;
  unsigned int *v56;
  re::internal::AssetLoadItem *v57[2];
  __int128 v58;
  __int128 v59;
  _OWORD v60[2];
  int v61;
  uint64_t v62;
  char v63;
  uint64_t (**v64)();
  id v65[2];
  uint64_t v66;
  uint64_t (***v67)();
  uint64_t v68;

  v68 = *MEMORY[0x24BDAC8D0];
  re::internal::AssetEntry::setIsLoading_locked((re::internal::AssetEntry *)a2, 1);
  v61 = *((_DWORD *)a2 + 30);
  re::DynamicString::DynamicString((re::DynamicString *)&v62, (const re::DynamicString *)(a2 + 5));
  Entry = re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::findEntry((uint64_t)this + 1144, &v61, (uint64_t)&v47);
  v7 = HIDWORD(v48);
  if (HIDWORD(v48) == 0x7FFFFFFF)
  {
    v8 = *((_DWORD *)a2 + 30);
    if (v8 != 8)
    {
      if (v8 == 4)
      {
        isAssetEntryShareableAndFetchable_entryStateLocked = (_anonymous_namespace_ *)re::AssetManager::isAssetEntryShareableAndFetchable_entryStateLocked(this, (re::internal::AssetEntry *)a2);
        if ((_DWORD)isAssetEntryShareableAndFetchable_entryStateLocked)
        {
          *((_BYTE *)a2 + 417) = 1;
          re::AssetManager::fromPeerID((uint64_t)v57, (uint64_t)this, (os_unfair_lock_s *)a2, 0);
          re::DynamicString::format((re::DynamicString *)"%llu", (re::DynamicString *)&v47, v57[1]);
          v10 = *((_QWORD *)this + 141);
          if ((v48 & 1) != 0)
            v11 = v49;
          else
            v11 = (char *)&v48 + 1;
          inited = (re *)objc_initWeak(&location, a2 + 1);
          v55 = this;
          v66 = re::globalAllocators(inited)[2];
          v67 = 0;
          v64 = &off_24ED2C648;
          v65[0] = 0;
          objc_moveWeak(v65, &location);
          v65[1] = v55;
          v67 = &v64;
          (*(void (**)(unsigned int **__return_ptr, uint64_t, char *, char *, uint64_t (***)()))(*(_QWORD *)v10 + 64))(&v56, v10, v11, (char *)a2 + 32, &v64);
          v13 = (unsigned int *)a2[49];
          a2[49] = (const re::AssetType *)v56;
          v56 = v13;
          if (v13)
          {
            re::details::release<re::ResourceRequest>(v13);
            v56 = 0;
          }
          if (v67)
          {
            ((void (*)(uint64_t (***)()))**v67)(v67);
            if (v67 != &v64)
              (*(void (**)(uint64_t))(*(_QWORD *)v66 + 40))(v66);
            v67 = 0;
          }
          objc_destroyWeak(&location);
          if (v47 && (v48 & 1) != 0)
            (*(void (**)(void))(*v47 + 40))();
        }
        else if (*((_QWORD *)this + 140))
        {
          dispatch_assert_queue_V2(*((dispatch_queue_t *)this + 73));
          v47 = 0;
          if (((unint64_t)a2[6] & 1) != 0)
            v26 = (const char *)a2[7];
          else
            v26 = (char *)a2 + 49;
          v27 = (_anonymous_namespace_ *)sscanf(v26, "%llu", &v47);
          v28 = *((_QWORD *)this + 140);
          v29 = (uint64_t)v47;
          if (((unint64_t)a2[17] & 1) != 0)
            v30 = (const char *)a2[18];
          else
            v30 = (char *)a2 + 137;
          re::internal::AssetNetworkLoader::sendRequestToNetworkPeer_entryStateLocked(v28, (uint64_t)a2, v29, (re::DynamicString *)v53);
          if (*(_QWORD *)&v53[0])
          {
            if ((BYTE8(v53[0]) & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)&v53[0] + 40))();
            memset(v53, 0, sizeof(v53));
          }
        }
        else
        {
          re::AssetManager::putEntryInFailedState_entryStateLocked(v32, (uint64_t)a2, 302, (uint64_t)v52);
          if (*(_QWORD *)&v52[0])
          {
            if ((BYTE8(v52[0]) & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)&v52[0] + 40))();
            memset(v52, 0, sizeof(v52));
          }
        }
      }
      else
      {
        v19 = re::globalAllocators(Entry);
        v20 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v19[2] + 32))(v19[2], 56, 8);
        *(_OWORD *)v20 = 0u;
        *((_OWORD *)v20 + 1) = 0u;
        *((_OWORD *)v20 + 2) = 0u;
        v20[6] = 0;
        re::CancellationTokenSource::CancellationTokenSource((re::CancellationTokenSource *)(v20 + 3));
        v47 = v20;
        *v20 = 0;
        *((_DWORD *)v20 + 4) = 0;
        re::internal::AssetBackgroundLoader::loadAssetAsync(*((re::internal::AssetBackgroundLoader **)this + 137), v20, a2[33], (const re::AssetPath *)(a2 + 4), v57);
        v21 = v20[1];
        v20[1] = v57[0];
        if (v21)

        os_unfair_lock_lock((os_unfair_lock_t)this + 336);
        a2[50] = (const re::AssetType *)v20;
        re::DynamicArray<re::RigDataValue *>::add((re::AssetManager *)((char *)this + 1352), &v47);
        os_unfair_lock_unlock((os_unfair_lock_t)this + 336);
      }
      goto LABEL_74;
    }
    v17 = (uint64_t)a2[14];
    if ((unint64_t)(v17 + 1) < 2)
    {
      re::AssetManager::putEntryInFailedState_entryStateLocked(v18, (uint64_t)a2, 200, (uint64_t)v42);
      if (*(_QWORD *)&v42[0])
      {
        if ((BYTE8(v42[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v42[0] + 40))();
        memset(v42, 0, sizeof(v42));
      }
      goto LABEL_74;
    }
    os_unfair_lock_lock((os_unfair_lock_t)this + 16);
    v47 = (_QWORD *)v17;
    v31 = (uint64_t *)re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 120, (uint64_t *)&v47);
    if (v31)
    {
      re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray((uint64_t)&v47, v31);
    }
    else
    {
      v51 = 0;
      v48 = 0;
      v49 = 0;
      v47 = 0;
      v50 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 16);
    if (v49)
    {
      v34 = (const re::AssetLoadDescriptor *)v51;
      if ((*(_QWORD *)(v51 + 8) & 1) != 0)
        v35 = *(const char **)(v51 + 16);
      else
        v35 = (const char *)(v51 + 9);
      v36 = (_anonymous_namespace_ *)strcmp(v35, "NetworkAsset");
      if ((_DWORD)v36)
      {
        v37 = (_anonymous_namespace_ *)strcmp(v35, "PeerAsset");
        if ((_DWORD)v37)
        {
          re::AssetManager::reuseExistingOrLoadNewAsset_locked((os_unfair_lock_s *)this, a2, (uint64_t *)&v47);
        }
        else if (*((_QWORD *)this + 140) && *((_QWORD *)this + 151))
        {
          re::AssetLoadDescriptor::AssetLoadDescriptor((re::AssetLoadDescriptor *)v44, v34);
          re::NetworkActionQueue::queueSyncActionPeerLoad((uint64_t)this + 768, v17, (const re::AssetLoadDescriptor *)v44);
          re::AssetLoadDescriptor::~AssetLoadDescriptor((re::AssetLoadDescriptor *)v44);
        }
        else
        {
          re::AssetManager::putEntryInFailedState_entryStateLocked(v40, (uint64_t)a2, 302, (uint64_t)v43);
          if (*(_QWORD *)&v43[0])
          {
            if ((BYTE8(v43[0]) & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)&v43[0] + 40))();
            memset(v43, 0, sizeof(v43));
          }
        }
        goto LABEL_73;
      }
      if (!*((_QWORD *)this + 151))
      {
        re::AssetManager::putEntryInFailedState_entryStateLocked(v41, (uint64_t)a2, 302, (uint64_t)v45);
        if (*(_QWORD *)&v45[0])
        {
          if ((BYTE8(v45[0]) & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)&v45[0] + 40))();
          memset(v45, 0, sizeof(v45));
        }
        goto LABEL_73;
      }
    }
    else if (!*((_QWORD *)this + 151) || (a3 & 1) != 0)
    {
      re::AssetManager::putEntryInFailedState_entryStateLocked(v38, (uint64_t)a2, 302, (uint64_t)v46);
      if (*(_QWORD *)&v46[0])
      {
        if ((BYTE8(v46[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v46[0] + 40))();
        memset(v46, 0, sizeof(v46));
      }
      goto LABEL_73;
    }
    re::AssetManager::queueSyncActionNetworkLoad(this, v17, (const re::internal::AssetEntry *)a2);
LABEL_73:
    re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)&v47);
    goto LABEL_74;
  }
  if (*((_QWORD *)this + 140))
  {
    v14 = *((_QWORD *)this + 145);
    dispatch_assert_queue_V2(*((dispatch_queue_t *)this + 73));
    v47 = 0;
    if ((*(_BYTE *)(v14 + 88 * v7 + 64) & 1) != 0)
      v15 = *(const char **)(v14 + 88 * v7 + 72);
    else
      v15 = (const char *)(v14 + 88 * v7 + 65);
    v22 = (_anonymous_namespace_ *)sscanf(v15, "%llu", &v47);
    v23 = *((_QWORD *)this + 140);
    v24 = (uint64_t)v47;
    if (((unint64_t)a2[17] & 1) != 0)
      v25 = (const char *)a2[18];
    else
      v25 = (char *)a2 + 137;
    re::internal::AssetNetworkLoader::sendRequestToNetworkPeer_entryStateLocked(v23, (uint64_t)a2, v24, (re::DynamicString *)v60);
    if (*(_QWORD *)&v60[0])
    {
      if ((BYTE8(v60[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v60[0] + 40))();
      memset(v60, 0, sizeof(v60));
    }
  }
  else
  {
    re::AssetManager::putEntryInFailedState_entryStateLocked(v16, (uint64_t)a2, 302, (uint64_t)&v58);
    if ((_QWORD)v58)
    {
      if ((BYTE8(v58) & 1) != 0)
        (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)v58 + 40))(v58, v59);
      v58 = 0u;
      v59 = 0u;
    }
  }
LABEL_74:
  result = v62;
  if (v62)
  {
    if ((v63 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v62 + 40))();
  }
  return result;
}

uint64_t *re::AssetManager::queueSyncActionNetworkLoad(re::AssetManager *this, uint64_t a2, const re::internal::AssetEntry *a3)
{
  _anonymous_namespace_ *v6;
  uint64_t v7;
  re *inited;
  NSObject *v9;
  char *v10;
  uint64_t *result;
  int v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  __int128 buf;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v12 = 0;
  v15 = 0;
  v16 = 0;
  v14 = 0;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v13, 0);
  *((_QWORD *)&v17 + 1) = 0;
  v18 = 0uLL;
  re::DynamicString::setCapacity(&v17, 0);
  v19 = 0;
  if (*((_QWORD *)a3 + 14) == -1)
    v7 = 0;
  else
    v7 = *((_QWORD *)a3 + 14);
  inited = (re *)re::AssetPath::initAssetIdAssetPath((uint64_t)&v12, v7, *((_QWORD *)a3 + 33));
  if (*((_QWORD *)this + 151))
  {
    v21 = 0;
    v22 = 0;
    buf = (unint64_t)v13;
    re::DynamicString::setCapacity(&buf, 0);
    re::AssetPath::fullAssetPath((re::DynamicString *)&v12, (re::DynamicString *)&buf);
    re::NetworkActionQueue::queueSyncActionNetworkLoad((re::AssetManager *)((char *)this + 768), a2, (const re::DynamicString *)&buf);
    if ((_QWORD)buf && (BYTE8(buf) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)buf + 40))();
  }
  else
  {
    v9 = *re::assetsLogObjects(inited);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      if ((*((_QWORD *)a3 + 21) & 1) != 0)
        v10 = (char *)*((_QWORD *)a3 + 22);
      else
        v10 = (char *)a3 + 169;
      LODWORD(buf) = 136315138;
      *(_QWORD *)((char *)&buf + 4) = v10;
      _os_log_impl(&dword_224FE9000, v9, OS_LOG_TYPE_DEFAULT, "Trying to queue network load for %s when NetworkAssetService not available!", (uint8_t *)&buf, 0xCu);
    }
  }
  if ((_QWORD)v17)
  {
    if ((BYTE8(v17) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v17 + 40))();
    v17 = 0u;
    v18 = 0u;
  }
  result = v13;
  if (v13)
  {
    if ((v14 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v13 + 40))();
  }
  return result;
}

void re::AssetManager::findDependencies(re::AssetManager *this@<X0>, const re::AssetHandle *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  unsigned int v6;
  NSObject *v7;
  _QWORD *v8;
  char *v9;
  int v10;
  char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v5 = *((_QWORD *)a2 + 1);
  if (v5 && (v6 = atomic_load((unsigned int *)(v5 + 704)), v6 == 2))
  {
    re::AssetManager::findDependencies(this, *((const re::internal::AssetEntry **)a2 + 1), a3);
  }
  else
  {
    v7 = *re::assetsLogObjects(this);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = re::AssetHandle::assetInfo(a2);
      if ((v8[17] & 1) != 0)
        v9 = (char *)v8[18];
      else
        v9 = (char *)v8 + 137;
      v10 = 136315138;
      v11 = v9;
      _os_log_impl(&dword_224FE9000, v7, OS_LOG_TYPE_DEFAULT, "Tried to get dependencies for unloaded asset '%s'", (uint8_t *)&v10, 0xCu);
    }
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    *(_DWORD *)(a3 + 24) = 0;
  }
}

void re::AssetManager::loadAssetFromDescriptorsOnBackgroundTask_entryStateLocked(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  re::internal::AssetLoadItem *v15;
  uint64_t v16;

  v6 = re::globalAllocators((re *)a1);
  v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6[2] + 32))(v6[2], 56, 8);
  *(_OWORD *)v7 = 0u;
  *(_OWORD *)(v7 + 16) = 0u;
  *(_OWORD *)(v7 + 32) = 0u;
  *(_QWORD *)(v7 + 48) = 0;
  re::CancellationTokenSource::CancellationTokenSource((re::CancellationTokenSource *)(v7 + 24));
  v16 = v7;
  if (a2[14] == -1)
    v8 = 0;
  else
    v8 = a2[14];
  *(_QWORD *)v7 = v8;
  *(_DWORD *)(v7 + 16) = 0;
  v9 = *(_QWORD *)(a1 + 1096);
  v10 = a2[33];
  v11 = *(_QWORD *)(v7 + 48);
  v14 = v11;
  if (v11)
    v12 = (id)(v11 + 8);
  re::internal::AssetBackgroundLoader::loadAssetAsync(v9, v7, v10, v8, a3, &v14, &v15);
  v13 = *(_QWORD *)(v7 + 8);
  *(_QWORD *)(v7 + 8) = v15;
  v15 = (re::internal::AssetLoadItem *)v13;
  if (v13)
  {

    v15 = 0;
  }
  if (v14)
  {

    v14 = 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1344));
  a2[50] = v7;
  re::DynamicArray<re::RigDataValue *>::add((_anonymous_namespace_ *)(a1 + 1352), &v16);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 1344));
}

unsigned __int8 *re::AssetManager::loadAssetAsync_entryStateLocked(unsigned __int8 *this, re::internal::AssetEntry *a2, char a3)
{
  unsigned __int8 v5;
  re *v6;
  uint64_t v7;
  re *v8;
  re *v9;
  _anonymous_namespace_ *v10;
  char v11;
  uint64_t v12;
  unsigned __int8 *v13;
  char v14;
  uint64_t v15;
  unsigned __int8 *v16;
  char v17;
  uint64_t v18;

  if (atomic_load((unsigned int *)a2 + 176))
    return this;
  v5 = atomic_load(this + 1409);
  if ((v5 & 1) != 0)
  {
    re::AssetManager::putEntryInFailedState_entryStateLocked(v8, (uint64_t)a2, 100, (uint64_t)&v16);
    this = v16;
    if (!v16 || (v17 & 1) == 0)
      return this;
    v7 = v18;
    return (unsigned __int8 *)(*(uint64_t (**)(unsigned __int8 *, uint64_t))(*(_QWORD *)this + 40))(this, v7);
  }
  if (!*((_QWORD *)a2 + 33))
  {
    re::AssetManager::putEntryInFailedState_entryStateLocked(v9, (uint64_t)a2, 200, (uint64_t)&v13);
    this = v13;
    if (!v13 || (v14 & 1) == 0)
      return this;
    v7 = v15;
    return (unsigned __int8 *)(*(uint64_t (**)(unsigned __int8 *, uint64_t))(*(_QWORD *)this + 40))(this, v7);
  }
  if (!*((_BYTE *)a2 + 312))
    return (unsigned __int8 *)re::AssetManager::putEntryInLoadingState_entryStateLocked((re::AssetManager *)this, (const re::AssetType **)a2, a3);
  re::AssetManager::putEntryInFailedState_entryStateLocked(v6, (uint64_t)a2, 200, (uint64_t)&v10);
  this = (unsigned __int8 *)v10;
  if (v10 && (v11 & 1) != 0)
  {
    v7 = v12;
    return (unsigned __int8 *)(*(uint64_t (**)(unsigned __int8 *, uint64_t))(*(_QWORD *)this + 40))(this, v7);
  }
  return this;
}

void re::AssetManager::unloadAssetEntry_entryStateLocked(os_unfair_lock_s *this, re::internal::AssetEntry *a2, int a3)
{
  os_unfair_lock_s *v5;
  uint64_t v6;
  unint64_t v7;

  if (*((_BYTE *)a2 + 416))
  {
    *((_BYTE *)a2 + 416) = 0;
    if (a3)
    {
      v5 = this + 16;
      os_unfair_lock_lock(this + 16);
    }
    else
    {
      v5 = 0;
    }
    v6 = *(_QWORD *)&this[94]._os_unfair_lock_opaque;
    if (v6)
    {
      v7 = 0;
      while (*(re::internal::AssetEntry **)(*(_QWORD *)(*(_QWORD *)&this[98]._os_unfair_lock_opaque + 8 * v7) + 24) != a2)
      {
        if (v6 == ++v7)
          goto LABEL_9;
      }
    }
    else
    {
LABEL_9:
      v7 = -1;
    }
    re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::removeAt((uint64_t)&this[90], v7);
    if (v5)
      os_unfair_lock_unlock(v5);
  }
  re::AssetManager::internalAssetEntryUnloadLoadingAssetPointer_entryStateLocked((re::AssetManager *)this, a2);
  re::AssetManager::internalAssetEntryUnloadAssetPointer_entryStateLocked((re::AssetManager *)this, a2);
  re::internal::AssetEntry::setIsLoading_locked(a2, 0);
  re::internal::AssetEntry::cancelResourceRequest_stateLocked(a2);
}

void re::AssetManager::cancelLoadingAsset_entryStateLocked(os_unfair_lock_s *a1, re::internal::AssetEntry *this, int a3)
{
  uint64_t v6;
  uint64_t v7;

  v6 = *((_QWORD *)this + 50);
  if (v6)
  {
    *(_DWORD *)(v6 + 16) = 1;
    *((_QWORD *)this + 50) = 0;
  }
  if (*((_DWORD *)this + 30) == 8)
  {
    if (*((_QWORD *)this + 14) == -1)
      v7 = 0;
    else
      v7 = *((_QWORD *)this + 14);
    re::NetworkActionQueue::removeLoadActions(a1 + 192, v7);
  }
  if ((re::internal::AssetEntry::hasAssetPointer(this) & 1) != 0
    || re::internal::AssetEntry::hasLoadingAssetPointer(this))
  {
    re::AssetManager::unloadAssetEntry_entryStateLocked(a1, this, a3);
  }
  re::internal::AssetEntry::setIsLoading_locked(this, 0);
}

void re::AssetManager::processUpdatedResourcePayload(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_unfair_lock_s *v6;
  const char *v7;
  uint64_t v8;
  const char **v9;
  const char *v10;
  unsigned int v11;
  uint64_t v12;
  _BOOL4 v13;
  id *v14;
  void *v15;
  const __CFString *v16;
  re::AssetLoader *v17;
  const __CFString *v18;
  const char *v19;
  _BYTE *v20;
  re *v21;
  _BYTE *v22;
  uint64_t v23;
  int v24;
  const char *CStringPtr;
  re *v26;
  re *v27;
  re *v28;
  void *v29;
  int v30;
  void *v31;
  uint64_t v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  NSObject *v37;
  uint64_t v38;
  void *v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  re *v43;
  uint64_t v44;
  uint64_t v45;
  id v46;
  uint64_t v47;
  _anonymous_namespace_ *v48;
  re *v49;
  id v50;
  _OWORD v51[2];
  id v52;
  id v53;
  id v54;
  void (**v55)(re::DefaultAssetSerialize *__hidden);
  _BYTE v56[96];
  _QWORD v57[5];
  _BYTE v58[8];
  uint64_t v59;
  uint64_t v60;
  char v61;
  _BYTE v62[32];
  _BYTE v63[32];
  uint64_t v64;
  re::internal::AssetLoadItem *v65;
  __int128 buf;
  uint64_t v67;

  v67 = *MEMORY[0x24BDAC8D0];
  v6 = (os_unfair_lock_s *)(a2 + 384);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 384));
  if (*(_QWORD *)(a2 + 112) == -1)
    LODWORD(v8) = 0;
  else
    v8 = *(_QWORD *)(a2 + 112);
  v9 = *(const char ***)(a2 + 264);
  if (v9)
    v10 = *v9;
  else
    v10 = 0;
  re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x80F, v8, v10, v7);
  if (*(_BYTE *)a3)
  {
    v11 = atomic_load((unsigned int *)(a2 + 704));
    v12 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 1208) + 104))(*(_QWORD *)(a1 + 1208));
    re::DynamicString::format((re::DynamicString *)"%llu", (re::DynamicString *)&v60, v12);
    re::AssetHandle::AssetHandle((re::AssetHandle *)v58, (re::internal::AssetEntry *)a2);
    if (v59)
      v13 = *(unsigned __int8 *)(v59 + 259) != 0;
    else
      v13 = 0;
    re::DefaultAssetSerialize::DefaultAssetSerialize((re::DefaultAssetSerialize *)&v55, (const re::AssetHandle *)v58);
    v55 = off_24ED2D398;
    v56[88] = 1;
    v26 = re::DynamicString::DynamicString((re::DynamicString *)v57, (const re::DynamicString *)&v60);
    v57[4] = a1;
    if (v11 == 2)
    {
      v34 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(a1 + 1104), *(_QWORD *)(a2 + 264));
      *(_BYTE *)(a2 + 256) = 1;
      ++*(_DWORD *)(a2 + 260);
      v35 = re::internal::AssetEntry::assetPointer((re::internal::AssetEntry *)a2);
      v36 = *(void **)(a3 + 8);
      *(_QWORD *)(a3 + 8) = 0;
      v50 = v36;
      (*(void (**)(uint64_t, uint64_t, id *, void (***)(re::DefaultAssetSerialize *__hidden)))(*(_QWORD *)v34 + 232))(v34, v35, &v50, &v55);

      if (*(_BYTE *)(a1 + 1441))
        re::AssetManager::assetNonSharedDataByteSize_entryStateLocked((re::AssetManager *)a1, (re::internal::AssetEntry *)a2);
    }
    else if (v11 == 1)
    {
      v27 = (re *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(a1 + 1104), *(_QWORD *)(a2 + 264));
      if (*(_BYTE *)(a1 + 1457))
      {
        v28 = v27;
        v29 = (void *)(*(uint64_t (**)(re *))(*(_QWORD *)v27 + 120))(v27);
        LOBYTE(buf) = 0;
        v53 = *(id *)(a3 + 8);
        v30 = (*(uint64_t (**)(re *, id *, void *, void (***)(re::DefaultAssetSerialize *__hidden), __int128 *, _QWORD))(*(_QWORD *)v28 + 208))(v28, &v53, v29, &v55, &buf, 0);

        if (!v30)
          goto LABEL_55;
        v31 = *(void **)(a3 + 8);
        *(_QWORD *)(a3 + 8) = 0;
        v52 = v31;
        if ((*(_QWORD *)(a2 + 168) & 1) != 0)
          v32 = *(_QWORD *)(a2 + 176);
        else
          v32 = a2 + 169;
        v33 = (*(uint64_t (**)(re *, id *, void *, uint64_t))(*(_QWORD *)v28 + 224))(v28, &v52, v29, v32);

        if (*(_BYTE *)(a2 + 352) || (_BYTE)buf)
        {
          if (!*(_BYTE *)(a2 + 352) || (_BYTE)buf)
          {
            if (!*(_BYTE *)(a2 + 352) && (_BYTE)buf)
              *(_BYTE *)(a2 + 352) = 1;
            *(_QWORD *)(a2 + 360) = *((_QWORD *)&buf + 1);
          }
          else
          {
            *(_BYTE *)(a2 + 352) = 0;
          }
        }
        if ((v33 & 1) != 0)
        {
          *(_BYTE *)(a2 + 417) = 0;
          re::AssetManager::processLoadedAsset_entryStateLocked((os_unfair_lock_s *)a1, (re::internal::AssetEntry *)a2, v29);
        }
        else
        {
LABEL_55:
          v48 = (_anonymous_namespace_ *)(*(uint64_t (**)(re *, void *))(*(_QWORD *)v28 + 16))(v28, v29);
          re::AssetManager::putEntryInFailedState_entryStateLocked(v49, a2, 302, (uint64_t)v51);
          if (*(_QWORD *)&v51[0])
          {
            if ((BYTE8(v51[0]) & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)&v51[0] + 40))();
            memset(v51, 0, sizeof(v51));
          }
        }
      }
      else
      {
        v39 = *(void **)(a3 + 8);
        *(_QWORD *)(a3 + 8) = 0;
        v54 = v39;
        v40 = re::globalAllocators(v27);
        v41 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v40[2] + 32))(v40[2], 56, 8);
        *(_OWORD *)v41 = 0u;
        *(_OWORD *)(v41 + 16) = 0u;
        *(_OWORD *)(v41 + 32) = 0u;
        *(_QWORD *)(v41 + 48) = 0;
        re::CancellationTokenSource::CancellationTokenSource((re::CancellationTokenSource *)(v41 + 24));
        *(_QWORD *)&buf = v41;
        if (*(_QWORD *)(a2 + 112) == -1)
          v42 = 0;
        else
          v42 = *(_QWORD *)(a2 + 112);
        *(_QWORD *)v41 = v42;
        *(_DWORD *)(v41 + 16) = 0;
        v43 = *(re **)(a1 + 1096);
        v44 = *(_QWORD *)(a2 + 264);
        v45 = *(_QWORD *)(v41 + 48);
        v64 = v45;
        if (v45)
          v46 = (id)(v45 + 8);
        re::internal::AssetBackgroundLoader::loadAssetAsync(v43, v41, v44, v42, (uint64_t *)&v54, &v64, v13, &v65);
        v47 = *(_QWORD *)(v41 + 8);
        *(_QWORD *)(v41 + 8) = v65;
        if (v47)

        if (v45)
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1344));
        *(_QWORD *)(a2 + 400) = v41;
        re::DynamicArray<re::RigDataValue *>::add((_anonymous_namespace_ *)(a1 + 1352), &buf);
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 1344));

      }
    }
    else
    {
      v37 = *re::assetsLogObjects(v26);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
      {
        if ((*(_QWORD *)(a2 + 168) & 1) != 0)
          v38 = *(_QWORD *)(a2 + 176);
        else
          v38 = a2 + 169;
        LODWORD(buf) = 136315138;
        *(_QWORD *)((char *)&buf + 4) = v38;
        _os_log_debug_impl(&dword_224FE9000, v37, OS_LOG_TYPE_DEBUG, "Updated payload for asset '%s' was ignored (asset is not currently loaded)", (uint8_t *)&buf, 0xCu);
      }
    }
    v55 = off_24ED2D398;
    if (v57[0])
    {
      if ((v57[1] & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v57[0] + 40))();
      memset(v57, 0, 32);
    }
    v55 = &off_24ED2D3D0;
    re::Optional<re::AssetPath>::~Optional((uint64_t)v56);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v58);
    if (v60 && (v61 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v60 + 40))();
  }
  else
  {
    v15 = *(void **)(a3 + 8);
    v14 = (id *)(a3 + 8);
    v16 = CFErrorCopyDescription((CFErrorRef)v15);
    v17 = (re::AssetLoader *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(a1 + 1104), *(_QWORD *)(a2 + 264));
    re::internal::AssetEntry::LoadState::unloadAssetPointer_locked(a2 + 704, v17);
    v18 = re::WrappedError::domain(v14);
    if (CFStringCompare(v18, CFSTR("REResourceSharingErrorDomain"), 0) || objc_msgSend(*v14, "code") != 600)
    {
      CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
      v20 = v62;
      v21 = (re *)re::DynamicString::format((re::DynamicString *)"Failed to fetch asset: %s", (re::DynamicString *)v62, CStringPtr);
      v22 = v62;
      v23 = a2;
      v24 = 302;
    }
    else
    {
      v19 = CFStringGetCStringPtr(v16, 0x8000100u);
      v20 = v63;
      v21 = (re *)re::DynamicString::format((re::DynamicString *)"Resource Memory limit hit for asset: %s", (re::DynamicString *)v63, v19);
      v22 = v63;
      v23 = a2;
      v24 = 400;
    }
    re::AssetManager::putEntryInFailedState_entryStateLocked(v21, v23, v24, (uint64_t)v22);
    if (*(_QWORD *)v20)
    {
      if ((v20[8] & 1) != 0)
        (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)v20 + 40))(*(_QWORD *)v20, *((_QWORD *)v20 + 2));
      *(_OWORD *)v20 = 0u;
      *((_OWORD *)v20 + 1) = 0u;
    }
    CFRelease(v16);
  }
  os_unfair_lock_unlock(v6);
}

void re::AssetManager::setAssetPayloadRequestOptions(uint64_t a1, uint64_t a2, id *a3)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  id v10;

  v6 = (os_unfair_lock_s *)(a2 + 384);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 384));
  v7 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(a1 + 1104), *(_QWORD *)(a2 + 264));
  v8 = re::internal::AssetEntry::assetPointer((re::internal::AssetEntry *)a2);
  v10 = *a3;
  (*(void (**)(uint64_t, uint64_t, id *))(*(_QWORD *)v7 + 240))(v7, v8, &v10);

  v9 = *(_QWORD *)(a2 + 392);
  if (v9)
    (*(void (**)(_QWORD, uint64_t, id *))(**(_QWORD **)(a1 + 1128) + 72))(*(_QWORD *)(a1 + 1128), v9, a3);
  os_unfair_lock_unlock(v6);
}

void re::AssetManager::assetPayloadDidChange(re::AssetManager *this, re::internal::AssetEntry *a2)
{
  void *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_weak_owners;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  _QWORD block[5];
  std::__shared_weak_count *v12;
  id v13[2];
  id location[3];

  if (*((_BYTE *)a2 + 320))
    *((_BYTE *)a2 + 320) = 0;
  if (*((_BYTE *)a2 + 336))
    *((_BYTE *)a2 + 336) = 0;
  if (*((_BYTE *)a2 + 352))
    *((_BYTE *)a2 + 352) = 0;
  v4 = (void *)*((_QWORD *)this + 142);
  if (v4)
  {
    if (*((_QWORD *)this + 112) && dispatch_get_specific((char *)this + 896) == (char *)this + 896)
    {
      re::AssetHandle::AssetHandle((re::AssetHandle *)location, a2);
      (*(void (**)(void *, id *))(*(_QWORD *)v4 + 16))(v4, location);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)location);
    }
    else
    {
      v5 = *((_QWORD *)this + 224);
      v6 = (std::__shared_weak_count *)*((_QWORD *)this + 225);
      if (v6)
      {
        p_shared_weak_owners = (unint64_t *)&v6->__shared_weak_owners_;
        do
          v8 = __ldxr(p_shared_weak_owners);
        while (__stxr(v8 + 1, p_shared_weak_owners));
      }
      objc_initWeak(location, (char *)a2 + 8);
      block[0] = MEMORY[0x24BDAC760];
      block[1] = 1174405120;
      block[2] = ___ZN2re12AssetManager21assetPayloadDidChangeERNS_8internal10AssetEntryE_block_invoke;
      block[3] = &__block_descriptor_tmp_59;
      block[4] = v5;
      v12 = v6;
      if (v6)
      {
        v9 = (unint64_t *)&v6->__shared_weak_owners_;
        do
          v10 = __ldxr(v9);
        while (__stxr(v10 + 1, v9));
      }
      v13[0] = 0;
      objc_copyWeak(v13, location);
      v13[1] = v4;
      dispatch_async(*((dispatch_queue_t *)this + 73), block);
      objc_destroyWeak(v13);
      v13[0] = 0;
      if (v12)
        std::__shared_weak_count::__release_weak(v12);
      objc_destroyWeak(location);
      if (v6)
        std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void ___ZN2re12AssetManager21assetPayloadDidChangeERNS_8internal10AssetEntryE_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  char *WeakRetained;
  void *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  char *v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD v16[5];
  std::__shared_weak_count *v17;
  uint64_t v18;
  char *v19;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5)
      {
        WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 48));
        if (WeakRetained)
        {
          v7 = WeakRetained;
          v16[0] = MEMORY[0x24BDAC760];
          v16[1] = 1174405120;
          v16[2] = ___ZN2re12AssetManager21assetPayloadDidChangeERNS_8internal10AssetEntryE_block_invoke_2;
          v16[3] = &__block_descriptor_tmp_58;
          v16[4] = v5;
          v17 = v4;
          p_shared_owners = (unint64_t *)&v4->__shared_owners_;
          do
            v9 = __ldxr(p_shared_owners);
          while (__stxr(v9 + 1, p_shared_owners));
          v18 = *(_QWORD *)(a1 + 56);
          v19 = WeakRetained - 8;
          v10 = WeakRetained;
          dispatch_sync(*(dispatch_queue_t *)(v5 + 1768), v16);
          if (v19)
          {

            v19 = 0;
          }
          v11 = v17;
          if (v17)
          {
            v12 = (unint64_t *)&v17->__shared_owners_;
            do
              v13 = __ldaxr(v12);
            while (__stlxr(v13 - 1, v12));
            if (!v13)
            {
              ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
              std::__shared_weak_count::__release_weak(v11);
            }
          }

        }
      }
      v14 = (unint64_t *)&v4->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void ___ZN2re12AssetManager21assetPayloadDidChangeERNS_8internal10AssetEntryE_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  _BYTE v2[24];

  if (!*(_BYTE *)(*(_QWORD *)(a1 + 32) + 1410))
  {
    v1 = *(_QWORD *)(a1 + 48);
    re::AssetHandle::AssetHandle((re::AssetHandle *)v2, *(re::internal::AssetEntry **)(a1 + 56));
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v1 + 16))(v1, v2);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v2);
  }
}

_QWORD *__copy_helper_block_8_32c45_ZTSNSt3__110shared_ptrIN2re12AssetManagerEEE56c46_ZTSN2re9SharedPtrINS_8internal10AssetEntryEEE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;

  v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[7];
  result[7] = v5;
  if (v5)
    return (id)(v5 + 8);
  return result;
}

uint64_t __destroy_helper_block_8_32c45_ZTSNSt3__110shared_ptrIN2re12AssetManagerEEE56c46_ZTSN2re9SharedPtrINS_8internal10AssetEntryEEE(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 56);
  if (v2)
  {

    *(_QWORD *)(a1 + 56) = 0;
  }
  return std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100](a1 + 32);
}

void __copy_helper_block_8_32c42_ZTSNSt3__18weak_ptrIN2re12AssetManagerEEE48c48_ZTSN2re10ArcWeakPtrINS_8internal10AssetEntryEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 16);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  *(_QWORD *)(a1 + 48) = 0;
  objc_copyWeak((id *)(a1 + 48), (id *)(a2 + 48));
}

void __destroy_helper_block_8_32c42_ZTSNSt3__18weak_ptrIN2re12AssetManagerEEE48c48_ZTSN2re10ArcWeakPtrINS_8internal10AssetEntryEEE(uint64_t a1)
{
  std::__shared_weak_count *v2;

  objc_destroyWeak((id *)(a1 + 48));
  *(_QWORD *)(a1 + 48) = 0;
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
}

void re::AssetManager::makeSharedResourcePayload(uint64_t a1, uint64_t a2, const char *a3)
{
  unint64_t *v5;
  _anonymous_namespace_ *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  void (**v11)(re::DefaultAssetSerialize *__hidden);
  _BYTE v12[96];
  _QWORD v13[5];
  _BYTE v14[24];

  v5 = *(unint64_t **)(a2 + 8);
  v6 = re::AssetHandle::AssetHandle((re::AssetHandle *)v14, (re::internal::AssetEntry *)v5);
  re::DefaultAssetSerialize::DefaultAssetSerialize((re::DefaultAssetSerialize *)&v11, (const re::AssetHandle *)v14);
  v11 = off_24ED2D398;
  v12[88] = 0;
  re::DynamicString::DynamicString((re::DynamicString *)v13, (const re::DynamicString *)&v9);
  v13[4] = a1;
  if (v9 && (v10 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v9 + 40))();
  v7 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(a1 + 1104), v5[33]);
  v8 = re::internal::AssetEntry::assetPointer((re::internal::AssetEntry *)v5);
  (*(void (**)(uint64_t, uint64_t, void (***)(re::DefaultAssetSerialize *__hidden)))(*(_QWORD *)v7 + 200))(v7, v8, &v11);
  v11 = off_24ED2D398;
  if (v13[0])
  {
    if ((v13[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v13[0] + 40))();
    memset(v13, 0, 32);
  }
  v11 = &off_24ED2D3D0;
  re::Optional<re::AssetPath>::~Optional((uint64_t)v12);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v14);
}

uint64_t re::AssetManager::setResourcePayloadObserver(uint64_t result, uint64_t a2)
{
  atomic_load((unsigned __int8 *)(result + 1409));
  *(_QWORD *)(result + 1136) = a2;
  return result;
}

void re::AssetManager::cancelLoadingAssetId(os_unfair_lock_s *this, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  os_unfair_lock_s *v6;
  unsigned int v7;
  uint64_t v8;
  re *v9;
  _OWORD v10[2];
  _BYTE v11[8];
  uint64_t v12;
  os_unfair_lock_s *v13;

  v4 = this + 16;
  os_unfair_lock_lock(this + 16);
  re::AssetManager::lookupExistingAsset_assetTablesLocked((re::internal::AssetTypeRegistry **)this, a2, v11);
  os_unfair_lock_unlock(v4);
  if (v11[0])
  {
    v5 = (uint64_t)v13;
    v6 = v13 + 96;
    os_unfair_lock_lock(v13 + 96);
    v7 = atomic_load((unsigned int *)(v5 + 704));
    if (v7 == 1)
    {
      re::internal::AssetEntry::cancelResourceRequest_stateLocked((re::internal::AssetEntry *)v5);
      v8 = *(_QWORD *)(v5 + 400);
      if (v8 && !*(_DWORD *)(v8 + 16) && !*(_QWORD *)(v5 + 720))
        atomic_store(1u, (unsigned __int8 *)(*(_QWORD *)(v8 + 48) + 24));
      re::AssetManager::cancelLoadingAsset_entryStateLocked(this, (re::internal::AssetEntry *)v5, 1);
      v9 = (re *)re::DynamicString::format((re::DynamicString *)"AssetId %llu has been removed over the network.", (re::DynamicString *)v10, a2);
      re::AssetManager::putEntryInFailedState_entryStateLocked(v9, v5, 302, (uint64_t)v10);
      if (*(_QWORD *)&v10[0])
      {
        if ((BYTE8(v10[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v10[0] + 40))();
        memset(v10, 0, sizeof(v10));
      }
    }
    os_unfair_lock_unlock(v6);
    if (v11[0])
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&v12);
  }
}

void re::AssetManager::entryLoadStateChanged(uint64_t a1, uint64_t a2, int *a3)
{
  int v6;
  uint64_t v7;

  if (*a3 <= 3 && *a3 != 1)
    atomic_store(1u, (unsigned __int8 *)(a1 + 704));
  if (*(_BYTE *)(a1 + 1458))
  {
    v6 = *a3;
    if (*a3 == 3)
    {
      if (!re::internal::enableSignposts(0, 0))
        goto LABEL_16;
      goto LABEL_15;
    }
    if (v6 == 2)
    {
      if (!re::internal::enableSignposts(0, 0))
        goto LABEL_16;
      goto LABEL_15;
    }
    if (v6 == 1 && re::internal::enableSignposts(0, 0))
LABEL_15:
      kdebug_trace();
  }
LABEL_16:
  v7 = *(_QWORD *)(a2 + 112);
  if ((unint64_t)(v7 + 1) >= 2)
  {
    if (*(_QWORD *)(a1 + 1208))
      re::NetworkActionQueue::queueSyncActionShareLoadState((re::NetworkActionQueue *)(a1 + 768), v7);
  }
}

void re::AssetManager::enqueueUnreferencedUnloadRequest(os_unfair_lock_s *this, re::internal::AssetEntry *a2)
{
  NSObject *v4;
  char *v5;
  os_unfair_lock_s *v6;
  _anonymous_namespace_ *v7;
  char *v8;
  int v9;
  char *v10;
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  if (re::assetsHighFrequencyLoggingEnabled(void)::onceToken != -1)
    dispatch_once(&re::assetsHighFrequencyLoggingEnabled(void)::onceToken, &__block_literal_global_1);
  if (re::assetsHighFrequencyLoggingEnabled(void)::shouldLog)
  {
    v4 = *re::assetsLogObjects((re *)this);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      if ((*((_BYTE *)a2 + 168) & 1) != 0)
        v5 = (char *)*((_QWORD *)a2 + 22);
      else
        v5 = (char *)a2 + 169;
      v9 = 136315138;
      v10 = v5;
      _os_log_impl(&dword_224FE9000, v4, OS_LOG_TYPE_DEFAULT, "Enqueue unreferenced unload request: %s", (uint8_t *)&v9, 0xCu);
    }
  }
  v6 = this + 240;
  os_unfair_lock_lock(this + 240);
  v7 = (_anonymous_namespace_ *)&this[242];
  if (a2)
    v8 = (char *)a2 + 8;
  else
    v8 = 0;
  objc_initWeak((id *)&v9, v8);
  re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::add(v7, (id *)&v9);
  objc_destroyWeak((id *)&v9);
  os_unfair_lock_unlock(v6);
}

uint64_t *re::AssetManager::registerAssetType(uint64_t a1, char **a2, uint64_t *a3)
{
  uint64_t v6;
  re *v7;
  NSObject *v8;
  char *v9;
  uint64_t v10;
  uint64_t v12[5];
  uint8_t buf[4];
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 584));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1344));
  v6 = *(_QWORD *)(a1 + 1368);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 1344));
  if (v6)
  {
    v8 = *re::assetsLogObjects(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = *a2;
      *(_DWORD *)buf = 136315138;
      v14 = v9;
      _os_log_impl(&dword_224FE9000, v8, OS_LOG_TYPE_DEFAULT, "Registering an asset type (%s) while there are active asset loading background tasks. Tasks that are already active may fail if they expect the type to be registered. Also, this could lead to a race condition.", buf, 0xCu);
    }
  }
  (*(void (**)(uint64_t))(*(_QWORD *)*a3 + 112))(*a3);
  v10 = *(_QWORD *)(a1 + 1104);
  std::unique_ptr<void,std::function<void ()(void *)>>::unique_ptr[abi:nn180100](v12, a3);
  re::internal::AssetTypeRegistry::registerAssetType(v10, a2, v12);
  return std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](v12);
}

uint64_t *re::AssetManager::registerAssetType@<X0>(uint64_t a1@<X0>, char *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  re *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v13[5];
  uint8_t buf[4];
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 584));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 1344));
  v8 = *(_QWORD *)(a1 + 1368);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 1344));
  if (v8)
  {
    v10 = *re::assetsLogObjects(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      v15 = a2;
      _os_log_impl(&dword_224FE9000, v10, OS_LOG_TYPE_DEFAULT, "Registering an asset type (%s) while there are active asset loading background tasks. Tasks that are already active may fail if they expect the type to be registered. Also, this could lead to a race condition.", buf, 0xCu);
    }
  }
  v11 = *(_QWORD *)(a1 + 1104);
  std::unique_ptr<void,std::function<void ()(void *)>>::unique_ptr[abi:nn180100](v13, a3);
  re::internal::AssetTypeRegistry::registerOwnedAssetType(a2, v11, v13, a4);
  return std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](v13);
}

void re::AssetManager::registerCustomAssetType(re::AssetManager *this@<X0>, const re::CustomAssetRegistrationParameters *a2@<X1>, uint64_t a3@<X8>)
{
  re *v6;
  uint64_t *v7;
  _QWORD *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  char *v12;
  id v13;
  char v14[8];
  id v15;
  _QWORD *v16;
  _QWORD v17[4];
  uint64_t v18;
  _QWORD v19[5];

  v19[4] = *MEMORY[0x24BDAC8D0];
  re::CustomAssetRegistrationParameters::validate(a2, v14);
  if (v14[0])
  {
    v7 = re::globalAllocators(v6);
    v8 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7[2] + 32))(v7[2], 24, 8);
    v9 = (const void *)*((_QWORD *)a2 + 8);
    if (*((_QWORD *)a2 + 7))
      v10 = (const void *)*((_QWORD *)a2 + 7);
    else
      v10 = &__block_literal_global_0;
    *v8 = &off_24ED2BEB0;
    v8[1] = v10;
    CFRetain(v10);
    if (v9)
      v11 = v9;
    else
      v11 = &__block_literal_global_4;
    v8[2] = v11;
    CFRetain(v11);
    v19[3] = v19;
    if ((*((_QWORD *)a2 + 4) & 1) != 0)
      v12 = (char *)*((_QWORD *)a2 + 5);
    else
      v12 = (char *)a2 + 33;
    v18 = 0;
    v19[0] = &off_24ED2C9E0;
    v17[3] = v17;
    v16 = v8;
    v17[0] = &off_24ED2C9E0;
    re::AssetManager::registerAssetType((uint64_t)this, v12, (uint64_t *)&v16, a3);
    std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v16);
    std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](&v18);
  }
  else
  {
    v13 = v15;
    *(_BYTE *)a3 = 0;
    *(_QWORD *)(a3 + 8) = v13;
  }
  if (!v14[0])

}

BOOL re::AssetManager::registerAssetProvider(re::AssetManager *this, re::AssetProvider *a2)
{
  os_unfair_lock_s *v2;
  char *v3;
  char *v4;
  _BOOL8 v5;
  re::AssetProvider *v7;

  v2 = (os_unfair_lock_s *)*((_QWORD *)this + 149);
  v7 = a2;
  if (!a2)
    return re::AssetProviderRegistry::registerAssetProvider(v2, (uint64_t *)&v7);
  v3 = (char *)a2 + 8;
  v4 = (char *)a2 + 8;
  v5 = re::AssetProviderRegistry::registerAssetProvider(v2, (uint64_t *)&v7);

  return v5;
}

uint64_t re::AssetManager::getCompilerForExtension(re::AssetManager *this, const char *a2)
{
  return (***((uint64_t (****)(_QWORD, const char *))this + 139))(*((_QWORD *)this + 139), a2);
}

uint64_t `non-virtual thunk to're::AssetManager::getCompilerForExtension(re::AssetManager *this, const char *a2)
{
  return (***((uint64_t (****)(_QWORD, const char *))this + 138))(*((_QWORD *)this + 138), a2);
}

void ___ZN2re12AssetManager15makeLoadRequestEv_block_invoke(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  _QWORD v13[5];
  std::__shared_weak_count *v14;

  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 32);
      if (v5)
      {
        v13[0] = MEMORY[0x24BDAC760];
        v13[1] = 1174405120;
        v13[2] = ___ZN2re12AssetManager15makeLoadRequestEv_block_invoke_2;
        v13[3] = &__block_descriptor_tmp_61;
        v13[4] = v5;
        v14 = v3;
        p_shared_owners = (unint64_t *)&v3->__shared_owners_;
        do
          v7 = __ldxr(p_shared_owners);
        while (__stxr(v7 + 1, p_shared_owners));
        dispatch_sync(*(dispatch_queue_t *)(v5 + 1768), v13);
        dispatch_group_leave(*(dispatch_group_t *)(v5 + 1776));
        v8 = v14;
        if (v14)
        {
          v9 = (unint64_t *)&v14->__shared_owners_;
          do
            v10 = __ldaxr(v9);
          while (__stlxr(v10 - 1, v9));
          if (!v10)
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
      }
      v11 = (unint64_t *)&v4->__shared_owners_;
      do
        v12 = __ldaxr(v11);
      while (__stlxr(v12 - 1, v11));
      if (!v12)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void ___ZN2re12AssetManager15makeLoadRequestEv_block_invoke_2(uint64_t a1)
{
  re::AssetManager *v1;

  v1 = *(re::AssetManager **)(a1 + 32);
  if (!*((_BYTE *)v1 + 1410))
    re::AssetManager::updateScheduler(v1);
}

BOOL re::AssetManager::isLoading(re::AssetManager *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  os_unfair_lock_s *v7;
  os_unfair_lock_s *v8;
  uint64_t v9;
  uint64_t v10;

  dispatch_assert_queue_V2(*((dispatch_queue_t *)this + 73));
  os_unfair_lock_lock((os_unfair_lock_t)this + 336);
  v2 = *((_QWORD *)this + 171);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 336);
  if (v2)
    return 1;
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  v3 = *((_QWORD *)this + 47);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 16);
  if (v3)
    return 1;
  os_unfair_lock_lock((os_unfair_lock_t)this + 160);
  v5 = *((_QWORD *)this + 83);
  if (v5)
  {
    v6 = 0;
    while (1)
    {
      v7 = *(os_unfair_lock_s **)(*((_QWORD *)this + 86)
                                + 8 * ((unint64_t)(v6 + *((_QWORD *)this + 84)) % *((_QWORD *)this + 82)));
      v8 = v7 + 48;
      os_unfair_lock_lock(v7 + 48);
      LODWORD(v7) = v7[84];
      os_unfair_lock_unlock(v8);
      if (!(_DWORD)v7)
        break;
      if (v5 == ++v6)
        goto LABEL_8;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)this + 160);
    return 1;
  }
LABEL_8:
  os_unfair_lock_unlock((os_unfair_lock_t)this + 160);
  v9 = *((_QWORD *)this + 140);
  if (v9)
  {
    if (*(_DWORD *)(v9 + 92))
      return 1;
  }
  v10 = *((_QWORD *)this + 141);
  if (v10)
  {
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10) & 1) != 0)
      return 1;
  }
  return re::NetworkActionQueue::hasLoadActions((os_unfair_lock_s *)this + 192);
}

uint64_t re::AssetManager::assetByteSize(re::AssetManager *this, re::AssetHandle *a2)
{
  uint64_t v2;
  unsigned int v3;
  os_unfair_lock_s *v5;
  uint64_t v6;

  v2 = *((_QWORD *)a2 + 1);
  if (!v2)
    return 0;
  v3 = atomic_load((unsigned int *)(v2 + 704));
  if (v3 != 2)
    return 0;
  v5 = (os_unfair_lock_s *)*((_QWORD *)a2 + 1);
  os_unfair_lock_lock(v5 + 96);
  v6 = re::AssetManager::assetByteSize_entryLocked(this, (re::internal::AssetEntry *)v5);
  os_unfair_lock_unlock(v5 + 96);
  return v6;
}

uint64_t re::AssetManager::assetNonSharedDataByteSize(re::AssetManager *this, re::AssetHandle *a2)
{
  uint64_t v2;
  unsigned int v3;
  os_unfair_lock_s *v5;
  uint64_t v6;

  v2 = *((_QWORD *)a2 + 1);
  if (!v2)
    return 0;
  v3 = atomic_load((unsigned int *)(v2 + 704));
  if (v3 != 2)
    return 0;
  v5 = (os_unfair_lock_s *)*((_QWORD *)a2 + 1);
  os_unfair_lock_lock(v5 + 96);
  v6 = re::AssetManager::assetNonSharedDataByteSize_entryStateLocked(this, (re::internal::AssetEntry *)v5);
  os_unfair_lock_unlock(v5 + 96);
  return v6;
}

double re::AssetManager::gatherAssetStatisticsByType@<D0>(re::AssetManager *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v4;
  _anonymous_namespace_ *v5;
  _anonymous_namespace_ *v6;
  uint64_t v7;
  _anonymous_namespace_ *v8;
  _anonymous_namespace_ *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  _anonymous_namespace_ *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _anonymous_namespace_ *v26;
  uint64_t v27;
  uint64_t v28;
  int *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  BOOL v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unsigned int v48;
  _QWORD *v49;
  uint64_t v50;
  int v51;
  int v52;
  _BYTE v54[12];
  __int16 v55;
  int v56;
  __int16 v57;
  uint64_t v58;
  __int16 v59;
  uint64_t v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;

  v66 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2(*((dispatch_queue_t *)this + 73));
  v4 = *(unsigned int *)(*((_QWORD *)this + 138) + 28);
  a2[1] = v4;
  a2[2] = 0;
  if ((_DWORD)v4)
  {
                                                       + 32))();
    a2[2] = v6;
    if (!v6)
      goto LABEL_79;
    v8 = v6;
    v9 = v6;
    v10 = v4 - 1;
    if (v4 != 1)
    {
      v9 = v6;
      do
      {
        *(_QWORD *)v9 = 0;
        *((_QWORD *)v9 + 1) = 0;
        *((_DWORD *)v9 + 6) = 0;
        *((_QWORD *)v9 + 2) = 0;
        *((_OWORD *)v9 + 2) = 0uLL;
        *((_OWORD *)v9 + 3) = 0uLL;
        *((_OWORD *)v9 + 4) = 0uLL;
        *((_OWORD *)v9 + 5) = 0uLL;
        *((_QWORD *)v9 + 12) = 0;
        v9 = (_anonymous_namespace_ *)((char *)v9 + 104);
        --v10;
      }
      while (v10);
    }
    *(_QWORD *)v9 = 0;
    *((_QWORD *)v9 + 1) = 0;
    *((_DWORD *)v9 + 6) = 0;
    *((_QWORD *)v9 + 2) = 0;
    *((_OWORD *)v9 + 2) = 0u;
    *((_OWORD *)v9 + 3) = 0u;
    *((_OWORD *)v9 + 4) = 0u;
    *((_OWORD *)v9 + 5) = 0u;
    *((_QWORD *)v9 + 12) = 0;
  }
  else
  {
    v8 = 0;
  }
  v11 = *((_QWORD *)this + 138);
  v12 = *(unsigned int *)(v11 + 32);
  if ((_DWORD)v12)
  {
    v13 = 0;
    v14 = (int *)(*(_QWORD *)(v11 + 16) + 8);
    while (1)
    {
      v15 = *v14;
      v14 += 16;
      if (v15 < 0)
        break;
      if (v12 == ++v13)
      {
        LODWORD(v13) = *(_DWORD *)(v11 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v13) = 0;
  }
  if ((_DWORD)v12 != (_DWORD)v13)
  {
    v16 = 0;
    v17 = v13;
    while (v16 != v4)
    {
      *((_QWORD *)v8 + 13 * v16++ + 5) = *(_QWORD *)(*(_QWORD *)(v11 + 16) + (v17 << 6) + 16);
      if (v12 <= (int)v13 + 1)
        v18 = v13 + 1;
      else
        v18 = v12;
      while (1)
      {
        v17 = (v13 + 1);
        if (v18 - 1 == (_DWORD)v13)
          break;
        v6 = (_anonymous_namespace_ *)*(unsigned int *)(*(_QWORD *)(v11 + 16) + (v17 << 6) + 8);
        LODWORD(v13) = v13 + 1;
        v19 = v17;
        if ((v6 & 0x80000000) != 0)
          goto LABEL_24;
      }
      v19 = v18;
LABEL_24:
      LODWORD(v13) = v19;
      if ((_DWORD)v12 == v19)
        goto LABEL_25;
    }
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    v61 = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v54 = 136315906;
    *(_QWORD *)&v54[4] = "operator[]";
    v55 = 1024;
    v56 = 468;
    v57 = 2048;
    v58 = v4;
    v59 = 2048;
    v60 = v4;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_79:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
  }
LABEL_25:
  LODWORD(v63) = 0;
  v61 = 0u;
  v62 = 0u;
  *(_QWORD *)((char *)&v63 + 4) = 0x7FFFFFFFLL;
  if ((_DWORD)v4)
  {
    v20 = (_anonymous_namespace_ *)((char *)v8 + 104 * v4);
    do
    {
      v21 = *((_QWORD *)v8 + 5);
      *(_QWORD *)v54 = v8;
      v22 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (v21 ^ (v21 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v21 ^ (v21 >> 30))) >> 27));
      v23 = v22 ^ (v22 >> 31);
      if ((_QWORD)v61)
      {
        v24 = v23 % DWORD2(v62);
        v25 = *(unsigned int *)(*((_QWORD *)&v61 + 1) + 4 * v24);
        if ((_DWORD)v25 != 0x7FFFFFFF)
        {
          while (*(_QWORD *)(v62 + 32 * v25 + 16) != v21)
          {
            v25 = *(_DWORD *)(v62 + 32 * v25 + 8) & 0x7FFFFFFF;
            if ((_DWORD)v25 == 0x7FFFFFFF)
              goto LABEL_33;
          }
          goto LABEL_34;
        }
      }
      else
      {
        LODWORD(v24) = 0;
      }
LABEL_33:
      re::HashTable<re::AssetType const*,re::AssetTypeStatistics *,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::addAsMove((uint64_t)&v61, v24, v23, (_QWORD *)v8 + 5, v54);
      ++DWORD2(v63);
LABEL_34:
      v8 = (_anonymous_namespace_ *)((char *)v8 + 104);
    }
    while (v8 != v20);
  }
  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  v27 = *((unsigned int *)this + 26);
  v28 = 0;
  if ((_DWORD)v27)
  {
    v29 = (int *)(*((_QWORD *)this + 11) + 8);
    while (1)
    {
      v30 = *v29;
      v29 += 14;
      if (v30 < 0)
        break;
      if (v27 == ++v28)
      {
        LODWORD(v28) = *((_DWORD *)this + 26);
        break;
      }
    }
  }
  if ((_DWORD)v27 != (_DWORD)v28)
  {
    v31 = v28;
    v32 = *((_QWORD *)this + 11);
    do
    {
      v33 = *(_QWORD *)(v32 + 56 * v31 + 48);
      if (v33)
        v26 = (_anonymous_namespace_ *)(id)(v33 + 8);
      if ((_QWORD)v61)
      {
        v34 = *(_QWORD *)(v33 + 264);
        v35 = 0x94D049BB133111EBLL
            * ((0xBF58476D1CE4E5B9 * (v34 ^ (v34 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v34 ^ (v34 >> 30))) >> 27));
        v36 = (v35 ^ (v35 >> 31)) % DWORD2(v62);
        v37 = v62;
        v38 = *(unsigned int *)(*((_QWORD *)&v61 + 1) + 4 * v36);
        if ((_DWORD)v38 != 0x7FFFFFFF)
        {
          while (*(_QWORD *)(v62 + 32 * v38 + 16) != v34)
          {
            v38 = *(_DWORD *)(v62 + 32 * v38 + 8) & 0x7FFFFFFF;
            if (v38 == 0x7FFFFFFF)
              goto LABEL_50;
          }
          goto LABEL_51;
        }
      }
      else
      {
        v37 = v62;
      }
LABEL_50:
      v38 = 0x7FFFFFFFLL;
LABEL_51:
      v39 = *(_QWORD *)(v37 + 32 * v38 + 24);
      v40 = *(_QWORD *)(v39 + 8);
      v41 = *(_QWORD *)(v39 + 16);
      if (v41 >= v40)
      {
        v42 = v41 + 1;
        if (v40 < v41 + 1)
        {
          if (*(_QWORD *)v39)
          {
            v43 = 2 * v40;
            v44 = v40 == 0;
            v45 = 8;
            if (!v44)
              v45 = v43;
            if (v45 <= v42)
              v46 = v42;
            else
              v46 = v45;
            re::DynamicArray<re::AssetPath>::setCapacity((_QWORD *)v39, v46);
          }
          else
          {
            re::DynamicArray<re::AssetPath>::setCapacity((_QWORD *)v39, v42);
            ++*(_DWORD *)(v39 + 24);
          }
        }
        v41 = *(_QWORD *)(v39 + 16);
      }
      v47 = *(_QWORD *)(v39 + 32) + 80 * v41;
      *(_DWORD *)v47 = *(_DWORD *)(v33 + 32);
      re::DynamicString::DynamicString((re::DynamicString *)(v47 + 8), (const re::DynamicString *)(v33 + 40));
      re::DynamicString::DynamicString((re::DynamicString *)(v47 + 40), (const re::DynamicString *)(v33 + 72));
      *(_QWORD *)(v47 + 72) = *(_QWORD *)(v33 + 104);
      ++*(_QWORD *)(v39 + 16);
      ++*(_DWORD *)(v39 + 24);
      ++*(_QWORD *)(v39 + 48);
      v48 = atomic_load((unsigned int *)(v33 + 704));
      switch(v48)
      {
        case 0u:
          v49 = (_QWORD *)(v39 + 56);
          goto LABEL_67;
        case 1u:
          v49 = (_QWORD *)(v39 + 64);
          goto LABEL_67;
        case 2u:
          ++*(_QWORD *)(v39 + 72);
          *(_QWORD *)(v39 + 88) += *(_QWORD *)(v33 + 648);
          os_unfair_lock_lock((os_unfair_lock_t)(v33 + 384));
          v50 = re::AssetManager::assetByteSize_entryLocked(this, (re::internal::AssetEntry *)v33);
          os_unfair_lock_unlock((os_unfair_lock_t)(v33 + 384));
          v49 = (_QWORD *)(v39 + 96);
          goto LABEL_68;
        case 3u:
          v49 = (_QWORD *)(v39 + 80);
LABEL_67:
          v50 = 1;
LABEL_68:
          *v49 += v50;
          break;
        default:
          break;
      }

      v32 = *((_QWORD *)this + 11);
      if (*((_DWORD *)this + 26) <= (v28 + 1))
        v51 = v28 + 1;
      else
        v51 = *((_DWORD *)this + 26);
      while (1)
      {
        v31 = (v28 + 1);
        if (v51 - 1 == (_DWORD)v28)
          break;
        LODWORD(v28) = v28 + 1;
        v52 = v31;
        if ((*(_DWORD *)(v32 + 56 * v31 + 8) & 0x80000000) != 0)
          goto LABEL_76;
      }
      v52 = v51;
LABEL_76:
      LODWORD(v28) = v52;
    }
    while ((_DWORD)v27 != v52);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this + 16);
  return re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)&v61);
}

void re::AssetManager::findAssetHandlesOfType(os_unfair_lock_s *this@<X0>, const re::AssetType *a2@<X1>, uint64_t a3@<X8>)
{
  _anonymous_namespace_ *v6;
  uint64_t os_unfair_lock_opaque;
  uint64_t v8;
  int *v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  void *v16;
  id v17;
  const re::AssetType *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  int v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const re::AssetType **v28;
  const re::AssetType **v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint32_t v35;
  uint32_t v36;
  uint64_t v37;
  os_unfair_lock_s *lock;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  const char *v46;
  __int16 v47;
  int v48;
  __int16 v49;
  unint64_t v50;
  __int16 v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;

  v58 = *MEMORY[0x24BDAC8D0];
  lock = this + 16;
  os_unfair_lock_lock(this + 16);
  os_unfair_lock_opaque = this[26]._os_unfair_lock_opaque;
  if ((_DWORD)os_unfair_lock_opaque)
  {
    v8 = 0;
    v9 = (int *)(*(_QWORD *)&this[22]._os_unfair_lock_opaque + 8);
    while (1)
    {
      v10 = *v9;
      v9 += 14;
      if (v10 < 0)
        break;
      if (os_unfair_lock_opaque == ++v8)
      {
        LODWORD(v8) = this[26];
        break;
      }
    }
  }
  else
  {
    LODWORD(v8) = 0;
  }
  if ((_DWORD)os_unfair_lock_opaque == (_DWORD)v8)
  {
    v11 = 0;
  }
  else
  {
    v11 = 0;
    v12 = v8;
    v13 = *(_QWORD *)&this[22]._os_unfair_lock_opaque;
    v14 = this[26]._os_unfair_lock_opaque;
    do
    {
      v15 = *(_QWORD *)(v13 + 56 * v12 + 48);
      if (v15)
      {
        v16 = (void *)(v15 + 8);
        v17 = (id)(v15 + 8);
        v18 = *(const re::AssetType **)(v15 + 264);

        v14 = this[26]._os_unfair_lock_opaque;
        v13 = *(_QWORD *)&this[22]._os_unfair_lock_opaque;
      }
      else
      {
        v18 = (const re::AssetType *)MEMORY[0x108];
      }
      if (v18 == a2)
        ++v11;
      if (v14 <= (int)v8 + 1)
        v19 = v8 + 1;
      else
        v19 = v14;
      while (1)
      {
        v12 = (v8 + 1);
        if (v19 - 1 == (_DWORD)v8)
          break;
        LODWORD(v8) = v8 + 1;
        v20 = v12;
        if ((*(_DWORD *)(v13 + 56 * v12 + 8) & 0x80000000) != 0)
          goto LABEL_22;
      }
      v20 = v19;
LABEL_22:
      LODWORD(v8) = v20;
    }
    while ((_DWORD)os_unfair_lock_opaque != v20);
  }
  v42 = 0uLL;
  v43 = 0;
  v21 = this[26]._os_unfair_lock_opaque;
  if ((_DWORD)v21)
  {
    v22 = 0;
    v23 = (int *)(*(_QWORD *)&this[22]._os_unfair_lock_opaque + 8);
    while (1)
    {
      v24 = *v23;
      v23 += 14;
      if (v24 < 0)
        break;
      if (v21 == ++v22)
      {
        LODWORD(v22) = this[26];
        break;
      }
    }
  }
  else
  {
    LODWORD(v22) = 0;
  }
  if ((_DWORD)v21 != (_DWORD)v22)
  {
    v25 = 0;
    v26 = v22;
    v27 = *(_QWORD *)&this[22]._os_unfair_lock_opaque;
    do
    {
      v28 = *(const re::AssetType ***)(v27 + 56 * v26 + 48);
      if (v28)
        v29 = v28 + 1;
      if (v28[33] == a2)
      {
        re::AssetHandle::AssetHandle(&v39, (re::internal::AssetEntry *)v28);
        v30 = *((_QWORD *)&v42 + 1);
        if (*((_QWORD *)&v42 + 1) <= v25)
        {
          v44 = 0;
          v56 = 0u;
          v57 = 0u;
          v55 = 0u;
          v53 = 0u;
          v54 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          v45 = 136315906;
          v46 = "operator[]";
          v47 = 1024;
          v48 = 468;
          v49 = 2048;
          v50 = v25;
          v51 = 2048;
          v52 = v30;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
        }
        v31 = (uint64_t *)(v43 + 24 * v25);
        v32 = v31[1];
        v31[1] = v40;
        v40 = v32;
        v33 = *v31;
        *v31 = 0;
        *v31 = v39;
        v39 = v33;
        v34 = v31[2];
        v31[2] = v41;
        v41 = v34;
        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v39);
        ++v25;
      }

      v27 = *(_QWORD *)&this[22]._os_unfair_lock_opaque;
      if (this[26]._os_unfair_lock_opaque <= (v22 + 1))
        v35 = v22 + 1;
      else
        v35 = this[26]._os_unfair_lock_opaque;
      while (1)
      {
        v26 = (v22 + 1);
        if (v35 - 1 == (_DWORD)v22)
          break;
        LODWORD(v22) = v22 + 1;
        v36 = v26;
        if ((*(_DWORD *)(v27 + 56 * v26 + 8) & 0x80000000) != 0)
          goto LABEL_43;
      }
      v36 = v35;
LABEL_43:
      LODWORD(v22) = v36;
    }
    while ((_DWORD)v21 != v36);
  }
  *(_OWORD *)a3 = v42;
  v37 = v43;
  v43 = 0;
  v42 = 0uLL;
  *(_QWORD *)(a3 + 16) = v37;
  re::FixedArray<re::AssetHandle>::deinit(&v42);
  os_unfair_lock_unlock(lock);
}

uint64_t re::AssetManager::enableBackgroundLoading(uint64_t this, char a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(this + 1096);
  *(_BYTE *)(v2 + 4) = a2;
  *(_BYTE *)(v2 + 5) = a2;
  return this;
}

uint64_t re::AssetManager::enableNetworkLoadingRedirector(uint64_t a1, int a2, const char *a3, const char *a4)
{
  _anonymous_namespace_ *v7;
  uint64_t result;
  int v9;
  uint64_t v10;
  char v11;
  const char *v12;

  v12 = a4;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 584));
  v9 = a2;
  re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::addOrReplace<char const*&>(a1 + 1144, (re::DynamicString *)&v9, &v12);
  result = v10;
  if (v10)
  {
    if ((v11 & 1) != 0)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 40))(v10);
  }
  return result;
}

uint64_t re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::addOrReplace<char const*&>(uint64_t a1, re::DynamicString *a2, const char **a3)
{
  unsigned int v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  _anonymous_namespace_ *v11;
  _OWORD *v12;
  _anonymous_namespace_ *v13;
  re::DynamicString *v14;
  const char *v15;
  int v17[2];
  int v18[2];
  uint64_t v19;

  *(_QWORD *)v17 = 0;
  *(_QWORD *)v18 = 0;
  v19 = 0;
  re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::findEntry(a1, a2, (uint64_t)v17);
  v6 = v18[1];
  if (v18[1] == 0x7FFFFFFF)
  {
    v7 = re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::addEmplace<char const*&>(a1, v18[0], *(unint64_t *)v17, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v8 = (uint64_t *)(a1 + 16);
  }
  else
  {
    v8 = (uint64_t *)(a1 + 16);
    v9 = *(_QWORD *)(a1 + 16);
    v10 = v9 + 88 * v18[1];
    v13 = *(_anonymous_namespace_ **)(v10 + 56);
    v12 = (_OWORD *)(v10 + 56);
    v11 = v13;
    if (v13)
    {
      if ((*(_BYTE *)(v9 + 88 * v18[1] + 64) & 1) != 0)
        v11 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, _QWORD))(*(_QWORD *)v11 + 40))(v11, *(_QWORD *)(v9 + 88 * v18[1] + 72));
      *v12 = 0u;
      v12[1] = 0u;
      v9 = *v8;
    }
    v14 = (re::DynamicString *)(v9 + 88 * v6 + 56);
    v15 = *a3;
    ++*(_DWORD *)(a1 + 40);
    v7 = v18[1];
  }
  return *v8 + 88 * v7 + 56;
}

uint64_t re::AssetManager::disableNetworkLoadingRedirector(uint64_t a1, int a2, const char *a3)
{
  _anonymous_namespace_ *v6;
  uint64_t result;
  int v8;
  uint64_t v9;
  char v10;

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 584));
  v8 = a2;
  re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::remove(a1 + 1144, &v8);
  result = v9;
  if (v9)
  {
    if ((v10 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v9 + 40))();
  }
  return result;
}

BOOL re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::remove(uint64_t a1, _DWORD *a2)
{
  unsigned int v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v11 = 0;
  v12 = 0;
  v13 = 0;
  re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::findEntry(a1, a2, (uint64_t)&v11);
  v3 = HIDWORD(v12);
  if (HIDWORD(v12) != 0x7FFFFFFF)
  {
    v4 = *(_QWORD *)(a1 + 16);
    v5 = *(_DWORD *)(v4 + 88 * HIDWORD(v12) + 8) & 0x7FFFFFFF;
    if ((_DWORD)v13 == 0x7FFFFFFF)
    {
      *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v12) = v5;
      v6 = HIDWORD(v12);
    }
    else
    {
      *(_DWORD *)(v4 + 88 * v13 + 8) = *(_DWORD *)(v4 + 88 * v13 + 8) & 0x80000000 | v5;
      v6 = v3;
    }
    re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 16) + 88 * v6);
    v7 = HIDWORD(v12);
    v8 = *(_QWORD *)(a1 + 16) + 88 * HIDWORD(v12);
    *(_DWORD *)(v8 + 8) = *(_DWORD *)(v8 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
    --*(_DWORD *)(a1 + 28);
    v9 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = v7;
    *(_DWORD *)(a1 + 40) = v9;
  }
  return v3 != 0x7FFFFFFF;
}

void re::AssetManager::findDependencies(re::AssetManager *this@<X0>, const re::internal::AssetEntry *a2@<X1>, uint64_t a3@<X8>)
{
  os_unfair_lock_s *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;

  v6 = (os_unfair_lock_s *)((char *)a2 + 384);
  os_unfair_lock_lock((os_unfair_lock_t)a2 + 96);
  v7 = atomic_load((unsigned int *)a2 + 176);
  if (v7 == 2)
  {
    v8 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*((_QWORD *)this + 138), *((_QWORD *)a2 + 33));
    v9 = re::internal::AssetEntry::assetPointer(a2);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 104))(v8, v9);
  }
  else
  {
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = 0;
    *(_DWORD *)(a3 + 24) = 0;
  }
  os_unfair_lock_unlock(v6);
}

void re::AssetManager::deviceAssetPath(uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, uint64_t a4@<X3>, _BYTE *a5@<X8>)
{
  uint64_t v6;
  os_unfair_lock_s *v10;
  uint64_t v11;
  _anonymous_namespace_ *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  int v16;
  char *v17;
  uint64_t v18;
  _BYTE v19[8];
  uint64_t v20;
  char v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  __int128 v34;
  __int128 v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v6 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 112);
  if ((unint64_t)(v6 + 1) < 2
    || (v10 = (os_unfair_lock_s *)(a1 + 64),
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64)),
        v22 = v6,
        v11 = re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 120, &v22), os_unfair_lock_unlock(v10), !v11))
  {
LABEL_2:
    *a5 = 0;
    return;
  }
  v37 = 0;
  v38 = 0;
  v39 = 0;
  re::DynamicString::setCapacity(&v36, 0);
  v13 = *(_QWORD *)(v11 + 16);
  if (!v13)
  {
LABEL_30:
    if (v36)
    {
      if ((v37 & 1) != 0)
        (*(void (**)(uint64_t *, uint64_t))(*v36 + 40))(v36, v38);
    }
    goto LABEL_2;
  }
  v14 = *(uint64_t **)(v11 + 32);
  v15 = 144 * v13;
  while (1)
  {
    re::DynamicString::DynamicString((re::DynamicString *)&v22, (const re::DynamicString *)v14);
    re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v24, v14 + 4);
    re::DynamicArray<BOOL>::DynamicArray((uint64_t)&v29, v14 + 9);
    re::DynamicString::DynamicString((re::DynamicString *)&v34, (const re::DynamicString *)(v14 + 14));
    re::AssetProviderRegistry::deviceAssetPath(*(os_unfair_lock_s **)(a1 + 1192), (uint64_t)&v22, a4, v19);
    v16 = v19[0];
    if (v19[0] && (a3 & 1) == 0)
    {
      if ((BYTE8(v34) & 1) != 0)
        v17 = (char *)v35;
      else
        v17 = (char *)&v34 + 9;
      v18 = re::internal::AssetTypeRegistry::assetTypeWithName(*(re::internal::AssetTypeRegistry **)(a1 + 1104), v17);
      re::AssetPath::updateWithCompiledExtension((char *)&v20, v18);
      v16 = v19[0];
    }
    if (v16)
      break;
    if ((_QWORD)v34)
    {
      if ((BYTE8(v34) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v34 + 40))();
      v34 = 0u;
      v35 = 0u;
    }
    if (v29)
    {
      if (v33)
        (*(void (**)(void))(*(_QWORD *)v29 + 40))();
      v33 = 0;
      v30 = 0;
      v31 = 0;
      v29 = 0;
      ++v32;
    }
    if (v24)
    {
      if (v28)
        (*(void (**)(void))(*(_QWORD *)v24 + 40))();
      v28 = 0;
      v25 = 0;
      v26 = 0;
      v24 = 0;
      ++v27;
    }
    if (v22 && (v23 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v22 + 40))();
    v14 += 18;
    v15 -= 144;
    if (!v15)
      goto LABEL_30;
  }
  *a5 = 1;
  re::DynamicString::DynamicString((re::DynamicString *)(a5 + 8), (const re::DynamicString *)&v20);
  if (v19[0] && v20 && (v21 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v20 + 40))();
  if ((_QWORD)v34)
  {
    if ((BYTE8(v34) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v34 + 40))();
    v34 = 0u;
    v35 = 0u;
  }
  if (v29)
  {
    if (v33)
      (*(void (**)(void))(*(_QWORD *)v29 + 40))();
    v33 = 0;
    v30 = 0;
    v31 = 0;
    v29 = 0;
    ++v32;
  }
  if (v24)
  {
    if (v28)
      (*(void (**)(void))(*(_QWORD *)v24 + 40))();
    v28 = 0;
    v25 = 0;
    v26 = 0;
    v24 = 0;
    ++v27;
  }
  if (v22 && (v23 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v22 + 40))();
  if (v36 && (v37 & 1) != 0)
    (*(void (**)(uint64_t *, uint64_t))(*v36 + 40))(v36, v38);
}

uint64_t re::AssetManager::getAssetCompatibilityService(re::AssetManager *this)
{
  return *((_QWORD *)this + 153);
}

uint64_t re::AssetManager::getBlockingAssetLoadRequestService(re::AssetManager *this)
{
  return *((_QWORD *)this + 152);
}

void re::AssetManager::registerExplicitDependency(re::AssetManager *this, re::internal::AssetEntry **a2, re::internal::AssetEntry **a3)
{
  re::internal::AssetEntry::addExplicitParentDependency(a3[1], a2[1]);
}

void re::AssetManager::registeredAssetTypes(re::AssetManager *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  int v21;
  int v22;

  a2[2] = 0;
  v3 = *((_QWORD *)this + 138);
  v4 = *(unsigned int *)(v3 + 28);
  a2[1] = v4;
  if ((_DWORD)v4)
  {
    v5 = 2 * v4;
    a2[2] = v6;
    if (!v6)
      goto LABEL_26;
    v8 = v6;
    v9 = v6;
    if ((_DWORD)v4 != 1)
    {
      bzero(v6, v5 * 8 - 16);
      v9 = &v8[v5 - 2];
    }
    *v9 = 0;
    v9[1] = 0;
  }
  else
  {
    v8 = 0;
  }
  v10 = *(unsigned int *)(v3 + 32);
  if ((_DWORD)v10)
  {
    v11 = 0;
    v12 = (int *)(*(_QWORD *)(v3 + 16) + 8);
    while (1)
    {
      v13 = *v12;
      v12 += 16;
      if (v13 < 0)
        break;
      if (v10 == ++v11)
      {
        LODWORD(v11) = *(_DWORD *)(v3 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v11) = 0;
  }
  if ((_DWORD)v10 != (_DWORD)v11)
  {
    v14 = 0;
    v15 = v11;
    v16 = *(_QWORD *)(v3 + 16);
    while (1)
    {
      v17 = v16 + (v15 << 6);
      v18 = *(_QWORD *)(v17 + 16);
      v19 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v17 + 24) + 112))(*(_QWORD *)(v17 + 24));
      if (v14 == v4)
        break;
      v20 = &v8[2 * v14];
      *v20 = v18;
      v20[1] = v19;
      ++v14;
      v16 = *(_QWORD *)(v3 + 16);
      if (*(_DWORD *)(v3 + 32) <= (v11 + 1))
        v21 = v11 + 1;
      else
        v21 = *(_DWORD *)(v3 + 32);
      while (1)
      {
        v15 = (v11 + 1);
        if (v21 - 1 == (_DWORD)v11)
          break;
        LODWORD(v11) = v11 + 1;
        v22 = v15;
        if ((*(_DWORD *)(v16 + (v15 << 6) + 8) & 0x80000000) != 0)
          goto LABEL_23;
      }
      v22 = v21;
LABEL_23:
      LODWORD(v11) = v22;
      if ((_DWORD)v10 == v22)
        return;
    }
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_26:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::AssetManager::pathStringfromAssetId(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  _anonymous_namespace_ *v6;
  uint64_t *v7;
  uint64_t result;
  int v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v9 = 0;
  v12 = 0;
  v13 = 0;
  v11 = 0;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v10, 0);
  *((_QWORD *)&v14 + 1) = 0;
  v15 = 0uLL;
  re::DynamicString::setCapacity(&v14, 0);
  v16 = 0;
  re::AssetPath::initAssetIdAssetPath((uint64_t)&v9, a2, a3);
  v7 = v10;
  *((_QWORD *)a1 + 2) = 0;
  *((_QWORD *)a1 + 3) = 0;
  *(_QWORD *)a1 = v7;
  *((_QWORD *)a1 + 1) = 0;
  re::DynamicString::setCapacity(a1, 0);
  re::AssetPath::fullAssetPath((re::DynamicString *)&v9, a1);
  if ((_QWORD)v14)
  {
    if ((BYTE8(v14) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v14 + 40))();
    v14 = 0u;
    v15 = 0u;
  }
  result = (uint64_t)v10;
  if (v10)
  {
    if ((v11 & 1) != 0)
      return (*(uint64_t (**)(void))(*v10 + 40))();
  }
  return result;
}

re::DynamicString *re::AssetManager::lookupAssetPathString@<X0>(os_unfair_lock_s *this@<X0>, const re::DynamicString *a2@<X1>, const re::AssetPath *a3@<X2>, uint64_t a4@<X8>)
{
  os_unfair_lock_s *v8;
  uint64_t v9;
  re::AssetPath *v10;
  re::DynamicString *result;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  _anonymous_namespace_ *v18;
  int v19;
  const char *v20;
  const char *v21;
  char *v22;
  char *v23;
  _BYTE *v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  _BYTE *v29;
  uint64_t v30;
  _anonymous_namespace_ *v31;
  uint64_t *v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE *v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  _BYTE *v45;
  __int128 v46;
  _BYTE *v47;
  uint64_t v48;
  char *v49;
  _BYTE *v50;
  __int128 v51;
  _BYTE *v52;
  uint64_t v53;
  char v54[8];
  uint64_t v55;
  uint64_t v56;
  char v57;
  _BYTE v58[7];
  _BYTE *v59;
  _BYTE v60[24];
  uint64_t v61;
  __int128 v62;
  _BYTE *v63;
  uint64_t v64;
  __int128 v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  __int128 v69;
  uint64_t v70;
  char v71;
  _BYTE v72[47];
  re::AssetType *v73;
  char v74[8];
  int v75;
  unint64_t v76;
  char v77;
  _BYTE v78[55];
  uint64_t v79;
  int v80;
  uint64_t v81;
  char v82;
  _BYTE v83[23];
  __int128 v84;
  __int128 v85;

  v8 = this + 16;
  os_unfair_lock_lock(this + 16);
  v9 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&this[18], (uint64_t)a2);
  os_unfair_lock_unlock(v8);
  if (v9)
  {
    result = re::DynamicString::DynamicString((re::DynamicString *)&v68, a2);
    *(_BYTE *)a4 = 1;
    v12 = v70;
    *(_QWORD *)(a4 + 8) = v68;
    *(_QWORD *)(a4 + 32) = v12;
    *(_OWORD *)(a4 + 16) = v69;
    return result;
  }
  re::AssetPath::invalidAssetPath(v10, (uint64_t)&v80);
  if ((*((_QWORD *)a2 + 1) & 1) != 0)
    v13 = (char *)*((_QWORD *)a2 + 2);
  else
    v13 = (char *)a2 + 9;
  re::AssetManager::parseAssetPath((re::AssetManager *)this, v13, (const re::AssetPath *)&v80, 0, (uint64_t)v74);
  if (v74[0])
  {
    *(_QWORD *)&v60[16] = 0;
    v61 = 0;
    *(_OWORD *)v60 = v76;
    re::DynamicString::setCapacity(v60, 0);
    re::AssetPath::fullAssetPath((re::DynamicString *)&v75, (re::DynamicString *)v60);
    os_unfair_lock_lock(v8);
    v14 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&this[18], (uint64_t)v60);
    os_unfair_lock_unlock(v8);
    if (v14)
    {
      re::DynamicString::DynamicString((re::DynamicString *)&v68, (const re::DynamicString *)v60);
      *(_BYTE *)a4 = 1;
      v15 = v70;
      *(_QWORD *)(a4 + 8) = v68;
      *(_QWORD *)(a4 + 32) = v15;
      *(_OWORD *)(a4 + 16) = v69;
LABEL_10:
      if (*(_QWORD *)v60 && (v60[8] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)v60 + 40))();
      goto LABEL_45;
    }
    v19 = v75;
    if (v75 == v80
      && ((v77 & 1) != 0 ? (v20 = *(const char **)&v78[7]) : (v20 = v78),
          (v82 & 1) != 0 ? (v21 = *(const char **)&v83[7]) : (v21 = v83),
          !strcmp(v20, v21)))
    {
      if ((*((_BYTE *)a2 + 8) & 1) != 0)
        v16 = (char *)*((_QWORD *)a2 + 2);
      else
        v16 = (char *)a2 + 9;
    }
    else
    {
      if (v19 != 5)
      {
        v31 = (_anonymous_namespace_ *)re::AssetManager::convertToLoadDescriptor(this, (const re::AssetPath *)&v75, &v68);
        if ((_BYTE)v68
          && (os_unfair_lock_lock(v8),
              v32 = (uint64_t *)re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::tryGet((uint64_t)&this[42], (uint64_t)&v69), os_unfair_lock_unlock(v8), v32))
        {
          re::AssetManager::pathStringfromAssetId((_anonymous_namespace_ *)&v65, *v32, v79);
          v33 = v65;
          v34 = v66;
          v35 = v67;
          *(_BYTE *)a4 = 1;
          *(_OWORD *)(a4 + 8) = v33;
          *(_QWORD *)(a4 + 24) = v34;
          *(_QWORD *)(a4 + 32) = v35;
        }
        else
        {
          re::DynamicString::operator+((re::DynamicString *)&v62, (uint64_t)a2, (re::DynamicString *)&v65);
          v41 = v65;
          v65 = 0uLL;
          v42 = v66;
          v43 = v67;
          v66 = 0;
          v67 = 0;
          *(_BYTE *)a4 = 0;
          *(_OWORD *)(a4 + 8) = v41;
          *(_QWORD *)(a4 + 24) = v42;
          *(_QWORD *)(a4 + 32) = v43;
          if ((_QWORD)v62 && (BYTE8(v62) & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v62 + 40))();
        }
        re::Optional<re::AssetLoadDescriptor>::~Optional((uint64_t)&v68);
        goto LABEL_10;
      }
      if ((*((_QWORD *)a2 + 1) & 1) != 0)
        v16 = (char *)*((_QWORD *)a2 + 2);
      else
        v16 = (char *)a2 + 9;
      v22 = strrchr(v16, 47);
      if (v22)
        v16 = v22 + 1;
    }
    if (*(_QWORD *)v60 && (v60[8] & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)v60 + 40))();
  }
  else if ((*((_BYTE *)a2 + 8) & 1) != 0)
  {
    v16 = (char *)*((_QWORD *)a2 + 2);
  }
  else
  {
    v16 = (char *)a2 + 9;
  }
  re::AssetManager::parseAssetPath((re::AssetManager *)this, v16, a3, 0, (uint64_t)&v68);
  if ((_BYTE)v68)
  {
    v66 = 0;
    v67 = 0;
    v65 = *((unint64_t *)&v69 + 1);
    re::DynamicString::setCapacity(&v65, 0);
    re::AssetPath::fullAssetPath((re::DynamicString *)&v69, (re::DynamicString *)&v65);
    os_unfair_lock_lock(v8);
    v17 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&this[18], (uint64_t)&v65);
    os_unfair_lock_unlock(v8);
    if (v17)
    {
      re::DynamicString::DynamicString((re::DynamicString *)v60, (const re::DynamicString *)&v65);
      *(_BYTE *)a4 = 1;
      *(_QWORD *)(a4 + 8) = *(_QWORD *)v60;
      *(_QWORD *)(a4 + 32) = v61;
      *(_OWORD *)(a4 + 16) = *(_OWORD *)&v60[8];
      goto LABEL_19;
    }
    if (*(_DWORD *)a3 == 8)
    {
      re::AssetManager::resolveChildLoadDescriptors((re::AssetManager *)this, v16, v73, a3, (uint64_t)v60);
      if (v60[0])
      {
        re::AssetManager::lookupExistingImmutableAssetId(this, (uint64_t)&v60[8], (uint64_t)v54);
        if (v54[0])
        {
          re::AssetManager::pathStringfromAssetId((_anonymous_namespace_ *)&v62, v55, (uint64_t)v73);
          v28 = v62;
          v29 = v63;
          v30 = v64;
          *(_BYTE *)a4 = 1;
          *(_OWORD *)(a4 + 8) = v28;
          *(_QWORD *)(a4 + 24) = v29;
          *(_QWORD *)(a4 + 32) = v30;
        }
        else
        {
          if ((*((_QWORD *)a2 + 1) & 1) != 0)
            v49 = (char *)*((_QWORD *)a2 + 2);
          else
            v49 = (char *)a2 + 9;
          re::AssetPath::fullAssetPath(a3, (re::DynamicString *)&v56);
          if ((v57 & 1) != 0)
            v50 = v59;
          else
            v50 = v58;
          re::DynamicString::format((re::DynamicString *)"Failed to find a registered AssetId for load descriptors resolved from relative path %s from parent %s. The resolved load descriptors must already be registered with an AssetId.", (re::DynamicString *)&v62, v49, v50);
          v51 = v62;
          v52 = v63;
          v53 = v64;
          *(_BYTE *)a4 = 0;
          *(_OWORD *)(a4 + 8) = v51;
          *(_QWORD *)(a4 + 24) = v52;
          *(_QWORD *)(a4 + 32) = v53;
          if (v56 && (v57 & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v56 + 40))();
        }
        re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)&v60[8]);
        goto LABEL_19;
      }
      if ((*((_QWORD *)a2 + 1) & 1) != 0)
        v44 = (char *)*((_QWORD *)a2 + 2);
      else
        v44 = (char *)a2 + 9;
      re::AssetPath::fullAssetPath(a3, (re::DynamicString *)&v56);
      if ((v57 & 1) != 0)
        v45 = v59;
      else
        v45 = v58;
      re::DynamicString::format((re::DynamicString *)"Failed to resolve child load descriptors with relative path %s from parent %s.", (re::DynamicString *)&v62, v44, v45);
      v46 = v62;
      v47 = v63;
      v48 = v64;
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(a4 + 8) = v46;
      *(_QWORD *)(a4 + 24) = v47;
      *(_QWORD *)(a4 + 32) = v48;
      v39 = v56;
      if (v56 && (v57 & 1) != 0)
      {
        v40 = v59;
        goto LABEL_82;
      }
    }
    else
    {
      re::DynamicString::operator+((re::DynamicString *)&v62, (uint64_t)a2, (re::DynamicString *)v60);
      v36 = *(_OWORD *)v60;
      memset(v60, 0, sizeof(v60));
      v37 = *(_QWORD *)&v60[16];
      v38 = v61;
      v61 = 0;
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(a4 + 8) = v36;
      *(_QWORD *)(a4 + 24) = v37;
      *(_QWORD *)(a4 + 32) = v38;
      v39 = v62;
      if ((_QWORD)v62 && (BYTE8(v62) & 1) != 0)
      {
        v40 = v63;
LABEL_82:
        (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v39 + 40))(v39, v40);
      }
    }
LABEL_19:
    if ((_QWORD)v65 && (BYTE8(v65) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v65 + 40))();
    goto LABEL_44;
  }
  if ((*((_QWORD *)a2 + 1) & 1) != 0)
    v23 = (char *)*((_QWORD *)a2 + 2);
  else
    v23 = (char *)a2 + 9;
  if ((v71 & 1) != 0)
    v24 = *(_BYTE **)&v72[7];
  else
    v24 = v72;
  re::DynamicString::format((re::DynamicString *)"Unexpected error parsing unknown path '%s': %s", (re::DynamicString *)v60, v23, v24);
  v25 = *(_OWORD *)v60;
  v26 = *(_QWORD *)&v60[16];
  v27 = v61;
  *(_BYTE *)a4 = 0;
  *(_OWORD *)(a4 + 8) = v25;
  *(_QWORD *)(a4 + 24) = v26;
  *(_QWORD *)(a4 + 32) = v27;
LABEL_44:
  re::Result<re::AssetPath,re::DetailedError>::~Result((uint64_t)&v68);
LABEL_45:
  re::Result<re::AssetPath,re::DetailedError>::~Result((uint64_t)v74);
  if ((_QWORD)v84)
  {
    if ((BYTE8(v84) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v84 + 40))();
    v84 = 0u;
    v85 = 0u;
  }
  result = (re::DynamicString *)v81;
  if (v81)
  {
    if ((v82 & 1) != 0)
      return (re::DynamicString *)(*(uint64_t (**)(void))(*(_QWORD *)v81 + 40))();
  }
  return result;
}

re::DynamicString *re::AssetManager::getDescription_assetTablesLocked@<X0>(re::AssetManager *this@<X0>, const re::internal::AssetEntry *a2@<X1>, char a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v6;
  const char *v7;
  re::DynamicString *result;
  re::AssetManager *v10;
  re::AssetManager *v11;
  const char *v12;
  size_t v13;
  _anonymous_namespace_ *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  const char *v20;
  const char *v21;
  size_t v22;
  size_t v23;
  size_t v24;
  uint64_t ProviderForScheme;
  const char *v26;
  size_t v27;
  re::DynamicString *v28;
  uint64_t *v29;
  unint64_t v30;
  const char *v31;
  uint64_t v32;

  v6 = *((_QWORD *)a2 + 14);
  if ((unint64_t)(v6 + 1) >= 2
    && (v10 = this,
        v29 = (uint64_t *)*((_QWORD *)a2 + 14),
        (this = (re::AssetManager *)re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 120, (uint64_t *)&v29)) != 0))
  {
    v11 = this;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    re::DynamicString::setCapacity((_QWORD *)a4, 0);
    if ((a3 & 1) == 0)
    {
      re::DynamicString::format((re::DynamicString *)"%llu ", (re::DynamicString *)&v29, v6);
      re::DynamicString::operator=((re::DynamicString *)a4, (re::DynamicString *)&v29);
      if (v29)
      {
        if ((v30 & 1) != 0)
          (*(void (**)(void))(*v29 + 40))();
      }
    }
    v12 = (const char *)**((_QWORD **)a2 + 33);
    v13 = strlen(v12);
    re::DynamicString::append((re::DynamicString *)a4, v12, v13);
    v14 = (_anonymous_namespace_ *)re::DynamicString::append((re::DynamicString *)a4, " ", 1uLL);
    v30 = 0;
    v31 = 0;
    v32 = 0;
    re::DynamicString::setCapacity(&v29, 0);
    v15 = *((_QWORD *)v11 + 2);
    if (v15)
    {
      v16 = 144 * v15;
      v17 = v15 - 1;
      v18 = *((_QWORD *)v11 + 4);
      do
      {
        re::DynamicString::append((re::DynamicString *)a4, "(", 1uLL);
        v19 = *(_QWORD *)(v18 + 8);
        v20 = (const char *)(v18 + 9);
        if ((v19 & 1) != 0)
          v21 = *(const char **)(v18 + 16);
        else
          v21 = (const char *)(v18 + 9);
        v22 = v19 >> 1;
        v23 = v19 >> 1;
        if ((*(_QWORD *)(v18 + 8) & 1) != 0)
          v24 = v22;
        else
          v24 = v23;
        re::DynamicString::append((re::DynamicString *)a4, v21, v24);
        re::DynamicString::append((re::DynamicString *)a4, ")", 1uLL);
        if ((*(_BYTE *)(v18 + 8) & 1) != 0)
          v20 = *(const char **)(v18 + 16);
        ProviderForScheme = re::AssetProviderRegistry::tryGetProviderForScheme(*((os_unfair_lock_s **)v10 + 149), v20);
        if (ProviderForScheme)
        {
          (*(void (**)(uint64_t, uint64_t, uint64_t **))(*(_QWORD *)ProviderForScheme + 72))(ProviderForScheme, v18, &v29);
          if ((v30 & 1) != 0)
            v26 = v31;
          else
            v26 = (char *)&v30 + 1;
          if ((v30 & 1) != 0)
            v27 = v30 >> 1;
          else
            v27 = v30 >> 1;
          v28 = (re::DynamicString *)a4;
        }
        else
        {
          v28 = (re::DynamicString *)a4;
          v26 = "<no registered provider>";
          v27 = 24;
        }
        re::DynamicString::append(v28, v26, v27);
        if (v17)
          re::DynamicString::append((re::DynamicString *)a4, ";", 1uLL);
        v18 += 144;
        --v17;
        v16 -= 144;
      }
      while (v16);
    }
    result = (re::DynamicString *)v29;
    if (v29 && (v30 & 1) != 0)
      return (re::DynamicString *)(*(uint64_t (**)(void))(*v29 + 40))();
  }
  else
  {
    if ((*((_QWORD *)a2 + 17) & 1) != 0)
      v7 = (const char *)*((_QWORD *)a2 + 18);
    else
      v7 = (char *)a2 + 137;
  }
  return result;
}

uint64_t re::AssetManager::finalizeAssetLoad(re::AssetManager *this, void *a2, void *a3, char *a4)
{
  uint64_t v7[3];

  re::AssetManager::assetHandle(this, a4, 1, 0, v7);
  re::AssetManager::processAssetPointer(this, a3, (re::internal::AssetEntry *)v7[1]);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v7);
  return 1;
}

uint64_t `non-virtual thunk to're::AssetManager::finalizeAssetLoad(re::AssetManager *this, void *a2, void *a3, char *a4)
{
  re::AssetManager::finalizeAssetLoad((re::AssetManager *)((char *)this - 16), a2, a3, a4);
  return 1;
}

void re::AssetManager::setDeserializedAssetPathRemapping(os_unfair_lock_s *this, const char *a2, const char *a3)
{
  os_unfair_lock_s *v6;
  _anonymous_namespace_ *v7;
  const char *v8;
  uint64_t v9;
  char v10;

  v8 = a3;
  v6 = this + 16;
  os_unfair_lock_lock(this + 16);
  if (a3)
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addInternal<char const*&>((uint64_t)&this[100], (re::DynamicString *)&v9, 2, &v8);
  else
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove((uint64_t)&this[100], (uint64_t)&v9);
  if (v9 && (v10 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v9 + 40))();
  LOBYTE(this[144]._os_unfair_lock_opaque) = this[107]._os_unfair_lock_opaque != 0;
  os_unfair_lock_unlock(v6);
}

void re::AssetManager::fromPeerID(os_unfair_lock_s *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  _BYTE v8[8];
  uint64_t v9;
  re::internal::AssetEntry *v10;

  v6 = this + 16;
  os_unfair_lock_lock(this + 16);
  re::AssetManager::lookupExistingAsset_assetTablesLocked((re::internal::AssetTypeRegistry **)this, a2, v8);
  os_unfair_lock_unlock(v6);
  if (v8[0])
  {
    if (v10 && *((_QWORD *)v10 + 3))
      re::internal::AssetEntry::fromPeerID((uint64_t)v10, a3);
    else
      *(_BYTE *)a3 = 0;
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v9);
  }
  else
  {
    v7 = *(_QWORD *)&this[302]._os_unfair_lock_opaque;
    if (v7)
    {
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 128))(v7, a2);
    }
    else
    {
      *(_BYTE *)a3 = 1;
      *(_QWORD *)(a3 + 8) = 0;
    }
  }
}

void re::internal::AssetIdLoadDescriptorTable::insertIntoMutableTables(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t *v4;
  uint64_t *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[2];
  uint64_t v15[6];
  uint64_t v16;
  char v17;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x24BDAC8D0];
  v16 = a2;
  if (a3)
  {
    v4 = a4;
    v6 = &a4[18 * a3];
    v7 = (_QWORD *)(a1 + 96);
    while (1)
    {
      v8 = re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::tryGet((uint64_t)v7, (uint64_t)v4);
      if (!v8)
        break;
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(v8, &v16);
LABEL_14:
      v4 += 18;
      if (v4 == v6)
        return;
    }
    v18[0] = v16;
    v14[0] = v18;
    v14[1] = 1;
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)v15, (uint64_t)v14);
    v9 = re::Hash<re::AssetLoadDescriptor>::operator()((uint64_t)&v17, (uint64_t)v4);
    v10 = v9;
    if (*v7)
    {
      v11 = v9 % *(unsigned int *)(a1 + 120);
      v12 = *(unsigned int *)(*(_QWORD *)(a1 + 104) + 4 * v11);
      if ((_DWORD)v12 != 0x7FFFFFFF)
      {
        v13 = *(_QWORD *)(a1 + 112);
        while (!re::EqualTo<re::AssetLoadDescriptor>::operator()((uint64_t)&v17, v13 + 208 * v12 + 16, (uint64_t)v4))
        {
          v13 = *(_QWORD *)(a1 + 112);
          v12 = *(_DWORD *)(v13 + 208 * v12 + 8) & 0x7FFFFFFF;
          if (v12 == 0x7FFFFFFF)
            goto LABEL_12;
        }
        goto LABEL_13;
      }
    }
    else
    {
      LODWORD(v11) = 0;
    }
LABEL_12:
    re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::addAsMove((uint64_t)v7, v11, v10, v4, v15);
    ++*(_DWORD *)(a1 + 136);
LABEL_13:
    re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v15);
    goto LABEL_14;
  }
}

uint64_t re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  char v9;
  char v10;

  v4 = re::Hash<re::AssetLoadDescriptor>::operator()((uint64_t)&v9, a2);
  if (!*(_QWORD *)a1)
    return 0;
  v5 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v5 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    v7 = re::EqualTo<re::AssetLoadDescriptor>::operator()((uint64_t)&v10, v6 + 208 * v5 + 16, a2);
    v6 = *(_QWORD *)(a1 + 16);
    if (v7)
      break;
    v5 = *(_DWORD *)(v6 + 208 * v5 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF)
      return 0;
  }
  return v6 + 208 * v5 + 160;
}

BOOL re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::containsKey(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *a2;
  v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v6 + (v4 << 6) + 16) == v2)
    return 1;
  do
  {
    v4 = *(_DWORD *)(v6 + (v4 << 6) + 8) & 0x7FFFFFFF;
    result = (_DWORD)v4 != 0x7FFFFFFF;
  }
  while ((_DWORD)v4 != 0x7FFFFFFF && *(_QWORD *)(v6 + (v4 << 6) + 16) != v2);
  return result;
}

unint64_t re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + ((unint64_t)v13 << 6);
    return v12 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + (v10 << 6) + 16) != v6)
  {
    v10 = *(_DWORD *)(v11 + (v10 << 6) + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + (v10 << 6);
  return v12 + 24;
}

BOOL re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::containsKey(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v9;
  char v10;

  v4 = re::Hash<re::AssetLoadDescriptor>::operator()((uint64_t)&v9, a2);
  v5 = 0x7FFFFFFFLL;
  if (*(_QWORD *)a1)
  {
    v6 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a1 + 16);
      v5 = 0x7FFFFFFFLL;
      while (!re::EqualTo<re::AssetLoadDescriptor>::operator()((uint64_t)&v10, v7 + 168 * v6 + 16, a2))
      {
        v7 = *(_QWORD *)(a1 + 16);
        v6 = *(_DWORD *)(v7 + 168 * v6 + 8) & 0x7FFFFFFF;
        if (v6 == 0x7FFFFFFF)
          return v5 != 0x7FFFFFFF;
      }
      v5 = v6;
    }
  }
  return v5 != 0x7FFFFFFF;
}

uint64_t re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::add<unsigned long long &>(uint64_t a1, re::DynamicString *a2, _QWORD *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  unsigned int v12;
  uint64_t v13;
  char v15;
  char v16;

  v6 = re::Hash<re::AssetLoadDescriptor>::operator()((uint64_t)&v15, (uint64_t)a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::addEmplace<unsigned long long &>(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v13 = *(_QWORD *)(a1 + 16) + 168 * v12;
    return v13 + 160;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    v11 = re::EqualTo<re::AssetLoadDescriptor>::operator()((uint64_t)&v16, v10 + 168 * v9 + 16, (uint64_t)a2);
    v10 = *(_QWORD *)(a1 + 16);
    if (v11)
      break;
    v9 = *(_DWORD *)(v10 + 168 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v13 = v10 + 168 * v9;
  return v13 + 160;
}

void re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::remove(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  char v12;
  char v13;

  v4 = re::Hash<re::AssetLoadDescriptor>::operator()((uint64_t)&v12, a2);
  if (*(_QWORD *)a1)
  {
    v5 = v4 % *(unsigned int *)(a1 + 24);
    v6 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v5);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      if (re::EqualTo<re::AssetLoadDescriptor>::operator()((uint64_t)&v13, *(_QWORD *)(a1 + 16) + 168 * v6 + 16, a2))
      {
        *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v5) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 168 * v6 + 8) & 0x7FFFFFFF;
LABEL_8:
        re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 16) + 168 * v6);
        v10 = *(_QWORD *)(a1 + 16) + 168 * v6;
        v11 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(v10 + 8) = *(_DWORD *)(v10 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v6;
        *(_DWORD *)(a1 + 40) = v11 + 1;
      }
      else
      {
        while (1)
        {
          v7 = v6;
          v8 = *(_QWORD *)(a1 + 16);
          v9 = *(_DWORD *)(v8 + 168 * v6 + 8);
          v6 = v9 & 0x7FFFFFFF;
          if ((v9 & 0x7FFFFFFF) == 0x7FFFFFFF)
            break;
          if (re::EqualTo<re::AssetLoadDescriptor>::operator()((uint64_t)&v13, v8 + 168 * v6 + 16, a2))
          {
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 168 * v7 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 168 * v7 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 16) + 168 * v6 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
}

void re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_140, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 24 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 24;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

uint64_t re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(uint64_t result, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int *v15;
  int v16;
  int v17;

  if (*(_QWORD *)result)
  {
    v2 = result;
    v3 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    v4 = (v3 ^ (v3 >> 31)) % *(unsigned int *)(result + 24);
    v5 = *(_QWORD *)(result + 8);
    v6 = *(unsigned int *)(v5 + 4 * v4);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(result + 16);
      v8 = v7 + (v6 << 6);
      if (*(_QWORD *)(v8 + 16) == a2)
      {
        *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v8 + 8) & 0x7FFFFFFF;
LABEL_8:
        v12 = *(_QWORD *)(result + 16);
        v13 = v12 + (v6 << 6);
        v16 = *(_DWORD *)(v13 + 8);
        v15 = (int *)(v13 + 8);
        v14 = v16;
        if (v16 < 0)
        {
          *v15 = v14 & 0x7FFFFFFF;
          result = re::DynamicArray<re::AssetLoadDescriptor>::deinit(v12 + (v6 << 6) + 24);
          v12 = *(_QWORD *)(v2 + 16);
          v14 = *(_DWORD *)(v12 + (v6 << 6) + 8);
        }
        v17 = *(_DWORD *)(v2 + 40);
        *(_DWORD *)(v12 + (v6 << 6) + 8) = *(_DWORD *)(v2 + 36) | v14 & 0x80000000;
        --*(_DWORD *)(v2 + 28);
        *(_DWORD *)(v2 + 36) = v6;
        *(_DWORD *)(v2 + 40) = v17 + 1;
      }
      else
      {
        while (1)
        {
          v9 = v6;
          v10 = *(_DWORD *)(v7 + (v6 << 6) + 8);
          v6 = v10 & 0x7FFFFFFF;
          if ((v10 & 0x7FFFFFFF) == 0x7FFFFFFF)
            break;
          v11 = v7 + (v6 << 6);
          if (*(_QWORD *)(v11 + 16) == a2)
          {
            *(_DWORD *)(v7 + ((unint64_t)v9 << 6) + 8) = *(_DWORD *)(v7 + ((unint64_t)v9 << 6) + 8) & 0x80000000 | *(_DWORD *)(v11 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
  return result;
}

_QWORD *re::AssetManager::addCleanupBlock(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *result;
  os_unfair_lock_s *v5;
  uint64_t v6;
  re::AssetManager *v7;
  _BYTE v8[24];
  _BYTE *v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(a1 + 1410))
  {
    v2 = *(_QWORD *)(a2 + 24);
    if (v2)
    {
      return (_QWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 48))(v2);
    }
    else
    {
      v7 = (re::AssetManager *)std::__throw_bad_function_call[abi:nn180100]();
      return (_QWORD *)re::AssetManager::assetRuntimeSizeLimit(v7);
    }
  }
  else
  {
    v5 = (os_unfair_lock_s *)(a1 + 448);
    std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100]((uint64_t)v8, a2);
    os_unfair_lock_lock(v5);
    re::DynamicArray<std::function<void ()(void)>>::add((_anonymous_namespace_ *)(a1 + 456), (uint64_t)v8);
    os_unfair_lock_unlock(v5);
    result = v9;
    if (v9 == v8)
    {
      v6 = 4;
      result = v8;
    }
    else
    {
      if (!v9)
        return result;
      v6 = 5;
    }
    return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v6))();
  }
}

uint64_t re::AssetManager::assetRuntimeSizeLimit(re::AssetManager *this)
{
  return *((_QWORD *)this + 179);
}

uint64_t re::AssetManager::forExportOnly(re::AssetManager *this)
{
  return *((unsigned __int8 *)this + 1440);
}

double re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 40 * v3;
      do
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 40;
      }
      while (v5 != v4);
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::AssetManager::AssetChangeCallbackImpl::stateChanged(re::AssetManager **this, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6)
{
  re::AssetManager::receiveAssetLoadState(this[1], a2, a3, a4, a5, a6);
}

double re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 208;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1;
  uint64_t v3;
  _OWORD *v4;
  _OWORD *v5;
  uint64_t v6;
  uint64_t v7;
  double result;

  v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    v4 = (_OWORD *)(a1 + 128);
    v3 = *(_QWORD *)(a1 + 128);
    *((_DWORD *)v4 - 30) = v1 & 0x7FFFFFFF;
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 136) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 144));
      *v4 = 0u;
      v4[1] = 0u;
    }
    v5 = v4 - 7;
    v6 = *(_QWORD *)(a1 + 88);
    if (v6)
    {
      if (*(_QWORD *)(a1 + 120))
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
      *(_QWORD *)(a1 + 120) = 0;
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
      *(_QWORD *)(a1 + 88) = 0;
      ++*(_DWORD *)(a1 + 112);
    }
    v7 = *(_QWORD *)(a1 + 48);
    if (v7)
    {
      if (*(_QWORD *)(a1 + 80))
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
      *(_QWORD *)(a1 + 80) = 0;
      *(_QWORD *)(a1 + 56) = 0;
      *(_QWORD *)(a1 + 64) = 0;
      *(_QWORD *)(a1 + 48) = 0;
      ++*(_DWORD *)(a1 + 72);
    }
    if (*(_QWORD *)v5)
    {
      if ((*(_BYTE *)(a1 + 24) & 1) != 0)
        (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)v5 + 40))(*(_QWORD *)v5, *(_QWORD *)(a1 + 32));
      *v5 = 0u;
      v5[1] = 0u;
    }
    return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)(a1 + 160));
  }
  return result;
}

double re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 168;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1;
  uint64_t v3;
  _OWORD *v4;
  double result;
  _OWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    v4 = (_OWORD *)(a1 + 128);
    v3 = *(_QWORD *)(a1 + 128);
    *((_DWORD *)v4 - 30) = v1 & 0x7FFFFFFF;
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 136) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 144));
      result = 0.0;
      *v4 = 0u;
      v4[1] = 0u;
    }
    v6 = v4 - 7;
    v7 = *(_QWORD *)(a1 + 88);
    if (v7)
    {
      if (*(_QWORD *)(a1 + 120))
        (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
      *(_QWORD *)(a1 + 120) = 0;
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 104) = 0;
      *(_QWORD *)(a1 + 88) = 0;
      ++*(_DWORD *)(a1 + 112);
    }
    v8 = *(_QWORD *)(a1 + 48);
    if (v8)
    {
      if (*(_QWORD *)(a1 + 80))
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 40))(v8);
      *(_QWORD *)(a1 + 80) = 0;
      *(_QWORD *)(a1 + 56) = 0;
      *(_QWORD *)(a1 + 64) = 0;
      *(_QWORD *)(a1 + 48) = 0;
      ++*(_DWORD *)(a1 + 72);
    }
    if (*(_QWORD *)v6)
    {
      if ((*(_BYTE *)(a1 + 24) & 1) != 0)
        (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)v6 + 40))(*(_QWORD *)v6, *(_QWORD *)(a1 + 32));
      result = 0.0;
      *v6 = 0u;
      v6[1] = 0u;
    }
  }
  return result;
}

double re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::DynamicArray<re::AssetLoadDescriptor>::deinit(v6 + 24);
          v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 64;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::Queue<re::SharedPtr<re::AssetLoadRequest::Data>>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = a1[5];
    if (v3)
    {
      v4 = a1[2];
      if (v4)
      {
        for (i = 0; i != v4; ++i)
        {
          v6 = (i + a1[3]) % (unint64_t)a1[1];
          v7 = a1[5];
          v8 = *(_QWORD *)(v7 + 8 * v6);
          if (v8)
          {

            *(_QWORD *)(v7 + 8 * v6) = 0;
            v4 = a1[2];
          }
        }
        v2 = *a1;
        v3 = a1[5];
      }
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, v3);
    }
    a1[5] = 0;
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *((_DWORD *)a1 + 8) = 0;
  }
  return result;
}

uint64_t re::DynamicArray<unsigned long long>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *a2;
    if (*(_QWORD *)a1)
    {
      if (v4)
        re::DynamicArray<char const*>::copy((void **)a1, (uint64_t)a2);
      else
        *(_QWORD *)(a1 + 16) = 0;
      ++*(_DWORD *)(a1 + 24);
    }
    else if (v4)
    {
      v5 = a2[2];
      *(_QWORD *)a1 = v4;
      re::DynamicArray<float *>::setCapacity((_QWORD *)a1, v5);
      ++*(_DWORD *)(a1 + 24);
      re::DynamicArray<char const*>::copy((void **)a1, (uint64_t)a2);
    }
  }
  return a1;
}

uint64_t re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v6;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = *a2;
  v3 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8)
                       + 4
                       * (((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) ^ ((0x94D049BB133111EBLL * (v3 ^ (v3 >> 27))) >> 31))
                        % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(v6 + (v4 << 6) + 16) != v2)
  {
    while (1)
    {
      v4 = *(_DWORD *)(v6 + (v4 << 6) + 8) & 0x7FFFFFFF;
      if ((_DWORD)v4 == 0x7FFFFFFF)
        break;
      if (*(_QWORD *)(v6 + (v4 << 6) + 16) == v2)
        return v6 + (v4 << 6) + 24;
    }
    return 0;
  }
  return v6 + (v4 << 6) + 24;
}

uint64_t re::DynamicOverflowArray<unsigned long long,1ul>::DynamicOverflowArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 1;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[1];
    *(_QWORD *)a1 = v3;
    re::DynamicOverflowArray<unsigned long long,1ul>::setCapacity((_QWORD *)a1, v5);
    *(_DWORD *)(a1 + 16) += 2;
    re::DynamicOverflowArray<unsigned long long,1ul>::copy(a1, (uint64_t)a2);
  }
  return a1;
}

void *re::DynamicOverflowArray<unsigned long long,1ul>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  const void *v5;
  void *result;
  const void *v7;
  uint64_t v8;
  int v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;

  v4 = *(_QWORD *)(a2 + 8);
  if (v4 >= *(_QWORD *)(a1 + 8))
  {
    re::DynamicOverflowArray<unsigned long long,1ul>::setCapacity((_QWORD *)a1, *(_QWORD *)(a2 + 8));
    if ((*(_BYTE *)(a2 + 16) & 1) != 0)
      v7 = (const void *)(a2 + 24);
    else
      v7 = *(const void **)(a2 + 32);
    v8 = *(_QWORD *)(a1 + 8);
    v9 = *(_DWORD *)(a1 + 16);
    if ((v9 & 1) != 0)
    {
      v10 = (void *)(a1 + 24);
      if (!v8)
      {
LABEL_18:
        if ((v9 & 1) != 0)
          v11 = a1 + 24;
        else
          v11 = *(_QWORD *)(a1 + 32);
        v12 = *(_QWORD *)(a1 + 8);
        v13 = (void *)(v11 + 8 * v12);
        if ((*(_DWORD *)(a2 + 16) & 1) != 0)
          v14 = a2 + 24;
        else
          v14 = *(_QWORD *)(a2 + 32);
        result = memcpy(v13, (const void *)(v14 + 8 * v12), 8 * v4 - 8 * v12);
        goto LABEL_25;
      }
    }
    else
    {
      v10 = *(void **)(a1 + 32);
      if (!v8)
        goto LABEL_18;
    }
    memmove(v10, v7, 8 * v8);
    v9 = *(_DWORD *)(a1 + 16);
    goto LABEL_18;
  }
  if ((*(_BYTE *)(a2 + 16) & 1) != 0)
    v5 = (const void *)(a2 + 24);
  else
    v5 = *(const void **)(a2 + 32);
  if ((*(_BYTE *)(a1 + 16) & 1) == 0)
  {
    result = *(void **)(a1 + 32);
    if (!v4)
      goto LABEL_25;
    goto LABEL_15;
  }
  result = (void *)(a1 + 24);
  if (v4)
LABEL_15:
    result = memmove(result, v5, 8 * v4);
LABEL_25:
  *(_QWORD *)(a1 + 8) = v4;
  return result;
}

_QWORD *re::DynamicOverflowArray<unsigned long long,1ul>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  const void *v13;
  void *v14;
  uint64_t v15;
  const void *v16;
  int v17;

  v4 = result;
  v5 = *result;
  if (a2 && !v5)
  {
    result = (_QWORD *)re::DynamicOverflowArray<unsigned long long,1ul>::setCapacity(v4, a2);
    v6 = *((_DWORD *)v4 + 4) + 2;
LABEL_4:
    *((_DWORD *)v4 + 4) = v6;
    return result;
  }
  v7 = *((_DWORD *)result + 4);
  if ((v7 & 1) != 0)
    v8 = 1;
  else
    v8 = result[3];
  if (v8 != a2)
  {
    v9 = result[1];
    if (v9 <= a2 && (a2 > 1 || (v7 & 1) == 0))
    {
      if (a2 < 2)
      {
        v14 = result + 3;
        v15 = v4[4];
        if ((v7 & 1) != 0)
          v16 = v4 + 3;
        else
          v16 = (const void *)v4[4];
        memcpy(v14, v16, 8 * v9);
        result = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, v15);
        v6 = *((_DWORD *)v4 + 4) | 1;
        goto LABEL_4;
      }
      if (a2 >> 61)
      {
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicOverflowArray<T, N>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 646, 8, a2);
        _os_crash();
        __break(1u);
      }
      else
      {
        v2 = 8 * a2;
        v10 = (void *)(*(uint64_t (**)(_QWORD, unint64_t, uint64_t))(*(_QWORD *)v5 + 32))(*result, 8 * a2, 8);
        if (v10)
        {
          v12 = v10;
          if ((v4[2] & 1) != 0)
            v13 = v4 + 3;
          else
            v13 = (const void *)v4[4];
          result = memcpy(v10, v13, 8 * v4[1]);
          v17 = *((_DWORD *)v4 + 4);
          if ((v17 & 1) == 0)
          {
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v4 + 40))(*v4, v4[4]);
            v17 = *((_DWORD *)v4 + 4);
          }
          *((_DWORD *)v4 + 4) = v17 & 0xFFFFFFFE;
          v4[3] = a2;
          v4[4] = v12;
          return result;
        }
      }
      re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 650, v2, *(_QWORD *)(*v4 + 8));
      result = (_QWORD *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

uint64_t re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  char v9;
  char v10;

  v4 = re::Hash<re::AssetLoadDescriptor>::operator()((uint64_t)&v9, a2);
  if (!*(_QWORD *)a1)
    return 0;
  v5 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v5 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    v7 = re::EqualTo<re::AssetLoadDescriptor>::operator()((uint64_t)&v10, v6 + 168 * v5 + 16, a2);
    v6 = *(_QWORD *)(a1 + 16);
    if (v7)
      break;
    v5 = *(_DWORD *)(v6 + 168 * v5 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF)
      return 0;
  }
  return v6 + 168 * v5 + 160;
}

BOOL re::EqualTo<re::AssetLoadDescriptor>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _BOOL8 result;
  size_t v6;

  result = re::DynamicString::operator==(a2, a3);
  if (result)
  {
    result = re::DynamicString::operator==(a2 + 112, a3 + 112);
    if (result)
    {
      v6 = *(_QWORD *)(a2 + 48);
      return v6 == *(_QWORD *)(a3 + 48) && memcmp(*(const void **)(a2 + 64), *(const void **)(a3 + 64), v6) == 0;
    }
  }
  return result;
}

unint64_t re::Hash<re::AssetLoadDescriptor>::operator()(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v9[3];

  v9[2] = *MEMORY[0x24BDAC8D0];
  v3 = re::Hash<re::DynamicString>::operator()((uint64_t)v9, a2);
  v4 = re::Hash<re::DynamicString>::operator()((uint64_t)v9, a2 + 112);
  v5 = *(_QWORD *)(a2 + 48);
  if (v5)
  {
    MurmurHash3_x64_128(*(_QWORD *)(a2 + 64), v5, 0, v9);
    v6 = ((v9[1] - 0x61C8864680B583E9 + (v9[0] << 6) + (v9[0] >> 2)) ^ v9[0]) - 0x61C8864680B583E9;
  }
  else
  {
    v6 = 0x9E3779B97F4A7C17;
  }
  v7 = ((v3 << 6) - 0x61C8864680B583E9 + (v3 >> 2) + v4) ^ v3;
  return ((v7 >> 2) + (v7 << 6) + v6) ^ v7;
}

uint64_t re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase(uint64_t a1, uint64_t a2)
{
  signed int v4;
  uint64_t *v5;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  if (*(_QWORD *)(a2 + 8))
  {
    if (*(_DWORD *)(a2 + 8) <= 3u)
      v4 = 3;
    else
      v4 = *(_DWORD *)(a2 + 8);
    if (*(_QWORD *)(a2 + 8))
    {
      v5 = *(uint64_t **)a2;
      do
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(a1, v5++);
      while (v5 != (uint64_t *)(*(_QWORD *)a2 + 8 * *(_QWORD *)(a2 + 8)));
    }
  }
  return a1;
}

{
  uint64_t v4;
  signed int v5;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u)
      v5 = 3;
    else
      v5 = *(_DWORD *)(a2 + 28);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(a1, v4, v5);
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(a1, a2);
  }
  return a1;
}

void re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_152, 4 * v2);
    v3 = *(unsigned int *)(a1 + 32);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 24 * v3;
      do
      {
        v6 = *(_QWORD *)(a1 + 16) + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
        v4 += 24;
      }
      while (v5 != v4);
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v8 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v8;
  }
}

uint64_t `anonymous namespace'::ImmutableAssetDependencyCrawler::push(_anonymous_namespace_::ImmutableAssetDependencyCrawler *this, const re::AssetHandle *a2)
{
  void *v5;

  re::DynamicArray<re::AssetHandle>::add((_anonymous_namespace_::ImmutableAssetDependencyCrawler *)((char *)this + 16), a2);
  v5 = re::AssetHandle::assetInfo(a2);
  return re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::add((uint64_t)this + 56, (uint64_t *)&v5);
}

uint64_t `anonymous namespace'::ImmutableAssetDependencyCrawler::processStack(_anonymous_namespace_::ImmutableAssetDependencyCrawler *this)
{
  uint64_t v2;
  re::AssetHandle *v3;
  void *v4;
  unint64_t v5;
  uint64_t v6;
  const re::AssetHandle *v7;
  const re::AssetHandle *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  int v23;
  int v24;
  uint64_t v25;
  void *v26;
  void *v27;
  _BOOL8 v28;
  NSObject *v29;
  uint64_t v30;
  NSObject *v31;
  _BOOL4 v32;
  char *v33;
  _QWORD *v34;
  char *v35;
  _QWORD *v36;
  char *v37;
  uint64_t v38;
  const re::AssetHandle *v39;
  uint64_t v40;
  _QWORD *v41;
  char *v42;
  char *v44;
  re::AssetHandle *v45;
  _BYTE v46[16];
  uint64_t v47;
  re::AssetHandle *v48;
  _BYTE buf[12];
  __int16 v50;
  char *v51;
  uint64_t v52;

  v52 = *MEMORY[0x24BDAC8D0];
  re::AssetManager::findDependencies(*(re::AssetManager **)this, (const re::AssetHandle *)(*((_QWORD *)this + 6) + 24 * *((_QWORD *)this + 4) - 24), (uint64_t)v46);
  v2 = v47;
  *((_DWORD *)this + 39) += v47;
  if (v2)
  {
    v3 = v48;
    v44 = (char *)this + 56;
    v45 = (re::AssetHandle *)((char *)v48 + 24 * v2);
    do
    {
      v4 = re::AssetHandle::assetInfo(v3);
      if (re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::contains((uint64_t)this + 104, (unint64_t)v4))
      {
        v5 = *((_QWORD *)re::AssetHandle::assetInfo(v3) + 10);
        if (v5 + 1 >= 2)
        {
          v6 = *((_QWORD *)this + 4);
          if (v6)
          {
            v7 = (const re::AssetHandle *)*((_QWORD *)this + 6);
            v8 = (const re::AssetHandle *)((char *)v7 + 24 * v6);
            do
            {
              v9 = re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(*((_QWORD *)this + 1), v5);
              if (v9)
              {
                v10 = v9;
                v11 = re::AssetHandle::assetInfo(v7);
                v12 = v11[10];
                if (v12 + 1 >= 2)
                {
                  *(_QWORD *)buf = v11[10];
                  v13 = *((_QWORD *)this + 1);
                  v14 = re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v13, v12);
                  if (v14)
                  {
                    v15 = v14;
                    v16 = *(unsigned int *)(v10 + 32);
                    if ((_DWORD)v16)
                    {
                      v17 = 0;
                      v18 = (int *)(*(_QWORD *)(v10 + 16) + 8);
                      while (1)
                      {
                        v19 = *v18;
                        v18 += 6;
                        if (v19 < 0)
                          break;
                        if (v16 == ++v17)
                        {
                          LODWORD(v17) = *(_DWORD *)(v10 + 32);
                          break;
                        }
                      }
                    }
                    else
                    {
                      LODWORD(v17) = 0;
                    }
                    if ((_DWORD)v16 != (_DWORD)v17)
                    {
                      v20 = v17;
                      v21 = *(_QWORD *)(v10 + 16);
                      do
                      {
                        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(v15, (uint64_t *)(v21 + 24 * v20 + 16));
                        v22 = *(_DWORD *)(v10 + 32);
                        v21 = *(_QWORD *)(v10 + 16);
                        if (v22 <= (int)v17 + 1)
                          v23 = v17 + 1;
                        else
                          v23 = *(_DWORD *)(v10 + 32);
                        v24 = v17;
                        while (1)
                        {
                          v20 = (v24 + 1);
                          if (v23 - 1 == v24)
                            break;
                          ++v24;
                          LODWORD(v17) = v20;
                          if ((*(_DWORD *)(v21 + 24 * v20 + 8) & 0x80000000) != 0)
                            goto LABEL_29;
                        }
                        LODWORD(v17) = v23;
LABEL_29:
                        ;
                      }
                      while (v22 != (_DWORD)v17);
                    }
                  }
                  else
                  {
                    re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add<re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>&>(v13, (uint64_t *)buf, v10);
                  }
                }
              }
              v7 = (const re::AssetHandle *)((char *)v7 + 24);
            }
            while (v7 != v8);
          }
        }
        goto LABEL_52;
      }
      v25 = *((_QWORD *)v3 + 1);
      if (!v25
        || *(_BYTE *)(v25 + 257)
        || (v26 = re::AssetHandle::assetInfo(v3),
            re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::contains((uint64_t)v44, (unint64_t)v26)))
      {
        v27 = re::AssetHandle::assetInfo(v3);
        v28 = re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::contains((uint64_t)v44, (unint64_t)v27);
        if (v28)
        {
          v29 = *re::assetsLogObjects((re *)v28);
          v28 = os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
          if (v28)
          {
            v41 = re::AssetHandle::assetInfo((re::AssetHandle *)(*((_QWORD *)this + 6)
                                                               + 24 * *((_QWORD *)this + 4)
                                                               - 24));
            if ((v41[17] & 1) != 0)
              v42 = (char *)v41[18];
            else
              v42 = (char *)v41 + 137;
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v42;
            _os_log_error_impl(&dword_224FE9000, v29, OS_LOG_TYPE_ERROR, "Asset dependency cycle detected at '%s'\n", buf, 0xCu);
          }
          ++*((_DWORD *)this + 38);
        }
        v30 = *((_QWORD *)v3 + 1);
        if (!v30 || !*(_BYTE *)(v30 + 257))
          goto LABEL_52;
        v31 = *re::assetsLogObjects((re *)v28);
        v32 = os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
        v33 = (char *)this + 152;
        if (v32)
        {
          v34 = re::AssetHandle::assetInfo((re::AssetHandle *)(*((_QWORD *)this + 6) + 24 * *((_QWORD *)this + 4) - 24));
          if ((v34[17] & 1) != 0)
            v35 = (char *)v34[18];
          else
            v35 = (char *)v34 + 137;
          v36 = re::AssetHandle::assetInfo(v3);
          if ((v36[17] & 1) != 0)
            v37 = (char *)v36[18];
          else
            v37 = (char *)v36 + 137;
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = v35;
          v50 = 2080;
          v51 = v37;
          _os_log_error_impl(&dword_224FE9000, v31, OS_LOG_TYPE_ERROR, "Immutable asset '%s' depends on mutable asset '%s'\n", buf, 0x16u);
          v33 = (char *)this + 152;
        }
      }
      else
      {
        v38 = *((_QWORD *)this + 4);
        if (v38)
        {
          v39 = (const re::AssetHandle *)*((_QWORD *)this + 6);
          v40 = 24 * v38;
          do
          {
            v39 = (const re::AssetHandle *)((char *)v39 + 24);
            v40 -= 24;
          }
          while (v40);
        }
        *(_QWORD *)buf = re::AssetHandle::assetInfo((re::AssetHandle *)(*((_QWORD *)this + 6)
                                                                      + 24 * *((_QWORD *)this + 4)
                                                                      - 24));
        re::HashSetBase<re::ecs2::Entity *,re::ecs2::Entity *,re::internal::ValueAsKey<re::ecs2::Entity *>,re::Hash<re::ecs2::Entity *>,re::EqualTo<re::ecs2::Entity *>,true,false>::remove((uint64_t)v44, (uint64_t *)buf);
        re::AssetHandle::~AssetHandle((re::AssetHandle *)(*((_QWORD *)this + 6) + 24 * *((_QWORD *)this + 4) - 24));
        --*((_QWORD *)this + 4);
        v33 = (char *)this + 40;
      }
      ++*(_DWORD *)v33;
LABEL_52:
      v3 = (re::AssetHandle *)((char *)v3 + 24);
    }
    while (v3 != v45);
  }
  *(_QWORD *)buf = re::AssetHandle::assetInfo((re::AssetHandle *)(*((_QWORD *)this + 6)
                                                                + 24 * *((_QWORD *)this + 4)
                                                                - 24));
  re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::add((uint64_t)this + 104, (uint64_t *)buf);
  return re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v46);
}

uint64_t re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::add(uint64_t result, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = result;
  v4 = *a2;
  v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  v7 = *(unsigned int *)(result + 24);
  if ((_DWORD)v7)
  {
    v8 = v6 % v7;
    v9 = *(unsigned int *)(*(_QWORD *)(result + 8) + 4 * (v6 % v7));
    if ((_DWORD)v9 != 0x7FFFFFFF)
    {
      v10 = *(_QWORD *)(result + 16);
      if (*(_QWORD *)(v10 + 24 * v9 + 16) == v4)
        return result;
      while (1)
      {
        LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
        if ((_DWORD)v9 == 0x7FFFFFFF)
          break;
        if (*(_QWORD *)(v10 + 24 * v9 + 16) == v4)
          return result;
      }
    }
  }
  else
  {
    LODWORD(v8) = 0;
  }
  result = re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::addAsMove(result, v8, v6, (uint64_t)a2, a2);
  ++*(_DWORD *)(v3 + 40);
  return result;
}

uint64_t re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, *(_QWORD *)&v13[16] + v10 + 16);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

void re::HashSetBase<void *,void *,re::internal::ValueAsKey<void *>,re::Hash<void *>,re::EqualTo<void *>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_153, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 600);
    _os_crash();
    __break(1u);
  }
}

double `anonymous namespace'::ImmutableAssetDependencyCrawler::recordDependency(_anonymous_namespace_::ImmutableAssetDependencyCrawler *this, const re::AssetHandle *a2, const re::AssetHandle *a3)
{
  unint64_t v5;
  double result;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[2];
  uint64_t v12[6];
  uint64_t v13;
  unint64_t v14;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x24BDAC8D0];
  v5 = *((_QWORD *)re::AssetHandle::assetInfo(a2) + 10);
  if (v5 + 1 >= 2)
  {
    v14 = v5;
    v7 = re::AssetHandle::assetInfo(a3);
    v8 = v7[10];
    if ((unint64_t)(v8 + 1) >= 2)
    {
      v13 = v7[10];
      v9 = *((_QWORD *)this + 1);
      v10 = re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(v9, v5);
      if (v10)
      {
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addNew(v10, &v13);
      }
      else
      {
        v15[0] = v8;
        v11[0] = v15;
        v11[1] = 1;
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::HashSetBase((uint64_t)v12, (uint64_t)v11);
        re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add(v9, (uint64_t *)&v14, v12);
        return re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit(v12);
      }
    }
  }
  return result;
}

uint64_t re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::add(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *a2;
  v7 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v8 = (0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) ^ ((0x94D049BB133111EBLL * (v7 ^ (v7 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_8;
  }
  v9 = v8 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, v9, v8, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 72 * v13;
    return v12 + 24;
  }
  v11 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v11 + 72 * v10 + 16) != v6)
  {
    LODWORD(v10) = *(_DWORD *)(v11 + 72 * v10 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v10 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v11 + 72 * v10;
  return v12 + 24;
}

uint64_t re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, uint64_t *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 72 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 72 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 72 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 72 * v10) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 72 * v10 + 16) = *a4;
  v14 = *(_QWORD *)(a1 + 16) + 72 * v10;
  *(_OWORD *)(v14 + 24) = 0u;
  v14 += 24;
  *(_OWORD *)(v14 + 16) = 0u;
  *(_DWORD *)(v14 + 32) = 0;
  *(_QWORD *)(v14 + 36) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v14, a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(_QWORD *)a1 || *(_QWORD *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1);
    }
  }
  return a1;
}

void re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;

  re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(a1, *(_QWORD *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)v8, v8 + 16, (_QWORD *)(v8 + 16));
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 24;
    }
  }
}

void re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, *(_QWORD *)&v13[16] + v10 + 24);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 72;
        }
        while (v11 < v9);
      }
      re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

void re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 72 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_154, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SharedPtr<re::internal::AssetReference> *,re::SharedPtr<re::internal::AssetReference> *,re::SharedPtr<re::internal::AssetReference> *,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t v6;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      v6 = *v5++;
      re::SharedPtr<re::SkeletalPoseJointDefinition>::reset(a3++, v6);
    }
    while (v5 != a2);
  }
}

uint64_t re::Optional<re::AssetPath>::~Optional(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;

  if (*(_BYTE *)a1)
  {
    v3 = (_OWORD *)(a1 + 48);
    v2 = *(_QWORD *)(a1 + 48);
    if (v2)
    {
      if ((*(_BYTE *)(a1 + 56) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 64));
      *v3 = 0u;
      *(_OWORD *)(a1 + 64) = 0u;
    }
    v4 = *(_QWORD *)(a1 + 16);
    if (v4)
    {
      if ((*(_BYTE *)(a1 + 24) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 32));
      *(_OWORD *)(a1 + 16) = 0u;
      *(_OWORD *)(a1 + 32) = 0u;
    }
  }
  return a1;
}

_anonymous_namespace_ *re::DynamicOverflowArray<unsigned long long,1ul>::add(uint64_t a1, _QWORD *a2)
{
  _anonymous_namespace_ *result;
  uint64_t v5;
  uint64_t v6;

  result = re::DynamicOverflowArray<unsigned long long,1ul>::ensureCapacity((_anonymous_namespace_ *)a1);
  if ((*(_BYTE *)(a1 + 16) & 1) != 0)
    v5 = a1 + 24;
  else
    v5 = *(_QWORD *)(a1 + 32);
  v6 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(v5 + 8 * v6) = *a2;
  *(_QWORD *)(a1 + 8) = v6 + 1;
  *(_DWORD *)(a1 + 16) += 2;
  return result;
}

uint64_t re::DynamicOverflowArray<unsigned long long,1ul>::indexOf@<X0>(uint64_t result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  int v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;

  v3 = *(_DWORD *)(result + 16);
  if ((v3 & 1) != 0)
    v4 = (_QWORD *)(result + 24);
  else
    v4 = *(_QWORD **)(result + 32);
  v5 = *(_QWORD *)(result + 8);
  if (v5)
  {
    v6 = 8 * v5;
    v7 = &v4[v5];
    while (*v4 != *a2)
    {
      ++v4;
      v6 -= 8;
      if (!v6)
      {
        v4 = v7;
        break;
      }
    }
  }
  if ((v3 & 1) != 0)
    v8 = result + 24;
  else
    v8 = *(_QWORD *)(result + 32);
  if (v4 == (_QWORD *)(v8 + 8 * v5))
  {
    *(_BYTE *)a3 = 0;
  }
  else
  {
    *(_BYTE *)a3 = 1;
    *(_QWORD *)(a3 + 8) = ((uint64_t)v4 - v8) >> 3;
  }
  return result;
}

_anonymous_namespace_ *re::DynamicOverflowArray<unsigned long long,1ul>::ensureCapacity(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v1 = result;
  if (*(_QWORD *)result)
  {
    v2 = *((_QWORD *)result + 1);
    if ((*((_BYTE *)result + 16) & 1) != 0)
      v3 = 1;
    else
      v3 = *((_QWORD *)result + 3);
    if (v2 >= v3)
      return re::DynamicOverflowArray<unsigned long long,1ul>::growCapacity(result, v2 + 1);
  }
  else
  {
    v4 = *((_QWORD *)v1 + 1) + 1;
    result = (_anonymous_namespace_ *)re::DynamicOverflowArray<unsigned long long,1ul>::setCapacity(v1, v4);
    *((_DWORD *)v1 + 4) += 2;
  }
  return result;
}

_anonymous_namespace_ *re::DynamicOverflowArray<unsigned long long,1ul>::growCapacity(_anonymous_namespace_ *result, unint64_t a2)
{
  unint64_t v2;
  _anonymous_namespace_ *v3;
  unint64_t v4;
  unint64_t v5;

  v2 = a2;
  v3 = result;
  if (!*(_QWORD *)result)
  {
    result = (_anonymous_namespace_ *)re::DynamicOverflowArray<unsigned long long,1ul>::setCapacity(v3, v2);
    *((_DWORD *)v3 + 4) += 2;
    return result;
  }
  if ((*((_BYTE *)result + 16) & 1) != 0)
  {
    if (a2 <= 1)
      return result;
    v5 = 2;
  }
  else
  {
    v4 = *((_QWORD *)result + 3);
    if (v4 >= a2)
      return result;
    v5 = 2 * v4;
  }
  if (v5 > a2)
    a2 = v5;
  return (_anonymous_namespace_ *)re::DynamicOverflowArray<unsigned long long,1ul>::setCapacity(result, a2);
}

uint64_t re::internal::Callable<re::AssetManager::tryLoadAssetOverNetwork_entryStateLocked(re::internal::AssetEntry &)::$_0,void ()(re::Result<re::SharedResourcePayload,re::WrappedError>)>::~Callable(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24ED2C5E0;
  objc_destroyWeak((id *)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
  return a1;
}

void re::internal::Callable<re::AssetManager::tryLoadAssetOverNetwork_entryStateLocked(re::internal::AssetEntry &)::$_0,void ()(re::Result<re::SharedResourcePayload,re::WrappedError>)>::~Callable(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24ED2C5E0;
  objc_destroyWeak((id *)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::AssetManager::tryLoadAssetOverNetwork_entryStateLocked(re::internal::AssetEntry &)::$_0,void ()(re::Result<re::SharedResourcePayload,re::WrappedError>)>::operator()(uint64_t a1, uint64_t a2)
{
  void *v2;
  uint64_t v3;
  id WeakRetained;
  void *v5;
  id v6;
  _BYTE v7[8];
  id v8;

  v7[0] = *(_BYTE *)a2;
  v2 = *(void **)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  v6 = v2;
  v8 = v2;
  v3 = *(_QWORD *)(a1 + 16);
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 8));
  if (WeakRetained)
  {
    v5 = WeakRetained;
    re::AssetManager::processUpdatedResourcePayload(v3, (uint64_t)WeakRetained - 8, (uint64_t)v7);

  }
  else
  {

  }
}

uint64_t re::internal::Callable<re::AssetManager::tryLoadAssetOverNetwork_entryStateLocked(re::internal::AssetEntry &)::$_0,void ()(re::Result<re::SharedResourcePayload,re::WrappedError>)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2C5E0;
  *(_QWORD *)(a2 + 8) = 0;
  objc_copyWeak((id *)(a2 + 8), (id *)(a1 + 8));
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::Callable<re::AssetManager::tryLoadAssetOverNetwork_entryStateLocked(re::internal::AssetEntry &)::$_0,void ()(re::Result<re::SharedResourcePayload,re::WrappedError>)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2C5E0;
  *(_QWORD *)(a2 + 8) = 0;
  objc_moveWeak((id *)(a2 + 8), (id *)(a1 + 8));
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::Callable<re::AssetManager::tryLoadAssetOverNetwork_entryStateLocked(re::internal::AssetEntry &)::$_0,void ()(re::Result<re::SharedResourcePayload,re::WrappedError>)>::size()
{
  return 24;
}

uint64_t std::__throw_bad_variant_access[abi:nn180100]()
{
  uint64_t v0;
  uint64_t v1;

  std::__libcpp_verbose_abort("bad_variant_access was thrown in -fno-exceptions mode");
  return re::DynamicArray<re::internal::DeferredUnregister *>::operator=(v0, v1);
}

uint64_t re::DynamicArray<re::internal::DeferredUnregister *>::operator=(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (result != a2)
  {
    v2 = *(_QWORD *)result;
    v3 = *(_QWORD *)a2;
    if (*(_QWORD *)result)
      v4 = v3 == 0;
    else
      v4 = 1;
    if (v4 || v2 == v3)
    {
      v6 = *(_QWORD *)(result + 8);
      v7 = *(_QWORD *)(a2 + 8);
      *(_QWORD *)result = v3;
      *(_QWORD *)(result + 8) = v7;
      *(_QWORD *)a2 = v2;
      *(_QWORD *)(a2 + 8) = v6;
      v8 = *(_QWORD *)(result + 16);
      *(_QWORD *)(result + 16) = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a2 + 16) = v8;
      v9 = *(_QWORD *)(result + 32);
      *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
      *(_QWORD *)(a2 + 32) = v9;
      ++*(_DWORD *)(a2 + 24);
      ++*(_DWORD *)(result + 24);
    }
    else
    {
      re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
      result = _os_crash();
      __break(1u);
    }
  }
  return result;
}

_anonymous_namespace_ *re::DynamicArray<re::SharedPtr<re::internal::AssetReference>>::add(_anonymous_namespace_ *result, _QWORD *a2)
{
  _anonymous_namespace_ *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v3 = result;
  v5 = *((_QWORD *)result + 1);
  v4 = *((_QWORD *)result + 2);
  if (v4 >= v5)
  {
    v6 = v4 + 1;
    if (v5 < v4 + 1)
    {
      if (*(_QWORD *)result)
      {
        v7 = 2 * v5;
        if (!v5)
          v7 = 8;
        if (v7 <= v6)
          v8 = v6;
        else
          v8 = v7;
        result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(result, v8);
      }
      else
      {
        result = (_anonymous_namespace_ *)re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(v3, v6);
        ++*((_DWORD *)v3 + 6);
      }
    }
    v4 = *((_QWORD *)v3 + 2);
  }
  *(_QWORD *)(*((_QWORD *)v3 + 4) + 8 * v4) = *a2;
  *a2 = 0;
  *((_QWORD *)v3 + 2) = v4 + 1;
  ++*((_DWORD *)v3 + 6);
  return result;
}

uint64_t re::internal::Callable<re::AssetManager::putEntryInLoadingState_entryStateLocked(re::internal::AssetEntry &,BOOL)::$_0,void ()(re::Result<re::SharedResourcePayload,re::WrappedError>)>::~Callable(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24ED2C648;
  objc_destroyWeak((id *)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
  return a1;
}

void re::internal::Callable<re::AssetManager::putEntryInLoadingState_entryStateLocked(re::internal::AssetEntry &,BOOL)::$_0,void ()(re::Result<re::SharedResourcePayload,re::WrappedError>)>::~Callable(uint64_t a1)
{
  *(_QWORD *)a1 = &off_24ED2C648;
  objc_destroyWeak((id *)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
  JUMPOUT(0x2276933B8);
}

void re::internal::Callable<re::AssetManager::putEntryInLoadingState_entryStateLocked(re::internal::AssetEntry &,BOOL)::$_0,void ()(re::Result<re::SharedResourcePayload,re::WrappedError>)>::operator()(uint64_t a1, uint64_t a2)
{
  void *v2;
  uint64_t v3;
  id WeakRetained;
  void *v5;
  id v6;
  _BYTE v7[8];
  id v8;

  v7[0] = *(_BYTE *)a2;
  v2 = *(void **)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  v6 = v2;
  v8 = v2;
  v3 = *(_QWORD *)(a1 + 16);
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 8));
  if (WeakRetained)
  {
    v5 = WeakRetained;
    re::AssetManager::processUpdatedResourcePayload(v3, (uint64_t)WeakRetained - 8, (uint64_t)v7);

  }
  else
  {

  }
}

uint64_t re::internal::Callable<re::AssetManager::putEntryInLoadingState_entryStateLocked(re::internal::AssetEntry &,BOOL)::$_0,void ()(re::Result<re::SharedResourcePayload,re::WrappedError>)>::cloneInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2C648;
  *(_QWORD *)(a2 + 8) = 0;
  objc_copyWeak((id *)(a2 + 8), (id *)(a1 + 8));
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::Callable<re::AssetManager::putEntryInLoadingState_entryStateLocked(re::internal::AssetEntry &,BOOL)::$_0,void ()(re::Result<re::SharedResourcePayload,re::WrappedError>)>::moveInto(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)a2 = &off_24ED2C648;
  *(_QWORD *)(a2 + 8) = 0;
  objc_moveWeak((id *)(a2 + 8), (id *)(a1 + 8));
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 16);
  return a2;
}

uint64_t re::internal::Callable<re::AssetManager::putEntryInLoadingState_entryStateLocked(re::internal::AssetEntry &,BOOL)::$_0,void ()(re::Result<re::SharedResourcePayload,re::WrappedError>)>::size()
{
  return 24;
}

re::CancellationTokenSource *re::CancellationTokenSource::CancellationTokenSource(re::CancellationTokenSource *this)
{
  re *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24ED2C6A0;
  *((_QWORD *)this + 3) = 0;
  v3 = re::globalAllocators(v2);
  v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v3[2] + 32))(v3[2], 32, 8);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v4, 0);
  *(_QWORD *)v4 = &off_24ED2C6E8;
  *(_BYTE *)(v4 + 24) = 0;
  v5 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v4;
  if (v5)

  return this;
}

void re::CancellationTokenSource::~CancellationTokenSource(re::CancellationTokenSource *this)
{
  uint64_t v2;

  *(_QWORD *)this = &off_24ED2C6A0;
  v2 = *((_QWORD *)this + 3);
  if (v2)
  {

    *((_QWORD *)this + 3) = 0;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t v2;

  *(_QWORD *)this = &off_24ED2C6A0;
  v2 = *((_QWORD *)this + 3);
  if (v2)
  {

    *((_QWORD *)this + 3) = 0;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

void re::CancellationToken::~CancellationToken(re::CancellationToken *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

void re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::add(_anonymous_namespace_ *this, id *from)
{
  unint64_t v4;
  id *v5;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = (id *)(*((_QWORD *)this + 4) + 8 * v4);
  *v5 = 0;
  objc_moveWeak(v5, from);
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
}

_QWORD *re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  id *v7;
  id *v8;
  uint64_t v9;
  uint64_t v10;
  id *v11;
  id *v12;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::ArcWeakPtr<re::internal::AssetEntry>>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = (id *)result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (id *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 8 * v9;
        v11 = v7;
        v12 = v7;
        do
        {
          *v12++ = 0;
          objc_moveWeak(v11, v8);
          objc_destroyWeak(v8);
          *v8++ = 0;
          v11 = v12;
          v10 -= 8;
        }
        while (v10);
        v8 = (id *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, id *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

_QWORD *re::Queue<re::SharedPtr<re::AssetLoadRequest::Data>>::enqueue(_QWORD *this, uint64_t *a2)
{
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;

  v3 = this;
  v5 = this[1];
  v4 = this[2];
  if (v4 + 1 >= v5)
  {
    this = re::Queue<re::SharedPtr<re::AssetLoadRequest::Data>>::growCapacity(this, v4 + 1);
    v5 = v3[1];
    v4 = v3[2];
  }
  v6 = (v3[3] + v4) % v5;
  v7 = *a2;
  *(_QWORD *)(v3[5] + 8 * v6) = *a2;
  if (v7)
  {
    this = (id)(v7 + 8);
    v4 = v3[2];
  }
  v3[2] = v4 + 1;
  ++*((_DWORD *)v3 + 8);
  return this;
}

_QWORD *re::Queue<re::SharedPtr<re::AssetLoadRequest::Data>>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::Queue<re::SharedPtr<re::AssetLoadRequest::Data>>::setCapacity(this, a2);
    }
    else
    {
      this = re::Queue<re::SharedPtr<re::AssetLoadRequest::Data>>::setCapacity(v4, v3);
      v4[2] = 0;
      v4[3] = 0;
      *((_DWORD *)v4 + 8) = 0;
    }
  }
  return this;
}

_QWORD *re::Queue<re::SharedPtr<re::AssetLoadRequest::Data>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    v6 = result + 2;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::Queue<re::SharedPtr<re::AssetLoadRequest::Data>>::setCapacity(v5, a2);
        *v6 = 0;
        v6[1] = 0;
        *((_DWORD *)v6 + 4) = 0;
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in Queue<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 440, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v8 = result;
            v3 = v5[1];
            if (!v3)
              goto LABEL_18;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Queue<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 444, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v8 = 0;
      if (!v3)
      {
LABEL_18:
        v5[5] = v8;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v9 = v5[2];
      v10 = v5[5];
      if (v9)
      {
        v11 = v5[3];
        v12 = v11;
        do
        {
          v8[v12] = *(_QWORD *)(v10 + 8 * (v11 % v3));
          *(_QWORD *)(v10 + 8 * (v11 % v3)) = 0;
          if (v12 + 1 < a2)
            ++v12;
          else
            v12 = 0;
          ++v11;
          --v9;
        }
        while (v9);
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v10);
      goto LABEL_18;
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::AssetPath>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  __int128 v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::AssetPath>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x50uLL))
        {
          v2 = 80 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 80 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_24;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 80, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_24:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 0;
        v11 = 80 * v9;
        v12 = 0uLL;
        do
        {
          v13 = &v7[v10 / 8];
          v14 = (_QWORD *)(v8 + v10);
          *(_DWORD *)v13 = *(_DWORD *)(v8 + v10);
          *(_OWORD *)(v13 + 1) = v12;
          *(_OWORD *)(v13 + 3) = v12;
          v15 = (_QWORD *)(v8 + v10 + 8);
          v13[1] = *v15;
          *v15 = 0;
          v13[4] = *(_QWORD *)(v8 + v10 + 32);
          v14[4] = 0;
          v17 = v7[v10 / 8 + 2];
          v16 = v7[v10 / 8 + 3];
          v18 = *(_QWORD *)(v8 + v10 + 24);
          v13[2] = *(_QWORD *)(v8 + v10 + 16);
          v13[3] = v18;
          v14[2] = v17;
          v14[3] = v16;
          *(_OWORD *)(v13 + 7) = v12;
          *(_OWORD *)(v13 + 5) = v12;
          v19 = (_QWORD *)(v8 + v10 + 40);
          v13[5] = *v19;
          *v19 = 0;
          v13[8] = *(_QWORD *)(v8 + v10 + 64);
          v14[8] = 0;
          v21 = v7[v10 / 8 + 6];
          v20 = v7[v10 / 8 + 7];
          v22 = *(_QWORD *)(v8 + v10 + 56);
          v13[6] = *(_QWORD *)(v8 + v10 + 48);
          v13[7] = v22;
          v14[6] = v21;
          v14[7] = v20;
          v13[9] = *(_QWORD *)(v8 + v10 + 72);
          if (*v19)
          {
            if ((v14[6] & 1) != 0)
            {
              (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v19 + 40))(*v19, v14[7]);
              v12 = 0uLL;
            }
            *(_OWORD *)v19 = v12;
            *(_OWORD *)(v8 + v10 + 56) = v12;
          }
          if (*v15)
          {
            if ((v14[2] & 1) != 0)
            {
              (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v15 + 40))(*v15, v14[3]);
              v12 = 0uLL;
            }
            *(_OWORD *)v15 = v12;
            *(_OWORD *)(v8 + v10 + 24) = v12;
          }
          v10 += 80;
        }
        while (v11 != v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_24;
    }
  }
  return result;
}

void re::FixedArray<re::AssetHandle>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;

  *a1 = a2;
  a1[1] = a3;
  if (!a3)
    return;
  if (a3 >= 0xAAAAAAAAAAAAAABLL)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 24, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v5 = 24 * a3;
  v6 = (_QWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 24 * a3, 8);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 24);
    v8 = (_QWORD *)((char *)v8 + v5 - 24);
  }
  *v8 = 0;
  v8[1] = 0;
  v8[2] = 0;
}

_QWORD *re::FixedArray<re::AssetHandle>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  re::AssetHandle *v4;
  uint64_t v5;
  uint64_t v6;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = (re::AssetHandle *)result[2];
      v5 = 24 * v2;
      do
      {
        re::AssetHandle::~AssetHandle(v4);
        v4 = (re::AssetHandle *)(v6 + 24);
        v5 -= 24;
      }
      while (v5);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v1 + 40))(*v1, v1[2]);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

re::DynamicString *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::AssetPath *,re::AssetPath *,re::AssetPath *>(re::DynamicString *result, re::DynamicString *a2, uint64_t a3)
{
  _QWORD *v4;
  _QWORD *v5;
  re::DynamicString *v6;

  if (result != a2)
  {
    v4 = (_QWORD *)(a3 + 40);
    v5 = (_QWORD *)((char *)result + 40);
    do
    {
      *((_DWORD *)v4 - 10) = *((_DWORD *)v5 - 10);
      re::DynamicString::operator=((re::DynamicString *)(v4 - 4), (re::DynamicString *)(v5 - 4));
      result = re::DynamicString::operator=((re::DynamicString *)v4, (re::DynamicString *)v5);
      v4[4] = v5[4];
      v4 += 10;
      v6 = (re::DynamicString *)(v5 + 5);
      v5 += 10;
    }
    while (v6 != a2);
  }
  return result;
}

uint64_t re::DynamicArray<re::AssetPath>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __n128 *v6;
  __n128 v7;
  unint64_t v8;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 80 * v4;
        v6 = (__n128 *)(v3 + 40);
        v7 = 0uLL;
        do
        {
          if (v6->n128_u64[0])
          {
            if ((v6->n128_u8[8] & 1) != 0)
            {
              (*(void (**)(unint64_t, unint64_t, __n128))(*(_QWORD *)v6->n128_u64[0] + 40))(v6->n128_u64[0], v6[1].n128_u64[0], v7);
              v7 = 0uLL;
            }
            *v6 = v7;
            v6[1] = v7;
          }
          v8 = v6[-2].n128_u64[0];
          if (v8)
          {
            if ((v6[-2].n128_u8[8] & 1) != 0)
            {
              (*(void (**)(unint64_t, unint64_t, __n128))(*(_QWORD *)v8 + 40))(v8, v6[-1].n128_u64[0], v7);
              v7 = 0uLL;
            }
            v6[-2] = v7;
            v6[-1] = v7;
          }
          v6 += 5;
          v5 -= 80;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  unsigned int v10;
  int v11;
  int v12;
  char v13;

  v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v13, a2);
  if (!*(_QWORD *)a1)
    return 0;
  v5 = v4 % *(unsigned int *)(a1 + 24);
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(unsigned int *)(v6 + 4 * v5);
  if ((_DWORD)v7 == 0x7FFFFFFF)
    return 0;
  v9 = *(_QWORD *)(a1 + 16);
  if (!re::DynamicString::operator==(v9 + 80 * v7 + 16, a2))
  {
    while (1)
    {
      v10 = v7;
      v11 = *(_DWORD *)(v9 + 80 * v7 + 8);
      v7 = v11 & 0x7FFFFFFF;
      if ((v11 & 0x7FFFFFFF) == 0x7FFFFFFF)
        return 0;
      if (re::DynamicString::operator==(v9 + 80 * v7 + 16, a2))
      {
        *(_DWORD *)(v9 + 80 * v10 + 8) = *(_DWORD *)(v9 + 80 * v10 + 8) & 0x80000000 | *(_DWORD *)(v9 + 80 * v7 + 8) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 80 * v7 + 8) & 0x7FFFFFFF;
LABEL_9:
  re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 16) + 80 * v7);
  v12 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v7 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v7 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v12 + 1;
  return 1;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addInternal<char const*&>(uint64_t a1, re::DynamicString *a2, int a3, const char **a4)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v16;
  _anonymous_namespace_ *v17;
  _OWORD *v18;
  _anonymous_namespace_ *v19;
  const char *v20;
  char v21;

  v8 = re::Hash<re::DynamicString>::operator()((uint64_t)&v21, (uint64_t)a2);
  v9 = v8;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v10) = 0;
    goto LABEL_8;
  }
  v10 = v8 % *(unsigned int *)(a1 + 24);
  v11 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v10);
  if ((_DWORD)v11 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<char const*&>(a1, v10, v9, a2, a4);
    ++*(_DWORD *)(a1 + 40);
    v14 = *(_QWORD *)(a1 + 16) + 80 * v13;
    return v14 + 48;
  }
  v12 = *(_QWORD *)(a1 + 16);
  while (!re::DynamicString::operator==(v12 + 80 * v11 + 16, (uint64_t)a2))
  {
    v11 = *(_DWORD *)(v12 + 80 * v11 + 8) & 0x7FFFFFFF;
    if (v11 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  switch(a3)
  {
    case 0:
    case 1:
      v14 = v12 + 80 * v11;
      break;
    case 2:
    case 3:
      v16 = v12 + 80 * v11;
      v19 = *(_anonymous_namespace_ **)(v16 + 48);
      v18 = (_OWORD *)(v16 + 48);
      v17 = v19;
      if (v19)
      {
        if ((*(_BYTE *)(v12 + 80 * v11 + 56) & 1) != 0)
          v17 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, _QWORD))(*(_QWORD *)v17 + 40))(v17, *(_QWORD *)(v12 + 80 * v11 + 64));
        *v18 = 0u;
        v18[1] = 0u;
        v12 = *(_QWORD *)(a1 + 16);
      }
      v20 = *a4;
      ++*(_DWORD *)(a1 + 40);
      v14 = *(_QWORD *)(a1 + 16) + 80 * v11;
      break;
    default:
      goto LABEL_8;
  }
  return v14 + 48;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<char const*&>(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, const char **a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  _anonymous_namespace_ *v14;
  re::DynamicString *v15;
  const char *v16;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 80 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10) = a3;
  v14 = re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 16), a4);
  v15 = (re::DynamicString *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 48);
  v16 = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (re::DynamicString *)(*(_QWORD *)&v13[16] + v10 + 16));
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 80;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, _QWORD *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 80 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 16), a4);
  v14 = *(_QWORD *)(a1 + 16) + 80 * v10;
  *(_OWORD *)(v14 + 48) = 0u;
  *(_OWORD *)(v14 + 64) = 0u;
  *(_QWORD *)(v14 + 72) = a5[3];
  v15 = a5[1];
  *(_QWORD *)(v14 + 48) = *a5;
  *a5 = 0;
  v16 = a5[2];
  a5[3] = 0;
  v18 = *(_QWORD *)(v14 + 56);
  v17 = *(_QWORD *)(v14 + 64);
  *(_QWORD *)(v14 + 56) = v15;
  *(_QWORD *)(v14 + 64) = v16;
  a5[1] = v18;
  a5[2] = v17;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 80 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_155, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

double re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1;
  uint64_t v3;
  _OWORD *v4;
  double result;
  uint64_t v6;

  v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    v4 = (_OWORD *)(a1 + 16);
    v3 = *(_QWORD *)(a1 + 16);
    *((_DWORD *)v4 - 2) = v1 & 0x7FFFFFFF;
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 24) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 32));
      result = 0.0;
      *v4 = 0u;
      v4[1] = 0u;
    }
    v6 = *(_QWORD *)(a1 + 48);
    if (v6)
    {
      if ((*(_BYTE *)(a1 + 56) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *(_QWORD *)(a1 + 64));
      result = 0.0;
      *(_OWORD *)(a1 + 48) = 0u;
      *(_OWORD *)(a1 + 64) = 0u;
    }
  }
  return result;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v8;

  v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v8, a2);
  if (!*(_QWORD *)a1)
    return 0;
  v5 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v5 == 0x7FFFFFFF)
    return 0;
  v6 = *(_QWORD *)(a1 + 16);
  while (!re::DynamicString::operator==(v6 + 80 * v5 + 16, a2))
  {
    v5 = *(_DWORD *)(v6 + 80 * v5 + 8) & 0x7FFFFFFF;
    if (v5 == 0x7FFFFFFF)
      return 0;
  }
  return v6 + 80 * v5 + 48;
}

uint64_t re::DynamicArray<std::function<void ()(void)>>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t result;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<std::function<void ()(void)>>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  result = std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100](*((_QWORD *)this + 4) + 32 * v4, a2);
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

_QWORD *re::DynamicArray<std::function<void ()(void)>>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<std::function<void ()(void)>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<std::function<void ()(void)>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<std::function<void ()(void)>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;

  v3 = result[1];
  if (v3 == a2)
    return result;
  v5 = result;
  if (result[2] > a2)
    return result;
  result = (_QWORD *)*result;
  if (!*v5)
  {
    result = (_QWORD *)re::DynamicArray<std::function<void ()(void)>>::setCapacity(v5, a2);
    ++*((_DWORD *)v5 + 6);
    return result;
  }
  if (a2)
  {
    if (a2 >> 59)
    {
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
      _os_crash();
      __break(1u);
    }
    else
    {
      v2 = 32 * a2;
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
      if (result)
      {
        v7 = result;
        if (!v5[1])
          goto LABEL_26;
        goto LABEL_11;
      }
    }
    re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
    result = (_QWORD *)_os_crash();
    __break(1u);
    return result;
  }
  v7 = 0;
  if (!v3)
    goto LABEL_26;
LABEL_11:
  v8 = (_QWORD *)v5[4];
  v9 = v5[2];
  if (!v9)
    goto LABEL_25;
  v10 = 32 * v9;
  v11 = v7;
  do
  {
    v12 = (_QWORD *)v8[3];
    if (v12)
    {
      if (v8 != v12)
      {
        v11[3] = v12;
        v8[3] = 0;
        goto LABEL_23;
      }
      v11[3] = v11;
      (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)v8[3] + 24))(v8[3], v11);
    }
    else
    {
      v11[3] = 0;
    }
    v13 = (_QWORD *)v8[3];
    if (v8 == v13)
    {
      v13 = v8;
      v14 = 4;
    }
    else
    {
      if (!v13)
        goto LABEL_23;
      v14 = 5;
    }
    (*(void (**)(void))(*v13 + 8 * v14))();
LABEL_23:
    v8 += 4;
    v11 += 4;
    v10 -= 32;
  }
  while (v10);
  v8 = (_QWORD *)v5[4];
LABEL_25:
  result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)*v5 + 40))(*v5, v8);
LABEL_26:
  v5[4] = v7;
  v5[1] = a2;
  return result;
}

uint64_t std::__function::__value_func<void ()(void)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(_QWORD *)(a1 + 24) = a1;
      (*(void (**)(_QWORD, uint64_t))(**(_QWORD **)(a2 + 24) + 24))(*(_QWORD *)(a2 + 24), a1);
    }
    else
    {
      *(_QWORD *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 16))(v3);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
  return a1;
}

double re::HashTable<unsigned long long,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)(v6 + 24));
          v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 72;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 80;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::DynamicArray<re::DynamicString>::deinit(uint64_t a1)
{
  uint64_t result;
  __n128 *v3;
  uint64_t v4;
  uint64_t v5;
  __n128 v6;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(__n128 **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 32 * v4;
        v6 = 0uLL;
        do
        {
          if (v3->n128_u64[0])
          {
            if ((v3->n128_u8[8] & 1) != 0)
            {
              (*(void (**)(unint64_t, unint64_t, __n128))(*(_QWORD *)v3->n128_u64[0] + 40))(v3->n128_u64[0], v3[1].n128_u64[0], v6);
              v6 = 0uLL;
            }
            *v3 = v6;
            v3[1] = v6;
          }
          v3 += 2;
          v5 -= 32;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(__n128 **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, __n128 *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::DynamicArray<re::AssetHandle>::deinit(uint64_t a1)
{
  uint64_t result;
  re::AssetHandle *v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(re::AssetHandle **)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 24 * v4;
        do
        {
          re::AssetHandle::~AssetHandle(v3);
          v3 = (re::AssetHandle *)((char *)v3 + 24);
          v5 -= 24;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(re::AssetHandle **)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, re::AssetHandle *))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::DynamicArray<re::AssetHandle>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::AssetHandle>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::AssetHandle>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

unsigned __int8 *re::Result<re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>,re::WrappedError>::~Result(unsigned __int8 *a1)
{
  id *v2;
  int v3;

  v3 = *a1;
  v2 = (id *)(a1 + 8);
  if (v3)
    re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::deinit((uint64_t)v2);
  else

  return a1;
}

uint64_t re::DynamicArray<re::DynamicArray<re::AssetLoadDescriptor>>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 40 * v4;
        do
        {
          re::DynamicArray<re::AssetLoadDescriptor>::deinit(v3);
          v3 += 40;
          v5 -= 40;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

uint64_t re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, int a4, re::AssetHandle *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 40 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 40 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 40 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9) = a3;
  re::AssetHandle::AssetHandle((re::AssetHandle *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 16), a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, (_QWORD *)(*(_QWORD *)&v13[16] + v10 + 16));
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 40;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

void re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 40 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_155, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 600);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 40 * v8 + 8);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 40 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 40 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v8 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v8) = a3;
  v12 = (_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v8);
  v12[2] = 0;
  v12[3] = 0;
  v12[4] = 0;
  v12[3] = a5[1];
  a5[1] = 0;
  v13 = v12[2];
  v12[2] = 0;
  v12[2] = *a5;
  *a5 = v13;
  v14 = v12[4];
  v12[4] = a5[2];
  a5[2] = v14;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

double re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 8;
      do
      {
        v6 = a1[2];
        v7 = *(_DWORD *)(v6 + v5);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + v5) = v7 & 0x7FFFFFFF;
          re::AssetHandle::~AssetHandle((re::AssetHandle *)(v6 + v5 + 8));
          v3 = *((unsigned int *)a1 + 8);
        }
        ++v4;
        v5 += 40;
      }
      while (v4 < v3);
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 88;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1;
  uint64_t v3;
  _OWORD *v4;
  double result;
  uint64_t v6;

  v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    v4 = (_OWORD *)(a1 + 24);
    v3 = *(_QWORD *)(a1 + 24);
    *((_DWORD *)v4 - 4) = v1 & 0x7FFFFFFF;
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 32) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 40));
      result = 0.0;
      *v4 = 0u;
      v4[1] = 0u;
    }
    v6 = *(_QWORD *)(a1 + 56);
    if (v6)
    {
      if ((*(_BYTE *)(a1 + 64) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *(_QWORD *)(a1 + 72));
      result = 0.0;
      *(_OWORD *)(a1 + 56) = 0u;
      *(_OWORD *)(a1 + 72) = 0u;
    }
  }
  return result;
}

uint64_t std::shared_ptr<re::AssetManager>::~shared_ptr[abi:nn180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

void re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 40 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_155, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void MemoryAssetProvider::~MemoryAssetProvider(MemoryAssetProvider *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

const char *MemoryAssetProvider::schemeName(MemoryAssetProvider *this)
{
  return "MemoryAsset";
}

void MemoryAssetProvider::load(uint64_t a1, uint64_t a2)
{
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Can't load a memory asset", "!\"Unreachable code\"", "load", 244);
  _os_crash();
  __break(1u);
}

uint64_t *MemoryAssetProvider::resolveChild@<X0>(const re::AssetLoadDescriptor *a1@<X1>, re::AssetProvider *a2@<X2>, const re::DynamicString *a3@<X3>, uint64_t a4@<X8>)
{
  const char *v9;
  _anonymous_namespace_ *v10;
  uint64_t *result;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  re::PathBuffer *v15;
  uint64_t v16;
  __n128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  int v24;
  __int128 v25;
  __int128 v26;
  int v27;
  _BYTE v28[24];
  __int128 v29;
  _BYTE v30[40];
  __int128 v31;
  int v32;
  __int128 v33;
  __int128 v34;
  int v35;
  _BYTE v36[24];
  __int128 v37;
  uint64_t v38;
  char v39;
  uint64_t *v40;
  uint64_t v41;
  re::PathBuffer *v42;
  uint64_t v43;

  if ((*((_BYTE *)a1 + 8) & 1) != 0)
    v9 = (const char *)*((_QWORD *)a1 + 2);
  else
    v9 = (char *)a1 + 9;
  v10 = (_anonymous_namespace_ *)strcmp(v9, "MemoryAsset");
  if ((_DWORD)v10)
  {
    result = (uint64_t *)re::DynamicString::format((re::DynamicString *)"Scheme %s does not match scheme %s.", (re::DynamicString *)v30, v9, "MemoryAsset");
    v12 = *(_OWORD *)v30;
    v13 = *(_OWORD *)&v30[16];
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v12;
    *(_OWORD *)(a4 + 24) = v13;
  }
  else
  {
    v41 = 0;
    v42 = 0;
    v43 = 0;
    re::DynamicString::setCapacity(&v40, 0);
    v14 = re::AssetLoadDescriptor::getIntrospectableData<re::DynamicString>(a1, &v40);
    if ((v14 & 1) != 0)
    {
      if ((v41 & 1) != 0)
        v15 = v42;
      else
        v15 = (re::PathBuffer *)((char *)&v41 + 1);
      re::AssetProvider::resolveChildPath(a2, v15, &v38);
      MemoryAssetProvider::makeDescriptor((MemoryAssetProvider *)&v38, a3, (uint64_t)&v20);
      v16 = v20;
      v20 = 0;
      *(_QWORD *)v30 = v16;
      *(_OWORD *)&v30[24] = v22;
      v22 = 0u;
      *(_OWORD *)&v30[8] = v21;
      v21 = 0u;
      v31 = v23;
      v23 = 0u;
      ++v24;
      v32 = 1;
      v33 = v25;
      v34 = v26;
      v25 = 0u;
      v26 = 0u;
      ++v27;
      v35 = 1;
      *(_OWORD *)v36 = *(_OWORD *)v28;
      memset(v28, 0, sizeof(v28));
      v37 = v29;
      *(_QWORD *)&v36[16] = *(_QWORD *)&v28[16];
      v29 = 0uLL;
      v17.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional(a4, (uint64_t)v30);
      if (*(_QWORD *)&v36[8])
      {
        if ((v36[16] & 1) != 0)
          (*(void (**)(double))(**(_QWORD **)&v36[8] + 40))(v17.n128_f64[0]);
        v17 = 0uLL;
        *(_OWORD *)&v36[8] = 0u;
        v37 = 0u;
      }
      if (*((_QWORD *)&v33 + 1))
      {
        if (*(_QWORD *)v36)
          (*(void (**)(__n128))(**((_QWORD **)&v33 + 1) + 40))(v17);
        *(_QWORD *)v36 = 0;
        v34 = 0uLL;
        *((_QWORD *)&v33 + 1) = 0;
        ++v35;
      }
      if (*(_QWORD *)&v30[32])
      {
        if ((_QWORD)v33)
          (*(void (**)(__n128))(**(_QWORD **)&v30[32] + 40))(v17);
        *(_QWORD *)&v33 = 0;
        v31 = 0uLL;
        *(_QWORD *)&v30[32] = 0;
        ++v32;
      }
      if (*(_QWORD *)v30)
      {
        if ((v30[8] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)v30 + 40))(v17);
        v17 = 0uLL;
        memset(v30, 0, 32);
      }
      if (*(_QWORD *)&v28[8])
      {
        if ((v28[16] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)&v28[8] + 40))(v17);
        v17 = 0uLL;
        *(_OWORD *)&v28[8] = 0u;
        v29 = 0u;
      }
      if (*((_QWORD *)&v25 + 1))
      {
        if (*(_QWORD *)v28)
          (*(void (**)(__n128))(**((_QWORD **)&v25 + 1) + 40))(v17);
        *(_QWORD *)v28 = 0;
        v26 = 0uLL;
        *((_QWORD *)&v25 + 1) = 0;
        ++v27;
      }
      if (*((_QWORD *)&v22 + 1))
      {
        if ((_QWORD)v25)
          (*(void (**)(__n128))(**((_QWORD **)&v22 + 1) + 40))(v17);
        *(_QWORD *)&v25 = 0;
        v23 = 0uLL;
        *((_QWORD *)&v22 + 1) = 0;
        ++v24;
      }
      if (v20 && (v21 & 1) != 0)
        (*(void (**)(__n128))(*(_QWORD *)v20 + 40))(v17);
      if (v38 && (v39 & 1) != 0)
        (*(void (**)(__n128))(*(_QWORD *)v38 + 40))(v17);
    }
    else
    {
      v17 = *(__n128 *)v30;
      v18 = *(_QWORD *)&v30[16];
      v19 = *(_QWORD *)&v30[24];
      *(_BYTE *)a4 = 0;
      *(__n128 *)(a4 + 8) = v17;
      *(_QWORD *)(a4 + 24) = v18;
      *(_QWORD *)(a4 + 32) = v19;
    }
    result = v40;
    if (v40)
    {
      if ((v41 & 1) != 0)
        return (uint64_t *)(*(uint64_t (**)(__n128))(*v40 + 40))(v17);
    }
  }
  return result;
}

uint64_t *MemoryAssetProvider::getDescription(MemoryAssetProvider *this, const re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  uint64_t *result;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];

  v7 = 0;
  v8 = 0;
  v9 = 0;
  re::DynamicString::setCapacity(&v6, 0);
  if (re::AssetLoadDescriptor::getIntrospectableData<re::DynamicString>(a2, &v6))
  {
    re::DynamicString::operator=(a3, (re::DynamicString *)&v6);
  }
  else
  {
    v10[0] = "mangled";
    v10[1] = 7;
    re::DynamicString::operator=(a3, (uint64_t)v10);
  }
  result = v6;
  if (v6)
  {
    if ((v7 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v6 + 40))();
  }
  return result;
}

uint64_t *MemoryAssetProvider::getAssetPathForRelease@<X0>(_anonymous_namespace_ *a1@<X0>, char *a2@<X1>, re::internal::AssetTypeRegistry *a3@<X2>, uint64_t a4@<X8>)
{
  char *v7;
  _anonymous_namespace_ *v8;
  _anonymous_namespace_ *v9;
  const char *v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *result;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  const char *v28;
  uint64_t v29;

  v27 = 0;
  v28 = 0;
  v29 = 0;
  re::DynamicString::setCapacity(&v26, 0);
  re::AssetLoadDescriptor::getIntrospectableData<re::DynamicString>((re::AssetLoadDescriptor *)a2, &v26);
  if ((*((_QWORD *)a2 + 15) & 1) != 0)
    v7 = (char *)*((_QWORD *)a2 + 16);
  else
    v7 = a2 + 121;
  v8 = (_anonymous_namespace_ *)re::internal::AssetTypeRegistry::assetTypeWithName(a3, v7);
  LODWORD(v18) = 0;
  v21 = 0;
  v22 = 0;
  v20 = 0;
  v9 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v19, 0);
  *((_QWORD *)&v23 + 1) = 0;
  v24 = 0uLL;
  re::DynamicString::setCapacity(&v23, 0);
  v25 = 0;
  if ((v27 & 1) != 0)
    v10 = v28;
  else
    v10 = (char *)&v27 + 1;
  re::AssetPath::initMemoryAssetPath(&v18, v10, (uint64_t)v8);
  v16 = 0;
  v17 = 0;
  v15 = (unint64_t)v19;
  re::DynamicString::setCapacity(&v15, 0);
  re::AssetPath::fullAssetPath((re::DynamicString *)&v18, (re::DynamicString *)&v15);
  v11 = v15;
  v12 = v16;
  v13 = v17;
  *(_BYTE *)a4 = 1;
  *(_OWORD *)(a4 + 8) = v11;
  *(_QWORD *)(a4 + 24) = v12;
  *(_QWORD *)(a4 + 32) = v13;
  if ((_QWORD)v23)
  {
    if ((BYTE8(v23) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v23 + 40))();
    v23 = 0u;
    v24 = 0u;
  }
  if (v19 && (v20 & 1) != 0)
    (*(void (**)(void))(*v19 + 40))();
  result = v26;
  if (v26)
  {
    if ((v27 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v26 + 40))();
  }
  return result;
}

uint64_t MemoryAssetProvider::makeDescriptorFromAssetPath@<X0>(const re::DynamicString ***a1@<X1>, uint64_t a2@<X8>)
{
  __n128 v4;
  uint64_t result;
  uint64_t v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;

  MemoryAssetProvider::makeDescriptor((MemoryAssetProvider *)(a1 + 5), *a1[9], (uint64_t)&v6);
  v4.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional(a2, (uint64_t)&v6);
  if ((_QWORD)v18)
  {
    if ((BYTE8(v18) & 1) != 0)
      (*(void (**)(double))(*(_QWORD *)v18 + 40))(v4.n128_f64[0]);
    v4 = 0uLL;
    v18 = 0u;
    v19 = 0u;
  }
  if (v13)
  {
    if (v17)
      (*(void (**)(__n128))(*(_QWORD *)v13 + 40))(v4);
    v17 = 0;
    v14 = 0;
    v15 = 0;
    v13 = 0;
    ++v16;
  }
  if (v8)
  {
    if (v12)
      (*(void (**)(__n128))(*(_QWORD *)v8 + 40))(v4);
    v12 = 0;
    v9 = 0;
    v10 = 0;
    v8 = 0;
    ++v11;
  }
  result = v6;
  if (v6)
  {
    if ((v7 & 1) != 0)
      return (*(uint64_t (**)(__n128))(*(_QWORD *)v6 + 40))(v4);
  }
  return result;
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<re::DynamicString>(re::AssetLoadDescriptor *a1, uint64_t **a2)
{
  uint64_t **v2;
  unsigned __int8 v3;
  __guard *v4;
  int v6;
  const re::IntrospectionBase *v7;
  int v8;
  re::AssetLoadDescriptor *v10;

  v2 = a2;
  if ((v3 & 1) == 0)
  {
    v10 = a1;
    v8 = v6;
    v2 = a2;
    a1 = v10;
    if (v8)
    {
      re::introspect<re::DynamicString>(void)::info = (uint64_t)re::IntrospectionInfo<re::DynamicString>::get(0, v7);
      v2 = a2;
      a1 = v10;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)v4[42], v2, 0);
}

void std::__shared_ptr_pointer<re::AssetManager *,re::AssetManager::init(re::AssetManager::Config const&)::$_0,std::allocator<re::AssetManager>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x2276933B8);
}

uint64_t std::__shared_ptr_pointer<re::AssetManager *,re::AssetManager::init(re::AssetManager::Config const&)::$_0,std::allocator<re::AssetManager>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

uint64_t re::DynamicArray<re::internal::AssetNetworkLoader::SerializedAssetResponse>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = (_QWORD *)(v3 + 96);
        v6 = 112 * v4;
        do
        {
          v7 = *(v5 - 4);
          if (v7)
          {
            if (*v5)
              (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
            *v5 = 0;
            *(v5 - 3) = 0;
            *(v5 - 2) = 0;
            *(v5 - 4) = 0;
            ++*((_DWORD *)v5 - 2);
          }
          v8 = *(v5 - 8);
          if (v8)
          {
            if ((*(_BYTE *)(v5 - 7) & 1) != 0)
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *(v5 - 6));
            *((_OWORD *)v5 - 4) = 0u;
            *((_OWORD *)v5 - 3) = 0u;
          }
          re::AssetHandle::~AssetHandle((re::AssetHandle *)(v5 - 11));
          v5 += 14;
          v6 -= 112;
        }
        while (v6);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

double re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::FragmentedNetworkAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1, double result)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  __n128 v7;
  uint64_t v8;
  __n128 *v9;
  int v10;
  uint64_t v11;
  __n128 *v12;
  uint64_t v13;

  v3 = *a1;
  if (v3)
  {
    v4 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v4)
    {
      v5 = 0;
      v6 = 0;
      v7 = 0uLL;
      do
      {
        v8 = a1[2];
        v9 = (__n128 *)(v8 + v5);
        v10 = *(_DWORD *)(v8 + v5 + 8);
        if (v10 < 0)
        {
          v9->n128_u32[2] = v10 & 0x7FFFFFFF;
          v13 = v9[1].n128_i64[0];
          v12 = v9 + 1;
          v11 = v13;
          if (v13)
          {
            if ((*(_BYTE *)(v8 + v5 + 24) & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v11 + 40))(v11, *(_QWORD *)(v8 + v5 + 32), v7);
              v7 = 0uLL;
            }
            *v12 = v7;
            v12[1] = v7;
            v4 = *((unsigned int *)a1 + 8);
          }
        }
        ++v6;
        v5 += 88;
      }
      while (v6 < v4);
      v3 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 40))(v3, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

double re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::PendingRequestedAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::PendingRequestedAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 80;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::PendingRequestedAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1;
  uint64_t v3;
  _OWORD *v4;

  v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    v4 = (_OWORD *)(a1 + 16);
    v3 = *(_QWORD *)(a1 + 16);
    *((_DWORD *)v4 - 2) = v1 & 0x7FFFFFFF;
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 24) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 32));
      *v4 = 0u;
      v4[1] = 0u;
    }
    re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 56));
  }
}

void re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  _QWORD *v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      v7 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)&v13[16] = v7;
      *(_QWORD *)(a1 + 16) = v6;
      v9 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = (_QWORD *)(v7 + 16);
        do
        {
          if ((*(_DWORD *)(v11 - 1) & 0x80000000) != 0)
            re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::addAsMove(a1, *(v11 - 2) % (unint64_t)*(unsigned int *)(a1 + 24), *(v11 - 2), v11);
          v11 += 3;
          --v10;
        }
        while (v10);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

void re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_155, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 600);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::addAsMove(uint64_t result, unsigned int a2, unint64_t a3, _QWORD *a4)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;

  v6 = result;
  v7 = *(unsigned int *)(result + 36);
  if ((_DWORD)v7 == 0x7FFFFFFF)
  {
    v7 = *(unsigned int *)(result + 32);
    v8 = v7;
    if ((_DWORD)v7 == *(_DWORD *)(result + 24))
    {
      result = re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::setCapacity(result, (2 * *(_DWORD *)(result + 28)));
      a2 = a3 % *(unsigned int *)(v6 + 24);
      v8 = *(_DWORD *)(v6 + 32);
    }
    *(_DWORD *)(v6 + 32) = v8 + 1;
    v9 = *(_QWORD *)(v6 + 16);
    v10 = *(_DWORD *)(v9 + 24 * v7 + 8);
  }
  else
  {
    v9 = *(_QWORD *)(result + 16);
    v10 = *(_DWORD *)(v9 + 24 * v7 + 8);
    *(_DWORD *)(result + 36) = v10 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v9 + 24 * v7 + 8) = v10 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(v6 + 16) + 24 * v7 + 8) = *(_DWORD *)(*(_QWORD *)(v6 + 16) + 24 * v7 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(v6 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(v6 + 16) + 24 * v7) = a3;
  *(_QWORD *)(*(_QWORD *)(v6 + 16) + 24 * v7 + 16) = *a4;
  *(_DWORD *)(*(_QWORD *)(v6 + 8) + 4 * a2) = v7;
  ++*(_DWORD *)(v6 + 28);
  return result;
}

void re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1;
  uint64_t v3;
  _OWORD *v4;
  uint64_t v5;

  v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    v4 = (_OWORD *)(a1 + 16);
    v3 = *(_QWORD *)(a1 + 16);
    *((_DWORD *)v4 - 2) = v1 & 0x7FFFFFFF;
    if (v3)
    {
      if ((*(_BYTE *)(a1 + 24) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(a1 + 32));
      *v4 = 0u;
      v4[1] = 0u;
    }
    v5 = *(_QWORD *)(a1 + 48);
    if (v5)
    {

      *(_QWORD *)(a1 + 48) = 0;
    }
  }
}

double re::HashTable<unsigned long long,re::SharedPtr<re::RealityFile>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  uint64_t v8;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          v8 = *(_QWORD *)(v6 + 24);
          if (v8)
          {

            *(_QWORD *)(v6 + 24) = 0;
            v3 = *((unsigned int *)a1 + 8);
          }
        }
        v4 += 32;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void std::__list_imp<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>>::clear(uint64_t *a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;

  if (a1[2])
  {
    v2 = *a1;
    v3 = (uint64_t *)a1[1];
    v4 = *v3;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(*a1 + 8);
    **(_QWORD **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        v5 = (uint64_t *)v3[1];
        std::__destroy_at[abi:nn180100]<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,0>(v3 + 2);
        operator delete(v3);
        v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

double std::__destroy_at[abi:nn180100]<re::Pair<re::DynamicString,re::Pair<re::SharedPtr<re::RealityFile>,unsigned int,true>,true>,0>(_QWORD *a1)
{
  uint64_t v2;
  double result;

  v2 = a1[4];
  if (v2)
  {

    a1[4] = 0;
  }
  if (*a1)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a1 + 40))(*a1, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

void std::__function::__func<re::AssetManager::update(BOOL,BOOL)::$_0,std::allocator<re::AssetManager::update(BOOL,BOOL)::$_0>,void ()(void)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

__n128 std::__function::__func<re::AssetManager::update(BOOL,BOOL)::$_0,std::allocator<re::AssetManager::update(BOOL,BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24ED2C830;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<re::AssetManager::update(BOOL,BOOL)::$_0,std::allocator<re::AssetManager::update(BOOL,BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED2C830;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<re::AssetManager::update(BOOL,BOOL)::$_0,std::allocator<re::AssetManager::update(BOOL,BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  unint64_t os_unfair_lock_opaque;
  uint64_t v3;
  _BOOL8 v4;
  re *isStatisticCollectionEnabled;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  signed int v9;
  int64_t v10;
  dispatch_time_t v11;
  dispatch_time_t v12;
  dispatch_time_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  id v19;
  os_unfair_lock_s *v20;
  os_unfair_lock_s *v21;
  os_unfair_lock_s *v22;
  os_unfair_lock_s *v23;
  uint64_t v24;
  id v25;
  _QWORD *v26;
  unint64_t i;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  os_unfair_lock_s *v35;
  void (**v36)(re::CancellationTokenSource *__hidden);
  uint64_t LoadItemResult;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  int v42;
  const char *v43;
  NSObject *v44;
  unint64_t v45;
  uint64_t v46;
  os_unfair_lock_s *v47;
  _anonymous_namespace_ *v48;
  uint64_t v49;
  int v50;
  NSObject *v51;
  unint64_t v52;
  NSObject *v53;
  unint64_t v54;
  const char *v55;
  NSObject *v56;
  uint64_t v57;
  re::AssetHandle **v58;
  uint64_t v59;
  re::AssetHandle *v60;
  _anonymous_namespace_ *v61;
  unint64_t v62;
  void (**v63)(re::CancellationTokenSource *__hidden);
  char *v64;
  char *v65;
  uint64_t *v66;
  unint64_t v67;
  re *v68;
  NSObject *v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  char v74;
  _anonymous_namespace_ *v75;
  uint64_t v76;
  re *v77;
  os_unfair_lock_s **v78;
  os_unfair_lock_s *v79;
  os_unfair_lock_s **v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  re *v85;
  unint64_t v86;
  uint64_t v87;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t *v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t *v95;
  uint64_t v96;
  uint64_t v97;
  id v98;
  uint64_t v99;
  id v100;
  uint64_t v101;
  std::chrono::steady_clock::time_point v102;
  __n128 *v103;
  uint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  uint64_t v109;
  std::chrono::steady_clock::time_point v110;
  unint64_t v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  unsigned int v117;
  uint64_t v118;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v119;
  int v120;
  unint64_t v121;
  unint64_t v122;
  uint64_t v123;
  re::internal::AssetNetworkLoader *v124;
  re::ProfilerConfig *v125;
  uint64_t v126;
  unsigned __int8 v127;
  uint64_t v128;
  _anonymous_namespace_ *v129;
  _anonymous_namespace_ *v130;
  uint64_t v131;
  _anonymous_namespace_ *v132;
  unint64_t v133;
  _DWORD *v134;
  uint64_t v135;
  __n128 *v137;
  unint64_t v138;
  uint64_t v139;
  uint64_t v140;
  char v141;
  unint64_t v142;
  uint64_t v143;
  char v144;
  __n128 *v145;
  re *v146;
  NSObject *v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  __int128 v152;
  uint64_t v153;
  int64x2_t *v154;
  uint64_t v155;
  uint64_t v156;
  int64x2_t v157;
  signed int v158;
  int v159;
  re::MeshAsset *v160;
  re::AssetHandle *v161;
  unint64_t v162;
  unint64_t v163;
  re::AssetHandle *v164;
  uint64_t v165;
  unint64_t v166;
  unint64_t v167;
  unint64_t v168;
  uint64_t v169;
  uint64_t v170;
  _QWORD *v171;
  unint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t *v178;
  uint64_t *v179;
  uint64_t *v180;
  uint64_t *v181;
  uint64_t v182;
  BOOL v183;
  uint64_t v184;
  uint64_t *v185;
  uint64_t *v186;
  unint64_t v187;
  uint64_t v188;
  uint64_t v189;
  int *v190;
  int v191;
  unint64_t v192;
  unint64_t v193;
  unint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  id v198;
  unsigned int v199;
  uint64_t **v200;
  int v201;
  int v202;
  unint64_t v203;
  re::ProfilerConfig *v204;
  uint64_t v205;
  int64x2_t *v206;
  uint64_t *v207;
  uint64_t *v208;
  uint64_t *v209;
  int64x2_t v210;
  uint64_t v211;
  int64x2_t *v212;
  unint64_t v213;
  unint64_t v214;
  unint64_t v215;
  int64x2_t v216;
  uint64_t v217;
  int64x2_t *v218;
  unint64_t v219;
  unint64_t v220;
  int64x2_t v221;
  uint64_t v222;
  int64x2_t *v223;
  unint64_t v224;
  unint64_t v225;
  unint64_t v226;
  int64x2_t v227;
  uint64_t v228;
  int64x2_t *v229;
  unint64_t v230;
  unint64_t v231;
  int64x2_t v232;
  uint64_t v233;
  int64x2_t *v234;
  unint64_t v235;
  unint64_t v236;
  int64x2_t v237;
  uint64_t v238;
  int64x2_t *v239;
  re::AssetHandle *v240;
  re::AssetHandle *v241;
  int64x2_t v242;
  uint64_t v243;
  int64x2_t *v244;
  re::AssetHandle *v245;
  re::AssetHandle *v246;
  int64x2_t v247;
  uint64_t v248;
  int64x2_t *v249;
  unint64_t v250;
  unint64_t v251;
  int64x2_t v252;
  re *v253;
  uint64_t v254;
  int64x2_t *v255;
  unint64_t v256;
  unint64_t v257;
  int64x2_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  dispatch_time_t v266;
  int64_t v267;
  std::chrono::steady_clock::time_point v268;
  uint64_t v269;
  _QWORD *v270;
  unint64_t v271;
  re::AssetHandle *v272;
  re::AssetHandle *v273;
  re::AssetHandle *v274;
  re::AssetHandle *v275;
  dispatch_time_t v276;
  unint64_t v277;
  os_unfair_lock_s *lock;
  _QWORD v279[3];
  _QWORD v280[3];
  _QWORD v281[3];
  __int128 v282;
  __int128 v283;
  __int128 v284;
  __int128 v285;
  int v286;
  uint64_t v287;
  unint64_t v288;
  unint64_t v289;
  uint64_t v290;
  uint64_t v291;
  unint64_t v292;
  uint64_t v293;
  uint64_t v294;
  __n128 buf[2];
  _BYTE v296[56];
  __int128 v297;
  __int128 v298;
  __int128 v299;
  uint64_t v300;
  __int128 v301;
  __int128 v302;
  _BYTE v303[12];
  _BYTE v304[28];
  __int16 v305;
  unint64_t v306;
  uint64_t *v307;
  unint64_t v308;
  unint64_t v309;
  int v310;
  __int16 v311;
  os_unfair_lock_s *v312;
  uint64_t v313;

  v313 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 8);
  v4 = re::internal::enableSignposts(0, 0);
  if (v4)
  {
    v4 = re::internal::enableHighFrequencyTracing(0, 0);
    if (v4)
    {
      re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)buf, 2000, v3);
      re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)buf);
    }
  }
  isStatisticCollectionEnabled = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v4);
  if ((_DWORD)isStatisticCollectionEnabled)
  {
    v6 = re::profilerThreadContext(isStatisticCollectionEnabled);
    if (*(_QWORD *)(v6 + 152))
      v263 = mach_absolute_time();
  }
  else
  {
    v6 = 0;
  }
  if (*(_BYTE *)(a1 + 17))
    *(_BYTE *)(v3 + 1785) = 0;
  v7 = *(_OWORD *)(v3 + 1512);
  v282 = *(_OWORD *)(v3 + 1496);
  v283 = v7;
  v284 = 0u;
  v285 = 0u;
  v286 = 0;
  v287 = 0x7FFFFFFFLL;
  v8 = *(_QWORD *)(v3 + 1528);
  if (v8)
  {
    if (*(_DWORD *)(v3 + 1556) <= 3u)
      v9 = 3;
    else
      v9 = *(_DWORD *)(v3 + 1556);
    re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::init((uint64_t)&v284, v8, v9);
    re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::copy((uint64_t)&v284, v3 + 1528);
  }
  v270 = (_QWORD *)(v3 + 1528);
  v265 = v6;
  if (!*(_BYTE *)(a1 + 16))
  {
    v12 = dispatch_time(0, 0);
    v10 = -1;
    goto LABEL_19;
  }
  v10 = *(_QWORD *)(v3 + 1448);
  v11 = dispatch_time(0, 0);
  v12 = v11;
  if (v10 == -1)
  {
LABEL_19:
    v13 = -1;
    goto LABEL_20;
  }
  v13 = dispatch_time(v11, v10);
LABEL_20:
  v14 = (uint64_t)&v301;
  *(_QWORD *)v303 = 0;
  *(_QWORD *)&v302 = 0;
  v301 = 0uLL;
  DWORD2(v302) = 0;
  v15 = *(_QWORD *)(v3 + 40);
  if (v15)
  {
    v16 = *(unint64_t **)(v3 + 56);
    v17 = 8 * v15;
    do
    {
      v18 = *v16;
      buf[0].n128_u64[0] = v18;
      if (v18)
        v19 = (id)(v18 + 8);
      v20 = *(os_unfair_lock_s **)(v18 + 24);
      v21 = v20 + 48;
      os_unfair_lock_lock(v20 + 48);
      os_unfair_lock_opaque = v20[84]._os_unfair_lock_opaque;
      os_unfair_lock_unlock(v21);
      if ((_DWORD)os_unfair_lock_opaque)
        re::DynamicArray<re::SharedPtr<re::AssetLoadRequest>>::add((_anonymous_namespace_ *)&v301, (uint64_t *)buf);

      ++v16;
      v17 -= 8;
    }
    while (v17);
    if ((_QWORD)v302)
    {
      v22 = *(os_unfair_lock_s **)v303;
      v23 = (os_unfair_lock_s *)(*(_QWORD *)v303 + 8 * v302);
      do
      {
        v24 = *(_QWORD *)&v22->_os_unfair_lock_opaque;
        if (*(_QWORD *)&v22->_os_unfair_lock_opaque)
          v25 = (id)(v24 + 8);
        v26 = *(_QWORD **)(v3 + 56);
        i = *(_QWORD *)(v3 + 40);
        v28 = &v26[i];
        v29 = v26;
        if (i)
        {
          v30 = 8 * i;
          v29 = *(_QWORD **)(v3 + 56);
          while (*v29 != v24)
          {
            ++v29;
            v30 -= 8;
            if (!v30)
            {
              v29 = &v26[i];
              break;
            }
          }
        }
        os_unfair_lock_opaque = v29 - v26;
        if (os_unfair_lock_opaque != i)
        {
          if (i <= os_unfair_lock_opaque)
            goto LABEL_472;
          v31 = i - 1;
          if (i - 1 > os_unfair_lock_opaque)
          {
            v32 = v26[os_unfair_lock_opaque];
            v26[os_unfair_lock_opaque] = *(v28 - 1);
            *(v28 - 1) = v32;
            v26 = *(_QWORD **)(v3 + 56);
          }
          v33 = &v26[i];
          v34 = *(v33 - 1);
          if (v34)
          {

            *(v33 - 1) = 0;
            v31 = *(_QWORD *)(v3 + 40) - 1;
          }
          *(_QWORD *)(v3 + 40) = v31;
          ++*(_DWORD *)(v3 + 48);
        }
        if (v24)

        v22 += 2;
      }
      while (v22 != v23);
    }
  }
  re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)&v301);
  v281[0] = v12;
  v281[1] = v13;
  v281[2] = v10;
  re::AssetManager::updateLoadRequests(v3, (uint64_t)v281);
  v266 = v12;
  v267 = v10;
  v280[0] = v12;
  v280[1] = v13;
  v280[2] = v10;
  re::AssetManager::processUnreferencedUnloadRequests(v3, (uint64_t)v280);
  if (re::internal::enableSignposts(0, 0) && re::internal::enableHighFrequencyTracing(0, 0))
  {
    re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)buf, 2012, 61);
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)buf);
  }
  atomic_load((unsigned __int8 *)(v3 + 1409));
  v268.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v35 = (os_unfair_lock_s *)(v3 + 64);
  v36 = &off_24ED2C6A0;
  v276 = v13;
  lock = (os_unfair_lock_s *)(v3 + 64);
  do
  {
    LoadItemResult = re::internal::AssetBackgroundLoader::tryGetLoadItemResult(*(_QWORD *)(v3 + 1096), 1);
    if (!LoadItemResult)
      break;
    i = LoadItemResult;
    v39 = *(_QWORD *)(LoadItemResult + 24);
    v40 = *(_DWORD *)(v39 + 16);
    switch(v40)
    {
      case 2:
        re::AssetManager::onUnloadComplete((os_unfair_lock_s *)v3, *(_QWORD *)v39);
        break;
      case 1:
        v42 = *(_DWORD *)(LoadItemResult + 136);
        if (v42 == 3)
        {
          v44 = *re::assetsLogObjects((re *)LoadItemResult);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          {
            if ((*(_BYTE *)(i + 40) & 1) != 0)
              v45 = *(_QWORD *)(i + 48);
            else
              v45 = i + 41;
            buf[0].n128_u32[0] = 136315138;
            *(unint64_t *)((char *)buf[0].n128_u64 + 4) = v45;
            _os_log_impl(&dword_224FE9000, v44, OS_LOG_TYPE_DEFAULT, "Asset load (which was cancelled) failed '%s'", (uint8_t *)buf, 0xCu);
          }
          if (*(_BYTE *)(i + 144))
            re::DynamicString::append((re::DynamicString *)(i + 152), " (was also cancelled)", 0x15uLL);
        }
        else
        {
          if (v42 != 2)
            goto LABEL_479;
          if ((*(_BYTE *)(LoadItemResult + 40) & 1) != 0)
            v43 = *(const char **)(LoadItemResult + 48);
          else
            v43 = (const char *)(LoadItemResult + 41);
          re::AssetManager::unloadAssetPointer((re::AssetManager *)v3, *(const re::AssetType **)(LoadItemResult + 64), *(void **)(LoadItemResult + 96), v43, *(_QWORD *)v39);
          *(_QWORD *)(i + 96) = 0;
        }
        break;
      case 0:
        v304[0] = 0;
        if (*(_BYTE *)(LoadItemResult + 344))
        {
          v41 = *(_QWORD *)(LoadItemResult + 360);
          goto LABEL_66;
        }
        if (*(_BYTE *)(LoadItemResult + 184))
        {
          v41 = *(_QWORD *)(LoadItemResult + 240);
LABEL_66:
          os_unfair_lock_lock(v35);
          re::AssetManager::lookupExistingAsset_assetTablesLocked((re::internal::AssetTypeRegistry **)v3, v41, buf);
          os_unfair_lock_unlock(v35);
LABEL_67:
          LoadItemResult = re::Optional<re::AssetHandle>::operator=((uint64_t)v304, buf);
          if (buf[0].n128_u8[0])
            re::AssetHandle::~AssetHandle((re::AssetHandle *)&buf[0].n128_i8[8]);
        }
        else if (*(_BYTE *)(LoadItemResult + 248))
        {
          re::AssetManager::lookupExistingAsset((re::AssetManager *)buf, (os_unfair_lock_s *)v3, (re::DynamicString *)(LoadItemResult + 256));
          goto LABEL_67;
        }
        if (v304[0])
        {
          v46 = *(_QWORD *)&v304[16];
          v47 = (os_unfair_lock_s *)(*(_QWORD *)&v304[16] + 384);
          os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)&v304[16] + 384));
          *(_QWORD *)(v46 + 400) = 0;
          v50 = *(_DWORD *)(i + 136);
          if (v50 == 3)
          {
            if (*(_BYTE *)(i + 144))
            {
              if ((*(_BYTE *)(i + 160) & 1) != 0)
                v55 = *(const char **)(i + 168);
              else
                v55 = (const char *)(i + 161);
            }
            else
            {
              v55 = "Load failed";
            }
            if (*(_QWORD *)(v46 + 24))
            {
              re::AssetManager::putEntryInFailedState_entryStateLocked(v68, v46, 300, (uint64_t)buf);
              v35 = (os_unfair_lock_s *)(v3 + 64);
              if (buf[0].n128_u64[0])
              {
                if ((buf[0].n128_u8[8] & 1) != 0)
                  (*(void (**)(void))(*(_QWORD *)buf[0].n128_u64[0] + 40))();
                memset(buf, 0, sizeof(buf));
              }
            }
            else
            {
              v69 = *re::assetsLogObjects(v48);
              v35 = (os_unfair_lock_s *)(v3 + 64);
              if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
              {
                if ((*(_BYTE *)(i + 40) & 1) != 0)
                  v70 = *(_QWORD *)(i + 48);
                else
                  v70 = i + 41;
                buf[0].n128_u32[0] = 136315394;
                *(unint64_t *)((char *)buf[0].n128_u64 + 4) = v70;
                buf[0].n128_u16[6] = 2080;
                *(unint64_t *)((char *)&buf[0].n128_u64[1] + 6) = (unint64_t)v55;
                _os_log_error_impl(&dword_224FE9000, v69, OS_LOG_TYPE_ERROR, "Failed to load asset path '%s' -- %s", (uint8_t *)buf, 0x16u);
              }
            }
          }
          else
          {
            if (v50 != 2)
              goto LABEL_480;
            if (*(_BYTE *)(v46 + 416))
            {
              v51 = *re::assetsLogObjects(v48);
              v35 = (os_unfair_lock_s *)(v3 + 64);
              if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
              {
                if ((*(_BYTE *)(i + 40) & 1) != 0)
                  v52 = *(_QWORD *)(i + 48);
                else
                  v52 = i + 41;
                buf[0].n128_u32[0] = 136315138;
                *(unint64_t *)((char *)buf[0].n128_u64 + 4) = v52;
                _os_log_impl(&dword_224FE9000, v51, OS_LOG_TYPE_DEFAULT, "Couldn't load asset at %s as there is an existing asset being registered", (uint8_t *)buf, 0xCu);
              }
              v73 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(v3 + 1104), *(_QWORD *)(i + 64));
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v73 + 16))(v73, *(_QWORD *)(i + 96));
              *(_QWORD *)(i + 96) = 0;
              *(_DWORD *)(i + 136) = 3;
              goto LABEL_140;
            }
            if (!*(_BYTE *)(i + 344))
            {
LABEL_139:
              *(_BYTE *)(v46 + 417) = 0;
              re::AssetManager::processLoadedAsset_entryStateLocked((os_unfair_lock_s *)v3, (re::internal::AssetEntry *)v46, *(void **)(i + 96));
              *(_QWORD *)(v46 + 648) = *(_QWORD *)(i + 408);
              v76 = *(_QWORD *)(i + 128);
              *(_QWORD *)(v46 + 768) = *(_QWORD *)(i + 120);
              *(_BYTE *)(v46 + 776) = v76;
              v35 = (os_unfair_lock_s *)(v3 + 64);
              goto LABEL_140;
            }
            v56 = *re::assetsLogObjects(v48);
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
            {
              if ((*(_BYTE *)(i + 40) & 1) != 0)
                v86 = *(_QWORD *)(i + 48);
              else
                v86 = i + 41;
              buf[0].n128_u32[0] = 136315138;
              *(unint64_t *)((char *)buf[0].n128_u64 + 4) = v86;
              _os_log_debug_impl(&dword_224FE9000, v56, OS_LOG_TYPE_DEBUG, "Processing Payload for '%s'", (uint8_t *)buf, 0xCu);
            }
            v57 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v3 + 1208) + 104))(*(_QWORD *)(v3 + 1208));
            re::DynamicString::format((re::DynamicString *)"%llu", (re::DynamicString *)&v288, v57);
            re::AssetHandle::AssetHandle(&v291, (re::internal::AssetEntry *)v46);
            re::DefaultAssetSerialize::DefaultAssetSerialize((re::DefaultAssetSerialize *)buf, (const re::AssetHandle *)&v291);
            buf[0].n128_u64[0] = (unint64_t)off_24ED2D398;
            BYTE8(v297) = 1;
            re::DynamicString::DynamicString((re::DynamicString *)&v298, (const re::DynamicString *)&v288);
            v300 = v3;
            v264 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(v3 + 1104), *(_QWORD *)(i + 64));
            (*(void (**)(__int128 *__return_ptr))(*(_QWORD *)v264 + 160))(&v301);
            if ((_QWORD)v302)
            {
              v58 = *(re::AssetHandle ***)v303;
              v59 = 8 * v302;
              do
              {
                v60 = *v58;
                v61 = re::AssetHandle::serializationString(*v58, (re::DynamicString *)&v307);
                if ((v308 & 1) != 0)
                  v62 = v308 >> 1;
                else
                  v62 = v308 >> 1;
                if (v62)
                {
                  v63 = v36;
                  if ((v308 & 1) != 0)
                    v64 = (char *)v309;
                  else
                    v64 = (char *)&v308 + 1;
                  v65 = v64;
                  v36 = v63;
                }
                if (v307 && (v308 & 1) != 0)
                  (*(void (**)(void))(*v307 + 40))();
                ++v58;
                v59 -= 8;
              }
              while (v59);
            }
            v66 = *(uint64_t **)(i + 352);
            *(_QWORD *)(i + 352) = 0;
            v307 = v66;
            if ((*(_BYTE *)(i + 40) & 1) != 0)
              v67 = *(_QWORD *)(i + 48);
            else
              v67 = i + 41;
            v74 = (*(uint64_t (**)(uint64_t, uint64_t **, _QWORD, unint64_t))(*(_QWORD *)v264 + 224))(v264, &v307, *(_QWORD *)(i + 96), v67);

            if ((v74 & 1) == 0)
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v264 + 16))(v264, *(_QWORD *)(i + 96));
            v75 = (_anonymous_namespace_ *)v301;
            v14 = (uint64_t)&v301;
            if ((_QWORD)v301 && *(_QWORD *)v303)
              v75 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v301 + 40))();
            if ((v74 & 1) != 0)
            {
              buf[0].n128_u64[0] = (unint64_t)off_24ED2D398;
              if ((_QWORD)v298)
              {
                if ((BYTE8(v298) & 1) != 0)
                  (*(void (**)(void))(*(_QWORD *)v298 + 40))();
                v298 = 0u;
                v299 = 0u;
              }
              buf[0].n128_u64[0] = (unint64_t)&off_24ED2D3D0;
              re::Optional<re::AssetPath>::~Optional((uint64_t)&buf[0].n128_i64[1]);
              re::AssetHandle::~AssetHandle((re::AssetHandle *)&v291);
              if (v288 && (v289 & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v288 + 40))();
              goto LABEL_139;
            }
            re::AssetManager::putEntryInFailedState_entryStateLocked(v85, v46, 303, (uint64_t)&v301);
            v35 = (os_unfair_lock_s *)(v3 + 64);
            if ((_QWORD)v301)
            {
              if ((BYTE8(v301) & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v301 + 40))();
              v301 = 0u;
              v302 = 0u;
            }
            buf[0].n128_u64[0] = (unint64_t)off_24ED2D398;
            if ((_QWORD)v298)
            {
              if ((BYTE8(v298) & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v298 + 40))();
              v298 = 0u;
              v299 = 0u;
            }
            buf[0].n128_u64[0] = (unint64_t)&off_24ED2D3D0;
            re::Optional<re::AssetPath>::~Optional((uint64_t)&buf[0].n128_i64[1]);
            re::AssetHandle::~AssetHandle((re::AssetHandle *)&v291);
            if (v288 && (v289 & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v288 + 40))();
          }
LABEL_140:
          os_unfair_lock_unlock(v47);
          v13 = v276;
        }
        else
        {
          v53 = *re::assetsLogObjects((re *)LoadItemResult);
          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
          {
            if ((*(_BYTE *)(i + 40) & 1) != 0)
              v54 = *(_QWORD *)(i + 48);
            else
              v54 = i + 41;
            buf[0].n128_u32[0] = 136315138;
            *(unint64_t *)((char *)buf[0].n128_u64 + 4) = v54;
            _os_log_impl(&dword_224FE9000, v53, OS_LOG_TYPE_DEFAULT, "Existing asset not found for '%s', may have been unloaded.", (uint8_t *)buf, 0xCu);
          }
          v71 = *(_QWORD *)(i + 96);
          if (v71)
          {
            v72 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(v3 + 1104), *(_QWORD *)(i + 64));
            (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v72 + 16))(v72, v71);
          }
        }
        if (v304[0])
          re::AssetHandle::~AssetHandle((re::AssetHandle *)&v304[8]);
        break;
    }
    ++*(_QWORD *)(v3 + 1496);
    os_unfair_lock_lock((os_unfair_lock_t)(v3 + 1344));
    v23 = *(os_unfair_lock_s **)(i + 24);
    v78 = *(os_unfair_lock_s ***)(v3 + 1384);
    v79 = *(os_unfair_lock_s **)(v3 + 1368);
    v80 = v78;
    if (v79)
    {
      v81 = 8 * (_QWORD)v79;
      v80 = *(os_unfair_lock_s ***)(v3 + 1384);
      while (*v80 != v23)
      {
        ++v80;
        v81 -= 8;
        if (!v81)
        {
          v80 = &v78[(_QWORD)v79];
          break;
        }
      }
    }
    os_unfair_lock_opaque = v80 - v78;
    if ((os_unfair_lock_s *)os_unfair_lock_opaque != v79)
    {
      if ((unint64_t)v79 <= os_unfair_lock_opaque)
        goto LABEL_471;
      if ((unint64_t)&v79[-1]._os_unfair_lock_opaque + 3 > os_unfair_lock_opaque)
        v78[os_unfair_lock_opaque] = v78[(_QWORD)v79 - 1];
      *(_QWORD *)(v3 + 1368) = (char *)v79 - 1;
      ++*(_DWORD *)(v3 + 1376);
    }
    if (v23)
    {
      v82 = re::globalAllocators(v77)[2];
      *(_QWORD *)&v23[6]._os_unfair_lock_opaque = v36;
      v83 = *(_QWORD *)&v23[12]._os_unfair_lock_opaque;
      if (v83)
      {

        *(_QWORD *)&v23[12]._os_unfair_lock_opaque = 0;
      }
      *(_QWORD *)&v23[6]._os_unfair_lock_opaque = &off_24ED426B8;
      objc_destructInstance(&v23[8]);
      v84 = *(_QWORD *)&v23[2]._os_unfair_lock_opaque;
      if (v84)
      {

        *(_QWORD *)&v23[2]._os_unfair_lock_opaque = 0;
      }
      (*(void (**)(uint64_t, os_unfair_lock_s *))(*(_QWORD *)v82 + 40))(v82, v23);
    }
    re::internal::AssetBackgroundLoader::assetLoadItemFree(*(_QWORD *)(v3 + 1096), i);
    os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 1344));
  }
  while (dispatch_time(0, 0) < v13);
  *(_QWORD *)(v3 + 1504) += std::chrono::steady_clock::now().__d_.__rep_ - v268.__d_.__rep_;
  v87 = *(_QWORD *)(v3 + 1136);
  if (v87)
  {
    rep = std::chrono::steady_clock::now().__d_.__rep_;
    *(_QWORD *)(v3 + 1512) += (*(uint64_t (**)(uint64_t, dispatch_time_t))(*(_QWORD *)v87 + 40))(v87, v13);
    *(_QWORD *)(v3 + 1520) += std::chrono::steady_clock::now().__d_.__rep_ - rep;
  }
  if (re::internal::enableSignposts(0, 0) && re::internal::enableHighFrequencyTracing(0, 0))
  {
    re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)buf, 2012, 61);
    re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)buf);
  }
  atomic_load((unsigned __int8 *)(v3 + 1409));
  *(_DWORD *)v303 = 0;
  v301 = 0u;
  v302 = 0u;
  *(_QWORD *)&v303[4] = 0x7FFFFFFFLL;
  os_unfair_lock_lock(v35);
  v312 = 0;
  v308 = 0;
  v309 = 0;
  v307 = 0;
  v310 = 0;
  if (*(_QWORD *)(v3 + 360))
  {
    v89 = *(_QWORD *)(v3 + 376);
    v307 = *(uint64_t **)(v3 + 360);
    re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(&v307, v89);
    ++v310;
    v90 = *(_QWORD *)(v3 + 376);
    v91 = v309;
    if (v90 >= v309)
    {
      re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity(&v307, *(_QWORD *)(v3 + 376));
      v94 = v309;
      v23 = v312;
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SharedPtr<re::internal::AssetReference> *,re::SharedPtr<re::internal::AssetReference> *,re::SharedPtr<re::internal::AssetReference> *,0>(*(uint64_t **)(v3 + 392), (uint64_t *)(*(_QWORD *)(v3 + 392) + 8 * v309), (uint64_t *)v312);
      if (v94 != v90)
      {
        v95 = (uint64_t *)(*(_QWORD *)(v3 + 392) + 8 * v94);
        v23 += 2 * v94;
        v96 = 8 * v90 - 8 * v94;
        do
        {
          v97 = *v95;
          *(_QWORD *)&v23->_os_unfair_lock_opaque = *v95;
          if (v97)
            v98 = (id)(v97 + 8);
          ++v95;
          v23 += 2;
          v96 -= 8;
        }
        while (v96);
      }
    }
    else
    {
      v92 = (uint64_t *)v312;
      std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SharedPtr<re::internal::AssetReference> *,re::SharedPtr<re::internal::AssetReference> *,re::SharedPtr<re::internal::AssetReference> *,0>(*(uint64_t **)(v3 + 392), (uint64_t *)(*(_QWORD *)(v3 + 392) + 8 * v90), (uint64_t *)v312);
      v23 = (os_unfair_lock_s *)&v92[v90];
      v93 = 8 * v91 - 8 * v90;
      do
      {
        if (*(_QWORD *)&v23->_os_unfair_lock_opaque)
        {

          *(_QWORD *)&v23->_os_unfair_lock_opaque = 0;
        }
        v23 += 2;
        v93 -= 8;
      }
      while (v93);
    }
    v309 = v90;
    os_unfair_lock_unlock(v35);
    if (v90)
    {
      for (i = 0; v90 > i; ++i)
      {
        if (dispatch_time(0, 0) >= v13)
          break;
        if (v90 <= i)
          goto LABEL_473;
        v99 = *(_QWORD *)(*(_QWORD *)&v312[2 * i]._os_unfair_lock_opaque + 24);
        *(_QWORD *)v304 = v99;
        if (!v99)
          continue;
        v100 = (id)(v99 + 8);
        v101 = *(_QWORD *)v304;
        if (!*(_QWORD *)v304)
          continue;
        if (*(_BYTE *)(*(_QWORD *)v304 + 640))
          goto LABEL_228;
        v102.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
        v23 = (os_unfair_lock_s *)(*(_QWORD *)v304 + 384);
        os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)v304 + 384));
        os_unfair_lock_opaque = *(_QWORD *)v304;
        *(_BYTE *)(*(_QWORD *)v304 + 640) = 1;
        buf[0].n128_u64[0] = (unint64_t)&off_24ED2C8B0;
        buf[0].n128_u64[1] = v3;
        buf[1].n128_u64[0] = (unint64_t)v304;
        buf[1].n128_u64[1] = (unint64_t)buf;
        re::runInLocalAutoreleasePool((uint64_t)buf);
        v103 = (__n128 *)buf[1].n128_u64[1];
        if ((__n128 *)buf[1].n128_u64[1] == buf)
        {
          v103 = buf;
          v104 = 4;
          v13 = v276;
        }
        else
        {
          v13 = v276;
          if (!buf[1].n128_u64[1])
            goto LABEL_208;
          v104 = 5;
        }
        (*(void (**)(void))(v103->n128_u64[0] + 8 * v104))();
LABEL_208:
        v105 = *(_QWORD *)v304;
        *(_BYTE *)(*(_QWORD *)v304 + 640) = 0;
        if (*(_BYTE *)(os_unfair_lock_opaque + 416))
          goto LABEL_216;
        buf[0].n128_u64[0] = v105;
        v106 = 0x94D049BB133111EBLL
             * ((0xBF58476D1CE4E5B9 * (v105 ^ (v105 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v105 ^ (v105 >> 30))) >> 27));
        v107 = v106 ^ (v106 >> 31);
        if (!DWORD2(v302))
        {
          LODWORD(v108) = 0;
LABEL_215:
          re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::addAsMove((uint64_t)&v301, v108, v107, buf);
          ++*(_DWORD *)&v303[8];
          goto LABEL_216;
        }
        v108 = v107 % DWORD2(v302);
        v109 = *(unsigned int *)(*((_QWORD *)&v301 + 1) + 4 * v108);
        if ((_DWORD)v109 == 0x7FFFFFFF)
          goto LABEL_215;
        while (*(_QWORD *)(v302 + 24 * v109 + 16) != v105)
        {
          LODWORD(v109) = *(_DWORD *)(v302 + 24 * v109 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v109 == 0x7FFFFFFF)
            goto LABEL_215;
        }
LABEL_216:
        v110.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
        v111 = *(_QWORD *)(*(_QWORD *)v304 + 264);
        v112 = 0x94D049BB133111EBLL
             * ((0xBF58476D1CE4E5B9 * (v111 ^ (v111 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v111 ^ (v111 >> 30))) >> 27));
        v113 = v112 ^ (v112 >> 31);
        if (!*v270)
        {
          LODWORD(v114) = 0;
LABEL_223:
          v288 = *(_QWORD *)(*(_QWORD *)v304 + 264);
          buf[0].n128_u64[0] = 1;
          buf[0].n128_u64[1] = v110.__d_.__rep_ - v102.__d_.__rep_;
LABEL_224:
          re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::addAsMove((uint64_t)v270, v114, v113, &v288, buf);
          ++*(_DWORD *)(v3 + 1568);
          goto LABEL_227;
        }
        v114 = v113 % *(unsigned int *)(v3 + 1552);
        v115 = *(unsigned int *)(*(_QWORD *)(v3 + 1536) + 4 * v114);
        if ((_DWORD)v115 == 0x7FFFFFFF)
          goto LABEL_223;
        v116 = *(_QWORD *)(v3 + 1544);
        if (*(_QWORD *)(v116 + 40 * v115 + 16) != v111)
        {
          while (1)
          {
            v117 = *(_DWORD *)(v116 + 40 * *(unsigned int *)(*(_QWORD *)(v3 + 1536) + 4 * v114) + 8) & 0x7FFFFFFF;
            if (v117 == 0x7FFFFFFF)
              break;
            if (*(_QWORD *)(v116 + 40 * v117 + 16) == v111)
              goto LABEL_226;
          }
          v288 = *(_QWORD *)(*(_QWORD *)v304 + 264);
          buf[0].n128_u64[0] = 1;
          buf[0].n128_u64[1] = v110.__d_.__rep_ - v102.__d_.__rep_;
          while (1)
          {
            v120 = *(_DWORD *)(v116 + 40 * v115 + 8);
            v115 = v120 & 0x7FFFFFFF;
            if ((v120 & 0x7FFFFFFF) == 0x7FFFFFFF)
              goto LABEL_224;
            if (*(_QWORD *)(v116 + 40 * v115 + 16) == v111)
              goto LABEL_227;
          }
        }
        v117 = *(_DWORD *)(*(_QWORD *)(v3 + 1536) + 4 * v114);
LABEL_226:
        v118 = v116 + 40 * v117;
        v119 = *(_QWORD *)(v118 + 32) + v110.__d_.__rep_ - v102.__d_.__rep_;
        ++*(_QWORD *)(v118 + 24);
        *(_QWORD *)(v118 + 32) = v119;
LABEL_227:
        os_unfair_lock_unlock(v23);
        v101 = *(_QWORD *)v304;
        if (*(_QWORD *)v304)
        {
LABEL_228:

          v90 = v309;
        }
      }
    }
  }
  else
  {
    os_unfair_lock_unlock(v35);
  }
  re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)&v307);
  v79 = (os_unfair_lock_s *)(v3 + 64);
  os_unfair_lock_lock(lock);
  v121 = *(_QWORD *)(v3 + 376);
  if (v121)
  {
    v122 = 0;
    do
    {
      v123 = *(_QWORD *)(v3 + 392);
      while (!re::HashSetBase<re::internal::AssetEntry *,re::internal::AssetEntry *,re::internal::ValueAsKey<re::internal::AssetEntry *>,re::Hash<re::internal::AssetEntry *>,re::EqualTo<re::internal::AssetEntry *>,true,false>::contains((uint64_t)&v301, *(_QWORD *)(*(_QWORD *)(v123 + 8 * v122) + 24)))
      {
        if (v121 <= ++v122)
          goto LABEL_242;
      }
      re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::removeAt(v3 + 360, v122);
      v121 = *(_QWORD *)(v3 + 376);
    }
    while (v121 > v122);
  }
LABEL_242:
  os_unfair_lock_unlock(lock);
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v301);
  v124 = *(re::internal::AssetNetworkLoader **)(v3 + 1120);
  if (v124)
    re::internal::AssetNetworkLoader::update(v124);
  v279[0] = v266;
  v279[1] = v13;
  v279[2] = v267;
  re::AssetManager::updateLoadRequests(v3, (uint64_t)v279);
  v126 = *(_QWORD *)(v3 + 1416);
  if (v126 && *(_BYTE *)(v126 + 204) && !*(_BYTE *)(v126 + 17))
  {
    v159 = *(_DWORD *)(v126 + 176);
    if (re::ProfilerConfig::isStatisticCollectionEnabled(v125) && (v159 & 4) != 0)
    {
      v307 = 0;
      *(_QWORD *)v304 = 0;
      v288 = 0;
      re::AssetManager::gatherAssetStatisticsByType((re::AssetManager *)v3, &v301);
      if (*((_QWORD *)&v301 + 1))
      {
        v161 = 0;
        v162 = 0;
        v163 = 0;
        v164 = 0;
        v165 = v302;
        v269 = v302 + 104 * *((_QWORD *)&v301 + 1);
        do
        {
          *(_QWORD *)v296 = 0;
          memset(buf, 0, 28);
          if (*(_QWORD *)v165)
          {
            v272 = v161;
            v274 = v164;
            v271 = v162;
            v166 = *(_QWORD *)(v165 + 16);
            buf[0].n128_u64[0] = *(_QWORD *)v165;
            re::DynamicArray<re::AssetPath>::setCapacity(buf, v166);
            ++buf[1].n128_u32[2];
            v167 = *(_QWORD *)(v165 + 16);
            v168 = buf[1].n128_u64[0];
            if (v167 >= buf[1].n128_u64[0])
            {
              re::DynamicArray<re::AssetPath>::setCapacity(buf, *(_QWORD *)(v165 + 16));
              v172 = buf[1].n128_u64[0];
              v173 = *(_QWORD *)v296;
              v160 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::AssetPath *,re::AssetPath *,re::AssetPath *>(*(re::DynamicString **)(v165 + 32), (re::DynamicString *)(*(_QWORD *)(v165 + 32) + 80 * buf[1].n128_u64[0]), *(uint64_t *)v296);
              if (v172 != v167)
              {
                v174 = *(_QWORD *)(v165 + 32);
                v175 = v174 + 80 * v167;
                v176 = 80 * v172;
                do
                {
                  v177 = v174 + v176;
                  *(_DWORD *)(v173 + v176) = *(_DWORD *)(v174 + v176);
                  re::DynamicString::DynamicString((re::DynamicString *)(v173 + v176 + 8), (const re::DynamicString *)(v174 + v176 + 8));
                  v160 = re::DynamicString::DynamicString((re::DynamicString *)(v173 + v176 + 40), (const re::DynamicString *)(v174 + v176 + 40));
                  *(_QWORD *)(v173 + v176 + 72) = *(_QWORD *)(v174 + v176 + 72);
                  v174 += 80;
                  v173 += 80;
                }
                while (v177 + 80 != v175);
              }
            }
            else
            {
              v169 = *(_QWORD *)v296;
              std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::AssetPath *,re::AssetPath *,re::AssetPath *>(*(re::DynamicString **)(v165 + 32), (re::DynamicString *)(*(_QWORD *)(v165 + 32) + 80 * v167), *(uint64_t *)v296);
              v170 = 80 * v168 - 80 * v167;
              v171 = (_QWORD *)(v169 + 80 * v167 + 40);
              do
              {
                if (*v171)
                {
                  if ((v171[1] & 1) != 0)
                    (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v171 + 40))(*v171, v171[2]);
                  *(_OWORD *)v171 = 0u;
                  *((_OWORD *)v171 + 1) = 0u;
                }
                v160 = (re::MeshAsset *)*(v171 - 4);
                if (v160)
                {
                  if ((*(_BYTE *)(v171 - 3) & 1) != 0)
                    v160 = (re::MeshAsset *)(*(uint64_t (**)(re::MeshAsset *, _QWORD))(*(_QWORD *)v160 + 40))(v160, *(v171 - 2));
                  *((_OWORD *)v171 - 2) = 0u;
                  *((_OWORD *)v171 - 1) = 0u;
                }
                v171 += 10;
                v170 -= 80;
              }
              while (v170);
            }
            buf[1].n128_u64[0] = v167;
            v79 = (os_unfair_lock_s *)(v3 + 64);
            v162 = v271;
            v161 = v272;
            v164 = v274;
          }
          *(_OWORD *)&v296[8] = *(_OWORD *)(v165 + 40);
          *(_OWORD *)&v296[24] = *(_OWORD *)(v165 + 56);
          *(_OWORD *)&v296[40] = *(_OWORD *)(v165 + 72);
          v297 = *(_OWORD *)(v165 + 88);
          v178 = *(uint64_t **)&v296[8];
          v179 = re::MeshAsset::assetType(v160);
          v180 = v178;
          do
          {
            v181 = v180;
            if (v180 == v179)
              break;
            v180 = (uint64_t *)v180[2];
          }
          while (v180);
          v182 = *((_QWORD *)&v297 + 1);
          v183 = v181 == v179;
          if (v181 == v179)
            v184 = *((_QWORD *)&v297 + 1);
          else
            v184 = 0;
          v164 = (re::AssetHandle *)((char *)v164 + v184);
          if (v183)
            v161 = (re::AssetHandle *)((char *)v161 + 1);
          v185 = re::TextureAsset::assetType((re::TextureAsset *)v179);
          while (1)
          {
            v186 = v178;
            if (v178 == v185)
              break;
            v178 = (uint64_t *)v178[2];
            if (!v178)
            {
              v182 = 0;
              break;
            }
          }
          if (v186 == v185)
            ++v163;
          v162 += v182;
          v160 = (re::MeshAsset *)re::DynamicArray<re::AssetPath>::deinit((uint64_t)buf);
          v165 += 104;
        }
        while (v165 != v269);
      }
      else
      {
        v164 = 0;
        v163 = 0;
        v162 = 0;
        v161 = 0;
      }
      v277 = v163;
      v273 = v161;
      v275 = v164;
      v187 = v162;
      os_unfair_lock_lock(v79);
      v188 = *(unsigned int *)(v3 + 104);
      if ((_DWORD)v188)
      {
        v189 = 0;
        v190 = (int *)(*(_QWORD *)(v3 + 88) + 8);
        while (1)
        {
          v191 = *v190;
          v190 += 14;
          if (v191 < 0)
            break;
          if (v188 == ++v189)
          {
            LODWORD(v189) = *(_DWORD *)(v3 + 104);
            break;
          }
        }
      }
      else
      {
        LODWORD(v189) = 0;
      }
      if ((_DWORD)v188 == (_DWORD)v189)
      {
        v192 = 0;
        v193 = 0;
        v194 = 0;
      }
      else
      {
        v192 = 0;
        v193 = 0;
        v194 = 0;
        v195 = v189;
        v196 = *(_QWORD *)(v3 + 88);
        do
        {
          v197 = *(_QWORD *)(v196 + 56 * v195 + 48);
          if (v197)
            v198 = (id)(v197 + 8);
          v199 = atomic_load((unsigned int *)(v197 + 704));
          v200 = &v307;
          switch(v199)
          {
            case 0u:
              goto LABEL_386;
            case 1u:
              v200 = (uint64_t **)v304;
              goto LABEL_386;
            case 2u:
              ++v193;
              v194 += *(_QWORD *)(v197 + 648);
              break;
            case 3u:
              v200 = (uint64_t **)&v288;
LABEL_386:
              *v200 = (uint64_t *)((char *)*v200 + 1);
              break;
            default:
              break;
          }
          ++v192;

          v196 = *(_QWORD *)(v3 + 88);
          if (*(_DWORD *)(v3 + 104) <= (v189 + 1))
            v201 = v189 + 1;
          else
            v201 = *(_DWORD *)(v3 + 104);
          while (1)
          {
            v195 = (v189 + 1);
            if (v201 - 1 == (_DWORD)v189)
              break;
            LODWORD(v189) = v189 + 1;
            v202 = v195;
            if ((*(_DWORD *)(v196 + 56 * v195 + 8) & 0x80000000) != 0)
              goto LABEL_394;
          }
          v202 = v201;
LABEL_394:
          LODWORD(v189) = v202;
        }
        while ((_DWORD)v188 != v202);
      }
      v203 = v194;
      v79 = (os_unfair_lock_s *)(v3 + 64);
      os_unfair_lock_unlock(lock);
      v205 = re::ProfilerConfig::isStatisticCollectionEnabled(v204);
      if ((v205 & 1) != 0)
      {
        v205 = re::profilerThreadContext((re *)v205);
        v206 = *(int64x2_t **)(v205 + 152);
        if (v206)
        {
          v207 = v307;
          v208 = (uint64_t *)v206[220].i64[0];
          if (v208 >= v307)
            v208 = v307;
          v206[220].i64[0] = (uint64_t)v208;
          v209 = (uint64_t *)v206[220].i64[1];
          if (v209 <= v207)
            v209 = v207;
          v206[220].i64[1] = (uint64_t)v209;
          v210 = vdupq_n_s64(1uLL);
          v210.i64[0] = (uint64_t)v207;
          v206[221] = vaddq_s64(v206[221], v210);
          *(_BYTE *)(v205 + 184) = 0;
        }
      }
      v211 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v205);
      v13 = v276;
      if ((_DWORD)v211)
      {
        v211 = re::profilerThreadContext((re *)v211);
        v212 = *(int64x2_t **)(v211 + 152);
        if (v212)
        {
          v213 = *(_QWORD *)v304;
          v214 = v212[224].u64[0];
          if (v214 >= *(_QWORD *)v304)
            v214 = *(_QWORD *)v304;
          v212[224].i64[0] = v214;
          v215 = v212[224].u64[1];
          if (v215 <= v213)
            v215 = v213;
          v212[224].i64[1] = v215;
          v216 = vdupq_n_s64(1uLL);
          v216.i64[0] = v213;
          v212[225] = vaddq_s64(v212[225], v216);
          *(_BYTE *)(v211 + 184) = 0;
        }
      }
      v217 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v211);
      if ((_DWORD)v217)
      {
        v217 = re::profilerThreadContext((re *)v217);
        v218 = *(int64x2_t **)(v217 + 152);
        if (v218)
        {
          v219 = v218[228].u64[0];
          if (v219 >= v193)
            v219 = v193;
          v218[228].i64[0] = v219;
          v220 = v218[228].u64[1];
          if (v220 <= v193)
            v220 = v193;
          v218[228].i64[1] = v220;
          v221 = vdupq_n_s64(1uLL);
          v221.i64[0] = v193;
          v218[229] = vaddq_s64(v218[229], v221);
          *(_BYTE *)(v217 + 184) = 0;
        }
      }
      v222 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v217);
      if ((_DWORD)v222)
      {
        v222 = re::profilerThreadContext((re *)v222);
        v223 = *(int64x2_t **)(v222 + 152);
        if (v223)
        {
          v224 = v288;
          v225 = v223[232].u64[0];
          if (v225 >= v288)
            v225 = v288;
          v223[232].i64[0] = v225;
          v226 = v223[232].u64[1];
          if (v226 <= v224)
            v226 = v224;
          v223[232].i64[1] = v226;
          v227 = vdupq_n_s64(1uLL);
          v227.i64[0] = v224;
          v223[233] = vaddq_s64(v223[233], v227);
          *(_BYTE *)(v222 + 184) = 0;
        }
      }
      v228 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v222);
      if ((_DWORD)v228)
      {
        v228 = re::profilerThreadContext((re *)v228);
        v229 = *(int64x2_t **)(v228 + 152);
        if (v229)
        {
          v230 = v229[236].u64[0];
          if (v230 >= v192)
            v230 = v192;
          v229[236].i64[0] = v230;
          v231 = v229[236].u64[1];
          if (v231 <= v192)
            v231 = v192;
          v229[236].i64[1] = v231;
          v232 = vdupq_n_s64(1uLL);
          v232.i64[0] = v192;
          v229[237] = vaddq_s64(v229[237], v232);
          *(_BYTE *)(v228 + 184) = 0;
        }
      }
      v233 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v228);
      if ((_DWORD)v233)
      {
        v233 = re::profilerThreadContext((re *)v233);
        v234 = *(int64x2_t **)(v233 + 152);
        if (v234)
        {
          v235 = v234[240].u64[0];
          if (v235 >= v203)
            v235 = v203;
          v234[240].i64[0] = v235;
          v236 = v234[240].u64[1];
          if (v236 <= v203)
            v236 = v203;
          v234[240].i64[1] = v236;
          v237 = vdupq_n_s64(1uLL);
          v237.i64[0] = v203;
          v234[241] = vaddq_s64(v234[241], v237);
          *(_BYTE *)(v233 + 184) = 0;
        }
      }
      v238 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v233);
      if ((_DWORD)v238)
      {
        v238 = re::profilerThreadContext((re *)v238);
        v239 = *(int64x2_t **)(v238 + 152);
        if (v239)
        {
          v240 = (re::AssetHandle *)v239[252].i64[0];
          if (v240 >= v273)
            v240 = v273;
          v239[252].i64[0] = (uint64_t)v240;
          v241 = (re::AssetHandle *)v239[252].i64[1];
          if (v241 <= v273)
            v241 = v273;
          v239[252].i64[1] = (uint64_t)v241;
          v242 = vdupq_n_s64(1uLL);
          v242.i64[0] = (uint64_t)v273;
          v239[253] = vaddq_s64(v239[253], v242);
          *(_BYTE *)(v238 + 184) = 0;
        }
      }
      v243 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v238);
      if ((_DWORD)v243)
      {
        v243 = re::profilerThreadContext((re *)v243);
        v244 = *(int64x2_t **)(v243 + 152);
        if (v244)
        {
          v245 = (re::AssetHandle *)v244[256].i64[0];
          if (v245 >= v275)
            v245 = v275;
          v244[256].i64[0] = (uint64_t)v245;
          v246 = (re::AssetHandle *)v244[256].i64[1];
          if (v246 <= v275)
            v246 = v275;
          v244[256].i64[1] = (uint64_t)v246;
          v247 = vdupq_n_s64(1uLL);
          v247.i64[0] = (uint64_t)v275;
          v244[257] = vaddq_s64(v244[257], v247);
          *(_BYTE *)(v243 + 184) = 0;
        }
      }
      v248 = re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v243);
      if ((_DWORD)v248)
      {
        v248 = re::profilerThreadContext((re *)v248);
        v249 = *(int64x2_t **)(v248 + 152);
        if (v249)
        {
          v250 = v249[260].u64[0];
          if (v250 >= v277)
            v250 = v277;
          v249[260].i64[0] = v250;
          v251 = v249[260].u64[1];
          if (v251 <= v277)
            v251 = v277;
          v249[260].i64[1] = v251;
          v252 = vdupq_n_s64(1uLL);
          v252.i64[0] = v277;
          v249[261] = vaddq_s64(v249[261], v252);
          *(_BYTE *)(v248 + 184) = 0;
        }
      }
      v253 = (re *)re::ProfilerConfig::isStatisticCollectionEnabled((re::ProfilerConfig *)v248);
      if ((_DWORD)v253)
      {
        v254 = re::profilerThreadContext(v253);
        v255 = *(int64x2_t **)(v254 + 152);
        if (v255)
        {
          v256 = v255[264].u64[0];
          if (v256 >= v187)
            v256 = v187;
          v255[264].i64[0] = v256;
          v257 = v255[264].u64[1];
          if (v257 <= v187)
            v257 = v187;
          v255[264].i64[1] = v257;
          v258 = vdupq_n_s64(1uLL);
          v258.i64[0] = v187;
          v255[265] = vaddq_s64(v255[265], v258);
          *(_BYTE *)(v254 + 184) = 0;
        }
      }
      v259 = v301;
      if ((_QWORD)v301 && *((_QWORD *)&v301 + 1))
      {
        v260 = 0;
        v261 = v302;
        v262 = 104 * *((_QWORD *)&v301 + 1);
        do
        {
          re::DynamicArray<re::AssetPath>::deinit(v261 + v260);
          v260 += 104;
        }
        while (v262 != v260);
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v259 + 40))(v259, v261);
      }
    }
  }
  else
  {
    re::ProfilerConfig::isStatisticCollectionEnabled(v125);
  }
  v127 = atomic_load((unsigned __int8 *)(v3 + 1409));
  if ((v127 & 1) == 0 && !*(_BYTE *)(v3 + 1410))
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 584));
  if (!*(_QWORD *)(v3 + 1208))
  {
    re::NetworkActionQueue::readActions((re::NetworkActionQueue *)(v3 + 768), (uint64_t)buf);
    if (buf[1].n128_u64[0])
    {
      v147 = *re::assetsLogObjects(v146);
      if (os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v301) = 0;
        _os_log_impl(&dword_224FE9000, v147, OS_LOG_TYPE_DEFAULT, "Found queued network actions when NetworkAssetService does not exist!, this can occur during AssetManager::deinit()", (uint8_t *)&v301, 2u);
      }
    }
    v145 = buf;
    goto LABEL_296;
  }
  re::NetworkActionQueue::readActions((re::NetworkActionQueue *)(v3 + 768), (uint64_t)&v301);
  v288 = 0;
  v289 = 0;
  v290 = 0;
  v291 = 0;
  v292 = 0;
  v293 = 0;
  v128 = v302;
  buf[0].n128_u8[0] = 0;
  v131 = v302;
  buf[0].n128_u8[0] = 0;
  v133 = v302;
  v312 = 0;
  v308 = 0;
  v309 = 0;
  v310 = 0;
  re::DynamicArray<re::AssetHandle>::setCapacity(&v307, v133);
  ++v310;
  os_unfair_lock_lock(v79);
  if (!(_QWORD)v302)
    goto LABEL_276;
  v134 = (_DWORD *)(*(_QWORD *)v303 + 160);
  v135 = 168 * v302;
  do
  {
    if (*v134 == 4 || *v134 == 1)
    {
      memset(buf, 0, 24);
      re::DynamicArray<re::AssetHandle>::add(&v307, (uint64_t *)buf);
      v137 = buf;
LABEL_265:
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v137);
      goto LABEL_266;
    }
    re::AssetManager::lookupExistingAsset_assetTablesLocked((re::internal::AssetTypeRegistry **)v3, *((_QWORD *)v134 - 1), buf);
    if (buf[0].n128_u8[0])
    {
      re::DynamicArray<re::AssetHandle>::add((_anonymous_namespace_ *)&v307, (re::AssetHandle *)&buf[0].n128_i8[8]);
    }
    else
    {
      memset(v304, 0, 24);
      re::DynamicArray<re::AssetHandle>::add(&v307, (uint64_t *)v304);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v304);
    }
    if (buf[0].n128_u8[0])
    {
      v137 = (__n128 *)&buf[0].n128_i8[8];
      goto LABEL_265;
    }
LABEL_266:
    v134 += 42;
    v135 -= 168;
  }
  while (v135);
  v138 = v302;
  if ((_QWORD)v302)
  {
    v139 = 0;
    v140 = 0;
    v23 = 0;
    while (1)
    {
      os_unfair_lock_opaque = v309;
      if (v309 <= (unint64_t)v23)
        break;
      if ((*(_DWORD *)(*(_QWORD *)v303 + v139 + 160) - 1) >= 7)
      {
        v141 = ((uint64_t (*)(uint64_t))re::AssetManager::performQueuedSyncAction)(v3);
        os_unfair_lock_opaque = v289;
        if (v289 <= (unint64_t)v23)
          goto LABEL_477;
        *((_BYTE *)&v23->_os_unfair_lock_opaque + v290) = v141;
        os_unfair_lock_opaque = v292;
        if (v292 <= (unint64_t)v23)
          goto LABEL_478;
        *((_BYTE *)&v23->_os_unfair_lock_opaque + v293) = 1;
        if (dispatch_time(0, 0) >= v13)
          goto LABEL_276;
        v138 = v302;
      }
      v23 = (os_unfair_lock_s *)((char *)v23 + 1);
      v140 += 24;
      v139 += 168;
      if ((unint64_t)v23 >= v138)
        goto LABEL_276;
    }
LABEL_474:
    v294 = 0;
    memset(v296, 0, 48);
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v304 = 136315906;
    *(_QWORD *)&v304[4] = "operator[]";
    *(_WORD *)&v304[12] = 1024;
    *(_DWORD *)&v304[14] = 789;
    *(_WORD *)&v304[18] = 2048;
    *(_QWORD *)&v304[20] = v23;
    v305 = 2048;
    v306 = os_unfair_lock_opaque;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_475:
    v294 = 0;
    memset(v296, 0, 48);
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v304 = 136315906;
    *(_QWORD *)&v304[4] = "operator[]";
    *(_WORD *)&v304[12] = 1024;
    *(_DWORD *)&v304[14] = 468;
    *(_WORD *)&v304[18] = 2048;
    *(_QWORD *)&v304[20] = v23;
    v305 = 2048;
    v306 = os_unfair_lock_opaque;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_476:
    v294 = 0;
    memset(v296, 0, 48);
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v304 = 136315906;
    *(_QWORD *)&v304[4] = "operator[]";
    *(_WORD *)&v304[12] = 1024;
    *(_DWORD *)&v304[14] = 468;
    *(_WORD *)&v304[18] = 2048;
    *(_QWORD *)&v304[20] = v23;
    v305 = 2048;
    v306 = os_unfair_lock_opaque;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_477:
    v294 = 0;
    memset(v296, 0, 48);
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v304 = 136315906;
    *(_QWORD *)&v304[4] = "operator[]";
    *(_WORD *)&v304[12] = 1024;
    *(_DWORD *)&v304[14] = 468;
    *(_WORD *)&v304[18] = 2048;
    *(_QWORD *)&v304[20] = v23;
    v305 = 2048;
    v306 = os_unfair_lock_opaque;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_478:
    v294 = 0;
    memset(v296, 0, 48);
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v304 = 136315906;
    *(_QWORD *)&v304[4] = "operator[]";
    *(_WORD *)&v304[12] = 1024;
    *(_DWORD *)&v304[14] = 468;
    *(_WORD *)&v304[18] = 2048;
    *(_QWORD *)&v304[20] = v23;
    v305 = 2048;
    v306 = os_unfair_lock_opaque;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_479:
    re::internal::assertLog((re::internal *)4, v38, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "processLoadItem", 3141);
    _os_crash();
    __break(1u);
LABEL_480:
    re::internal::assertLog((re::internal *)4, v49, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "processLoadItem", 3120);
    _os_crash();
    __break(1u);
  }
LABEL_276:
  os_unfair_lock_unlock(v79);
  v142 = v302;
  if ((_QWORD)v302)
  {
    v143 = 0;
    i = 0;
    v23 = 0;
    v14 = 1;
    while (1)
    {
      os_unfair_lock_opaque = v309;
      if (v309 <= (unint64_t)v23)
        break;
      if ((*(_DWORD *)(*(_QWORD *)v303 + v143 + 160) - 1) <= 6)
      {
        v144 = ((uint64_t (*)(uint64_t))re::AssetManager::performQueuedSyncAction)(v3);
        os_unfair_lock_opaque = v289;
        if (v289 <= (unint64_t)v23)
          goto LABEL_475;
        *((_BYTE *)&v23->_os_unfair_lock_opaque + v290) = v144;
        os_unfair_lock_opaque = v292;
        if (v292 <= (unint64_t)v23)
          goto LABEL_476;
        *((_BYTE *)&v23->_os_unfair_lock_opaque + v293) = 1;
        if (dispatch_time(0, 0) >= v13)
          goto LABEL_285;
        v142 = v302;
      }
      v23 = (os_unfair_lock_s *)((char *)v23 + 1);
      i += 24;
      v143 += 168;
      if ((unint64_t)v23 >= v142)
        goto LABEL_285;
    }
    v294 = 0;
    memset(v296, 0, 48);
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v304 = 136315906;
    *(_QWORD *)&v304[4] = "operator[]";
    *(_WORD *)&v304[12] = 1024;
    *(_DWORD *)&v304[14] = 789;
    *(_WORD *)&v304[18] = 2048;
    *(_QWORD *)&v304[20] = v23;
    v305 = 2048;
    v306 = os_unfair_lock_opaque;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_471:
    v307 = 0;
    memset(v296, 0, 48);
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v301) = 136315906;
    *(_QWORD *)(v14 + 4) = "removeAt";
    WORD6(v301) = 1024;
    *(_DWORD *)(v14 + 14) = 931;
    WORD1(v302) = 2048;
    *(_QWORD *)(v14 + 20) = os_unfair_lock_opaque;
    WORD6(v302) = 2048;
    *(_QWORD *)(v14 + 30) = v79;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_472:
    *(_QWORD *)v304 = 0;
    memset(v296, 0, 48);
    memset(buf, 0, sizeof(buf));
    v90 = MEMORY[0x24BDACB70];
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    LODWORD(v307) = 136315906;
    *(_QWORD *)(v14 + 100) = "removeAt";
    WORD2(v308) = 1024;
    *(_DWORD *)(v14 + 110) = 931;
    WORD1(v309) = 2048;
    *(_QWORD *)(v14 + 116) = os_unfair_lock_opaque;
    v311 = 2048;
    *(_QWORD *)(v14 + 126) = i;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_473:
    v288 = 0;
    memset(v296, 0, 48);
    memset(buf, 0, sizeof(buf));
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    *(_DWORD *)v304 = 136315906;
    *(_QWORD *)&v304[4] = "operator[]";
    *(_WORD *)&v304[12] = 1024;
    *(_DWORD *)&v304[14] = 789;
    *(_WORD *)&v304[18] = 2048;
    *(_QWORD *)&v304[20] = i;
    v305 = 2048;
    v306 = v90;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_474;
  }
LABEL_285:
  re::NetworkActionQueue::removeActions(v3 + 768, (uint64_t)&v288, (uint64_t)&v291);
  re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v307);
  if (v291 && v292)
    (*(void (**)(void))(*(_QWORD *)v291 + 40))();
  if (v288 && v289)
    (*(void (**)(void))(*(_QWORD *)v288 + 40))();
  v145 = (__n128 *)&v301;
LABEL_296:
  re::DynamicArray<re::NetworkActionQueue::Action>::deinit((uint64_t)v145);
  *(_QWORD *)v296 = 0;
  memset(buf, 0, 28);
  os_unfair_lock_lock((os_unfair_lock_t)(v3 + 1024));
  re::DynamicArray<unsigned long long>::operator=((uint64_t)buf, (uint64_t *)(v3 + 1032));
  *(_QWORD *)(v3 + 1048) = 0;
  ++*(_DWORD *)(v3 + 1056);
  os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 1024));
  v148 = *(_QWORD *)(v3 + 1592);
  if (v148)
  {
    v149 = *(_QWORD *)(v3 + 1608);
    v150 = 40 * v148;
    do
    {
      *((_QWORD *)&v302 + 1) = *(_QWORD *)(v149 + 24);
      *(_QWORD *)v303 = 0;
      re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)&v301, v149);
      re::DynamicArray<char const*>::DynamicArray((uint64_t)&v307, (uint64_t *)buf);
      (*(void (**)(_QWORD, uint64_t **))(**(_QWORD **)v303 + 16))(*(_QWORD *)v303, &v307);
      if (v307)
      {
        if (v312)
          (*(void (**)(void))(*v307 + 40))();
        v312 = 0;
        v308 = 0;
        v309 = 0;
        v307 = 0;
        ++v310;
      }
      if (*(_QWORD *)v303)
      {
        (***(void (****)(_QWORD))v303)(*(_QWORD *)v303);
        if (*(__int128 **)v303 != &v301)
          (*(void (**)(_QWORD))(**((_QWORD **)&v302 + 1) + 40))(*((_QWORD *)&v302 + 1));
      }
      v149 += 40;
      v150 -= 40;
    }
    while (v150);
  }
  if (buf[0].n128_u64[0] && *(_QWORD *)v296)
    (*(void (**)(void))(*(_QWORD *)buf[0].n128_u64[0] + 40))();
  re::AssetManager::updateScheduler((re::AssetManager *)v3);
  v151 = *(_QWORD *)(v3 + 1208);
  if (v151)
    (*(void (**)(uint64_t))(*(_QWORD *)v151 + 200))(v151);
  if (dispatch_time(0, 0) >= v13)
  {
    if (re::internal::enableSignposts(0, 0))
      kdebug_trace();
    ++*(_QWORD *)(v3 + 1472);
  }
  else
  {
    v152 = v283;
    *(_OWORD *)(v3 + 1496) = v282;
    *(_OWORD *)(v3 + 1512) = v152;
    if (*v270)
    {
      if ((_QWORD)v284)
      {
        re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::copy((uint64_t)v270, (uint64_t)&v284);
        ++*(_DWORD *)(v3 + 1568);
      }
      else
      {
        re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::clear((uint64_t)v270);
      }
    }
    else if ((_QWORD)v284)
    {
      if (HIDWORD(v285) <= 3)
        v158 = 3;
      else
        v158 = HIDWORD(v285);
      re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::init((uint64_t)v270, v284, v158);
      re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::copy((uint64_t)v270, (uint64_t)&v284);
    }
  }
  re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)&v284);
  if (v265)
  {
    if (*(_QWORD *)(v265 + 152))
    {
      v153 = mach_absolute_time();
      v154 = *(int64x2_t **)(v265 + 152);
      if (v154)
      {
        v155 = v154[88].u64[0];
        if (v155 >= v153 - v263)
          v155 = v153 - v263;
        v154[88].i64[0] = v155;
        v156 = v154[88].u64[1];
        if (v156 <= v153 - v263)
          v156 = v153 - v263;
        v154[88].i64[1] = v156;
        v157 = vdupq_n_s64(1uLL);
        v157.i64[0] = v153 - v263;
        v154[89] = vaddq_s64(v154[89], v157);
        *(_BYTE *)(v265 + 184) = 0;
      }
    }
  }
}

uint64_t std::__function::__func<re::AssetManager::update(BOOL,BOOL)::$_0,std::allocator<re::AssetManager::update(BOOL,BOOL)::$_0>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
    return a1 + 8;
  else
    return 0;
}

void *std::__function::__func<re::AssetManager::update(BOOL,BOOL)::$_0,std::allocator<re::AssetManager::update(BOOL,BOOL)::$_0>,void ()(void)>::target_type()
{
}

void re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;

  re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = (uint64_t *)(*(_QWORD *)(a2 + 16) + v6);
      if ((v8[1] & 0x80000000) != 0)
      {
        v9 = *v8;
        v10 = *(unsigned int *)(a1 + 24);
        v11 = *v8 % v10;
        v12 = *(unsigned int *)(a1 + 36);
        if ((_DWORD)v12 == 0x7FFFFFFF)
        {
          v12 = *(unsigned int *)(a1 + 32);
          v13 = v12;
          if ((_DWORD)v12 == (_DWORD)v10)
          {
            re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
            v11 = v9 % *(unsigned int *)(a1 + 24);
            v13 = *(_DWORD *)(a1 + 32);
          }
          *(_DWORD *)(a1 + 32) = v13 + 1;
          v14 = *(_QWORD *)(a1 + 16);
          v15 = *(_DWORD *)(v14 + 40 * v12 + 8);
        }
        else
        {
          v14 = *(_QWORD *)(a1 + 16);
          v15 = *(_DWORD *)(v14 + 40 * v12 + 8);
          *(_DWORD *)(a1 + 36) = v15 & 0x7FFFFFFF;
        }
        *(_DWORD *)(v14 + 40 * v12 + 8) = v15 | 0x80000000;
        *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v12 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v12 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v11);
        *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v12) = v9;
        *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v12 + 16) = v8[2];
        *(_OWORD *)(*(_QWORD *)(a1 + 16) + 40 * v12 + 24) = *(_OWORD *)(v8 + 3);
        *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v11) = v12;
        ++*(_DWORD *)(a1 + 28);
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 40;
    }
  }
}

void re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      v7 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)&v13[16] = v7;
      *(_QWORD *)(a1 + 16) = v6;
      v9 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = v7 + 16;
        do
        {
          if ((*(_DWORD *)(v11 - 8) & 0x80000000) != 0)
            re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::addAsMove(a1, *(_QWORD *)(v11 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v11 - 16), (_QWORD *)v11, (__n128 *)(v11 + 8));
          v11 += 40;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

__n128 re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, __n128 *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  __n128 result;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::AssetType const*,std::pair<unsigned long,unsigned long>,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 40 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 40 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 40 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 16) = *a4;
  result = *a5;
  *(__n128 *)(*(_QWORD *)(a1 + 16) + 40 * v9 + 24) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

_anonymous_namespace_ *re::DynamicOverflowArray<re::internal::AssetEntry *,32ul>::ensureCapacity(_anonymous_namespace_ *result)
{
  _anonymous_namespace_ *v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;

  v1 = result;
  if (!*(_QWORD *)result)
  {
    v7 = *((_QWORD *)v1 + 1) + 1;
    result = (_anonymous_namespace_ *)re::DynamicOverflowArray<re::internal::AssetEntry *,32ul>::setCapacity(v1, v7);
    *((_DWORD *)v1 + 4) += 2;
    return result;
  }
  v2 = *((_QWORD *)result + 1);
  if ((*((_BYTE *)result + 16) & 1) != 0)
  {
    if (v2 - 32 >= 0xFFFFFFFFFFFFFFDFLL)
      return result;
    v4 = v2 + 1;
    v6 = 64;
    goto LABEL_11;
  }
  v3 = *((_QWORD *)result + 3);
  v5 = v2 >= v3;
  v4 = v2 + 1;
  v5 = !v5 || v3 >= v4;
  if (!v5)
  {
    v6 = 2 * v3;
LABEL_11:
    if (v6 <= v4)
      v8 = v4;
    else
      v8 = v6;
    return (_anonymous_namespace_ *)re::DynamicOverflowArray<re::internal::AssetEntry *,32ul>::setCapacity(result, v8);
  }
  return result;
}

_QWORD *re::DynamicOverflowArray<re::internal::AssetEntry *,32ul>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  const void *v13;
  void *v14;
  uint64_t v15;
  const void *v16;
  int v17;

  v4 = result;
  v5 = *result;
  if (a2 && !v5)
  {
    result = (_QWORD *)re::DynamicOverflowArray<re::internal::AssetEntry *,32ul>::setCapacity(v4, a2);
    v6 = *((_DWORD *)v4 + 4) + 2;
LABEL_4:
    *((_DWORD *)v4 + 4) = v6;
    return result;
  }
  v7 = *((_DWORD *)result + 4);
  if ((v7 & 1) != 0)
    v8 = 32;
  else
    v8 = result[3];
  if (v8 != a2)
  {
    v9 = result[1];
    if (v9 <= a2 && (a2 > 0x20 || (v7 & 1) == 0))
    {
      if (a2 < 0x21)
      {
        v14 = result + 3;
        v15 = v4[4];
        if ((v7 & 1) != 0)
          v16 = v4 + 3;
        else
          v16 = (const void *)v4[4];
        memcpy(v14, v16, 8 * v9);
        result = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 40))(v5, v15);
        v6 = *((_DWORD *)v4 + 4) | 1;
        goto LABEL_4;
      }
      if (a2 >> 61)
      {
        re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicOverflowArray<T, N>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 646, 8, a2);
        _os_crash();
        __break(1u);
      }
      else
      {
        v2 = 8 * a2;
        v10 = (void *)(*(uint64_t (**)(_QWORD, unint64_t, uint64_t))(*(_QWORD *)v5 + 32))(*result, 8 * a2, 8);
        if (v10)
        {
          v12 = v10;
          if ((v4[2] & 1) != 0)
            v13 = v4 + 3;
          else
            v13 = (const void *)v4[4];
          result = memcpy(v10, v13, 8 * v4[1]);
          v17 = *((_DWORD *)v4 + 4);
          if ((v17 & 1) == 0)
          {
            result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v4 + 40))(*v4, v4[4]);
            v17 = *((_DWORD *)v4 + 4);
          }
          *((_DWORD *)v4 + 4) = v17 & 0xFFFFFFFE;
          v4[3] = a2;
          v4[4] = v12;
          return result;
        }
      }
      re::internal::assertLog((re::internal *)6, v11, "assertion failure: '%s' (%s:line %i) DynamicOverflowArray<T, N> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 650, v2, *(_QWORD *)(*v4 + 8));
      result = (_QWORD *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

_QWORD *re::DynamicArray<re::AssetLoadDescriptor>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::AssetLoadDescriptor>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::AssetLoadDescriptor>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

uint64_t re::Result<re::AssetPath,re::DetailedError>::~Result(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  _QWORD *v4;

  if (*(_BYTE *)a1)
  {
    v3 = (_OWORD *)(a1 + 48);
    v2 = *(_QWORD *)(a1 + 48);
    if (v2)
    {
      if ((*(_BYTE *)(a1 + 56) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 64));
      *v3 = 0u;
      *(_OWORD *)(a1 + 64) = 0u;
    }
    v4 = (_QWORD *)(a1 + 16);
  }
  else
  {
    v4 = (_QWORD *)(a1 + 24);
  }
  if (*v4)
  {
    if ((v4[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v4 + 40))(*v4, v4[2]);
    *(_OWORD *)v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
  }
  return a1;
}

uint64_t re::Result<re::AssetLoadDescriptor,re::DynamicString>::~Result(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (*(_BYTE *)a1)
  {
    v3 = (_OWORD *)(a1 + 120);
    v2 = *(_QWORD *)(a1 + 120);
    if (v2)
    {
      if ((*(_BYTE *)(a1 + 128) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 136));
      *v3 = 0u;
      *(_OWORD *)(a1 + 136) = 0u;
    }
    v4 = *(_QWORD *)(a1 + 80);
    if (v4)
    {
      if (*(_QWORD *)(a1 + 112))
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 40))(v4);
      *(_QWORD *)(a1 + 112) = 0;
      *(_QWORD *)(a1 + 88) = 0;
      *(_QWORD *)(a1 + 96) = 0;
      *(_QWORD *)(a1 + 80) = 0;
      ++*(_DWORD *)(a1 + 104);
    }
    v5 = *(_QWORD *)(a1 + 40);
    if (v5)
    {
      if (*(_QWORD *)(a1 + 72))
        (*(void (**)(uint64_t))(*(_QWORD *)v5 + 40))(v5);
      *(_QWORD *)(a1 + 72) = 0;
      *(_QWORD *)(a1 + 48) = 0;
      *(_QWORD *)(a1 + 56) = 0;
      *(_QWORD *)(a1 + 40) = 0;
      ++*(_DWORD *)(a1 + 64);
    }
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v6)
  {
    if ((*(_BYTE *)(a1 + 16) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v6 + 40))(v6, *(_QWORD *)(a1 + 24));
    *(_OWORD *)(a1 + 8) = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
  }
  return a1;
}

void re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  signed int v21;
  _BYTE v22[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(_QWORD *)&v22[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v22, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v22;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)v22 = v5;
      *(_QWORD *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = (_QWORD *)(v6 + 48);
        do
        {
          if ((*(_DWORD *)(v13 - 5) & 0x80000000) != 0)
          {
            v14 = *(v13 - 6);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 56 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 56 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 56 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v17) = v14;
            re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 56 * v17 + 16), (const re::DynamicString *)(v13 - 4));
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v17 + 48) = *v13;
            *v13 = 0;
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 7;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2)
      v21 = a2;
    else
      v21 = 3;
  }
}

void re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 56 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_155, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void std::__function::__func<re::AssetManager::processRegisteringEntries(re::AssetManager::UpdateDeadline)::$_2,std::allocator<re::AssetManager::processRegisteringEntries(re::AssetManager::UpdateDeadline)::$_2>,void ()(void)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

__n128 std::__function::__func<re::AssetManager::processRegisteringEntries(re::AssetManager::UpdateDeadline)::$_2,std::allocator<re::AssetManager::processRegisteringEntries(re::AssetManager::UpdateDeadline)::$_2>,void ()(void)>::__clone(uint64_t a1)
{
  char *v2;
  __n128 result;

  v2 = (char *)operator new(0x18uLL);
  *(_QWORD *)v2 = &off_24ED2C8B0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<re::AssetManager::processRegisteringEntries(re::AssetManager::UpdateDeadline)::$_2,std::allocator<re::AssetManager::processRegisteringEntries(re::AssetManager::UpdateDeadline)::$_2>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_QWORD *)a2 = &off_24ED2C8B0;
  result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<re::AssetManager::processRegisteringEntries(re::AssetManager::UpdateDeadline)::$_2,std::allocator<re::AssetManager::processRegisteringEntries(re::AssetManager::UpdateDeadline)::$_2>,void ()(void)>::operator()(uint64_t a1)
{
  return re::AssetManager::processAssetRegistration_entryStateLocked(*(re::AssetManager **)(a1 + 8), **(re::internal::AssetEntry ***)(a1 + 16));
}

uint64_t std::__function::__func<re::AssetManager::processRegisteringEntries(re::AssetManager::UpdateDeadline)::$_2,std::allocator<re::AssetManager::processRegisteringEntries(re::AssetManager::UpdateDeadline)::$_2>,void ()(void)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::AssetManager::processRegisteringEntries(re::AssetManager::UpdateDeadline)::$_2,std::allocator<re::AssetManager::processRegisteringEntries(re::AssetManager::UpdateDeadline)::$_2>,void ()(void)>::target_type()
{
}

_QWORD *re::DynamicArray<re::Function<void ()(re::DynamicArray<unsigned long long>)>>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::Function<void ()(re::DynamicArray<unsigned long long>)>>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::Function<void ()(re::DynamicArray<unsigned long long>)>>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::Function<void ()(re::DynamicArray<unsigned long long>)>>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;

  v3 = result[1];
  if (v3 == a2)
    return result;
  v5 = result;
  if (result[2] > a2)
    return result;
  result = (_QWORD *)*result;
  if (!*v5)
  {
    result = (_QWORD *)re::DynamicArray<re::Function<void ()(re::DynamicArray<unsigned long long>)>>::setCapacity(v5, a2);
    ++*((_DWORD *)v5 + 6);
    return result;
  }
  if (a2)
  {
    if (is_mul_ok(a2, 0x28uLL))
    {
      v2 = 40 * a2;
      result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
      if (result)
      {
        v7 = result;
        if (!v5[1])
          goto LABEL_27;
        goto LABEL_11;
      }
    }
    else
    {
      re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
      _os_crash();
      __break(1u);
    }
    re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
    result = (_QWORD *)_os_crash();
    __break(1u);
    return result;
  }
  v7 = 0;
  if (!v3)
    goto LABEL_27;
LABEL_11:
  v8 = v5[4];
  v9 = v5[2];
  if (!v9)
    goto LABEL_26;
  v10 = 40 * v9;
  v11 = (uint64_t)v7;
  do
  {
    *(_QWORD *)(v11 + 24) = *(_QWORD *)(v8 + 24);
    *(_QWORD *)(v11 + 32) = 0;
    if (v8 == v11)
      goto LABEL_24;
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v11);
    v12 = *(_QWORD *)(v8 + 32);
    if (*(_QWORD *)(v11 + 24) == *(_QWORD *)(v8 + 24))
    {
      v13 = v8;
      if (v8 != v12)
      {
        *(_QWORD *)(v11 + 32) = v12;
        *(_QWORD *)(v8 + 32) = 0;
        goto LABEL_24;
      }
    }
    else
    {
      v13 = *(_QWORD *)(v8 + 32);
      if (!v12)
        goto LABEL_24;
    }
    v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v13 + 40))(v13);
    v15 = v11;
    if (v14 >= 0x19)
    {
      v16 = v14;
      v17 = *(_QWORD *)(v11 + 24);
      if (v17)
        v15 = (*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(*(_QWORD *)v17 + 32))(v17, v16, 0);
      else
        v15 = 0;
    }
    *(_QWORD *)(v11 + 32) = v15;
    (*(void (**)(_QWORD))(**(_QWORD **)(v8 + 32) + 32))(*(_QWORD *)(v8 + 32));
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v8);
LABEL_24:
    re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v8);
    v8 += 40;
    v11 += 40;
    v10 -= 40;
  }
  while (v10);
  v8 = v5[4];
LABEL_26:
  result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
LABEL_27:
  v5[4] = v7;
  v5[1] = a2;
  return result;
}

void re::details::release<re::ResourceRequest>(unsigned int *a1)
{
  unsigned int *v2;
  unsigned int v3;
  const void *v4;

  v2 = a1 + 2;
  do
  {
    v3 = __ldaxr(v2);
    v4 = (const void *)(v3 - 1);
  }
  while (__stlxr(v4, v2));
  if (v3 - 1048578 > 0xFFEFFFFE)
  {
    if (v3 != 1)
      return;
LABEL_7:
    (*(void (**)(unsigned int *))(*(_QWORD *)a1 + 16))(a1);
    return;
  }
  re::internal::refCountCheckFailHandler(0, a1, v4);
  if (!(_DWORD)v4)
    goto LABEL_7;
}

_anonymous_namespace_ *re::DynamicArray<re::AssetLoadDescriptor>::resize(_anonymous_namespace_ *result, unint64_t a2)
{
  _anonymous_namespace_ *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _anonymous_namespace_ *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v3 = result;
  v4 = *((_QWORD *)result + 2);
  if (v4 >= a2)
  {
    if (v4 <= a2)
      return result;
    v9 = 144 * a2 + 128;
    v10 = a2;
    do
    {
      v11 = *((_QWORD *)v3 + 4);
      v12 = v11 + v9;
      v13 = *(_QWORD *)(v11 + v9 - 16);
      if (v13)
      {
        if ((*(_BYTE *)(v12 - 8) & 1) != 0)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v13 + 40))(v13, *(_QWORD *)(v11 + v9));
        *(_OWORD *)(v11 + v9 - 16) = 0u;
        *(_OWORD *)(v11 + v9) = 0u;
      }
      v16 = *(_QWORD *)(v12 - 56);
      v15 = (_QWORD *)(v12 - 56);
      v14 = v16;
      if (v16)
      {
        v17 = v11 + v9;
        if (*(_QWORD *)(v11 + v9 - 24))
          (*(void (**)(uint64_t))(*(_QWORD *)v14 + 40))(v14);
        *(_QWORD *)(v17 - 24) = 0;
        v15[1] = 0;
        v15[2] = 0;
        *v15 = 0;
        ++*(_DWORD *)(v17 - 32);
      }
      v18 = v11 + v9;
      v19 = *(_QWORD *)(v11 + v9 - 96);
      if (v19)
      {
        if (*(_QWORD *)(v18 - 64))
          (*(void (**)(uint64_t))(*(_QWORD *)v19 + 40))(v19);
        *(_QWORD *)(v18 - 64) = 0;
        *(_QWORD *)(v11 + v9 - 88) = 0;
        *(_QWORD *)(v11 + v9 - 80) = 0;
        *(_QWORD *)(v11 + v9 - 96) = 0;
        ++*(_DWORD *)(v11 + v9 - 72);
      }
      result = *(_anonymous_namespace_ **)(v11 + v9 - 128);
      if (result)
      {
        if ((*(_BYTE *)(v11 + v9 - 120) & 1) != 0)
          result = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, _QWORD))(*(_QWORD *)result + 40))(result, *(_QWORD *)(v11 + v9 - 112));
        *(_OWORD *)(v11 + v9 - 128) = 0u;
        *(_OWORD *)(v11 + v9 - 112) = 0u;
      }
      ++v10;
      v9 += 144;
    }
    while (v10 < *((_QWORD *)v3 + 2));
  }
  else
  {
    if (*((_QWORD *)result + 1) < a2)
    {
      result = (_anonymous_namespace_ *)re::DynamicArray<re::AssetLoadDescriptor>::setCapacity(result, a2);
      v4 = *((_QWORD *)v3 + 2);
    }
    v5 = a2 - v4;
    if (a2 > v4)
    {
      v6 = 144 * v4;
      do
      {
        v7 = *((_QWORD *)v3 + 4) + v6;
        *(_OWORD *)v7 = 0u;
        *(_OWORD *)(v7 + 16) = 0u;
        v8 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)v7, 0);
        *(_QWORD *)(v7 + 32) = 0;
        *(_QWORD *)(v7 + 40) = 0;
        *(_DWORD *)(v7 + 56) = 0;
        *(_QWORD *)(v7 + 48) = 0;
        *(_OWORD *)(v7 + 64) = 0u;
        *(_OWORD *)(v7 + 80) = 0u;
        *(_DWORD *)(v7 + 96) = 0;
        *(_OWORD *)(v7 + 104) = 0u;
        *(_OWORD *)(v7 + 120) = 0u;
        *(_QWORD *)(v7 + 136) = 0;
        result = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)(v7 + 112), 0);
        v6 += 144;
        --v5;
      }
      while (v5);
    }
  }
  *((_QWORD *)v3 + 2) = a2;
  ++*((_DWORD *)v3 + 6);
  return result;
}

re::DynamicString *re::DynamicArray<re::AssetLoadDescriptor>::copy(re::DynamicString *this, re::DynamicString *a2, unint64_t a3)
{
  re::DynamicString *v3;
  unint64_t v4;
  uint64_t v7;
  re::DynamicString *v8;
  uint64_t v9;
  uint64_t v10;

  if (a3)
  {
    v3 = this;
    v4 = *((_QWORD *)this + 2);
    if (v4 == -1)
    {
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v4 >= a3)
    {
      this = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::AssetLoadDescriptor const*,re::AssetLoadDescriptor const*,re::AssetLoadDescriptor*>(a2, (re::DynamicString *)((char *)a2 + 144 * a3), *((_QWORD *)this + 4));
    }
    else
    {
      re::DynamicArray<re::AssetLoadDescriptor>::growCapacity(this, a3);
      v7 = *((_QWORD *)v3 + 2);
      v8 = (re::DynamicString *)((char *)a2 + 144 * v7);
      this = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::AssetLoadDescriptor const*,re::AssetLoadDescriptor const*,re::AssetLoadDescriptor*>(a2, v8, *((_QWORD *)v3 + 4));
      if (v7 != a3)
      {
        v9 = 0;
        v10 = *((_QWORD *)v3 + 4) + 144 * *((_QWORD *)v3 + 2);
        do
        {
          re::DynamicString::DynamicString((re::DynamicString *)(v10 + v9), (re::DynamicString *)((char *)v8 + v9));
          re::DynamicArray<BOOL>::DynamicArray(v10 + v9 + 32, (uint64_t *)((char *)v8 + v9 + 32));
          re::DynamicArray<BOOL>::DynamicArray(v10 + v9 + 72, (uint64_t *)((char *)v8 + v9 + 72));
          this = re::DynamicString::DynamicString((re::DynamicString *)(v10 + v9 + 112), (re::DynamicString *)((char *)v8 + v9 + 112));
          v9 += 144;
        }
        while (-144 * v7 + 144 * a3 != v9);
      }
      *((_QWORD *)v3 + 2) = a3;
    }
    ++*((_DWORD *)v3 + 6);
  }
  return this;
}

re::DynamicString *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<re::AssetLoadDescriptor const*,re::AssetLoadDescriptor const*,re::AssetLoadDescriptor*>(re::DynamicString *result, re::DynamicString *a2, uint64_t a3)
{
  re::DynamicString *v5;
  uint64_t v6;

  if (result != a2)
  {
    v5 = result;
    v6 = 0;
    do
    {
      re::DynamicString::operator=((re::DynamicString *)(a3 + v6), (re::DynamicString *)((char *)v5 + v6));
      re::DynamicArray<BOOL>::operator=(a3 + v6 + 32, (uint64_t *)((char *)v5 + v6 + 32));
      re::DynamicArray<BOOL>::operator=(a3 + v6 + 72, (uint64_t *)((char *)v5 + v6 + 72));
      result = re::DynamicString::operator=((re::DynamicString *)(a3 + v6 + 112), (re::DynamicString *)((char *)v5 + v6 + 112));
      v6 += 144;
    }
    while ((re::DynamicString *)((char *)v5 + v6) != a2);
  }
  return result;
}

uint64_t re::DynamicArray<re::NetworkActionQueue::Action>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 168 * v4;
        do
        {
          v6 = *(unsigned int *)(v3 + 144);
          if ((_DWORD)v6 != -1)
            ((void (*)(char *, uint64_t))off_24ED2C920[v6])(&v7, v3);
          *(_DWORD *)(v3 + 144) = -1;
          v3 += 168;
          v5 -= 168;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSJ_1EJS9_SG_SH_SB_EEEEEEDcSL_DpT0_(double a1, uint64_t a2, uint64_t *a3)
{
  return re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(a3, a1);
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSJ_1EJS9_SG_SH_SB_EEEEEEDcSL_DpT0_(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  _OWORD *v4;
  double result;
  uint64_t v6;
  uint64_t v7;

  v4 = a2 + 14;
  v3 = a2[14];
  if (v3)
  {
    if ((a2[15] & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, a2[16]);
    result = 0.0;
    *v4 = 0u;
    v4[1] = 0u;
  }
  v6 = a2[9];
  if (v6)
  {
    if (a2[13])
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 40))(v6);
    a2[13] = 0;
    a2[10] = 0;
    a2[11] = 0;
    a2[9] = 0;
    ++*((_DWORD *)a2 + 24);
  }
  v7 = a2[4];
  if (v7)
  {
    if (a2[8])
      (*(void (**)(uint64_t))(*(_QWORD *)v7 + 40))(v7);
    a2[8] = 0;
    a2[5] = 0;
    a2[6] = 0;
    a2[4] = 0;
    ++*((_DWORD *)a2 + 14);
  }
  if (*a2)
  {
    if ((a2[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 40))(*a2, a2[2]);
    result = 0.0;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
  }
  return result;
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2re23AssetNetworkSharingModeENS8_9HashTableINS8_13DynamicStringEyNS8_4HashISB_EENS8_7EqualToISB_EELb1ELb0EEENS8_19AssetLoadDescriptorESB_EEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSJ_1EJS9_SG_SH_SB_EEEEEEDcSL_DpT0_(uint64_t a1, _QWORD *a2)
{
  double result;

  if (*a2)
  {
    if ((a2[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 40))(*a2, a2[2]);
    result = 0.0;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
  }
  return result;
}

_QWORD *re::FixedArray<BOOL>::init<BOOL>(_QWORD *result, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  *result = a2;
  result[1] = a3;
  if (a3)
  {
    v6 = result;
    result = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, a3, 1);
    v6[2] = result;
    if (result)
    {
      v8 = a3 - 1;
      if (a3 != 1)
      {
        do
        {
          *(_BYTE *)result = *a4;
          result = (_QWORD *)((char *)result + 1);
          --v8;
        }
        while (v8);
      }
      *(_BYTE *)result = *a4;
    }
    else
    {
      re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
      result = (_QWORD *)_os_crash();
      __break(1u);
    }
  }
  return result;
}

void re::HashTable<re::DynamicString,re::AssetHandle const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  unint64_t *v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  signed int v20;
  _BYTE v21[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v21, 0, 36);
      *(_QWORD *)&v21[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v21, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v21;
      v6 = *(unint64_t **)(a1 + 16);
      v7 = *(_OWORD *)&v21[8];
      *(_OWORD *)v21 = v5;
      *(_QWORD *)&v21[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v21[24];
      *(_OWORD *)&v21[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v21[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        do
        {
          if ((v6[1] & 0x80000000) != 0)
          {
            v13 = *v6;
            v14 = *(unsigned int *)(a1 + 24);
            v15 = *v6 % v14;
            v16 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v16 == 0x7FFFFFFF)
            {
              v16 = *(unsigned int *)(a1 + 32);
              v17 = v16;
              if ((_DWORD)v16 == (_DWORD)v14)
              {
                re::HashTable<re::DynamicString,re::AssetHandle const*,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * v11));
                v15 = v13 % *(unsigned int *)(a1 + 24);
                v17 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v17 + 1;
              v18 = *(_QWORD *)(a1 + 16);
              v19 = *(_DWORD *)(v18 + 56 * v16 + 8);
            }
            else
            {
              v18 = *(_QWORD *)(a1 + 16);
              v19 = *(_DWORD *)(v18 + 56 * v16 + 8);
              *(_DWORD *)(a1 + 36) = v19 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v18 + 56 * v16 + 8) = v19 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v16 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v16 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v15);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v16) = v13;
            re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 56 * v16 + 16), (const re::DynamicString *)(v6 + 2));
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v16 + 48) = v6[6];
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v15) = v16;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v6 += 7;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v21, *(double *)&v7);
    }
  }
  else
  {
    if (a2)
      v20 = a2;
    else
      v20 = 3;
  }
}

_anonymous_namespace_ *re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::findEntry@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6;
  _anonymous_namespace_ *result;
  int v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  unint64_t v16;
  uint64_t v17;
  _QWORD v18[4];
  char v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v21 = 0;
  v22 = 0;
  v23 = 0;
  re::DynamicString::setCapacity(&v20, 0);
  re::DynamicString::DynamicString((re::DynamicString *)v18, (const re::DynamicString *)(a2 + 2));
  v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v19, (uint64_t)v18);
  if (v18[0])
  {
    if ((v18[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v18[0] + 40))();
    memset(v18, 0, sizeof(v18));
  }
  result = (_anonymous_namespace_ *)v20;
  if (v20 && (v21 & 1) != 0)
    result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*v20 + 40))();
  v8 = 0x7FFFFFFF;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v9) = 0;
    goto LABEL_23;
  }
  v9 = v6 % *(unsigned int *)(a1 + 24);
  v10 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v9);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
LABEL_23:
    v12 = 0x7FFFFFFF;
    goto LABEL_25;
  }
  v16 = v6 % *(unsigned int *)(a1 + 24);
  v17 = a3;
  v11 = *(_QWORD *)(a1 + 16);
  v8 = 0x7FFFFFFF;
  v12 = 0x7FFFFFFF;
  do
  {
    v13 = v10;
    v14 = v11 + 88 * v10;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    re::DynamicString::setCapacity(&v20, 0);
    if (*(_DWORD *)(v14 + 16) == *a2)
    {
      v15 = re::DynamicString::operator==(v11 + 88 * v13 + 24, (uint64_t)(a2 + 2));
      result = (_anonymous_namespace_ *)v20;
      if (v20 && (v21 & 1) != 0)
        result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*v20 + 40))();
      if (v15)
      {
        v8 = v13;
        goto LABEL_24;
      }
    }
    else
    {
      result = (_anonymous_namespace_ *)v20;
      if (v20 && (v21 & 1) != 0)
        result = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*v20 + 40))();
    }
    v11 = *(_QWORD *)(a1 + 16);
    v10 = *(_DWORD *)(v11 + 88 * v13 + 8) & 0x7FFFFFFF;
    v12 = v13;
  }
  while (v10 != 0x7FFFFFFF);
  v12 = v13;
LABEL_24:
  a3 = v17;
  LODWORD(v9) = v16;
LABEL_25:
  *(_QWORD *)a3 = v6;
  *(_DWORD *)(a3 + 8) = v9;
  *(_DWORD *)(a3 + 12) = v8;
  *(_DWORD *)(a3 + 16) = v12;
  return result;
}

_QWORD *std::__function::__func<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2,std::allocator<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2>,void ()(BOOL)>::~__func(_QWORD *a1)
{
  *a1 = &off_24ED2C950;
  re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)(a1 + 7));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 4));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 1));
  return a1;
}

void std::__function::__func<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2,std::allocator<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2>,void ()(BOOL)>::~__func(_QWORD *a1)
{
  *a1 = &off_24ED2C950;
  re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)(a1 + 7));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 4));
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 1));
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2,std::allocator<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2>,void ()(BOOL)>::__clone(uint64_t a1)
{
  uint64_t *v1;
  _QWORD *v2;

  v1 = (uint64_t *)(a1 + 8);
  v2 = operator new(0x68uLL);
  *v2 = &off_24ED2C950;
  std::__compressed_pair_elem<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2,0,false>::__compressed_pair_elem[abi:nn180100]<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2 const&,0ul>((re::AssetHandle *)(v2 + 1), v1);
  return v2;
}

re::AssetHandle *std::__function::__func<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2,std::allocator<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2>,void ()(BOOL)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED2C950;
  return std::__compressed_pair_elem<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2,0,false>::__compressed_pair_elem[abi:nn180100]<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2 const&,0ul>((re::AssetHandle *)(a2 + 1), (uint64_t *)(a1 + 8));
}

void std::__function::__func<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2,std::allocator<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2>,void ()(BOOL)>::destroy(uint64_t a1)
{
  re::AssetHandle *v2;

  v2 = (re::AssetHandle *)(a1 + 8);
  re::DynamicArray<re::AssetLoadDescriptor>::deinit(a1 + 56);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 32));
  re::AssetHandle::~AssetHandle(v2);
}

void std::__function::__func<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2,std::allocator<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2>,void ()(BOOL)>::destroy_deallocate(uint64_t a1)
{
  re::AssetHandle *v2;

  v2 = (re::AssetHandle *)(a1 + 8);
  re::DynamicArray<re::AssetLoadDescriptor>::deinit(a1 + 56);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 32));
  re::AssetHandle::~AssetHandle(v2);
  operator delete((void *)a1);
}

void std::__function::__func<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2,std::allocator<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2>,void ()(BOOL)>::operator()(_QWORD *a1, unsigned __int8 *a2)
{
  int v3;
  os_unfair_lock_s *v4;
  os_unfair_lock_s *v5;
  uint64_t v6;
  unsigned int v7;

  v3 = *a2;
  v4 = (os_unfair_lock_s *)a1[12];
  v5 = (os_unfair_lock_s *)(a1[2] + 384);
  os_unfair_lock_lock(v5);
  if (v3 || (v6 = a1[5]) != 0 && (v7 = atomic_load((unsigned int *)(v6 + 704)), v7 == 2))
    re::AssetManager::reuseExistingOrLoadNewAsset_locked(v4, (_QWORD *)a1[2], a1 + 7);
  else
    re::AssetManager::loadAssetFromDescriptorsOnBackgroundTask_entryStateLocked((uint64_t)v4, (_QWORD *)a1[2], a1 + 7);
  os_unfair_lock_unlock(v5);
}

uint64_t std::__function::__func<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2,std::allocator<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2>,void ()(BOOL)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2,std::allocator<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2>,void ()(BOOL)>::target_type()
{
}

re::AssetHandle *std::__compressed_pair_elem<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2,0,false>::__compressed_pair_elem[abi:nn180100]<re::AssetManager::tryReuseExistingAsset_locked(re::internal::AssetEntry &,re::DynamicArray<re::AssetLoadDescriptor> const&)::$_2 const&,0ul>(re::AssetHandle *a1, uint64_t *a2)
{
  re::AssetHandle *v4;

  v4 = re::AssetHandle::AssetHandle(a1, (const re::AssetHandle *)a2);
  re::AssetHandle::AssetHandle((re::AssetHandle *)((char *)v4 + 24), (const re::AssetHandle *)(a2 + 3));
  re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray((uint64_t)a1 + 48, a2 + 6);
  *((_QWORD *)a1 + 11) = a2[11];
  return a1;
}

void std::__function::__func<re::AssetManager::registerCustomAssetType(re::CustomAssetRegistrationParameters const&)::$_0,std::allocator<re::AssetManager::registerCustomAssetType(re::CustomAssetRegistrationParameters const&)::$_0>,void ()(re::AssetLoader *)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::AssetManager::registerCustomAssetType(re::CustomAssetRegistrationParameters const&)::$_0,std::allocator<re::AssetManager::registerCustomAssetType(re::CustomAssetRegistrationParameters const&)::$_0>,void ()(re::AssetLoader *)>::__clone()
{
  _QWORD *result;

  result = operator new(0x10uLL);
  *result = &off_24ED2C9E0;
  return result;
}

void std::__function::__func<re::AssetManager::registerCustomAssetType(re::CustomAssetRegistrationParameters const&)::$_0,std::allocator<re::AssetManager::registerCustomAssetType(re::CustomAssetRegistrationParameters const&)::$_0>,void ()(re::AssetLoader *)>::__clone(uint64_t a1, _QWORD *a2)
{
  *a2 = &off_24ED2C9E0;
}

re *std::__function::__func<re::AssetManager::registerCustomAssetType(re::CustomAssetRegistrationParameters const&)::$_0,std::allocator<re::AssetManager::registerCustomAssetType(re::CustomAssetRegistrationParameters const&)::$_0>,void ()(re::AssetLoader *)>::operator()(re *result, void (****a2)(_QWORD))
{
  void (***v2)(_QWORD);
  uint64_t v3;

  v2 = *a2;
  if (*a2)
  {
    v3 = re::globalAllocators(result)[2];
    (**v2)(v2);
    return (re *)(*(uint64_t (**)(uint64_t, void (***)(_QWORD)))(*(_QWORD *)v3 + 40))(v3, v2);
  }
  return result;
}

uint64_t std::__function::__func<re::AssetManager::registerCustomAssetType(re::CustomAssetRegistrationParameters const&)::$_0,std::allocator<re::AssetManager::registerCustomAssetType(re::CustomAssetRegistrationParameters const&)::$_0>,void ()(re::AssetLoader *)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::AssetManager::registerCustomAssetType(re::CustomAssetRegistrationParameters const&)::$_0,std::allocator<re::AssetManager::registerCustomAssetType(re::CustomAssetRegistrationParameters const&)::$_0>,void ()(re::AssetLoader *)>::target_type()
{
}

void re::HashTable<re::AssetType const*,re::AssetTypeStatistics *,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 32 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_155, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<re::AssetType const*,re::AssetTypeStatistics *,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  int v10;
  int v11;
  signed int v12;
  uint64_t v13;
  BOOL v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  signed int v24;
  _BYTE v25[44];

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      v11 = *(_DWORD *)(a1 + 28);
      v12 = 2 * v11;
      v13 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v12)
          v14 = (_DWORD)v9 == v12;
        else
          v14 = 1;
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v25, 0, 36);
          *(_QWORD *)&v25[36] = 0x7FFFFFFFLL;
          re::HashTable<re::AssetType const*,re::AssetTypeStatistics *,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::init((uint64_t)v25, v13, v12);
          v15 = *(_OWORD *)v25;
          *(_OWORD *)v25 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          v16 = *(_QWORD *)&v25[16];
          v17 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v25[16] = v17;
          *(_QWORD *)(a1 + 16) = v16;
          v19 = *(_OWORD *)&v25[24];
          *(_OWORD *)&v25[24] = *(_OWORD *)(a1 + 24);
          v18 = *(_DWORD *)&v25[32];
          *(_OWORD *)(a1 + 24) = v19;
          v20 = v18;
          if (v18)
          {
            v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0)
                re::HashTable<re::AssetType const*,re::AssetTypeStatistics *,re::Hash<re::AssetType const*>,re::EqualTo<re::AssetType const*>,true,false>::addAsMove(a1, *(_QWORD *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v21 - 16), v21, v21 + 8);
              v21 += 32;
              --v20;
            }
            while (v20);
          }
          re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v25);
        }
      }
      else
      {
        if (v12)
          v24 = 2 * v11;
        else
          v24 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 32 * v9 + 8);
  }
  else
  {
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 32 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + 32 * v9 + 8) = v23 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 16) = *a4;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v9 + 24) = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
}

uint64_t re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::addEmplace<char const*&>(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, const char **a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _anonymous_namespace_ *v16;
  re::DynamicString *v17;
  const char *v18;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  v14 = 88 * v10;
  *(_DWORD *)(v12 + v14 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v14) = a3;
  v15 = *(_QWORD *)(a1 + 16) + v14;
  *(_DWORD *)(v15 + 16) = *(_DWORD *)a4;
  v16 = re::DynamicString::DynamicString((re::DynamicString *)(v15 + 24), (re::DynamicString *)((char *)a4 + 8));
  v17 = (re::DynamicString *)(*(_QWORD *)(a1 + 16) + 88 * v10 + 56);
  v18 = *a5;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  signed int v26;
  _BYTE v27[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v27, 0, 36);
      *(_QWORD *)&v27[36] = 0x7FFFFFFFLL;
      re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::init((uint64_t)v27, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v27;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v27[8];
      *(_OWORD *)v27 = v5;
      *(_QWORD *)&v27[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v27[24];
      *(_OWORD *)&v27[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v27[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = (_QWORD *)(v6 + 80);
        do
        {
          if ((*(_DWORD *)(v13 - 9) & 0x80000000) != 0)
          {
            v14 = *(v13 - 10);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(_DWORD *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              v17 = *(_DWORD *)(a1 + 32);
              v18 = v17;
              if (v17 == (_DWORD)v15)
              {
                re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 88 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 88 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 88 * v17 + 8) = v20 | 0x80000000;
            v21 = *(_QWORD *)(a1 + 16) + 88 * v17;
            *(_DWORD *)(v21 + 8) = *(_DWORD *)(v21 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 88 * v17) = v14;
            v22 = *(_QWORD *)(a1 + 16) + 88 * v17;
            *(_DWORD *)(v22 + 16) = *((_DWORD *)v13 - 16);
            re::DynamicString::DynamicString((re::DynamicString *)(v22 + 24), (const re::DynamicString *)(v13 - 7));
            v23 = *(_QWORD *)(a1 + 16) + 88 * v17;
            *(_OWORD *)(v23 + 72) = 0u;
            *(_OWORD *)(v23 + 56) = 0u;
            *(_QWORD *)(v23 + 56) = *(v13 - 3);
            *(v13 - 3) = 0;
            v24 = *(_QWORD *)(v23 + 72);
            *(_QWORD *)(v23 + 72) = *(v13 - 1);
            *(v13 - 1) = v24;
            *(_QWORD *)(v23 + 80) = *v13;
            *v13 = 0;
            v25 = *(_QWORD *)(v23 + 64);
            *(_QWORD *)(v23 + 64) = *(v13 - 2);
            *(v13 - 2) = v25;
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 11;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::deinit((uint64_t *)v27);
    }
  }
  else
  {
    if (a2)
      v26 = a2;
    else
      v26 = 3;
  }
}

void re::HashTable<re::internal::AssetLoadingRoot,re::DynamicString,re::internal::AssetLoadingRoot,re::internal::AssetLoadingRoot,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 88 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_155, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t *re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t *a4, uint64_t *a5)
{
  unsigned int v10;
  unsigned int v11;
  int v12;
  signed int v13;
  uint64_t v14;
  BOOL v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  signed int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *result;
  _BYTE v30[44];

  v10 = *(_DWORD *)(a1 + 36);
  if (v10 == 0x7FFFFFFF)
  {
    v10 = *(_DWORD *)(a1 + 32);
    v11 = v10;
    if (v10 == *(_DWORD *)(a1 + 24))
    {
      v12 = *(_DWORD *)(a1 + 28);
      v13 = 2 * v12;
      v14 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v13)
          v15 = v10 == v13;
        else
          v15 = 1;
        if (!v15 && (v12 & 0x80000000) == 0)
        {
          memset(v30, 0, 36);
          *(_QWORD *)&v30[36] = 0x7FFFFFFFLL;
          re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::init((uint64_t)v30, v14, v13);
          v16 = *(_OWORD *)v30;
          *(_OWORD *)v30 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v16;
          v17 = *(_QWORD *)&v30[16];
          v18 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v30[16] = v18;
          *(_QWORD *)(a1 + 16) = v17;
          v20 = *(_OWORD *)&v30[24];
          *(_OWORD *)&v30[24] = *(_OWORD *)(a1 + 24);
          v19 = *(_DWORD *)&v30[32];
          *(_OWORD *)(a1 + 24) = v20;
          v21 = v19;
          if (v19)
          {
            v22 = v18 + 160;
            do
            {
              if ((*(_DWORD *)(v22 - 152) & 0x80000000) != 0)
                re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::addAsMove(a1, *(_QWORD *)(v22 - 160) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v22 - 160), v22 - 144, v22);
              v22 += 208;
              --v21;
            }
            while (v21);
          }
          re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::deinit((uint64_t *)v30);
        }
      }
      else
      {
        if (v13)
          v25 = 2 * v12;
        else
          v25 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v23 = *(_QWORD *)(a1 + 16);
    v24 = *(_DWORD *)(v23 + 208 * v10 + 8);
  }
  else
  {
    v23 = *(_QWORD *)(a1 + 16);
    v24 = *(_DWORD *)(v23 + 208 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v24 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v23 + 208 * v10 + 8) = v24 | 0x80000000;
  v26 = 208 * v10;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v26 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + v26 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v26) = a3;
  v27 = *(_QWORD *)(a1 + 16) + v26;
  re::DynamicString::DynamicString((re::DynamicString *)(v27 + 16), (const re::DynamicString *)a4);
  re::DynamicArray<BOOL>::DynamicArray(v27 + 48, a4 + 4);
  re::DynamicArray<BOOL>::DynamicArray(v27 + 88, a4 + 9);
  re::DynamicString::DynamicString((re::DynamicString *)(v27 + 128), (const re::DynamicString *)(a4 + 14));
  v28 = *(_QWORD *)(a1 + 16) + 208 * v10;
  *(_OWORD *)(v28 + 160) = 0u;
  v28 += 160;
  *(_DWORD *)(v28 + 32) = 0;
  *(_OWORD *)(v28 + 16) = 0u;
  *(_QWORD *)(v28 + 36) = 0x7FFFFFFFLL;
  result = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v28, a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

void re::HashTable<re::AssetLoadDescriptor,re::HashSet<unsigned long long,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 208 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_155, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, uint64_t *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + (v10 << 6) + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6)) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 16) = *a4;
  re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray(*(_QWORD *)(a1 + 16) + (v10 << 6) + 24, a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  signed int v24;
  _BYTE v25[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v25, 0, 36);
      *(_QWORD *)&v25[36] = 0x7FFFFFFFLL;
      re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v25, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v25;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v25[8];
      *(_OWORD *)v25 = v5;
      *(_QWORD *)&v25[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v25[24];
      *(_OWORD *)&v25[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v25[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = v6 + 32;
        do
        {
          if ((*(_DWORD *)(v13 - 24) & 0x80000000) != 0)
          {
            v14 = *(_QWORD *)(v13 - 32);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + (v17 << 6) + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + (v17 << 6) + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + (v17 << 6) + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v17 << 6) + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v17 << 6) + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v17 << 6)) = v14;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v17 << 6) + 16) = *(_QWORD *)(v13 - 16);
            v21 = *(_QWORD *)(a1 + 16) + (v17 << 6);
            *(_QWORD *)(v21 + 56) = 0;
            *(_DWORD *)(v21 + 48) = 0;
            *(_QWORD *)(v21 + 32) = 0;
            *(_QWORD *)(v21 + 40) = 0;
            *(_QWORD *)(v21 + 24) = 0;
            *(_QWORD *)(v21 + 24) = *(_QWORD *)(v13 - 8);
            *(_QWORD *)(v13 - 8) = 0;
            *(_QWORD *)(v21 + 32) = *(_QWORD *)v13;
            *(_QWORD *)v13 = 0;
            v22 = *(_QWORD *)(v21 + 40);
            *(_QWORD *)(v21 + 40) = *(_QWORD *)(v13 + 8);
            *(_QWORD *)(v13 + 8) = v22;
            v23 = *(_QWORD *)(v21 + 56);
            *(_QWORD *)(v21 + 56) = *(_QWORD *)(v13 + 24);
            *(_QWORD *)(v13 + 24) = v23;
            ++*(_DWORD *)(v13 + 16);
            ++*(_DWORD *)(v21 + 48);
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 64;
          --v10;
        }
        while (v10);
      }
      re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v25);
    }
  }
  else
  {
    if (a2)
      v24 = a2;
    else
      v24 = 3;
  }
}

void re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + (v10 << 6), 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_155, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::addEmplace<unsigned long long &>(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, _QWORD *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 168 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 168 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 168 * v10 + 8) = v13 | 0x80000000;
  v14 = 168 * v10;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v14) = a3;
  v15 = *(_QWORD *)(a1 + 16) + v14;
  re::DynamicString::DynamicString((re::DynamicString *)(v15 + 16), a4);
  re::DynamicArray<BOOL>::DynamicArray(v15 + 48, (uint64_t *)a4 + 4);
  re::DynamicArray<BOOL>::DynamicArray(v15 + 88, (uint64_t *)a4 + 9);
  re::DynamicString::DynamicString((re::DynamicString *)(v15 + 128), (re::DynamicString *)((char *)a4 + 112));
  v16 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 168 * v10 + 160) = *a5;
  *(_DWORD *)(v16 + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  signed int v23;
  _BYTE v24[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v24, 0, 36);
      *(_QWORD *)&v24[36] = 0x7FFFFFFFLL;
      re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::init((uint64_t)v24, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v24;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v24[8];
      *(_OWORD *)v24 = v5;
      *(_QWORD *)&v24[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v24[24];
      *(_OWORD *)&v24[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v24[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = (uint64_t *)(v6 + 88);
        do
        {
          if ((*(_DWORD *)(v13 - 10) & 0x80000000) != 0)
          {
            v14 = *(v13 - 11);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(_DWORD *)(a1 + 36);
            if (v17 == 0x7FFFFFFF)
            {
              v17 = *(_DWORD *)(a1 + 32);
              v18 = v17;
              if (v17 == (_DWORD)v15)
              {
                re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 168 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 168 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 168 * v17 + 8) = v20 | 0x80000000;
            v21 = *(_QWORD *)(a1 + 16) + 168 * v17;
            *(_DWORD *)(v21 + 8) = *(_DWORD *)(v21 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 168 * v17) = v14;
            v22 = *(_QWORD *)(a1 + 16) + 168 * v17;
            re::DynamicString::DynamicString((re::DynamicString *)(v22 + 16), (const re::DynamicString *)(v13 - 9));
            re::DynamicArray<BOOL>::DynamicArray(v22 + 48, v13 - 5);
            re::DynamicArray<BOOL>::DynamicArray(v22 + 88, v13);
            re::DynamicString::DynamicString((re::DynamicString *)(v22 + 128), (const re::DynamicString *)(v13 + 5));
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 168 * v17 + 160) = v13[9];
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 21;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::deinit((uint64_t *)v24);
    }
  }
  else
  {
    if (a2)
      v23 = a2;
    else
      v23 = 3;
  }
}

void re::HashTable<re::AssetLoadDescriptor,unsigned long long,re::Hash<re::AssetLoadDescriptor>,re::EqualTo<re::AssetLoadDescriptor>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 168 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_155, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::NetworkSendBlockingAssetLoadRequestManager::registerECSSendBlockingAssetLoadRequest(uint64_t a1, uint64_t *a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (*(_BYTE *)(a1 + 8))
  {
    v4 = (os_unfair_lock_s *)(a1 + 64);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
    v5 = *a2;
    v6 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
    v7 = (0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31);
    v8 = *(unsigned int *)(a1 + 96);
    if ((_DWORD)v8)
    {
      v9 = v7 % v8;
      v10 = *(unsigned int *)(*(_QWORD *)(a1 + 80) + 4 * (v7 % v8));
      if ((_DWORD)v10 != 0x7FFFFFFF)
      {
        v11 = *(_QWORD *)(a1 + 88);
        if (*(_QWORD *)(v11 + 24 * v10 + 16) == v5)
        {
LABEL_11:
          os_unfair_lock_unlock(v4);
          return;
        }
        while (1)
        {
          LODWORD(v10) = *(_DWORD *)(v11 + 24 * v10 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v10 == 0x7FFFFFFF)
            break;
          if (*(_QWORD *)(v11 + 24 * v10 + 16) == v5)
            goto LABEL_11;
        }
      }
    }
    else
    {
      LODWORD(v9) = 0;
    }
    re::HashSetBase<re::SharedPtr<re::AssetLoadRequest>,re::SharedPtr<re::AssetLoadRequest>,re::internal::ValueAsKey<re::SharedPtr<re::AssetLoadRequest>>,re::Hash<re::SharedPtr<re::AssetLoadRequest>>,re::EqualTo<re::SharedPtr<re::AssetLoadRequest>>,true,false>::addAsMove(a1 + 72, v9, v7, a2);
    ++*(_DWORD *)(a1 + 112);
    goto LABEL_11;
  }
}

void re::NetworkSendBlockingAssetLoadRequestManager::clearECSSendBlockingAssetLoadRequests(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;

  v2 = this + 16;
  os_unfair_lock_lock(this + 16);
  re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::clear((uint64_t)&this[18]);
  os_unfair_lock_unlock(v2);
}

double re::NetworkSendBlockingAssetLoadRequestManager::flushAndWaitForECSSendBlockingAssetLoadRequests(os_unfair_lock_s *this)
{
  uint64_t *v1;
  os_unfair_lock_s *v2;
  int v3;
  uint64_t v4;
  int *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  os_unfair_lock_s *v13;
  uint64_t v14;
  re *v15;
  NSObject *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  char *v21;
  re *v22;
  NSObject *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  char *v28;
  int v29;
  int v30;
  _BYTE v32[16];
  __int128 v33;
  uint64_t v34;
  __int128 v35;
  int v36;
  uint8_t buf[24];
  __int128 v38;
  int v39;
  uint64_t v40;

  v1 = (uint64_t *)this;
  v40 = *MEMORY[0x24BDAC8D0];
  v36 = 0;
  v2 = this + 16;
  os_unfair_lock_lock(this + 16);
  v1 += 9;
  v39 = 0;
  memset(buf, 0, sizeof(buf));
  v33 = 0u;
  v34 = 0;
  v38 = xmmword_2260F5A80;
  v35 = xmmword_2260F5A80;
  re::HashSetBase<re::SharedPtr<re::AssetLoadRequest>,re::SharedPtr<re::AssetLoadRequest>,re::internal::ValueAsKey<re::SharedPtr<re::AssetLoadRequest>>,re::Hash<re::SharedPtr<re::AssetLoadRequest>>,re::EqualTo<re::SharedPtr<re::AssetLoadRequest>>,true,false>::operator=((uint64_t)&v33, v1);
  re::HashSetBase<re::SharedPtr<re::AssetLoadRequest>,re::SharedPtr<re::AssetLoadRequest>,re::internal::ValueAsKey<re::SharedPtr<re::AssetLoadRequest>>,re::Hash<re::SharedPtr<re::AssetLoadRequest>>,re::EqualTo<re::SharedPtr<re::AssetLoadRequest>>,true,false>::operator=((uint64_t)v1, (uint64_t *)buf);
  re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit((uint64_t *)buf);
  os_unfair_lock_unlock(v2);
  v3 = DWORD2(v35);
  if (DWORD2(v35))
  {
    v4 = 0;
    v5 = (int *)(v34 + 8);
    while (1)
    {
      v6 = *v5;
      v5 += 6;
      if (v6 < 0)
        break;
      if (DWORD2(v35) == ++v4)
      {
        LODWORD(v4) = DWORD2(v35);
        break;
      }
    }
  }
  else
  {
    LODWORD(v4) = 0;
  }
  if (DWORD2(v35) != (_DWORD)v4)
  {
    v7 = v4;
    v8 = v34;
    do
    {
      v9 = v8 + 24 * v7;
      v11 = *(_QWORD *)(v9 + 16);
      v10 = v9 + 16;
      re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v32, 2074, v11);
      v12 = *(_QWORD *)(*(_QWORD *)v10 + 24);
      v13 = (os_unfair_lock_s *)(v12 + 192);
      os_unfair_lock_lock((os_unfair_lock_t)(v12 + 192));
      v14 = *(_QWORD *)(v12 + 216);
      os_unfair_lock_unlock(v13);
      if (v14)
      {
        v16 = *re::assetsLogObjects(v15);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          v17 = *(_QWORD **)(*(_QWORD *)v10 + 24);
          v18 = v17[11];
          v19 = v17[13];
          v20 = (char *)v17[14];
          v21 = (char *)v17 + 105;
          if ((v19 & 1) != 0)
            v21 = v20;
          *(_DWORD *)buf = 134218498;
          *(_QWORD *)&buf[4] = v18;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v21;
          *(_WORD *)&buf[22] = 2048;
          *(_QWORD *)&v38 = v14;
          _os_log_impl(&dword_224FE9000, v16, OS_LOG_TYPE_DEFAULT, "Waiting for ECS send blocking AssetLoadRequest with first assetId %llu (%s) to complete loading %zu remaining assets", buf, 0x20u);
        }
        re::AssetLoadRequest::Data::waitForCompletion(*(_QWORD *)(*(_QWORD *)v10 + 24), 0);
        v23 = *re::assetsLogObjects(v22);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          v24 = *(_QWORD **)(*(_QWORD *)v10 + 24);
          v25 = v24[11];
          v26 = v24[13];
          v27 = (char *)v24[14];
          v28 = (char *)v24 + 105;
          if ((v26 & 1) != 0)
            v28 = v27;
          *(_DWORD *)buf = 134218242;
          *(_QWORD *)&buf[4] = v25;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v28;
          _os_log_impl(&dword_224FE9000, v23, OS_LOG_TYPE_DEFAULT, "Completed waiting for ECS send blocking AssetLoadRequest with first assetId %llu (%s).", buf, 0x16u);
        }
      }
      else
      {
        re::AssetLoadRequest::Data::waitForCompletion(*(_QWORD *)(*(_QWORD *)v10 + 24), 0);
      }
      re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v32);
      v8 = v34;
      if (DWORD2(v35) <= (v4 + 1))
        v29 = v4 + 1;
      else
        v29 = DWORD2(v35);
      while (1)
      {
        v7 = (v4 + 1);
        if (v29 - 1 == (_DWORD)v4)
          break;
        LODWORD(v4) = v4 + 1;
        v30 = v7;
        if ((*(_DWORD *)(v34 + 24 * v7 + 8) & 0x80000000) != 0)
          goto LABEL_26;
      }
      v30 = v29;
LABEL_26:
      LODWORD(v4) = v30;
    }
    while (v3 != v30);
  }
  return re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit((uint64_t *)&v33);
}

uint64_t re::NetworkSendBlockingAssetLoadRequestManager::setIsListeningForECSSendBlockingAssetLoadRequests(uint64_t this)
{
  *(_BYTE *)(this + 8) = 1;
  return this;
}

void re::HashSetBase<re::SharedPtr<re::AssetLoadRequest>,re::SharedPtr<re::AssetLoadRequest>,re::internal::ValueAsKey<re::SharedPtr<re::AssetLoadRequest>>,re::Hash<re::SharedPtr<re::AssetLoadRequest>>,re::EqualTo<re::SharedPtr<re::AssetLoadRequest>>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;

  v7 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v7 == 0x7FFFFFFF)
  {
    v7 = *(unsigned int *)(a1 + 32);
    v8 = v7;
    if ((_DWORD)v7 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::SharedPtr<re::AssetLoadRequest>,re::SharedPtr<re::AssetLoadRequest>,re::internal::ValueAsKey<re::SharedPtr<re::AssetLoadRequest>>,re::Hash<re::SharedPtr<re::AssetLoadRequest>>,re::EqualTo<re::SharedPtr<re::AssetLoadRequest>>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v8 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v8 + 1;
    v9 = *(_QWORD *)(a1 + 16);
    v10 = *(_DWORD *)(v9 + 24 * v7 + 8);
  }
  else
  {
    v9 = *(_QWORD *)(a1 + 16);
    v10 = *(_DWORD *)(v9 + 24 * v7 + 8);
    *(_DWORD *)(a1 + 36) = v10 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v9 + 24 * v7 + 8) = v10 | 0x80000000;
  v11 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v7 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v7 + 8) & 0x80000000 | *(_DWORD *)(v11 + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v7) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v7 + 16) = *a4;
  *a4 = 0;
  *(_DWORD *)(v11 + 4 * a2) = v7;
  ++*(_DWORD *)(a1 + 28);
}

void re::HashSetBase<re::SharedPtr<re::AssetLoadRequest>,re::SharedPtr<re::AssetLoadRequest>,re::internal::ValueAsKey<re::SharedPtr<re::AssetLoadRequest>>,re::Hash<re::SharedPtr<re::AssetLoadRequest>>,re::EqualTo<re::SharedPtr<re::AssetLoadRequest>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  signed int v13;
  _BYTE v14[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v14, 0, 36);
      *(_QWORD *)&v14[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::init((uint64_t)v14, v4, a2);
      v5 = *(_OWORD *)v14;
      *(_OWORD *)v14 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v14[16];
      v7 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)&v14[16] = v7;
      *(_QWORD *)(a1 + 16) = v6;
      v9 = *(_OWORD *)&v14[24];
      *(_OWORD *)&v14[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v14[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = 0;
        v12 = v7 + 16;
        do
        {
          if ((*(_DWORD *)(v12 - 8) & 0x80000000) != 0)
            re::HashSetBase<re::SharedPtr<re::AssetLoadRequest>,re::SharedPtr<re::AssetLoadRequest>,re::internal::ValueAsKey<re::SharedPtr<re::AssetLoadRequest>>,re::Hash<re::SharedPtr<re::AssetLoadRequest>>,re::EqualTo<re::SharedPtr<re::AssetLoadRequest>>,true,false>::addAsMove(a1, *(_QWORD *)(v12 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v12 - 16), v12);
          ++v11;
          v12 += 24;
        }
        while (v11 < v10);
      }
      re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::deinit((uint64_t *)v14);
    }
  }
  else
  {
    if (a2)
      v13 = a2;
    else
      v13 = 3;
  }
}

uint64_t re::HashSetBase<re::SharedPtr<re::AssetLoadRequest>,re::SharedPtr<re::AssetLoadRequest>,re::internal::ValueAsKey<re::SharedPtr<re::AssetLoadRequest>>,re::Hash<re::SharedPtr<re::AssetLoadRequest>>,re::EqualTo<re::SharedPtr<re::AssetLoadRequest>>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t i;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  unint64_t v22;
  id v23;

  if ((uint64_t *)a1 != a2)
  {
    v4 = *(_QWORD *)a1;
    v5 = *a2;
    if (*(_QWORD *)a1)
      v6 = v4 == v5;
    else
      v6 = 1;
    if (v6)
    {
      *(_QWORD *)a1 = v5;
      *a2 = v4;
      v7 = *(_QWORD *)(a1 + 8);
      *(_QWORD *)(a1 + 8) = a2[1];
      a2[1] = v7;
      v8 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = a2[2];
      a2[2] = v8;
      LODWORD(v8) = *(_DWORD *)(a1 + 24);
      *(_DWORD *)(a1 + 24) = *((_DWORD *)a2 + 6);
      *((_DWORD *)a2 + 6) = v8;
      LODWORD(v8) = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(a1 + 28) = *((_DWORD *)a2 + 7);
      *((_DWORD *)a2 + 7) = v8;
      LODWORD(v8) = *(_DWORD *)(a1 + 32);
      *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
      *((_DWORD *)a2 + 8) = v8;
      LODWORD(v8) = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 9);
      *((_DWORD *)a2 + 9) = v8;
    }
    else
    {
      re::HashSetBase<re::SharedPtr<re::AnimationEventDelegate>,re::SharedPtr<re::AnimationEventDelegate>,re::internal::ValueAsKey<re::SharedPtr<re::AnimationEventDelegate>>,re::Hash<re::SharedPtr<re::AnimationEventDelegate>>,re::EqualTo<re::SharedPtr<re::AnimationEventDelegate>>,true,false>::clear(a1);
      if (v5)
      {
        v9 = *((_DWORD *)a2 + 7);
        if (*(_DWORD *)(a1 + 24) < v9)
          re::HashSetBase<re::SharedPtr<re::AssetLoadRequest>,re::SharedPtr<re::AssetLoadRequest>,re::internal::ValueAsKey<re::SharedPtr<re::AssetLoadRequest>>,re::Hash<re::SharedPtr<re::AssetLoadRequest>>,re::EqualTo<re::SharedPtr<re::AssetLoadRequest>>,true,false>::setCapacity(a1, v9);
        v10 = *((unsigned int *)a2 + 8);
        if ((_DWORD)v10)
        {
          v11 = 0;
          for (i = 0; i < v10; ++i)
          {
            v13 = (unint64_t *)(a2[2] + v11);
            if ((v13[1] & 0x80000000) != 0)
            {
              v14 = *v13;
              v15 = *(unsigned int *)(a1 + 24);
              v16 = *v13 % v15;
              v17 = *(unsigned int *)(a1 + 36);
              if ((_DWORD)v17 == 0x7FFFFFFF)
              {
                v17 = *(unsigned int *)(a1 + 32);
                v18 = v17;
                if ((_DWORD)v17 == (_DWORD)v15)
                {
                  re::HashSetBase<re::SharedPtr<re::AssetLoadRequest>,re::SharedPtr<re::AssetLoadRequest>,re::internal::ValueAsKey<re::SharedPtr<re::AssetLoadRequest>>,re::Hash<re::SharedPtr<re::AssetLoadRequest>>,re::EqualTo<re::SharedPtr<re::AssetLoadRequest>>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
                  v16 = v14 % *(unsigned int *)(a1 + 24);
                  v18 = *(_DWORD *)(a1 + 32);
                }
                *(_DWORD *)(a1 + 32) = v18 + 1;
                v19 = *(_QWORD *)(a1 + 16);
                v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
              }
              else
              {
                v19 = *(_QWORD *)(a1 + 16);
                v20 = *(_DWORD *)(v19 + 24 * v17 + 8);
                *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
              }
              *(_DWORD *)(v19 + 24 * v17 + 8) = v20 | 0x80000000;
              v21 = *(_QWORD *)(a1 + 8);
              *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 8) & 0x80000000 | *(_DWORD *)(v21 + 4 * v16);
              *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17) = v14;
              v22 = v13[2];
              *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v17 + 16) = v22;
              if (v22)
              {
                v23 = (id)(v22 + 8);
                v21 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(v21 + 4 * v16) = v17;
              ++*(_DWORD *)(a1 + 28);
              v10 = *((unsigned int *)a2 + 8);
            }
            v11 += 24;
          }
        }
        ++*(_DWORD *)(a1 + 40);
      }
    }
  }
  return a1;
}

void re::internal::ResourceRequestQueue::enqueue(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 24));
  re::DynamicArray<void({block_pointer} {__strong})(void)>::add((_anonymous_namespace_ *)(a1 + 32), (const void **)&v3);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 24));
  atomic_store(1u, (unsigned __int8 *)(a1 + 72));

}

void *re::DynamicArray<void({block_pointer} {__strong})(void)>::add(_anonymous_namespace_ *this, const void **a2)
{
  unint64_t v4;
  uint64_t v5;
  void *result;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<void({block_pointer} {__strong})(void)>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4);
  result = _Block_copy(*a2);
  *(_QWORD *)(v5 + 8 * v4) = result;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

void re::internal::ResourceRequestQueue::flushAsync(uint64_t a1, dispatch_queue_t *a2)
{
  void *v3;
  _QWORD v4[4];
  id v5;
  id location;

  if (a1)
    v3 = (void *)(a1 + 8);
  else
    v3 = 0;
  objc_initWeak(&location, v3);
  v4[0] = MEMORY[0x24BDAC760];
  v4[1] = 3321888768;
  v4[2] = ___ZN2re8internal20ResourceRequestQueue10flushAsyncERKNS_8dispatch5QueueE_block_invoke;
  v4[3] = &__block_descriptor_40_a8_32c58_ZTSN2re10ArcWeakPtrINS_8internal20ResourceRequestQueueEEE_e5_v8__0l;
  v5 = 0;
  objc_copyWeak(&v5, &location);
  dispatch_async(*a2, v4);
  objc_destroyWeak(&v5);
  v5 = 0;
  objc_destroyWeak(&location);
}

void ___ZN2re8internal20ResourceRequestQueue10flushAsyncERKNS_8dispatch5QueueE_block_invoke(uint64_t a1)
{
  id WeakRetained;
  void *v2;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    v2 = WeakRetained;
    re::internal::ResourceRequestQueue::flushSync((dispatch_time_t)WeakRetained - 8, 0xFFFFFFFFFFFFFFFFLL);

  }
}

dispatch_time_t re::internal::ResourceRequestQueue::flushSync(dispatch_time_t this, dispatch_time_t a2)
{
  unsigned __int8 v2;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  const void **v7;
  unint64_t v8;
  void (**v9)(void);
  unint64_t v10;
  _QWORD v11[3];
  int v12;
  const void **v13;

  v2 = atomic_load((unsigned __int8 *)(this + 72));
  if ((v2 & 1) != 0)
  {
    v4 = this;
    if (a2 == -1 || (this = dispatch_time(0, 0), this < a2))
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v4 + 24));
      v5 = *(_QWORD *)(v4 + 40);
      v6 = *(_QWORD *)(v4 + 48);
      v11[0] = *(_QWORD *)(v4 + 32);
      v11[1] = v5;
      v11[2] = v6;
      *(_QWORD *)(v4 + 32) = 0;
      *(_QWORD *)(v4 + 40) = 0;
      *(_QWORD *)(v4 + 48) = 0;
      v7 = *(const void ***)(v4 + 64);
      v13 = v7;
      *(_QWORD *)(v4 + 64) = 0;
      ++*(_DWORD *)(v4 + 56);
      v12 = 1;
      atomic_store(0, (unsigned __int8 *)(v4 + 72));
      os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 24));
      if (v6)
      {
        v8 = 0;
        while (a2 == -1 || dispatch_time(0, 0) < a2)
        {
          v9 = (void (**)(void))*v7++;
          v9[2]();
          if (v6 == ++v8)
            return re::DynamicArray<re::ObjCObject>::deinit((uint64_t)v11);
        }
        os_unfair_lock_lock((os_unfair_lock_t)(v4 + 24));
        v10 = v6 - v8;
        if (v6 > v8)
        {
          do
          {
            re::DynamicArray<void({block_pointer} {__strong})(void)>::add((_anonymous_namespace_ *)(v4 + 32), v7++);
            --v10;
          }
          while (v10);
        }
        atomic_store(1u, (unsigned __int8 *)(v4 + 72));
        os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 24));
      }
      return re::DynamicArray<re::ObjCObject>::deinit((uint64_t)v11);
    }
  }
  return this;
}

void __copy_helper_block_a8_32c58_ZTSN2re10ArcWeakPtrINS_8internal20ResourceRequestQueueEEE(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 32) = 0;
  objc_copyWeak((id *)(a1 + 32), (id *)(a2 + 32));
}

void __destroy_helper_block_a8_32c58_ZTSN2re10ArcWeakPtrINS_8internal20ResourceRequestQueueEEE(uint64_t a1)
{
  objc_destroyWeak((id *)(a1 + 32));
  *(_QWORD *)(a1 + 32) = 0;
}

_QWORD *re::DynamicArray<void({block_pointer} {__strong})(void)>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<void({block_pointer} {__strong})(void)>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<void({block_pointer} {__strong})(void)>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<void({block_pointer} {__strong})(void)>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  void **v7;
  const void **v8;
  uint64_t v9;
  uint64_t v10;
  void **v11;
  void *v12;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<void({block_pointer} {__strong})(void)>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v7 = (void **)result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (const void **)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 8 * v9;
        v11 = v7;
        do
        {
          *v11++ = _Block_copy(*v8);
          v12 = (void *)*v8++;

          v10 -= 8;
        }
        while (v10);
        v8 = (const void **)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, const void **))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

BOOL ends_with(_QWORD *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  _BOOL8 v5;
  char *v6;
  uint64_t v7;
  __darwin_ct_rune_t v8;
  __darwin_ct_rune_t v9;

  v3 = a2[1];
  v4 = a1[1];
  if (v3 + a3 > v4)
    return 0;
  v6 = (char *)(*a1 + ~a3 + v4);
  v7 = *a2 - 1;
  do
  {
    v5 = v3 == 0;
    if (!v3)
      break;
    v8 = *v6--;
    v9 = __tolower(*(char *)(v7 + v3--));
  }
  while (v9 == __tolower(v8));
  return v5;
}

void file_seek(FILE *a1, uint64_t a2, int a3)
{
  fseek(a1, a2, a3);
  JUMPOUT(0x227693B80);
}

size_t file_read(FILE *__stream, void *__ptr, size_t a3)
{
  return fread(__ptr, 1uLL, a3, __stream);
}

size_t file_write(FILE *__stream, const void *__ptr, size_t a3)
{
  return fwrite(__ptr, 1uLL, a3, __stream);
}

uint64_t file_close(FILE *a1)
{
  fflush(a1);
  return fclose(a1);
}

BOOL file_swap(FILE *a1, FILE *a2)
{
  int v3;
  int v4;
  char v6[1024];
  char v7[1024];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v3 = fileno(a1);
  if (fcntl(v3, 50, v7))
    return 0;
  v4 = fileno(a2);
  return !fcntl(v4, 50, v6) && renamex_np(v7, v6, 2u) == 0;
}

uint64_t _collect_paths(const char *a1, const char *a2, uint64_t *a3)
{
  uint64_t v6;
  int v8;
  size_t v9;
  size_t v10;
  char v11;
  std::string *v12;
  size_t v13;
  std::string *v14;
  unint64_t v15;
  unint64_t v16;
  __int128 v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  int v37;
  unint64_t v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  int v42;
  DIR *v43;
  DIR *v44;
  dirent *v45;
  dirent *v46;
  const char *d_name;
  int v48;
  std::string::size_type size;
  size_t v50;
  std::string *v51;
  int v52;
  std::string::value_type v53;
  std::string v54;
  void *__p[2];
  uint64_t v56;
  char v57;
  std::string v58;
  std::string __str;
  stat v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t *v65;

  if (stat(a2, &v60))
    return 0;
  v8 = v60.st_mode & 0xF000;
  if (v8 != 0x8000 && v8 != 0x4000)
    return 0;
  memset(&__str, 0, sizeof(__str));
  v9 = strlen(a2);
  std::string::reserve(&__str, v9 + 1);
  MEMORY[0x227692F50](&__str, a2);
  if (v8 != 0x8000)
  {
    std::string::append(&__str, 1uLL, 47);
    v13 = strlen(a1);
    std::string::basic_string(&v58, &__str, v13 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v54);
    if ((*((_BYTE *)&v58.__r_.__value_.__s + 23) & 0x80) != 0)
    {
      if (!v58.__r_.__value_.__l.__size_)
        goto LABEL_57;
      if (v58.__r_.__value_.__l.__size_ != 1)
        goto LABEL_25;
      v14 = (std::string *)v58.__r_.__value_.__r.__words[0];
    }
    else
    {
      if (!*((_BYTE *)&v58.__r_.__value_.__s + 23))
        goto LABEL_57;
      if (HIBYTE(v58.__r_.__value_.__r.__words[2]) != 1)
      {
LABEL_25:
        v53 = 0;
        _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES8_bEEC2B8nn180100IJLm0ELm1ELm2EEJS8_S8_bEJEJEJRS8_SB_bEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSD_IJDpT2_EEEDpOT3_(&v54, (__int128 *)&__str, (__int128 *)&v58, &v53);
        v19 = a3[2];
        v20 = a3[1];
        if (v20 >= v19)
        {
          v28 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v20 - *a3) >> 3);
          v29 = v28 + 1;
          if ((unint64_t)(v28 + 1) > 0x492492492492492)
            goto LABEL_79;
          v30 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v19 - *a3) >> 3);
          if (2 * v30 > v29)
            v29 = 2 * v30;
          if (v30 >= 0x249249249249249)
            v31 = 0x492492492492492;
          else
            v31 = v29;
          v65 = a3 + 2;
          if (v31)
            v31 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::tuple<std::string,std::string,BOOL>>>(v31);
          else
            v32 = 0;
          v38 = v31 + 56 * v28;
          v61 = v31;
          v62 = v38;
          v64 = v31 + 56 * v32;
          v39 = *(_OWORD *)&v54.__r_.__value_.__l.__data_;
          *(_QWORD *)(v38 + 16) = *((_QWORD *)&v54.__r_.__value_.__l + 2);
          *(_OWORD *)v38 = v39;
          memset(&v54, 0, sizeof(v54));
          v40 = *(_OWORD *)__p;
          *(_QWORD *)(v38 + 40) = v56;
          *(_OWORD *)(v38 + 24) = v40;
          __p[1] = 0;
          v56 = 0;
          __p[0] = 0;
          *(_BYTE *)(v38 + 48) = v57;
          v63 = v38 + 56;
          std::vector<std::tuple<std::string,std::string,BOOL>>::__swap_out_circular_buffer(a3, &v61);
          v41 = a3[1];
          std::__split_buffer<std::tuple<std::string,std::string,BOOL>>::~__split_buffer((uint64_t)&v61);
          v42 = SHIBYTE(v56);
          a3[1] = v41;
          if (v42 < 0)
            operator delete(__p[0]);
        }
        else
        {
          v21 = *(_OWORD *)&v54.__r_.__value_.__l.__data_;
          *(_QWORD *)(v20 + 16) = *((_QWORD *)&v54.__r_.__value_.__l + 2);
          *(_OWORD *)v20 = v21;
          *(_OWORD *)&v54.__r_.__value_.__l.__data_ = 0uLL;
          v22 = v56;
          *(_OWORD *)(v20 + 24) = *(_OWORD *)__p;
          *(_QWORD *)(v20 + 40) = v22;
          v54.__r_.__value_.__r.__words[2] = 0;
          __p[0] = 0;
          __p[1] = 0;
          v56 = 0;
          *(_BYTE *)(v20 + 48) = v57;
          a3[1] = v20 + 56;
        }
        if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v54.__r_.__value_.__l.__data_);
LABEL_57:
        v43 = opendir(a2);
        if (v43)
        {
          v44 = v43;
          v45 = readdir(v43);
          if (v45)
          {
            v46 = v45;
            while (1)
            {
              v48 = v46->d_name[0];
              d_name = v46->d_name;
              if (v48 != 46)
              {
                memset(&v54, 0, sizeof(v54));
                if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                  size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
                else
                  size = __str.__r_.__value_.__l.__size_;
                v50 = strlen(d_name);
                std::string::reserve(&v54, size + v50);
                std::string::operator=(&v54, &__str);
                std::string::append(&v54, d_name);
                if ((v54.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                  v51 = &v54;
                else
                  v51 = (std::string *)v54.__r_.__value_.__r.__words[0];
                v52 = _collect_paths(a1, v51, a3);
                if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v54.__r_.__value_.__l.__data_);
                if (!v52)
                  break;
              }
              v46 = readdir(v44);
              if (!v46)
                goto LABEL_71;
            }
            v6 = 0;
          }
          else
          {
LABEL_71:
            v6 = 1;
          }
          closedir(v44);
        }
        else
        {
          v6 = 0;
        }
        if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v58.__r_.__value_.__l.__data_);
        goto LABEL_77;
      }
      v14 = &v58;
    }
    if (v14->__r_.__value_.__s.__data_[0] == 47)
      goto LABEL_57;
    goto LABEL_25;
  }
  v10 = strlen(a1);
  std::string::basic_string(&v58, &__str, v10 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v54);
  v11 = HIBYTE(v58.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(v58.__r_.__value_.__r.__words[2]) < 0)
  {
    if (!v58.__r_.__value_.__l.__size_)
    {
LABEL_50:
      operator delete(v58.__r_.__value_.__l.__data_);
      goto LABEL_51;
    }
    if (v58.__r_.__value_.__l.__size_ != 1)
      goto LABEL_19;
    v12 = (std::string *)v58.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((_BYTE *)&v58.__r_.__value_.__s + 23))
      goto LABEL_51;
    if (HIBYTE(v58.__r_.__value_.__r.__words[2]) != 1)
      goto LABEL_19;
    v12 = &v58;
  }
  if (v12->__r_.__value_.__s.__data_[0] == 47)
    goto LABEL_49;
LABEL_19:
  v53 = 1;
  _ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES8_bEEC2B8nn180100IJLm0ELm1ELm2EEJS8_S8_bEJEJEJRS8_SB_bEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSD_IJDpT2_EEEDpOT3_(&v54, (__int128 *)&__str, (__int128 *)&v58, &v53);
  v15 = a3[2];
  v16 = a3[1];
  if (v16 >= v15)
  {
    v23 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v16 - *a3) >> 3);
    v24 = v23 + 1;
    if ((unint64_t)(v23 + 1) <= 0x492492492492492)
    {
      v25 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v15 - *a3) >> 3);
      if (2 * v25 > v24)
        v24 = 2 * v25;
      if (v25 >= 0x249249249249249)
        v26 = 0x492492492492492;
      else
        v26 = v24;
      v65 = a3 + 2;
      if (v26)
        v26 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::tuple<std::string,std::string,BOOL>>>(v26);
      else
        v27 = 0;
      v33 = v26 + 56 * v23;
      v61 = v26;
      v62 = v33;
      v64 = v26 + 56 * v27;
      v34 = *(_OWORD *)&v54.__r_.__value_.__l.__data_;
      *(_QWORD *)(v33 + 16) = *((_QWORD *)&v54.__r_.__value_.__l + 2);
      *(_OWORD *)v33 = v34;
      memset(&v54, 0, sizeof(v54));
      v35 = *(_OWORD *)__p;
      *(_QWORD *)(v33 + 40) = v56;
      *(_OWORD *)(v33 + 24) = v35;
      __p[1] = 0;
      v56 = 0;
      __p[0] = 0;
      *(_BYTE *)(v33 + 48) = v57;
      v63 = v33 + 56;
      std::vector<std::tuple<std::string,std::string,BOOL>>::__swap_out_circular_buffer(a3, &v61);
      v36 = a3[1];
      std::__split_buffer<std::tuple<std::string,std::string,BOOL>>::~__split_buffer((uint64_t)&v61);
      v37 = SHIBYTE(v56);
      a3[1] = v36;
      if (v37 < 0)
        operator delete(__p[0]);
      goto LABEL_46;
    }
LABEL_79:
    abort();
  }
  v17 = *(_OWORD *)&v54.__r_.__value_.__l.__data_;
  *(_QWORD *)(v16 + 16) = *((_QWORD *)&v54.__r_.__value_.__l + 2);
  *(_OWORD *)v16 = v17;
  *(_OWORD *)&v54.__r_.__value_.__l.__data_ = 0uLL;
  v18 = v56;
  *(_OWORD *)(v16 + 24) = *(_OWORD *)__p;
  *(_QWORD *)(v16 + 40) = v18;
  v54.__r_.__value_.__r.__words[2] = 0;
  __p[0] = 0;
  __p[1] = 0;
  v56 = 0;
  *(_BYTE *)(v16 + 48) = v57;
  a3[1] = v16 + 56;
LABEL_46:
  if (SHIBYTE(v54.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v54.__r_.__value_.__l.__data_);
  v11 = HIBYTE(v58.__r_.__value_.__r.__words[2]);
LABEL_49:
  if (v11 < 0)
    goto LABEL_50;
LABEL_51:
  v6 = 1;
LABEL_77:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  return v6;
}

BOOL _collect_paths(char *a1, uint64_t *a2)
{
  int v5;
  BOOL v6;
  std::string *v7;
  char *v8;
  unint64_t v9;
  unint64_t v10;
  __int128 v11;
  std::string::size_type v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  int v22;
  std::string v23;
  BOOL v24;
  void *v25[2];
  uint64_t v26;
  std::string __p;
  BOOL v28;
  std::string v29;
  stat v30;
  _QWORD v31[5];

  if (stat(a1, &v30))
    return 0;
  v5 = v30.st_mode & 0xF000;
  v6 = v5 == 0x8000;
  if (v5 == 0x8000)
  {
    std::string::basic_string[abi:nn180100]<0>(&v29, a1);
    if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v7 = &v29;
    else
      v7 = (std::string *)v29.__r_.__value_.__r.__words[0];
    v8 = basename((char *)v7);
    MEMORY[0x227692F50](&v29, v8);
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
      std::string::__init_copy_ctor_external(&v23, v29.__r_.__value_.__l.__data_, v29.__r_.__value_.__l.__size_);
    else
      v23 = v29;
    v24 = v6;
    std::string::basic_string[abi:nn180100]<0>(v25, a1);
    __p = v23;
    memset(&v23, 0, sizeof(v23));
    v28 = v24;
    v9 = a2[2];
    v10 = a2[1];
    if (v10 >= v9)
    {
      v13 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v10 - *a2) >> 3);
      v14 = v13 + 1;
      if ((unint64_t)(v13 + 1) > 0x492492492492492)
        abort();
      v15 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v9 - *a2) >> 3);
      if (2 * v15 > v14)
        v14 = 2 * v15;
      if (v15 >= 0x249249249249249)
        v16 = 0x492492492492492;
      else
        v16 = v14;
      v31[4] = a2 + 2;
      if (v16)
        v16 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::tuple<std::string,std::string,BOOL>>>(v16);
      else
        v17 = 0;
      v18 = v16 + 56 * v13;
      v31[0] = v16;
      v31[1] = v18;
      v31[3] = v16 + 56 * v17;
      v19 = *(_OWORD *)v25;
      *(_QWORD *)(v18 + 16) = v26;
      *(_OWORD *)v18 = v19;
      v25[1] = 0;
      v26 = 0;
      v25[0] = 0;
      v20 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(_QWORD *)(v18 + 40) = *((_QWORD *)&__p.__r_.__value_.__l + 2);
      *(_OWORD *)(v18 + 24) = v20;
      memset(&__p, 0, sizeof(__p));
      *(_BYTE *)(v18 + 48) = v28;
      v31[2] = v18 + 56;
      std::vector<std::tuple<std::string,std::string,BOOL>>::__swap_out_circular_buffer(a2, v31);
      v21 = a2[1];
      std::__split_buffer<std::tuple<std::string,std::string,BOOL>>::~__split_buffer((uint64_t)v31);
      v22 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
      a2[1] = v21;
      if (v22 < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
    }
    else
    {
      v11 = *(_OWORD *)v25;
      *(_QWORD *)(v10 + 16) = v26;
      *(_OWORD *)v10 = v11;
      v25[1] = 0;
      v26 = 0;
      v25[0] = 0;
      v12 = __p.__r_.__value_.__r.__words[2];
      *(_OWORD *)(v10 + 24) = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
      *(_QWORD *)(v10 + 40) = v12;
      memset(&__p, 0, sizeof(__p));
      *(_BYTE *)(v10 + 48) = v28;
      a2[1] = v10 + 56;
    }
    if (SHIBYTE(v26) < 0)
      operator delete(v25[0]);
    if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v23.__r_.__value_.__l.__data_);
    if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v29.__r_.__value_.__l.__data_);
    return 1;
  }
  return v5 == 0x4000 && (_collect_paths(a1, a1, a2) & 1) != 0;
}

std::string *_ZNSt3__112__tuple_implINS_15__tuple_indicesIJLm0ELm1ELm2EEEEJNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEES8_bEEC2B8nn180100IJLm0ELm1ELm2EEJS8_S8_bEJEJEJRS8_SB_bEEENS1_IJXspT_EEEENS_13__tuple_typesIJDpT0_EEENS1_IJXspT1_EEEENSD_IJDpT2_EEEDpOT3_(std::string *this, __int128 *a2, __int128 *a3, std::string::value_type *a4)
{
  __int128 v7;
  std::string *v8;
  __int128 v9;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v7 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v7;
  }
  v8 = this + 1;
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)a3, *((_QWORD *)a3 + 1));
  }
  else
  {
    v9 = *a3;
    this[1].__r_.__value_.__r.__words[2] = *((_QWORD *)a3 + 2);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
  this[2].__r_.__value_.__s.__data_[0] = *a4;
  return this;
}

uint64_t *std::vector<std::tuple<std::string,std::string,BOOL>>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *result;
  v3 = result[1];
  v4 = a2[1];
  if (v3 == *result)
  {
    v5 = a2[1];
  }
  else
  {
    do
    {
      v5 = v4 - 56;
      v6 = *(_OWORD *)(v3 - 56);
      *(_QWORD *)(v4 - 40) = *(_QWORD *)(v3 - 40);
      *(_OWORD *)(v4 - 56) = v6;
      *(_QWORD *)(v3 - 48) = 0;
      *(_QWORD *)(v3 - 40) = 0;
      *(_QWORD *)(v3 - 56) = 0;
      v7 = *(_OWORD *)(v3 - 32);
      *(_QWORD *)(v4 - 16) = *(_QWORD *)(v3 - 16);
      *(_OWORD *)(v4 - 32) = v7;
      *(_QWORD *)(v3 - 24) = 0;
      *(_QWORD *)(v3 - 16) = 0;
      *(_QWORD *)(v3 - 32) = 0;
      *(_BYTE *)(v4 - 8) = *(_BYTE *)(v3 - 8);
      v3 -= 56;
      v4 -= 56;
    }
    while (v3 != v2);
  }
  a2[1] = v5;
  v8 = *result;
  *result = v5;
  a2[1] = v8;
  v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::tuple<std::string,std::string,BOOL>>>(unint64_t a1)
{
  if (a1 >= 0x492492492492493)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(56 * a1);
}

uint64_t std::__split_buffer<std::tuple<std::string,std::string,BOOL>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 16) = i - 56;
    std::allocator<std::tuple<std::string,std::string,BOOL>>::destroy[abi:nn180100](v4, i - 56);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::allocator<std::tuple<std::string,std::string,BOOL>>::destroy[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 47) < 0)
    operator delete(*(void **)(a2 + 24));
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
}

uint64_t *re::allocInfo_ExternalResolverLoadDescriptorParameters(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_39);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_39))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FB708, 0);
    *(uint64_t *)((char *)&qword_2540FB718 + 6) = 0;
    qword_2540FB718 = 0;
    qword_2540FB728 = 0;
    qword_2540FB730 = 0xFFFFFFFFLL;
    qword_2540FB708 = (uint64_t)&off_24ED7DAA8;
    qword_2540FB738 = (uint64_t)"ExternalResolverLoadDescriptorParameters";
    dword_2540FB740 = 0;
    unk_2540FB748 = 0u;
    unk_2540FB758 = 0u;
    unk_2540FB768 = 0u;
    qword_2540FB778 = 0;
    __cxa_guard_release(&_MergedGlobals_39);
  }
  return &qword_2540FB708;
}

void re::initInfo_ExternalResolverLoadDescriptorParameters(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  __int128 v10;
  _QWORD v11[2];
  __int128 v12;

  v11[0] = 0x924A8B63D20795E0;
  v11[1] = "ExternalResolverLoadDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FB700);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FB700);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<re::DynamicString>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "assetKey";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FB6F8 = v9;
      __cxa_guard_release(&qword_2540FB700);
    }
  }
  *((_QWORD *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((_QWORD *)this + 8) = &qword_2540FB6F8;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::ExternalResolverLoadDescriptorParameters>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::ExternalResolverLoadDescriptorParameters>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::ExternalResolverLoadDescriptorParameters>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::ExternalResolverLoadDescriptorParameters>;
  re::IntrospectionRegistry::add(this, v3);
  v10 = v12;
}

_QWORD *re::internal::defaultConstruct<re::ExternalResolverLoadDescriptorParameters>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  return re::DynamicString::setCapacity((_QWORD *)a3, 0);
}

double re::internal::defaultDestruct<re::ExternalResolverLoadDescriptorParameters>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  double result;

  if (*a3)
  {
    if ((a3[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a3 + 40))(*a3, a3[2]);
    result = 0.0;
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
  }
  return result;
}

_QWORD *re::internal::defaultConstructV2<re::ExternalResolverLoadDescriptorParameters>(_anonymous_namespace_ *a1)
{
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  return re::DynamicString::setCapacity(a1, 0);
}

double re::internal::defaultDestructV2<re::ExternalResolverLoadDescriptorParameters>(uint64_t *a1)
{
  uint64_t v2;
  double result;

  v2 = *a1;
  if (v2)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

uint64_t re::ExternalResolverAssetProvider::ExternalResolverAssetProvider(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, __int128 *a5, char a6)
{
  _anonymous_namespace_ *v12;
  unsigned __int8 v13;
  __guard *v14;
  __int128 v15;
  int v17;
  _QWORD v18[2];

  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = off_24ED2CB18;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  re::DynamicString::setCapacity((_QWORD *)(a1 + 24), 0);
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  if ((v13 & 1) == 0)
  {
    if (v17)
    {
      re::introspect<re::ExternalResolverLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"ExternalResolverLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_ExternalResolverLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_ExternalResolverLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ExternalResolverLoadDescriptorParameters>, 0);
    }
  }
  re::ExternalResolverAssetProvider::s_loadDescriptorParametersIntrospect = v14[57];
  v18[0] = a2;
  v18[1] = strlen(a2);
  re::DynamicString::operator=((re::DynamicString *)(a1 + 24), (uint64_t)v18);
  *(_QWORD *)(a1 + 56) = a4;
  *(_QWORD *)(a1 + 64) = a3;
  v15 = *a5;
  *(_QWORD *)(a1 + 88) = *((_QWORD *)a5 + 2);
  *(_OWORD *)(a1 + 72) = v15;
  *(_BYTE *)(a1 + 96) = a6;
  return a1;
}

void re::ExternalResolverAssetProvider::~ExternalResolverAssetProvider(re::ExternalResolverAssetProvider *this)
{
  uint64_t v2;
  _OWORD *v3;

  v3 = (_OWORD *)((char *)this + 24);
  v2 = *((_QWORD *)this + 3);
  if (v2)
  {
    if ((*((_BYTE *)this + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 5));
    *v3 = 0u;
    v3[1] = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  uint64_t v2;
  _OWORD *v3;

  v3 = (_OWORD *)((char *)this + 24);
  v2 = *((_QWORD *)this + 3);
  if (v2)
  {
    if ((*((_BYTE *)this + 32) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 5));
    *v3 = 0u;
    v3[1] = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t *re::ExternalResolverAssetProvider::load@<X0>(re::ExternalResolverAssetProvider *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  const re::DynamicString *v9;
  _BOOL8 v10;
  char *v11;
  uint64_t v12;
  _anonymous_namespace_ *v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *result;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v9 = (re::ExternalResolverAssetProvider *)((char *)this + 24);
  v10 = re::DynamicString::operator!=((uint64_t)a2, (uint64_t)this + 24);
  if (v10)
  {
    if ((*((_BYTE *)a2 + 8) & 1) != 0)
      v11 = (char *)*((_QWORD *)a2 + 2);
    else
      v11 = (char *)a2 + 9;
    if ((*((_BYTE *)this + 32) & 1) != 0)
      v15 = (char *)*((_QWORD *)this + 5);
    else
      v15 = (char *)this + 33;
    result = (uint64_t *)re::DynamicString::format((re::DynamicString *)"Scheme %s does not match scheme %s.", (re::DynamicString *)&v31, v11, v15);
    v20 = v31;
    v21 = v32;
    v22 = v33;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v20;
    *(_QWORD *)(a4 + 24) = v21;
    *(_QWORD *)(a4 + 32) = v22;
  }
  else
  {
    v35 = 0;
    v36 = 0;
    v37 = 0;
    re::DynamicString::setCapacity(&v34, 0);
    v12 = re::AssetLoadDescriptor::getIntrospectableData<re::ExternalResolverLoadDescriptorParameters>(a2, &v34);
    if ((v12 & 1) != 0)
    {
      re::AssetProviderRegistry::getPathFromResolver(*((os_unfair_lock_s **)this + 11), v9, (const re::DynamicString *)&v34, (uint64_t)&v31);
      if ((_BYTE)v31)
      {
        if ((*((_BYTE *)a2 + 120) & 1) != 0)
          v14 = (char *)*((_QWORD *)a2 + 16);
        else
          v14 = (char *)a2 + 121;
        re::loadCompiledOrSourceFile((char *)&v31 + 8, v14, (re::internal::AssetTypeRegistry **)this + 9, (uint64_t)a3, a4);
      }
      else
      {
        re::DynamicString::operator+((re::DynamicString *)&v26, (uint64_t)v9, (re::DynamicString *)&v28);
        v23 = v28;
        v28 = 0uLL;
        v24 = v29;
        v25 = v30;
        v29 = 0;
        v30 = 0;
        *(_BYTE *)a4 = 0;
        *(_OWORD *)(a4 + 8) = v23;
        *(_QWORD *)(a4 + 24) = v24;
        *(_QWORD *)(a4 + 32) = v25;
        if (v26 && (v27 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v26 + 40))();
      }
      if ((_BYTE)v31 && *((_QWORD *)&v31 + 1) && (v32 & 1) != 0)
        (*(void (**)(void))(**((_QWORD **)&v31 + 1) + 40))();
    }
    else
    {
      v16 = v31;
      v17 = v32;
      v18 = v33;
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(a4 + 8) = v16;
      *(_QWORD *)(a4 + 24) = v17;
      *(_QWORD *)(a4 + 32) = v18;
    }
    result = v34;
    if (v34 && (v35 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t))(*v34 + 40))(v34, v36);
  }
  return result;
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<re::ExternalResolverLoadDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2)
{
  uint64_t **v2;
  unsigned __int8 v3;
  __guard *v4;
  int v6;
  int v7;
  re::AssetLoadDescriptor *v9;

  v2 = a2;
  if ((v3 & 1) == 0)
  {
    v9 = a1;
    v7 = v6;
    v2 = a2;
    a1 = v9;
    if (v7)
    {
      re::introspect<re::ExternalResolverLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"ExternalResolverLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_ExternalResolverLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_ExternalResolverLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ExternalResolverLoadDescriptorParameters>, 0);
      v2 = a2;
      a1 = v9;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)v4[57], v2, 0);
}

__n128 re::ExternalResolverAssetProvider::resolveChild@<Q0>(re::ExternalResolverAssetProvider *this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, re::AssetProvider *a3@<X2>, const char *a4@<X3>, uint64_t a5@<X8>)
{
  re::AssetProviderRegistry *v10;
  _BOOL8 v11;
  char *v12;
  uint64_t v13;
  re::PathBuffer *v14;
  _anonymous_namespace_ *v15;
  uint64_t v16;
  __n128 result;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  _BYTE v25[40];
  __int128 v26;
  int v27;
  __int128 v28;
  __int128 v29;
  int v30;
  _BYTE v31[24];
  __int128 v32;
  _BYTE v33[40];
  __int128 v34;
  int v35;
  __int128 v36;
  __int128 v37;
  int v38;
  _BYTE v39[24];
  __int128 v40;
  uint64_t v41;
  char v42;
  uint64_t *v43;
  uint64_t v44;
  re::PathBuffer *v45;
  uint64_t v46;

  v10 = (re::ExternalResolverAssetProvider *)((char *)this + 24);
  v11 = re::DynamicString::operator!=((uint64_t)a2, (uint64_t)this + 24);
  if (v11)
  {
    if ((*((_BYTE *)a2 + 8) & 1) != 0)
      v12 = (char *)*((_QWORD *)a2 + 2);
    else
      v12 = (char *)a2 + 9;
    if ((*((_BYTE *)this + 32) & 1) != 0)
      v18 = (char *)*((_QWORD *)this + 5);
    else
      v18 = (char *)this + 33;
    re::DynamicString::format((re::DynamicString *)"Scheme %s does not match scheme %s.", (re::DynamicString *)v33, v12, v18);
    result = *(__n128 *)v33;
    v21 = *(_QWORD *)&v33[16];
    v22 = *(_QWORD *)&v33[24];
    *(_BYTE *)a5 = 0;
    *(__n128 *)(a5 + 8) = result;
    *(_QWORD *)(a5 + 24) = v21;
    *(_QWORD *)(a5 + 32) = v22;
  }
  else
  {
    v44 = 0;
    v45 = 0;
    v46 = 0;
    re::DynamicString::setCapacity(&v43, 0);
    v13 = re::AssetLoadDescriptor::getIntrospectableData<re::ExternalResolverLoadDescriptorParameters>(a2, &v43);
    if ((v13 & 1) != 0)
    {
      if ((v44 & 1) != 0)
        v14 = v45;
      else
        v14 = (re::PathBuffer *)((char *)&v44 + 1);
      v15 = (_anonymous_namespace_ *)re::AssetProvider::resolveChildPath(a3, v14, &v41);
      re::AssetProviderRegistry::makeDescriptorForResolver(v10, (const re::DynamicString *)&v41, (const re::DynamicString *)&v23, (uint64_t)v25);
      v16 = *(_QWORD *)v25;
      memset(v25, 0, sizeof(v25));
      *(_QWORD *)v33 = v16;
      *(_OWORD *)&v33[24] = *(_OWORD *)&v25[24];
      *(_OWORD *)&v33[8] = *(_OWORD *)&v25[8];
      v34 = v26;
      v26 = 0u;
      ++v27;
      v35 = 1;
      v36 = v28;
      v37 = v29;
      v28 = 0u;
      v29 = 0u;
      ++v30;
      v38 = 1;
      *(_OWORD *)v39 = *(_OWORD *)v31;
      memset(v31, 0, sizeof(v31));
      v40 = v32;
      *(_QWORD *)&v39[16] = *(_QWORD *)&v31[16];
      v32 = 0uLL;
      result.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional(a5, (uint64_t)v33);
      if (*(_QWORD *)&v39[8])
      {
        if ((v39[16] & 1) != 0)
          (*(void (**)(double))(**(_QWORD **)&v39[8] + 40))(result.n128_f64[0]);
        result = 0uLL;
        *(_OWORD *)&v39[8] = 0u;
        v40 = 0u;
      }
      if (*((_QWORD *)&v36 + 1))
      {
        if (*(_QWORD *)v39)
          (*(void (**)(__n128))(**((_QWORD **)&v36 + 1) + 40))(result);
        *(_QWORD *)v39 = 0;
        v37 = 0uLL;
        *((_QWORD *)&v36 + 1) = 0;
        ++v38;
      }
      if (*(_QWORD *)&v33[32])
      {
        if ((_QWORD)v36)
          (*(void (**)(__n128))(**(_QWORD **)&v33[32] + 40))(result);
        *(_QWORD *)&v36 = 0;
        v34 = 0uLL;
        *(_QWORD *)&v33[32] = 0;
        ++v35;
      }
      if (*(_QWORD *)v33)
      {
        if ((v33[8] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)v33 + 40))(result);
        result = 0uLL;
        memset(v33, 0, 32);
      }
      if (*(_QWORD *)&v31[8])
      {
        if ((v31[16] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)&v31[8] + 40))(result);
        result = 0uLL;
        *(_OWORD *)&v31[8] = 0u;
        v32 = 0u;
      }
      if (*((_QWORD *)&v28 + 1))
      {
        if (*(_QWORD *)v31)
          (*(void (**)(__n128))(**((_QWORD **)&v28 + 1) + 40))(result);
        *(_QWORD *)v31 = 0;
        v29 = 0uLL;
        *((_QWORD *)&v28 + 1) = 0;
        ++v30;
      }
      if (*(_QWORD *)&v25[32])
      {
        if ((_QWORD)v28)
          (*(void (**)(__n128))(**(_QWORD **)&v25[32] + 40))(result);
        *(_QWORD *)&v28 = 0;
        v26 = 0uLL;
        *(_QWORD *)&v25[32] = 0;
        ++v27;
      }
      if (*(_QWORD *)v25)
      {
        if ((v25[8] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)v25 + 40))(result);
        result = 0uLL;
        memset(v25, 0, 32);
      }
      if (v23 && (v24 & 1) != 0)
        (*(void (**)(__n128))(*(_QWORD *)v23 + 40))(result);
      if (v41 && (v42 & 1) != 0)
        (*(void (**)(__n128))(*(_QWORD *)v41 + 40))(result);
    }
    else
    {
      result = *(__n128 *)v33;
      v19 = *(_QWORD *)&v33[16];
      v20 = *(_QWORD *)&v33[24];
      *(_BYTE *)a5 = 0;
      *(__n128 *)(a5 + 8) = result;
      *(_QWORD *)(a5 + 24) = v19;
      *(_QWORD *)(a5 + 32) = v20;
    }
    if (v43 && (v44 & 1) != 0)
      (*(void (**)(__n128))(*v43 + 40))(result);
  }
  return result;
}

uint64_t re::ExternalResolverAssetProvider::isDeviceAssetForRelease(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 96);
}

uint64_t *re::ExternalResolverAssetProvider::getAssetPathForRelease@<X0>(_anonymous_namespace_ *a1@<X0>, re::AssetLoadDescriptor *a2@<X1>, const re::internal::AssetTypeRegistry *a3@<X2>, os_unfair_lock_s *a4@<X3>, uint64_t a5@<X8>)
{
  char v9;
  char *v10;
  char *v11;
  _anonymous_namespace_ *v12;
  _anonymous_namespace_ *v13;
  char *v14;
  double v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *result;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  char v26[24];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  _BYTE v38[23];
  uint64_t *v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;

  v40 = 0;
  v41 = 0;
  v42 = 0;
  re::DynamicString::setCapacity(&v39, 0);
  v9 = re::AssetLoadDescriptor::getIntrospectableData<re::ExternalResolverLoadDescriptorParameters>(a2, &v39);
  v10 = (char *)a2 + 9;
  if ((v9 & 1) != 0)
  {
    if ((*((_QWORD *)a2 + 1) & 1) != 0)
      v10 = (char *)*((_QWORD *)a2 + 2);
    if ((v40 & 1) != 0)
      v11 = v41;
    else
      v11 = (char *)&v40 + 1;
    v12 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"%s:%s", (re::DynamicString *)&v36, v10, v11);
    LODWORD(v29) = 0;
    v31 = 0;
    v32 = 0;
    v30 = 0;
    v13 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)&v29 + 1, 0);
    *((_QWORD *)&v33 + 1) = 0;
    v34 = 0uLL;
    re::DynamicString::setCapacity(&v33, 0);
    v35 = 0;
    if ((v37 & 1) != 0)
      v14 = *(char **)&v38[7];
    else
      v14 = v38;
    v15 = re::AssetPath::parse((re::AssetPath *)&v29, v14, 0, a3, a4, v26);
    if (!v26[0] && (_QWORD)v27)
    {
      if ((BYTE8(v27) & 1) != 0)
        (*(void (**)(double))(*(_QWORD *)v27 + 40))(v15);
      v27 = 0u;
      v28 = 0u;
    }
    v24 = 0;
    v25 = 0;
    v23 = *((unint64_t *)&v29 + 1);
    re::DynamicString::setCapacity(&v23, 0);
    re::AssetPath::fullAssetPath((re::DynamicString *)&v29, (re::DynamicString *)&v23);
    v16 = v23;
    v17 = v24;
    v18 = v25;
    *(_BYTE *)a5 = 1;
    *(_OWORD *)(a5 + 8) = v16;
    *(_QWORD *)(a5 + 24) = v17;
    *(_QWORD *)(a5 + 32) = v18;
    if ((_QWORD)v33)
    {
      if ((BYTE8(v33) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v33 + 40))();
      v33 = 0u;
      v34 = 0u;
    }
    if (*((_QWORD *)&v29 + 1) && (v30 & 1) != 0)
      (*(void (**)(void))(**((_QWORD **)&v29 + 1) + 40))();
    if (v36 && (v37 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v36 + 40))();
  }
  else
  {
    if ((*((_QWORD *)a2 + 1) & 1) != 0)
      v10 = (char *)*((_QWORD *)a2 + 2);
    re::DynamicString::format((re::DynamicString *)"Failed to deserialize parameters for %s", (re::DynamicString *)&v29, v10);
    v19 = v29;
    v20 = v30;
    v21 = v31;
    *(_BYTE *)a5 = 0;
    *(_OWORD *)(a5 + 8) = v19;
    *(_QWORD *)(a5 + 24) = v20;
    *(_QWORD *)(a5 + 32) = v21;
  }
  result = v39;
  if (v39)
  {
    if ((v40 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v39 + 40))();
  }
  return result;
}

uint64_t *re::ExternalResolverAssetProvider::getDescription(re::ExternalResolverAssetProvider *this, const re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  uint64_t *result;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];

  v7 = 0;
  v8 = 0;
  v9 = 0;
  re::DynamicString::setCapacity(&v6, 0);
  if (re::AssetLoadDescriptor::getIntrospectableData<re::ExternalResolverLoadDescriptorParameters>(a2, &v6))
  {
    re::DynamicString::operator=(a3, (re::DynamicString *)&v6);
  }
  else
  {
    v10[0] = "mangled";
    v10[1] = 7;
    re::DynamicString::operator=(a3, (uint64_t)v10);
  }
  result = v6;
  if (v6)
  {
    if ((v7 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v6 + 40))();
  }
  return result;
}

uint64_t re::ExternalResolverAssetProvider::schemeName(re::ExternalResolverAssetProvider *this)
{
  if ((*((_BYTE *)this + 32) & 1) != 0)
    return *((_QWORD *)this + 5);
  else
    return (uint64_t)this + 33;
}

uint64_t guess_compression_from_magic_number(unsigned __int8 *a1)
{
  int v5;

  if (*(_WORD *)a1 == 30306 && a1[2] == 120)
    return 2;
  if (*(_WORD *)a1 != 30306 || a1[2] != 52)
  {
    if (*a1 == 253 && *(_DWORD *)(a1 + 1) == 1515747895)
      return 4;
    if (*(_WORD *)a1 != 25200 || a1[2] != 122)
      return 0;
    v5 = a1[3];
    if (v5 != 52)
    {
      if (v5 != 101)
      {
        if (v5 != 120)
          return 0;
        return 4;
      }
      return 2;
    }
  }
  return 3;
}

uint64_t reality_compression_stream_begin(unsigned int a1, int a2)
{
  compression_stream *v4;
  compression_stream *v5;
  compression_stream_operation v6;
  compression_algorithm v7;
  uint64_t result;

  v4 = (compression_stream *)operator new();
  v5 = v4;
  v6 = a2 != 0;
  if (a1 > 4)
    v7 = COMPRESSION_ZLIB;
  else
    v7 = dword_2260F5B2C[a1];
  if (compression_stream_init(v4, v6, v7))
  {
    MEMORY[0x2276933B8](v5, 0x10D0C405C4BD7A1);
    return 0;
  }
  else
  {
    result = operator new();
    *(_WORD *)(result + 36) = 4097;
    *(_QWORD *)(result + 40) = 0;
    *(_BYTE *)(result + 48) = 1;
    *(_QWORD *)result = v5;
    *(_DWORD *)(result + 56) = v6;
    *(_DWORD *)(result + 60) = v7;
  }
  return result;
}

uint64_t reality_compression_process_stream_chunk@<X0>(int flags@<W1>, uint64_t result@<X0>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v6;
  compression_stream *v8;
  uint64_t v9;
  uint64_t v10;
  const uint8_t *v11;
  unint64_t v12;
  size_t v13;
  uint8_t *v14;
  size_t v15;
  const uint8_t *src_ptr;
  int64_t v17;
  size_t dst_size;
  uint64_t v19;
  unint64_t v20;
  size_t v21;
  int v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  size_t v26;
  uint8_t *v27;
  size_t v28;
  const uint8_t *v29;
  const uint8_t *v30;
  const uint8_t *v31;
  size_t v32;
  size_t v33;
  size_t v34;
  uint8_t *v35;
  uint64_t v36;
  size_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  const uint8_t *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;

  v6 = result;
  v43 = *(_QWORD *)result;
  v44 = *(_QWORD *)(result + 16);
  *(_QWORD *)(a4 + 24) = *(_QWORD *)result;
  *(_QWORD *)(a4 + 32) = v44;
  v9 = a3 + 20;
  v8 = *(compression_stream **)a3;
  *(_QWORD *)(a4 + 8) = 0;
  *(_QWORD *)(a4 + 16) = 0;
  v10 = a3 + 8;
  while (1)
  {
    v11 = *(const uint8_t **)v6;
    if (*(_DWORD *)(a3 + 56) != 1)
    {
      v13 = *(_QWORD *)(v6 + 8);
      v14 = *(uint8_t **)(v6 + 16);
      v8->src_ptr = v11;
      v8->src_size = v13;
      v15 = *(_QWORD *)(v6 + 24);
      v8->dst_ptr = v14;
      v8->dst_size = v15;
      result = compression_stream_process(v8, flags);
      if ((_DWORD)result == -1)
        goto LABEL_45;
      src_ptr = v8->src_ptr;
      v17 = *(_QWORD *)(v6 + 8) + *(_QWORD *)v6 - (_QWORD)src_ptr;
      *(_QWORD *)v6 = src_ptr;
      *(_QWORD *)(v6 + 8) = v17;
      dst_size = v8->dst_size;
      *(_QWORD *)(v6 + 16) = v8->dst_ptr;
      *(_QWORD *)(v6 + 24) = dst_size;
      if ((_DWORD)result == 1)
      {
LABEL_46:
        v38 = 1;
        goto LABEL_47;
      }
      goto LABEL_42;
    }
    v12 = *(_QWORD *)(v6 + 8);
    if (*(_BYTE *)(a3 + 36))
    {
      if (v12 <= 0xB)
      {
        *(_BYTE *)(a3 + 37) = 0;
LABEL_19:
        *(_QWORD *)(a3 + 40) = v12;
        goto LABEL_27;
      }
      v19 = *(_QWORD *)v11;
      *(_DWORD *)(v10 + 8) = *((_DWORD *)v11 + 2);
      *(_QWORD *)v10 = v19;
      v11 += 12;
      v12 -= 12;
      *(_QWORD *)(a3 + 12) = bswap64(*(_QWORD *)(a3 + 12));
      *(_WORD *)(a3 + 36) = 4096;
      *(_QWORD *)(a3 + 40) = 0;
    }
    if (*(_BYTE *)(a3 + 8) != 112 || *(_BYTE *)(a3 + 9) != 98 || *(_BYTE *)(a3 + 10) != 122)
    {
      *(_BYTE *)(a3 + 37) = 0;
      v11 = *(const uint8_t **)v6;
      v12 = *(_QWORD *)(v6 + 8);
      goto LABEL_19;
    }
    v20 = *(unsigned __int8 *)(a3 + 37);
    if (*(_BYTE *)(a3 + 37))
      break;
LABEL_26:
    *(_QWORD *)v6 = v11;
    *(_QWORD *)(v6 + 8) = v12;
LABEL_27:
    v26 = *(_QWORD *)(a3 + 40);
    if (v12 < v26)
      v26 = v12;
    v8->src_ptr = v11;
    v8->src_size = v26;
    v27 = *(uint8_t **)(v6 + 16);
    v28 = *(_QWORD *)(v6 + 24);
    v8->dst_ptr = v27;
    v8->dst_size = v28;
    if (*(_BYTE *)(a3 + 48))
    {
      result = compression_stream_process(v8, 0);
      if ((_DWORD)result == -1)
      {
LABEL_45:
        v38 = 0;
        goto LABEL_47;
      }
      v29 = v8->src_ptr;
      v30 = *(const uint8_t **)(v6 + 8);
      v31 = &v29[-*(_QWORD *)v6];
      *(_QWORD *)(a3 + 40) -= v31;
      v17 = v30 - v31;
      *(_QWORD *)v6 = v29;
      *(_QWORD *)(v6 + 8) = v30 - v31;
      v32 = v8->dst_size;
      *(_QWORD *)(v6 + 16) = v8->dst_ptr;
      *(_QWORD *)(v6 + 24) = v32;
      if ((_DWORD)result == 1)
      {
        if (flags && v30 == v31)
          goto LABEL_46;
        *(_DWORD *)a4 = 2;
        compression_stream_destroy(v8);
        result = compression_stream_init(v8, *(compression_stream_operation *)(a3 + 56), *(compression_algorithm *)(a3 + 60));
        *(_BYTE *)(a3 + 37) = 16;
        v17 = *(_QWORD *)(v6 + 8);
      }
    }
    else
    {
      if (v26 >= v28)
        v33 = v28;
      else
        v33 = v26;
      result = (uint64_t)memcpy(v27, v11, v33);
      v34 = v8->dst_size;
      v35 = &v8->dst_ptr[v33];
      v36 = *(_QWORD *)(v6 + 8);
      v17 = v36 - v33;
      *(_QWORD *)v6 = &v8->src_ptr[v33];
      *(_QWORD *)(v6 + 8) = v36 - v33;
      *(_QWORD *)(v6 + 16) = v35;
      *(_QWORD *)(v6 + 24) = v34 - v33;
      v37 = *(_QWORD *)(a3 + 40) - v33;
      *(_QWORD *)(a3 + 40) = v37;
      if (!v37)
      {
        if (flags && v36 == v33)
          goto LABEL_46;
        *(_DWORD *)a4 = 2;
        *(_BYTE *)(a3 + 37) = 16;
      }
    }
LABEL_42:
    if (!v17 || !*(_QWORD *)(v6 + 24))
    {
      v38 = 2;
LABEL_47:
      v39 = v43;
      v40 = v44;
      v11 = *(const uint8_t **)v6;
      goto LABEL_48;
    }
  }
  if ((flags & 1) != 0)
  {
    if (!v12 && (_DWORD)v20 == 16)
    {
      v12 = 0;
      *(_BYTE *)(a3 + 37) = 0;
      *(_QWORD *)v6 = v11;
      *(_QWORD *)(v6 + 8) = 0;
      goto LABEL_27;
    }
    if (v12 < v20)
      goto LABEL_45;
  }
  if (v20 >= v12)
    v21 = v12;
  else
    v21 = *(unsigned __int8 *)(a3 + 37);
  result = (uint64_t)memcpy((void *)(v9 - v20 + 16), v11, v21);
  v11 += v21;
  v12 -= v21;
  v22 = *(unsigned __int8 *)(a3 + 37) - (_DWORD)v21;
  *(_BYTE *)(a3 + 37) = v22;
  if (!v22)
  {
    v23 = *(_QWORD *)(a3 + 20);
    *(_QWORD *)(a3 + 20) = bswap64(v23);
    v24 = *(_QWORD *)(a3 + 28);
    v25 = bswap64(v24);
    *(_QWORD *)(a3 + 28) = v25;
    *(_QWORD *)(a3 + 40) = v25;
    *(_BYTE *)(a3 + 48) = v24 != v23;
    goto LABEL_26;
  }
  *(_QWORD *)v6 = v11;
  *(_QWORD *)(v6 + 8) = v12;
  v38 = 2;
  v39 = v43;
  v40 = v44;
LABEL_48:
  *(_DWORD *)a4 = v38;
  v41 = &v11[-v39];
  v42 = *(_QWORD *)(v6 + 16) - v40;
  *(_QWORD *)(a4 + 8) = v41;
  *(_QWORD *)(a4 + 16) = v42;
  return result;
}

void reality_compression_stream_end(compression_stream **a1)
{
  compression_stream_destroy(*a1);
  if (*a1)
    MEMORY[0x2276933B8](*a1, 0x10D0C405C4BD7A1);
  JUMPOUT(0x2276933B8);
}

_QWORD *reality_archive_file_pack(char *a1, const char *a2, int a3)
{
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  char v9;
  char *v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t *v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  unsigned int v20;
  BOOL v21;
  uint64_t v22;
  const char *v23;
  void *v24;
  _WORD *entry;
  uint64_t v26;
  FILE *v27;
  FILE *v28;
  size_t v29;
  size_t v30;
  __int128 *v31;
  __int128 *v32;
  void *v33;
  void *__p;
  char *v36;
  uint64_t v37;

  zip_file_create(a2);
  v6 = v5;
  if (!v5)
    return v6;
  __p = 0;
  v36 = 0;
  v37 = 0;
  if (!_collect_paths(a1, (uint64_t *)&__p))
    goto LABEL_47;
  v7 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * ((v36 - (_BYTE *)__p) >> 3));
  if (v36 == __p)
    v8 = 0;
  else
    v8 = v7;
  std::__introsort<std::_ClassicAlgPolicy,reality_archive_file_pack(char const*,char const*,BOOL)::$_0 &,std::tuple<std::string,std::string,BOOL> *,false>((uint64_t)__p, (__int128 *)v36, v8, 1);
  if (a3)
    v9 = 1;
  else
    v9 = 2;
  v10 = (char *)__p;
  v11 = v36;
  if (__p == v36)
  {
LABEL_45:
    v6 = (_QWORD *)zip_close(v6);
    goto LABEL_48;
  }
  while (1)
  {
    v12 = (uint64_t)(v10 + 24);
    v13 = v10[47];
    if (v10[48])
      break;
    if ((v13 & 0x80) != 0)
      v12 = *(_QWORD *)v12;
    if (!zip_append_entry(v6, v12, 0, 0, 0))
      goto LABEL_47;
LABEL_41:
    v10 += 56;
    if (v10 == v11)
      goto LABEL_45;
  }
  if ((v13 & 0x80) != 0)
  {
    v16 = *((_QWORD *)v10 + 4);
    if (v16 == 11)
    {
      v18 = *(_QWORD *)(*(_QWORD *)v12 + 3);
      v19 = **(_QWORD **)v12 == 0x6A2E726564616568;
      v20 = 779248996;
LABEL_27:
      v22 = v20 | 0x6E6F736A00000000;
      v21 = v19 && v18 == v22;
      goto LABEL_30;
    }
    v15 = v9;
    if (v16 != 13)
      goto LABEL_33;
    v14 = *(uint64_t **)v12;
LABEL_22:
    v17 = *v14;
    v18 = *(uint64_t *)((char *)v14 + 5);
    v19 = v17 == 0x70614D7465737361;
    v20 = 779116877;
    goto LABEL_27;
  }
  if (v13 != 11)
  {
    v14 = (uint64_t *)(v10 + 24);
    v15 = v9;
    if (v13 != 13)
      goto LABEL_33;
    goto LABEL_22;
  }
  v21 = *(_QWORD *)v12 == 0x6A2E726564616568 && *(_QWORD *)(v10 + 27) == 0x6E6F736A2E726564;
LABEL_30:
  v15 = v9;
  if (v21)
    v15 = 0;
LABEL_33:
  v23 = v10;
  if (v10[23] < 0)
  {
    v23 = *(const char **)v10;
    if ((v13 & 0x80) == 0)
      goto LABEL_35;
LABEL_44:
    v12 = *(_QWORD *)v12;
    goto LABEL_35;
  }
  if ((v13 & 0x80) != 0)
    goto LABEL_44;
LABEL_35:
  v24 = malloc_type_malloc(0x10000uLL, 0xC2A086EBuLL);
  entry = (_WORD *)zip_create_entry(v6, v12, 0x63006300080000uLL >> (16 * v15));
  if (entry)
  {
    v26 = zip_entry_save_data_begin(entry);
    v27 = fopen(v23, "rb");
    if (v27)
    {
      v28 = v27;
      v29 = fread(v24, 1uLL, 0x10000uLL, v27);
      if (v29)
      {
        v30 = v29;
        do
        {
          zip_entry_save_data_write((Bytef *)v24, v30, v26);
          v30 = fread(v24, 1uLL, 0x10000uLL, v28);
        }
        while (v30);
      }
      zip_entry_save_data_end(v26);
      fclose(v28);
      free(v24);
      goto LABEL_41;
    }
  }
  free(v24);
LABEL_47:
  v6 = 0;
LABEL_48:
  v31 = (__int128 *)__p;
  if (__p)
  {
    v32 = (__int128 *)v36;
    v33 = __p;
    if (v36 != __p)
    {
      do
      {
        v32 = (__int128 *)((char *)v32 - 56);
        std::allocator<std::tuple<std::string,std::string,BOOL>>::destroy[abi:nn180100]((uint64_t)&v37, (uint64_t)v32);
      }
      while (v32 != v31);
      v33 = __p;
    }
    v36 = (char *)v31;
    operator delete(v33);
  }
  return v6;
}

void std::__introsort<std::_ClassicAlgPolicy,reality_archive_file_pack(char const*,char const*,BOOL)::$_0 &,std::tuple<std::string,std::string,BOOL> *,false>(uint64_t a1, __int128 *a2, uint64_t a3, char a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  unint64_t v24;
  unint64_t v25;
  BOOL v26;
  unint64_t v27;
  unint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  __int128 *v35;
  BOOL v36;
  __int128 v37;
  __int128 v38;
  unint64_t v39;
  int v40;
  unint64_t v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  __int128 v46;
  uint64_t v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  __int128 v58;
  uint64_t v59;
  uint64_t v60;
  int64_t v61;
  int64_t v62;
  int64_t v63;
  uint64_t v64;
  __int128 *v65;
  uint64_t v66;
  __int128 v67;
  __int128 v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int64_t v72;
  uint64_t v73;
  __int128 v74;
  __int128 v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  __int128 *v80;
  __int128 *v81;
  uint64_t v82;
  unint64_t v83;
  __int128 *v84;
  __int128 v85;
  __int128 v86;
  uint64_t v87;
  BOOL v88;
  uint64_t v89;
  uint64_t v90;
  __int128 v91;
  uint64_t v92;
  uint64_t v93;
  __int128 *v94;
  unint64_t v95;
  void *v96[2];
  uint64_t v97;
  __int128 __p;
  uint64_t v99;
  char v100;
  __int128 v101;
  uint64_t v102;
  __int128 v103;
  uint64_t v104;
  char v105;

uint64_t reality_archive_file_pack(char const*,char const*,BOOL)::$_0::operator()(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  size_t v5;
  size_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v16;

  v4 = *(_QWORD **)(a1 + 24);
  v2 = (_QWORD *)(a1 + 24);
  v3 = v4;
  v5 = v2[1];
  if (*((char *)v2 + 23) >= 0)
  {
    v6 = *((unsigned __int8 *)v2 + 23);
  }
  else
  {
    v2 = v3;
    v6 = v5;
  }
  v9 = *(uint64_t **)(a2 + 24);
  v7 = a2 + 24;
  v8 = v9;
  v10 = *(unsigned __int8 *)(v7 + 23);
  if ((v10 & 0x80u) != 0)
    v10 = *(_QWORD *)(v7 + 8);
  else
    v8 = (uint64_t *)v7;
  if (v10 != 11)
  {
    if (v6 == 11)
    {
      if (*v2 == 0x6A2E726564616568 && *(_QWORD *)((char *)v2 + 3) == 0x6E6F736A2E726564)
        return 1;
      if (v10 != 13)
        return 0;
    }
    else if (v10 != 13)
    {
      goto LABEL_29;
    }
    if (*v8 ^ 0x70614D7465737361 | *(uint64_t *)((char *)v8 + 5) ^ 0x6E6F736A2E70614DLL)
      v16 = v6 == 13;
    else
      v16 = 0;
    if (v16)
      return memcmp(v2, "assetMap.json", v6) == 0;
    return 0;
  }
  v11 = *v8;
  v12 = *(uint64_t *)((char *)v8 + 3);
  if (v11 == 0x6A2E726564616568 && v12 == 0x6E6F736A2E726564)
    return 0;
  if (v6 == 11)
    return *v2 == 0x6A2E726564616568 && *(_QWORD *)((char *)v2 + 3) == 0x6E6F736A2E726564;
LABEL_29:
  if (v6 != 13)
    return 0;
  return memcmp(v2, "assetMap.json", v6) == 0;
}

__n128 std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,reality_archive_file_pack(char const*,char const*,BOOL)::$_0 &,std::tuple<std::string,std::string,BOOL> *,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __n128 result;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v29;
  char v30;
  uint64_t v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;

  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,reality_archive_file_pack(char const*,char const*,BOOL)::$_0 &,std::tuple<std::string,std::string,BOOL> *>(a1, a2, a3, a4);
  if (reality_archive_file_pack(char const*,char const*,BOOL)::$_0::operator()(a5, a4))
  {
    v11 = *(_QWORD *)(a4 + 16);
    v12 = *(_OWORD *)a4;
    v13 = *(_QWORD *)(a5 + 16);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_QWORD *)(a4 + 16) = v13;
    *(_OWORD *)a5 = v12;
    *(_QWORD *)(a5 + 16) = v11;
    v14 = *(_QWORD *)(a4 + 40);
    v15 = *(_OWORD *)(a4 + 24);
    v16 = *(_QWORD *)(a5 + 40);
    *(_OWORD *)(a4 + 24) = *(_OWORD *)(a5 + 24);
    *(_QWORD *)(a4 + 40) = v16;
    *(_OWORD *)(a5 + 24) = v15;
    *(_QWORD *)(a5 + 40) = v14;
    LOBYTE(v14) = *(_BYTE *)(a4 + 48);
    *(_BYTE *)(a4 + 48) = *(_BYTE *)(a5 + 48);
    *(_BYTE *)(a5 + 48) = v14;
    if (reality_archive_file_pack(char const*,char const*,BOOL)::$_0::operator()(a4, a3))
    {
      v17 = *(_QWORD *)(a3 + 16);
      v18 = *(_OWORD *)a3;
      v19 = *(_QWORD *)(a4 + 16);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_QWORD *)(a3 + 16) = v19;
      *(_OWORD *)a4 = v18;
      *(_QWORD *)(a4 + 16) = v17;
      v20 = *(_QWORD *)(a3 + 40);
      v21 = *(_OWORD *)(a3 + 24);
      v22 = *(_QWORD *)(a4 + 40);
      *(_OWORD *)(a3 + 24) = *(_OWORD *)(a4 + 24);
      *(_QWORD *)(a3 + 40) = v22;
      *(_OWORD *)(a4 + 24) = v21;
      *(_QWORD *)(a4 + 40) = v20;
      v23 = *(_BYTE *)(a3 + 48);
      *(_BYTE *)(a3 + 48) = *(_BYTE *)(a4 + 48);
      *(_BYTE *)(a4 + 48) = v23;
      if (reality_archive_file_pack(char const*,char const*,BOOL)::$_0::operator()(a3, a2))
      {
        v24 = *(_QWORD *)(a2 + 16);
        v25 = *(_OWORD *)a2;
        v26 = *(_QWORD *)(a3 + 16);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_QWORD *)(a2 + 16) = v26;
        *(_OWORD *)a3 = v25;
        *(_QWORD *)(a3 + 16) = v24;
        v27 = *(_QWORD *)(a2 + 40);
        v28 = *(_OWORD *)(a2 + 24);
        v29 = *(_QWORD *)(a3 + 40);
        *(_OWORD *)(a2 + 24) = *(_OWORD *)(a3 + 24);
        *(_QWORD *)(a2 + 40) = v29;
        *(_OWORD *)(a3 + 24) = v28;
        *(_QWORD *)(a3 + 40) = v27;
        v30 = *(_BYTE *)(a2 + 48);
        *(_BYTE *)(a2 + 48) = *(_BYTE *)(a3 + 48);
        *(_BYTE *)(a3 + 48) = v30;
        if (reality_archive_file_pack(char const*,char const*,BOOL)::$_0::operator()(a2, a1))
        {
          v31 = *(_QWORD *)(a1 + 16);
          v32 = *(_OWORD *)a1;
          v33 = *(_QWORD *)(a2 + 16);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_QWORD *)(a1 + 16) = v33;
          *(_OWORD *)a2 = v32;
          *(_QWORD *)(a2 + 16) = v31;
          v34 = *(_QWORD *)(a1 + 40);
          result = *(__n128 *)(a1 + 24);
          v35 = *(_QWORD *)(a2 + 40);
          *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
          *(_QWORD *)(a1 + 40) = v35;
          *(__n128 *)(a2 + 24) = result;
          *(_QWORD *)(a2 + 40) = v34;
          v36 = *(_BYTE *)(a1 + 48);
          *(_BYTE *)(a1 + 48) = *(_BYTE *)(a2 + 48);
          *(_BYTE *)(a2 + 48) = v36;
        }
      }
    }
  }
  return result;
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,reality_archive_file_pack(char const*,char const*,BOOL)::$_0 &,std::tuple<std::string,std::string,BOOL> *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v6;
  uint64_t result;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  uint64_t v35;
  char v36;

  v6 = reality_archive_file_pack(char const*,char const*,BOOL)::$_0::operator()(a2, a1);
  result = reality_archive_file_pack(char const*,char const*,BOOL)::$_0::operator()(a3, a2);
  if ((v6 & 1) != 0)
  {
    v8 = a1 + 24;
    if ((_DWORD)result)
    {
      v9 = (char *)(a1 + 48);
      v10 = *(_QWORD *)(a1 + 16);
      v11 = *(_OWORD *)a1;
      v12 = *(_QWORD *)(a3 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(_QWORD *)(a1 + 16) = v12;
    }
    else
    {
      v26 = *(_QWORD *)(a1 + 16);
      v27 = *(_OWORD *)a1;
      v28 = *(_QWORD *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_QWORD *)(a1 + 16) = v28;
      *(_OWORD *)a2 = v27;
      *(_QWORD *)(a2 + 16) = v26;
      v29 = *(_QWORD *)(a1 + 40);
      v30 = *(_OWORD *)v8;
      v31 = *(_QWORD *)(a2 + 40);
      *(_OWORD *)v8 = *(_OWORD *)(a2 + 24);
      *(_QWORD *)(a1 + 40) = v31;
      *(_OWORD *)(a2 + 24) = v30;
      *(_QWORD *)(a2 + 40) = v29;
      v9 = (char *)(a2 + 48);
      LOBYTE(v29) = *(_BYTE *)(a1 + 48);
      *(_BYTE *)(a1 + 48) = *(_BYTE *)(a2 + 48);
      *(_BYTE *)(a2 + 48) = v29;
      result = reality_archive_file_pack(char const*,char const*,BOOL)::$_0::operator()(a3, a2);
      if (!(_DWORD)result)
        return result;
      v8 = a2 + 24;
      v10 = *(_QWORD *)(a2 + 16);
      v11 = *(_OWORD *)a2;
      v32 = *(_QWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_QWORD *)(a2 + 16) = v32;
    }
    *(_OWORD *)a3 = v11;
    *(_QWORD *)(a3 + 16) = v10;
    v33 = *(_QWORD *)(v8 + 16);
    v34 = *(_OWORD *)v8;
    v35 = *(_QWORD *)(a3 + 40);
    *(_OWORD *)v8 = *(_OWORD *)(a3 + 24);
    *(_QWORD *)(v8 + 16) = v35;
    *(_OWORD *)(a3 + 24) = v34;
    *(_QWORD *)(a3 + 40) = v33;
    v19 = (char *)(a3 + 48);
    goto LABEL_10;
  }
  if ((_DWORD)result)
  {
    v13 = *(_QWORD *)(a2 + 16);
    v14 = *(_OWORD *)a2;
    v15 = *(_QWORD *)(a3 + 16);
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_QWORD *)(a2 + 16) = v15;
    *(_OWORD *)a3 = v14;
    *(_QWORD *)(a3 + 16) = v13;
    v16 = *(_QWORD *)(a2 + 40);
    v17 = *(_OWORD *)(a2 + 24);
    v18 = *(_QWORD *)(a3 + 40);
    *(_OWORD *)(a2 + 24) = *(_OWORD *)(a3 + 24);
    *(_QWORD *)(a2 + 40) = v18;
    *(_OWORD *)(a3 + 24) = v17;
    *(_QWORD *)(a3 + 40) = v16;
    v19 = (char *)(a2 + 48);
    LOBYTE(v16) = *(_BYTE *)(a2 + 48);
    *(_BYTE *)(a2 + 48) = *(_BYTE *)(a3 + 48);
    *(_BYTE *)(a3 + 48) = v16;
    result = reality_archive_file_pack(char const*,char const*,BOOL)::$_0::operator()(a2, a1);
    if ((_DWORD)result)
    {
      v20 = *(_QWORD *)(a1 + 16);
      v21 = *(_OWORD *)a1;
      v22 = *(_QWORD *)(a2 + 16);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_QWORD *)(a1 + 16) = v22;
      *(_OWORD *)a2 = v21;
      *(_QWORD *)(a2 + 16) = v20;
      v23 = *(_QWORD *)(a1 + 40);
      v24 = *(_OWORD *)(a1 + 24);
      v25 = *(_QWORD *)(a2 + 40);
      *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
      *(_QWORD *)(a1 + 40) = v25;
      *(_OWORD *)(a2 + 24) = v24;
      *(_QWORD *)(a2 + 40) = v23;
      v9 = (char *)(a1 + 48);
LABEL_10:
      v36 = *v9;
      *v9 = *v19;
      *v19 = v36;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,reality_archive_file_pack(char const*,char const*,BOOL)::$_0 &,std::tuple<std::string,std::string,BOOL> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  _OWORD *v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  __int128 v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  void *v21[2];
  uint64_t v22;
  __int128 __p;
  uint64_t v24;
  char v25;

  v4 = 0x6DB6DB6DB6DB6DB7 * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (_OWORD *)(a2 - 56);
      if (reality_archive_file_pack(char const*,char const*,BOOL)::$_0::operator()(a2 - 56, a1))
      {
        v7 = *(_QWORD *)(a1 + 16);
        v8 = *(_OWORD *)a1;
        v9 = *(_QWORD *)(a2 - 40);
        *(_OWORD *)a1 = *v6;
        *(_QWORD *)(a1 + 16) = v9;
        *v6 = v8;
        *(_QWORD *)(a2 - 40) = v7;
        v10 = *(_QWORD *)(a1 + 40);
        v11 = *(_OWORD *)(a1 + 24);
        v12 = *(_QWORD *)(a2 - 16);
        *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 - 32);
        *(_QWORD *)(a1 + 40) = v12;
        *(_OWORD *)(a2 - 32) = v11;
        *(_QWORD *)(a2 - 16) = v10;
        LOBYTE(v10) = *(_BYTE *)(a1 + 48);
        *(_BYTE *)(a1 + 48) = *(_BYTE *)(a2 - 8);
        *(_BYTE *)(a2 - 8) = v10;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,reality_archive_file_pack(char const*,char const*,BOOL)::$_0 &,std::tuple<std::string,std::string,BOOL> *>(a1, a1 + 56, a2 - 56);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,reality_archive_file_pack(char const*,char const*,BOOL)::$_0 &,std::tuple<std::string,std::string,BOOL> *>(a1, a1 + 56, a1 + 112, a2 - 56);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,reality_archive_file_pack(char const*,char const*,BOOL)::$_0 &,std::tuple<std::string,std::string,BOOL> *,0>(a1, a1 + 56, a1 + 112, a1 + 168, a2 - 56);
      return 1;
    default:
      v13 = a1 + 112;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,reality_archive_file_pack(char const*,char const*,BOOL)::$_0 &,std::tuple<std::string,std::string,BOOL> *>(a1, a1 + 56, a1 + 112);
      v14 = a1 + 168;
      if (a1 + 168 == a2)
        return 1;
      v15 = 0;
      v16 = 0;
      break;
  }
  while (1)
  {
    if (reality_archive_file_pack(char const*,char const*,BOOL)::$_0::operator()(v14, v13))
    {
      *(_OWORD *)v21 = *(_OWORD *)v14;
      v22 = *(_QWORD *)(v14 + 16);
      *(_QWORD *)v14 = 0;
      *(_QWORD *)(v14 + 8) = 0;
      v17 = *(_OWORD *)(v14 + 24);
      *(_QWORD *)(v14 + 16) = 0;
      *(_QWORD *)(v14 + 24) = 0;
      __p = v17;
      v24 = *(_QWORD *)(v14 + 40);
      v25 = *(_BYTE *)(v14 + 48);
      v18 = v15;
      *(_QWORD *)(v14 + 32) = 0;
      *(_QWORD *)(v14 + 40) = 0;
      while (1)
      {
        std::__memberwise_forward_assign[abi:nn180100]<std::tuple<std::string,std::string,BOOL>,std::tuple<std::string,std::string,BOOL>,std::string,std::string,BOOL,0ul,1ul,2ul>(a1 + v18 + 168, (__int128 *)(a1 + v18 + 112));
        if (v18 == -112)
          break;
        v19 = reality_archive_file_pack(char const*,char const*,BOOL)::$_0::operator()((uint64_t)v21, a1 + v18 + 56);
        v18 -= 56;
        if ((v19 & 1) == 0)
        {
          v20 = a1 + v18 + 168;
          goto LABEL_12;
        }
      }
      v20 = a1;
LABEL_12:
      std::__memberwise_forward_assign[abi:nn180100]<std::tuple<std::string,std::string,BOOL>,std::tuple<std::string,std::string,BOOL>,std::string,std::string,BOOL,0ul,1ul,2ul>(v20, (__int128 *)v21);
      if (SHIBYTE(v24) < 0)
        operator delete((void *)__p);
      if (SHIBYTE(v22) < 0)
        operator delete(v21[0]);
      if (++v16 == 8)
        return v14 + 56 == a2;
    }
    v13 = v14;
    v15 += 56;
    v14 += 56;
    if (v14 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,reality_archive_file_pack(char const*,char const*,BOOL)::$_0 &,std::tuple<std::string,std::string,BOOL> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,reality_archive_file_pack(char const*,char const*,BOOL)::$_0 &,std::tuple<std::string,std::string,BOOL> *>(a1, a2, a3);
  if (reality_archive_file_pack(char const*,char const*,BOOL)::$_0::operator()(a4, a3))
  {
    v9 = *(_QWORD *)(a3 + 16);
    v10 = *(_OWORD *)a3;
    v11 = *(_QWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_QWORD *)(a3 + 16) = v11;
    *(_OWORD *)a4 = v10;
    *(_QWORD *)(a4 + 16) = v9;
    v12 = *(_QWORD *)(a3 + 40);
    v13 = *(_OWORD *)(a3 + 24);
    v14 = *(_QWORD *)(a4 + 40);
    *(_OWORD *)(a3 + 24) = *(_OWORD *)(a4 + 24);
    *(_QWORD *)(a3 + 40) = v14;
    *(_OWORD *)(a4 + 24) = v13;
    *(_QWORD *)(a4 + 40) = v12;
    LOBYTE(v12) = *(_BYTE *)(a3 + 48);
    *(_BYTE *)(a3 + 48) = *(_BYTE *)(a4 + 48);
    *(_BYTE *)(a4 + 48) = v12;
    if (reality_archive_file_pack(char const*,char const*,BOOL)::$_0::operator()(a3, a2))
    {
      v15 = *(_QWORD *)(a2 + 16);
      v16 = *(_OWORD *)a2;
      v17 = *(_QWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_QWORD *)(a2 + 16) = v17;
      *(_OWORD *)a3 = v16;
      *(_QWORD *)(a3 + 16) = v15;
      v18 = *(_QWORD *)(a2 + 40);
      v19 = *(_OWORD *)(a2 + 24);
      v20 = *(_QWORD *)(a3 + 40);
      *(_OWORD *)(a2 + 24) = *(_OWORD *)(a3 + 24);
      *(_QWORD *)(a2 + 40) = v20;
      *(_OWORD *)(a3 + 24) = v19;
      *(_QWORD *)(a3 + 40) = v18;
      v21 = *(_BYTE *)(a2 + 48);
      *(_BYTE *)(a2 + 48) = *(_BYTE *)(a3 + 48);
      *(_BYTE *)(a3 + 48) = v21;
      if (reality_archive_file_pack(char const*,char const*,BOOL)::$_0::operator()(a2, a1))
      {
        v22 = *(_QWORD *)(a1 + 16);
        v23 = *(_OWORD *)a1;
        v24 = *(_QWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_QWORD *)(a1 + 16) = v24;
        *(_OWORD *)a2 = v23;
        *(_QWORD *)(a2 + 16) = v22;
        v25 = *(_QWORD *)(a1 + 40);
        result = *(__n128 *)(a1 + 24);
        v26 = *(_QWORD *)(a2 + 40);
        *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
        *(_QWORD *)(a1 + 40) = v26;
        *(__n128 *)(a2 + 24) = result;
        *(_QWORD *)(a2 + 40) = v25;
        v27 = *(_BYTE *)(a1 + 48);
        *(_BYTE *)(a1 + 48) = *(_BYTE *)(a2 + 48);
        *(_BYTE *)(a2 + 48) = v27;
      }
    }
  }
  return result;
}

__n128 std::__memberwise_forward_assign[abi:nn180100]<std::tuple<std::string,std::string,BOOL>,std::tuple<std::string,std::string,BOOL>,std::string,std::string,BOOL,0ul,1ul,2ul>(uint64_t a1, __int128 *a2)
{
  __int128 v4;
  void **v5;
  __n128 result;

  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  v4 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v4;
  *((_BYTE *)a2 + 23) = 0;
  *(_BYTE *)a2 = 0;
  v5 = (void **)(a1 + 24);
  if (*(char *)(a1 + 47) < 0)
    operator delete(*v5);
  result = *(__n128 *)((char *)a2 + 24);
  *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 5);
  *(__n128 *)v5 = result;
  *((_BYTE *)a2 + 47) = 0;
  *((_BYTE *)a2 + 24) = 0;
  *(_BYTE *)(a1 + 48) = *((_BYTE *)a2 + 48);
  return result;
}

uint64_t re::NamedFileRegistry::registerFileNameAlias(os_unfair_lock_s *a1, uint64_t a2, const char *a3)
{
  const char *v6;
  char *v7;
  const char *v8;
  re *v9;
  int v10;
  NSObject *v11;
  _BOOL4 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD v21[2];
  char v22[8];
  uint64_t v23;
  char v24;
  _BYTE v25[7];
  const char *v26;
  uint8_t buf[4];
  uint64_t v28;
  __int16 v29;
  char *v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  re::DynamicString::DynamicString((re::DynamicString *)v21, (const re::DynamicString *)a2);
  re::NamedFileRegistry::tryGetFilePathFor(a1, (uint64_t)v21, v22);
  if (*(_QWORD *)&v21[0])
  {
    if ((BYTE8(v21[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v21[0] + 40))();
    memset(v21, 0, sizeof(v21));
  }
  if (!v22[0])
  {
    os_unfair_lock_lock(a1);
    re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>((uint64_t)&a1[2], (re::DynamicString *)a2, (const re::DynamicString *)a3);
    os_unfair_lock_unlock(a1);
LABEL_32:
    v19 = 1;
    goto LABEL_33;
  }
  if ((v24 & 1) != 0)
    v6 = v26;
  else
    v6 = v25;
  v7 = (char *)(a3 + 9);
  if ((*((_QWORD *)a3 + 1) & 1) != 0)
    v8 = (const char *)*((_QWORD *)a3 + 2);
  else
    v8 = a3 + 9;
  v9 = (re *)strcmp(v6, v8);
  v10 = (int)v9;
  v11 = *re::assetsLogObjects(v9);
  v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
  if (!v10)
  {
    if (v12)
    {
      if ((*(_BYTE *)(a2 + 8) & 1) != 0)
        v17 = *(_QWORD *)(a2 + 16);
      else
        v17 = a2 + 9;
      if ((a3[8] & 1) != 0)
        v7 = (char *)*((_QWORD *)a3 + 2);
      *(_DWORD *)buf = 136315394;
      v28 = v17;
      v29 = 2080;
      v30 = v7;
      _os_log_impl(&dword_224FE9000, v11, OS_LOG_TYPE_DEFAULT, "FileNameAlias '%s' already registered for file '%s'", buf, 0x16u);
    }
    goto LABEL_32;
  }
  if (v12)
  {
    v15 = *(_QWORD *)(a2 + 8);
    if ((v15 & 1) != 0)
      v16 = *(_QWORD *)(a2 + 16);
    else
      v16 = a2 + 9;
    if ((a3[8] & 1) != 0)
      v7 = (char *)*((_QWORD *)a3 + 2);
    if ((v15 & 1) != 0)
      v18 = *(_QWORD *)(a2 + 16);
    else
      v18 = a2 + 9;
    *(_DWORD *)buf = 136315650;
    v28 = v16;
    v29 = 2080;
    v30 = v7;
    v31 = 2080;
    v32 = v18;
    _os_log_impl(&dword_224FE9000, v11, OS_LOG_TYPE_DEFAULT, "Failed to register '%s' alias for file '%s'! FileAlias '%s' already registered for different file.", buf, 0x20u);
  }
  v19 = 0;
LABEL_33:
  if (v22[0] && v23 && (v24 & 1) != 0)
    (*(void (**)(uint64_t, const char *, uint64_t, uint64_t))(*(_QWORD *)v23 + 40))(v23, v26, v13, v14);
  return v19;
}

void re::NamedFileRegistry::tryGetFilePathFor(os_unfair_lock_s *a1@<X0>, uint64_t a2@<X1>, _BYTE *a3@<X8>)
{
  const re::DynamicString *v6;

  os_unfair_lock_lock(a1);
  v6 = (const re::DynamicString *)re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)&a1[2], a2);
  if (v6)
  {
    *a3 = 1;
    re::DynamicString::DynamicString((re::DynamicString *)(a3 + 8), v6);
  }
  else
  {
    *a3 = 0;
  }
  os_unfair_lock_unlock(a1);
}

void re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_4, 4 * v2);
    if (*(_DWORD *)(a1 + 32))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 16) + v3);
        ++v4;
        v3 += 80;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

uint64_t re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::DynamicString&>(uint64_t a1, re::DynamicString *a2, const re::DynamicString *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  char v14;

  v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v14, (uint64_t)a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v11 = re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<re::DynamicString&>(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 80 * v11;
    return v12 + 48;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (!re::DynamicString::operator==(v10 + 80 * v9 + 16, (uint64_t)a2))
  {
    v9 = *(_DWORD *)(v10 + 80 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v10 + 80 * v9;
  return v12 + 48;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<re::DynamicString&>(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, const re::DynamicString *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::DynamicString,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 80 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 80 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 16), a4);
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 48), a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

re::RealityFileWriter *re::RealityFileWriter::RealityFileWriter(re::RealityFileWriter *this)
{
  _anonymous_namespace_ *v2;
  re *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v8;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24ED2CBB8;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_DWORD *)this + 14) = 0;
  *(_QWORD *)((char *)this + 60) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 0;
  *(_QWORD *)((char *)this + 108) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((_DWORD *)this + 38) = 0;
  *(_QWORD *)((char *)this + 156) = 0x7FFFFFFFLL;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  re::DynamicString::setCapacity((_QWORD *)this + 21, 0);
  *((_DWORD *)this + 58) = 0;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_QWORD *)((char *)this + 236) = 0x7FFFFFFFLL;
  v3 = re::RealityArchiveWriter::RealityArchiveWriter((re::RealityFileWriter *)((char *)this + 248));
  *((_DWORD *)this + 88) = 0;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *((_DWORD *)this + 98) = 0;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 27) = 0u;
  *((_DWORD *)this + 112) = 0;
  *(_QWORD *)((char *)this + 452) = 0x7FFFFFFFLL;
  *((_OWORD *)this + 29) = 0u;
  *((_OWORD *)this + 30) = 0u;
  *((_DWORD *)this + 124) = 0;
  *(_QWORD *)((char *)this + 500) = 0x7FFFFFFFLL;
  *((_BYTE *)this + 512) = 0;
  *(_OWORD *)((char *)this + 536) = 0u;
  *(_OWORD *)((char *)this + 552) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  re::make::shared::object<re::RealityFileWriter::WritingParameters>(v3, &v8);
  v4 = *((_QWORD *)this + 40);
  v5 = v8;
  *((_QWORD *)this + 40) = v8;
  v8 = v4;
  if (v4)
  {

    v5 = *((_QWORD *)this + 40);
  }
  if (*(uint64_t *)(v5 + 24) < 3)
    v6 = 1;
  else
    v6 = 2;
  *((_DWORD *)this + 78) = v6;
  return this;
}

uint64_t re::RealityFileWriter::RealityFileWriter(uint64_t a1, uint64_t *a2)
{
  _anonymous_namespace_ *v4;
  int v5;

  ArcSharedObject::ArcSharedObject((ArcSharedObject *)a1, 0);
  *(_QWORD *)a1 = &off_24ED2CBB8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_DWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 60) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 108) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_DWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 156) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  re::DynamicString::setCapacity((_QWORD *)(a1 + 168), 0);
  *(_DWORD *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_QWORD *)(a1 + 236) = 0x7FFFFFFFLL;
  re::RealityArchiveWriter::RealityArchiveWriter((re::RealityArchiveWriter *)(a1 + 248));
  *(_DWORD *)(a1 + 352) = 0;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_DWORD *)(a1 + 392) = 0;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_DWORD *)(a1 + 448) = 0;
  *(_QWORD *)(a1 + 452) = 0x7FFFFFFFLL;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_DWORD *)(a1 + 496) = 0;
  *(_QWORD *)(a1 + 500) = 0x7FFFFFFFLL;
  *(_BYTE *)(a1 + 512) = 0;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  re::SharedPtr<re::SkeletalPoseJointDefinition>::reset((uint64_t *)(a1 + 320), *a2);
  if (*(uint64_t *)(*(_QWORD *)(a1 + 320) + 24) < 3)
    v5 = 1;
  else
    v5 = 2;
  *(_DWORD *)(a1 + 312) = v5;
  return a1;
}

void re::RealityFileWriter::~RealityFileWriter(re::RealityFileWriter *this)
{
  __n128 v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  uint64_t v14;
  double v15;

  *(_QWORD *)this = &off_24ED2CBB8;
  re::FixedArray<re::DynamicString>::deinit((_QWORD *)this + 68);
  re::FixedArray<re::DynamicString>::deinit((_QWORD *)this + 65);
  re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 58);
  v2.n128_f64[0] = re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 52);
  v3 = *((_QWORD *)this + 51);
  if (v3)
  {

    *((_QWORD *)this + 51) = 0;
  }
  v4 = *((_QWORD *)this + 46);
  if (v4)
  {
    v5 = *((_QWORD *)this + 50);
    if (v5)
    {
      v6 = *((_QWORD *)this + 48);
      if (v6)
      {
        v7 = 40 * v6;
        do
        {
          re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v5);
          v5 += 40;
          v7 -= 40;
        }
        while (v7);
        v4 = *((_QWORD *)this + 46);
        v5 = *((_QWORD *)this + 50);
      }
      (*(void (**)(uint64_t, uint64_t, __n128))(*(_QWORD *)v4 + 40))(v4, v5, v2);
    }
    *((_QWORD *)this + 50) = 0;
    *((_QWORD *)this + 47) = 0;
    *((_QWORD *)this + 48) = 0;
    *((_QWORD *)this + 46) = 0;
    ++*((_DWORD *)this + 98);
  }
  v8 = *((_QWORD *)this + 41);
  if (v8)
  {
    v9 = *((_QWORD *)this + 45);
    if (v9)
    {
      v10 = *((_QWORD *)this + 43);
      if (v10)
      {
        v11 = 40 * v10;
        do
        {
          re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v9);
          v9 += 40;
          v11 -= 40;
        }
        while (v11);
        v8 = *((_QWORD *)this + 41);
        v9 = *((_QWORD *)this + 45);
      }
      (*(void (**)(uint64_t, uint64_t, __n128))(*(_QWORD *)v8 + 40))(v8, v9, v2);
    }
    *((_QWORD *)this + 45) = 0;
    *((_QWORD *)this + 42) = 0;
    *((_QWORD *)this + 43) = 0;
    *((_QWORD *)this + 41) = 0;
    ++*((_DWORD *)this + 88);
  }
  v12 = *((_QWORD *)this + 40);
  if (v12)
  {

    *((_QWORD *)this + 40) = 0;
  }
  re::RealityArchiveWriter::~RealityArchiveWriter((re::RealityFileWriter *)((char *)this + 248));
  v13 = re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 25);
  v14 = *((_QWORD *)this + 21);
  if (v14)
  {
    if ((*((_BYTE *)this + 176) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v14 + 40))(v14, *((_QWORD *)this + 23), v13);
    *(_OWORD *)((char *)this + 168) = 0u;
    *(_OWORD *)((char *)this + 184) = 0u;
  }
  v15 = re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)this + 15);
  re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 9, v15);
  re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 3);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::RealityFileWriter::~RealityFileWriter(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::RealityFileWriter::setOrClearMetadataString(_anonymous_namespace_ *a1, StringID *a2, const char *a3)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v7;
  char v8;

  v4 = (uint64_t)a1 + 464;
  if (!a3)
    return re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove((uint64_t)a1 + 464, a2);
  re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addOrReplace(v4, a2, (re::DynamicString *)&v7);
  result = v7;
  if (v7)
  {
    if ((v8 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v7 + 40))();
  }
  return result;
}

uint64_t re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addOrReplace(uint64_t a1, StringID *a2, re::DynamicString *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;

  v6 = 0xBF58476D1CE4E5B9 * ((*(_QWORD *)&a2->var0 >> 31) ^ (*(_QWORD *)&a2->var0 >> 1));
  v7 = (0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) ^ ((0x94D049BB133111EBLL * (v6 ^ (v6 >> 27))) >> 31);
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v7 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v11 = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::addAsMove(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 56 * v11;
    return v12 + 24;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (!re::StringID::operator==((_QWORD *)(v10 + 56 * v9 + 8), a2))
  {
    v9 = *(_DWORD *)(v10 + 56 * v9) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  re::DynamicString::operator=((re::DynamicString *)(v10 + 56 * v9 + 24), a3);
  ++*(_DWORD *)(a1 + 40);
  v12 = *(_QWORD *)(a1 + 16) + 56 * v9;
  return v12 + 24;
}

uint64_t re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::remove(uint64_t a1, _QWORD *a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  unsigned int v10;
  int v11;
  int v12;

  if (!*(_QWORD *)a1)
    return 0;
  v4 = 0xBF58476D1CE4E5B9 * ((*a2 >> 31) ^ (*a2 >> 1));
  v5 = ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) ^ ((0x94D049BB133111EBLL * (v4 ^ (v4 >> 27))) >> 31))
     % *(unsigned int *)(a1 + 24);
  v6 = *(_QWORD *)(a1 + 8);
  v7 = *(unsigned int *)(v6 + 4 * v5);
  if ((_DWORD)v7 == 0x7FFFFFFF)
    return 0;
  v9 = *(_QWORD *)(a1 + 16);
  if (!re::StringID::operator==((_QWORD *)(v9 + 56 * v7 + 8), a2))
  {
    while (1)
    {
      v10 = v7;
      v11 = *(_DWORD *)(v9 + 56 * v7);
      v7 = v11 & 0x7FFFFFFF;
      if ((v11 & 0x7FFFFFFF) == 0x7FFFFFFF)
        return 0;
      if (re::StringID::operator==((_QWORD *)(v9 + 56 * v7 + 8), a2))
      {
        *(_DWORD *)(v9 + 56 * v10) = *(_DWORD *)(v9 + 56 * v10) & 0x80000000 | *(_DWORD *)(v9
                                                                                             + 56 * v7) & 0x7FFFFFFF;
        goto LABEL_9;
      }
    }
  }
  *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v9 + 56 * v7) & 0x7FFFFFFF;
LABEL_9:
  re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::EntryWithoutHash::free(*(_QWORD *)(a1 + 16) + 56 * v7);
  v12 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v7) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v7) & 0x80000000 | *(_DWORD *)(a1 + 36);
  --*(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 36) = v7;
  *(_DWORD *)(a1 + 40) = v12 + 1;
  return 1;
}

re::DynamicString *re::RealityFileWriter::getMetadataString@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X1>, _BYTE *a3@<X8>)
{
  re::DynamicString *result;

  result = (re::DynamicString *)re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::tryGet(a1 + 464, a2);
  if (result)
  {
    *a3 = 1;
    return re::DynamicString::DynamicString((re::DynamicString *)(a3 + 8), result);
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

uint64_t re::RealityFileWriter::open@<X0>(re::RealityFileWriter *this@<X0>, const re::DynamicString *a2@<X1>, uint64_t a3@<X8>)
{
  const char *v4;
  uint64_t result;
  char *v6;
  re::RealityArchiveWriter *v9;
  re *v10;
  re *v11;
  _anonymous_namespace_ *v12;
  _anonymous_namespace_ *v13;
  _anonymous_namespace_ *v14;
  id v15;
  id v16;
  void (**v17)(ArcSharedObject *__hidden);
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 v22;
  re *v23;
  const __CFData *Mutable;
  _anonymous_namespace_ *v25;
  id v26;
  void *v27;
  __n128 v28;
  id v29;
  void (**v30)(ArcSharedObject *__hidden);
  _BYTE v31[8];
  char *v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40[4];
  int v41;
  uint64_t v42;
  int v43;
  _BYTE v44[8];
  uint64_t v45;
  char v46;
  uint64_t v47;
  char v48;
  _BYTE v49[7];
  re *v50;
  void *v51;
  const char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  _QWORD v57[4];
  char v58;
  __int128 v59;

  if (*((_QWORD *)this + 34))
  {
    v4 = v52;
    v52 = 0;
    *(_BYTE *)a3 = 0;
    *(_QWORD *)(a3 + 8) = v4;

    result = (uint64_t)v30;
    if (v30 && (v31[0] & 1) != 0)
    {
      v6 = v32;
      return (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)result + 40))(result, v6);
    }
    return result;
  }
  v9 = (re::RealityFileWriter *)((char *)this + 248);
  if ((*((_QWORD *)a2 + 1) & 1) != 0)
    v10 = (re *)*((_QWORD *)a2 + 2);
  else
    v10 = (const re::DynamicString *)((char *)a2 + 9);
  re::filePathWithURL(v10, (re::DynamicString *)&v47);
  if ((v48 & 1) != 0)
    v11 = v50;
  else
    v11 = (re *)v49;
  re::RealityArchiveWriter::open(v9, v11, (uint64_t)v44);
  if (!v44[0])
  {
    v17 = v30;
    v30 = 0;
    *(_BYTE *)a3 = 0;
    *(_QWORD *)(a3 + 8) = v17;

    goto LABEL_55;
  }
  v12 = re::DynamicString::operator=((re::RealityFileWriter *)((char *)this + 168), a2);
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)&v30, 0);
  v30 = off_24ED2CCB0;
  v33 = 0u;
  v34 = 0u;
  v14 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v33, 0);
  v36 = 0u;
  v35 = 0u;
  re::DynamicString::setCapacity(&v35, 0);
  v37 = 2;
  memset(v40, 0, sizeof(v40));
  v42 = 0x7FFFFFFFLL;
  v41 = 0;
  v43 = 0;
  v52 = "com.apple.RealityKit";
  v53 = 20;
  re::DynamicString::operator=((re::DynamicString *)&v33, (uint64_t)&v52);
  re::Bundle::realityKitFramework((uint64_t)&v52);
  if ((_BYTE)v52)
    v15 = (id)v53;
  else
    v15 = 0;
  v16 = v15;
  v29 = v16;
  if ((_BYTE)v52)

  if (v29)
  {
    re::Bundle::versionString(&v29, (re::DynamicString *)&v52);
  }
  else
  {
  }
  re::DynamicString::operator=((re::DynamicString *)&v35, (re::DynamicString *)&v52);
  if (v52 && (v53 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v52 + 40))();
  v18 = *((_QWORD *)this + 40);
  v19 = *(_QWORD *)(v18 + 24);
  v20 = *(unsigned int *)(v18 + 36);
  if (v19 <= 6 && v20 >= 2)
  {
    re::DynamicString::format((re::DynamicString *)"The target platform %u cannot be used for reality file version %lld, because older REKit builds did not recognize target platform specificatons.", (re::DynamicString *)&v52, v20, v19);
    v21 = v57[0];
    v57[0] = 0;
    *(_BYTE *)a3 = 0;
    *(_QWORD *)(a3 + 8) = v21;

    if (v52 && (v53 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v52 + 40))();
    goto LABEL_46;
  }
  v38 = v19;
  v39 = 0;
  v43 = v20;
  re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=((uint64_t)v40, (uint64_t)this + 464);
  if ((v22 & 1) == 0
  {
    re::introspect<re::RealityFileHeader>(void)::info = (_UNKNOWN *)re::introspect_RealityFileHeader(0);
  }
  v59 = *((_OWORD *)re::introspect<re::RealityFileHeader>(void)::info + 2);
  v23 = (re *)v59;
  if (!(_QWORD)v59)
  {
    re::DynamicString::format((re::DynamicString *)"Type of object for file \"%s\" has not been registered", (re::DynamicString *)&v52, "header.json");
    v26 = (id)v57[0];
    v57[0] = 0;

    if (v52 && (v53 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v52 + 40))();
    goto LABEL_45;
  }
  Mutable = CFDataCreateMutable(0, 0);
  re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v58);
  re::TypeRegistry::typeInfo(v23, (re **)&v59, &v52);
  v25 = (_anonymous_namespace_ *)re::TypeInfo::TypeInfo((uint64_t)v57, (uint64_t)&v53);
  if ((_BYTE)v52)
  {
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v58);
  }
  else
  {
    v27 = v51;
    v51 = 0;

    if (!(_BYTE)v52 && v55 && (v56 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v55 + 40))();
    re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v58);
    if (v27)
    {
      CFRelease(Mutable);
LABEL_44:
      v26 = v27;

LABEL_45:
      *(_BYTE *)a3 = 0;
      *(_QWORD *)(a3 + 8) = v26;
      goto LABEL_46;
    }
  }
  re::RealityArchiveWriter::writeEntry((uint64_t)v9, (uint64_t)"header.json", Mutable, 1, (uint64_t)&v52);
  if (!(_BYTE)v52)
  {
    v27 = (void *)v57[0];
    v57[0] = 0;

    if (!(_BYTE)v52 && v53 && (v54 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v53 + 40))();
    CFRelease(Mutable);
    if (!v27)
      goto LABEL_35;
    goto LABEL_44;
  }
  CFRelease(Mutable);
LABEL_35:
  *(_BYTE *)a3 = 1;
LABEL_46:

  v30 = off_24ED2CCB0;
  v28.n128_f64[0] = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v40);
  if ((_QWORD)v35)
  {
    if ((BYTE8(v35) & 1) != 0)
      (*(void (**)(double))(*(_QWORD *)v35 + 40))(v28.n128_f64[0]);
    v28 = 0uLL;
    v35 = 0u;
    v36 = 0u;
  }
  if ((_QWORD)v33)
  {
    if ((BYTE8(v33) & 1) != 0)
      (*(void (**)(__n128))(*(_QWORD *)v33 + 40))(v28);
    v33 = 0u;
    v34 = 0u;
  }
  v30 = &off_24ED426B8;
  objc_destructInstance(v31);
LABEL_55:
  if (!v44[0] && v45 && (v46 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v45 + 40))();
  result = v47;
  if (v47 && (v48 & 1) != 0)
  {
    v6 = (char *)v50;
    return (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)result + 40))(result, v6);
  }
  return result;
}

void `anonymous namespace'::makeError(__CFString *this@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v4 = *(_QWORD *)(a2 + 8);
  v5 = v4 >> 1;
  if ((v4 & 1) == 0)
    v5 = v4 >> 1;
  if (v5)
  {
    if ((v4 & 1) != 0)
      v6 = *(_QWORD *)(a2 + 16);
    else
      v6 = a2 + 9;
    re::WrappedError::make((re::WrappedError *)CFSTR("RERealityFileWriterErrorDomain"), this, v6, a3);
  }
  else
  {
    re::WrappedError::make((re::WrappedError *)CFSTR("RERealityFileWriterErrorDomain"), this, 0, a3);
  }
}

{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;

  v4 = *(_QWORD *)(a2 + 8);
  v5 = v4 >> 1;
  if ((v4 & 1) == 0)
    v5 = v4 >> 1;
  if (v5)
  {
    if ((v4 & 1) != 0)
      v6 = *(_QWORD *)(a2 + 16);
    else
      v6 = a2 + 9;
    re::WrappedError::make((re::WrappedError *)CFSTR("RERealityFileErrorDomain"), this, v6, a3);
  }
  else
  {
    re::WrappedError::make((re::WrappedError *)CFSTR("RERealityFileErrorDomain"), this, 0, a3);
  }
}

void re::RealityFileHeader::~RealityFileHeader(re::RealityFileHeader *this)
{
  __n128 v2;
  uint64_t v3;
  _QWORD *v4;

  *(_QWORD *)this = off_24ED2CCB0;
  v2.n128_f64[0] = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 13);
  v3 = *((_QWORD *)this + 7);
  v4 = (_QWORD *)((char *)this + 24);
  if (v3)
  {
    if ((*((_BYTE *)this + 64) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 9), v2.n128_f64[0]);
    v2 = 0uLL;
    *(_OWORD *)((char *)this + 56) = 0u;
    *(_OWORD *)((char *)this + 72) = 0u;
  }
  if (*v4)
  {
    if ((*((_BYTE *)this + 32) & 1) != 0)
      (*(void (**)(_QWORD, _QWORD, __n128))(*(_QWORD *)*v4 + 40))(*v4, *((_QWORD *)this + 5), v2);
    *(_OWORD *)v4 = 0u;
    *(_OWORD *)((char *)this + 40) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  __n128 v2;
  uint64_t v3;
  _QWORD *v4;

  *(_QWORD *)this = off_24ED2CCB0;
  v2.n128_f64[0] = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 13);
  v3 = *((_QWORD *)this + 7);
  v4 = (_QWORD *)((char *)this + 24);
  if (v3)
  {
    if ((*((_BYTE *)this + 64) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 9), v2.n128_f64[0]);
    v2 = 0uLL;
    *(_OWORD *)((char *)this + 56) = 0u;
    *(_OWORD *)((char *)this + 72) = 0u;
  }
  if (*v4)
  {
    if ((*((_BYTE *)this + 32) & 1) != 0)
      (*(void (**)(_QWORD, _QWORD, __n128))(*(_QWORD *)*v4 + 40))(*v4, *((_QWORD *)this + 5), v2);
    *(_OWORD *)v4 = 0u;
    *(_OWORD *)((char *)this + 40) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

BOOL re::RealityFileWriter::isAssetWritten(re::RealityFileWriter *this, const re::AssetHandle *a2)
{
  re::DynamicString *v3;
  uint64_t v4;
  _BOOL8 v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = (re::DynamicString *)re::AssetHandle::legacy_assetPath(a2);
  v4 = *((_QWORD *)v3 + 1);
  v10 = 0;
  v11 = 0;
  v8 = v4;
  v9 = 0;
  re::DynamicString::setCapacity(&v8, 0);
  re::AssetPath::fullAssetPath(v3, (re::DynamicString *)&v8);
  re::RealityFileWriter::AssetInfoTable::tryGetAssetInfo((re::RealityFileWriter *)((char *)this + 24), (const re::DynamicString *)&v8, &v7);
  if (v7)
  {
    v5 = *(_DWORD *)(v7 + 24) == 1;

  }
  else
  {
    v5 = 0;
  }
  if (v8 && (v9 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v8 + 40))();
  return v5;
}

uint64_t *re::RealityFileWriter::AssetInfoTable::tryGetAssetInfo@<X0>(re::RealityFileWriter::AssetInfoTable *this@<X0>, const re::DynamicString *a2@<X1>, uint64_t *a3@<X8>)
{
  uint64_t *result;
  uint64_t v5;

  result = (uint64_t *)re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)this, (uint64_t)a2);
  if (result)
  {
    v5 = *result;
    *a3 = *result;
    if (v5)
      return (uint64_t *)(id)(v5 + 8);
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

uint64_t re::RealityFileWriter::writeAsset(uint64_t a1, re::AssetHandle *a2, re::RealityFileWriter::AssetWriteResult **a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _anonymous_namespace_ *v9;
  re::RealityFileWriter::AssetWriteResult *v10;
  re::RealityFileWriter::AssetWriteResult *v11;
  char *v12;
  _DWORD *v13;
  char *v14;
  unsigned int v15;
  uint64_t v16;
  int *v17;
  int v18;
  uint64_t v19;
  re::RealityFileWriter::AssetWriteResult *v20;
  char *v21;
  void *v22;
  _DWORD *v23;
  int v24;
  id v25;
  re::RealityFileWriter::AssetWriteResult *v26;
  char *v27;
  id v28;
  void *v29;
  _DWORD *v30;
  int v31;
  id v32;
  re::RealityFileWriter::AssetWriteResult *v33;
  void *v34;
  char *v35;
  id v36;
  id v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  re::RealityFileWriter::AssetWriteResult *v42;
  char *v43;
  re::RealityFileWriter::AssetWriteResult *v44;
  char *v45;
  re::RealityFileWriter::AssetWriteResult *v46;
  char *v47;
  re::RealityFileWriter::AssetWriteResult *v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  int v53;
  void *v54;
  id v55;
  const re::DynamicString *v56;
  re::RealityFileWriter::AssetWriteResult *v57;
  char *v58;
  int v59;
  re::RealityFileWriter::AssetWriteResult *v60;
  char *v61;
  re::RealityFileWriter::AssetWriteResult *v62;
  char *v63;
  id v64;
  int v65;
  id v67;
  _DWORD *v68;
  id v69;
  _BYTE v70[2];
  _DWORD *v71;
  id v72;
  _DWORD *v73;
  id v74;
  char *v75;
  _BYTE v76[8];
  id v77;
  id v78;
  _BYTE v79[2];
  char *v80;
  _BYTE v81[8];
  id v82;
  char *v83;
  _BYTE v84[8];
  char *v85;
  uint64_t v86;
  id v87;
  id v88;
  _BYTE v89[2];
  _DWORD *v90;
  _BYTE v91[8];
  id v92;
  id v93;
  id v94;
  uint64_t v95;
  id v96;
  char *v97;
  _BYTE v98[8];
  char *v99;
  uint64_t v100;
  id v101;
  id v102;
  __int128 v103;
  __int128 v104;
  unsigned int v105;
  uint64_t v106;
  id v107;
  _BYTE v108[8];
  id v109;

  if (*a3)
    re::RealityFileWriter::AssetWriteResult::clear(*a3);
  if (v108[0])
  {
    v105 = 0;
    v103 = 0u;
    v104 = 0u;
    v106 = 0x7FFFFFFFLL;
    v6 = *(_QWORD *)(*((_QWORD *)a2 + 1) + 24);
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 328))(v6);
    v8 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v7 + 72))(v7, *(_QWORD *)(*(_QWORD *)(a1 + 320) + 24));
    v9 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, re::AssetHandle *, uint64_t))(*(_QWORD *)v6 + 320))(v6, a2, v8);
    if ((_DWORD)v9)
    {
      v10 = *a3;
      if (v10)
      {
        re::ObjCObject::operator=((id *)v10 + 12, &v102);
      }
      else
      {
      }

      if (v100 && (v101 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v100 + 40))();
      if (v10)

      re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)&v103);
      return 0;
    }
    re::RealityFileWriter::getOrMakeAssetInfo((re::RealityFileWriter *)v98, (const re::AssetHandle *)a1, a2);
    if (!v98[0])
    {
      v20 = *a3;
      if (*a3)
      {
        v21 = (char *)v20 + 8;
        v97 = v99;
        re::ObjCObject::operator=((id *)v20 + 12, (id *)&v97);

      }
      else
      {
        v97 = v99;

      }
      v19 = 0;
      goto LABEL_118;
    }
    v13 = v99;
    if (v99)
      v14 = v99 + 8;
    if (v13[6] == 1)
      goto LABEL_13;
    if ((**(unsigned int (***)(uint64_t, re::AssetHandle *))v7)(v7, a2))
    {
      re::AssetHandle::AssetHandle((re::AssetHandle *)&v95, a2);
      if ((*(unsigned int (**)(uint64_t, uint64_t *, _QWORD))(*(_QWORD *)v7 + 8))(v7, &v95, *(_QWORD *)(*(_QWORD *)(a1 + 320) + 24)))
      {
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, _QWORD))(*(_QWORD *)v7 + 16))(&v100, v7, &v95, *(_QWORD *)(*(_QWORD *)(a1 + 320) + 24));
        if (!(_BYTE)v100)
        {
          v48 = *a3;
          if (*a3)
          {
            v49 = (char *)v48 + 8;
            v94 = v101;
            re::ObjCObject::operator=((id *)v48 + 12, &v94);

          }
          else
          {
            v94 = v101;

          }
          re::Result<re::AssetHandle,re::WrappedError>::~Result((unsigned __int8 *)&v100);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)&v95);
          goto LABEL_116;
        }
        re::AssetHandle::operator=(&v95, (uint64_t *)&v101);
        re::Result<re::AssetHandle,re::WrappedError>::~Result((unsigned __int8 *)&v100);
      }
      re::RealityFileWriter::remapSceneAsset((re::RealityFileWriter *)&v100, *(const re::AssetHandle **)(a1 + 408), (const re::DynamicString *)&v95, (uint64_t)a2 + 56);
      if (!(_BYTE)v100)
      {
        v44 = *a3;
        if (*a3)
        {
          v45 = (char *)v44 + 8;
          v93 = v101;
          re::ObjCObject::operator=((id *)v44 + 12, &v93);

        }
        else
        {
          v93 = v101;

        }
        goto LABEL_114;
      }
      re::AssetHandle::operator=(&v95, (uint64_t *)&v101);
      v90 = v13;
      v22 = v13 + 2;
      v23 = v13 + 2;
      v24 = *((unsigned __int8 *)a2 + 89);
      v89[0] = *((_BYTE *)a2 + 90);
      if (v89[0])
        v89[1] = *((_BYTE *)a2 + 91);
      re::RealityFileWriter::findDependenciesAndSaveAsset((uint64_t)v91, a1, v7, (const re::AssetHandle *)&v95, (uint64_t *)&v90, (uint64_t)&v103, v24, v89);

      v90 = 0;
      if (!v91[0])
      {
        v46 = *a3;
        if (*a3)
        {
          v47 = (char *)v46 + 8;
          v88 = v92;
          re::ObjCObject::operator=((id *)v46 + 12, &v88);

        }
        else
        {
          v88 = v92;

        }
        goto LABEL_114;
      }
      if (((*(uint64_t (**)(uint64_t, uint64_t *, _QWORD))(*(_QWORD *)v7 + 40))(v7, &v95, *(_QWORD *)(*(_QWORD *)(a1 + 320) + 24)) & 1) != 0)
      {
        v73 = v13;
        v25 = v22;
        re::RealityFileWriter::assignSceneSettingsToAssetInfo((_anonymous_namespace_ *)&v86, (re::DynamicString *)a1, (uint64_t *)&v73, (uint64_t)a2, 1);

        v73 = 0;
        if (!(_BYTE)v86)
        {
          v26 = *a3;
          if (*a3)
          {
            v27 = (char *)v26 + 8;
            v28 = v87;
            v72 = v28;
            re::ObjCObject::operator=((id *)v26 + 12, &v72);

          }
          else
          {
            v28 = v87;
            v72 = v28;

          }
          goto LABEL_114;
        }
LABEL_120:
        v65 = 0;
LABEL_115:
        re::Result<re::AssetHandle,re::WrappedError>::~Result((unsigned __int8 *)&v100);
        re::AssetHandle::~AssetHandle((re::AssetHandle *)&v95);
        if (v65)
          goto LABEL_116;
LABEL_13:
        if (*a3)
        {
          re::DynamicString::operator=((re::RealityFileWriter::AssetWriteResult *)((char *)*a3 + 24), (re::DynamicString *)(v13 + 8));
          v15 = v105;
          if (v105)
          {
            v16 = 0;
            v17 = (int *)(v104 + 8);
            while (1)
            {
              v18 = *v17;
              v17 += 10;
              if (v18 < 0)
                break;
              if (v105 == ++v16)
              {
                LODWORD(v16) = v105;
                break;
              }
            }
          }
          else
          {
            LODWORD(v16) = 0;
          }
          if (v105 != (_DWORD)v16)
          {
            v38 = v16;
            v39 = v104;
            do
            {
              re::AssetHandle::AssetHandle((re::AssetHandle *)&v100, (const re::AssetHandle *)(v39 + 40 * v38 + 16));
              re::DynamicArray<re::AssetHandle>::add((re::RealityFileWriter::AssetWriteResult *)((char *)*a3 + 56), (re::AssetHandle *)&v100);
              re::AssetHandle::~AssetHandle((re::AssetHandle *)&v100);
              v39 = v104;
              if (v105 <= (int)v16 + 1)
                v40 = v16 + 1;
              else
                v40 = v105;
              v41 = v16;
              while (1)
              {
                v38 = (v41 + 1);
                if (v40 - 1 == v41)
                  break;
                ++v41;
                LODWORD(v16) = v38;
                if ((*(_DWORD *)(v104 + 40 * v38 + 8) & 0x80000000) != 0)
                  goto LABEL_63;
              }
              LODWORD(v16) = v40;
LABEL_63:
              ;
            }
            while (v15 != (_DWORD)v16);
          }
          v19 = 1;
          if (!v13)
            goto LABEL_118;
        }
        else
        {
          v19 = 1;
        }
        goto LABEL_117;
      }
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *, _QWORD))(*(_QWORD *)v7 + 48))(&v86, v7, &v95, *(_QWORD *)(*(_QWORD *)(a1 + 320) + 24));
      re::RealityFileWriter::getOrMakeAssetInfo((re::RealityFileWriter *)v84, (const re::AssetHandle *)a1, (re::AssetHandle *)&v86);
      if (!v84[0])
      {
        v57 = *a3;
        if (*a3)
        {
          v58 = (char *)v57 + 8;
          v83 = v85;
          re::ObjCObject::operator=((id *)v57 + 12, (id *)&v83);

        }
        else
        {
          v83 = v85;

        }
        v59 = 1;
        goto LABEL_113;
      }
      v50 = v85;
      if (v85)
      {
        v51 = v85 + 8;
        v52 = v50 + 8;
      }
      v80 = v50;
      v53 = *((unsigned __int8 *)a2 + 89);
      v79[0] = *((_BYTE *)a2 + 90);
      if (v79[0])
        v79[1] = *((_BYTE *)a2 + 91);
      re::RealityFileWriter::findDependenciesAndSaveAsset((uint64_t)v81, a1, v7, (const re::AssetHandle *)&v86, (uint64_t *)&v80, (uint64_t)&v103, v53, v79);
      if (v50)
      {
        v54 = v50 + 8;

        v80 = 0;
        if (v81[0])
        {
          v75 = v50;
          v55 = v54;
          re::RealityFileWriter::assignSceneSettingsToAssetInfo((_anonymous_namespace_ *)v76, (re::DynamicString *)a1, (uint64_t *)&v75, (uint64_t)a2, 1);

          v75 = 0;
LABEL_96:
          if (v76[0])
          {
            re::RealityFileWriter::AssetInfo::addSceneVariant((re::RealityFileWriter::AssetInfo *)v50, (const re::DynamicString *)(v13 + 8), v56);
            v59 = 0;
            goto LABEL_111;
          }
          v62 = *a3;
          if (*a3)
          {
            v63 = (char *)v62 + 8;
            v64 = v77;
            v74 = v64;
            re::ObjCObject::operator=((id *)v62 + 12, &v74);

          }
          else
          {
            v64 = v77;
            v74 = v64;

          }
LABEL_110:
          v59 = 1;
LABEL_111:
          if (v50)

LABEL_113:
          re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v84);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)&v86);
          if (!v59)
            goto LABEL_120;
LABEL_114:
          v65 = 1;
          goto LABEL_115;
        }
      }
      else if (v81[0])
      {
        v75 = 0;
        re::RealityFileWriter::assignSceneSettingsToAssetInfo((_anonymous_namespace_ *)v76, (re::DynamicString *)a1, (uint64_t *)&v75, (uint64_t)a2, 1);
        goto LABEL_96;
      }
      v60 = *a3;
      if (*a3)
      {
        v61 = (char *)v60 + 8;
        v78 = v82;
        re::ObjCObject::operator=((id *)v60 + 12, &v78);

      }
      else
      {
        v78 = v82;

      }
      goto LABEL_110;
    }
    v71 = v13;
    v29 = v13 + 2;
    v30 = v13 + 2;
    v31 = *((unsigned __int8 *)a2 + 89);
    v70[0] = *((_BYTE *)a2 + 90);
    if (v70[0])
      v70[1] = *((_BYTE *)a2 + 91);
    re::RealityFileWriter::findDependenciesAndSaveAsset((uint64_t)&v100, a1, v7, a2, (uint64_t *)&v71, (uint64_t)&v103, v31, v70);

    v71 = 0;
    if ((_BYTE)v100)
    {
      v68 = v13;
      v32 = v29;
      re::RealityFileWriter::assignLabelToAssetInfo((re::DynamicString *)a1, (uint64_t *)&v68, (re::AssetHandle *)((char *)a2 + 56), (uint64_t)&v95);

      v68 = 0;
      if ((_BYTE)v95)
        goto LABEL_13;
      v33 = *a3;
      if (*a3)
      {
        v34 = (char *)v33 + 8;
        v35 = (char *)v33 + 8;
        v36 = v96;
        v67 = v36;
        re::ObjCObject::operator=((id *)v33 + 12, &v67);
        v37 = v67;
LABEL_68:

LABEL_87:
LABEL_116:
        v19 = 0;
LABEL_117:

LABEL_118:
        re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v98);
        re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)&v103);
        return v19;
      }
      v36 = v96;
      v67 = v36;
    }
    else
    {
      v42 = *a3;
      if (*a3)
      {
        v34 = (char *)v42 + 8;
        v43 = (char *)v42 + 8;
        v36 = v101;
        v69 = v36;
        re::ObjCObject::operator=((id *)v42 + 12, &v69);
        v37 = v69;
        goto LABEL_68;
      }
      v36 = v101;
      v69 = v36;
    }

    goto LABEL_87;
  }
  v11 = *a3;
  if (*a3)
  {
    v12 = (char *)v11 + 8;
    v107 = v109;
    re::ObjCObject::operator=((id *)v11 + 12, &v107);

  }
  else
  {
    v107 = v109;

  }
  return 0;
}

void re::RealityFileWriter::AssetWriteResult::clear(re::RealityFileWriter::AssetWriteResult *this)
{
  uint64_t v2;
  _BYTE *v3;
  void *v4;

  v2 = *((_QWORD *)this + 4);
  if ((v2 & 1) != 0)
  {
    *((_QWORD *)this + 4) = 1;
    v3 = (_BYTE *)*((_QWORD *)this + 5);
  }
  else
  {
    *((_BYTE *)this + 32) = v2 & 1;
    v3 = (char *)this + 33;
  }
  *v3 = 0;
  re::DynamicArray<re::AssetHandle>::clear((re::RealityFileWriter::AssetWriteResult *)((char *)this + 56));
  v4 = (void *)*((_QWORD *)this + 12);
  *((_QWORD *)this + 12) = 0;

}

_BYTE *`anonymous namespace'::checkAssetIsValid(_BYTE *this, const re::AssetHandle *a2)
{
  _BYTE *v2;
  uint64_t v3;
  unsigned int v4;
  re::DynamicString *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  re::DynamicString *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  _OWORD v17[2];
  uint64_t v18;

  v2 = this;
  v3 = *((_QWORD *)a2 + 1);
  if (v3 && *(_QWORD *)(v3 + 24))
  {
    v4 = atomic_load((unsigned int *)(v3 + 704));
    if (v4 == 2)
    {
      *this = 1;
      return this;
    }
    v9 = (re::DynamicString *)re::AssetHandle::legacy_assetPath(a2);
    v10 = *((_QWORD *)v9 + 1);
    v15 = 0;
    v16 = 0;
    v13 = v10;
    v14 = 0;
    re::DynamicString::setCapacity(&v13, 0);
    re::AssetPath::fullAssetPath(v9, (re::DynamicString *)&v13);
    if ((v14 & 1) != 0)
      v11 = v15;
    else
      v11 = (char *)&v14 + 1;
    re::DynamicString::format((re::DynamicString *)"The asset (%s) is not loaded.", (re::DynamicString *)v17, v11);
    v8 = 4;
  }
  else
  {
    v5 = (re::DynamicString *)re::AssetHandle::legacy_assetPath(a2);
    v6 = *((_QWORD *)v5 + 1);
    v15 = 0;
    v16 = 0;
    v13 = v6;
    v14 = 0;
    re::DynamicString::setCapacity(&v13, 0);
    re::AssetPath::fullAssetPath(v5, (re::DynamicString *)&v13);
    if ((v14 & 1) != 0)
      v7 = v15;
    else
      v7 = (char *)&v14 + 1;
    re::DynamicString::format((re::DynamicString *)"The asset (%s) is not bound to an AssetService.", (re::DynamicString *)v17, v7);
    v8 = 3;
  }
  v12 = v18;
  v18 = 0;
  *v2 = 0;
  *((_QWORD *)v2 + 1) = v12;

  if (*(_QWORD *)&v17[0])
  {
    if ((BYTE8(v17[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v17[0] + 40))();
    memset(v17, 0, sizeof(v17));
  }
  this = (_BYTE *)v13;
  if (v13)
  {
    if ((v14 & 1) != 0)
      return (_BYTE *)(*(uint64_t (**)(void))(*(_QWORD *)v13 + 40))();
  }
  return this;
}

uint64_t re::RealityFileWriter::getOrMakeAssetInfo(re::RealityFileWriter *this, const re::AssetHandle *a2, re::AssetHandle *a3)
{
  re::DynamicString *v6;
  uint64_t v7;
  __n128 v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11[6];
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v6 = (re::DynamicString *)re::AssetHandle::legacy_assetPath(a3);
  v7 = *((_QWORD *)v6 + 1);
  v14 = 0;
  v15 = 0;
  v12 = v7;
  v13 = 0;
  re::DynamicString::setCapacity(&v12, 0);
  re::AssetPath::fullAssetPath(v6, (re::DynamicString *)&v12);
  re::RealityFileWriter::getOrMakeAssetInfo(this, a2, (re::DynamicString *)&v12, *(const char **)(*(_QWORD *)(*((_QWORD *)a3 + 1) + 264) + 8), **(char ***)(*((_QWORD *)a3 + 1) + 264));
  if (*(_BYTE *)this)
  {
    v9 = *((_QWORD *)this + 1);
    re::AssetHandle::composedMetadata(a3, (uint64_t)v11);
    re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=(v9 + 208, (uint64_t)v11);
    v8.n128_f64[0] = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit(v11);
  }
  result = v12;
  if (v12)
  {
    if ((v13 & 1) != 0)
      return (*(uint64_t (**)(__n128))(*(_QWORD *)v12 + 40))(v8);
  }
  return result;
}

void re::RealityFileWriter::remapSceneAsset(re::RealityFileWriter *this, const re::AssetHandle *a2, const re::DynamicString *a3, uint64_t a4)
{
  __int128 v5;
  uint64_t v6;

  if (a2)
  {
    (*(void (**)(const re::AssetHandle *, const re::DynamicString *, uint64_t))(*(_QWORD *)a2 + 32))(a2, a3, a4);
  }
  else
  {
    re::AssetHandle::AssetHandle((re::AssetHandle *)&v5, a3);
    *(_BYTE *)this = 1;
    *(_OWORD *)((char *)this + 8) = v5;
    v5 = 0uLL;
    *((_QWORD *)this + 3) = v6;
    v6 = 0;
    re::AssetHandle::~AssetHandle((re::AssetHandle *)&v5);
  }
}

void re::RealityFileWriter::findDependenciesAndSaveAsset(uint64_t a1, uint64_t a2, uint64_t a3, const re::AssetHandle *a4, uint64_t *a5, uint64_t a6, int a7, _BYTE *a8)
{
  void *v15;
  id v16;
  uint64_t v17;
  uint64_t *v18;
  id v19;
  uint64_t v20;
  re::AssetHandle *v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  int *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  void *v32;
  id v33;
  _anonymous_namespace_ *v34;
  signed int v35;
  unsigned int v36;
  uint64_t v37;
  int *v38;
  int v39;
  id v40;
  uint64_t v41;
  uint64_t v42;
  re::AssetHandle *v43;
  re::DynamicString *v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t v49;
  id v50;
  _BYTE *v51;
  int v52;
  int v53[2];
  _BYTE v55[2];
  uint64_t v56;
  _OWORD v57[2];
  int v58;
  uint64_t v59;
  uint64_t v60;
  char v61[8];
  id v62;
  __int128 v63;
  __int128 v64;
  unsigned int v65;
  uint64_t v66;
  _BYTE v67[16];
  uint64_t v68;
  re::AssetHandle *v69;
  uint64_t v70;
  char v71[8];
  id v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;

  v70 = *a5;
  if (v70)
  {
    v15 = (void *)(v70 + 8);
    v16 = (id)(v70 + 8);
    re::RealityFileWriter::checkAssetIsWritable((uint64_t)v71, a4, (uint64_t)&v70);

    v70 = 0;
  }
  else
  {
    re::RealityFileWriter::checkAssetIsWritable((uint64_t)v71, a4, (uint64_t)&v70);
  }
  if (v71[0])
  {
    v17 = *((_QWORD *)a4 + 1);
    if (v17)
      v18 = *(uint64_t **)(v17 + 24);
    else
      v18 = 0;
    v20 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 72))(a3, *(_QWORD *)(*(_QWORD *)(a2 + 320) + 24));
    re::AssetManager::findDependencies((re::AssetManager *)v18, a4, (uint64_t)v67);
    v65 = 0;
    v63 = 0u;
    v64 = 0u;
    v66 = 0x7FFFFFFFLL;
    v52 = a7;
    *(_QWORD *)v53 = a2;
    v51 = a8;
    if (v68)
    {
      v21 = v69;
      v22 = 24 * v68;
      do
      {
        if (*((_QWORD *)v21 + 1) && !re::AssetManager::isDeviceAsset((uint64_t)v18, (uint64_t)v21, v20))
          re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add((uint64_t)&v63, v21);
        v21 = (re::AssetHandle *)((char *)v21 + 24);
        v22 -= 24;
      }
      while (v22);
      v23 = v65;
      if (v65)
      {
        v24 = 0;
        v25 = (int *)(v64 + 8);
        while (1)
        {
          v26 = *v25;
          v25 += 10;
          if (v26 < 0)
            break;
          if (v65 == ++v24)
          {
            LODWORD(v24) = v65;
            break;
          }
        }
LABEL_22:
        if (v23 != (_DWORD)v24)
        {
          v27 = v24;
          v28 = v64;
          do
          {
            re::AssetHandle::AssetHandle((re::AssetHandle *)v57, (const re::AssetHandle *)(v28 + 40 * v27 + 16));
            re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(a6, (re::AssetHandle *)v57);
            re::AssetHandle::~AssetHandle((re::AssetHandle *)v57);
            v28 = v64;
            if (v65 <= (int)v24 + 1)
              v29 = v24 + 1;
            else
              v29 = v65;
            v30 = v24;
            while (1)
            {
              v27 = (v30 + 1);
              if (v29 - 1 == v30)
                break;
              ++v30;
              LODWORD(v24) = v27;
              if ((*(_DWORD *)(v64 + 40 * v27 + 8) & 0x80000000) != 0)
                goto LABEL_32;
            }
            LODWORD(v24) = v29;
LABEL_32:
            ;
          }
          while (v23 != (_DWORD)v24);
        }
        v31 = *a5;
        v60 = v31;
        if (v31)
        {
          v32 = (void *)(v31 + 8);
          v33 = (id)(v31 + 8);
          re::RealityFileWriter::addDependentAssets((uint64_t)v61, *(const re::AssetHandle **)v53, &v60, (uint64_t)&v63);

        }
        else
        {
          re::RealityFileWriter::addDependentAssets((uint64_t)v61, *(const re::AssetHandle **)v53, &v60, (uint64_t)&v63);
        }
        if (v61[0])
        {
          v58 = 0;
          memset(v57, 0, sizeof(v57));
          v59 = 0x7FFFFFFFLL;
          v35 = HIDWORD(v64);
          if (HIDWORD(v64))
          {
            v36 = v65;
            if (v65)
            {
              v37 = 0;
              v38 = (int *)(v64 + 8);
              while (1)
              {
                v39 = *v38;
                v38 += 10;
                if (v39 < 0)
                  break;
                if (v65 == ++v37)
                {
                  LODWORD(v37) = v65;
                  break;
                }
              }
            }
            else
            {
              LODWORD(v37) = 0;
            }
            if (v65 != (_DWORD)v37)
            {
              v41 = v37;
              v42 = v64;
              do
              {
                v43 = (re::AssetHandle *)(v42 + 40 * v41 + 16);
                v44 = (re::DynamicString *)re::AssetHandle::legacy_assetPath(v43);
                v45 = *((_QWORD *)v44 + 1);
                v76 = 0;
                v77 = 0;
                v75 = 0;
                v74 = v45;
                re::DynamicString::setCapacity(&v74, 0);
                re::AssetPath::fullAssetPath(v44, (re::DynamicString *)&v74);
                re::RealityFileWriter::AssetInfoTable::tryGetAssetInfo((re::RealityFileWriter::AssetInfoTable *)(*(_QWORD *)v53 + 24), (const re::DynamicString *)&v74, &v73);
                v46 = v73;
                re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add((uint64_t)v57, v43, (const re::DynamicString *)(v73 + 32));
                if (v46)

                if (v74 && (v75 & 1) != 0)
                  (*(void (**)(void))(*(_QWORD *)v74 + 40))();
                v42 = v64;
                if (v65 <= (int)v37 + 1)
                  v47 = v37 + 1;
                else
                  v47 = v65;
                while (1)
                {
                  v41 = (v37 + 1);
                  if (v47 - 1 == (_DWORD)v37)
                    break;
                  LODWORD(v37) = v37 + 1;
                  v48 = v41;
                  if ((*(_DWORD *)(v64 + 40 * v41 + 8) & 0x80000000) != 0)
                    goto LABEL_59;
                }
                v48 = v47;
LABEL_59:
                LODWORD(v37) = v48;
              }
              while (v36 != v48);
            }
          }
          v49 = *a5;
          v56 = v49;
          if (v49)
            v50 = (id)(v49 + 8);
          v55[0] = *v51;
          if (v55[0])
            v55[1] = v51[1];
          re::RealityFileWriter::saveAssetToArchive(a1, *(re::AssetPathMapping **)v53, a4, &v56, (uint64_t)v57, v52, v55, v18[153]);
          if (v49)

          re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)v57);
          if (v61[0])
          {
LABEL_68:
            re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)&v63);
            re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v67);
            if (v71[0])
              return;
            goto LABEL_69;
          }
        }
        else
        {
          *(_BYTE *)a1 = 0;
          v40 = v62;
          v62 = 0;
          *(_QWORD *)(a1 + 8) = v40;
        }

        goto LABEL_68;
      }
    }
    else
    {
      v23 = 0;
    }
    LODWORD(v24) = 0;
    goto LABEL_22;
  }
  *(_BYTE *)a1 = 0;
  v19 = v72;
  v72 = 0;
  *(_QWORD *)(a1 + 8) = v19;
LABEL_69:

}

void re::RealityFileWriter::assignSceneSettingsToAssetInfo(_anonymous_namespace_ *a1, re::DynamicString *a2, uint64_t *a3, uint64_t a4, char a5)
{
  uint64_t v9;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  _anonymous_namespace_ *v14;
  unint64_t v15;
  unint64_t v16;
  id v17;
  uint64_t v18;
  id v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v9 = *a3;
  if (!a4)
  {
    v22 = 0;
    v23 = 0;
    v24 = 0;
    re::DynamicString::setCapacity(&v21, 0);
    re::DynamicString::operator=((re::DynamicString *)(v9 + 136), (re::DynamicString *)&v21);
    if (v21 && (v22 & 1) != 0)
      (*(void (**)(void))(*v21 + 40))();
    v13 = *a3;
    *(_BYTE *)(v13 + 256) = a5;
    v20 = v13;
    v14 = (_anonymous_namespace_ *)(id)(v13 + 8);
    v22 = 0;
    v23 = 0;
    v24 = 0;
    re::DynamicString::setCapacity(&v21, 0);
    re::RealityFileWriter::assignLabelToAssetInfo(a2, &v20, (re::DynamicString *)&v21, (uint64_t)a1);
    if (v21 && (v22 & 1) != 0)
      (*(void (**)(void))(*v21 + 40))();
    goto LABEL_22;
  }
  re::DynamicString::operator=((re::DynamicString *)(v9 + 136), (re::DynamicString *)(a4 + 24));
  v11 = *a3;
  v12 = (a5 & 1) != 0 || *(_BYTE *)(a4 + 88) != 0;
  *(_BYTE *)(v11 + 256) = v12;
  re::FixedArray<re::DynamicString>::operator=((re::DynamicString *)(v11 + 264), a4 + 96);
  if (!*(_QWORD *)(a4 + 104)
    || ((v15 = *(_QWORD *)(a4 + 64), (v15 & 1) != 0) ? (v16 = v15 >> 1) : (v16 = v15 >> 1), v16))
  {
    v13 = *a3;
    v25 = v13;
    if (!v13)
    {
      re::RealityFileWriter::assignLabelToAssetInfo(a2, &v25, (re::DynamicString *)(a4 + 56), (uint64_t)a1);
      return;
    }
    v17 = (id)(v13 + 8);
    re::RealityFileWriter::assignLabelToAssetInfo(a2, &v25, (re::DynamicString *)(a4 + 56), (uint64_t)a1);
    goto LABEL_22;
  }
  v18 = *a3;
  v26 = v18;
  if (v18)
  {
    v19 = (id)(v18 + 8);
    v18 = *a3;
  }
  re::RealityFileWriter::assignLabelToAssetInfo(a2, &v26, (re::DynamicString *)(v18 + 32), (uint64_t)a1);
  v13 = v26;
  if (v26)
LABEL_22:

}

uint64_t re::RealityFileWriter::AssetInfo::addSceneVariant(re::RealityFileWriter::AssetInfo *this, const re::DynamicString *a2, const re::DynamicString *a3)
{
  _anonymous_namespace_ *v3;
  double v4;
  uint64_t result;
  int v6;
  uint64_t v7;
  char v8;

  v3 = (re::RealityFileWriter::AssetInfo *)((char *)this + 168);
  v6 = 4;
  re::DynamicString::DynamicString((re::DynamicString *)&v7, a2);
  v4 = re::DynamicArray<re::SceneCompatibilityVariant>::add(v3, (uint64_t)&v6);
  result = v7;
  if (v7)
  {
    if ((v8 & 1) != 0)
      return (*(uint64_t (**)(double))(*(_QWORD *)v7 + 40))(v4);
  }
  return result;
}

re::DynamicString *re::RealityFileWriter::assignLabelToAssetInfo@<X0>(re::DynamicString *result@<X0>, uint64_t *a2@<X1>, re::DynamicString *a3@<X2>, uint64_t a4@<X8>)
{
  re::DynamicString *v6;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  re::DynamicString *v20;
  char v21;
  uint64_t v22;

  v6 = result;
  v8 = *((_QWORD *)a3 + 1);
  if ((v8 & 1) != 0)
    v9 = v8 >> 1;
  else
    v9 = v8 >> 1;
  if (!v9)
  {
    v16 = *(_QWORD *)(*a2 + 72);
    if ((v16 & 1) != 0)
      v17 = v16 >> 1;
    else
      v17 = v16 >> 1;
    if (!v17)
      goto LABEL_22;
    re::HashTable<re::DynamicString,re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove((uint64_t)result + 416, *a2 + 64);
LABEL_21:
    result = re::DynamicString::operator=((re::DynamicString *)(*a2 + 64), a3);
LABEL_22:
    *(_BYTE *)a4 = 1;
    return result;
  }
  v10 = re::Hash<re::DynamicString>::operator()((uint64_t)&v20, (uint64_t)a3);
  if (!*((_QWORD *)v6 + 52)
    || (v11 = *(unsigned int *)(*((_QWORD *)v6 + 53) + 4 * (v10 % *((unsigned int *)v6 + 110))),
        (_DWORD)v11 == 0x7FFFFFFF))
  {
LABEL_10:
    v13 = (uint64_t)v6 + 416;
    v14 = *(_QWORD *)(*a2 + 72);
    if ((v14 & 1) != 0)
      v15 = v14 >> 1;
    else
      v15 = v14 >> 1;
    if (v15)
      re::HashTable<re::DynamicString,re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(v13, *a2 + 64);
    re::HashTable<re::DynamicString,re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::SharedPtr<re::RealityFileWriter::AssetInfo>&>(v13, a3, a2);
    goto LABEL_21;
  }
  v12 = *((_QWORD *)v6 + 54);
  while (1)
  {
    result = (re::DynamicString *)re::DynamicString::operator==(v12 + 56 * v11 + 16, (uint64_t)a3);
    if ((result & 1) != 0)
      break;
    v11 = *(_DWORD *)(v12 + 56 * v11 + 8) & 0x7FFFFFFF;
    if (v11 == 0x7FFFFFFF)
      goto LABEL_10;
  }
  if (*(_QWORD *)(v12 + 56 * v11 + 48) == *a2)
    goto LABEL_22;
  if ((*((_QWORD *)a3 + 1) & 1) != 0)
    v18 = (char *)*((_QWORD *)a3 + 2);
  else
    v18 = (char *)a3 + 9;
  re::DynamicString::format((re::DynamicString *)"An asset naming conflict occurred because multiple assets have been assigned the caller name '%s'.", (re::DynamicString *)&v20, v18);
  v19 = v22;
  v22 = 0;
  *(_BYTE *)a4 = 0;
  *(_QWORD *)(a4 + 8) = v19;

  result = v20;
  if (v20 && (v21 & 1) != 0)
    return (re::DynamicString *)(*(uint64_t (**)(void))(*(_QWORD *)v20 + 40))();
  return result;
}

uint64_t re::RealityFileWriter::writeDataEntry(const re::DynamicString *a1, const char *a2, _QWORD *a3, re::RealityFileWriter::AssetWriteResult **a4)
{
  re::path *v8;
  const char *v9;
  _DWORD *v10;
  char *v11;
  _DWORD *v12;
  uint64_t v13;
  re::RealityFileWriter::AssetWriteResult *v14;
  char *v15;
  char *v16;
  unint64_t v17;
  char *v18;
  re::RealityFileWriter::AssetWriteResult *v19;
  char *v20;
  void **v21;
  id v22;
  void *v23;
  re::RealityFileWriter::AssetWriteResult *v25;
  char *v26;
  id v27;
  id v28;
  _DWORD *v29;
  id v30;
  id v31;
  id v32;
  uint64_t v33;
  id v34[3];

  if (*a4)
    re::RealityFileWriter::AssetWriteResult::clear(*a4);
  if ((a3[1] & 1) != 0)
    v8 = (re::path *)a3[2];
  else
    v8 = (re::path *)((char *)a3 + 9);
  v9 = (const char *)re::path::ext(v8, a2);
  if (v9 && *v9)
  {
    re::RealityFileWriter::getOrMakeAssetInfo((re::RealityFileWriter *)&v33, a1, (re::DynamicString *)a3, v9, 0);
    if ((_BYTE)v33)
    {
      v10 = v34[0];
      if (v34[0])
        v11 = (char *)v34[0] + 8;
      if (v10[6] == 1
        || (v29 = v10,
            v12 = v10 + 2,
            re::RealityFileWriter::saveEntryToArchive((uint64_t)&v30, (uint64_t)a1, (const __CFData *)a2, (uint64_t *)&v29, 0), v10 + 2, (_BYTE)v30))
      {
        if (*a4)
          re::DynamicString::operator=((re::RealityFileWriter::AssetWriteResult *)((char *)*a4 + 24), (re::DynamicString *)(v10 + 8));
        v13 = 1;
      }
      else
      {
        v25 = *a4;
        if (*a4)
        {
          v26 = (char *)v25 + 8;
          v27 = v31;
          v28 = v27;
          re::ObjCObject::operator=((id *)v25 + 12, &v28);

        }
        else
        {
          v27 = v31;
          v28 = v27;

        }
        v13 = 0;
      }

    }
    else
    {
      v19 = *a4;
      if (*a4)
      {
        v20 = (char *)v19 + 8;
        v32 = v34[0];
        re::ObjCObject::operator=((id *)v19 + 12, &v32);

      }
      else
      {
        v32 = v34[0];

      }
      v13 = 0;
    }
    re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)&v33);
  }
  else
  {
    v14 = *a4;
    if (*a4)
    {
      v15 = (char *)v14 + 8;
      if ((a3[1] & 1) != 0)
        v16 = (char *)a3[2];
      else
        v16 = (char *)a3 + 9;
      re::DynamicString::format((re::DynamicString *)"Could not parse an extension from the path %s.", (re::DynamicString *)&v33, v16);
      v17 = (unint64_t)v34[0] >> 1;
      if (((uint64_t)v34[0] & 1) == 0)
        v17 = LOBYTE(v34[0]) >> 1;
      if (v17)
      {
        if (((uint64_t)v34[0] & 1) != 0)
          v18 = (char *)v34[1];
        else
          v18 = (char *)v34 + 1;
        re::WrappedError::make((re::WrappedError *)CFSTR("RERealityFileWriterErrorDomain"), (const __CFString *)7, (uint64_t)v18, &v30);
      }
      else
      {
        re::WrappedError::make((re::WrappedError *)CFSTR("RERealityFileWriterErrorDomain"), (const __CFString *)7, 0, &v30);
      }
      v21 = (void **)((char *)v14 + 96);
      if ((id *)((char *)v14 + 96) != &v30)
      {
        v22 = v30;
        v30 = 0;
        v23 = *v21;
        *v21 = v22;

      }
      if (v33 && ((uint64_t)v34[0] & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v33 + 40))();

    }
    else
    {
      re::DynamicString::format((re::DynamicString *)"Could not parse an extension from the path %s.", (re::DynamicString *)&v33, v8);
      if (v33 && ((uint64_t)v34[0] & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v33 + 40))();
    }
    return 0;
  }
  return v13;
}

void re::RealityFileWriter::getOrMakeAssetInfo(re::RealityFileWriter *this, const re::DynamicString *a2, re::DynamicString *a3, const char *a4, char *a5)
{
  char *v10;
  uint64_t *AssetInfo;
  uint64_t v12;
  id v13;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  size_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  re::RealityFileWriter *v25;
  re::DynamicString *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  unint64_t v39;
  unint64_t v40;
  int v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  uint64_t v46;
  int v47;
  int v48;
  unint64_t v49;
  uint64_t i;
  _BOOL4 v51;
  char *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  _BOOL8 v57;
  char *v58;
  uint64_t *v59;
  _anonymous_namespace_ *v60;
  _anonymous_namespace_ *v61;
  id v62;
  id v63;
  char v64;
  char *v65;
  uint64_t v66;
  re::RealityFileWriter *v67;
  _OWORD v68[2];
  uint64_t v69;
  uint64_t v70;
  _QWORD v71[3];
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  char v75[16];
  __int128 v76;
  __int128 v77;
  char *v78;
  uint64_t v79;

  v10 = (char *)a2 + 24;
  AssetInfo = re::RealityFileWriter::AssetInfoTable::tryGetAssetInfo((const re::DynamicString *)((char *)a2 + 24), a3, &v72);
  v12 = v72;
  if (v72)
    goto LABEL_2;
  if (a5)
  {
    v15 = re::RigEvaluation::HashString::operator()((int)&v77, a5);
    if (*((_QWORD *)a2 + 15))
    {
      v16 = *(unsigned int *)(*((_QWORD *)a2 + 16) + 4 * (v15 % *((unsigned int *)a2 + 36)));
      if ((_DWORD)v16 != 0x7FFFFFFF)
      {
        v17 = *((_QWORD *)a2 + 17);
        while (1)
        {
          v18 = v17 + 32 * v16;
          if (!strcmp(*(const char **)(v18 + 16), a5))
            break;
          v16 = *(_DWORD *)(v18 + 8) & 0x7FFFFFFF;
          if (v16 == 0x7FFFFFFF)
            goto LABEL_13;
        }
        v36 = (*(_DWORD *)(v18 + 24) + 1);
        *(_DWORD *)(v18 + 24) = v36;
        goto LABEL_37;
      }
    }
LABEL_13:
    v19 = re::RigEvaluation::HashString::operator()((int)&v77, a5);
    v20 = v19;
    if (*((_QWORD *)a2 + 15))
    {
      v21 = v19 % *((unsigned int *)a2 + 36);
      v22 = *(unsigned int *)(*((_QWORD *)a2 + 16) + 4 * v21);
      if ((_DWORD)v22 != 0x7FFFFFFF)
      {
        v67 = this;
        v23 = *((_QWORD *)a2 + 17);
        while (1)
        {
          v24 = v23 + 32 * v22;
          if (!strcmp(*(const char **)(v24 + 16), a5))
            break;
          v22 = *(_DWORD *)(v24 + 8) & 0x7FFFFFFF;
          if (v22 == 0x7FFFFFFF)
          {
            this = v67;
            goto LABEL_31;
          }
        }
        v36 = 0;
        this = v67;
        goto LABEL_37;
      }
    }
    else
    {
      LODWORD(v21) = 0;
    }
LABEL_31:
    v32 = *((unsigned int *)a2 + 39);
    if ((_DWORD)v32 == 0x7FFFFFFF)
    {
      v32 = *((unsigned int *)a2 + 38);
      v33 = v32;
      if ((_DWORD)v32 == *((_DWORD *)a2 + 36))
      {
        re::HashTable<char const*,int,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::setCapacity((uint64_t)a2 + 120, 2 * *((_DWORD *)a2 + 37));
        LODWORD(v21) = v20 % *((unsigned int *)a2 + 36);
        v33 = *((_DWORD *)a2 + 38);
      }
      *((_DWORD *)a2 + 38) = v33 + 1;
      v34 = *((_QWORD *)a2 + 17);
      v35 = *(_DWORD *)(v34 + 32 * v32 + 8);
    }
    else
    {
      v34 = *((_QWORD *)a2 + 17);
      v35 = *(_DWORD *)(v34 + 32 * v32 + 8);
      *((_DWORD *)a2 + 39) = v35 & 0x7FFFFFFF;
    }
    v36 = 0;
    *(_DWORD *)(v34 + 32 * v32 + 8) = v35 | 0x80000000;
    *(_DWORD *)(*((_QWORD *)a2 + 17) + 32 * v32 + 8) = *(_DWORD *)(*((_QWORD *)a2 + 17) + 32 * v32 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)a2 + 16) + 4 * v21);
    *(_QWORD *)(*((_QWORD *)a2 + 17) + 32 * v32) = v20;
    *(_QWORD *)(*((_QWORD *)a2 + 17) + 32 * v32 + 16) = a5;
    *(_DWORD *)(*((_QWORD *)a2 + 17) + 32 * v32 + 24) = 0;
    *(_DWORD *)(*((_QWORD *)a2 + 16) + 4 * v21) = v32;
    ++*((_DWORD *)a2 + 37);
    ++*((_DWORD *)a2 + 40);
LABEL_37:
    v37 = v10;
    re::DynamicString::format((re::DynamicString *)"%s_%i.%s", (re::DynamicString *)&v70, a5, v36, a4);
    if (*(_QWORD *)&v68[0] && (BYTE8(v68[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v68[0] + 40))();
    goto LABEL_102;
  }
  v25 = this;
  v26 = re::DynamicString::DynamicString((re::DynamicString *)&v77, a3);
  re::DynamicString::rfind((uint64_t)v26, 47, v75);
  if (v75[0])
    v27 = *(_QWORD *)&v75[8] + 1;
  else
    v27 = 0;
  re::DynamicString::rfind((uint64_t)&v77, 58, &v73);
  if (v27 <= v74 + 1)
    v28 = v74 + 1;
  else
    v28 = v27;
  if ((_BYTE)v73)
    v29 = v28;
  else
    v29 = v27;
  v30 = *((_QWORD *)&v77 + 1);
  re::DynamicString::rfind((uint64_t)&v77, 46, &v70);
  if ((_BYTE)v70)
  {
    v31 = v71[0];
    this = v25;
  }
  else
  {
    v31 = v30 >> 1;
    if ((v30 & 1) == 0)
      v31 = v30 >> 1;
    this = v25;
    if (!v29)
      goto LABEL_46;
  }
  re::DynamicString::substr((re::DynamicString *)&v77, v29, v31 - v29, (re::DynamicString *)v68);
  re::DynamicString::operator=((re::DynamicString *)&v77, (re::DynamicString *)v68);
  if (*(_QWORD *)&v68[0] && (BYTE8(v68[0]) & 1) != 0)
    (*(void (**)(void))(**(_QWORD **)&v68[0] + 40))();
LABEL_46:
  v38 = v10;
  v75[0] = 95;
  re::DynamicString::find((re::DynamicString *)&v77, v75, 1, 0, (uint64_t)v68);
  if (!LOBYTE(v68[0]))
    goto LABEL_66;
  v39 = (BYTE8(v77) & 1) != 0 ? *((_QWORD *)&v77 + 1) >> 1 : BYTE8(v77) >> 1;
  v40 = *((_QWORD *)&v68[0] + 1) + 1;
  if (*((_QWORD *)&v68[0] + 1) + 1 >= v39)
    goto LABEL_66;
  v41 = 0;
  v42 = 1;
  v43 = MEMORY[0x24BDAC740];
  do
  {
    v44 = *(unsigned __int8 *)re::DynamicString::operator[]((uint64_t)&v77, v40);
    if ((v42 & 1) == 0)
    {
      if ((v44 & 0x80) != 0 || (*(_DWORD *)(v43 + 4 * v44 + 60) & 0x400) == 0)
        goto LABEL_63;
      goto LABEL_59;
    }
    if ((v44 & 0x80) != 0)
      goto LABEL_63;
    if ((*(_DWORD *)(v43 + 4 * v44 + 60) & 0x10000) == 0)
    {
      if ((_DWORD)v44 != 95)
        goto LABEL_63;
LABEL_59:
      v42 = 0;
      goto LABEL_61;
    }
    ++v41;
    v42 = 1;
LABEL_61:
    ++v40;
  }
  while (v39 != v40);
  v40 = v39;
LABEL_63:
  if (v40 != v39 || v41 < 4 || v41 > 8)
  {
LABEL_66:
    re::DynamicString::DynamicString((re::DynamicString *)v75, a3);
    v45 = (char *)v76;
    if ((v75[8] & 1) == 0)
      v45 = &v75[9];
    v46 = v75[8] >> 1;
    v47 = 5381;
    if ((v75[8] & 1) != 0)
      v46 = *(_QWORD *)&v75[8] >> 1;
    for (; v46; --v46)
    {
      v48 = *v45++;
      v47 = v48 - (v47 & 0xFFFFFF) + ((v47 & 0xFFFFFF) << 7);
    }
    if ((BYTE8(v77) & 1) != 0)
      v49 = *((_QWORD *)&v77 + 1) >> 1;
    else
      v49 = BYTE8(v77) >> 1;
    if (v49 > 0xF4)
    {
      re::DynamicString::substr((re::DynamicString *)&v77, v49 - 244, 0xF4uLL, (re::DynamicString *)v68);
      re::DynamicString::operator=((re::DynamicString *)&v77, (re::DynamicString *)v68);
      if (*(_QWORD *)&v68[0])
      {
        if ((BYTE8(v68[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v68[0] + 40))();
      }
    }
    re::DynamicString::appendf((re::DynamicString *)&v77, "_%x", v47);
    if (*(_QWORD *)v75)
    {
      if ((v75[8] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)v75 + 40))();
      *(_OWORD *)v75 = 0u;
      v76 = 0u;
    }
  }
  re::DynamicString::operator+((re::DynamicString *)&v77, ".", (re::DynamicString *)v68);
  re::DynamicString::operator+((re::DynamicString *)v68, a4, (re::DynamicString *)&v70);
  if (*(_QWORD *)&v68[0] && (BYTE8(v68[0]) & 1) != 0)
    (*(void (**)(void))(**(_QWORD **)&v68[0] + 40))();
  for (i = 1; ; i = (i + 1))
  {
    re::DynamicString::DynamicString((re::DynamicString *)v68, (const re::DynamicString *)&v70);
    v51 = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey((uint64_t)a2 + 72, (uint64_t)v68);
    if (*(_QWORD *)&v68[0])
    {
      if ((BYTE8(v68[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v68[0] + 40))();
      memset(v68, 0, sizeof(v68));
    }
    if (!v51)
      break;
    v52 = v78;
    if ((BYTE8(v77) & 1) == 0)
      v52 = (char *)&v77 + 9;
    re::DynamicString::format((re::DynamicString *)"%s_%d.%s", (re::DynamicString *)&v73, v52, i, a4);
    re::DynamicString::operator=((re::DynamicString *)&v70, (re::DynamicString *)&v73);
    if (v73 && (v74 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v73 + 40))();
  }
  if ((_QWORD)v77 && (BYTE8(v77) & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v77 + 40))();
  v37 = v38;
LABEL_102:
  v53 = re::Hash<re::DynamicString>::operator()((uint64_t)v68, (uint64_t)a3);
  if (!*v37
    || (v54 = *(unsigned int *)(*((_QWORD *)a2 + 4) + 4 * (v53 % *((unsigned int *)a2 + 12))), (_DWORD)v54 == 0x7FFFFFFF))
  {
LABEL_107:
    v56 = (char *)a2 + 72;
    v57 = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey((uint64_t)v56, (uint64_t)&v70);
    if (v57)
    {
      if ((v71[0] & 1) != 0)
        v58 = (char *)v71[1];
      else
        v58 = (char *)v71 + 1;
      re::DynamicString::format((re::DynamicString *)"The serialization string '%s' is already in use.", (re::DynamicString *)&v77, v58);
      goto LABEL_117;
    }
    v59 = re::globalAllocators((re *)v57);
    v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v59[2] + 32))(v59[2], 288, 8);
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)v12, 0);
    *(_QWORD *)v12 = off_24ED2CC68;
    *(_DWORD *)(v12 + 24) = 0;
    v60 = re::DynamicString::DynamicString((re::DynamicString *)(v12 + 32), (const re::DynamicString *)&v70);
    *(_OWORD *)(v12 + 80) = 0u;
    *(_OWORD *)(v12 + 64) = 0u;
    v61 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)(v12 + 64), 0);
    *(_QWORD *)(v12 + 96) = 0;
    *(_QWORD *)(v12 + 104) = 0;
    *(_DWORD *)(v12 + 120) = 0;
    *(_QWORD *)(v12 + 112) = 0;
    *(_OWORD *)(v12 + 128) = 0u;
    *(_OWORD *)(v12 + 144) = 0u;
    *(_QWORD *)(v12 + 160) = 0;
    re::DynamicString::setCapacity((_QWORD *)(v12 + 136), 0);
    *(_QWORD *)(v12 + 168) = 0;
    *(_QWORD *)(v12 + 176) = 0;
    *(_DWORD *)(v12 + 192) = 0;
    *(_QWORD *)(v12 + 184) = 0;
    *(_OWORD *)(v12 + 200) = 0u;
    *(_OWORD *)(v12 + 216) = 0u;
    *(_OWORD *)(v12 + 228) = 0u;
    *(_QWORD *)(v12 + 244) = 0x7FFFFFFFLL;
    *(_BYTE *)(v12 + 256) = 0;
    *(_QWORD *)(v12 + 272) = 0;
    *(_QWORD *)(v12 + 280) = 0;
    *(_QWORD *)(v12 + 264) = 0;
    *(_QWORD *)&v77 = v12;
    re::HashTable<re::DynamicString,re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::SharedPtr<re::RealityFileWriter::AssetInfo>&>((uint64_t)v37, a3, (uint64_t *)&v77);
    re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)v56, (re::DynamicString *)&v70);
    v62 = (id)(v12 + 8);
    LOBYTE(v68[0]) = 1;
    *((_QWORD *)&v68[0] + 1) = v12;

    v63 = (id)(v12 + 8);
    v64 = 0;
    v72 = v12;
  }
  else
  {
    v55 = *((_QWORD *)a2 + 5);
    while (!re::DynamicString::operator==(v55 + 56 * v54 + 16, (uint64_t)a3))
    {
      v54 = *(_DWORD *)(v55 + 56 * v54 + 8) & 0x7FFFFFFF;
      if (v54 == 0x7FFFFFFF)
        goto LABEL_107;
    }
    if ((*((_QWORD *)a3 + 1) & 1) != 0)
      v65 = (char *)*((_QWORD *)a3 + 2);
    else
      v65 = (char *)a3 + 9;
    re::DynamicString::format((re::DynamicString *)"The AssetPath '%s' is already in use.", (re::DynamicString *)&v77, v65);
LABEL_117:
    LOBYTE(v68[0]) = 0;
    *(_OWORD *)((char *)v68 + 8) = v77;
    *((_QWORD *)&v68[1] + 1) = v78;
    v69 = v79;
    v64 = 1;
    v66 = v77;
    *(_QWORD *)&v77 = 0;
    *(_BYTE *)this = 0;
    *((_QWORD *)this + 1) = v66;

    v12 = 0;
  }
  if (LOBYTE(v68[0]))
  {
    if (*((_QWORD *)&v68[0] + 1))

  }
  else if (*((_QWORD *)&v68[0] + 1) && (v68[1] & 1) != 0)
  {
    (*(void (**)(void))(**((_QWORD **)&v68[0] + 1) + 40))();
  }
  if (v70 && (v71[0] & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v70 + 40))();
  if ((v64 & 1) != 0)
    goto LABEL_4;
  if (v12)
  {
LABEL_2:
    v13 = (id)(v12 + 8);
    v14 = v72;
    goto LABEL_3;
  }
  v14 = 0;
LABEL_3:
  *(_BYTE *)this = 1;
  *((_QWORD *)this + 1) = v12;
  v12 = v14;
LABEL_4:
  if (v12)

}

uint64_t re::RealityFileWriter::saveEntryToArchive(uint64_t a1, uint64_t a2, const __CFData *a3, uint64_t *a4, int a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  char *v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  char v23;
  _BYTE v24[7];
  _BYTE *v25;

  v6 = *a4;
  if (*(_DWORD *)(*a4 + 24) == 1)
  {
    if ((*(_BYTE *)(v6 + 40) & 1) != 0)
      v7 = *(_QWORD *)(v6 + 48);
    else
      v7 = v6 + 41;
    re::DynamicString::format((re::DynamicString *)"The asset (%s) has already been written.", (re::DynamicString *)&v19, v7);
    v13 = v22;
    v22 = 0;
    *(_BYTE *)a1 = 0;
    *(_QWORD *)(a1 + 8) = v13;

    result = v19;
    if (v19 && (v20 & 1) != 0)
    {
      v15 = v21;
      return (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)result + 40))(result, v15);
    }
  }
  else
  {
    if ((*(_BYTE *)(v6 + 40) & 1) != 0)
      v12 = *(_QWORD *)(v6 + 48);
    else
      v12 = v6 + 41;
    re::DynamicString::format((re::DynamicString *)"assets/%s", (re::DynamicString *)&v22, v12);
    if ((v23 & 1) != 0)
      v16 = v25;
    else
      v16 = v24;
    re::RealityArchiveWriter::writeEntry(a2 + 248, (uint64_t)v16, a3, a5, (uint64_t)&v19);
    if ((_BYTE)v19)
    {
      *(_DWORD *)(*a4 + 24) = 1;
      *(_BYTE *)a1 = 1;
    }
    else
    {
      v17 = v18;
      v18 = 0;
      *(_BYTE *)a1 = 0;
      *(_QWORD *)(a1 + 8) = v17;

      if (!(_BYTE)v19 && v20 && (v21 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v20 + 40))();
    }
    result = v22;
    if (v22 && (v23 & 1) != 0)
    {
      v15 = v25;
      return (*(uint64_t (**)(uint64_t, char *))(*(_QWORD *)result + 40))(result, v15);
    }
  }
  return result;
}

uint64_t re::RealityFileWriter::writeAllDependencies(uint64_t a1, uint64_t a2, re::RealityFileWriter::AssetWriteResult **a3)
{
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  unsigned int v13;
  unsigned int v14;
  _BYTE *v15;
  AssetService *v16;
  _BOOL4 v17;
  re *v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  re::RealityFileWriter::AssetWriteResult *v23;
  char *v24;
  _BYTE *v25;
  re::RealityFileWriter::AssetWriteResult *v26;
  void *v27;
  char *v28;
  int v29;
  re::RealityFileWriter::AssetWriteResult *v32;
  _BYTE v33[24];
  _QWORD v34[4];
  _QWORD v35[4];
  __int16 v36;
  char v37;
  char v38;
  _QWORD v39[3];
  _BYTE *v40;
  uint64_t v41[3];
  int v42;
  _BYTE v43[24];
  id v44;
  _BYTE v45[8];
  id v46;
  uint64_t v47[4];
  int v48;
  uint64_t v49;
  _QWORD v50[3];
  uint64_t v51;
  char v52;
  _BYTE v53[23];
  char v54;
  uint64_t v55;
  char v56;
  uint8_t buf[4];
  uint64_t v58;
  __int16 v59;
  uint64_t v60;
  _QWORD v61[4];
  _QWORD v62[4];
  _BYTE v63[3];
  char v64;
  _QWORD v65[6];

  v65[3] = *MEMORY[0x24BDAC8D0];
  if (*a3)
    re::RealityFileWriter::AssetWriteResult::clear(*a3);
  v5 = *(unsigned int *)(a1 + 56);
  if ((_DWORD)v5)
  {
    v6 = 0;
    v7 = (int *)(*(_QWORD *)(a1 + 40) + 8);
    while (1)
    {
      v8 = *v7;
      v7 += 14;
      if (v8 < 0)
        break;
      if (v5 == ++v6)
      {
        LODWORD(v6) = *(_DWORD *)(a1 + 56);
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if ((_DWORD)v5 != (_DWORD)v6)
  {
    v9 = v6;
    while (1)
    {
      v10 = *(_QWORD *)(a1 + 40);
      v11 = *(_QWORD *)(v10 + 56 * v9 + 48);
      if (v11)
        v12 = (id)(v11 + 8);
      if (!*(_DWORD *)(v11 + 24))
        break;

      v13 = *(_DWORD *)(a1 + 56);
      if (v13 <= (int)v6 + 1)
        v13 = v6 + 1;
      while (1)
      {
        v9 = (v6 + 1);
        if (v13 - 1 == (_DWORD)v6)
          break;
        LODWORD(v6) = v6 + 1;
        v14 = v9;
        if ((*(_DWORD *)(*(_QWORD *)(a1 + 40) + 56 * v9 + 8) & 0x80000000) != 0)
          goto LABEL_20;
      }
      v14 = v13;
LABEL_20:
      LODWORD(v6) = v14;
      if ((_DWORD)v5 == v14)
        return 1;
    }
    v54 = 1;
    re::DynamicString::DynamicString((re::DynamicString *)&v55, (const re::DynamicString *)(v10 + 56 * v9 + 16));

    re::DynamicString::DynamicString((re::DynamicString *)&v51, (const re::DynamicString *)&v55);
    if ((v52 & 1) != 0)
      v15 = *(_BYTE **)&v53[7];
    else
      v15 = v53;
    (*(void (**)(_QWORD *__return_ptr, uint64_t, _BYTE *))(*(_QWORD *)a2 + 8))(v50, a2, v15);
    v48 = 0;
    memset(v47, 0, sizeof(v47));
    v49 = 0x7FFFFFFFLL;
    v16 = (AssetService *)re::AssetHandle::legacy_assetPath((re::AssetHandle *)v50);
    re::RealityFileWriter::customizeAssetPathMapping(v45, (re::AssetPathMapping *)a1, (const re::AssetPath *)v47, v16, a2);
    if (!v45[0])
    {
      v23 = *a3;
      if (*a3)
      {
        v24 = (char *)v23 + 8;
        v44 = v46;
        re::ObjCObject::operator=((id *)v23 + 12, &v44);

      }
      else
      {
        v44 = v46;

      }
      v22 = 1;
      goto LABEL_60;
    }
    re::AssetHandle::AssetHandle((re::AssetHandle *)v43, (const re::AssetHandle *)v50);
    re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::HashTable((uint64_t)v41, (uint64_t)v47);
    if (v42)
    {
      v17 = re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::containsKey((uint64_t)v41, (uint64_t)v43);
      re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit(v41);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v43);
      if (v17)
      {
        v19 = *re::assetsLogObjects(v18);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          v20 = **(_QWORD **)(v50[1] + 264);
          v21 = *((_QWORD *)re::AssetHandle::assetInfo((re::AssetHandle *)v50) + 10);
          if (v21 == -1)
            v21 = 0;
          *(_DWORD *)buf = 136315394;
          v58 = v20;
          v59 = 2048;
          v60 = v21;
          _os_log_impl(&dword_224FE9000, v19, OS_LOG_TYPE_DEFAULT, "Not writing remapped %s with assetID: %llu", buf, 0x16u);
        }
        v22 = 3;
        goto LABEL_60;
      }
    }
    else
    {
      re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit(v41);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v43);
    }
    re::RealityFileWriter::AssetInfoTable::tryGetAssetInfo((re::RealityFileWriter::AssetInfoTable *)(a1 + 24), (const re::DynamicString *)&v51, (uint64_t *)&v40);
    re::AssetHandle::AssetHandle((re::AssetHandle *)buf, (const re::AssetHandle *)v50);
    v25 = v40;
    re::DynamicString::DynamicString((re::DynamicString *)v61, (const re::DynamicString *)(v40 + 136));
    re::DynamicString::DynamicString((re::DynamicString *)v62, (const re::DynamicString *)(v25 + 64));
    v63[0] = v25[256];
    *(_WORD *)&v63[1] = 0;
    memset(v65, 0, 24);
    re::AssetHandle::AssetHandle((re::AssetHandle *)v33, (const re::AssetHandle *)buf);
    re::DynamicString::DynamicString((re::DynamicString *)v34, (const re::DynamicString *)v61);
    re::DynamicString::DynamicString((re::DynamicString *)v35, (const re::DynamicString *)v62);
    v36 = *(_WORD *)v63;
    v37 = v63[2];
    if (v63[2])
      v38 = v64;
    re::FixedArray<re::DynamicString>::FixedArray((re::DynamicString *)v39, (uint64_t)v65);
    v26 = *a3;
    v32 = v26;
    if (v26)
    {
      v27 = (char *)v26 + 8;
      v28 = (char *)v26 + 8;
      v29 = re::RealityFileWriter::writeAsset(a1, (re::AssetHandle *)v33, &v32);

      v32 = 0;
    }
    else
    {
      v29 = re::RealityFileWriter::writeAsset(a1, (re::AssetHandle *)v33, &v32);
    }
    re::FixedArray<re::DynamicString>::deinit(v39);
    if (v35[0])
    {
      if ((v35[1] & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v35[0] + 40))();
      memset(v35, 0, sizeof(v35));
    }
    if (v34[0])
    {
      if ((v34[1] & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v34[0] + 40))();
      memset(v34, 0, sizeof(v34));
    }
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v33);
    re::FixedArray<re::DynamicString>::deinit(v65);
    if (v62[0])
    {
      if ((v62[1] & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v62[0] + 40))();
      memset(v62, 0, sizeof(v62));
    }
    if (v61[0])
    {
      if ((v61[1] & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v61[0] + 40))();
      memset(v61, 0, sizeof(v61));
    }
    v22 = v29 ^ 1;
    re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);

LABEL_60:
    re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit(v47);
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v50);
    if (v51 && (v52 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v51 + 40))();
    if (v54 && v55 && (v56 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v55 + 40))();
    __asm { BR              X9 }
  }
  return 1;
}

_BYTE *re::RealityFileWriter::customizeAssetPathMapping(_BYTE *this, re::AssetPathMapping *a2, const re::AssetPath *a3, AssetService *a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  _BYTE v21[24];
  uint64_t v22;
  _BYTE *v23;
  uint64_t v24;

  v9 = (uint64_t)this;
  v24 = *MEMORY[0x24BDAC8D0];
  v10 = *((_QWORD *)a2 + 48);
  if (v10)
  {
    v11 = *((_QWORD *)a2 + 50);
    v12 = 40 * v10;
    while (1)
    {
      v22 = *(_QWORD *)(v11 + 24);
      v23 = 0;
      re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v21, v11);
      v18 = a5;
      v13 = (*(uint64_t (**)(_BYTE *, const re::AssetPath *, uint64_t *))(*(_QWORD *)v23 + 16))(v23, a3, &v18);
      if ((v13 & 1) == 0)
        break;
      this = v23;
      if (v23)
      {
        this = (_BYTE *)(**(uint64_t (***)(_BYTE *))v23)(v23);
        if (v23 != v21)
          this = (_BYTE *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v22 + 40))(v22);
      }
      v11 += 40;
      v12 -= 40;
      if (!v12)
      {
        if (*((_QWORD *)a2 + 48))
          goto LABEL_16;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    v14 = *((_QWORD *)a2 + 43);
    if (!v14)
    {
LABEL_16:
      *(_BYTE *)v9 = 1;
      return this;
    }
    v15 = *((_QWORD *)a2 + 45);
    v16 = 40 * v14;
    while (1)
    {
      v22 = *(_QWORD *)(v15 + 24);
      v23 = 0;
      re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v21, v15);
      v18 = a5;
      v13 = (*(uint64_t (**)(_BYTE *, const re::AssetPath *, AssetService *, uint64_t *))(*(_QWORD *)v23 + 16))(v23, a3, a4, &v18);
      if ((v13 & 1) == 0)
        break;
      this = v23;
      if (v23)
      {
        this = (_BYTE *)(**(uint64_t (***)(_BYTE *))v23)(v23);
        if (v23 != v21)
          this = (_BYTE *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v22 + 40))(v22);
      }
      v15 += 40;
      v16 -= 40;
      if (!v16)
        goto LABEL_16;
    }
  }
  v17 = v20;
  v20 = 0;
  *(_BYTE *)v9 = 0;
  *(_QWORD *)(v9 + 8) = v17;

  if (v18 && (v19 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v18 + 40))();
  this = v23;
  if (v23)
  {
    this = (_BYTE *)(**(uint64_t (***)(_BYTE *))v23)(v23);
    if (v23 != v21)
      return (_BYTE *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v22 + 40))(v22);
  }
  return this;
}

uint64_t re::RealityFileWriter::writeAssetArrayAndDependencies(uint64_t a1, uint64_t a2, int a3, re::RealityFileWriter::AssetWriteResult **a4)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _anonymous_namespace_ *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  re::RealityFileWriter::AssetWriteResult *v14;
  char *v15;
  id v16;
  re::AssetManager **v17;
  unint64_t v18;
  re::AssetManager *v19;
  uint64_t v20;
  _anonymous_namespace_ *v21;
  unint64_t v22;
  unsigned int v23;
  uint64_t v24;
  unint64_t i;
  _BOOL8 isDeviceAsset;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  int v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  const re::AssetHandle *v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  id v45;
  int v46;
  uint64_t v47;
  int *v48;
  int v49;
  re::RealityFileWriter::AssetWriteResult *v50;
  uint64_t v51;
  uint64_t v52;
  re::AssetHandle *v53;
  int v54;
  int v55;
  int v56;
  uint64_t v57;
  int *v58;
  int v59;
  re::RealityFileWriter::AssetWriteResult *v60;
  char *v61;
  id v62;
  unsigned int v63;
  uint64_t v64;
  uint64_t v65;
  re::AssetHandle *v66;
  AssetService *v67;
  _BOOL4 v68;
  re *v69;
  NSObject *v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  uint64_t v83;
  int *v84;
  int v85;
  unsigned int v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t *v89;
  re::AssetHandle *v90;
  unint64_t v91;
  re::DynamicString *v92;
  uint64_t v93;
  _DWORD *v94;
  uint64_t v95;
  const re::AssetHandle *v96;
  void *v97;
  id v98;
  int v99;
  int v100;
  uint64_t v101;
  int *v102;
  int v103;
  unsigned int v104;
  uint64_t v105;
  _QWORD *v106;
  uint64_t v107;
  _QWORD *v108;
  _QWORD *v109;
  re::AssetHandle *v110;
  _QWORD *v111;
  uint64_t v112;
  const re::AssetHandle *v113;
  uint64_t v114;
  const re::DynamicString *v115;
  uint64_t v116;
  uint64_t v117;
  re::AssetHandle *v118;
  uint64_t v119;
  int v120;
  uint64_t v121;
  int *v122;
  int v123;
  uint64_t v124;
  _anonymous_namespace_ *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  const re::AssetHandle *v129;
  void *v130;
  id v131;
  int v132;
  int v133;
  unint64_t v134;
  uint64_t v135;
  uint64_t v136;
  _anonymous_namespace_ *v137;
  char *v138;
  const char *v139;
  __n128 v140;
  int v141;
  int v142;
  uint64_t v143;
  re::RealityFileWriter::AssetWriteResult *v144;
  char *v145;
  re::RealityFileWriter::AssetWriteResult *v146;
  char *v147;
  id v148;
  __int128 v149;
  __int128 v150;
  re::RealityFileWriter::AssetWriteResult *v151;
  char *v152;
  unsigned __int8 *v153;
  _BYTE *v154;
  re::RealityFileWriter::AssetWriteResult *v155;
  char *v156;
  re::RealityFileWriter::AssetWriteResult *v157;
  char *v158;
  uint64_t v159;
  int *v160;
  int v161;
  uint64_t v162;
  uint64_t v163;
  unsigned int v164;
  _QWORD *v165;
  uint64_t v166;
  uint8_t *v167;
  unsigned __int8 *v168;
  uint64_t v169;
  id v170;
  int v171;
  int v172;
  char v173;
  id v174;
  char *v175;
  char *v176;
  char *v177;
  int v178;
  re::RealityFileWriter::AssetWriteResult *v179;
  char *v180;
  void *v181;
  id v182;
  const re::DynamicString *v183;
  int v184;
  re::RealityFileWriter::AssetWriteResult *v185;
  char *v186;
  re::RealityFileWriter::AssetWriteResult *v187;
  char *v188;
  id v189;
  unsigned int v190;
  unsigned int v191;
  re::RealityFileWriter::AssetWriteResult *v192;
  void *v193;
  char *v194;
  id v195;
  id v196;
  re::RealityFileWriter::AssetWriteResult *v197;
  char *v198;
  int v200;
  uint64_t v202;
  unsigned int v203;
  unsigned int v204;
  uint64_t v205;
  unsigned int v206;
  uint64_t v207;
  unsigned int v208;
  unsigned int v209;
  re::AssetManager *v211;
  id v212;
  uint64_t v213;
  id v214;
  char *v215;
  uint64_t v216;
  id v217;
  id v218;
  _BYTE v219[2];
  char *v220;
  uint64_t v221;
  id v222;
  char *v223;
  id v224;
  _BYTE v225[2];
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  id v229;
  char *v230;
  _DWORD *v231;
  id v232;
  uint64_t v233;
  re::AssetHandle *v234;
  id v235;
  id v236;
  uint64_t v237[3];
  int v238;
  _BYTE v239[24];
  id v240;
  _BYTE v241[44];
  id v242;
  uint64_t v243;
  id v244;
  id v245;
  id v246;
  uint64_t v247;
  unint64_t v248;
  const re::AssetHandle *v249;
  id v250;
  id v251;
  uint8_t buf[48];
  _BYTE v253[44];
  _BYTE v254[44];
  __int128 v255;
  __int128 v256;
  __int128 v257;
  __int128 v258;
  __int128 v259;
  uint64_t v260;

  v260 = *MEMORY[0x24BDAC8D0];
  if (*a4)
    re::RealityFileWriter::AssetWriteResult::clear(*a4);
  if (!*(_QWORD *)(a2 + 8))
    return 1;
  v6 = 0;
  v7 = 0;
  v8 = (unint64_t)v254;
  do
  {
    if (!(_BYTE)v255)
    {
      v14 = *a4;
      if (*a4)
      {
        v15 = (char *)v14 + 8;
        v16 = *((id *)&v255 + 1);
        v251 = v16;
        re::ObjCObject::operator=((id *)v14 + 12, &v251);

      }
      else
      {
        v16 = *((id *)&v255 + 1);
        v251 = v16;

      }
      return 0;
    }
    ++v7;
    v10 = *(_QWORD *)(a2 + 8);
    v6 += 120;
  }
  while (v7 < v10);
  if (!v10)
    goto LABEL_353;
  v11 = *(_QWORD *)(a2 + 16);
  v12 = *(_QWORD *)(v11 + 8);
  if (v12)
    v211 = *(re::AssetManager **)(v12 + 24);
  else
    v211 = 0;
  if (v10 >= 2)
  {
    v17 = (re::AssetManager **)(v11 + 128);
    v18 = v10 - 1;
    while (1)
    {
      v19 = *v17;
      if (*v17)
        v19 = (re::AssetManager *)*((_QWORD *)v19 + 3);
      if (v211 != v19)
        break;
      v17 += 15;
      if (!--v18)
        goto LABEL_23;
    }
    v13 = (uint64_t)*a4;
    if (*a4)
    {
      re::ObjCObject::operator=((id *)(v13 + 96), &v250);
    }
    else
    {
    }

    if ((_QWORD)v255 && (BYTE8(v255) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v255 + 40))();
    if (!v13)
      return v13;

    return 0;
  }
LABEL_23:
  v200 = a3;
  v20 = *((_QWORD *)v211 + 153);
  memset(v254, 0, 36);
  *(_QWORD *)&v254[36] = 0x7FFFFFFFLL;
  v21 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v20 + 72))(v20, *(_QWORD *)(*(_QWORD *)(a1 + 320) + 24));
  v209 = v21;
  v22 = *(_QWORD *)(a2 + 8);
  v249 = 0;
  v247 = 0;
  v248 = 0;
  v202 = v20;
  if (*(_QWORD *)(a2 + 8))
  {
    v205 = 0;
    v207 = 0;
    v8 = 0;
    v23 = 0;
    v24 = 0;
    v203 = 0;
    for (i = 0; i < *(_QWORD *)(a2 + 8); ++i)
    {
      re::AssetHandle::AssetHandle((re::AssetHandle *)buf, (const re::AssetHandle *)(*(_QWORD *)(a2 + 16) + 120 * i));
      isDeviceAsset = re::AssetManager::isDeviceAsset((uint64_t)v211, (uint64_t)buf, v209);
      if (isDeviceAsset)
      {
        v50 = *a4;
        if (*a4)
        {
          re::ObjCObject::operator=((id *)v50 + 12, &v246);
        }
        else
        {
        }

        if ((_QWORD)v255 && (BYTE8(v255) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v255 + 40))();
        if (v50)

        goto LABEL_331;
      }
      if ((**(unsigned int (***)(uint64_t, uint8_t *))v20)(v20, buf))
      {
        if ((*(unsigned int (**)(uint64_t, uint8_t *, _QWORD))(*(_QWORD *)v20 + 8))(v20, buf, *(_QWORD *)(*(_QWORD *)(a1 + 320) + 24)))
        {
          (*(void (**)(__int128 *__return_ptr, uint64_t, uint8_t *, _QWORD))(*(_QWORD *)v20 + 16))(&v255, v20, buf, *(_QWORD *)(*(_QWORD *)(a1 + 320) + 24));
          if (!(_BYTE)v255)
          {
            v151 = *a4;
            if (*a4)
            {
              v152 = (char *)v151 + 8;
              v245 = *((id *)&v255 + 1);
              re::ObjCObject::operator=((id *)v151 + 12, &v245);

            }
            else
            {
              v245 = *((id *)&v255 + 1);

            }
            v153 = (unsigned __int8 *)&v255;
LABEL_330:
            re::Result<re::AssetHandle,re::WrappedError>::~Result(v153);
LABEL_331:
            re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
            v13 = 0;
            goto LABEL_343;
          }
          re::AssetHandle::operator=((uint64_t *)buf, (uint64_t *)&v255 + 1);
          re::Result<re::AssetHandle,re::WrappedError>::~Result((unsigned __int8 *)&v255);
        }
        v27 = *(_QWORD *)(a2 + 8);
        if (v27 <= i)
          goto LABEL_352;
        re::RealityFileWriter::remapSceneAsset((re::RealityFileWriter *)v241, *(const re::AssetHandle **)(a1 + 408), (const re::DynamicString *)buf, *(_QWORD *)(a2 + 16) + 120 * i + 56);
        if (!v241[0])
        {
          v144 = *a4;
          if (*a4)
          {
            v145 = (char *)v144 + 8;
            v244 = *(id *)&v241[8];
            re::ObjCObject::operator=((id *)v144 + 12, &v244);

          }
          else
          {
            v244 = *(id *)&v241[8];

          }
          v153 = v241;
          goto LABEL_330;
        }
        re::AssetHandle::operator=((uint64_t *)buf, (uint64_t *)&v241[8]);
        re::Result<re::AssetHandle,re::WrappedError>::~Result(v241);
      }
      v27 = *(_QWORD *)(a2 + 8);
      if (v27 <= i)
      {
        *(_QWORD *)v241 = 0;
        v258 = 0u;
        v259 = 0u;
        v256 = 0u;
        v257 = 0u;
        v255 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v253 = 136315906;
        *(_QWORD *)&v253[4] = "operator[]";
        *(_WORD *)&v253[12] = 1024;
        *(_DWORD *)&v253[14] = 476;
        *(_WORD *)&v253[18] = 2048;
        *(_QWORD *)&v253[20] = i;
        *(_WORD *)&v253[28] = 2048;
        *(_QWORD *)&v253[30] = v27;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_351:
        *(_QWORD *)v241 = 0;
        v258 = 0u;
        v259 = 0u;
        v256 = 0u;
        v257 = 0u;
        v255 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v253 = 136315906;
        *(_QWORD *)&v253[4] = "operator[]";
        *(_WORD *)&v253[12] = 1024;
        *(_DWORD *)&v253[14] = 468;
        *(_WORD *)&v253[18] = 2048;
        *(_QWORD *)&v253[20] = i;
        *(_WORD *)&v253[28] = 2048;
        *(_QWORD *)&v253[30] = v27;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_352:
        v231 = 0;
        v258 = 0u;
        v259 = 0u;
        v256 = 0u;
        v257 = 0u;
        v255 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v253 = 136315906;
        *(_QWORD *)&v253[4] = "operator[]";
        *(_WORD *)&v253[12] = 1024;
        *(_DWORD *)&v253[14] = 476;
        *(_WORD *)&v253[18] = 2048;
        *(_QWORD *)&v253[20] = i;
        *(_WORD *)&v253[28] = 2048;
        *(_QWORD *)&v253[30] = v27;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
LABEL_353:
        *(_QWORD *)v253 = 0;
        *(_OWORD *)(v8 + 96) = 0u;
        *(_OWORD *)(v8 + 112) = 0u;
        *(_OWORD *)(v8 + 64) = 0u;
        *(_OWORD *)(v8 + 80) = 0u;
        *(_OWORD *)(v8 + 48) = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v254 = 136315906;
        *(_QWORD *)&v254[4] = "operator[]";
        *(_WORD *)&v254[12] = 1024;
        *(_DWORD *)&v254[14] = 476;
        *(_WORD *)&v254[18] = 2048;
        *(_QWORD *)&v254[20] = 0;
        *(_WORD *)&v254[28] = 2048;
        *(_QWORD *)&v254[30] = 0;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (*(_QWORD *)&buf[8])
        v28 = *(_QWORD *)(*(_QWORD *)&buf[8] + 664);
      else
        v28 = 0;
      v29 = *(_QWORD *)(a2 + 16);
      v30 = 0x94D049BB133111EBLL
          * ((0xBF58476D1CE4E5B9 * (*(_QWORD *)&buf[8] ^ (*(_QWORD *)&buf[8] >> 30))) ^ ((0xBF58476D1CE4E5B9
                                                                                          * (*(_QWORD *)&buf[8] ^ (*(_QWORD *)&buf[8] >> 30))) >> 27));
      v31 = v28 ^ (v30 >> 31) ^ v30;
      if (*(_QWORD *)v254)
      {
        v32 = v31 % v203;
        v33 = *(unsigned int *)(v205 + 4 * v32);
        if ((_DWORD)v33 != 0x7FFFFFFF)
        {
          while (*(_QWORD *)(v24 + 160 * v33 + 24) != *(_QWORD *)&buf[8])
          {
            v33 = *(_DWORD *)(v24 + 160 * v33 + 8) & 0x7FFFFFFF;
            if (v33 == 0x7FFFFFFF)
              goto LABEL_43;
          }
          goto LABEL_51;
        }
      }
      else
      {
        v32 = 0;
      }
LABEL_43:
      v34 = *(unsigned int *)&v254[36];
      if (*(_DWORD *)&v254[36] == 0x7FFFFFFF)
      {
        v35 = v23;
        v203 = *(_DWORD *)&v254[24];
        if (v23 == *(_DWORD *)&v254[24])
        {
          re::HashTable<re::AssetHandle,re::RealityFileWriter::AssetHandleWithMetadata,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::setCapacity((uint64_t)v254, 2 * v8);
          v35 = *(_DWORD *)&v254[32];
          v203 = *(_DWORD *)&v254[24];
          v32 = v31 % *(unsigned int *)&v254[24];
          v24 = *(_QWORD *)&v254[16];
          v207 = *(_QWORD *)&v254[8];
        }
        v204 = v35 + 1;
        v206 = v23;
        *(_DWORD *)&v254[32] = v35 + 1;
        v34 = v23;
        v36 = *(_DWORD *)(v24 + 160 * v23 + 8);
      }
      else
      {
        v36 = *(_DWORD *)(v24 + 160 * *(unsigned int *)&v254[36] + 8);
        *(_DWORD *)&v254[36] = v36 & 0x7FFFFFFF;
        v204 = v23;
        v206 = v34;
      }
      *(_DWORD *)(v24 + 160 * v34 + 8) = v36 | 0x80000000;
      v37 = v32;
      v24 = *(_QWORD *)&v254[16];
      v38 = *(_QWORD *)&v254[16] + 160 * v34;
      *(_DWORD *)(v38 + 8) = *(_DWORD *)(v38 + 8) & 0x80000000 | *(_DWORD *)(v207 + 4 * v32);
      *(_QWORD *)v38 = v31;
      re::AssetHandle::AssetHandle((re::AssetHandle *)(v38 + 16), (const re::AssetHandle *)buf);
      re::AssetHandle::AssetHandle((re::AssetHandle *)(v38 + 40), (const re::AssetHandle *)(v29 + 120 * i));
      v39 = v29 + 120 * i;
      re::DynamicString::DynamicString((re::DynamicString *)(v38 + 64), (const re::DynamicString *)(v39 + 24));
      re::DynamicString::DynamicString((re::DynamicString *)(v38 + 96), (const re::DynamicString *)(v39 + 56));
      *(_WORD *)(v38 + 128) = *(_WORD *)(v39 + 88);
      v40 = *(unsigned __int8 *)(v39 + 90);
      *(_BYTE *)(v38 + 130) = v40;
      if (v40)
        *(_BYTE *)(v24 + 160 * v34 + 131) = *(_BYTE *)(v29 + 120 * i + 91);
      re::FixedArray<re::DynamicString>::FixedArray((re::DynamicString *)(v24 + 160 * v34 + 136), v29 + 120 * i + 96);
      *(_DWORD *)(v207 + 4 * v37) = v206;
      v8 = ++*(_DWORD *)&v254[28];
      ++*(_DWORD *)&v254[40];
      v205 = v207;
      v20 = v202;
      v23 = v204;
LABEL_51:
      v27 = v248;
      if (v248 <= i)
        goto LABEL_351;
      re::AssetHandle::operator=((uint64_t *)v249 + 3 * i, (uint64_t *)buf);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
    }
  }
  LODWORD(v257) = 0;
  v255 = 0u;
  v256 = 0u;
  *(_QWORD *)((char *)&v257 + 4) = 0x7FFFFFFFLL;
  if (v200)
  {
    *(_QWORD *)v241 = v249;
    *(_QWORD *)&v241[8] = v248;
    re::AssetDeduplication::deduplicate((uint64_t)v241, (uint64_t)v211, (uint64_t)v253);
    re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::operator=((uint64_t)&v255, (uint64_t *)v253);
    re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)v253);
  }
  memset(v253, 0, 36);
  *(_QWORD *)&v253[36] = 0x7FFFFFFFLL;
  if (!v248)
  {
    v46 = 0;
LABEL_72:
    LODWORD(v47) = 0;
    goto LABEL_73;
  }
  v41 = v249;
  v42 = 24 * v248;
  do
  {
    v43 = *(_QWORD *)(a1 + 320);
    v243 = v43;
    if (v43)
    {
      v44 = (void *)(v43 + 8);
      v45 = (id)(v43 + 8);

      v243 = 0;
    }
    else
    {
    }
    if (!v241[0])
    {
      v60 = *a4;
      if (*a4)
      {
        v61 = (char *)v60 + 8;
        v62 = *(id *)&v241[8];
        v242 = v62;
        re::ObjCObject::operator=((id *)v60 + 12, &v242);

      }
      else
      {
        v62 = *(id *)&v241[8];
        v242 = v62;

      }
      goto LABEL_341;
    }
    v41 = (const re::AssetHandle *)((char *)v41 + 24);
    v42 -= 24;
  }
  while (v42);
  v46 = *(_DWORD *)&v253[32];
  if (!*(_DWORD *)&v253[32])
    goto LABEL_72;
  v47 = 0;
  v48 = (int *)(*(_QWORD *)&v253[16] + 8);
  while (1)
  {
    v49 = *v48;
    v48 += 10;
    if (v49 < 0)
      break;
    if (*(unsigned int *)&v253[32] == ++v47)
    {
      LODWORD(v47) = *(_DWORD *)&v253[32];
      break;
    }
  }
LABEL_73:
  if (v46 != (_DWORD)v47)
  {
    v51 = v47;
    v52 = *(_QWORD *)&v253[16];
    do
    {
      v53 = (re::AssetHandle *)(v52 + 40 * v51 + 16);
      if (!re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::containsKey((uint64_t)&v255, (uint64_t)v53))re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add((uint64_t)&v255, v53, v53);
      v52 = *(_QWORD *)&v253[16];
      if (*(_DWORD *)&v253[32] <= (v47 + 1))
        v54 = v47 + 1;
      else
        v54 = *(_DWORD *)&v253[32];
      while (1)
      {
        v51 = (v47 + 1);
        if (v54 - 1 == (_DWORD)v47)
          break;
        LODWORD(v47) = v47 + 1;
        v55 = v51;
        if ((*(_DWORD *)(*(_QWORD *)&v253[16] + 40 * v51 + 8) & 0x80000000) != 0)
          goto LABEL_84;
      }
      v55 = v54;
LABEL_84:
      LODWORD(v47) = v55;
    }
    while (v46 != v55);
  }
  v56 = v257;
  if ((_DWORD)v257)
  {
    v57 = 0;
    v58 = (int *)(v256 + 8);
    while (1)
    {
      v59 = *v58;
      v58 += 16;
      if (v59 < 0)
        break;
      if (v257 == ++v57)
      {
        LODWORD(v57) = v257;
        break;
      }
    }
  }
  else
  {
    LODWORD(v57) = 0;
  }
  v63 = v257;
  if ((_DWORD)v257 != (_DWORD)v57)
  {
    v64 = v57;
    v65 = v256;
    do
    {
      v66 = (re::AssetHandle *)(v65 + (v64 << 6) + 16);
      memset(v241, 0, 36);
      *(_QWORD *)&v241[36] = 0x7FFFFFFFLL;
      v67 = (AssetService *)re::AssetHandle::legacy_assetPath(v66);
      re::RealityFileWriter::customizeAssetPathMapping(&v231, (re::AssetPathMapping *)a1, (const re::AssetPath *)v241, v67, (uint64_t)v211);
      if (!(_BYTE)v231)
      {
        v146 = *a4;
        if (*a4)
        {
          v147 = (char *)v146 + 8;
          v148 = v232;
          v240 = v148;
          re::ObjCObject::operator=((id *)v146 + 12, &v240);

        }
        else
        {
          v148 = v232;
          v240 = v148;

        }
        re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)v241);
        goto LABEL_341;
      }
      re::AssetHandle::AssetHandle((re::AssetHandle *)v239, v66);
      re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::HashTable((uint64_t)v237, (uint64_t)v241);
      if (v238)
      {
        v68 = re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::containsKey((uint64_t)v237, (uint64_t)v239);
        re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit(v237);
        re::AssetHandle::~AssetHandle((re::AssetHandle *)v239);
        if (v68)
        {
          v70 = *re::assetsLogObjects(v69);
          if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
          {
            v71 = **(_QWORD **)(*((_QWORD *)v66 + 1) + 264);
            v72 = *((_QWORD *)re::AssetHandle::assetInfo(v66) + 10);
            if (v72 == -1)
              v72 = 0;
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = v71;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v72;
            _os_log_impl(&dword_224FE9000, v70, OS_LOG_TYPE_DEFAULT, "Not writing remapped %s with assetID: %llu", buf, 0x16u);
          }
          if ((_QWORD)v255)
          {
            v73 = *((_QWORD *)v66 + 1);
            v74 = v73 ? *(_QWORD *)(v73 + 664) : 0;
            v75 = 0x94D049BB133111EBLL
                * ((0xBF58476D1CE4E5B9 * (v73 ^ (v73 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v73 ^ (v73 >> 30))) >> 27));
            v76 = (v74 ^ (v75 >> 31) ^ v75) % DWORD2(v256);
            v77 = *(unsigned int *)(*((_QWORD *)&v255 + 1) + 4 * v76);
            if ((_DWORD)v77 != 0x7FFFFFFF)
            {
              v78 = v256 + (v77 << 6);
              if (*(_QWORD *)(v78 + 24) == v73)
              {
                *(_DWORD *)(*((_QWORD *)&v255 + 1) + 4 * v76) = *(_DWORD *)(v78 + 8) & 0x7FFFFFFF;
LABEL_113:
                re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::EntryWithHash::free((_DWORD *)(v256 + (v77 << 6)));
                *(_DWORD *)(v256 + (v77 << 6) + 8) = *(_DWORD *)(v256 + (v77 << 6) + 8) & 0x80000000 | DWORD1(v257);
                --HIDWORD(v256);
                *(_QWORD *)((char *)&v257 + 4) = __PAIR64__(DWORD2(v257), v77) + 0x100000000;
              }
              else
              {
                while (1)
                {
                  v79 = v77;
                  v77 = *(_DWORD *)(v256 + (v77 << 6) + 8) & 0x7FFFFFFF;
                  if (v77 == 0x7FFFFFFF)
                    break;
                  v80 = v256 + (v77 << 6);
                  if (*(_QWORD *)(v80 + 24) == v73)
                  {
                    *(_DWORD *)(v256 + (v79 << 6) + 8) = *(_DWORD *)(v256 + (v79 << 6) + 8) & 0x80000000 | *(_DWORD *)(v80 + 8) & 0x7FFFFFFF;
                    goto LABEL_113;
                  }
                }
              }
            }
          }
        }
      }
      else
      {
        re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit(v237);
        re::AssetHandle::~AssetHandle((re::AssetHandle *)v239);
      }
      re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)v241);
      v63 = v257;
      v65 = v256;
      if (v257 <= (int)v57 + 1)
        v81 = v57 + 1;
      else
        v81 = v257;
      while (1)
      {
        v64 = (v57 + 1);
        if (v81 - 1 == (_DWORD)v57)
          break;
        LODWORD(v57) = v57 + 1;
        v82 = v64;
        if ((*(_DWORD *)(v256 + (v64 << 6) + 8) & 0x80000000) != 0)
          goto LABEL_121;
      }
      v82 = v81;
LABEL_121:
      LODWORD(v57) = v82;
    }
    while (v56 != v82);
  }
  v83 = 0;
  if (v63)
  {
    v84 = (int *)(v256 + 8);
    while (1)
    {
      v85 = *v84;
      v84 += 16;
      if (v85 < 0)
        break;
      if (v63 == ++v83)
      {
        LODWORD(v83) = v63;
        break;
      }
    }
  }
  if (v63 != (_DWORD)v83)
  {
    v87 = v83;
    v88 = v256;
    while (1)
    {
      v89 = (unint64_t *)(v88 + (v87 << 6));
      v90 = (re::AssetHandle *)(v89 + 2);
      v91 = v89[3];
      if (v91 == v89[6])
      {
        v95 = re::HashTable<re::AssetHandle,re::RealityFileWriter::AssetHandleWithMetadata,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::tryGet((uint64_t)v254, v91);
        if (v95)
          v96 = (const re::AssetHandle *)v95;
        else
          v96 = v90;
        re::AssetHandle::AssetHandle((re::AssetHandle *)v241, v96);
        re::RealityFileWriter::getOrMakeAssetInfo((re::RealityFileWriter *)buf, (const re::AssetHandle *)a1, (re::AssetHandle *)v241);
        re::AssetHandle::~AssetHandle((re::AssetHandle *)v241);
        if (!buf[0])
        {
          v157 = *a4;
          if (*a4)
          {
            v158 = (char *)v157 + 8;
            v236 = *(id *)&buf[8];
            re::ObjCObject::operator=((id *)v157 + 12, &v236);

          }
          else
          {
            v236 = *(id *)&buf[8];

          }
          re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)buf);
LABEL_341:
          v13 = 0;
          goto LABEL_342;
        }
        if (*(_QWORD *)&buf[8])
        {
          v97 = (void *)(*(_QWORD *)&buf[8] + 8);
          v98 = (id)(*(_QWORD *)&buf[8] + 8);

        }
        re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)buf);
      }
      else
      {
        v92 = (re::DynamicString *)re::AssetHandle::legacy_assetPath(v90);
        v93 = *((_QWORD *)v92 + 1);
        memset(&v241[8], 0, 24);
        *(_QWORD *)v241 = v93;
        re::DynamicString::setCapacity(v241, 0);
        re::AssetPath::fullAssetPath(v92, (re::DynamicString *)v241);
        re::RealityFileWriter::AssetInfoTable::tryGetAssetInfo((re::RealityFileWriter::AssetInfoTable *)(a1 + 24), (const re::DynamicString *)v241, (uint64_t *)&v231);
        v94 = v231;
        if (v231)
        {
          if (v231[6] == 1)
          {
            if ((v241[8] & 1) != 0)
              v154 = *(_BYTE **)&v241[16];
            else
              v154 = &v241[9];
            re::DynamicString::format((re::DynamicString *)"The asset '%s' has been selected to be pruned from the reality file because it is a duplicate of another asset, but it has already been written to the reality file. This could happen if ::writeAssetArrayAndDependencies is invoked with the deduplicate argument after previous calls to write assets.", (re::DynamicString *)buf, v154);
            if (*(_QWORD *)buf && (buf[8] & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)buf + 40))();
            v155 = *a4;
            if (*a4)
            {
              v156 = (char *)v155 + 8;
              v235 = v229;
              re::ObjCObject::operator=((id *)v155 + 12, &v235);

            }
            else
            {
              v235 = v229;

            }
            if (*(_QWORD *)v241 && (v241[8] & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)v241 + 40))();
            goto LABEL_341;
          }

        }
        if (*(_QWORD *)v241 && (v241[8] & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)v241 + 40))();
      }
      v86 = v257;
      v88 = v256;
      if (v257 <= (int)v83 + 1)
        v99 = v83 + 1;
      else
        v99 = v257;
      while (1)
      {
        v87 = (v83 + 1);
        if (v99 - 1 == (_DWORD)v83)
          break;
        LODWORD(v83) = v83 + 1;
        v100 = v87;
        if ((*(_DWORD *)(v256 + (v87 << 6) + 8) & 0x80000000) != 0)
          goto LABEL_151;
      }
      v100 = v99;
LABEL_151:
      LODWORD(v83) = v100;
      if (v63 == v100)
        goto LABEL_152;
    }
  }
  v86 = v63;
LABEL_152:
  memset(v241, 0, 36);
  *(_QWORD *)&v241[36] = 0x7FFFFFFFLL;
  v101 = 0;
  if (v86)
  {
    v102 = (int *)(v256 + 8);
    while (1)
    {
      v103 = *v102;
      v102 += 16;
      if (v103 < 0)
        break;
      if (v86 == ++v101)
      {
        LODWORD(v101) = v86;
        break;
      }
    }
  }
  if (v86 != (_DWORD)v101)
  {
    v105 = v101;
    v106 = (_QWORD *)(a1 + 200);
    v107 = v256;
    v208 = v86;
    while (1)
    {
      v108 = v106;
      v109 = (_QWORD *)(v107 + (v105 << 6));
      v110 = (re::AssetHandle *)(v109 + 2);
      v111 = v109 + 5;
      v112 = re::HashTable<re::AssetHandle,re::RealityFileWriter::AssetHandleWithMetadata,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::tryGet((uint64_t)v254, v109[6]);
      if (v112)
        v113 = (const re::AssetHandle *)v112;
      else
        v113 = (const re::AssetHandle *)(v109 + 5);
      re::AssetHandle::AssetHandle((re::AssetHandle *)buf, v113);
      re::RealityFileWriter::getAssetInfo((re::RealityFileWriter *)&v221, (const re::AssetHandle *)a1, (re::AssetHandle *)buf);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
      v114 = v221;
      v115 = (const re::DynamicString *)(v221 + 32);
      re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add((uint64_t)v241, (re::AssetHandle *)(v109 + 2), (const re::DynamicString *)(v221 + 32));
      v116 = v109[3];
      v117 = v109[6];
      if (v116 != v117)
        goto LABEL_199;
      re::AssetManager::findDependencies(v211, (const re::AssetHandle *)(v109 + 2), (uint64_t)&v231);
      memset(buf, 0, 36);
      *(_QWORD *)&buf[36] = 0x7FFFFFFFLL;
      if (v233)
      {
        v118 = v234;
        v119 = 24 * v233;
        do
        {
          if (*((_QWORD *)v118 + 1))
            re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add((uint64_t)buf, v118);
          v118 = (re::AssetHandle *)((char *)v118 + 24);
          v119 -= 24;
        }
        while (v119);
        v120 = *(_DWORD *)&buf[32];
        if (*(_DWORD *)&buf[32])
        {
          v121 = 0;
          v122 = (int *)(*(_QWORD *)&buf[16] + 8);
          while (1)
          {
            v123 = *v122;
            v122 += 10;
            if (v123 < 0)
              goto LABEL_182;
            if (*(unsigned int *)&buf[32] == ++v121)
            {
              LODWORD(v121) = *(_DWORD *)&buf[32];
              goto LABEL_182;
            }
          }
        }
      }
      else
      {
        v120 = 0;
      }
      LODWORD(v121) = 0;
LABEL_182:
      if (v120 != (_DWORD)v121)
      {
        v124 = v121;
        v125 = (_anonymous_namespace_ *)(v114 + 96);
        v126 = *(_QWORD *)&buf[16];
        do
        {
          v127 = v126 + 40 * v124 + 16;
          if (!re::AssetManager::isDeviceAsset((uint64_t)v211, v127, v209))
          {
            v128 = re::HashTable<re::AssetHandle,re::RealityFileWriter::AssetHandleWithMetadata,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::tryGet((uint64_t)v254, *(_QWORD *)(v127 + 8));
            v129 = (const re::AssetHandle *)(v128 ? v128 : v127);
            re::AssetHandle::AssetHandle((re::AssetHandle *)&v229, v129);
            re::RealityFileWriter::getAssetInfo((re::RealityFileWriter *)&v216, (const re::AssetHandle *)a1, (re::AssetHandle *)&v229);
            re::AssetHandle::~AssetHandle((re::AssetHandle *)&v229);
            if (v216)
            {
              v228 = v216;
              v130 = (void *)(v216 + 8);
              v131 = (id)(v216 + 8);
              re::DynamicArray<re::SharedPtr<re::AssetLoadRequest>>::add(v125, &v228);

              v228 = 0;
            }
          }
          v126 = *(_QWORD *)&buf[16];
          if (*(_DWORD *)&buf[32] <= (v121 + 1))
            v132 = v121 + 1;
          else
            v132 = *(_DWORD *)&buf[32];
          while (1)
          {
            v124 = (v121 + 1);
            if (v132 - 1 == (_DWORD)v121)
              break;
            LODWORD(v121) = v121 + 1;
            v133 = v124;
            if ((*(_DWORD *)(*(_QWORD *)&buf[16] + 40 * v124 + 8) & 0x80000000) != 0)
              goto LABEL_197;
          }
          v133 = v132;
LABEL_197:
          LODWORD(v121) = v133;
        }
        while (v120 != v133);
      }
      re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)buf);
      re::DynamicArray<re::AssetHandle>::deinit((uint64_t)&v231);
      v116 = *((_QWORD *)v110 + 1);
      v117 = v111[1];
      v86 = v208;
LABEL_199:
      v106 = v108;
      if (v116 == v117)
        goto LABEL_218;
      re::DynamicString::DynamicString((re::DynamicString *)&v231, v115);
      if (!re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey((uint64_t)v108, (uint64_t)&v231))
      {
        *(_QWORD *)&buf[32] = 0;
        memset(buf, 0, 28);
        re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add((uint64_t)v108, (re::DynamicString *)&v231, (uint64_t)buf);
        re::DynamicArray<re::DynamicString>::deinit((uint64_t)buf);
      }
      v134 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, (uint64_t)&v231);
      if (*v108)
      {
        v135 = *(_QWORD *)(a1 + 216);
        v136 = *(unsigned int *)(*(_QWORD *)(a1 + 208) + 4 * (v134 % *(unsigned int *)(a1 + 224)));
        if ((_DWORD)v136 != 0x7FFFFFFF)
        {
          while (!re::DynamicString::operator==(v135 + 88 * v136 + 16, (uint64_t)&v231))
          {
            v136 = *(_DWORD *)(v135 + 88 * v136 + 8) & 0x7FFFFFFF;
            if (v136 == 0x7FFFFFFF)
              goto LABEL_208;
          }
          goto LABEL_209;
        }
      }
      else
      {
        v135 = *(_QWORD *)(a1 + 216);
      }
LABEL_208:
      v136 = 0x7FFFFFFFLL;
LABEL_209:
      v137 = (_anonymous_namespace_ *)(v135 + 88 * v136 + 48);
      v138 = (char *)re::AssetHandle::assetInfo(v110);
      if ((*((_QWORD *)v138 + 13) & 1) != 0)
        v139 = (const char *)*((_QWORD *)v138 + 14);
      else
        v139 = v138 + 105;
      v140.n128_f64[0] = re::DynamicArray<re::DynamicString>::add(v137, buf);
      if (*(_QWORD *)buf && (buf[8] & 1) != 0)
        (*(void (**)(double))(**(_QWORD **)buf + 40))(v140.n128_f64[0]);
      if (v231 && (v232 & 1) != 0)
        (*(void (**)(__n128))(*(_QWORD *)v231 + 40))(v140);
LABEL_218:
      if (v221)

      v104 = v257;
      v107 = v256;
      if (v257 <= (int)v101 + 1)
        v141 = v101 + 1;
      else
        v141 = v257;
      while (1)
      {
        v105 = (v101 + 1);
        if (v141 - 1 == (_DWORD)v101)
          break;
        LODWORD(v101) = v101 + 1;
        v142 = v105;
        if ((*(_DWORD *)(v256 + (v105 << 6) + 8) & 0x80000000) != 0)
          goto LABEL_227;
      }
      v142 = v141;
LABEL_227:
      LODWORD(v101) = v142;
      if (v86 == v142)
        goto LABEL_228;
    }
  }
  v104 = v86;
LABEL_228:
  if ((v200 & 1) != 0)
  {
    re::AssetDeduplication::remap((uint64_t)&v255, (uint64_t)v241, (uint64_t)buf);
    v143 = *(_QWORD *)buf;
    if (!*(_QWORD *)v241 || *(_QWORD *)v241 == *(_QWORD *)buf)
    {
      *(_QWORD *)buf = *(_QWORD *)v241;
      v149 = *(_OWORD *)&v241[8];
      *(_QWORD *)v241 = v143;
      *(_QWORD *)&v241[8] = *(_QWORD *)&buf[8];
      *(_QWORD *)&v241[16] = *(_QWORD *)&buf[16];
      *(_OWORD *)&buf[8] = v149;
      v150 = *(_OWORD *)&v241[24];
      *(_OWORD *)&v241[24] = *(_OWORD *)&buf[24];
      *(_OWORD *)&buf[24] = v150;
    }
    else if (*(_QWORD *)buf)
    {
      re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::copy((uint64_t)v241, (uint64_t)buf);
      ++*(_DWORD *)&v241[40];
    }
    else
    {
      re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::clear((uint64_t)v241);
    }
    re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)buf);
    v104 = v257;
  }
  v159 = 0;
  if (v104)
  {
    v160 = (int *)(v256 + 8);
    while (1)
    {
      v161 = *v160;
      v160 += 16;
      if (v161 < 0)
        break;
      if (v104 == ++v159)
      {
        LODWORD(v159) = v104;
        break;
      }
    }
  }
  if (v104 == (_DWORD)v159)
  {
LABEL_324:
    v13 = 1;
    goto LABEL_325;
  }
  v162 = v159;
  v163 = v256;
  v164 = v104;
  while (1)
  {
    v165 = (_QWORD *)(v163 + (v162 << 6));
    if (v165[3] == v165[6])
      break;
LABEL_316:
    if (v164 <= (int)v159 + 1)
      v190 = v159 + 1;
    else
      v190 = v164;
    while (1)
    {
      v162 = (v159 + 1);
      if (v190 - 1 == (_DWORD)v159)
        break;
      LODWORD(v159) = v159 + 1;
      v191 = v162;
      if ((*(_DWORD *)(v163 + (v162 << 6) + 8) & 0x80000000) != 0)
        goto LABEL_323;
    }
    v191 = v190;
LABEL_323:
    LODWORD(v159) = v191;
    if (v104 == v191)
      goto LABEL_324;
  }
  re::AssetHandle::AssetHandle((re::AssetHandle *)buf, (const re::AssetHandle *)(v165 + 5));
  v166 = re::HashTable<re::AssetHandle,re::RealityFileWriter::AssetHandleWithMetadata,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::tryGet((uint64_t)v254, *(unint64_t *)&buf[8]);
  if (v166)
    v167 = (uint8_t *)v166;
  else
    v167 = buf;
  re::AssetHandle::AssetHandle((re::AssetHandle *)&v231, (const re::AssetHandle *)v167);
  re::RealityFileWriter::getAssetInfo((re::RealityFileWriter *)&v227, (const re::AssetHandle *)a1, (re::AssetHandle *)&v231);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v231);
  v168 = (unsigned __int8 *)re::HashTable<re::AssetHandle,re::RealityFileWriter::AssetHandleWithMetadata,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::tryGet((uint64_t)v254, *(unint64_t *)&buf[8]);
  v169 = v227;
  if (*(_DWORD *)(v227 + 24) == 1)
    goto LABEL_281;
  v226 = v227;
  v170 = (id)(v227 + 8);
  if (v168)
  {
    v171 = v168[89];
    v225[0] = v168[90];
    if (v225[0])
      v225[1] = v168[91];
  }
  else
  {
    v171 = 0;
    v225[0] = 0;
  }
  re::RealityFileWriter::saveAssetToArchive((uint64_t)&v231, (re::AssetPathMapping *)a1, (re::AssetHandle *)buf, &v226, (uint64_t)v241, v171, v225, v202);

  v226 = 0;
  if ((_BYTE)v231)
  {
LABEL_281:
    v172 = (**(uint64_t (***)(uint64_t, uint8_t *))v202)(v202, buf);
    v173 = v172;
    if (!v172
      || ((*(uint64_t (**)(uint64_t, uint8_t *, _QWORD))(*(_QWORD *)v202 + 40))(v202, buf, *(_QWORD *)(*(_QWORD *)(a1 + 320) + 24)) & 1) != 0)
    {
      v213 = v169;
      v174 = (id)(v169 + 8);
      re::RealityFileWriter::assignSceneSettingsToAssetInfo((_anonymous_namespace_ *)&v231, (re::DynamicString *)a1, &v213, (uint64_t)v168, v173);

      v213 = 0;
      if (!(_BYTE)v231)
      {
        v192 = *a4;
        if (*a4)
        {
          v193 = (char *)v192 + 8;
          v194 = (char *)v192 + 8;
          v195 = v232;
          v212 = v195;
          re::ObjCObject::operator=((id *)v192 + 12, &v212);
          v196 = v212;
LABEL_334:

          goto LABEL_348;
        }
        v195 = v232;
        v212 = v195;
        goto LABEL_347;
      }
      goto LABEL_315;
    }
    (*(void (**)(_DWORD **__return_ptr, uint64_t, uint8_t *, _QWORD))(*(_QWORD *)v202 + 48))(&v231, v202, buf, *(_QWORD *)(*(_QWORD *)(a1 + 320) + 24));
    re::RealityFileWriter::getOrMakeAssetInfo((re::RealityFileWriter *)&v229, (const re::AssetHandle *)a1, (re::AssetHandle *)&v231);
    if (!(_BYTE)v229)
    {
      v179 = *a4;
      if (*a4)
      {
        v180 = (char *)v179 + 8;
        v223 = v230;
        re::ObjCObject::operator=((id *)v179 + 12, (id *)&v223);

      }
      else
      {
        v223 = v230;

      }
      v184 = 1;
LABEL_314:
      re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)&v229);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)&v231);
      if (v184)
        goto LABEL_349;
LABEL_315:

      re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
      v164 = v257;
      v163 = v256;
      goto LABEL_316;
    }
    v175 = v230;
    if (v230)
    {
      v176 = v230 + 8;
      v177 = v175 + 8;
    }
    v220 = v175;
    if (v168)
    {
      v178 = v168[89];
      v219[0] = v168[90];
      if (v219[0])
        v219[1] = v168[91];
    }
    else
    {
      v178 = 0;
      v219[0] = 0;
    }
    re::RealityFileWriter::saveAssetToArchive((uint64_t)&v221, (re::AssetPathMapping *)a1, (re::AssetHandle *)&v231, (uint64_t *)&v220, (uint64_t)v241, v178, v219, v202);
    if (v175)
    {
      v181 = v175 + 8;

      v220 = 0;
      if ((_BYTE)v221)
      {
        v215 = v175;
        v182 = v181;
        re::RealityFileWriter::assignSceneSettingsToAssetInfo((_anonymous_namespace_ *)&v216, (re::DynamicString *)a1, (uint64_t *)&v215, (uint64_t)v168, 1);

        v215 = 0;
LABEL_299:
        if ((_BYTE)v216)
        {
          re::RealityFileWriter::AssetInfo::addSceneVariant((re::RealityFileWriter::AssetInfo *)v175, (const re::DynamicString *)(v169 + 32), v183);
          v184 = 0;
          goto LABEL_312;
        }
        v187 = *a4;
        if (*a4)
        {
          v188 = (char *)v187 + 8;
          v189 = v217;
          v214 = v189;
          re::ObjCObject::operator=((id *)v187 + 12, &v214);

        }
        else
        {
          v189 = v217;
          v214 = v189;

        }
LABEL_311:
        v184 = 1;
LABEL_312:
        if (v175)

        goto LABEL_314;
      }
    }
    else if ((_BYTE)v221)
    {
      v215 = 0;
      re::RealityFileWriter::assignSceneSettingsToAssetInfo((_anonymous_namespace_ *)&v216, (re::DynamicString *)a1, (uint64_t *)&v215, (uint64_t)v168, 1);
      goto LABEL_299;
    }
    v185 = *a4;
    if (*a4)
    {
      v186 = (char *)v185 + 8;
      v218 = v222;
      re::ObjCObject::operator=((id *)v185 + 12, &v218);

    }
    else
    {
      v218 = v222;

    }
    goto LABEL_311;
  }
  v197 = *a4;
  if (*a4)
  {
    v193 = (char *)v197 + 8;
    v198 = (char *)v197 + 8;
    v195 = v232;
    v224 = v195;
    re::ObjCObject::operator=((id *)v197 + 12, &v224);
    v196 = v224;
    goto LABEL_334;
  }
  v195 = v232;
  v224 = v195;
LABEL_347:

LABEL_348:
LABEL_349:

  re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
  v13 = 0;
LABEL_325:
  re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)v241);
LABEL_342:
  re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)v253);
  re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)&v255);
LABEL_343:
  re::FixedArray<re::AssetHandle>::deinit(&v247);
  re::HashTable<re::AssetHandle,re::RealityFileWriter::AssetHandleWithMetadata,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)v254);
  return v13;
}

uint64_t re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    if (!*(_QWORD *)a1 || *(_QWORD *)a1 == *a2)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)a1, a2);
    }
    else if (*a2)
    {
      re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::copy(a1, (uint64_t)a2);
      ++*(_DWORD *)(a1 + 40);
    }
    else
    {
      re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::clear(a1);
    }
  }
  return a1;
}

uint64_t `anonymous namespace'::gatherDependencies(uint64_t result, const re::AssetHandle *a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5;
  uint64_t v10;
  re::AssetManager *v11;
  uint64_t v12;
  re::AssetHandle *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  id v18;
  re::AssetPath *v19;
  _BYTE *v20;
  re::AssetPath *v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  _BYTE v27[23];
  uint64_t v28;
  char v29;
  _BYTE v30[23];
  _OWORD v31[2];
  uint64_t v32;
  _BYTE v33[16];
  uint64_t v34;
  re::AssetHandle *v35;
  _BYTE v36[8];
  uint64_t v37;

  v5 = result;
  if (!*((_QWORD *)a2 + 1))
    goto LABEL_9;
  result = re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::contains(a4, (uint64_t)a2);
  if ((_DWORD)result)
    goto LABEL_9;
  if (!v36[0])
  {
    *(_BYTE *)v5 = 0;
    v12 = v37;
    v37 = 0;
    *(_QWORD *)(v5 + 8) = v12;
    return result;
  }
  v10 = *((_QWORD *)a2 + 1);
  v11 = v10 ? *(re::AssetManager **)(v10 + 24) : 0;
  result = re::AssetManager::isDeviceAsset((uint64_t)v11, (uint64_t)a2, a3);
  if ((_DWORD)result)
  {
LABEL_9:
    *(_BYTE *)v5 = 1;
  }
  else
  {
    re::HashSetBase<re::AssetHandle,re::AssetHandle,re::internal::ValueAsKey<re::AssetHandle>,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(a4, a2);
    re::AssetManager::findDependencies(v11, a2, (uint64_t)v33);
    if (v34)
    {
      v13 = v35;
      v14 = 24 * v34;
      while (1)
      {
        v15 = *a5;
        if (!*(_BYTE *)(*a5 + 40))
        {
          v16 = *((_QWORD *)v13 + 1);
          if (v16)
          {
            if (*(re::AssetManager **)(v16 + 24) != v11)
              break;
          }
        }
        v24 = *a5;
        v17 = (void *)(v15 + 8);
        v18 = (id)(v15 + 8);

        v24 = 0;
        if (!*(_BYTE *)v5)
          return re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v33);
        v13 = (re::AssetHandle *)((char *)v13 + 24);
        v14 -= 24;
        if (!v14)
          goto LABEL_17;
      }
      v19 = (re::AssetPath *)re::AssetHandle::legacy_assetPath(v13);
      re::AssetPath::fullAssetPath(v19, (re::DynamicString *)&v28);
      if ((v29 & 1) != 0)
        v20 = *(_BYTE **)&v30[7];
      else
        v20 = v30;
      v21 = (re::AssetPath *)re::AssetHandle::legacy_assetPath(a2);
      re::AssetPath::fullAssetPath(v21, (re::DynamicString *)&v25);
      if ((v26 & 1) != 0)
        v22 = *(_BYTE **)&v27[7];
      else
        v22 = v27;
      re::DynamicString::format((re::DynamicString *)"The dependent asset (%s) does not come from the same engine as (%s)", (re::DynamicString *)v31, v20, v22);
      v23 = v32;
      v32 = 0;
      *(_BYTE *)v5 = 0;
      *(_QWORD *)(v5 + 8) = v23;

      if (*(_QWORD *)&v31[0])
      {
        if ((BYTE8(v31[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v31[0] + 40))();
        memset(v31, 0, sizeof(v31));
      }
      if (v25 && (v26 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v25 + 40))();
      if (v28)
      {
        if ((v29 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v28 + 40))();
      }
    }
    else
    {
LABEL_17:
      *(_BYTE *)v5 = 1;
    }
    return re::DynamicArray<re::AssetHandle>::deinit((uint64_t)v33);
  }
  return result;
}

BOOL re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::containsKey(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*(_QWORD *)a1)
  {
    v2 = *(_QWORD *)(a2 + 8);
    if (v2)
      v3 = *(_QWORD *)(v2 + 664);
    else
      v3 = 0;
    v5 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) >> 27));
    v6 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v3 ^ (v5 >> 31) ^ v5) % *(unsigned int *)(a1 + 24)));
    v4 = 0x7FFFFFFFLL;
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      do
      {
        v7 = *(_QWORD *)(a1 + 16) + (v6 << 6);
        v4 = v6;
        if (*(_QWORD *)(v7 + 24) == v2)
          break;
        v6 = *(_DWORD *)(v7 + 8) & 0x7FFFFFFF;
        v4 = 0x7FFFFFFFLL;
      }
      while (v6 != 0x7FFFFFFF);
    }
  }
  else
  {
    v4 = 0x7FFFFFFFLL;
  }
  return v4 != 0x7FFFFFFF;
}

unint64_t re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(uint64_t a1, re::AssetHandle *a2, const re::AssetHandle *a3)
{
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;

  v6 = *((_QWORD *)a2 + 1);
  if (v6)
    v7 = *(_QWORD *)(v6 + 664);
  else
    v7 = 0;
  v8 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
  v9 = v7 ^ (v8 >> 31) ^ v8;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v10) = 0;
    goto LABEL_10;
  }
  v10 = v9 % *(unsigned int *)(a1 + 24);
  v11 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v10);
  if ((_DWORD)v11 == 0x7FFFFFFF)
  {
LABEL_10:
    v13 = re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::addAsCopy(a1, v10, v9, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    return *(_QWORD *)(a1 + 16) + ((unint64_t)v13 << 6) + 40;
  }
  while (1)
  {
    v12 = *(_QWORD *)(a1 + 16) + (v11 << 6);
    if (*(_QWORD *)(v12 + 24) == v6)
      return v12 + 40;
    v11 = *(_DWORD *)(v12 + 8) & 0x7FFFFFFF;
    if (v11 == 0x7FFFFFFF)
      goto LABEL_10;
  }
}

uint64_t re::RealityFileWriter::getAssetInfo(re::RealityFileWriter *this, const re::AssetHandle *a2, re::AssetHandle *a3)
{
  re::DynamicString *v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (re::DynamicString *)re::AssetHandle::legacy_assetPath(a3);
  v6 = *((_QWORD *)v5 + 1);
  v10 = 0;
  v11 = 0;
  v8 = v6;
  v9 = 0;
  re::DynamicString::setCapacity(&v8, 0);
  re::AssetPath::fullAssetPath(v5, (re::DynamicString *)&v8);
  re::RealityFileWriter::AssetInfoTable::tryGetAssetInfo((const re::AssetHandle *)((char *)a2 + 24), (const re::DynamicString *)&v8, (uint64_t *)this);
  result = v8;
  if (v8)
  {
    if ((v9 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v8 + 40))();
  }
  return result;
}

uint64_t re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::add(uint64_t a1, re::AssetHandle *a2, const re::DynamicString *a3)
{
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;

  v6 = *((_QWORD *)a2 + 1);
  if (v6)
    v7 = *(_QWORD *)(v6 + 664);
  else
    v7 = 0;
  v8 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v6 ^ (v6 >> 30))) >> 27));
  v9 = v7 ^ (v8 >> 31) ^ v8;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v10) = 0;
    goto LABEL_11;
  }
  v10 = v9 % *(unsigned int *)(a1 + 24);
  v11 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v10);
  if ((_DWORD)v11 == 0x7FFFFFFF)
  {
LABEL_11:
    v13 = re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::addAsCopy(a1, v10, v9, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v14 = *(_QWORD *)(a1 + 16) + 72 * v13;
    return v14 + 40;
  }
  v12 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v12 + 72 * v11 + 24) != v6)
  {
    v11 = *(_DWORD *)(v12 + 72 * v11 + 8) & 0x7FFFFFFF;
    if (v11 == 0x7FFFFFFF)
      goto LABEL_11;
  }
  v14 = v12 + 72 * v11;
  return v14 + 40;
}

BOOL re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v9;

  v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v9, a2);
  v5 = 0x7FFFFFFFLL;
  if (*(_QWORD *)a1)
  {
    v6 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a1 + 16);
      v5 = 0x7FFFFFFFLL;
      while (!re::DynamicString::operator==(v7 + 88 * v6 + 16, a2))
      {
        v6 = *(_DWORD *)(v7 + 88 * v6 + 8) & 0x7FFFFFFF;
        if (v6 == 0x7FFFFFFF)
          return v5 != 0x7FFFFFFF;
      }
      v5 = v6;
    }
  }
  return v5 != 0x7FFFFFFF;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add(uint64_t a1, re::DynamicString *a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  char v14;

  v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v14, (uint64_t)a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v11 = re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    v12 = *(_QWORD *)(a1 + 16) + 88 * v11;
    return v12 + 48;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (!re::DynamicString::operator==(v10 + 88 * v9 + 16, (uint64_t)a2))
  {
    v9 = *(_DWORD *)(v10 + 88 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v12 = v10 + 88 * v9;
  return v12 + 48;
}

double re::DynamicArray<re::DynamicString>::add(_anonymous_namespace_ *this, _QWORD *a2)
{
  unint64_t v4;
  uint64_t v5;
  double result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::DynamicString>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 32 * v4;
  result = 0.0;
  *(_OWORD *)v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_QWORD *)(v5 + 24) = a2[3];
  v7 = a2[1];
  *(_QWORD *)v5 = *a2;
  *a2 = 0;
  v8 = a2[2];
  a2[3] = 0;
  v10 = *(_QWORD *)(v5 + 8);
  v9 = *(_QWORD *)(v5 + 16);
  *(_QWORD *)(v5 + 8) = v7;
  *(_QWORD *)(v5 + 16) = v8;
  a2[1] = v10;
  a2[2] = v9;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

uint64_t re::HashTable<re::AssetHandle,re::RealityFileWriter::AssetHandleWithMetadata,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::tryGet(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!*(_QWORD *)a1)
    return 0;
  v2 = a2 ? *(_QWORD *)(a2 + 664) : 0;
  v3 = 0x94D049BB133111EBLL
     * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
  v4 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v2 ^ (v3 >> 31) ^ v3) % *(unsigned int *)(a1 + 24)));
  if ((_DWORD)v4 == 0x7FFFFFFF)
    return 0;
  v5 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v5 + 160 * v4 + 24) != a2)
  {
    v4 = *(_DWORD *)(v5 + 160 * v4 + 8) & 0x7FFFFFFF;
    if (v4 == 0x7FFFFFFF)
      return 0;
  }
  return v5 + 160 * v4 + 40;
}

uint64_t *re::RealityFileWriter::saveAssetToArchive(uint64_t a1, re::AssetPathMapping *a2, re::AssetHandle *this, uint64_t *a4, uint64_t a5, int a6, _BYTE *a7, uint64_t a8)
{
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  const re::IntrospectionBase **v22;
  uint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  char *v26;
  uint64_t v27;
  uint64_t *result;
  id v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  id v33;
  AssetService *v34;
  _anonymous_namespace_ *v35;
  std::string *v36;
  std::string *v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _anonymous_namespace_ *v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  id v46;
  int v47;
  uint64_t v48;
  const re::AssetPath *v49;
  uint64_t v50;
  uint64_t *v51;
  const __CFData *v52;
  uint64_t v53;
  void *v54;
  id v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  std::string v59;
  __int128 v60;
  __int128 v61;
  int v62;
  BOOL v63;
  char v64;
  _QWORD v65[2];
  uint64_t v66;
  uint64_t v67;
  CFIndex length;
  int v69;
  UInt8 *bytes;
  _QWORD v71[3];
  uint64_t v72[4];
  __int128 v73;
  char v74[8];
  uint64_t v75;
  uint64_t v76[6];
  uint64_t v77;
  id v78;
  uint64_t v79;
  id v80;
  const re::IntrospectionBase **v81;
  uint64_t v82[8];

  v82[5] = *MEMORY[0x24BDAC8D0];
  v16 = *((_QWORD *)this + 1);
  if (!v16)
  {
    v18 = 0;
    goto LABEL_5;
  }
  v17 = atomic_load((unsigned int *)(v16 + 704));
  if (v17 != 2)
  {
    v18 = *((_QWORD *)this + 1);
LABEL_5:
    re::AssetHandle::loadNow(v18, 0);
  }
  v19 = *((_QWORD *)this + 1);
  if (v19)
  {
    v20 = atomic_load((unsigned int *)(v19 + 704));
    if (v20 == 2)
    {
      re::AssetHandle::serializableAsset(this, v82);
      v21 = v82[0];
      (*(void (**)(uint64_t *__return_ptr, uint64_t, re::AssetHandle *))(*(_QWORD *)a8 + 64))(&v77, a8, this);
      if (!(_BYTE)v77)
      {
        v29 = v78;
        *(_BYTE *)a1 = 0;
        *(_QWORD *)(a1 + 8) = v29;
LABEL_78:
        if (!(_BYTE)v77)

        return std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](v82);
      }
      if (((*(uint64_t (**)(uint64_t, re::AssetHandle *, _QWORD))(*(_QWORD *)a8 + 56))(a8, this, *(_QWORD *)(*((_QWORD *)a2 + 40) + 24)) & 1) == 0)
      {
        v30 = *a4;
        if ((*(_BYTE *)(*a4 + 40) & 1) != 0)
          v31 = *(_QWORD *)(v30 + 48);
        else
          v31 = v30 + 41;
        re::DynamicString::format((re::DynamicString *)"This asset (%s) is not supported by this version of RealityKit.", (re::DynamicString *)&v79, v31);
        v32 = v76[0];
        v76[0] = 0;
        *(_BYTE *)a1 = 0;
        *(_QWORD *)(a1 + 8) = v32;

        if (v79 && (v80 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v79 + 40))();
        goto LABEL_78;
      }
      (*(void (**)(uint64_t *__return_ptr, uint64_t, re::AssetHandle *, _QWORD, _QWORD))(*(_QWORD *)a8 + 32))(&v79, a8, this, *(_QWORD *)(*((_QWORD *)a2 + 40) + 24), *(unsigned __int8 *)(*((_QWORD *)a2 + 40) + 41));
      if (!(_BYTE)v79)
      {
        v33 = v80;
        *(_BYTE *)a1 = 0;
        *(_QWORD *)(a1 + 8) = v33;
        goto LABEL_74;
      }
      if ((_BYTE)v80)
        v22 = v81;
      else
        v22 = (const re::IntrospectionBase **)v21;
      v23 = *((_QWORD *)this + 1);
      if (v23)
        v24 = *(_QWORD *)(v23 + 24);
      else
        v24 = 0;
      re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::HashTable((uint64_t)v76, a5);
      v34 = (AssetService *)re::AssetHandle::legacy_assetPath(this);
      v35 = (_anonymous_namespace_ *)re::RealityFileWriter::customizeAssetPathMapping(v74, a2, (const re::AssetPath *)v76, v34, v24);
      if (!v74[0])
      {
        *(_BYTE *)a1 = 0;
        v40 = v75;
        v75 = 0;
        *(_QWORD *)(a1 + 8) = v40;
LABEL_73:
        re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit(v76);
LABEL_74:
        if ((_BYTE)v79)
        {
          if ((_BYTE)v80)
            std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100]((uint64_t *)&v81);
        }
        else
        {

        }
        goto LABEL_78;
      }
      v73 = 0u;
      memset(v72, 0, sizeof(v72));
      DWORD1(v73) = 0x7FFFFFFF;
      v36 = &v59;
      v37 = std::to_string(&v59, *(_QWORD *)(*((_QWORD *)a2 + 40) + 24));
      if ((v59.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v36 = (std::string *)v59.__r_.__value_.__r.__words[0];
      re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addInternal<re::DynamicString>((uint64_t)v72, (re::DynamicString *)&v66, 2, &v60);
      if ((_QWORD)v60)
      {
        if ((BYTE8(v60) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v60 + 40))();
        v60 = 0u;
        v61 = 0u;
      }
      if (SHIBYTE(v59.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v59.__r_.__value_.__l.__data_);
      if (v66 && (v67 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v66 + 40))();
      v38 = *((_QWORD *)this + 1);
      if (v38)
        v39 = *(_QWORD *)(v38 + 264);
      else
        v39 = 0;
      v41 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(v24 + 1104), v39);
      v42 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, const re::IntrospectionBase **, uint64_t *))(*(_QWORD *)v41 + 288))(v41, v22, v72);
      v43 = *((_QWORD *)a2 + 40);
      v44 = *(_QWORD *)(v43 + 24);
      if (*a7)
      {
        if (a7[1])
        {
LABEL_49:
          if (v44 <= 5)
          {
            v45 = (void *)v60;
            *(_QWORD *)&v60 = 0;

            if (v66 && (v67 & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v66 + 40))();
            v46 = v45;
            *(_BYTE *)a1 = 0;
            *(_QWORD *)(a1 + 8) = v46;

LABEL_72:
            re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(v72);
            goto LABEL_73;
          }
          v47 = 3;
LABEL_57:
          v71[1] = 0;
          v71[2] = 0;
          v48 = *(_QWORD *)(v24 + 1104);
          bytes = 0;
          v71[0] = v48;
          v67 = 0;
          length = 0;
          v69 = 0;
          v65[0] = &off_24ED7C100;
          v65[1] = &v66;
          v66 = 0;
          v60 = (unint64_t)v71;
          v62 = v47;
          v63 = *(_QWORD *)(v43 + 24) > 6;
          *(_QWORD *)&v61 = v76;
          *((_QWORD *)&v61 + 1) = v72;
          v64 = 0;
          v49 = (const re::AssetPath *)re::AssetHandle::legacy_assetPath(this);
          v50 = *((_QWORD *)this + 1);
          if (v50)
            v51 = *(uint64_t **)(v50 + 264);
          else
            v51 = 0;
          re::AssetUtilities::saveCompiledAssetToStream((uint64_t)v65, v22, v49, v51, (uint64_t)&v60, (unsigned __int8 *)&v59);
          if (v59.__r_.__value_.__s.__data_[0])
          {
            if (!a6)
              a6 = (*(uint64_t (**)(uint64_t, const re::IntrospectionBase **))(*(_QWORD *)v41 + 248))(v41, v22) ^ 1;
            v52 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x24BDBD240], bytes, length, (CFAllocatorRef)*MEMORY[0x24BDBD258]);
            v53 = *a4;
            v57 = v53;
            if (v53)
            {
              v54 = (void *)(v53 + 8);
              v55 = (id)(v53 + 8);
              re::RealityFileWriter::saveEntryToArchive(a1, (uint64_t)a2, v52, &v57, a6);

            }
            else
            {
              re::RealityFileWriter::saveEntryToArchive(a1, (uint64_t)a2, v52, &v57, a6);
            }
            CFRelease(v52);
          }
          else
          {
            v56 = v58;
            v58 = 0;
            *(_BYTE *)a1 = 0;
            *(_QWORD *)(a1 + 8) = v56;

          }
          if (!v59.__r_.__value_.__s.__data_[0]
            && v59.__r_.__value_.__l.__size_
            && (v59.__r_.__value_.__s.__data_[16] & 1) != 0)
          {
            (*(void (**)(void))(*(_QWORD *)v59.__r_.__value_.__l.__size_ + 40))();
          }
          if (v66 && bytes)
            (*(void (**)(void))(*(_QWORD *)v66 + 40))();
          goto LABEL_72;
        }
      }
      else if (v44 > 5)
      {
        goto LABEL_49;
      }
      v47 = 2;
      goto LABEL_57;
    }
  }
  v25 = re::AssetHandle::assetInfo(this);
  if ((v25[17] & 1) != 0)
    v26 = (char *)v25[18];
  else
    v26 = (char *)v25 + 137;
  re::DynamicString::format((re::DynamicString *)"Asset '%s' failed to load", (re::DynamicString *)&v79, v26);
  v27 = v76[0];
  v76[0] = 0;
  *(_BYTE *)a1 = 0;
  *(_QWORD *)(a1 + 8) = v27;

  result = (uint64_t *)v79;
  if (v79 && (v80 & 1) != 0)
    return (uint64_t *)(*(uint64_t (**)(void))(*(_QWORD *)v79 + 40))();
  return result;
}

uint64_t re::RealityFileWriter::editAssetLabel@<X0>(re::RealityFileWriter *this@<X0>, const re::AssetHandle *a2@<X1>, const re::DynamicString *a3@<X2>, uint64_t a4@<X8>)
{
  re::DynamicString *v7;
  uint64_t v8;
  void *v9;
  id v10;
  uint64_t result;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;

  v7 = (re::DynamicString *)re::AssetHandle::legacy_assetPath(a2);
  v8 = *((_QWORD *)v7 + 1);
  v21 = 0;
  v22 = 0;
  v19 = v8;
  v20 = 0;
  re::DynamicString::setCapacity(&v19, 0);
  re::AssetPath::fullAssetPath(v7, (re::DynamicString *)&v19);
  re::RealityFileWriter::AssetInfoTable::tryGetAssetInfo((re::RealityFileWriter *)((char *)this + 24), (const re::DynamicString *)&v19, &v18);
  if (v18)
  {
    v14 = v18;
    v9 = (void *)(v18 + 8);
    v10 = (id)(v18 + 8);
    re::RealityFileWriter::assignLabelToAssetInfo(this, &v14, a3, a4);

  }
  else
  {
    if ((v20 & 1) != 0)
      v12 = v21;
    else
      v12 = (char *)&v20 + 1;
    re::DynamicString::format((re::DynamicString *)"The asset (%s) is not registered with this RealityFileWriter.", (re::DynamicString *)&v15, v12);
    v13 = v17;
    v17 = 0;
    *(_BYTE *)a4 = 0;
    *(_QWORD *)(a4 + 8) = v13;

    if (v15 && (v16 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v15 + 40))();
  }
  result = v19;
  if (v19)
  {
    if ((v20 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v19 + 40))();
  }
  return result;
}

re::DynamicString *re::FixedArray<re::DynamicString>::operator=(re::DynamicString *a1, uint64_t a2)
{
  uint64_t v4;

  if (a1 != (re::DynamicString *)a2)
  {
    v4 = *(_QWORD *)a2;
    if (*(_QWORD *)a1)
    {
      if (!v4)
        return a1;
      goto LABEL_7;
    }
    if (v4)
    {
      re::FixedArray<re::DynamicString>::init<>(a1, v4, *(_QWORD *)(a2 + 8));
LABEL_7:
      re::FixedArray<re::DynamicString>::copy(a1, a2);
    }
  }
  return a1;
}

void re::RealityFileWriter::checkAssetIsWritable(uint64_t a1, const re::AssetHandle *a2, uint64_t a3)
{
  re::DynamicString *v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  _OWORD v14[2];
  uint64_t v15;
  char v16[8];
  uint64_t v17;

  if (v16[0])
  {
    if (*(_DWORD *)(*(_QWORD *)a3 + 24) == 1)
    {
      v6 = (re::DynamicString *)re::AssetHandle::legacy_assetPath(a2);
      v7 = *((_QWORD *)v6 + 1);
      v12 = 0;
      v13 = 0;
      v10 = v7;
      v11 = 0;
      re::DynamicString::setCapacity(&v10, 0);
      re::AssetPath::fullAssetPath(v6, (re::DynamicString *)&v10);
      if ((v11 & 1) != 0)
        v8 = v12;
      else
        v8 = (char *)&v11 + 1;
      re::DynamicString::format((re::DynamicString *)"The asset (%s) has already been written.", (re::DynamicString *)v14, v8);
      v9 = v15;
      v15 = 0;
      *(_BYTE *)a1 = 0;
      *(_QWORD *)(a1 + 8) = v9;

      if (*(_QWORD *)&v14[0])
      {
        if ((BYTE8(v14[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v14[0] + 40))();
        memset(v14, 0, sizeof(v14));
      }
      if (v10)
      {
        if ((v11 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v10 + 40))();
      }
    }
    else
    {
      *(_BYTE *)a1 = 1;
    }
  }
  else
  {
    *(_BYTE *)a1 = 0;
    *(_QWORD *)(a1 + 8) = v17;

  }
}

void re::RealityFileWriter::addDependentAssets(uint64_t a1, const re::AssetHandle *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  int v19;
  int v20;
  char *v21;
  char v22[8];
  char *v23;
  _BYTE v24[24];

  v8 = *(unsigned int *)(a4 + 32);
  if ((_DWORD)v8)
  {
    v9 = 0;
    v10 = (int *)(*(_QWORD *)(a4 + 16) + 8);
    while (1)
    {
      v11 = *v10;
      v10 += 10;
      if (v11 < 0)
        break;
      if (v8 == ++v9)
      {
        LODWORD(v9) = *(_DWORD *)(a4 + 32);
        break;
      }
    }
  }
  else
  {
    LODWORD(v9) = 0;
  }
  if ((_DWORD)v8 == (_DWORD)v9)
  {
LABEL_23:
    *(_BYTE *)a1 = 1;
  }
  else
  {
    v12 = v9;
    v13 = *(_QWORD *)(a4 + 16);
    while (1)
    {
      re::AssetHandle::AssetHandle((re::AssetHandle *)v24, (const re::AssetHandle *)(v13 + 40 * v12 + 16));
      re::RealityFileWriter::getOrMakeAssetInfo((re::RealityFileWriter *)v22, a2, (re::AssetHandle *)v24);
      v14 = v22[0];
      if (v22[0])
      {
        v15 = *a3;
        v21 = v23;
        if (v23)
        {
          v16 = v23 + 8;
          v17 = v23 + 8;
          re::DynamicArray<re::SharedPtr<re::AssetLoadRequest>>::add((_anonymous_namespace_ *)(v15 + 96), (uint64_t *)&v21);

          v21 = 0;
        }
        else
        {
          re::DynamicArray<re::SharedPtr<re::AssetLoadRequest>>::add((_anonymous_namespace_ *)(v15 + 96), (uint64_t *)&v21);
        }
      }
      else
      {
        v18 = v23;
        *(_BYTE *)a1 = 0;
        *(_QWORD *)(a1 + 8) = v18;
      }
      re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result((uint64_t)v22);
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v24);
      if (!v14)
        break;
      v13 = *(_QWORD *)(a4 + 16);
      if (*(_DWORD *)(a4 + 32) <= (v9 + 1))
        v19 = v9 + 1;
      else
        v19 = *(_DWORD *)(a4 + 32);
      while (1)
      {
        v12 = (v9 + 1);
        if (v19 - 1 == (_DWORD)v9)
          break;
        LODWORD(v9) = v9 + 1;
        v20 = v12;
        if ((*(_DWORD *)(v13 + 40 * v12 + 8) & 0x80000000) != 0)
          goto LABEL_22;
      }
      v20 = v19;
LABEL_22:
      LODWORD(v9) = v20;
      if ((_DWORD)v8 == v20)
        goto LABEL_23;
    }
  }
}

void re::RealityFileWriter::close(re::RealityFileWriter *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2;
  uint64_t *v5;
  uint64_t *v6;
  int *v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  id v12;
  int v13;
  unsigned int v14;
  unint64_t v15;
  uint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFData *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  int *v26;
  int v27;
  unint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  const __CFData *Mutable;
  unint64_t v36;
  _BOOL8 v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unsigned int *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _anonymous_namespace_ *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  re::DynamicString *v51;
  uint64_t v52;
  const char *v53;
  size_t v54;
  char *v55;
  int v56;
  uint64_t v57;
  double v58;
  unsigned int *v59;
  uint64_t v60;
  uint64_t v61;
  int *v62;
  int v63;
  unsigned int v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  id v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  signed int v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  uint64_t v82;
  const re::DynamicString *v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t i;
  uint64_t v90;
  unsigned int v91;
  unsigned int v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  id v96;
  _anonymous_namespace_ *v97;
  unint64_t v98;
  _QWORD *v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  _QWORD *v103;
  __n128 v104;
  int v105;
  int v106;
  uint64_t v107;
  int *v108;
  int v109;
  unint64_t v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t v113;
  _QWORD *v114;
  _QWORD *v115;
  uint64_t v116;
  _QWORD *v117;
  unint64_t v118;
  _QWORD *v119;
  _QWORD *v120;
  unint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t j;
  int v125;
  int v126;
  _anonymous_namespace_ *v127;
  uint64_t v128;
  uint64_t *v129;
  _QWORD *v130;
  uint64_t v131;
  uint64_t v132;
  re::DynamicString *v133;
  unint64_t v134;
  uint64_t v135;
  _QWORD *v136;
  unsigned __int8 v137;
  re *v138;
  _anonymous_namespace_ *v139;
  unsigned __int8 v140;
  re *v141;
  const __CFData *v142;
  _anonymous_namespace_ *v143;
  id v144;
  _BYTE *v145;
  id v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  void *v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  int v156;
  int v157;
  uint64_t v158;
  _BYTE *v159;
  uint64_t v160;
  BOOL v161;
  _QWORD *v163;
  int v164;
  int v165;
  unsigned int v166;
  unint64_t v167;
  uint64_t v168;
  unsigned int v169;
  uint64_t v170;
  unsigned int v171;
  unint64_t v172;
  re::RealityFileWriter *v173;
  int v174;
  uint64_t v175;
  char v176;
  unint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  unint64_t v182;
  unint64_t v183;
  unint64_t v184;
  int v185;
  _QWORD *v186;
  __int128 v187;
  __int128 v188;
  unsigned int v189;
  uint64_t v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  _BYTE v194[40];
  int v195;
  uint64_t v196;
  BOOL v197;
  _OWORD v198[3];
  __int128 v199;
  __int128 v200;
  __int128 v201;
  int v202;
  __int128 v203;
  _BYTE v204[28];
  uint64_t v205;
  __int128 v206;
  __int128 v207;
  int v208;
  uint64_t v209;
  __int128 v210;
  __int128 v211;
  int v212;
  uint64_t v213;
  __int128 v214;
  __int128 v215;
  int v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  __int128 v221;
  _BYTE v222[72];
  unsigned __int8 v223[8];
  __int128 v224;
  __int128 v225;
  __int128 v226;
  __int128 v227;
  _BYTE v228[48];
  _BYTE v229[28];
  __int16 v230;
  _BYTE v231[18];
  __int128 v232;
  int v233;
  uint64_t v234;
  unsigned __int8 v235[8];
  _QWORD v236[4];
  __int128 v237;
  __int128 v238;
  int v239;
  uint64_t v240;
  uint64_t v241;

  v241 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 34))
  {
    v5 = (uint64_t *)*((unsigned int *)this + 14);
    if ((_DWORD)v5)
    {
      v6 = 0;
      v7 = (int *)(*((_QWORD *)this + 5) + 8);
      while (1)
      {
        v8 = *v7;
        v7 += 14;
        if (v8 < 0)
          break;
        v6 = (uint64_t *)((char *)v6 + 1);
        if (v5 == v6)
        {
          v6 = (uint64_t *)*((unsigned int *)this + 14);
          break;
        }
      }
    }
    else
    {
      v6 = 0;
    }
    if ((_DWORD)v5 != (_DWORD)v6)
    {
      v10 = v6;
      v2 = 56;
      while (1)
      {
        v11 = *(_QWORD *)(*((_QWORD *)this + 5) + 56 * v10 + 48);
        if (v11)
          v12 = (id)(v11 + 8);
        v13 = *(_DWORD *)(v11 + 24);

        if (v13 != 1)
          break;
        v14 = *((_DWORD *)this + 14);
        if (v14 <= (int)v6 + 1)
          v15 = ((_DWORD)v6 + 1);
        else
          v15 = v14;
        while (1)
        {
          v10 = ((_DWORD)v6 + 1);
          if ((_DWORD)v15 - 1 == (_DWORD)v6)
            break;
          LODWORD(v6) = (_DWORD)v6 + 1;
          v16 = (uint64_t *)v10;
          if ((*(_DWORD *)(*((_QWORD *)this + 5) + 56 * v10 + 8) & 0x80000000) != 0)
            goto LABEL_21;
        }
        v16 = (uint64_t *)v15;
LABEL_21:
        v6 = v16;
        if ((_DWORD)v5 == (_DWORD)v16)
          goto LABEL_22;
      }
      v45 = v221;
      *(_QWORD *)&v221 = 0;
      *(_BYTE *)a2 = 0;
      *(_QWORD *)(a2 + 8) = v45;
      goto LABEL_65;
    }
LABEL_22:
    v173 = this;
    v17 = *((_QWORD *)this + 66);
    v221 = 0u;
    memset(v222, 0, 20);
    *(_QWORD *)&v222[20] = 0x7FFFFFFFLL;
    if (v17)
    {
      if (v17 >= 0x555555555555556)
        goto LABEL_351;
      if (!v19)
      {
LABEL_352:
        re::internal::assertLog((re::internal *)4, v20, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
        _os_crash();
        __break(1u);
LABEL_353:
        re::internal::assertLog((re::internal *)4, v128, "assertion failure: '%s' (%s:line %i) Cannot copy from a Slice of a different size", "m_size == other.size()", "copy", 378);
        _os_crash();
        __break(1u);
LABEL_354:
        *(_QWORD *)&v187 = 0;
        memset(v194, 0, 32);
        v192 = 0u;
        v193 = 0u;
        v191 = 0u;
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v229 = 136315906;
        *(_QWORD *)&v229[4] = "operator[]";
        *(_WORD *)&v229[12] = 1024;
        *(_DWORD *)&v229[14] = 476;
        *(_WORD *)&v229[18] = 2048;
        *(_QWORD *)&v229[20] = v6;
        v230 = 2048;
        *(_QWORD *)v231 = v2;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v21 = (const __CFData *)v19;
      v22 = v19;
      v23 = v17 - 1;
      if (v17 != 1)
      {
        v22 = v19;
        do
        {
          *(_OWORD *)(v22 + 16) = 0uLL;
          *(_OWORD *)(v22 + 32) = 0uLL;
          *(_OWORD *)v22 = 0uLL;
          *(_DWORD *)(v22 + 36) = 0x7FFFFFFF;
          v22 += 48;
          --v23;
        }
        while (v23);
      }
      *(_OWORD *)(v22 + 16) = 0u;
      *(_OWORD *)(v22 + 32) = 0u;
      *(_OWORD *)v22 = 0u;
      *(_DWORD *)(v22 + 36) = 0x7FFFFFFF;
    }
    else
    {
      v21 = 0;
    }
    v24 = *((unsigned int *)v173 + 14);
    if ((_DWORD)v24)
    {
      v25 = 0;
      v26 = (int *)(*((_QWORD *)v173 + 5) + 8);
      while (1)
      {
        v27 = *v26;
        v26 += 14;
        if (v27 < 0)
          break;
        if (v24 == ++v25)
        {
          v25 = *((unsigned int *)v173 + 14);
          break;
        }
      }
    }
    else
    {
      v25 = 0;
    }
    if ((_DWORD)v24 == (_DWORD)v25)
      goto LABEL_56;
    v28 = v25;
    do
    {
      v29 = *((_QWORD *)v173 + 5);
      v30 = *(_QWORD **)(v29 + 56 * v28 + 48);
      if (v30)
        v31 = v30 + 1;
      v32 = v30[34];
      if (!v32)
        goto LABEL_48;
      if (v32 != v17)
      {
        if ((*(_BYTE *)(v29 + 56 * v28 + 24) & 1) != 0)
          v49 = *(_QWORD *)(v29 + 56 * v28 + 32);
        else
          v49 = v29 + 56 * v28 + 25;
        re::DynamicString::format((re::DynamicString *)"Asset '%s' has %zu configuration names, but there are %zu configuration set names.", (re::DynamicString *)&v191, v49, v30[34], v17);
        v42 = *(unsigned int **)v229;
        *(_QWORD *)v229 = 0;

        if ((_QWORD)v191 && (BYTE8(v191) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v191 + 40))();
LABEL_109:

LABEL_110:
        v56 = 1;
        goto LABEL_111;
      }
      v33 = 0;
      v34 = 0;
      v182 = 1;
      Mutable = v21;
      do
      {
        v177 = 0;
        v36 = v30[34];
        if (v36 <= v34)
        {
          *(_QWORD *)&v187 = 0;
          memset(v194, 0, 32);
          v192 = 0u;
          v193 = 0u;
          v191 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v229 = 136315906;
          *(_QWORD *)&v229[4] = "operator[]";
          *(_WORD *)&v229[12] = 1024;
          *(_DWORD *)&v229[14] = 476;
          *(_WORD *)&v229[18] = 2048;
          *(_QWORD *)&v229[20] = v34;
          v230 = 2048;
          *(_QWORD *)v231 = v36;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
LABEL_307:
          *(_QWORD *)&v187 = 0;
          memset(v194, 0, 32);
          v192 = 0u;
          v193 = 0u;
          v191 = 0u;
          os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
          *(_DWORD *)v229 = 136315906;
          *(_QWORD *)&v229[4] = "operator[]";
          *(_WORD *)&v229[12] = 1024;
          *(_DWORD *)&v229[14] = 468;
          *(_WORD *)&v229[18] = 2048;
          *(_QWORD *)&v229[20] = v17;
          v230 = 2048;
          *(_QWORD *)v231 = v17;
          _os_log_send_and_compose_impl();
          _os_crash_msg();
          __break(1u);
          goto LABEL_308;
        }
        v177 = re::Hash<re::DynamicString>::operator()((uint64_t)&v174, v30[35] + v33);
        if (v17 == v34)
          goto LABEL_307;
        re::HashSetBase<unsigned long,unsigned long,re::internal::ValueAsKey<unsigned long>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::add((uint64_t)Mutable, (uint64_t *)&v177);
        v182 *= v34 + v177;
        ++v34;
        Mutable = (const __CFData *)((char *)Mutable + 48);
        v33 += 32;
      }
      while (v17 != v34);
      v37 = re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)&v221, (uint64_t *)&v182);
      if (v37)
      {
        v50 = v30[34];
        if (v50)
        {
          v51 = (re::DynamicString *)v30[35];
          v52 = 32 * v50;
          do
          {
            re::DynamicString::operator+(v51, ", ", (re::DynamicString *)v229);
            if ((v229[8] & 1) != 0)
              v53 = *(const char **)&v229[16];
            else
              v53 = &v229[9];
            if ((v229[8] & 1) != 0)
              v54 = *(_QWORD *)&v229[8] >> 1;
            else
              v54 = v229[8] >> 1;
            re::DynamicString::append((re::DynamicString *)&v191, v53, v54);
            if (*(_QWORD *)v229 && (v229[8] & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)v229 + 40))();
            v51 = (re::DynamicString *)((char *)v51 + 32);
            v52 -= 32;
          }
          while (v52);
        }
        if ((BYTE8(v191) & 1) != 0)
          v55 = (char *)v192;
        else
          v55 = (char *)&v191 + 9;
        re::DynamicString::format((re::DynamicString *)"This combination of configuration names is not unique in the reality file: %s", (re::DynamicString *)v229, v55);
        v42 = (unsigned int *)v187;
        *(_QWORD *)&v187 = 0;

        if (*(_QWORD *)v229 && (v229[8] & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)v229 + 40))();
        if ((_QWORD)v191 && (BYTE8(v191) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v191 + 40))();
        if (!v30)
          goto LABEL_110;
        goto LABEL_109;
      }
      re::HashSetBase<unsigned long,unsigned long,re::internal::ValueAsKey<unsigned long>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::add((uint64_t)&v221, (uint64_t *)&v182);
LABEL_48:

      LODWORD(v38) = *((_DWORD *)v173 + 14);
      if (v38 <= (int)v25 + 1)
        v38 = (v25 + 1);
      else
        v38 = v38;
      while (1)
      {
        v28 = (v25 + 1);
        if ((_DWORD)v38 - 1 == (_DWORD)v25)
          break;
        LODWORD(v25) = v25 + 1;
        v39 = v28;
        if ((*(_DWORD *)(*((_QWORD *)v173 + 5) + 56 * v28 + 8) & 0x80000000) != 0)
          goto LABEL_55;
      }
      v39 = v38;
LABEL_55:
      v25 = v39;
    }
    while ((_DWORD)v24 != (_DWORD)v39);
LABEL_56:
    if (!v17)
    {
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v221);
      goto LABEL_117;
    }
    v40 = 0;
    v6 = 0;
    v41 = 1;
    v42 = (unsigned int *)v21;
    while (2)
    {
      v43 = v42[7];
      if ((unint64_t)v6 >= *((_QWORD *)v173 + 69)
        || (v182 = 0,
            v182 = re::Hash<re::DynamicString>::operator()((uint64_t)&v174, *((_QWORD *)v173 + 70) + v40),
            re::HashSetBase<unsigned long long,unsigned long long,re::internal::ValueAsKey<unsigned long long>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::contains((uint64_t)v42, (uint64_t *)&v182)))
      {
        v41 *= v43;
        v6 = (uint64_t *)((char *)v6 + 1);
        v40 += 32;
        v42 += 12;
        if ((uint64_t *)v17 != v6)
          continue;
        if (v41 == *(unsigned int *)&v222[12])
        {
          if (v41 > 0x40000)
          {
            re::DynamicString::format((re::DynamicString *)"There are %zu scenes in the reality file addressed by configurations, which exceeds the maximum number %u.", (re::DynamicString *)&v191, v41, 0x40000);
            v44 = 23;
            goto LABEL_101;
          }
          v56 = 0;
LABEL_111:
          if (v17)
          {
            v57 = 0;
            do
            {
              v58 = re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)((char *)v21 + v57));
              v57 += 48;
            }
            while (48 * v17 != v57);
          }
          re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)&v221);
          if (v56)
          {
            v59 = v42;
            *(_BYTE *)a2 = 0;
            *(_QWORD *)(a2 + 8) = v59;

            return;
          }
LABEL_117:
          v17 = (unint64_t)v173;
          if (*((_BYTE *)v173 + 512))
            v161 = *(_QWORD *)(*((_QWORD *)v173 + 40) + 24) > 7;
          else
            v161 = 0;
          ArcSharedObject::ArcSharedObject((ArcSharedObject *)&v191, 0);
          *((_QWORD *)&v192 + 1) = 0;
          *(_QWORD *)&v191 = &off_24ED2D798;
          v193 = 0uLL;
          v196 = 0;
          v197 = 0;
          memset(&v194[8], 0, 32);
          *(_DWORD *)v194 = 0;
          v195 = 0;
          memset(v198, 0, sizeof(v198));
          v199 = 0u;
          v200 = 0u;
          v201 = 0u;
          v203 = 0u;
          memset(v204, 0, sizeof(v204));
          v205 = 0x7FFFFFFFLL;
          v206 = 0u;
          v207 = 0u;
          v202 = 0;
          v208 = 0;
          v209 = 0x7FFFFFFFLL;
          v210 = 0u;
          v211 = 0u;
          v212 = 0;
          v213 = 0x7FFFFFFFLL;
          v214 = 0u;
          v215 = 0u;
          v216 = 0;
          v217 = 0x7FFFFFFFLL;
          v220 = 0;
          v218 = 0;
          v219 = 0;
          v189 = 0;
          v188 = 0u;
          v187 = 0u;
          v190 = 0x7FFFFFFFLL;
          v186 = 0;
          v183 = 0;
          v184 = 0;
          v182 = 0;
          v185 = 0;
          v60 = *((unsigned int *)v173 + 14);
          if ((_DWORD)v60)
          {
            v61 = 0;
            v62 = (int *)(*((_QWORD *)v173 + 5) + 8);
            while (1)
            {
              v63 = *v62;
              v62 += 14;
              if (v63 < 0)
                break;
              if (v60 == ++v61)
              {
                LODWORD(v61) = *((_DWORD *)v173 + 14);
                break;
              }
            }
          }
          else
          {
            LODWORD(v61) = 0;
          }
          if ((_DWORD)v60 == (_DWORD)v61)
          {
            v167 = 0;
            v64 = *((_DWORD *)v173 + 14);
          }
          else
          {
            v166 = 0;
            v167 = 0;
            v164 = 0;
            v169 = 0;
            v65 = 0;
            v66 = v61;
            v170 = 0;
            v168 = 0;
            v163 = 0;
            v165 = *((_DWORD *)v173 + 14);
            do
            {
              v67 = *(_QWORD *)(*(_QWORD *)(v17 + 40) + 56 * v66 + 48);
              if (v67)
                v68 = (id)(v67 + 8);
              memset(v229, 0, sizeof(v229));
              v234 = 0;
              v235[0] = 0;
              v237 = 0u;
              v238 = 0u;
              v239 = 0;
              *(_OWORD *)&v231[2] = 0u;
              v232 = 0u;
              v233 = 0;
              v240 = 0x7FFFFFFFLL;
              re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)v229, (re::DynamicString *)(v67 + 32));
              v69 = *(_QWORD *)(v67 + 72);
              if ((v69 & 1) != 0)
                v70 = v69 >> 1;
              else
                v70 = v69 >> 1;
              if (v70)
              {
                LOBYTE(v221) = 1;
                re::DynamicString::DynamicString((re::DynamicString *)((char *)&v221 + 8), (const re::DynamicString *)(v67 + 64));
              }
              else
              {
                LOBYTE(v221) = 0;
              }
              re::Optional<re::DynamicString>::operator=(v235, &v221);
              if ((_BYTE)v221 && *((_QWORD *)&v221 + 1) && (v222[0] & 1) != 0)
                (*(void (**)(void))(**((_QWORD **)&v221 + 1) + 40))();
              re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::operator=((uint64_t)&v237, v67 + 208);
              v71 = *(_QWORD *)&v194[32];
              if (*(_QWORD *)&v194[32] >= *(_QWORD *)&v194[24])
              {
                re::DynamicArray<re::AssetMapAssetDescriptor>::growCapacity(&v194[16], *(_QWORD *)&v194[32] + 1);
                v71 = *(_QWORD *)&v194[32];
              }
              v72 = v196;
              v73 = v196 + 168 * v71;
              re::DynamicArray<re::DynamicString>::DynamicArray(v73, (uint64_t *)v229);
              re::DynamicArray<unsigned long>::DynamicArray(v73 + 40, (uint64_t *)&v231[10]);
              v74 = v235[0];
              *(_BYTE *)(v73 + 80) = v235[0];
              if (v74)
                re::DynamicString::DynamicString((re::DynamicString *)(v72 + 168 * v71 + 88), (const re::DynamicString *)v236);
              v75 = v72 + 168 * v71;
              *(_OWORD *)(v75 + 120) = 0u;
              v76 = v75 + 120;
              *(_DWORD *)(v76 + 32) = 0;
              *(_OWORD *)(v76 + 16) = 0u;
              *(_QWORD *)(v76 + 36) = 0x7FFFFFFFLL;
              if ((_QWORD)v237)
              {
                if (HIDWORD(v238) <= 3)
                  v77 = 3;
                else
                  v77 = HIDWORD(v238);
                re::HashTable<re::Pair<re::StringSlice,re::StringSlice,true>,unsigned long,re::Hash<re::Pair<re::StringSlice,re::StringSlice,true>>,re::EqualTo<re::Pair<re::StringSlice,re::StringSlice,true>>,true,false>::init(v76, v237, v77);
                re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::copy(v76, (uint64_t)&v237);
              }
              ++*(_QWORD *)&v194[32];
              ++v195;
              if (*(_BYTE *)(v67 + 256))
              {
                re::SceneDescriptor::SceneDescriptor((re::SceneDescriptor *)&v221);
                re::DynamicString::operator=((re::DynamicString *)&v222[8], (re::DynamicString *)(v67 + 32));
                re::DynamicString::operator=((re::DynamicString *)&v222[40], (re::DynamicString *)(v67 + 64));
                v78 = *(_QWORD *)(v67 + 144);
                if ((v78 & 1) != 0)
                  v79 = v78 >> 1;
                else
                  v79 = v78 >> 1;
                if (v79)
                {
                  LOBYTE(v177) = 1;
                  re::DynamicString::DynamicString((re::DynamicString *)&v178, (const re::DynamicString *)(v67 + 136));
                  re::Optional<re::DynamicString>::operator=(v223, &v177);
                  if ((_BYTE)v177)
                  {
                    if (v178 && (v179 & 1) != 0)
                      (*(void (**)(void))(*(_QWORD *)v178 + 40))();
                  }
                }
                v80 = *(_QWORD *)(v67 + 168);
                v181 = 0;
                v178 = 0;
                v179 = 0;
                v177 = 0;
                LODWORD(v180) = 0;
                if (v80)
                {
                  v81 = *(_QWORD *)(v67 + 184);
                  v177 = v80;
                  re::DynamicArray<re::SceneCompatibilityVariant>::setCapacity(&v177, v81);
                  LODWORD(v180) = v180 + 1;
                  re::DynamicArray<re::SceneCompatibilityVariant>::copy((uint64_t)&v177, v67 + 168);
                  if (v179)
                  {
                    v82 = 40 * v179;
                    v83 = (const re::DynamicString *)(v181 + 8);
                    do
                    {
                      v174 = *((_DWORD *)v83 - 2);
                      re::DynamicString::DynamicString((re::DynamicString *)&v175, v83);
                      re::DynamicArray<re::SceneCompatibilityVariant>::add((_anonymous_namespace_ *)v228, (re::DynamicString *)&v174);
                      if (v175 && (v176 & 1) != 0)
                        (*(void (**)(void))(*(_QWORD *)v175 + 40))();
                      v83 = (const re::DynamicString *)((char *)v83 + 40);
                      v82 -= 40;
                    }
                    while (v82);
                  }
                }
                re::DynamicArray<re::SceneCompatibilityVariant>::deinit((uint64_t)&v177);
                v84 = *((_QWORD *)&v193 + 1);
                if (*((_QWORD *)&v193 + 1) >= (unint64_t)v193)
                {
                  re::DynamicArray<re::SceneDescriptor>::growCapacity((_QWORD *)&v192 + 1, *((_QWORD *)&v193 + 1) + 1);
                  v84 = *((_QWORD *)&v193 + 1);
                }
                re::SceneDescriptor::SceneDescriptor((re::SceneDescriptor *)(*(_QWORD *)&v194[8] + 200 * v84), (const re::SceneDescriptor *)&v221);
                ++*((_QWORD *)&v193 + 1);
                ++*(_DWORD *)v194;
                *(_QWORD *)&v221 = off_24ED2D718;
                re::DynamicArray<re::SceneCompatibilityVariant>::deinit((uint64_t)v228);
                if ((_QWORD)v226)
                {
                  if ((BYTE8(v226) & 1) != 0)
                    (*(void (**)(void))(*(_QWORD *)v226 + 40))();
                  v226 = 0u;
                  v227 = 0u;
                }
                if (v223[0] && (_QWORD)v224)
                {
                  if ((BYTE8(v224) & 1) != 0)
                    (*(void (**)(void))(*(_QWORD *)v224 + 40))();
                  v224 = 0u;
                  v225 = 0u;
                }
                if (*(_QWORD *)&v222[40])
                {
                  if ((v222[48] & 1) != 0)
                    (*(void (**)(void))(**(_QWORD **)&v222[40] + 40))();
                  memset(&v222[40], 0, 32);
                }
                if (*(_QWORD *)&v222[8])
                {
                  if ((v222[16] & 1) != 0)
                    (*(void (**)(void))(**(_QWORD **)&v222[8] + 40))();
                  memset(&v222[8], 0, 32);
                }
                *(_QWORD *)&v221 = &off_24ED426B8;
                objc_destructInstance((char *)&v221 + 8);
              }
              v85 = 0x94D049BB133111EBLL
                  * ((0xBF58476D1CE4E5B9 * (v67 ^ (v67 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v67 ^ (v67 >> 30))) >> 27));
              v86 = v85 ^ (v85 >> 31);
              if ((_QWORD)v187)
              {
                v87 = v86 % v166;
                v88 = v168;
                for (i = *(unsigned int *)(v168 + 4 * v87);
                      (_DWORD)i != 0x7FFFFFFF;
                      i = *(_DWORD *)(v65 + 32 * i + 8) & 0x7FFFFFFF)
                {
                  if (*(_QWORD *)(v65 + 32 * i + 16) == v67)
                    goto LABEL_200;
                }
              }
              else
              {
                v87 = 0;
                v88 = v168;
              }
              v90 = v190;
              if ((_DWORD)v190 == 0x7FFFFFFF)
              {
                v91 = v169;
                v166 = DWORD2(v188);
                if (v169 == DWORD2(v188))
                {
                  re::HashTable<re::SharedPtr<re::RealityFileWriter::AssetInfo>,unsigned long,re::Hash<re::SharedPtr<re::RealityFileWriter::AssetInfo>>,re::EqualTo<re::SharedPtr<re::RealityFileWriter::AssetInfo>>,true,false>::setCapacity((uint64_t)&v187, 2 * v164);
                  v91 = v189;
                  v166 = DWORD2(v188);
                  v87 = v86 % DWORD2(v188);
                  v65 = v188;
                }
                v92 = v91 + 1;
                v189 = v91 + 1;
                v90 = v169;
                v93 = *(_DWORD *)(v65 + 32 * v169 + 8);
                v88 = *((_QWORD *)&v187 + 1);
              }
              else
              {
                v93 = *(_DWORD *)(v65 + 32 * v190 + 8);
                LODWORD(v190) = v93 & 0x7FFFFFFF;
                v92 = v169;
                v169 = v90;
              }
              *(_DWORD *)(v65 + 32 * v90 + 8) = v93 | 0x80000000;
              v65 = v188;
              v94 = v188 + 32 * v90;
              *(_DWORD *)(v94 + 8) = *(_DWORD *)(v94 + 8) & 0x80000000 | *(_DWORD *)(v88 + 4 * v87);
              *(_QWORD *)v94 = v86;
              *(_QWORD *)(v94 + 16) = v67;
              if (v67)
              {
                v95 = v88;
                v96 = (id)(v67 + 8);
                v88 = v95;
              }
              *(_QWORD *)(v94 + 24) = v170;
              *(_DWORD *)(v88 + 4 * v87) = v169;
              v164 = ++HIDWORD(v188);
              ++HIDWORD(v190);
              v169 = v92;
LABEL_200:
              v168 = v88;
              if (*(_QWORD *)(v67 + 272))
              {
                *(_QWORD *)&v221 = v170;
                v97 = re::FixedArray<re::DynamicString>::FixedArray((re::DynamicString *)((char *)&v221 + 8), v67 + 264);
                v98 = v167;
                if (v167 >= v183)
                {
                  v100 = v167 + 1;
                  if (v183 < v167 + 1)
                  {
                    if (v182)
                    {
                      v101 = 8;
                      if (v183)
                        v101 = 2 * v183;
                      if (v101 <= v100)
                        v102 = v167 + 1;
                      else
                        v102 = v101;
                      re::DynamicArray<re::RealityFileConfigurationEntryDescriptor>::setCapacity(&v182, v102);
                    }
                    else
                    {
                      re::DynamicArray<re::RealityFileConfigurationEntryDescriptor>::setCapacity(&v182, v100);
                      ++v185;
                    }
                  }
                  v98 = v184;
                  v99 = v186;
                }
                else
                {
                  v99 = v163;
                }
                v163 = v99;
                v103 = &v99[4 * v98];
                *v103 = v221;
                re::FixedArray<re::DynamicString>::FixedArray((re::DynamicString *)(v103 + 1), (uint64_t)&v221 + 8);
                v167 = ++v184;
                ++v185;
                re::FixedArray<re::DynamicString>::deinit((_QWORD *)&v221 + 1);
              }
              v104.n128_f64[0] = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)&v237);
              if (v235[0] && v236[0])
              {
                if ((v236[1] & 1) != 0)
                  (*(void (**)(double))(*(_QWORD *)v236[0] + 40))(v104.n128_f64[0]);
                v104 = 0uLL;
                memset(v236, 0, sizeof(v236));
              }
              if (*(_QWORD *)&v231[10])
              {
                if (v234)
                  (*(void (**)(__n128))(**(_QWORD **)&v231[10] + 40))(v104);
                v234 = 0;
                v232 = 0uLL;
                *(_QWORD *)&v231[10] = 0;
                ++v233;
              }
              ++v170;
              re::DynamicArray<re::DynamicString>::deinit((uint64_t)v229);

              v17 = (unint64_t)v173;
              v64 = *((_DWORD *)v173 + 14);
              if (v64 <= (int)v61 + 1)
                v105 = v61 + 1;
              else
                v105 = *((_DWORD *)v173 + 14);
              while (1)
              {
                v66 = (v61 + 1);
                if (v105 - 1 == (_DWORD)v61)
                  break;
                LODWORD(v61) = v61 + 1;
                v106 = v66;
                if ((*(_DWORD *)(*((_QWORD *)v173 + 5) + 56 * v66 + 8) & 0x80000000) != 0)
                  goto LABEL_230;
              }
              v106 = v105;
LABEL_230:
              LODWORD(v61) = v106;
            }
            while (v165 != v106);
          }
          v107 = 0;
          if (v64)
          {
            v108 = (int *)(*(_QWORD *)(v17 + 40) + 8);
            while (1)
            {
              v109 = *v108;
              v108 += 14;
              if (v109 < 0)
                break;
              if (v64 == ++v107)
              {
                LODWORD(v107) = v64;
                break;
              }
            }
          }
          v171 = v64;
          if (v64 != (_DWORD)v107)
          {
            v110 = 0;
            v111 = v107;
            v112 = DWORD2(v188);
            v2 = *((_QWORD *)&v187 + 1);
            v113 = v187;
            v6 = (uint64_t *)v188;
            while (1)
            {
              v114 = *(_QWORD **)(*(_QWORD *)(v17 + 40) + 56 * v111 + 48);
              if (v114)
                v115 = v114 + 1;
              v17 = *(_QWORD *)&v194[32];
              if (*(_QWORD *)&v194[32] <= v110)
              {
                v177 = 0;
                memset(v222, 0, 64);
                v221 = 0u;
                os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
                *(_DWORD *)v229 = 136315906;
                *(_QWORD *)&v229[4] = "operator[]";
                *(_WORD *)&v229[12] = 1024;
                *(_DWORD *)&v229[14] = 789;
                *(_WORD *)&v229[18] = 2048;
                *(_QWORD *)&v229[20] = v110;
                v230 = 2048;
                *(_QWORD *)v231 = v17;
                _os_log_send_and_compose_impl();
                _os_crash_msg();
                __break(1u);
LABEL_351:
                re::internal::assertLog((re::internal *)6, v18, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 48, v17);
                _os_crash();
                __break(1u);
                goto LABEL_352;
              }
              v116 = v196 + 168 * v110;
              v117 = (_QWORD *)(v116 + 40);
              v118 = v114[14];
              if (*(_QWORD *)(v116 + 48) < v118)
              {
                re::DynamicArray<re::EvaluationRegisterId<int>>::setCapacity(v117, v118);
                v118 = v114[14];
              }
              if (!v118)
                break;
              v172 = v110;
              v119 = (_QWORD *)v114[16];
              v120 = &v119[v118];
              do
              {
                *(_QWORD *)&v221 = 0;
                if (v113
                  && (v121 = 0xBF58476D1CE4E5B9 * (*v119 ^ (*v119 >> 30)),
                      v122 = *(unsigned int *)(v2
                                             + 4
                                             * (((0x94D049BB133111EBLL * (v121 ^ (v121 >> 27))) ^ ((0x94D049BB133111EBLL
                                                                                                  * (v121 ^ (v121 >> 27))) >> 31))
                                              % v112)),
                      (_DWORD)v122 != 0x7FFFFFFF))
                {
                  v123 = v6[4 * v122 + 2];
                  for (j = v122; v123 != *v119; v122 = j)
                  {
                    j = v6[4 * j + 1] & 0x7FFFFFFF;
                    v122 = 0x7FFFFFFFLL;
                    if (j == 0x7FFFFFFF)
                      break;
                    v123 = v6[4 * j + 2];
                  }
                }
                else
                {
                  v122 = 0x7FFFFFFFLL;
                }
                *(_QWORD *)&v221 = v6[4 * v122 + 3];
                re::DynamicArray<unsigned long>::add(v117, &v221);
                ++v119;
              }
              while (v119 != v120);
              v110 = v172 + 1;
              if (v114)
                goto LABEL_257;
LABEL_258:
              v17 = (unint64_t)v173;
              if (*((_DWORD *)v173 + 14) <= (v107 + 1))
                v125 = v107 + 1;
              else
                v125 = *((_DWORD *)v173 + 14);
              while (1)
              {
                v111 = (v107 + 1);
                if (v125 - 1 == (_DWORD)v107)
                  break;
                LODWORD(v107) = v107 + 1;
                v126 = v111;
                if ((*(_DWORD *)(*((_QWORD *)v173 + 5) + 56 * v111 + 8) & 0x80000000) != 0)
                  goto LABEL_265;
              }
              v126 = v125;
LABEL_265:
              LODWORD(v107) = v126;
              if (v171 == v126)
                goto LABEL_266;
            }
            ++v110;
LABEL_257:

            goto LABEL_258;
          }
LABEL_266:
          v197 = v161;
          re::FixedArray<re::DynamicString>::operator=((re::DynamicString *)v198, v17 + 520);
          v2 = (unint64_t)&v191;
          v127 = re::FixedArray<re::DynamicString>::operator=((re::DynamicString *)((char *)&v198[1] + 8), v17 + 544);
          v6 = v186;
          if (!(_QWORD)v199)
          {
            if (v167)
            {
              v2 = v167;
              goto LABEL_269;
            }
LABEL_273:
            v134 = v182;
            if (v182 && v186)
            {
              if (v184)
              {
                v135 = 32 * v184;
                v136 = v186 + 1;
                do
                {
                  re::FixedArray<re::DynamicString>::deinit(v136);
                  v136 += 4;
                  v135 -= 32;
                }
                while (v135);
                v134 = v182;
              }
              (*(void (**)(unint64_t))(*(_QWORD *)v134 + 40))(v134);
            }
            re::HashTable<re::SharedPtr<re::RealityFileWriter::AssetInfo>,unsigned long,re::Hash<re::SharedPtr<re::RealityFileWriter::AssetInfo>>,re::EqualTo<re::SharedPtr<re::RealityFileWriter::AssetInfo>>,true,false>::deinit((uint64_t *)&v187);
            if ((v137 & 1) == 0
            {
              re::introspect<re::AssetMap>(void)::info = (_UNKNOWN *)re::introspect_AssetMap(0);
            }
            v187 = *((_OWORD *)re::introspect<re::AssetMap>(void)::info + 2);
            v138 = (re *)v187;
            if (!(_QWORD)v187)
            {
              re::DynamicString::format((re::DynamicString *)"Type of object for file \"%s\" has not been registered", (re::DynamicString *)&v221, "assetMap.json");
              v146 = *(id *)v229;
              *(_QWORD *)v229 = 0;

              if ((_QWORD)v221 && (BYTE8(v221) & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v221 + 40))();
LABEL_303:
              *(_BYTE *)a2 = 0;
              *(_QWORD *)(a2 + 8) = v146;
              goto LABEL_304;
            }
            Mutable = CFDataCreateMutable(0, 0);
            re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v177);
            re::TypeRegistry::typeInfo(v138, (re **)&v187, &v221);
            v139 = (_anonymous_namespace_ *)re::TypeInfo::TypeInfo((uint64_t)v229, (uint64_t)&v221 + 8);
            if ((_BYTE)v221)
            {
              re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v177);
              goto LABEL_284;
            }
            v25 = v182;
            v182 = 0;

            if ((_BYTE)v221)
            {
LABEL_298:
              re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v177);
              if (v25)
              {
                CFRelease(Mutable);
                goto LABEL_302;
              }
LABEL_284:
              re::RealityArchiveWriter::writeEntry(v17 + 248, (uint64_t)"assetMap.json", Mutable, 1, (uint64_t)&v221);
              if ((_BYTE)v221)
              {
                CFRelease(Mutable);
                goto LABEL_286;
              }
              v25 = *(_QWORD *)v229;
              *(_QWORD *)v229 = 0;

              if (!(_BYTE)v221 && *((_QWORD *)&v221 + 1) && (v222[0] & 1) != 0)
                (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)&v221 + 1) + 40))(*((_QWORD *)&v221 + 1), *(_QWORD *)&v222[8]);
              CFRelease(Mutable);
              if (v25)
              {
LABEL_302:
                v146 = (id)v25;

                goto LABEL_303;
              }
LABEL_286:
              if (!*(_DWORD *)(v17 + 228))
                goto LABEL_324;
              if ((v140 & 1) == 0
              {
                re::introspect<re::DeduplicationInformation>(void)::info = (_UNKNOWN *)re::introspect_DeduplicationInformation(0);
              }
              v187 = *((_OWORD *)re::introspect<re::DeduplicationInformation>(void)::info + 2);
              v141 = (re *)v187;
              if ((_QWORD)v187)
              {
                v142 = CFDataCreateMutable(0, 0);
                re::IntrospectionSharedLock::IntrospectionSharedLock((re::IntrospectionSharedLock *)&v177);
                re::TypeRegistry::typeInfo(v141, (re **)&v187, &v221);
                v143 = (_anonymous_namespace_ *)re::TypeInfo::TypeInfo((uint64_t)v229, (uint64_t)&v221 + 8);
                if ((_BYTE)v221)
                {
                  re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v177);
                  goto LABEL_291;
                }
                v150 = (void *)v182;
                v182 = 0;

                if (!(_BYTE)v221 && *(_QWORD *)&v222[8] && (v222[16] & 1) != 0)
                  (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)&v222[8] + 40))(*(_QWORD *)&v222[8], *(_QWORD *)&v222[24]);
                re::IntrospectionSharedLock::~IntrospectionSharedLock((re::IntrospectionSharedLock *)&v177);
                if (v150)
                {
                  CFRelease(v142);
                  goto LABEL_322;
                }
LABEL_291:
                re::RealityArchiveWriter::writeEntry(v17 + 248, (uint64_t)"dedupe.json", v142, 0, (uint64_t)&v221);
                if ((_BYTE)v221)
                {
                  CFRelease(v142);
                  goto LABEL_293;
                }
                v150 = *(void **)v229;
                *(_QWORD *)v229 = 0;

                if (!(_BYTE)v221 && *((_QWORD *)&v221 + 1) && (v222[0] & 1) != 0)
                  (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)&v221 + 1) + 40))(*((_QWORD *)&v221 + 1), *(_QWORD *)&v222[8]);
                CFRelease(v142);
                if (v150)
                {
LABEL_322:
                  v144 = v150;
                  v145 = (_BYTE *)a2;
                  *(_BYTE *)a2 = 0;
                  *(_QWORD *)(a2 + 8) = v144;
                }
                else
                {
LABEL_293:
                  v144 = 0;
                  v145 = (_BYTE *)a2;
                  *(_BYTE *)a2 = 1;
                }

                if (*v145)
                {
LABEL_324:
                  re::RealityArchiveWriter::close((re::RealityArchiveWriter *)(v17 + 248), (uint64_t)&v221);
                  if ((_BYTE)v221)
                  {
                    if (*(_DWORD *)(v17 + 148))
                    {
                      v151 = *(unsigned int *)(v17 + 144);
                      if ((_DWORD)v151)
                        memset_pattern16(*(void **)(v17 + 128), &memset_pattern_82, 4 * v151);
                      v152 = *(unsigned int *)(v17 + 152);
                      if ((_DWORD)v152)
                      {
                        v153 = 0;
                        v154 = 32 * v152;
                        do
                        {
                          v155 = *(_QWORD *)(v17 + 136) + v153;
                          v156 = *(_DWORD *)(v155 + 8);
                          if (v156 < 0)
                            *(_DWORD *)(v155 + 8) = v156 & 0x7FFFFFFF;
                          v153 += 32;
                        }
                        while (v154 != v153);
                      }
                      *(_DWORD *)(v17 + 148) = 0;
                      *(_DWORD *)(v17 + 152) = 0;
                      v157 = *(_DWORD *)(v17 + 160) + 1;
                      *(_DWORD *)(v17 + 156) = 0x7FFFFFFF;
                      *(_DWORD *)(v17 + 160) = v157;
                    }
                    v158 = *(_QWORD *)(v17 + 176);
                    if ((v158 & 1) != 0)
                    {
                      *(_QWORD *)(v17 + 176) = 1;
                      v159 = *(_BYTE **)(v17 + 184);
                    }
                    else
                    {
                      *(_BYTE *)(v17 + 176) = v158 & 1;
                      v159 = (_BYTE *)(v17 + 177);
                    }
                    *v159 = 0;
                    *(_BYTE *)a2 = 1;
                  }
                  else
                  {
                    v160 = *(_QWORD *)v229;
                    *(_QWORD *)v229 = 0;
                    *(_BYTE *)a2 = 0;
                    *(_QWORD *)(a2 + 8) = v160;

                  }
                  if (!(_BYTE)v221)
                  {
                    v148 = *((_QWORD *)&v221 + 1);
                    if (*((_QWORD *)&v221 + 1))
                    {
                      if ((v222[0] & 1) != 0)
                      {
                        v149 = *(_QWORD *)&v222[8];
LABEL_343:
                        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v148 + 40))(v148, v149);
                      }
                    }
                  }
                }
              }
              else
              {
                re::DynamicString::format((re::DynamicString *)"Type of object for file \"%s\" has not been registered", (re::DynamicString *)&v221, "dedupe.json");
                v147 = *(_QWORD *)v229;
                *(_QWORD *)v229 = 0;
                *(_BYTE *)a2 = 0;
                *(_QWORD *)(a2 + 8) = v147;

                v148 = v221;
                if ((_QWORD)v221 && (BYTE8(v221) & 1) != 0)
                {
                  v149 = *(_QWORD *)v222;
                  goto LABEL_343;
                }
              }
LABEL_304:
              re::AssetMap::~AssetMap((re::AssetMap *)&v191);
              return;
            }
LABEL_308:
            if (*(_QWORD *)&v222[8] && (v222[16] & 1) != 0)
              (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)&v222[8] + 40))(*(_QWORD *)&v222[8], *(_QWORD *)&v222[24]);
            goto LABEL_298;
          }
LABEL_269:
          if (*((_QWORD *)&v199 + 1) == v167)
          {
            if (v167)
            {
              v129 = &v6[4 * v167];
              v130 = (_QWORD *)v200;
              do
              {
                v131 = (uint64_t)(v6 + 1);
                v132 = *v6;
                v6 += 4;
                v133 = (re::DynamicString *)(v130 + 1);
                *v130 = v132;
                v130 += 4;
                re::FixedArray<re::DynamicString>::operator=(v133, v131);
              }
              while (v6 != v129);
            }
            goto LABEL_273;
          }
          goto LABEL_353;
        }
        re::DynamicString::format((re::DynamicString *)"There are %zu possible combinations of configuration names in the reality file, but only %u combinations were utilized.", (re::DynamicString *)&v191, v41, *(unsigned int *)&v222[12]);
      }
      else
      {
        v2 = *((_QWORD *)v173 + 69);
        if (v2 <= (unint64_t)v6)
          goto LABEL_354;
        v47 = *((_QWORD *)v173 + 70) + v40;
        if ((*(_BYTE *)(v47 + 8) & 1) != 0)
          v48 = *(_QWORD *)(v47 + 16);
        else
          v48 = v47 + 9;
        re::DynamicString::format((re::DynamicString *)"A default configuration name of '%s' was specified for configuration set at index %zu, but no matching configurations were added to the set.", (re::DynamicString *)&v191, v48, v6);
      }
      break;
    }
    v44 = 22;
LABEL_101:
    v42 = *(unsigned int **)v229;
    *(_QWORD *)v229 = 0;

    if ((_QWORD)v191 && (BYTE8(v191) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v191 + 40))();
    goto LABEL_110;
  }
  v9 = v221;
  *(_QWORD *)&v221 = 0;
  *(_BYTE *)a2 = 0;
  *(_QWORD *)(a2 + 8) = v9;
LABEL_65:

  if ((_QWORD)v191 && (BYTE8(v191) & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v191 + 40))();
}

BOOL re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v10;

  v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v10, a2);
  v5 = *(unsigned int *)(a1 + 24);
  v6 = 0x7FFFFFFFLL;
  if ((_DWORD)v5)
  {
    v7 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % v5));
    if ((_DWORD)v7 != 0x7FFFFFFF)
    {
      v8 = *(_QWORD *)(a1 + 16);
      v6 = 0x7FFFFFFFLL;
      while (!re::DynamicString::operator==(v8 + 48 * v7 + 16, a2))
      {
        v7 = *(_DWORD *)(v8 + 48 * v7 + 8) & 0x7FFFFFFF;
        if (v7 == 0x7FFFFFFF)
          return v6 != 0x7FFFFFFF;
      }
      v6 = v7;
    }
  }
  return v6 != 0x7FFFFFFF;
}

re::DynamicString *re::HashTable<re::DynamicString,re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add<re::SharedPtr<re::RealityFileWriter::AssetInfo>&>(uint64_t a1, const re::DynamicString *a2, uint64_t *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  re::DynamicString *result;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  char v17;

  v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v17, (uint64_t)a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = *(unsigned int *)(a1 + 36);
    if ((_DWORD)v12 == 0x7FFFFFFF)
    {
      v12 = *(unsigned int *)(a1 + 32);
      v13 = v12;
      if ((_DWORD)v12 == *(_DWORD *)(a1 + 24))
      {
        re::HashTable<re::DynamicString,re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
        LODWORD(v8) = v7 % *(unsigned int *)(a1 + 24);
        v13 = *(_DWORD *)(a1 + 32);
      }
      *(_DWORD *)(a1 + 32) = v13 + 1;
      v14 = *(_QWORD *)(a1 + 16);
      v15 = *(_DWORD *)(v14 + 56 * v12 + 8);
    }
    else
    {
      v14 = *(_QWORD *)(a1 + 16);
      v15 = *(_DWORD *)(v14 + 56 * v12 + 8);
      *(_DWORD *)(a1 + 36) = v15 & 0x7FFFFFFF;
    }
    *(_DWORD *)(v14 + 56 * v12 + 8) = v15 | 0x80000000;
    *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v12 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v12 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v8);
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v12) = v7;
    result = re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 56 * v12 + 16), a2);
    v16 = *a3;
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v12 + 48) = *a3;
    if (v16)
      result = (re::DynamicString *)(id)(v16 + 8);
    *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * v8) = v12;
    ++*(_DWORD *)(a1 + 28);
    ++*(_DWORD *)(a1 + 40);
    return result;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    result = (re::DynamicString *)re::DynamicString::operator==(v10 + 56 * v9 + 16, (uint64_t)a2);
    if ((result & 1) != 0)
      return result;
    v9 = *(_DWORD *)(v10 + 56 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
}

uint64_t re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::add(uint64_t a1, re::DynamicString *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  char v13;

  v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v13, (uint64_t)a2);
  v5 = v4;
  v6 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v6)
  {
    LODWORD(v7) = 0;
    goto LABEL_8;
  }
  v7 = v4 % v6;
  v8 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % v6));
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
LABEL_8:
    v11 = re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(a1, v7, v5, (int)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    return *(_QWORD *)(a1 + 16) + 48 * v11 + 16;
  }
  v9 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    v10 = v9 + 48 * v8 + 16;
    if (re::DynamicString::operator==(v10, (uint64_t)a2))
      return v10;
    v8 = *(_DWORD *)(v9 + 48 * v8 + 8) & 0x7FFFFFFF;
    if (v8 == 0x7FFFFFFF)
      goto LABEL_8;
  }
}

void re::HashTable<re::DynamicString,re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  int v11;
  char v12;

  v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v12, a2);
  if (*(_QWORD *)a1)
  {
    v5 = v4 % *(unsigned int *)(a1 + 24);
    v6 = *(_QWORD *)(a1 + 8);
    v7 = *(unsigned int *)(v6 + 4 * v5);
    if ((_DWORD)v7 != 0x7FFFFFFF)
    {
      v8 = *(_QWORD *)(a1 + 16);
      if (re::DynamicString::operator==(v8 + 56 * v7 + 16, a2))
      {
        *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v8 + 56 * v7 + 8) & 0x7FFFFFFF;
LABEL_8:
        re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 16) + 56 * v7);
        v11 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v7 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v7 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v7;
        *(_DWORD *)(a1 + 40) = v11 + 1;
      }
      else
      {
        while (1)
        {
          v9 = v7;
          v10 = *(_DWORD *)(v8 + 56 * v7 + 8);
          v7 = v10 & 0x7FFFFFFF;
          if ((v10 & 0x7FFFFFFF) == 0x7FFFFFFF)
            break;
          if (re::DynamicString::operator==(v8 + 56 * v7 + 16, a2))
          {
            *(_DWORD *)(v8 + 56 * v9 + 8) = *(_DWORD *)(v8 + 56 * v9 + 8) & 0x80000000 | *(_DWORD *)(v8 + 56 * v7 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
}

uint64_t re::HashSetBase<unsigned long,unsigned long,re::internal::ValueAsKey<unsigned long>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::add(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v4 = *a2;
  v5 = 0xBF58476D1CE4E5B9 * (*a2 ^ ((unint64_t)*a2 >> 30));
  v6 = (0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) ^ ((0x94D049BB133111EBLL * (v5 ^ (v5 >> 27))) >> 31);
  v7 = *(unsigned int *)(a1 + 24);
  if (!(_DWORD)v7)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % v7;
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v6 % v7));
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    v12 = re::HashSetBase<unsigned long,unsigned long,re::internal::ValueAsKey<unsigned long>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addAsCopy(a1, v8, v6, (uint64_t)a2, a2);
    ++*(_DWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 16) + 24 * v12;
    return v11 + 16;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (*(_QWORD *)(v10 + 24 * v9 + 16) != v4)
  {
    LODWORD(v9) = *(_DWORD *)(v10 + 24 * v9 + 8) & 0x7FFFFFFF;
    if ((_DWORD)v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  v11 = v10 + 24 * v9;
  return v11 + 16;
}

re::DynamicString *re::DynamicArray<re::DynamicString>::add(_anonymous_namespace_ *this, re::DynamicString *a2)
{
  unint64_t v4;
  re::DynamicString *result;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::DynamicString>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  result = re::DynamicString::DynamicString((re::DynamicString *)(*((_QWORD *)this + 4) + 32 * v4), a2);
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

unsigned __int8 *re::Optional<re::DynamicString>::operator=(unsigned __int8 *a1, _QWORD *a2)
{
  int v3;
  int v4;
  BOOL v5;
  BOOL v6;
  re::DynamicString *v7;
  BOOL v8;
  uint64_t v9;
  _OWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v3 = *a1;
  v4 = *(unsigned __int8 *)a2;
  if (*a1)
    v5 = 0;
  else
    v5 = v4 == 0;
  if (!v5)
  {
    if (*a1)
      v6 = v4 == 0;
    else
      v6 = 0;
    if (v6)
    {
      v10 = a1 + 8;
      v9 = *((_QWORD *)a1 + 1);
      if (v9)
      {
        if ((a1[16] & 1) != 0)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 40))(v9, *((_QWORD *)a1 + 3));
        *v10 = 0u;
        *(_OWORD *)(a1 + 24) = 0u;
      }
      *a1 = 0;
    }
    else
    {
      v7 = (re::DynamicString *)(a1 + 8);
      if (v3)
        v8 = 1;
      else
        v8 = v4 == 0;
      if (v8)
      {
        re::DynamicString::operator=(v7, (re::DynamicString *)(a2 + 1));
      }
      else
      {
        *a1 = 1;
        *(_OWORD *)v7 = 0u;
        *(_OWORD *)(a1 + 24) = 0u;
        *((_QWORD *)a1 + 4) = a2[4];
        v11 = a2[2];
        *((_QWORD *)a1 + 1) = a2[1];
        a2[1] = 0;
        v12 = a2[3];
        a2[4] = 0;
        v14 = *((_QWORD *)a1 + 2);
        v13 = *((_QWORD *)a1 + 3);
        *((_QWORD *)a1 + 2) = v11;
        *((_QWORD *)a1 + 3) = v12;
        a2[2] = v14;
        a2[3] = v13;
      }
    }
  }
  return a1;
}

re::DynamicString *re::DynamicArray<re::SceneCompatibilityVariant>::add(_anonymous_namespace_ *this, re::DynamicString *a2)
{
  unint64_t v4;
  _DWORD *v5;
  re::DynamicString *result;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::SceneCompatibilityVariant>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = (_DWORD *)(*((_QWORD *)this + 4) + 40 * v4);
  *v5 = *(_DWORD *)a2;
  result = re::DynamicString::DynamicString((re::DynamicString *)(v5 + 2), (re::DynamicString *)((char *)a2 + 8));
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

double re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 88;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(uint64_t result)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  _OWORD *v4;

  v1 = *(_DWORD *)(result + 8);
  if (v1 < 0)
  {
    v2 = result;
    v4 = (_OWORD *)(result + 16);
    v3 = *(_QWORD *)(result + 16);
    *((_DWORD *)v4 - 2) = v1 & 0x7FFFFFFF;
    if (v3)
    {
      if ((*(_BYTE *)(v2 + 24) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *(_QWORD *)(v2 + 32));
      *v4 = 0u;
      v4[1] = 0u;
    }
    return re::DynamicArray<re::DynamicString>::deinit(v2 + 48);
  }
  return result;
}

double re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1, double result)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  __n128 v7;
  uint64_t v8;
  __n128 *v9;
  int v10;
  uint64_t v11;
  __n128 *v12;
  uint64_t v13;

  v3 = *a1;
  if (v3)
  {
    v4 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v4)
    {
      v5 = 0;
      v6 = 0;
      v7 = 0uLL;
      do
      {
        v8 = a1[2];
        v9 = (__n128 *)(v8 + v5);
        v10 = *(_DWORD *)(v8 + v5 + 8);
        if (v10 < 0)
        {
          v9->n128_u32[2] = v10 & 0x7FFFFFFF;
          v13 = v9[1].n128_i64[0];
          v12 = v9 + 1;
          v11 = v13;
          if (v13)
          {
            if ((*(_BYTE *)(v8 + v5 + 24) & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v11 + 40))(v11, *(_QWORD *)(v8 + v5 + 32), v7);
              v7 = 0uLL;
            }
            *v12 = v7;
            v12[1] = v7;
            v4 = *((unsigned int *)a1 + 8);
          }
        }
        ++v6;
        v5 += 48;
      }
      while (v6 < v4);
      v3 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 40))(v3, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

re::AssetHandle *re::DynamicArray<re::AssetHandle>::clear(re::AssetHandle *result)
{
  re::AssetHandle *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = result;
  v2 = *((_QWORD *)result + 2);
  *((_QWORD *)result + 2) = 0;
  if (v2)
  {
    result = (re::AssetHandle *)*((_QWORD *)result + 4);
    v3 = 24 * v2;
    do
    {
      re::AssetHandle::~AssetHandle(result);
      result = (re::AssetHandle *)(v4 + 24);
      v3 -= 24;
    }
    while (v3);
  }
  ++*((_DWORD *)v1 + 6);
  return result;
}

double re::DynamicArray<re::SceneCompatibilityVariant>::add(_anonymous_namespace_ *this, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  double result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = *((_QWORD *)this + 2);
  if (v4 >= *((_QWORD *)this + 1))
  {
    re::DynamicArray<re::SceneCompatibilityVariant>::growCapacity(this, v4 + 1);
    v4 = *((_QWORD *)this + 2);
  }
  v5 = *((_QWORD *)this + 4) + 40 * v4;
  *(_DWORD *)v5 = *(_DWORD *)a2;
  result = 0.0;
  *(_OWORD *)(v5 + 8) = 0u;
  *(_OWORD *)(v5 + 24) = 0u;
  *(_QWORD *)(v5 + 32) = *(_QWORD *)(a2 + 32);
  v7 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(v5 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  v8 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 32) = 0;
  v10 = *(_QWORD *)(v5 + 16);
  v9 = *(_QWORD *)(v5 + 24);
  *(_QWORD *)(v5 + 16) = v7;
  *(_QWORD *)(v5 + 24) = v8;
  *(_QWORD *)(a2 + 16) = v10;
  *(_QWORD *)(a2 + 24) = v9;
  ++*((_QWORD *)this + 2);
  ++*((_DWORD *)this + 6);
  return result;
}

_QWORD *re::DynamicArray<re::SceneCompatibilityVariant>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::SceneCompatibilityVariant>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SceneCompatibilityVariant>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::SceneCompatibilityVariant>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  __int128 v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::SceneCompatibilityVariant>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x28uLL))
        {
          v2 = 40 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 40 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_20;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 40, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = (_QWORD *)(v8 + 16);
        v11 = 40 * v9;
        v12 = 0uLL;
        v13 = v7;
        do
        {
          *(_DWORD *)v13 = *((_DWORD *)v10 - 4);
          *(_OWORD *)(v13 + 1) = v12;
          *(_OWORD *)(v13 + 3) = v12;
          v13[1] = *(v10 - 1);
          *(v10 - 1) = 0;
          v13[4] = v10[2];
          v10[2] = 0;
          v14 = v13[2];
          v15 = v13[3];
          v16 = v10[1];
          v13[2] = *v10;
          v13[3] = v16;
          *v10 = v14;
          v10[1] = v15;
          v17 = *(v10 - 1);
          if (v17)
          {
            if ((v14 & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v17 + 40))(v17, v10[1]);
              v12 = 0uLL;
            }
            *(_OWORD *)(v10 - 1) = v12;
            *(_OWORD *)(v10 + 1) = v12;
          }
          v10 += 5;
          v13 += 5;
          v11 -= 40;
        }
        while (v11);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

BOOL re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::containsKey(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*(_QWORD *)a1)
  {
    v2 = *(_QWORD *)(a2 + 8);
    if (v2)
      v3 = *(_QWORD *)(v2 + 664);
    else
      v3 = 0;
    v5 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (v2 ^ (v2 >> 30))) >> 27));
    v6 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * ((v3 ^ (v5 >> 31) ^ v5) % *(unsigned int *)(a1 + 24)));
    v4 = 0x7FFFFFFFLL;
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a1 + 16);
      v4 = 0x7FFFFFFFLL;
      while (*(_QWORD *)(v7 + 72 * v6 + 24) != v2)
      {
        v6 = *(_DWORD *)(v7 + 72 * v6 + 8) & 0x7FFFFFFF;
        if (v6 == 0x7FFFFFFF)
          return v4 != 0x7FFFFFFF;
      }
      v4 = v6;
    }
  }
  else
  {
    v4 = 0x7FFFFFFFLL;
  }
  return v4 != 0x7FFFFFFF;
}

uint64_t re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::HashTable(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  signed int v5;

  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 36) = 0x7FFFFFFFLL;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    if (*(_DWORD *)(a2 + 28) <= 3u)
      v5 = 3;
    else
      v5 = *(_DWORD *)(a2 + 28);
    re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::init(a1, v4, v5);
    re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::copy(a1, a2);
  }
  return a1;
}

void re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 72 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_82, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

void re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;

  re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::addAsCopy(a1, *(_QWORD *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)v8, (re::AssetHandle *)(v8 + 16), (const re::DynamicString *)(v8 + 40));
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 72;
    }
  }
}

void re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_82, 4 * v2);
    if (*(_DWORD *)(a1 + 32))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 16) + v3);
        ++v4;
        v3 += 72;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

void re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (re::AssetHandle *)(*(_QWORD *)&v13[16] + v10 + 16), (_QWORD *)(*(_QWORD *)&v13[16] + v10 + 40));
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 72;
        }
        while (v11 < v9);
      }
      re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, re::AssetHandle *a4, const re::DynamicString *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 72 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 72 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 72 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 72 * v10) = a3;
  re::AssetHandle::AssetHandle((re::AssetHandle *)(*(_QWORD *)(a1 + 16) + 72 * v10 + 16), a4);
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 72 * v10 + 40), a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

double re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::EntryWithHash::free(uint64_t a1)
{
  int v1;
  double result;
  uint64_t v4;

  v1 = *(_DWORD *)(a1 + 8);
  if (v1 < 0)
  {
    *(_DWORD *)(a1 + 8) = v1 & 0x7FFFFFFF;
    re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 16));
    v4 = *(_QWORD *)(a1 + 40);
    if (v4)
    {
      if ((*(_BYTE *)(a1 + 48) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a1 + 56));
      result = 0.0;
      *(_OWORD *)(a1 + 40) = 0u;
      *(_OWORD *)(a1 + 56) = 0u;
    }
  }
  return result;
}

uint64_t re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, re::AssetHandle *a4, _QWORD *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 72 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 72 * v10 + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 72 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 72 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 72 * v10) = a3;
  re::AssetHandle::AssetHandle((re::AssetHandle *)(*(_QWORD *)(a1 + 16) + 72 * v10 + 16), a4);
  v14 = *(_QWORD *)(a1 + 16) + 72 * v10;
  *(_OWORD *)(v14 + 56) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_QWORD *)(v14 + 64) = a5[3];
  v15 = a5[1];
  *(_QWORD *)(v14 + 40) = *a5;
  *a5 = 0;
  v16 = a5[2];
  a5[3] = 0;
  v18 = *(_QWORD *)(v14 + 48);
  v17 = *(_QWORD *)(v14 + 56);
  *(_QWORD *)(v14 + 48) = v15;
  *(_QWORD *)(v14 + 56) = v16;
  a5[1] = v18;
  a5[2] = v17;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

double re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::AssetHandle,re::DynamicString,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 72;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

re::SceneDescriptor *re::SceneDescriptor::SceneDescriptor(re::SceneDescriptor *this)
{
  _anonymous_namespace_ *v2;
  _anonymous_namespace_ *v3;
  _anonymous_namespace_ *v4;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = off_24ED2D718;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  v3 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 3, 0);
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  v4 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)this + 7, 0);
  *((_BYTE *)this + 88) = 0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 8) = 0u;
  re::DynamicString::setCapacity((_QWORD *)this + 16, 0);
  *((_QWORD *)this + 24) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_DWORD *)this + 46) = 0;
  return this;
}

int *re::DynamicArray<re::SceneCompatibilityVariant>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  int *result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __n128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const re::DynamicString *v13;
  re::DynamicString *v14;

  v4 = *(_QWORD *)(a2 + 16);
  if (v4 >= *(_QWORD *)(a1 + 16))
  {
    re::DynamicArray<re::SceneCompatibilityVariant>::setCapacity((_QWORD *)a1, *(_QWORD *)(a2 + 16));
    result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SceneCompatibilityVariant *,re::SceneCompatibilityVariant *,re::SceneCompatibilityVariant *,0>(*(int **)(a2 + 32), (int *)(*(_QWORD *)(a2 + 32) + 40 * *(_QWORD *)(a1 + 16)), *(_DWORD **)(a1 + 32));
    v10 = *(_QWORD *)(a1 + 16);
    if (v10 != v4)
    {
      v11 = 40 * v4 - 40 * v10;
      v12 = 40 * v10 + 8;
      v13 = (const re::DynamicString *)(*(_QWORD *)(a2 + 32) + v12);
      result = (int *)(*(_QWORD *)(a1 + 32) + v12);
      do
      {
        *(result - 2) = *((_DWORD *)v13 - 2);
        v14 = re::DynamicString::DynamicString((re::DynamicString *)result, v13);
        v13 = (const re::DynamicString *)((char *)v13 + 40);
        result = (int *)((char *)v14 + 40);
        v11 -= 40;
      }
      while (v11);
    }
  }
  else
  {
    result = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SceneCompatibilityVariant *,re::SceneCompatibilityVariant *,re::SceneCompatibilityVariant *,0>(*(int **)(a2 + 32), (int *)(*(_QWORD *)(a2 + 32) + 40 * v4), *(_DWORD **)(a1 + 32));
    v6 = *(_QWORD *)(a1 + 16);
    if (v4 != v6)
    {
      v7 = *(_QWORD *)(a1 + 32) + 40 * v4 + 16;
      v8 = 40 * v6 - 40 * v4;
      v9 = 0uLL;
      do
      {
        result = *(int **)(v7 - 8);
        if (result)
        {
          if ((*(_BYTE *)v7 & 1) != 0)
          {
            result = (int *)(*(uint64_t (**)(int *, _QWORD, __n128))(*(_QWORD *)result + 40))(result, *(_QWORD *)(v7 + 8), v9);
            v9 = 0uLL;
          }
          *(__n128 *)(v7 - 8) = v9;
          *(__n128 *)(v7 + 8) = v9;
        }
        v7 += 40;
        v8 -= 40;
      }
      while (v8);
    }
  }
  *(_QWORD *)(a1 + 16) = v4;
  return result;
}

int *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,re::SceneCompatibilityVariant *,re::SceneCompatibilityVariant *,re::SceneCompatibilityVariant *,0>(int *a1, int *a2, _DWORD *a3)
{
  int *v4;
  re::DynamicString *v6;
  int v7;
  re::DynamicString *v8;

  v4 = a1;
  if (a1 != a2)
  {
    do
    {
      v6 = (re::DynamicString *)(v4 + 2);
      v7 = *v4;
      v4 += 10;
      v8 = (re::DynamicString *)(a3 + 2);
      *a3 = v7;
      a3 += 10;
      re::DynamicString::operator=(v8, v6);
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t re::DynamicArray<re::SceneCompatibilityVariant>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __n128 v7;
  uint64_t v8;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = v3 + 16;
        v6 = 40 * v4;
        v7 = 0uLL;
        do
        {
          v8 = *(_QWORD *)(v5 - 8);
          if (v8)
          {
            if ((*(_BYTE *)v5 & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v8 + 40))(v8, *(_QWORD *)(v5 + 8), v7);
              v7 = 0uLL;
            }
            *(__n128 *)(v5 - 8) = v7;
            *(__n128 *)(v5 + 8) = v7;
          }
          v5 += 40;
          v6 -= 40;
        }
        while (v6);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

_QWORD *re::FixedArray<re::DynamicString>::deinit(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  __n128 *v4;
  uint64_t v5;
  __n128 v6;

  if (*result)
  {
    v1 = result;
    v3 = result + 1;
    v2 = result[1];
    if (v2)
    {
      v4 = (__n128 *)result[2];
      v5 = 32 * v2;
      v6 = 0uLL;
      do
      {
        if (v4->n128_u64[0])
        {
          if ((v4->n128_u8[8] & 1) != 0)
          {
            (*(void (**)(unint64_t, unint64_t, __n128))(*(_QWORD *)v4->n128_u64[0] + 40))(v4->n128_u64[0], v4[1].n128_u64[0], v6);
            v6 = 0uLL;
          }
          *v4 = v6;
          v4[1] = v6;
        }
        v4 += 2;
        v5 -= 32;
      }
      while (v5);
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD, __n128))(*(_QWORD *)*v1 + 40))(*v1, v1[2], v6);
      *v3 = 0;
      v3[1] = 0;
    }
    *v1 = 0;
  }
  return result;
}

_QWORD *re::FixedArray<re::DynamicString>::init<>(_QWORD *result, uint64_t a2, unint64_t a3)
{
  _QWORD *v4;
  _anonymous_namespace_ *v5;
  uint64_t v6;
  _anonymous_namespace_ *v7;
  unint64_t i;

  *result = a2;
  result[1] = a3;
  if (!a3)
    return result;
  if (a3 >> 59)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 32, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v4 = result;
  v5 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 32 * a3, 8);
  v4[2] = v5;
  if (!v5)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v6, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    result = (_QWORD *)_os_crash();
    __break(1u);
    return result;
  }
  v7 = v5;
  for (i = a3 - 1; i; --i)
  {
    *(_OWORD *)v7 = 0u;
    *((_OWORD *)v7 + 1) = 0u;
    v5 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v7, 0);
    v7 = (_anonymous_namespace_ *)((char *)v7 + 32);
  }
  *(_OWORD *)v7 = 0u;
  *((_OWORD *)v7 + 1) = 0u;
  return re::DynamicString::setCapacity(v7, 0);
}

re::DynamicString *re::FixedArray<re::DynamicString>::copy(re::DynamicString *result, uint64_t a2)
{
  uint64_t v2;
  re::DynamicString *v3;
  uint64_t v4;
  re::DynamicString *v5;

  v2 = *((_QWORD *)result + 1);
  if (v2 == *(_QWORD *)(a2 + 8))
  {
    if (v2)
    {
      v3 = *(re::DynamicString **)(a2 + 16);
      result = (re::DynamicString *)*((_QWORD *)result + 2);
      v4 = 32 * v2;
      do
      {
        v5 = re::DynamicString::operator=(result, v3);
        v3 = (re::DynamicString *)((char *)v3 + 32);
        result = (re::DynamicString *)((char *)v5 + 32);
        v4 -= 32;
      }
      while (v4);
    }
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Cannot copy from a FixedArray of a different size", "m_size == other.m_size", "copy", 388);
    result = (re::DynamicString *)_os_crash();
    __break(1u);
  }
  return result;
}

void re::make::shared::object<re::RealityFileWriter::WritingParameters>(re *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t *v3;
  uint64_t v4;

  v3 = re::globalAllocators(a1);
  v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v3[2] + 32))(v3[2], 48, 8);
  *(_OWORD *)v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v4, 0);
  *(_QWORD *)v4 = &off_24ED2CC00;
  *(_QWORD *)(v4 + 24) = 2;
  *(_BYTE *)(v4 + 32) = 0;
  *(_DWORD *)(v4 + 36) = 1;
  *(_WORD *)(v4 + 40) = 0;
  *a2 = v4;
}

void re::RealityFileWriter::WritingParameters::~WritingParameters(re::RealityFileWriter::WritingParameters *this)
{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::Result<re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::WrappedError>::~Result(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)a1)
  {
    if (v2)
    {

      *(_QWORD *)(a1 + 8) = 0;
    }
  }
  else
  {

  }
  return a1;
}

unsigned __int8 *re::Result<re::AssetHandle,re::WrappedError>::~Result(unsigned __int8 *a1)
{
  re::AssetHandle *v2;
  int v3;

  v3 = *a1;
  v2 = (re::AssetHandle *)(a1 + 8);
  if (v3)
    re::AssetHandle::~AssetHandle(v2);
  else

  return a1;
}

re::DynamicString *re::FixedArray<re::DynamicString>::FixedArray(re::DynamicString *a1, uint64_t a2)
{
  uint64_t v4;

  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  v4 = *(_QWORD *)a2;
  if (v4)
  {
    re::FixedArray<re::DynamicString>::init<>(a1, v4, *(_QWORD *)(a2 + 8));
    re::FixedArray<re::DynamicString>::copy(a1, a2);
  }
  return a1;
}

double re::HashTable<re::AssetHandle,re::RealityFileWriter::AssetHandleWithMetadata,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  _OWORD *v10;
  uint64_t v11;
  uint64_t v12;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      v5 = 72;
      do
      {
        v6 = a1[2];
        v7 = v6 + v5;
        v8 = *(_DWORD *)(v6 + v5 - 64);
        if (v8 < 0)
        {
          *(_DWORD *)(v7 - 64) = v8 & 0x7FFFFFFF;
          re::AssetHandle::~AssetHandle((re::AssetHandle *)(v7 - 56));
          re::FixedArray<re::DynamicString>::deinit((_QWORD *)(v7 + 64));
          v11 = *(_QWORD *)(v7 + 24);
          v10 = (_OWORD *)(v7 + 24);
          v9 = v11;
          if (v11)
          {
            if ((*(_BYTE *)(v6 + v5 + 32) & 1) != 0)
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 40))(v9, *(_QWORD *)(v6 + v5 + 40));
            *v10 = 0u;
            v10[1] = 0u;
          }
          v12 = *(_QWORD *)(v6 + v5 - 8);
          if (v12)
          {
            if ((*(_BYTE *)(v6 + v5) & 1) != 0)
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v12 + 40))(v12, *(_QWORD *)(v6 + v5 + 8));
            *(_OWORD *)(v6 + v5 - 8) = 0u;
            *(_OWORD *)(v6 + v5 + 8) = 0u;
          }
          re::AssetHandle::~AssetHandle((re::AssetHandle *)((char *)v10 - 56));
          v3 = *((unsigned int *)a1 + 8);
        }
        ++v4;
        v5 += 160;
      }
      while (v4 < v3);
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<re::AssetHandle,re::RealityFileWriter::AssetHandleWithMetadata,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  signed int v33;
  _BYTE v34[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v34, 0, 36);
      *(_QWORD *)&v34[36] = 0x7FFFFFFFLL;
      re::HashTable<re::AssetHandle,re::RealityFileWriter::AssetHandleWithMetadata,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::init((uint64_t)v34, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v34;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v34[8];
      *(_OWORD *)v34 = v5;
      *(_QWORD *)&v34[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v34[24];
      *(_OWORD *)&v34[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v34[32];
      *(_OWORD *)(a1 + 24) = v9;
      if (v8)
      {
        v10 = 0;
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = 160 * v8;
        do
        {
          v14 = (unint64_t *)(v6 + v10);
          if ((*(_DWORD *)(v6 + v10 + 8) & 0x80000000) != 0)
          {
            v15 = *v14;
            v16 = *(unsigned int *)(a1 + 24);
            v17 = *v14 % v16;
            v18 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v18 == 0x7FFFFFFF)
            {
              v18 = *(unsigned int *)(a1 + 32);
              v19 = v18;
              if ((_DWORD)v18 == (_DWORD)v16)
              {
                re::HashTable<re::AssetHandle,re::RealityFileWriter::AssetHandleWithMetadata,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::setCapacity(a1, (2 * v11));
                v17 = v15 % *(unsigned int *)(a1 + 24);
                v19 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v19 + 1;
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 160 * v18 + 8);
            }
            else
            {
              v20 = *(_QWORD *)(a1 + 16);
              v21 = *(_DWORD *)(v20 + 160 * v18 + 8);
              *(_DWORD *)(a1 + 36) = v21 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v20 + 160 * v18 + 8) = v21 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 160 * v18 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 160 * v18 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v17);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 160 * v18) = v15;
            re::AssetHandle::AssetHandle((re::AssetHandle *)(*(_QWORD *)(a1 + 16) + 160 * v18 + 16), (const re::AssetHandle *)(v14 + 2));
            v22 = *(_QWORD *)(a1 + 16);
            v23 = v22 + 160 * v18;
            v24 = v6 + v10;
            *(_QWORD *)(v23 + 40) = 0;
            *(_QWORD *)(v23 + 48) = 0;
            *(_QWORD *)(v23 + 56) = 0;
            *(_QWORD *)(v23 + 48) = *(_QWORD *)(v6 + v10 + 48);
            *(_QWORD *)(v24 + 48) = 0;
            v25 = *(_QWORD *)(v23 + 40);
            *(_QWORD *)(v23 + 40) = 0;
            *(_QWORD *)(v23 + 40) = v14[5];
            v14[5] = v25;
            v26 = *(_QWORD *)(v23 + 56);
            *(_QWORD *)(v23 + 56) = *(_QWORD *)(v6 + v10 + 56);
            *(_QWORD *)(v24 + 56) = v26;
            *(_OWORD *)(v23 + 64) = 0u;
            *(_OWORD *)(v23 + 80) = 0u;
            *(_QWORD *)(v23 + 64) = *(_QWORD *)(v6 + v10 + 64);
            *(_QWORD *)(v24 + 64) = 0;
            v27 = *(_QWORD *)(v23 + 80);
            *(_QWORD *)(v23 + 80) = *(_QWORD *)(v6 + v10 + 80);
            *(_QWORD *)(v24 + 80) = v27;
            *(_QWORD *)(v23 + 88) = *(_QWORD *)(v6 + v10 + 88);
            *(_QWORD *)(v24 + 88) = 0;
            v28 = *(_QWORD *)(v23 + 72);
            *(_QWORD *)(v23 + 72) = *(_QWORD *)(v6 + v10 + 72);
            *(_QWORD *)(v24 + 72) = v28;
            *(_OWORD *)(v23 + 96) = 0u;
            *(_OWORD *)(v23 + 112) = 0u;
            *(_QWORD *)(v23 + 96) = *(_QWORD *)(v6 + v10 + 96);
            *(_QWORD *)(v24 + 96) = 0;
            v29 = *(_QWORD *)(v23 + 112);
            *(_QWORD *)(v23 + 112) = *(_QWORD *)(v6 + v10 + 112);
            *(_QWORD *)(v24 + 112) = v29;
            *(_QWORD *)(v23 + 120) = *(_QWORD *)(v6 + v10 + 120);
            *(_QWORD *)(v24 + 120) = 0;
            v30 = *(_QWORD *)(v23 + 104);
            *(_QWORD *)(v23 + 104) = *(_QWORD *)(v6 + v10 + 104);
            *(_QWORD *)(v24 + 104) = v30;
            *(_WORD *)(v23 + 128) = *(_WORD *)(v6 + v10 + 128);
            LODWORD(v30) = *(unsigned __int8 *)(v6 + v10 + 130);
            *(_BYTE *)(v23 + 130) = v30;
            if ((_DWORD)v30)
              *(_BYTE *)(v22 + 160 * v18 + 131) = *(_BYTE *)(v24 + 131);
            v31 = (_QWORD *)(v22 + 160 * v18);
            v31[17] = 0;
            v31[18] = 0;
            v31[19] = 0;
            v31[17] = *(_QWORD *)(v24 + 136);
            *(_QWORD *)(v24 + 136) = 0;
            v31[18] = *(_QWORD *)(v24 + 144);
            *(_QWORD *)(v24 + 144) = 0;
            v32 = v31[19];
            v31[19] = *(_QWORD *)(v24 + 152);
            *(_QWORD *)(v24 + 152) = v32;
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v17) = v18;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v10 += 160;
        }
        while (v13 != v10);
      }
      re::HashTable<re::AssetHandle,re::RealityFileWriter::AssetHandleWithMetadata,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)v34);
    }
  }
  else
  {
    if (a2)
      v33 = a2;
    else
      v33 = 3;
  }
}

void re::HashTable<re::AssetHandle,re::RealityFileWriter::AssetHandleWithMetadata,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 160 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_82, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

double re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::EntryWithHash::free((_DWORD *)(a1[2] + v3));
        ++v4;
        v3 += 64;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::EntryWithHash::free(_DWORD *a1)
{
  int v1;

  v1 = a1[2];
  if (v1 < 0)
  {
    a1[2] = v1 & 0x7FFFFFFF;
    re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 4));
    re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 10));
  }
}

void re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::clear(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  int v5;

  if (*(_DWORD *)(a1 + 28))
  {
    v2 = *(unsigned int *)(a1 + 24);
    if ((_DWORD)v2)
      memset_pattern16(*(void **)(a1 + 8), &memset_pattern_82, 4 * v2);
    if (*(_DWORD *)(a1 + 32))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::EntryWithHash::free((_DWORD *)(*(_QWORD *)(a1 + 16) + v3));
        ++v4;
        v3 += 64;
      }
      while (v4 < *(unsigned int *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 28) = 0;
    *(_DWORD *)(a1 + 32) = 0;
    v5 = *(_DWORD *)(a1 + 40) + 1;
    *(_DWORD *)(a1 + 36) = 0x7FFFFFFF;
    *(_DWORD *)(a1 + 40) = v5;
  }
}

void re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::copy(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;

  re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::clear(a1);
  v4 = *(_DWORD *)(a2 + 28);
  if (*(_DWORD *)(a1 + 24) < v4)
    re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::setCapacity(a1, v4);
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5)
  {
    v6 = 0;
    for (i = 0; i < v5; ++i)
    {
      v8 = *(_QWORD *)(a2 + 16) + v6;
      if ((*(_DWORD *)(v8 + 8) & 0x80000000) != 0)
      {
        re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::addAsCopy(a1, *(_QWORD *)v8 % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)v8, (re::AssetHandle *)(v8 + 16), (const re::AssetHandle *)(v8 + 40));
        v5 = *(unsigned int *)(a2 + 32);
      }
      v6 += 64;
    }
  }
}

void re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (re::AssetHandle *)(*(_QWORD *)&v13[16] + v10 + 16), (_QWORD *)(*(_QWORD *)&v13[16] + v10 + 40));
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 64;
        }
        while (v11 < v9);
      }
      re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, re::AssetHandle *a4, const re::AssetHandle *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + (v10 << 6) + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6)) = a3;
  re::AssetHandle::AssetHandle((re::AssetHandle *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 16), a4);
  re::AssetHandle::AssetHandle((re::AssetHandle *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 40), a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, re::AssetHandle *a4, _QWORD *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + (v10 << 6) + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + (v10 << 6) + 8) = v13 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6)) = a3;
  re::AssetHandle::AssetHandle((re::AssetHandle *)(*(_QWORD *)(a1 + 16) + (v10 << 6) + 16), a4);
  v14 = (_QWORD *)(*(_QWORD *)(a1 + 16) + (v10 << 6));
  v14[5] = 0;
  v14[6] = 0;
  v14[7] = 0;
  v14[6] = a5[1];
  a5[1] = 0;
  v15 = v14[5];
  v14[5] = 0;
  v14[5] = *a5;
  *a5 = v15;
  v16 = v14[7];
  v14[7] = a5[2];
  a5[2] = v16;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::AssetHandle,re::AssetHandle,re::Hash<re::AssetHandle>,re::EqualTo<re::AssetHandle>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + (v10 << 6), 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_82, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 88 * v10 + 8) = v13 | 0x80000000;
  v14 = 88 * v10;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v14) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + v14 + 16), a4);
  v15 = *(_QWORD *)(a1 + 16) + 88 * v10;
  *(_QWORD *)(v15 + 80) = 0;
  *(_DWORD *)(v15 + 72) = 0;
  *(_QWORD *)(v15 + 56) = 0;
  *(_QWORD *)(v15 + 64) = 0;
  *(_QWORD *)(v15 + 48) = 0;
  v16 = *(_QWORD *)(a5 + 8);
  *(_QWORD *)(v15 + 48) = *(_QWORD *)a5;
  *(_QWORD *)(v15 + 56) = v16;
  *(_QWORD *)a5 = 0;
  *(_QWORD *)(a5 + 8) = 0;
  v17 = *(_QWORD *)(v15 + 64);
  *(_QWORD *)(v15 + 64) = *(_QWORD *)(a5 + 16);
  *(_QWORD *)(a5 + 16) = v17;
  v18 = *(_QWORD *)(v15 + 80);
  *(_QWORD *)(v15 + 80) = *(_QWORD *)(a5 + 32);
  *(_QWORD *)(a5 + 32) = v18;
  ++*(_DWORD *)(a5 + 24);
  ++*(_DWORD *)(v15 + 72);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (re::DynamicString *)(*(_QWORD *)&v13[16] + v10 + 16), *(_QWORD *)&v13[16] + v10 + 48);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 88;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

void re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 88 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_82, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

_QWORD *re::DynamicArray<re::DynamicString>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::DynamicString>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::DynamicString>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::DynamicString>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  __int128 v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::DynamicString>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 32 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_20;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = (_QWORD *)(v8 + 16);
        v11 = 32 * v9;
        v12 = 0uLL;
        v13 = v7;
        do
        {
          *(_OWORD *)v13 = v12;
          *((_OWORD *)v13 + 1) = v12;
          *v13 = *(v10 - 2);
          *(v10 - 2) = 0;
          v14 = *v10;
          v13[3] = v10[1];
          v10[1] = 0;
          v15 = v13[1];
          v16 = v13[2];
          v17 = *(v10 - 1);
          v13[2] = v14;
          *v10 = v16;
          v13[1] = v17;
          *(v10 - 1) = v15;
          v18 = *(v10 - 2);
          if (v18)
          {
            if ((v15 & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v18 + 40))(v18, *v10);
              v12 = 0uLL;
            }
            *((_OWORD *)v10 - 1) = v12;
            *(_OWORD *)v10 = v12;
          }
          v10 += 4;
          v13 += 4;
          v11 -= 32;
        }
        while (v11);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

double re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 88;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(uint64_t result)
{
  int v1;
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;
  char v5;

  v1 = *(_DWORD *)(result + 8);
  if (v1 < 0)
  {
    v2 = result;
    v3 = (_OWORD *)(result + 16);
    result = *(_QWORD *)(result + 16);
    *((_DWORD *)v3 - 2) = v1 & 0x7FFFFFFF;
    if (result)
    {
      if ((*(_BYTE *)(v2 + 24) & 1) != 0)
        result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 40))(result, *(_QWORD *)(v2 + 32));
      *v3 = 0u;
      v3[1] = 0u;
    }
    v4 = *(unsigned int *)(v2 + 80);
    if ((_DWORD)v4 != -1)
      result = ((uint64_t (*)(char *, uint64_t))off_24ED2CC38[v4])(&v5, v2 + 48);
    *(_DWORD *)(v2 + 80) = -1;
  }
  return result;
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2re13DynamicStringENS8_4DataEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSC_1EJS9_SA_EEEEEEDcSE_DpT0_(uint64_t a1, _QWORD *a2)
{
  double result;

  if (*a2)
  {
    if ((a2[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 40))(*a2, a2[2]);
    result = 0.0;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2re13DynamicStringENS8_4DataEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSC_1EJS9_SA_EEEEEEDcSE_DpT0_(uint64_t a1, id *a2)
{

}

uint64_t re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addInternal<re::DynamicString>(uint64_t a1, re::DynamicString *a2, int a3, _QWORD *a4)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  char v27;
  char v28;

  v8 = re::Hash<re::DynamicString>::operator()((uint64_t)&v26, (uint64_t)a2);
  v9 = v8;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v10) = 0;
    goto LABEL_8;
  }
  v10 = v8 % *(unsigned int *)(a1 + 24);
  v11 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v10);
  if ((_DWORD)v11 == 0x7FFFFFFF)
  {
LABEL_8:
    v13 = re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<re::DynamicString>(a1, v10, v9, a2, a4);
    ++*(_DWORD *)(a1 + 40);
    v14 = *(_QWORD *)(a1 + 16) + 88 * v13;
    return v14 + 48;
  }
  v12 = *(_QWORD *)(a1 + 16);
  while (!re::DynamicString::operator==(v12 + 88 * v11 + 16, (uint64_t)a2))
  {
    v11 = *(_DWORD *)(v12 + 88 * v11 + 8) & 0x7FFFFFFF;
    if (v11 == 0x7FFFFFFF)
      goto LABEL_8;
  }
  switch(a3)
  {
    case 0:
    case 1:
      v14 = v12 + 88 * v11;
      return v14 + 48;
    case 2:
      v16 = v12 + 88 * v11;
      v17 = v16 + 48;
      v18 = *(unsigned int *)(v16 + 80);
      if ((_DWORD)v18 != -1)
        ((void (*)(char *, uint64_t))off_24ED2CC38[v18])(&v27, v17);
      goto LABEL_16;
    case 3:
      v19 = v12 + 88 * v11;
      v17 = v19 + 48;
      v20 = *(unsigned int *)(v19 + 80);
      if ((_DWORD)v20 != -1)
        ((void (*)(char *, uint64_t))off_24ED2CC38[v20])(&v28, v17);
LABEL_16:
      *(_DWORD *)(v17 + 32) = -1;
      v21 = *(_QWORD *)(a1 + 16) + 88 * v11;
      *(_OWORD *)(v21 + 48) = 0u;
      *(_OWORD *)(v21 + 64) = 0u;
      *(_QWORD *)(v21 + 72) = a4[3];
      v22 = a4[1];
      *(_QWORD *)(v21 + 48) = *a4;
      *a4 = 0;
      v23 = a4[2];
      a4[3] = 0;
      v25 = *(_QWORD *)(v21 + 56);
      v24 = *(_QWORD *)(v21 + 64);
      *(_QWORD *)(v21 + 56) = v22;
      *(_QWORD *)(v21 + 64) = v23;
      a4[1] = v25;
      a4[2] = v24;
      *(_DWORD *)(v21 + 80) = 0;
      ++*(_DWORD *)(a1 + 40);
      v14 = *(_QWORD *)(a1 + 16) + 88 * v11;
      break;
    default:
      goto LABEL_8;
  }
  return v14 + 48;
}

uint64_t re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addEmplace<re::DynamicString>(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, _QWORD *a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 88 * v10 + 8) = v13 | 0x80000000;
  v14 = 88 * v10;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v14) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + v14 + 16), a4);
  v15 = *(_QWORD *)(a1 + 16) + 88 * v10;
  *(_OWORD *)(v15 + 48) = 0u;
  *(_OWORD *)(v15 + 64) = 0u;
  *(_QWORD *)(v15 + 72) = a5[3];
  v16 = a5[1];
  *(_QWORD *)(v15 + 48) = *a5;
  *a5 = 0;
  v17 = a5[2];
  a5[3] = 0;
  v19 = *(_QWORD *)(v15 + 56);
  v18 = *(_QWORD *)(v15 + 64);
  *(_QWORD *)(v15 + 56) = v16;
  *(_QWORD *)(v15 + 64) = v17;
  a5[1] = v19;
  a5[2] = v18;
  *(_DWORD *)(v15 + 80) = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

void re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::DynamicArray<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (re::DynamicString *)(*(_QWORD *)&v13[16] + v10 + 16), *(_QWORD *)&v13[16] + v10 + 48);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 88;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 88 * v10 + 8) = v13 | 0x80000000;
  v14 = 88 * v10;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v14) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + v14 + 16), a4);
  v15 = *(_QWORD *)(a1 + 16) + 88 * v10;
  *(_BYTE *)(v15 + 48) = 0;
  v15 += 48;
  *(_DWORD *)(v15 + 32) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<re::DynamicString,re::Data>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<re::DynamicString,re::Data>,(std::__variant_detail::_Trait)1>>(v15, a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<re::DynamicString,re::Data>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<re::DynamicString,re::Data>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  char v7;

  v3 = result;
  v4 = *(unsigned int *)(result + 32);
  if ((_DWORD)v4 != -1)
    result = ((uint64_t (*)(char *, uint64_t))off_24ED2CC38[v4])(&v7, result);
  *(_DWORD *)(v3 + 32) = -1;
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5 != -1)
  {
    result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_24ED2CC48[v5])(&v6, v3, a2);
    *(_DWORD *)(v3 + 32) = v5;
  }
  return result;
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re13DynamicStringENS8_4DataEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSI_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEEOSQ_EEEDcSI_DpT0_(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  double result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  result = 0.0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)(a2 + 24) = a3[3];
  v4 = a3[1];
  *(_QWORD *)a2 = *a3;
  *a3 = 0;
  v5 = a3[2];
  a3[3] = 0;
  v7 = *(_QWORD *)(a2 + 8);
  v6 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = v4;
  *(_QWORD *)(a2 + 16) = v5;
  a3[1] = v7;
  a3[2] = v6;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re13DynamicStringENS8_4DataEEEEE19__generic_constructB8nn180100INS0_18__move_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSI_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEEOSQ_EEEDcSI_DpT0_(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  uint64_t v3;

  v3 = *a3;
  *a3 = 0;
  *a2 = v3;
}

void re::RealityFileWriter::AssetInfo::~AssetInfo(re::RealityFileWriter::AssetInfo *this)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = off_24ED2CC68;
  v2 = (char *)this + 168;
  re::FixedArray<re::DynamicString>::deinit((_QWORD *)this + 33);
  re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 26);
  re::DynamicArray<re::SceneCompatibilityVariant>::deinit((uint64_t)v2);
  v3 = *((_QWORD *)this + 17);
  if (v3)
  {
    if ((*((_BYTE *)this + 144) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 19));
    *(_OWORD *)((char *)this + 136) = 0u;
    *(_OWORD *)((char *)this + 152) = 0u;
  }
  re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)this + 96);
  v4 = *((_QWORD *)this + 8);
  if (v4)
  {
    if ((*((_BYTE *)this + 72) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 10));
    *((_OWORD *)this + 4) = 0u;
    *((_OWORD *)this + 5) = 0u;
  }
  v5 = *((_QWORD *)this + 4);
  if (v5)
  {
    if ((*((_BYTE *)this + 40) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)this + 6));
    *((_OWORD *)this + 2) = 0u;
    *((_OWORD *)this + 3) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)this = off_24ED2CC68;
  v2 = (char *)this + 168;
  re::FixedArray<re::DynamicString>::deinit((_QWORD *)this + 33);
  re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)this + 26);
  re::DynamicArray<re::SceneCompatibilityVariant>::deinit((uint64_t)v2);
  v3 = *((_QWORD *)this + 17);
  if (v3)
  {
    if ((*((_BYTE *)this + 144) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 19));
    *(_OWORD *)((char *)this + 136) = 0u;
    *(_OWORD *)((char *)this + 152) = 0u;
  }
  re::DynamicArray<re::SharedPtr<re::ecs2::System>>::deinit((uint64_t)this + 96);
  v4 = *((_QWORD *)this + 8);
  if (v4)
  {
    if ((*((_BYTE *)this + 72) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 10));
    *((_OWORD *)this + 4) = 0u;
    *((_OWORD *)this + 5) = 0u;
  }
  v5 = *((_QWORD *)this + 4);
  if (v5)
  {
    if ((*((_BYTE *)this + 40) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)this + 6));
    *((_OWORD *)this + 2) = 0u;
    *((_OWORD *)this + 3) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

void re::HashTable<re::DynamicString,re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  signed int v21;
  _BYTE v22[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(_QWORD *)&v22[36] = 0x7FFFFFFFLL;
      re::HashTable<re::DynamicString,re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v22, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v22;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)v22 = v5;
      *(_QWORD *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = (_QWORD *)(v6 + 48);
        do
        {
          if ((*(_DWORD *)(v13 - 5) & 0x80000000) != 0)
          {
            v14 = *(v13 - 6);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashTable<re::DynamicString,re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 56 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 56 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 56 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 56 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v17) = v14;
            re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 56 * v17 + 16), (const re::DynamicString *)(v13 - 4));
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 56 * v17 + 48) = *v13;
            *v13 = 0;
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 7;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::DynamicString,re::SharedPtr<re::internal::AssetEntry>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2)
      v21 = a2;
    else
      v21 = 3;
  }
}

void re::HashTable<re::DynamicString,re::SharedPtr<re::RealityFileWriter::AssetInfo>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 56 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_82, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, int a4, re::DynamicString *a5)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 48 * v9 + 8);
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 16);
    v12 = *(_DWORD *)(v11 + 48 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v12 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v11 + 48 * v9 + 8) = v12 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 48 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 48 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * v9) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 48 * v9 + 16), a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
  return v9;
}

void re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_OWORD *)&v13[24];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = DWORD2(v7);
      if (DWORD2(v7))
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, (_QWORD *)(*(_QWORD *)&v13[16] + v10 + 16));
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 48;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13, *(double *)&v7);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

void re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 48 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_82, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 600);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<re::DynamicString,re::DynamicString,re::internal::ValueAsKey<re::DynamicString>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 48 * v8 + 8);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 48 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 48 * v8 + 8) = v11 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 48 * v8 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 48 * v8 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * v8) = a3;
  v12 = *(_QWORD *)(a1 + 16) + 48 * v8;
  *(_OWORD *)(v12 + 16) = 0u;
  *(_OWORD *)(v12 + 32) = 0u;
  *(_QWORD *)(v12 + 40) = a5[3];
  v13 = a5[1];
  *(_QWORD *)(v12 + 16) = *a5;
  *a5 = 0;
  v14 = a5[2];
  a5[3] = 0;
  v16 = *(_QWORD *)(v12 + 24);
  v15 = *(_QWORD *)(v12 + 32);
  *(_QWORD *)(v12 + 24) = v13;
  *(_QWORD *)(v12 + 32) = v14;
  a5[1] = v16;
  a5[2] = v15;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashTable<char const*,int,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  signed int v21;
  _BYTE v22[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v22, 0, 36);
      *(_QWORD *)&v22[36] = 0x7FFFFFFFLL;
      re::HashTable<char const*,int,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::init((uint64_t)v22, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v22;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v22[8];
      *(_OWORD *)v22 = v5;
      *(_QWORD *)&v22[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v22[24];
      *(_OWORD *)&v22[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v22[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = v6 + 16;
        do
        {
          if ((*(_DWORD *)(v13 - 8) & 0x80000000) != 0)
          {
            v14 = *(_QWORD *)(v13 - 16);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashTable<char const*,int,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 32 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17) = v14;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 16) = *(_QWORD *)v13;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 24) = *(_DWORD *)(v13 + 8);
            v12 = *(_QWORD *)(a1 + 8);
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 32;
          --v10;
        }
        while (v10);
      }
      re::HashTable<void *,re::internal::AnimationCompositionChainBase *,re::Hash<void *>,re::EqualTo<void *>,true,false>::deinit((uint64_t *)v22);
    }
  }
  else
  {
    if (a2)
      v21 = a2;
    else
      v21 = 3;
  }
}

void re::HashTable<char const*,int,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 32 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_82, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 575);
    _os_crash();
    __break(1u);
  }
}

uint64_t re::HashSetBase<unsigned long,unsigned long,re::internal::ValueAsKey<unsigned long>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addAsCopy(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;

  v8 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v8 == 0x7FFFFFFF)
  {
    v8 = *(unsigned int *)(a1 + 32);
    v9 = v8;
    if ((_DWORD)v8 == *(_DWORD *)(a1 + 24))
    {
      re::HashSetBase<unsigned long,unsigned long,re::internal::ValueAsKey<unsigned long>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::setCapacity(a1, 2 * *(_DWORD *)(a1 + 28));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v9 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v9 + 1;
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 16);
    v11 = *(_DWORD *)(v10 + 24 * v8 + 8);
    *(_DWORD *)(a1 + 36) = v11 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v10 + 24 * v8 + 8) = v11 | 0x80000000;
  v12 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24 * v8 + 16) = *a5;
  *(_DWORD *)(v12 + 4 * a2) = v8;
  ++*(_DWORD *)(a1 + 28);
  return v8;
}

void re::HashSetBase<unsigned long,unsigned long,re::internal::ValueAsKey<unsigned long>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashSetBase<unsigned long,unsigned long,re::internal::ValueAsKey<unsigned long>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashSetBase<unsigned long,unsigned long,re::internal::ValueAsKey<unsigned long>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::addAsCopy(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), *(_QWORD *)&v13[16] + v10 + 16, *(_QWORD *)&v13[16] + v10 + 16);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 24;
        }
        while (v11 < v9);
      }
      re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

void re::HashSetBase<unsigned long,unsigned long,re::internal::ValueAsKey<unsigned long>,re::Hash<unsigned long>,re::EqualTo<unsigned long>,true,false>::init(uint64_t a1, uint64_t a2, signed int a3)
{
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  signed int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;

  v4 = 245;
  v5 = (unsigned int *)&re::internal::PrimeHelper::s_primes;
  do
  {
    v6 = v4 >> 1;
    v7 = &v5[v4 >> 1];
    v9 = *v7;
    v8 = v7 + 1;
    v4 += ~(v4 >> 1);
    if (v9 < a3)
      v5 = v8;
    else
      v4 = v6;
  }
  while (v4);
  v10 = *v5;
  *(_QWORD *)a1 = a2;
  v11 = (4 * v10 + 15) & 0x7FFFFFFF0;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, v11 + 24 * v10, 16);
  if (v12)
  {
    v14 = v12;
    *(_QWORD *)(a1 + 8) = v12;
    if ((_DWORD)v10)
      memset_pattern16(v12, &memset_pattern_82, 4 * v10);
    *(_QWORD *)(a1 + 16) = &v14[v11];
    *(_DWORD *)(a1 + 24) = v10;
    *(_DWORD *)(a1 + 40) = 0;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, v13, "assertion failure: '%s' (%s:line %i) Out of memory.", "temp", "init", 600);
    _os_crash();
    __break(1u);
  }
}

double re::HashTable<re::SharedPtr<re::RealityFileWriter::AssetInfo>,unsigned long,re::Hash<re::SharedPtr<re::RealityFileWriter::AssetInfo>>,re::EqualTo<re::SharedPtr<re::RealityFileWriter::AssetInfo>>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  uint64_t v8;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          v8 = *(_QWORD *)(v6 + 16);
          if (v8)
          {

            *(_QWORD *)(v6 + 16) = 0;
            v3 = *((unsigned int *)a1 + 8);
          }
        }
        v4 += 32;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

_QWORD *re::DynamicArray<re::AssetMapAssetDescriptor>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::AssetMapAssetDescriptor>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::AssetMapAssetDescriptor>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::AssetMapAssetDescriptor>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::AssetMapAssetDescriptor>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xA8uLL))
        {
          v2 = 168 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 168 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 168, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 168 * v9;
        v11 = (uint64_t)v7;
        do
        {
          re::ObjectHelper::move<re::AssetMapAssetDescriptor>(v8, v11);
          v8 += 168;
          v11 += 168;
          v10 -= 168;
        }
        while (v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t re::ObjectHelper::move<re::AssetMapAssetDescriptor>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __n128 v15;
  uint64_t v16;

  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 24) = 0;
  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a2 = *(_QWORD *)a1;
  *(_QWORD *)(a2 + 8) = v3;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v4 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v4;
  v5 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = v5;
  ++*(_DWORD *)(a1 + 24);
  ++*(_DWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 72) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 40) = 0;
  *(_DWORD *)(a2 + 64) = 0;
  v6 = *(_QWORD *)(a1 + 48);
  v7 = (_QWORD *)(a1 + 40);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a2 + 48) = v6;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  v8 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = v8;
  v9 = *(_QWORD *)(a2 + 72);
  *(_QWORD *)(a2 + 72) = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 72) = v9;
  ++*(_DWORD *)(a1 + 64);
  ++*(_DWORD *)(a2 + 64);
  LODWORD(v9) = *(unsigned __int8 *)(a1 + 80);
  *(_BYTE *)(a2 + 80) = v9;
  if ((_DWORD)v9)
  {
    *(_OWORD *)(a2 + 104) = 0u;
    *(_OWORD *)(a2 + 88) = 0u;
    *(_QWORD *)(a2 + 112) = *(_QWORD *)(a1 + 112);
    v10 = *(_QWORD *)(a1 + 96);
    *(_QWORD *)(a2 + 88) = *(_QWORD *)(a1 + 88);
    *(_QWORD *)(a1 + 88) = 0;
    v11 = *(_QWORD *)(a1 + 104);
    *(_QWORD *)(a1 + 112) = 0;
    v13 = *(_QWORD *)(a2 + 96);
    v12 = *(_QWORD *)(a2 + 104);
    *(_QWORD *)(a2 + 96) = v10;
    *(_QWORD *)(a2 + 104) = v11;
    *(_QWORD *)(a1 + 96) = v13;
    *(_QWORD *)(a1 + 104) = v12;
  }
  *(_OWORD *)(a2 + 120) = 0u;
  v14 = a2 + 120;
  *(_DWORD *)(v14 + 32) = 0;
  *(_OWORD *)(v14 + 16) = 0u;
  *(_QWORD *)(v14 + 36) = 0x7FFFFFFFLL;
  re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap((uint64_t *)v14, (uint64_t *)(a1 + 120));
  v15.n128_f64[0] = re::HashTable<re::StringID,re::DynamicString,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::deinit((uint64_t *)(a1 + 120));
  if (*(_BYTE *)(a1 + 80))
  {
    v16 = *(_QWORD *)(a1 + 88);
    if (v16)
    {
      if ((*(_BYTE *)(a1 + 96) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD, double))(*(_QWORD *)v16 + 40))(v16, *(_QWORD *)(a1 + 104), v15.n128_f64[0]);
      v15 = 0uLL;
      *(_OWORD *)(a1 + 88) = 0u;
      *(_OWORD *)(a1 + 104) = 0u;
    }
  }
  if (*v7)
  {
    if (*(_QWORD *)(a1 + 72))
      (*(void (**)(_QWORD, __n128))(*(_QWORD *)*v7 + 40))(*v7, v15);
    *(_QWORD *)(a1 + 72) = 0;
    v7[1] = 0;
    v7[2] = 0;
    *v7 = 0;
    ++*(_DWORD *)(a1 + 64);
  }
  return re::DynamicArray<re::DynamicString>::deinit(a1);
}

uint64_t re::DynamicArray<re::DynamicString>::DynamicArray(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unint64_t v5;

  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = 0;
  v3 = *a2;
  if (*a2)
  {
    v5 = a2[2];
    *(_QWORD *)a1 = v3;
    re::DynamicArray<re::DynamicString>::setCapacity((_QWORD *)a1, v5);
    ++*(_DWORD *)(a1 + 24);
    re::DynamicArray<re::DynamicString>::copy((_QWORD *)a1, (uint64_t)a2);
  }
  return a1;
}

re::DynamicString *re::DynamicArray<re::DynamicString>::copy(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  re::DynamicString *result;
  re::DynamicString *v7;
  uint64_t v8;
  re::DynamicString *v9;
  __n128 *v10;
  __n128 v11;
  uint64_t v12;
  re::DynamicString *v13;
  uint64_t v14;
  uint64_t v15;
  re::DynamicString *v16;
  const re::DynamicString *v17;
  uint64_t v18;
  re::DynamicString *v19;

  v4 = *(_QWORD *)(a2 + 16);
  v5 = a1[2];
  if (v4 >= v5)
  {
    re::DynamicArray<re::DynamicString>::setCapacity(a1, *(_QWORD *)(a2 + 16));
    v13 = *(re::DynamicString **)(a2 + 32);
    v14 = a1[2];
    result = (re::DynamicString *)a1[4];
    if (v14)
    {
      v15 = 32 * v14;
      do
      {
        v16 = re::DynamicString::operator=(result, v13);
        v13 = (re::DynamicString *)((char *)v13 + 32);
        result = (re::DynamicString *)((char *)v16 + 32);
        v15 -= 32;
      }
      while (v15);
      result = (re::DynamicString *)a1[4];
      v14 = a1[2];
      v13 = *(re::DynamicString **)(a2 + 32);
    }
    if (v14 != v4)
    {
      v17 = (re::DynamicString *)((char *)v13 + 32 * v14);
      result = (re::DynamicString *)((char *)result + 32 * v14);
      v18 = 32 * v4 - 32 * v14;
      do
      {
        v19 = re::DynamicString::DynamicString(result, v17);
        v17 = (const re::DynamicString *)((char *)v17 + 32);
        result = (re::DynamicString *)((char *)v19 + 32);
        v18 -= 32;
      }
      while (v18);
    }
  }
  else
  {
    result = (re::DynamicString *)a1[4];
    if (v4)
    {
      v7 = *(re::DynamicString **)(a2 + 32);
      v8 = 32 * v4;
      do
      {
        v9 = re::DynamicString::operator=(result, v7);
        v7 = (re::DynamicString *)((char *)v7 + 32);
        result = (re::DynamicString *)((char *)v9 + 32);
        v8 -= 32;
      }
      while (v8);
      result = (re::DynamicString *)a1[4];
      v5 = a1[2];
    }
    if (v4 != v5)
    {
      v10 = (__n128 *)((char *)result + 32 * v4);
      v11 = 0uLL;
      v12 = 32 * v5 - 32 * v4;
      do
      {
        result = (re::DynamicString *)v10->n128_u64[0];
        if (v10->n128_u64[0])
        {
          if ((v10->n128_u8[8] & 1) != 0)
          {
            result = (re::DynamicString *)(*(uint64_t (**)(re::DynamicString *, unint64_t, __n128))(*(_QWORD *)result + 40))(result, v10[1].n128_u64[0], v11);
            v11 = 0uLL;
          }
          *v10 = v11;
          v10[1] = v11;
        }
        v10 += 2;
        v12 -= 32;
      }
      while (v12);
    }
  }
  a1[2] = v4;
  return result;
}

_QWORD *re::DynamicArray<re::SceneDescriptor>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::DynamicArray<re::SceneDescriptor>::setCapacity(this, a2);
    }
    else
    {
      this = re::DynamicArray<re::SceneDescriptor>::setCapacity(v4, v3);
      ++*((_DWORD *)v4 + 6);
    }
  }
  return this;
}

_QWORD *re::DynamicArray<re::SceneDescriptor>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  re::SceneDescriptor *v7;
  const re::SceneDescriptor *v8;
  uint64_t v9;
  uint64_t v10;
  re::SceneDescriptor *v11;
  const re::SceneDescriptor *v12;
  void (**v13)(const re::SceneDescriptor *);

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::SceneDescriptor>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0xC8uLL))
        {
          v2 = 200 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 200 * a2, 8);
          if (result)
          {
            v7 = (re::SceneDescriptor *)result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 200, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (const re::SceneDescriptor *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 200 * v9;
        v11 = v7;
        v12 = (const re::SceneDescriptor *)v5[4];
        do
        {
          re::SceneDescriptor::SceneDescriptor(v11, v8);
          v13 = *(void (***)(const re::SceneDescriptor *))v12;
          v12 = (const re::SceneDescriptor *)((char *)v12 + 200);
          (*v13)(v8);
          v11 = (re::SceneDescriptor *)((char *)v11 + 200);
          v8 = v12;
          v10 -= 200;
        }
        while (v10);
        v8 = (const re::SceneDescriptor *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, const re::SceneDescriptor *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::HashTable<re::SharedPtr<re::RealityFileWriter::AssetInfo>,unsigned long,re::Hash<re::SharedPtr<re::RealityFileWriter::AssetInfo>>,re::EqualTo<re::SharedPtr<re::RealityFileWriter::AssetInfo>>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  id v22;
  signed int v23;
  _BYTE v24[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v24, 0, 36);
      *(_QWORD *)&v24[36] = 0x7FFFFFFFLL;
      re::HashTable<char const*,int,re::Hash<char const*>,re::EqualTo<char const*>,true,false>::init((uint64_t)v24, v4, a2);
      v5 = *(_OWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)v24;
      v6 = *(_QWORD *)(a1 + 16);
      v7 = *(_OWORD *)&v24[8];
      *(_OWORD *)v24 = v5;
      *(_QWORD *)&v24[16] = v6;
      *(_OWORD *)(a1 + 8) = v7;
      v9 = *(_OWORD *)&v24[24];
      *(_OWORD *)&v24[24] = *(_OWORD *)(a1 + 24);
      v8 = *(_DWORD *)&v24[32];
      *(_OWORD *)(a1 + 24) = v9;
      v10 = v8;
      if (v8)
      {
        v11 = DWORD1(v9);
        v12 = v7;
        v13 = (uint64_t *)(v6 + 16);
        do
        {
          if ((*(_DWORD *)(v13 - 1) & 0x80000000) != 0)
          {
            v14 = *(v13 - 2);
            v15 = *(unsigned int *)(a1 + 24);
            v16 = v14 % v15;
            v17 = *(unsigned int *)(a1 + 36);
            if ((_DWORD)v17 == 0x7FFFFFFF)
            {
              v17 = *(unsigned int *)(a1 + 32);
              v18 = v17;
              if ((_DWORD)v17 == (_DWORD)v15)
              {
                re::HashTable<re::SharedPtr<re::RealityFileWriter::AssetInfo>,unsigned long,re::Hash<re::SharedPtr<re::RealityFileWriter::AssetInfo>>,re::EqualTo<re::SharedPtr<re::RealityFileWriter::AssetInfo>>,true,false>::setCapacity(a1, (2 * v11));
                v16 = v14 % *(unsigned int *)(a1 + 24);
                v18 = *(_DWORD *)(a1 + 32);
                v12 = *(_QWORD *)(a1 + 8);
              }
              *(_DWORD *)(a1 + 32) = v18 + 1;
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
            }
            else
            {
              v19 = *(_QWORD *)(a1 + 16);
              v20 = *(_DWORD *)(v19 + 32 * v17 + 8);
              *(_DWORD *)(a1 + 36) = v20 & 0x7FFFFFFF;
            }
            *(_DWORD *)(v19 + 32 * v17 + 8) = v20 | 0x80000000;
            *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 8) & 0x80000000 | *(_DWORD *)(v12 + 4 * v16);
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17) = v14;
            v21 = *v13;
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 16) = *v13;
            if (v21)
            {
              v22 = (id)(v21 + 8);
              v12 = *(_QWORD *)(a1 + 8);
            }
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 32 * v17 + 24) = v13[1];
            *(_DWORD *)(v12 + 4 * v16) = v17;
            v11 = *(_DWORD *)(a1 + 28) + 1;
            *(_DWORD *)(a1 + 28) = v11;
          }
          v13 += 4;
          --v10;
        }
        while (v10);
      }
      re::HashTable<re::SharedPtr<re::RealityFileWriter::AssetInfo>,unsigned long,re::Hash<re::SharedPtr<re::RealityFileWriter::AssetInfo>>,re::EqualTo<re::SharedPtr<re::RealityFileWriter::AssetInfo>>,true,false>::deinit((uint64_t *)v24);
    }
  }
  else
  {
    if (a2)
      v23 = a2;
    else
      v23 = 3;
  }
}

_QWORD *re::DynamicArray<re::RealityFileConfigurationEntryDescriptor>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::RealityFileConfigurationEntryDescriptor>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 59)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 32, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 32 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 32 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_16;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_16:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = (_QWORD *)v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = &v8[4 * v9];
        v11 = v7;
        do
        {
          *v11 = *v8;
          v11[1] = 0;
          v11[2] = 0;
          v11[3] = 0;
          v13 = v8[1];
          v12 = v8 + 1;
          v11[1] = v13;
          *v12 = 0;
          v14 = v11[3];
          v15 = v12[2];
          v11[2] = v12[1];
          v11[3] = v15;
          v12[1] = 0;
          v12[2] = v14;
          re::FixedArray<re::DynamicString>::deinit(v12);
          v8 = v12 + 3;
          v11 += 4;
        }
        while (v8 != v10);
        v8 = (_QWORD *)v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD *))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_16;
    }
  }
  return result;
}

void re::FixedArray<re::RealityFileConfigurationEntryDescriptor>::init<>(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  _OWORD *v6;
  uint64_t v7;
  _OWORD *v8;

  *a1 = a2;
  a1[1] = a3;
  if (!a3)
    return;
  if (a3 >> 59)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in FixedArray<T>::init(). Element size = %zu, count = %zu", "!overflow", "init", 324, 32, a3);
    _os_crash();
    __break(1u);
    goto LABEL_9;
  }
  v5 = 32 * a3;
  v6 = (_OWORD *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)a2 + 32))(a2, 32 * a3, 8);
  a1[2] = (uint64_t)v6;
  if (!v6)
  {
LABEL_9:
    re::internal::assertLog((re::internal *)4, v7, "assertion failure: '%s' (%s:line %i) Out of memory.", "m_data", "init", 327);
    _os_crash();
    __break(1u);
    return;
  }
  v8 = v6;
  if (a3 != 1)
  {
    bzero(v6, v5 - 32);
    v8 = (_OWORD *)((char *)v8 + v5 - 32);
  }
  *v8 = 0u;
  v8[1] = 0u;
}

uint64_t zip_save_manifest(uint64_t a1, const char *a2, _QWORD **a3, unint64_t a4)
{
  _BYTE *v9;
  unint64_t v10;
  __int128 v11;
  size_t v12;
  char *v13;
  char *v14;
  char *v15;
  _OWORD v16[2];
  _BYTE __src[2048];
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  bzero(__src, 0x800uLL);
  if (a4 > 0x40)
    return 0;
  if (a4)
  {
    v9 = __src;
    v10 = a4;
    do
    {
      zip_calculate_signature(*a3, (uint64_t)v16);
      v11 = v16[1];
      *(_OWORD *)v9 = v16[0];
      *((_OWORD *)v9 + 1) = v11;
      if (!(*(_QWORD *)v9 | *((_QWORD *)v9 + 1) | *((_QWORD *)v9 + 2) | *((_QWORD *)v9 + 3)))
        return 0;
      v9 += 32;
      ++a3;
    }
    while (--v10);
  }
  if (a2)
    v12 = strlen(a2) + 1;
  else
    v12 = 0;
  v13 = (char *)malloc_type_malloc(v12 + 32 * a4 + 10, 0xC2A086EBuLL);
  v14 = v13;
  *(_DWORD *)v13 = 21250386;
  *((_WORD *)v13 + 2) = 2;
  *((_WORD *)v13 + 3) = v12;
  *((_WORD *)v13 + 4) = a4;
  v15 = v13 + 10;
  if (v12)
  {
    memcpy(v13 + 10, a2, v12);
    v15 += v12;
  }
  if (a4)
    memcpy(v15, __src, 32 * a4);
  zip_set_comment(a1, v14, v12 + 32 * a4 + 10);
  free(v14);
  return 1;
}

re::internal::AssetLoadItem *re::internal::AssetLoadItem::AssetLoadItem(re::internal::AssetLoadItem *this)
{
  _anonymous_namespace_ *v2;
  char *v3;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24ED2CCF8;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 2) = 0u;
  re::DynamicString::setCapacity((_QWORD *)this + 4, 0);
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_BYTE *)this + 104) = 1;
  *((_QWORD *)this + 14) = 0;
  *((_BYTE *)this + 120) = 0;
  *((_BYTE *)this + 128) = 0;
  *((_BYTE *)this + 144) = 0;
  *((_BYTE *)this + 184) = 0;
  *((_BYTE *)this + 248) = 0;
  *((_BYTE *)this + 344) = 0;
  *((_DWORD *)this + 94) = 0;
  *((_QWORD *)this + 48) = this;
  v3 = (char *)this + 8;
  *((_QWORD *)this + 49) = 0;
  *((_DWORD *)this + 100) = 0;
  *((_QWORD *)this + 52) = 0;
  *((_QWORD *)this + 53) = 0;
  *((_QWORD *)this + 51) = 0;
  *((_BYTE *)this + 432) = 0;
  return this;
}

void re::internal::AssetLoadItem::~AssetLoadItem(re::internal::AssetLoadItem *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24ED2CCF8;

  v2 = *((_QWORD *)this + 48);
  if (v2)
  {

    *((_QWORD *)this + 48) = 0;
  }
  re::Optional<re::internal::AssetLoadItem::PayloadSource>::~Optional((uint64_t)this + 344);
  re::Optional<re::AssetPath>::~Optional((uint64_t)this + 248);
  re::Optional<re::internal::AssetLoadItem::DescriptorSource>::~Optional((uint64_t)this + 184);
  if (*((_BYTE *)this + 144))
  {
    v3 = *((_QWORD *)this + 19);
    if (v3)
    {
      if ((*((_BYTE *)this + 160) & 1) != 0)
        (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 40))(v3, *((_QWORD *)this + 21));
      *(_OWORD *)((char *)this + 152) = 0u;
      *(_OWORD *)((char *)this + 168) = 0u;
    }
  }
  v4 = *((_QWORD *)this + 4);
  if (v4)
  {
    if ((*((_BYTE *)this + 40) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v4 + 40))(v4, *((_QWORD *)this + 6));
    *((_OWORD *)this + 2) = 0u;
    *((_OWORD *)this + 3) = 0u;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::internal::AssetLoadItem::~AssetLoadItem(this);
  JUMPOUT(0x2276933B8);
}

re::internal::AssetBackgroundLoader *re::internal::AssetBackgroundLoader::AssetBackgroundLoader(re::internal::AssetBackgroundLoader *this, const char *a2)
{
  int v3;
  _BYTE v5[4];
  int v6;

  re::Defaults::intValue((re::Defaults *)"assetBackgroundLoaderTaskLimit", a2, (uint64_t)v5);
  if (v5[0])
    v3 = v6;
  else
    v3 = 8;
  *(_DWORD *)this = v3;
  *((_WORD *)this + 2) = 257;
  *((_QWORD *)this + 8) = (char *)this + 360;
  *((_QWORD *)this + 14) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 0;
  *((_QWORD *)this + 16) = (char *)this + 360;
  *((_QWORD *)this + 22) = 0;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *((_DWORD *)this + 42) = 0;
  *((_QWORD *)this + 29) = 0;
  *((_QWORD *)this + 24) = (char *)this + 360;
  *((_QWORD *)this + 25) = 0;
  *((_QWORD *)this + 26) = 0;
  *((_QWORD *)this + 27) = 0;
  *((_DWORD *)this + 56) = 0;
  *((_QWORD *)this + 32) = (char *)this + 360;
  *((_QWORD *)this + 38) = 0;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *((_DWORD *)this + 74) = 0;
  *((_QWORD *)this + 48) = 0;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *(_OWORD *)((char *)this + 348) = 0u;
  return this;
}

const char *re::internal::AssetBackgroundLoader::init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  NSObject *v7;
  NSObject *v8;
  NSObject *global_queue;
  NSObject *v10;
  NSObject *v11;
  void *v12;
  char *v13;
  const char *result;

  *(_QWORD *)(a1 + 320) = a2;
  *(_QWORD *)(a1 + 328) = a3;
  *(_QWORD *)(a1 + 336) = a4;
  *(_QWORD *)(a1 + 344) = a5;
  *(_QWORD *)(a1 + 352) = a6;
  v7 = MEMORY[0x24BDAC9C0];
  v8 = dispatch_queue_attr_make_with_qos_class(MEMORY[0x24BDAC9C0], QOS_CLASS_USER_INITIATED, -15);
  global_queue = dispatch_get_global_queue(25, 0);
  *(_QWORD *)(a1 + 368) = dispatch_queue_create_with_target_V2("com.apple.re.AssetBackgroundLoader", v8, global_queue);
  v10 = dispatch_queue_attr_make_with_qos_class(v7, QOS_CLASS_USER_INITIATED, 0);
  *(_QWORD *)(a1 + 376) = dispatch_queue_create_with_target_V2("com.apple.re.AssetBackgroundLoaderPriority", v10, global_queue);
  v11 = dispatch_group_create();

  v12 = *(void **)(a1 + 384);
  *(_QWORD *)(a1 + 384) = v11;

  v13 = getenv("RE_ASSET_BACKGROUND_LOADING_ENABLE");
  if (v13)
    *(_BYTE *)(a1 + 4) = atoi(v13) != 0;
  result = getenv("RE_ASSET_BACKGROUND_UNLOADING_ENABLE");
  if (result)
  {
    result = (const char *)atoi(result);
    *(_BYTE *)(a1 + 5) = (_DWORD)result != 0;
  }
  return result;
}

void re::internal::AssetBackgroundLoader::runIfNeeded(re::internal::AssetBackgroundLoader *this, os_unfair_lock_s *a2)
{
  os_unfair_lock_s *v4;
  re::internal::AssetLoadItem *v5;
  unsigned int v6;

  v4 = a2 + 100;
  os_unfair_lock_lock(a2 + 100);
  v6 = atomic_load(&a2[94]._os_unfair_lock_opaque);
  if (v6 == 2)
  {
    re::internal::AssetBackgroundLoader::unloadAsset((re::internal::AssetBackgroundLoader *)a2, v5);
    goto LABEL_5;
  }
  if (v6 == 1)
  {
    re::internal::AssetBackgroundLoader::loadAsset((uint64_t)a2, *((_QWORD *)this + 43));
LABEL_5:
    atomic_store(4u, &a2[94]._os_unfair_lock_opaque);
    re::internal::AssetBackgroundLoader::onActiveTaskDone((uint64_t)this, a2, 1);
  }
  re::internal::AssetBackgroundLoader::startPendingLoadItems((os_unfair_lock_s *)this, 1);
  os_unfair_lock_unlock(v4);
}

void re::internal::AssetBackgroundLoader::loadAsset(uint64_t a1, uint64_t a2)
{
  re *v4;
  NSObject *v5;
  _anonymous_namespace_ *v6;
  _anonymous_namespace_ *v7;
  unint64_t v8;
  re *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  _anonymous_namespace_ *v13;
  CFHashCode v14;
  _anonymous_namespace_ *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  re *ProviderForScheme;
  re *v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  __n128 v25;
  mach_timebase_info v26;
  uint64_t v27;
  char *v28;
  _anonymous_namespace_ *v29;
  mach_timebase_info v30;
  int v31;
  uint64_t CompiledAsset;
  const char **v33;
  const char *v34;
  uint64_t v35;
  NSObject *v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  mach_timebase_info v41;
  uint32_t denom;
  uint32_t numer;
  mach_timebase_info v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  re *v49;
  NSObject *v50;
  uint64_t v51;
  _anonymous_namespace_ *v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t i;
  unint64_t v57;
  uint64_t v58;
  const char *v59;
  size_t v60;
  int v61;
  uint64_t v62;
  int v63;
  _BOOL8 v64;
  _anonymous_namespace_ *v65;
  uint64_t (***v66)(_QWORD, char *);
  char *v67;
  char *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  re *v73;
  NSObject *v74;
  _BOOL8 v75;
  NSObject *v76;
  uint64_t v77;
  _anonymous_namespace_ *v78;
  uint64_t v79;
  std::string *v80;
  char *v81;
  uint64_t v82;
  unint64_t v83;
  double v84;
  unint64_t v85;
  unint64_t v86;
  double v87;
  double v88;
  NSObject *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  CFHashCode v94;
  _anonymous_namespace_ *v95;
  _anonymous_namespace_ *v96;
  char v97[16];
  std::string v98;
  uint64_t v99;
  id v100;
  void (**v101)(re::DeferredAssetDeserialize *__hidden);
  _BYTE v102[16];
  uint64_t v103;
  mach_timebase_info buf[12];
  __int128 cf;
  unint64_t v106;
  int v107;
  uint64_t v108;
  _BYTE v109[38];
  __int128 v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  char *v114;
  uint64_t v115;
  uint64_t v116;

  v116 = *MEMORY[0x24BDAC8D0];
  if (a2)
    (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a2 + 80))(a2, *(_QWORD *)(a1 + 64), a1);
  v4 = re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v102, 2002, a1);
  v5 = *re::assetsLogObjects(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    if ((*(_QWORD *)(a1 + 40) & 1) != 0)
      v53 = *(_QWORD *)(a1 + 48);
    else
      v53 = a1 + 41;
    buf[0].numer = 136315138;
    *(_QWORD *)&buf[0].denom = v53;
    _os_log_debug_impl(&dword_224FE9000, v5, OS_LOG_TYPE_DEBUG, "Loading asset '%s'", (uint8_t *)buf, 0xCu);
  }
  v6 = (_anonymous_namespace_ *)mach_absolute_time();
  v7 = v6;
  v101 = &off_24ED2D2A8;
  if (*(_BYTE *)(a1 + 344))
  {
    v8 = *(_QWORD *)(a1 + 64);
    if (v8)
    {
      v9 = (re *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(a1 + 72), v8);
      v10 = *re::assetsLogObjects(v9);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        if ((*(_QWORD *)(a1 + 40) & 1) != 0)
          v79 = *(_QWORD *)(a1 + 48);
        else
          v79 = a1 + 41;
        buf[0].numer = 136315138;
        *(_QWORD *)&buf[0].denom = v79;
        _os_log_debug_impl(&dword_224FE9000, v10, OS_LOG_TYPE_DEBUG, "Loading asset '%s' from payload", (uint8_t *)buf, 0xCu);
      }
      v11 = (*(uint64_t (**)(re *))(*(_QWORD *)v9 + 120))(v9);
      memset(buf, 0, 36);
      *(_QWORD *)&buf[4].denom = 0x7FFFFFFFLL;
      re::SharedResourcePayload::clientObject((id *)(a1 + 352), &v110);
      v12 = v110;

      if (!v12)
        goto LABEL_75;
      re::SharedResourcePayload::clientObject((id *)(a1 + 352), &cf);
      if ((_QWORD)cf)
        v14 = CFHash((CFTypeRef)cf);
      else
        v14 = 0;
      v96 = v7;
      v37 = re::Hash<re::DynamicString>::operator()((uint64_t)v109, (uint64_t)&v110);
      v38 = v37;
      if (buf[0])
      {
        v39 = v37 % buf[3].numer;
        v40 = *(unsigned int *)(*(_QWORD *)&buf[1] + 4 * v39);
        if ((_DWORD)v40 != 0x7FFFFFFF)
        {
          v94 = v14;
          v41 = buf[2];
          while (!re::DynamicString::operator==(*(_QWORD *)&v41 + 88 * v40 + 16, (uint64_t)&v110))
          {
            v40 = *(_DWORD *)(*(_QWORD *)&v41 + 88 * v40 + 8) & 0x7FFFFFFF;
            if (v40 == 0x7FFFFFFF)
            {
              v14 = v94;
              goto LABEL_65;
            }
          }
          goto LABEL_71;
        }
      }
      else
      {
        LODWORD(v39) = 0;
      }
LABEL_65:
      denom = buf[4].denom;
      if (buf[4].denom == 0x7FFFFFFF)
      {
        denom = buf[4].numer;
        numer = buf[4].numer;
        if (buf[4].numer == buf[3].numer)
        {
          re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data,unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity((uint64_t)buf, 2 * buf[3].denom);
          numer = buf[4].numer;
          LODWORD(v39) = v38 % buf[3].numer;
        }
        buf[4].numer = numer + 1;
        v44 = buf[2];
        v45 = *(_DWORD *)(*(_QWORD *)&buf[2] + 88 * denom + 8);
      }
      else
      {
        v44 = buf[2];
        v45 = *(_DWORD *)(*(_QWORD *)&buf[2] + 88 * buf[4].denom + 8);
        buf[4].denom = v45 & 0x7FFFFFFF;
      }
      *(_DWORD *)(*(_QWORD *)&v44 + 88 * denom + 8) = v45 | 0x80000000;
      v46 = 88 * denom;
      *(_DWORD *)(*(_QWORD *)&buf[2] + v46 + 8) = *(_DWORD *)(*(_QWORD *)&buf[2] + v46 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)&buf[1] + 4 * v39);
      *(_QWORD *)(*(_QWORD *)&buf[2] + v46) = v38;
      re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)&buf[2] + v46 + 16), (const re::DynamicString *)&v110);
      v47 = *(_QWORD *)&buf[2] + 88 * denom;
      *(_QWORD *)(v47 + 48) = v14;
      *(_DWORD *)(v47 + 80) = 2;
      *(_DWORD *)(*(_QWORD *)&buf[1] + 4 * v39) = denom;
      ++buf[3].denom;
      ++buf[5].numer;
LABEL_71:
      if ((_QWORD)v110 && (BYTE8(v110) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v110 + 40))();

      v7 = v96;
LABEL_75:
      v100 = *(id *)(a1 + 352);
      v48 = (*(uint64_t (**)(re *, id *, uint64_t, void (***)(re::DeferredAssetDeserialize *__hidden), uint64_t, mach_timebase_info *))(*(_QWORD *)v9 + 208))(v9, &v100, v11, &v101, a1 + 104, buf);

      if (v48)
      {
        *(_QWORD *)(a1 + 96) = v11;
      }
      else
      {
        v50 = *re::assetsLogObjects(v49);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          if ((*(_QWORD *)(a1 + 40) & 1) != 0)
            v51 = *(_QWORD *)(a1 + 48);
          else
            v51 = a1 + 41;
          LODWORD(v110) = 136315138;
          *(_QWORD *)((char *)&v110 + 4) = v51;
          _os_log_impl(&dword_224FE9000, v50, OS_LOG_TYPE_DEFAULT, "rdar://102632350 Asset '%s' failed to load from payload.", (uint8_t *)&v110, 0xCu);
        }
        v52 = (_anonymous_namespace_ *)(*(uint64_t (**)(re *, uint64_t))(*(_QWORD *)v9 + 16))(v9, v11);
        re::internal::AssetLoadItem::setFailure((re::internal::AssetLoadItem *)a1, (const re::DynamicString *)&v110);
        if ((_QWORD)v110 && (BYTE8(v110) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v110 + 40))();
      }
      re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data,unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)buf);
      goto LABEL_195;
    }
    re::internal::AssetLoadItem::setFailure((re::internal::AssetLoadItem *)a1, (const re::DynamicString *)buf);
    v29 = (_anonymous_namespace_ *)buf[0];
    if (!*(_QWORD *)buf || (buf[1].numer & 1) == 0)
      goto LABEL_195;
    v30 = buf[2];
LABEL_194:
    v29 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, mach_timebase_info))(*(_QWORD *)v29 + 40))(v29, v30);
    goto LABEL_195;
  }
  if (!*(_BYTE *)(a1 + 184))
  {
    buf[0].numer = *(_DWORD *)(a1 + 256);
    re::DynamicString::DynamicString((re::DynamicString *)&buf[1], (const re::DynamicString *)(a1 + 264));
    re::DynamicString::DynamicString((re::DynamicString *)&buf[5], (const re::DynamicString *)(a1 + 296));
    *(_OWORD *)&buf[9].numer = *(_OWORD *)(a1 + 328);
    v31 = dyld_program_sdk_at_least();
    if (!(_DWORD)CompiledAsset)
    {
      v34 = 0;
LABEL_127:
      memset(v109, 0, 32);
      re::DynamicString::setCapacity(v109, 0);
      v64 = re::AssetPath::temp_filePathToSourceAssetInBundle((re::AssetPath *)buf, (re::DynamicString *)v109, *(os_unfair_lock_s **)(a1 + 88));
      if (!v64)
      {
        re::internal::AssetLoadItem::setFailure((re::internal::AssetLoadItem *)a1, (const re::DynamicString *)&v110);
        if ((_QWORD)v110 && (BYTE8(v110) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v110 + 40))();
        if (*(_QWORD *)v109 && (v109[8] & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)v109 + 40))();
        if (buf[5])
        {
          if ((buf[6].numer & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)&buf[5] + 40))();
          memset(&buf[5], 0, 32);
        }
        if (*(_QWORD *)&buf[1] && (buf[2].numer & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&buf[1] + 40))();
        goto LABEL_213;
      }
      v65 = v7;
      v66 = (uint64_t (***)(_QWORD, char *))buf[10];
      if ((v109[8] & 1) != 0)
        v67 = *(char **)&v109[16];
      else
        v67 = (char *)((unint64_t)v109 | 9);
      v68 = strrchr(v67, 46) + 1;
      v69 = (**v66)(v66, v68);
      if (v69)
      {
        v70 = v69;
        v71 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 64));
        v72 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v71 + 176))(v71, 0);
        (*(void (**)(__int128 *__return_ptr, uint64_t, char *, uint64_t, void (***)(re::DeferredAssetDeserialize *__hidden)))(*(_QWORD *)v70 + 40))(&v110, v70, v67, v72, &v101);
        v73 = (re *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v70 + 56))(v70, v72);
        v74 = *re::assetsLogObjects(v73);
        v75 = os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG);
        if (v75)
        {
          if ((*(_QWORD *)(a1 + 40) & 1) != 0)
            v92 = *(_QWORD *)(a1 + 48);
          else
            v92 = a1 + 41;
          LODWORD(cf) = 136315138;
          *(_QWORD *)((char *)&cf + 4) = v92;
          _os_log_debug_impl(&dword_224FE9000, v74, OS_LOG_TYPE_DEBUG, "Compiling source asset '%s'", (uint8_t *)&cf, 0xCu);
        }
        v7 = v65;
        if ((_BYTE)v110)
        {
          v76 = *re::assetsLogObjects((re *)v75);
          if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
          {
            if ((*(_QWORD *)(a1 + 40) & 1) != 0)
              v93 = *(_QWORD *)(a1 + 48);
            else
              v93 = a1 + 41;
            LODWORD(cf) = 136315138;
            *(_QWORD *)((char *)&cf + 4) = v93;
            _os_log_debug_impl(&dword_224FE9000, v76, OS_LOG_TYPE_DEBUG, "Compiled asset '%s'", (uint8_t *)&cf, 0xCu);
          }
          *(_QWORD *)(a1 + 96) = *((_QWORD *)&v110 + 1);
          if (*(_BYTE *)(a1 + 344))
            v77 = *(_QWORD *)(a1 + 360);
          else
            v77 = 0;
          re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)&v98, 2056, v77, **(const char ***)(a1 + 64));
          if (((*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v71 + 24))(v71, *(_QWORD *)(a1 + 96), 0, 0) & 1) == 0)
          {
            v78 = (_anonymous_namespace_ *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v71 + 16))(v71, *(_QWORD *)(a1 + 96));
            *(_QWORD *)(a1 + 96) = 0;
            re::internal::AssetLoadItem::setFailure((re::internal::AssetLoadItem *)a1, (const re::DynamicString *)&cf);
            if ((_QWORD)cf)
            {
              if ((BYTE8(cf) & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)cf + 40))();
            }
          }
          re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)&v98);
        }
        else
        {
          std::error_code::message(&v98, (const std::error_code *)((char *)&v110 + 8));
          if ((v98.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v80 = &v98;
          else
            v80 = (std::string *)v98.__r_.__value_.__r.__words[0];
          if ((v113 & 1) != 0)
            v81 = v114;
          else
            v81 = (char *)&v113 + 1;
          re::DynamicString::format((re::DynamicString *)"Failed to compile -- %s (%s)", (re::DynamicString *)&cf, v80, v81);
          re::internal::AssetLoadItem::setFailure((re::internal::AssetLoadItem *)a1, (const re::DynamicString *)&cf);
          if ((_QWORD)cf && (BYTE8(cf) & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)cf + 40))();
          if (SHIBYTE(v98.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v98.__r_.__value_.__l.__data_);
        }
        if (!(_BYTE)v110 && v112 && (v113 & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v112 + 40))();
      }
      else
      {
        re::DynamicString::format((re::DynamicString *)"Failed to compile -- no compiler for files with extension %s", (re::DynamicString *)&v110, v68);
        re::internal::AssetLoadItem::setFailure((re::internal::AssetLoadItem *)a1, (const re::DynamicString *)&v110);
        if ((_QWORD)v110 && (BYTE8(v110) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v110 + 40))();
        v7 = v65;
      }
      CompiledAsset = *(_QWORD *)v109;
      if (*(_QWORD *)v109 && (v109[8] & 1) != 0)
        CompiledAsset = (*(uint64_t (**)(void))(**(_QWORD **)v109 + 40))();
      v62 = *(_QWORD *)(a1 + 96);
LABEL_180:
      if (!v62 && *(_DWORD *)(a1 + 136) != 3)
      {
        if (!v34)
          v34 = "Unknown failure";
        re::internal::AssetLoadItem::setFailure((re::internal::AssetLoadItem *)a1, (const re::DynamicString *)&v110);
        if ((_QWORD)v110 && (BYTE8(v110) & 1) != 0)
          (*(void (**)(void))(*(_QWORD *)v110 + 40))();
      }
      if (buf[5])
      {
        if ((buf[6].numer & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&buf[5] + 40))();
        memset(&buf[5], 0, 32);
      }
      v29 = (_anonymous_namespace_ *)buf[1];
      if (*(_QWORD *)&buf[1] && (buf[2].numer & 1) != 0)
      {
        v30 = buf[3];
        goto LABEL_194;
      }
LABEL_195:
      if (!*(_QWORD *)(a1 + 96))
      {
        if (*(_DWORD *)(a1 + 136) != 3)
        {
          re::internal::AssetLoadItem::setFailure((re::internal::AssetLoadItem *)a1, (const re::DynamicString *)buf);
          if (buf[0])
          {
            if ((buf[1].numer & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)buf + 40))();
          }
        }
        goto LABEL_211;
      }
      *(_DWORD *)(a1 + 136) = 2;
      v82 = mach_absolute_time();
      v83 = v82 - (_QWORD)v7;
      *(_QWORD *)(a1 + 408) = v82 - (_QWORD)v7;
      v84 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
      if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale < 0.0)
      {
        v82 = mach_timebase_info(buf);
        if ((_DWORD)v82)
        {
          v87 = NAN;
LABEL_205:
          v88 = v87 / 1000000.0;
          if (v87 / 1000000.0 > 1000.0)
          {
            v89 = *re::assetsLogObjects((re *)v82);
            if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
            {
              if ((*(_QWORD *)(a1 + 40) & 1) != 0)
                v90 = *(_QWORD *)(a1 + 48);
              else
                v90 = a1 + 41;
              buf[0].numer = 134218498;
              *(_QWORD *)&buf[0].denom = a1;
              LOWORD(buf[1].denom) = 2080;
              *(_QWORD *)((char *)&buf[1].denom + 2) = v90;
              HIWORD(buf[2].denom) = 2048;
              buf[3] = *(mach_timebase_info *)&v88;
              _os_log_impl(&dword_224FE9000, v89, OS_LOG_TYPE_DEFAULT, "Asset(%llu) '%s' took '%.0f' ms to load", (uint8_t *)buf, 0x20u);
            }
          }
LABEL_211:
          if (a2)
            (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a2 + 88))(a2, *(_QWORD *)(a1 + 64), a1);
          goto LABEL_213;
        }
        LODWORD(v85) = buf[0].numer;
        LODWORD(v86) = buf[0].denom;
        v84 = (double)v85 / (double)v86;
        re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v84;
      }
      v87 = v84 * (double)v83;
      goto LABEL_205;
    }
    v33 = *(const char ***)(a1 + 64);
    v97[0] = 0;
    CompiledAsset = re::AssetUtilities::loadCompiledAsset((_anonymous_namespace_ *)buf, a1 + 72, v33, (uint64_t)&v101, (uint64_t)v97, (uint64_t)&v110);
    if ((_BYTE)v110)
    {
      v34 = 0;
      v35 = *((_QWORD *)&v110 + 1);
      *(_QWORD *)(a1 + 96) = *((_QWORD *)&v110 + 1);
      if (v35)
        goto LABEL_55;
    }
    else
    {
      *(_QWORD *)(a1 + 96) = 0;
      CompiledAsset = re::WrappedError::localizedDescription((id *)&v110 + 1);
      v34 = (const char *)CompiledAsset;
      if (*(_QWORD *)(a1 + 96))
      {
LABEL_55:
        v36 = *re::assetsLogObjects((re *)CompiledAsset);
        CompiledAsset = os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)CompiledAsset)
        {
          if ((*(_QWORD *)(a1 + 40) & 1) != 0)
            v91 = *(_QWORD *)(a1 + 48);
          else
            v91 = a1 + 41;
          LODWORD(cf) = 136315138;
          *(_QWORD *)((char *)&cf + 4) = v91;
          _os_log_debug_impl(&dword_224FE9000, v36, OS_LOG_TYPE_DEBUG, "Loaded compiled asset '%s'", (uint8_t *)&cf, 0xCu);
        }
        goto LABEL_121;
      }
    }
    if (v34)
      v61 = 1;
    else
      v61 = v31;
    if (!v61)
      v34 = "Can't find source asset path";
LABEL_121:
    if (!(_BYTE)v110)

    v62 = *(_QWORD *)(a1 + 96);
    if (v62)
      v63 = 0;
    else
      v63 = v31;
    if (v63 != 1)
      goto LABEL_180;
    goto LABEL_127;
  }
  v95 = v6;
  v15 = (_anonymous_namespace_ *)re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray((uint64_t)&v110, (uint64_t *)(a1 + 192));
  v16 = *(char **)(a1 + 232);
  v114 = v16;
  if (v16)
    v15 = v16 + 8;
  v115 = *(_QWORD *)(a1 + 240);
  v108 = 0;
  v106 = 0;
  cf = 0uLL;
  v107 = 0;
  if (v111)
  {
    v17 = v113;
    v18 = 144 * v111;
    while (1)
    {
      v19 = (*(_BYTE *)(v17 + 8) & 1) != 0 ? *(const char **)(v17 + 16) : (const char *)(v17 + 9);
      ProviderForScheme = (re *)re::AssetProviderRegistry::tryGetProviderForScheme(*(os_unfair_lock_s **)(a1 + 88), v19);
      if (!ProviderForScheme)
        break;
      v21 = ProviderForScheme;
      if (re::assetsHighFrequencyLoggingEnabled(void)::onceToken != -1)
        dispatch_once(&re::assetsHighFrequencyLoggingEnabled(void)::onceToken, &__block_literal_global_1);
      if (re::assetsHighFrequencyLoggingEnabled(void)::shouldLog)
      {
        v22 = *re::assetsLogObjects(ProviderForScheme);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          if ((*(_BYTE *)(v17 + 8) & 1) != 0)
            v23 = *(_QWORD *)(v17 + 16);
          else
            v23 = v17 + 9;
          buf[0].numer = 136315138;
          *(_QWORD *)&buf[0].denom = v23;
          _os_log_impl(&dword_224FE9000, v22, OS_LOG_TYPE_DEFAULT, "Loading requested descriptor of type '%s'", (uint8_t *)buf, 0xCu);
        }
      }
      (*(void (**)(mach_timebase_info *__return_ptr, re *, uint64_t, uint64_t, void (***)(re::DeferredAssetDeserialize *__hidden), char *))(*(_QWORD *)v21 + 40))(buf, v21, v17, v115, &v101, v114);
      if (LOBYTE(buf[0].numer))
      {
        *(mach_timebase_info *)(a1 + 120) = buf[6];
        *(_BYTE *)(a1 + 128) = buf[7].numer;
        v15 = (_anonymous_namespace_ *)buf[1];
        *(mach_timebase_info *)(a1 + 96) = buf[5];
        if (v15 && (buf[2].numer & 1) != 0)
          v15 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, _QWORD))(*(_QWORD *)v15 + 40))(v15, *(_QWORD *)&buf[3]);
        goto LABEL_94;
      }
      if ((*(_BYTE *)(v17 + 8) & 1) != 0)
        v27 = *(_QWORD *)(v17 + 16);
      else
        v27 = v17 + 9;
      if ((buf[2].numer & 1) != 0)
        v28 = (char *)buf[3];
      else
        v28 = (char *)&buf[2] + 1;
      re::DynamicString::format((re::DynamicString *)"Asset provider load failed: type '%s' -- %s", (re::DynamicString *)v109, v27, v28);
      v25.n128_f64[0] = re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)&cf, v109);
      if (*(_QWORD *)v109 && (v109[8] & 1) != 0)
        (*(void (**)(double))(**(_QWORD **)v109 + 40))(v25.n128_f64[0]);
      v15 = (_anonymous_namespace_ *)buf[1];
      if (*(_QWORD *)&buf[1] && (buf[2].numer & 1) != 0)
      {
        v26 = buf[3];
LABEL_46:
        v15 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, mach_timebase_info, __n128))(*(_QWORD *)v15 + 40))(v15, v26, v25);
      }
LABEL_47:
      v17 += 144;
      v18 -= 144;
      if (!v18)
        goto LABEL_94;
    }
    if ((*(_BYTE *)(v17 + 8) & 1) != 0)
      v24 = *(_QWORD *)(v17 + 16);
    else
      v24 = v17 + 9;
    re::DynamicString::format((re::DynamicString *)"No asset provider found: type '%s'", (re::DynamicString *)buf, v24);
    v25.n128_f64[0] = re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)&cf, buf);
    v15 = (_anonymous_namespace_ *)buf[0];
    if (!*(_QWORD *)buf || (buf[1].numer & 1) == 0)
      goto LABEL_47;
    v26 = buf[2];
    goto LABEL_46;
  }
LABEL_94:
  if (*(_QWORD *)(a1 + 96))
  {
    re::DynamicArray<re::DynamicString>::deinit((uint64_t)&cf);
    if (v114)
    {

      v114 = 0;
    }
    v29 = (_anonymous_namespace_ *)re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)&v110);
    v7 = v95;
    goto LABEL_195;
  }
  v54 = v106;
  *(_OWORD *)&v98.__r_.__value_.__r.__words[1] = 0uLL;
  v99 = 0;
  re::DynamicString::setCapacity(&v98, 0);
  if (v54)
  {
    v55 = 0;
    for (i = 0; i != v54; ++i)
    {
      v57 = v106;
      if (v106 <= i)
      {
        v103 = 0;
        memset(buf, 0, 80);
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v109 = 136315906;
        *(_QWORD *)&v109[4] = "operator[]";
        *(_WORD *)&v109[12] = 1024;
        *(_DWORD *)&v109[14] = 789;
        *(_WORD *)&v109[18] = 2048;
        *(_QWORD *)&v109[20] = i;
        *(_WORD *)&v109[28] = 2048;
        *(_QWORD *)&v109[30] = v57;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v58 = v108 + v55;
      if ((*(_BYTE *)(v108 + v55 + 8) & 1) != 0)
        v59 = *(const char **)(v58 + 16);
      else
        v59 = (const char *)(v58 + 9);
      v60 = strlen(v59);
      re::DynamicString::append((re::DynamicString *)&v98, v59, v60);
      if (i < v54 - 1)
        re::DynamicString::append((re::DynamicString *)&v98, "; ", 2uLL);
      v55 += 32;
    }
  }
  re::internal::AssetLoadItem::setFailure((re::internal::AssetLoadItem *)a1, (const re::DynamicString *)&v98);
  if (a2)
    (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a2 + 88))(a2, *(_QWORD *)(a1 + 64), a1);
  if (v98.__r_.__value_.__r.__words[0] && (v98.__r_.__value_.__s.__data_[8] & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v98.__r_.__value_.__l.__data_ + 40))();
  re::DynamicArray<re::DynamicString>::deinit((uint64_t)&cf);
  if (v114)
  {

    v114 = 0;
  }
  re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)&v110);
LABEL_213:
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v102);
}

void re::internal::AssetBackgroundLoader::onActiveTaskDone(uint64_t a1, _QWORD *a2, int a3)
{
  NSObject *v6;
  std::chrono::system_clock::time_point v7;
  os_unfair_lock_s *v8;
  _QWORD *v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  re *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  _QWORD buf[4];
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v6 = *re::assetsLogObjects((re *)a1);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    if ((a2[5] & 1) != 0)
      v23 = (char *)a2[6];
    else
      v23 = (char *)a2 + 41;
    LODWORD(buf[0]) = 136315138;
    *(_QWORD *)((char *)buf + 4) = v23;
    _os_log_debug_impl(&dword_224FE9000, v6, OS_LOG_TYPE_DEBUG, "Finished background processing of asset '%s'", (uint8_t *)buf, 0xCu);
  }
  v7.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  if (v7.__d_.__rep_ - a2[53] >= 1000000
    && re::internal::enableSignposts(0, 0)
    && re::internal::enableHighFrequencyTracing(0, 0))
  {
    kdebug_trace();
  }
  v8 = (os_unfair_lock_s *)(a1 + 360);
  if (a3 == 1)
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 360));
  v9 = *(_QWORD **)(a1 + 232);
  v10 = *(_QWORD *)(a1 + 216);
  v11 = v9;
  if (v10)
  {
    v12 = 8 * v10;
    v11 = *(_QWORD **)(a1 + 232);
    while ((_QWORD *)*v11 != a2)
    {
      ++v11;
      v12 -= 8;
      if (!v12)
      {
        v11 = &v9[v10];
        break;
      }
    }
  }
  v13 = v11 - v9;
  if (v13 != v10)
  {
    if (v10 <= v13)
    {
      v26 = 0u;
      v27 = 0u;
      v25 = 0u;
      memset(buf, 0, sizeof(buf));
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    if (v10 - 1 > v13)
      v9[v13] = v9[v10 - 1];
    *(_QWORD *)(a1 + 216) = v10 - 1;
    ++*(_DWORD *)(a1 + 224);
  }
  buf[0] = a2;
  v14 = (re *)re::Queue<re::internal::AssetLoadItem *>::enqueue((_QWORD *)(a1 + 264), buf);
  v15 = *(_QWORD *)(a1 + 88);
  if (v15)
  {
    v16 = *(_QWORD *)(a1 + 216);
    v17 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8 * *(_QWORD *)(a1 + 96)) + 416);
    if (a3 == 1)
      os_unfair_lock_unlock(v8);
    v18 = v7.__d_.__rep_ - v17;
    if (v18 >= 5000000)
    {
      v19 = *re::assetsLogObjects(v14);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        v20 = a2[5];
        v21 = (char *)a2[6];
        LODWORD(buf[0]) = 136315906;
        if ((v20 & 1) != 0)
          v22 = v21;
        else
          v22 = (char *)a2 + 41;
        *(_QWORD *)((char *)buf + 4) = v22;
        WORD2(buf[1]) = 2048;
        *(_QWORD *)((char *)&buf[1] + 6) = v18 / 1000;
        HIWORD(buf[2]) = 2048;
        buf[3] = v15;
        LOWORD(v25) = 2048;
        *(_QWORD *)((char *)&v25 + 2) = v16;
        _os_log_impl(&dword_224FE9000, v19, OS_LOG_TYPE_DEFAULT, "Asset '%s' has been in pending state in Asset Background Loader for '%lld' ms, pending queue size is '%zu', active queue size is '%zu", (uint8_t *)buf, 0x2Au);
      }
    }
  }
  else if (a3 == 1)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 360));
  }
}

void re::internal::AssetBackgroundLoader::unloadAsset(re::internal::AssetBackgroundLoader *this, re::internal::AssetLoadItem *a2)
{
  uint64_t v3;
  unint64_t v4;
  re *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  double v9;
  unint64_t v10;
  unint64_t v11;
  double v12;
  double v13;
  NSObject *v14;
  char *v15;
  char *v16;
  _BYTE v17[16];
  _BYTE info[12];
  __int16 v19;
  char *v20;
  __int16 v21;
  double v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  re::internal::AriadneSignpostScopeGuard::AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v17, 2010, (uint64_t)this);
  v3 = mach_absolute_time();
  v4 = *((_QWORD *)this + 8);
  if (v4)
  {
    v5 = (re *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*((_QWORD *)this + 9), v4);
    v6 = *re::assetsLogObjects(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      if ((*((_QWORD *)this + 5) & 1) != 0)
        v16 = (char *)*((_QWORD *)this + 6);
      else
        v16 = (char *)this + 41;
      *(_DWORD *)info = 136315138;
      *(_QWORD *)&info[4] = v16;
      _os_log_debug_impl(&dword_224FE9000, v6, OS_LOG_TYPE_DEBUG, "Unloading asset '%s'", info, 0xCu);
    }
    (*(void (**)(re *, _QWORD))(*(_QWORD *)v5 + 16))(v5, *((_QWORD *)this + 12));
  }
  v7 = mach_absolute_time();
  v8 = v7;
  v9 = *(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale;
  if (*(double *)&re::convertMachTimeToNanoSecs(unsigned long long)::tmscale >= 0.0)
    goto LABEL_8;
  v7 = mach_timebase_info((mach_timebase_info_t)info);
  if (!(_DWORD)v7)
  {
    LODWORD(v10) = *(_DWORD *)info;
    LODWORD(v11) = *(_DWORD *)&info[4];
    v9 = (double)v10 / (double)v11;
    re::convertMachTimeToNanoSecs(unsigned long long)::tmscale = *(_QWORD *)&v9;
LABEL_8:
    v12 = v9 * (double)(v8 - v3);
    goto LABEL_9;
  }
  v12 = NAN;
LABEL_9:
  v13 = v12 / 1000000.0;
  if (v12 / 1000000.0 > 1000.0)
  {
    v14 = *re::assetsLogObjects((re *)v7);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      if ((*((_QWORD *)this + 5) & 1) != 0)
        v15 = (char *)*((_QWORD *)this + 6);
      else
        v15 = (char *)this + 41;
      *(_DWORD *)info = 134218498;
      *(_QWORD *)&info[4] = this;
      v19 = 2080;
      v20 = v15;
      v21 = 2048;
      v22 = v13;
      _os_log_impl(&dword_224FE9000, v14, OS_LOG_TYPE_DEFAULT, "Asset(%llu) '%s' took '%.0f' ms to unload", info, 0x20u);
    }
  }
  *((_DWORD *)this + 34) = 4;
  re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v17);
}

void re::internal::AssetBackgroundLoader::startPendingLoadItems(os_unfair_lock_s *a1, int a2)
{
  os_unfair_lock_s *v3;
  std::chrono::system_clock::time_point v4;
  std::chrono::system_clock::time_point v5;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep;
  uint64_t v7;
  uint64_t v8;
  re *v9;
  re *v10;
  uint64_t v11;
  NSObject *v12;
  const char *v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  char *v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x24BDAC8D0];
  v3 = a1 + 90;
  if (a2 == 1)
    os_unfair_lock_lock(a1 + 90);
  v4.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  if (*(_QWORD *)&a1[54]._os_unfair_lock_opaque < (unint64_t)(int)a1->_os_unfair_lock_opaque)
  {
    rep = v4.__d_.__rep_;
    do
    {
      v7 = *(_QWORD *)&a1[38]._os_unfair_lock_opaque;
      v8 = (uint64_t)&a1[34];
      if (!v7)
      {
        v8 = (uint64_t)&a1[18];
        if (!*(_QWORD *)&a1[22]._os_unfair_lock_opaque)
          break;
      }
      v9 = (re *)re::Queue<re::internal::AssetLoadItem *>::dequeue(v8, v5.__d_.__rep_);
      v10 = v9;
      v11 = rep - *((_QWORD *)v9 + 52);
      if (v11 >= 300000)
      {
        v12 = *re::assetsLogObjects(v9);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          v13 = "";
          if (v7)
            v13 = "Priority ";
          if ((*((_BYTE *)v10 + 40) & 1) != 0)
            v14 = (char *)*((_QWORD *)v10 + 6);
          else
            v14 = (char *)v10 + 41;
          v15 = *(_QWORD *)&a1[38]._os_unfair_lock_opaque;
          v16 = *(_QWORD *)&a1[22]._os_unfair_lock_opaque;
          v17 = *(_QWORD *)&a1[54]._os_unfair_lock_opaque;
          v18 = *(_QWORD *)&a1[70]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136316674;
          v21 = v13;
          v22 = 2080;
          v23 = v14;
          v24 = 2048;
          v25 = v11 / 1000;
          v26 = 2048;
          v27 = v15;
          v28 = 2048;
          v29 = v16;
          v30 = 2048;
          v31 = v17;
          v32 = 2048;
          v33 = v18;
          _os_log_impl(&dword_224FE9000, v12, OS_LOG_TYPE_DEFAULT, "%sAsset '%s' has been in pending state in Asset Background Loader for '%lld' ms, started loading now\nPending Priority: %zu, Pending Normal: %zu, Active: %zu, Done: %zu", buf, 0x48u);
        }
      }
      re::internal::AssetBackgroundLoader::startBackgroundTask(a1, v10, 0, v7 != 0);
    }
    while (*(_QWORD *)&a1[54]._os_unfair_lock_opaque < (unint64_t)(int)a1->_os_unfair_lock_opaque);
  }
  if (a2 == 1)
    os_unfair_lock_unlock(v3);
}

_QWORD *re::Queue<re::internal::AssetLoadItem *>::enqueue(_QWORD *this, _QWORD *a2)
{
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v3 = this;
  v5 = this[1];
  v4 = this[2];
  v6 = v4 + 1;
  if (v4 + 1 >= v5)
  {
    this = re::Queue<re::internal::AssetLoadItem *>::growCapacity(this, v6);
    v5 = v3[1];
    v4 = v3[2];
    v6 = v4 + 1;
  }
  *(_QWORD *)(v3[5] + 8 * ((v3[3] + v4) % v5)) = *a2;
  v3[2] = v6;
  ++*((_DWORD *)v3 + 8);
  return this;
}

void re::internal::AssetBackgroundLoader::prepareBackgroundTask(uint64_t a1, uint64_t a2, int a3)
{
  int v6;
  BOOL v7;
  BOOL v8;
  NSObject *v9;
  _BOOL4 v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t v14[24];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v6 = *(_DWORD *)(a2 + 136);
  if (*(_BYTE *)(a1 + 4))
    v7 = 0;
  else
    v7 = v6 == 0;
  if (v7)
  {
    re::internal::AssetBackgroundLoader::loadAsset(a2, *(_QWORD *)(a1 + 344));
    goto LABEL_14;
  }
  if (*(_BYTE *)(a1 + 5))
    v8 = 0;
  else
    v8 = v6 == 1;
  if (v8)
  {
    re::internal::AssetBackgroundLoader::unloadAsset((re::internal::AssetBackgroundLoader *)a2, (re::internal::AssetLoadItem *)a2);
LABEL_14:
    if (a3 == 1)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 360));
      *(_QWORD *)v14 = a2;
      re::Queue<re::internal::AssetLoadItem *>::enqueue((_QWORD *)(a1 + 264), v14);
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 360));
    }
    else
    {
      *(_QWORD *)v14 = a2;
      re::Queue<re::internal::AssetLoadItem *>::enqueue((_QWORD *)(a1 + 264), v14);
    }
    return;
  }
  v9 = *re::assetsLogObjects((re *)a1);
  v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
  if (v6)
  {
    if (v10)
    {
      if ((*(_QWORD *)(a2 + 40) & 1) != 0)
        v12 = *(_QWORD *)(a2 + 48);
      else
        v12 = a2 + 41;
      *(_DWORD *)v14 = 136315138;
      *(_QWORD *)&v14[4] = v12;
      v11 = 2;
      _os_log_debug_impl(&dword_224FE9000, v9, OS_LOG_TYPE_DEBUG, "Starting background unload of asset '%s'", v14, 0xCu);
    }
    else
    {
      v11 = 2;
    }
  }
  else
  {
    if (v10)
    {
      if ((*(_QWORD *)(a2 + 40) & 1) != 0)
        v13 = *(_QWORD *)(a2 + 48);
      else
        v13 = a2 + 41;
      *(_DWORD *)v14 = 136315138;
      *(_QWORD *)&v14[4] = v13;
      _os_log_debug_impl(&dword_224FE9000, v9, OS_LOG_TYPE_DEBUG, "Starting background load of asset '%s'", v14, 0xCu);
    }
    v11 = 1;
  }
  atomic_store(v11, (unsigned int *)(a2 + 376));
  *(std::chrono::system_clock::time_point *)(a2 + 424) = std::chrono::system_clock::now();
  if (a3 == 1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 360));
    *(_QWORD *)v14 = a2;
    re::DynamicArray<re::RigDataValue *>::add((_anonymous_namespace_ *)(a1 + 200), v14);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 360));
  }
  else
  {
    *(_QWORD *)v14 = a2;
    re::DynamicArray<re::RigDataValue *>::add((_anonymous_namespace_ *)(a1 + 200), v14);
  }
}

void re::internal::AssetBackgroundLoader::startBackgroundTask(uint64_t a1, uint64_t a2, int a3, int a4)
{
  id v7;
  uint64_t v8;
  NSObject *v9;
  _QWORD v10[6];

  re::internal::AssetBackgroundLoader::prepareBackgroundTask(a1, a2, a3);
  if (*(_BYTE *)(a1 + 4) && *(_BYTE *)(a1 + 5))
  {
    dispatch_group_enter(*(dispatch_group_t *)(a1 + 384));
    v7 = (id)(a2 + 8);
    v8 = 368;
    if (a4)
      v8 = 376;
    v9 = *(NSObject **)(a1 + v8);
    v10[0] = MEMORY[0x24BDAC760];
    v10[1] = 0x40000000;
    v10[2] = ___ZN2re8internal21AssetBackgroundLoader19startBackgroundTaskERNS0_13AssetLoadItemENS1_9LockStateEb_block_invoke;
    v10[3] = &__block_descriptor_tmp_1;
    v10[4] = a1;
    v10[5] = a2;
    dispatch_async(v9, v10);
  }
}

void ___ZN2re8internal21AssetBackgroundLoader19startBackgroundTaskERNS0_13AssetLoadItemENS1_9LockStateEb_block_invoke(uint64_t a1)
{
  dispatch_group_t *v2;

  v2 = *(dispatch_group_t **)(a1 + 32);
  re::internal::AssetBackgroundLoader::runIfNeeded((re::internal::AssetBackgroundLoader *)v2, *(os_unfair_lock_s **)(a1 + 40));

  dispatch_group_leave(v2[48]);
}

void re::internal::AssetBackgroundLoader::queueOrStartBackgroundTask(os_unfair_lock_s *this, std::chrono::system_clock::time_point *a2, const char *a3, int a4)
{
  os_unfair_lock_s *v8;
  re *v9;
  NSObject *v10;
  char *rep;
  os_unfair_lock_s *v12;
  _BYTE v13[12];
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  v8 = this + 90;
  os_unfair_lock_lock(this + 90);
  if (*(_QWORD *)&this[54]._os_unfair_lock_opaque >= (unint64_t)(int)this->_os_unfair_lock_opaque)
  {
    if (re::assetsHighFrequencyLoggingEnabled(void)::onceToken != -1)
      dispatch_once(&re::assetsHighFrequencyLoggingEnabled(void)::onceToken, &__block_literal_global_1);
    if (re::assetsHighFrequencyLoggingEnabled(void)::shouldLog)
    {
      v10 = *re::assetsLogObjects(v9);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        if ((a2[5].__d_.__rep_ & 1) != 0)
          rep = (char *)a2[6].__d_.__rep_;
        else
          rep = (char *)&a2[5].__d_.__rep_ + 1;
        *(_DWORD *)v13 = 136315394;
        *(_QWORD *)&v13[4] = a3;
        v14 = 2080;
        v15 = rep;
        _os_log_impl(&dword_224FE9000, v10, OS_LOG_TYPE_DEFAULT, "Deferring background %s of asset '%s'", v13, 0x16u);
      }
    }
    a2[52].__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    if (a4)
      v12 = this + 34;
    else
      v12 = this + 18;
    *(_QWORD *)v13 = a2;
    re::Queue<re::internal::AssetLoadItem *>::enqueue(v12, v13);
    os_unfair_lock_unlock(v8);
  }
  else
  {
    os_unfair_lock_unlock(v8);
    re::internal::AssetBackgroundLoader::startBackgroundTask((uint64_t)this, (uint64_t)a2, 1, a4);
  }
}

void re::internal::AssetBackgroundLoader::loadAssetAsync(re *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X5>, int a7@<W6>, re::internal::AssetLoadItem **a8@<X8>)
{
  uint64_t *v16;
  _QWORD *v17;
  re::internal::AssetLoadItem *Item;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  id v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v16 = re::globalAllocators(a1);
  v17 = (_QWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v16[2] + 32))(v16[2], 440, 8);
  Item = re::internal::AssetLoadItem::AssetLoadItem((re::internal::AssetLoadItem *)v17);
  *a8 = Item;
  *((_QWORD *)Item + 3) = a2;
  *((_QWORD *)Item + 8) = a3;
  *((_QWORD *)Item + 12) = 0;
  *((_DWORD *)Item + 34) = 0;
  v19 = *((_QWORD *)a1 + 42);
  *((_QWORD *)Item + 9) = *((_QWORD *)a1 + 40);
  *((_QWORD *)Item + 10) = 0;
  *((_QWORD *)Item + 11) = v19;
  v20 = *a5;
  *a5 = 0;
  v21 = *a6;
  if (v21)
    v22 = (id)(v21 + 8);
  LOBYTE(v25) = 1;
  v26 = v20;
  v27 = a4;
  v28 = v21;
  re::Optional<re::internal::AssetLoadItem::PayloadSource>::operator=((uint64_t)(v17 + 43), &v25);
  re::Optional<re::internal::AssetLoadItem::PayloadSource>::~Optional((uint64_t)&v25);
  v23 = v17[5];
  if ((v23 & 1) != 0)
    v24 = v23 >> 1;
  else
    v24 = v23 >> 1;
  if (!v24)
  {
    re::DynamicString::format((re::DynamicString *)"#%llu", (re::DynamicString *)&v25, a4);
    re::DynamicString::operator=((re::DynamicString *)(v17 + 4), (re::DynamicString *)&v25);
    if (v25)
    {
      if ((v26 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v25 + 40))();
    }
  }
  re::internal::AssetBackgroundLoader::queueOrStartBackgroundTask((os_unfair_lock_s *)a1, (std::chrono::system_clock::time_point *)v17, "load", a7);
}

uint64_t re::Optional<re::internal::AssetLoadItem::PayloadSource>::operator=(uint64_t a1, _QWORD *a2)
{
  int v3;
  BOOL v4;
  BOOL v5;
  BOOL v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v3 = *(unsigned __int8 *)a2;
  if (*(_BYTE *)a1)
    v4 = 0;
  else
    v4 = v3 == 0;
  if (!v4)
  {
    if (*(_BYTE *)a1)
      v5 = v3 == 0;
    else
      v5 = 0;
    if (v5)
    {
      v12 = *(_QWORD *)(a1 + 24);
      if (v12)
      {

        *(_QWORD *)(a1 + 24) = 0;
      }

      *(_BYTE *)a1 = 0;
    }
    else
    {
      if (*(_BYTE *)a1)
        v7 = 1;
      else
        v7 = v3 == 0;
      if (v7)
      {
        if ((_QWORD *)a1 != a2)
        {
          v8 = a2[1];
          a2[1] = 0;
          v9 = *(void **)(a1 + 8);
          *(_QWORD *)(a1 + 8) = v8;

        }
        v10 = *(_QWORD *)(a1 + 24);
        v11 = a2[3];
        *(_QWORD *)(a1 + 16) = a2[2];
        *(_QWORD *)(a1 + 24) = v11;
        a2[3] = v10;
      }
      else
      {
        *(_BYTE *)a1 = 1;
        v13 = a2[1];
        v14 = a2[2];
        a2[1] = 0;
        *(_QWORD *)(a1 + 8) = v13;
        *(_QWORD *)(a1 + 16) = v14;
        *(_QWORD *)(a1 + 24) = a2[3];
        a2[3] = 0;
      }
    }
  }
  return a1;
}

void re::internal::AssetBackgroundLoader::loadAssetAsync(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, uint64_t *a6@<X5>, re::internal::AssetLoadItem **a7@<X8>)
{
  uint64_t *v14;
  uint64_t v15;
  re::internal::AssetLoadItem *Item;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  id v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  uint64_t ProviderForScheme;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  __int128 v37;
  int v38;
  __int128 v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int128 v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;

  v14 = re::globalAllocators((re *)a1);
  v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v14[2] + 32))(v14[2], 440, 8);
  Item = re::internal::AssetLoadItem::AssetLoadItem((re::internal::AssetLoadItem *)v15);
  *a7 = Item;
  *((_QWORD *)Item + 3) = a2;
  *((_QWORD *)Item + 8) = a3;
  *((_QWORD *)Item + 12) = 0;
  *((_DWORD *)Item + 34) = 0;
  v17 = *(_QWORD *)(a1 + 336);
  *((_QWORD *)Item + 9) = *(_QWORD *)(a1 + 320);
  *((_QWORD *)Item + 10) = 0;
  *((_QWORD *)Item + 11) = v17;
  re::DynamicArray<re::AssetLoadDescriptor>::DynamicArray((uint64_t)&v36, a5);
  v19 = *a6;
  *((_QWORD *)&v39 + 1) = v19;
  if (v19)
  {
    v20 = (id)(v19 + 8);
    v19 = *((_QWORD *)&v39 + 1);
  }
  v40 = a4;
  LOBYTE(v41) = 1;
  v21 = v36;
  v22 = v37;
  v36 = 0;
  v42 = v21;
  v23 = *((_QWORD *)&v37 + 1);
  v43 = v37;
  v37 = 0u;
  v24 = v39;
  ++v38;
  v44 = 1;
  v45 = v39;
  v46 = v19;
  v39 = 0u;
  v47 = a4;
  if (*(_BYTE *)(v15 + 184))
  {
    if ((uint64_t *)(v15 + 184) != &v41)
    {
      v25 = *(_QWORD *)(v15 + 192);
      if (v25)
        v26 = v21 == 0;
      else
        v26 = 1;
      if (!v26 && v25 != v21)
      {
        re::internal::assertLog((re::internal *)4, v18, "assertion failure: '%s' (%s:line %i) ", "!isInitialized() || !other.isInitialized() || m_allocator == other.m_allocator", "operator=", 503);
        _os_crash();
        __break(1u);
        return;
      }
      v42 = *(_QWORD *)(v15 + 192);
      v28 = *(_OWORD *)(v15 + 200);
      *(_QWORD *)(v15 + 192) = v21;
      *(_QWORD *)(v15 + 200) = v22;
      *(_QWORD *)(v15 + 208) = v23;
      v43 = v28;
      v29 = *(_QWORD *)(v15 + 224);
      *(_QWORD *)(v15 + 224) = v24;
      v45 = v29;
      v44 = 2;
      ++*(_DWORD *)(v15 + 216);
    }
    v30 = *(_QWORD *)(v15 + 232);
  }
  else
  {
    v30 = 0;
    *(_BYTE *)(v15 + 184) = 1;
    *(_QWORD *)(v15 + 192) = v21;
    *(_QWORD *)(v15 + 200) = v22;
    *(_QWORD *)(v15 + 208) = v23;
    v43 = 0uLL;
    v42 = 0;
    *(_QWORD *)(v15 + 224) = v24;
    v45 = 0;
    v44 = 2;
    *(_DWORD *)(v15 + 216) = 1;
  }
  v46 = v30;
  *(_QWORD *)(v15 + 232) = v19;
  *(_QWORD *)(v15 + 240) = a4;
  re::Optional<re::internal::AssetLoadItem::DescriptorSource>::~Optional((uint64_t)&v41);
  if (*((_QWORD *)&v39 + 1))
  {

    *((_QWORD *)&v39 + 1) = 0;
  }
  re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)&v36);
  if (a5[2])
  {
    v31 = a5[4];
    v32 = (*(_BYTE *)(v31 + 8) & 1) != 0 ? *(const char **)(v31 + 16) : (const char *)(v31 + 9);
    ProviderForScheme = re::AssetProviderRegistry::tryGetProviderForScheme(*(os_unfair_lock_s **)(a1 + 336), v32);
    if (ProviderForScheme)
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)ProviderForScheme + 72))(ProviderForScheme, v31, v15 + 32);
  }
  v34 = *(_QWORD *)(v15 + 40);
  if ((v34 & 1) != 0)
    v35 = v34 >> 1;
  else
    v35 = v34 >> 1;
  if (!v35)
  {
    re::DynamicString::format((re::DynamicString *)"#%llu", (re::DynamicString *)&v41, a4);
    re::DynamicString::operator=((re::DynamicString *)(v15 + 32), (re::DynamicString *)&v41);
    if (v41)
    {
      if ((v42 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v41 + 40))();
    }
  }
  re::internal::AssetBackgroundLoader::queueOrStartBackgroundTask((os_unfair_lock_s *)a1, (std::chrono::system_clock::time_point *)v15, "load", 0);
}

void re::internal::AssetBackgroundLoader::loadAssetAsync(re::internal::AssetBackgroundLoader *this@<X0>, void *a2@<X1>, const re::AssetType *a3@<X2>, const re::AssetPath *a4@<X3>, re::internal::AssetLoadItem **a5@<X8>)
{
  uint64_t *v10;
  uint64_t v11;
  re::internal::AssetLoadItem *Item;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  __int128 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  v10 = re::globalAllocators(this);
  v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10[2] + 32))(v10[2], 440, 8);
  Item = re::internal::AssetLoadItem::AssetLoadItem((re::internal::AssetLoadItem *)v11);
  *a5 = Item;
  *((_QWORD *)Item + 3) = a2;
  *((_QWORD *)Item + 8) = a3;
  *((_QWORD *)Item + 12) = 0;
  *((_DWORD *)Item + 34) = 0;
  v13 = *((_QWORD *)this + 42);
  *((_QWORD *)Item + 9) = *((_QWORD *)this + 40);
  *((_QWORD *)Item + 10) = 0;
  *((_QWORD *)Item + 11) = v13;
  v18 = *(_DWORD *)a4;
  re::DynamicString::DynamicString((re::DynamicString *)&v19, (const re::AssetPath *)((char *)a4 + 8));
  re::DynamicString::DynamicString((re::DynamicString *)&v22, (const re::AssetPath *)((char *)a4 + 40));
  v14 = *((_QWORD *)this + 41);
  v24 = *((_QWORD *)a4 + 9);
  v25 = v14;
  LOBYTE(v26) = 1;
  LODWORD(v27) = v18;
  v28 = v19;
  v15 = v21;
  v29 = v20;
  v21 = 0;
  v19 = 0;
  v20 = 0uLL;
  v30 = v15;
  v31 = v22;
  v16 = *((_QWORD *)&v23 + 1);
  v32 = v23;
  v23 = 0uLL;
  v22 = 0uLL;
  v33 = v16;
  v34 = v24;
  v35 = v14;
  re::Optional<re::internal::AssetLoadItem::LegacySource>::operator=(v11 + 248, (unsigned __int8 *)&v26);
  re::Optional<re::AssetPath>::~Optional((uint64_t)&v26);
  if ((_QWORD)v22)
  {
    if ((BYTE8(v22) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v22 + 40))();
    v22 = 0u;
    v23 = 0u;
  }
  if (v19 && (v20 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v19 + 40))();
  v17 = *((_QWORD *)a4 + 1);
  v28 = 0;
  *(_QWORD *)&v29 = 0;
  v26 = v17;
  v27 = 0;
  re::DynamicString::setCapacity(&v26, 0);
  re::AssetPath::fullAssetPath(a4, (re::DynamicString *)&v26);
  re::DynamicString::operator=((re::DynamicString *)(v11 + 32), (re::DynamicString *)&v26);
  if (v26 && (v27 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v26 + 40))();
  re::internal::AssetBackgroundLoader::queueOrStartBackgroundTask((os_unfair_lock_s *)this, (std::chrono::system_clock::time_point *)v11, "load", 0);
}

uint64_t re::Optional<re::internal::AssetLoadItem::LegacySource>::operator=(uint64_t a1, unsigned __int8 *a2)
{
  int v3;
  BOOL v4;
  BOOL v5;
  BOOL v7;
  uint64_t v8;
  _OWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v3 = *a2;
  if (*(_BYTE *)a1)
    v4 = 0;
  else
    v4 = v3 == 0;
  if (!v4)
  {
    if (*(_BYTE *)a1)
      v5 = v3 == 0;
    else
      v5 = 0;
    if (v5)
    {
      v9 = (_OWORD *)(a1 + 48);
      v8 = *(_QWORD *)(a1 + 48);
      if (v8)
      {
        if ((*(_BYTE *)(a1 + 56) & 1) != 0)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *(_QWORD *)(a1 + 64));
        *v9 = 0u;
        *(_OWORD *)(a1 + 64) = 0u;
      }
      v10 = *(_QWORD *)(a1 + 16);
      if (v10)
      {
        if ((*(_BYTE *)(a1 + 24) & 1) != 0)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 40))(v10, *(_QWORD *)(a1 + 32));
        *(_OWORD *)(a1 + 16) = 0u;
        *(_OWORD *)(a1 + 32) = 0u;
      }
      *(_BYTE *)a1 = 0;
    }
    else
    {
      if (*(_BYTE *)a1)
        v7 = 1;
      else
        v7 = v3 == 0;
      if (v7)
      {
        *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
        re::DynamicString::operator=((re::DynamicString *)(a1 + 16), (re::DynamicString *)(a2 + 16));
        re::DynamicString::operator=((re::DynamicString *)(a1 + 48), (re::DynamicString *)(a2 + 48));
      }
      else
      {
        *(_BYTE *)a1 = 1;
        *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
        *(_OWORD *)(a1 + 16) = 0u;
        *(_OWORD *)(a1 + 32) = 0u;
        *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 5);
        v11 = *((_QWORD *)a2 + 3);
        *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
        *((_QWORD *)a2 + 2) = 0;
        v12 = *((_QWORD *)a2 + 4);
        *((_QWORD *)a2 + 5) = 0;
        v14 = *(_QWORD *)(a1 + 24);
        v13 = *(_QWORD *)(a1 + 32);
        *(_QWORD *)(a1 + 24) = v11;
        *(_QWORD *)(a1 + 32) = v12;
        *((_QWORD *)a2 + 3) = v14;
        *((_QWORD *)a2 + 4) = v13;
        *(_OWORD *)(a1 + 48) = 0u;
        *(_OWORD *)(a1 + 64) = 0u;
        *(_QWORD *)(a1 + 72) = *((_QWORD *)a2 + 9);
        v15 = *((_QWORD *)a2 + 7);
        *(_QWORD *)(a1 + 48) = *((_QWORD *)a2 + 6);
        *((_QWORD *)a2 + 6) = 0;
        v16 = *((_QWORD *)a2 + 8);
        *((_QWORD *)a2 + 9) = 0;
        v18 = *(_QWORD *)(a1 + 56);
        v17 = *(_QWORD *)(a1 + 64);
        *(_QWORD *)(a1 + 56) = v15;
        *(_QWORD *)(a1 + 64) = v16;
        *((_QWORD *)a2 + 7) = v18;
        *((_QWORD *)a2 + 8) = v17;
      }
      *(_OWORD *)(a1 + 80) = *((_OWORD *)a2 + 5);
    }
  }
  return a1;
}

void re::internal::AssetBackgroundLoader::unloadAssetAsync(re::internal::AssetBackgroundLoader *this@<X0>, void *a2@<X1>, const re::AssetType *a3@<X2>, void *a4@<X3>, const char *a5@<X4>, re::internal::AssetLoadItem **a6@<X8>)
{
  uint64_t *v12;
  re::internal::AssetLoadItem *v13;
  re::internal::AssetLoadItem *Item;
  uint64_t v15;
  re::DynamicString *v16;
  _QWORD v17[2];

  v12 = re::globalAllocators(this);
  v13 = (re::internal::AssetLoadItem *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12[2] + 32))(v12[2], 440, 8);
  Item = re::internal::AssetLoadItem::AssetLoadItem(v13);
  *a6 = Item;
  *((_QWORD *)Item + 3) = a2;
  *((_QWORD *)Item + 8) = a3;
  *((_QWORD *)Item + 12) = a4;
  *((_DWORD *)Item + 34) = 1;
  v15 = *((_QWORD *)this + 42);
  *((_QWORD *)Item + 9) = *((_QWORD *)this + 40);
  *((_QWORD *)Item + 10) = 0;
  *((_QWORD *)Item + 11) = v15;
  v16 = (re::internal::AssetLoadItem *)((char *)Item + 32);
  v17[0] = a5;
  v17[1] = strlen(a5);
  re::DynamicString::operator=(v16, (uint64_t)v17);
  re::internal::AssetBackgroundLoader::queueOrStartBackgroundTask((os_unfair_lock_s *)this, (std::chrono::system_clock::time_point *)v13, "unload", 0);
}

unsigned __int8 *re::internal::AssetLoadItem::setFailure(re::internal::AssetLoadItem *this, const re::DynamicString *a2)
{
  unsigned __int8 *result;
  uint64_t v4;
  uint64_t v5;
  char v6;

  LOBYTE(v4) = 1;
  re::DynamicString::DynamicString((re::DynamicString *)&v5, a2);
  result = re::Optional<re::DynamicString>::operator=((unsigned __int8 *)this + 144, &v4);
  if ((_BYTE)v4)
  {
    result = (unsigned __int8 *)v5;
    if (v5)
    {
      if ((v6 & 1) != 0)
        result = (unsigned __int8 *)(*(uint64_t (**)(void))(*(_QWORD *)v5 + 40))();
    }
  }
  *((_DWORD *)this + 34) = 3;
  return result;
}

uint64_t re::Queue<re::internal::AssetLoadItem *>::dequeue(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 24);
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * v3);
    if ((unint64_t)(v3 + 1) < *(_QWORD *)(a1 + 8))
      v5 = v3 + 1;
    else
      v5 = 0;
    *(_QWORD *)(a1 + 16) = v2 - 1;
    *(_QWORD *)(a1 + 24) = v5;
    ++*(_DWORD *)(a1 + 32);
    return v4;
  }
  else
  {
    re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Queue<T> is empty", "m_size > 0", "dequeue", 569);
    result = _os_crash();
    __break(1u);
  }
  return result;
}

uint64_t re::internal::AssetBackgroundLoader::tryGetLoadItemResult(uint64_t a1, uint64_t a2)
{
  int v2;
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t *v6;
  std::chrono::system_clock::time_point v7;
  uint64_t v8;
  uint64_t v9;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep rep;
  uint64_t v11;
  BOOL v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  uint64_t v30;

  v2 = a2;
  v30 = *MEMORY[0x24BDAC8D0];
  v4 = (os_unfair_lock_s *)(a1 + 360);
  if ((_DWORD)a2 == 1)
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 360));
  if (*(_QWORD *)(a1 + 280))
  {
    v5 = re::Queue<re::internal::AssetLoadItem *>::dequeue(a1 + 264, a2);
  }
  else
  {
    if (*(_QWORD *)(a1 + 216))
    {
      v6 = *(uint64_t **)(a1 + 232);
      v7.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
      v8 = *(_QWORD *)(a1 + 232);
      v9 = *(_QWORD *)(a1 + 216);
      if (v6 != (uint64_t *)(v8 + 8 * v9))
      {
        rep = v7.__d_.__rep_;
        do
        {
          v11 = rep - *(_QWORD *)(*v6 + 424);
          if (*(_BYTE *)(*v6 + 432))
            v12 = 1;
          else
            v12 = v11 < 1001000;
          if (!v12)
          {
            v13 = *re::assetsLogObjects((re *)v7.__d_.__rep_);
            v7.__d_.__rep_ = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
            if (LODWORD(v7.__d_.__rep_))
            {
              v14 = *v6;
              if ((*(_BYTE *)(*v6 + 40) & 1) != 0)
                v15 = *(_QWORD *)(v14 + 48);
              else
                v15 = v14 + 41;
              v16 = *(_QWORD *)(a1 + 88);
              v17 = *(_QWORD *)(a1 + 216);
              v18 = *(_QWORD *)(a1 + 280);
              *(_DWORD *)buf = 136316162;
              v21 = v15;
              v22 = 2048;
              v23 = v11 / 1000;
              v24 = 2048;
              v25 = v16;
              v26 = 2048;
              v27 = v17;
              v28 = 2048;
              v29 = v18;
              _os_log_impl(&dword_224FE9000, v13, OS_LOG_TYPE_DEFAULT, "Asset '%s' has been in active state in Asset Background Loader for '%lld' ms.\nPending: %zu, Active: %zu, Done: %zu", buf, 0x34u);
            }
            *(_BYTE *)(*v6 + 432) = 1;
            v8 = *(_QWORD *)(a1 + 232);
            v9 = *(_QWORD *)(a1 + 216);
          }
          ++v6;
        }
        while (v6 != (uint64_t *)(v8 + 8 * v9));
      }
    }
    v5 = 0;
  }
  if (v2 == 1)
    os_unfair_lock_unlock(v4);
  return v5;
}

void re::internal::AssetBackgroundLoader::assetLoadItemFree(uint64_t a1, uint64_t a2)
{
  id v3;
  uint64_t v4;

  if (a2)
    v3 = (id)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 384);
  if (v4)
  {

    *(_QWORD *)(a2 + 384) = 0;
  }

}

void re::internal::AssetBackgroundLoader::waitForActiveLoadItemsToComplete(re::internal::AssetBackgroundLoader *this)
{
  os_unfair_lock_s *i;
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;

  for (i = (os_unfair_lock_s *)*((_QWORD *)this + 24); ; i = (os_unfair_lock_s *)*((_QWORD *)this + 24))
  {
    os_unfair_lock_lock(i);
    if (!*((_QWORD *)this + 27))
      break;
    v3 = (os_unfair_lock_s *)**((_QWORD **)this + 29);
    if (!v3)
      break;
    v4 = &v3[2];
    os_unfair_lock_unlock(*((os_unfair_lock_t *)this + 24));
    re::internal::AssetBackgroundLoader::runIfNeeded(this, v3);

  }
  os_unfair_lock_unlock(*((os_unfair_lock_t *)this + 24));
}

void re::internal::AssetBackgroundLoader::loadNow(os_unfair_lock_s *this, re::internal::AssetLoadItem *a2, int a3)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  std::chrono::system_clock::time_point v13;
  std::chrono::duration<long long, std::ratio<1, 1000000>>::rep v14;
  NSObject *v15;
  char *v16;
  _BYTE v17[12];
  __int16 v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v6 = this + 90;
  if (a3 == 1)
    os_unfair_lock_lock(this + 90);
  v7 = *(_QWORD *)&this[38]._os_unfair_lock_opaque;
  if (v7)
  {
    v8 = 0;
LABEL_5:
    v9 = 1 - v7;
    do
    {
      *(_QWORD *)v17 = re::Queue<re::internal::AssetLoadItem *>::dequeue((uint64_t)&this[34], (uint64_t)a2);
      if (*(re::internal::AssetLoadItem **)v17 == a2)
      {
        v7 = -v9;
        v8 = 1;
        if (v9)
          goto LABEL_5;
        goto LABEL_21;
      }
      re::Queue<re::internal::AssetLoadItem *>::enqueue(&this[34]._os_unfair_lock_opaque, v17);
      ++v9;
    }
    while (v9 != 1);
    if ((v8 & 1) != 0)
      goto LABEL_21;
  }
  v10 = *(_QWORD *)&this[22]._os_unfair_lock_opaque;
  if (v10)
  {
    v11 = 0;
LABEL_14:
    v12 = 1 - v10;
    do
    {
      *(_QWORD *)v17 = re::Queue<re::internal::AssetLoadItem *>::dequeue((uint64_t)&this[18], (uint64_t)a2);
      if (*(re::internal::AssetLoadItem **)v17 == a2)
      {
        v10 = -v12;
        v11 = 1;
        if (v12)
          goto LABEL_14;
        goto LABEL_21;
      }
      re::Queue<re::internal::AssetLoadItem *>::enqueue(&this[18]._os_unfair_lock_opaque, v17);
      ++v12;
    }
    while (v12 != 1);
    if ((v11 & 1) == 0)
      goto LABEL_28;
LABEL_21:
    v13.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
    v14 = v13.__d_.__rep_ - *((_QWORD *)a2 + 52);
    if (v14 >= 300000)
    {
      v15 = *re::assetsLogObjects((re *)v13.__d_.__rep_);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        if ((*((_BYTE *)a2 + 40) & 1) != 0)
          v16 = (char *)*((_QWORD *)a2 + 6);
        else
          v16 = (char *)a2 + 41;
        *(_DWORD *)v17 = 136315394;
        *(_QWORD *)&v17[4] = v16;
        v18 = 2048;
        v19 = v14 / 1000;
        _os_log_impl(&dword_224FE9000, v15, OS_LOG_TYPE_DEFAULT, "Asset '%s' has been in pending state in Asset Background Loader for '%lld' ms, started loading now via loadNow", v17, 0x16u);
      }
    }
    re::internal::AssetBackgroundLoader::prepareBackgroundTask((uint64_t)this, (uint64_t)a2, 0);
  }
LABEL_28:
  if (a3 == 1)
    os_unfair_lock_unlock(v6);
  re::internal::AssetBackgroundLoader::runIfNeeded((re::internal::AssetBackgroundLoader *)this, (os_unfair_lock_s *)a2);
}

uint64_t re::Optional<re::internal::AssetLoadItem::DescriptorSource>::~Optional(uint64_t a1)
{
  uint64_t v2;

  if (*(_BYTE *)a1)
  {
    v2 = *(_QWORD *)(a1 + 48);
    if (v2)
    {

      *(_QWORD *)(a1 + 48) = 0;
    }
    re::DynamicArray<re::AssetLoadDescriptor>::deinit(a1 + 8);
  }
  return a1;
}

uint64_t re::Optional<re::internal::AssetLoadItem::PayloadSource>::~Optional(uint64_t a1)
{
  uint64_t v2;

  if (*(_BYTE *)a1)
  {
    v2 = *(_QWORD *)(a1 + 24);
    if (v2)
    {

      *(_QWORD *)(a1 + 24) = 0;
    }

  }
  return a1;
}

_QWORD *re::Queue<re::internal::AssetLoadItem *>::growCapacity(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  BOOL v6;
  unint64_t v7;

  v2 = this[1];
  if (v2 < a2)
  {
    v3 = a2;
    v4 = this;
    if (*this)
    {
      v5 = 2 * v2;
      v6 = v2 == 0;
      v7 = 8;
      if (!v6)
        v7 = v5;
      if (v7 > a2)
        a2 = v7;
      return re::Queue<re::internal::AssetLoadItem *>::setCapacity(this, a2);
    }
    else
    {
      this = re::Queue<re::internal::AssetLoadItem *>::setCapacity(v4, v3);
      v4[2] = 0;
      v4[3] = 0;
      *((_DWORD *)v4 + 8) = 0;
    }
  }
  return this;
}

_QWORD *re::Queue<re::internal::AssetLoadItem *>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    v6 = result + 2;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::Queue<re::internal::AssetLoadItem *>::setCapacity(v5, a2);
        *v6 = 0;
        v6[1] = 0;
        *((_DWORD *)v6 + 4) = 0;
        return result;
      }
      if (a2)
      {
        if (a2 >> 61)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in Queue<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 440, 8, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = 8 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 8 * a2, 8);
          if (result)
          {
            v8 = result;
            v3 = v5[1];
            if (!v3)
              goto LABEL_18;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v7, "assertion failure: '%s' (%s:line %i) Queue<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 444, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v8 = 0;
      if (!v3)
      {
LABEL_18:
        v5[5] = v8;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v9 = v5[2];
      if (v9)
      {
        v10 = v5[3];
        v11 = v10;
        do
        {
          v8[v11] = *(_QWORD *)(v5[5] + 8 * (v10 % v3));
          if (v11 + 1 < a2)
            ++v11;
          else
            v11 = 0;
          ++v10;
          --v9;
        }
        while (v9);
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v5 + 40))(*v5, v5[5]);
      goto LABEL_18;
    }
  }
  return result;
}

double re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data,unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  double result;

  v2 = *a1;
  if (v2)
  {
    if (*((_DWORD *)a1 + 8))
    {
      v3 = 0;
      v4 = 0;
      do
      {
        re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data,unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(a1[2] + v3);
        ++v4;
        v3 += 88;
      }
      while (v4 < *((unsigned int *)a1 + 8));
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

uint64_t re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data,unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(uint64_t result)
{
  int v1;
  uint64_t v2;
  _OWORD *v3;
  uint64_t v4;
  char v5;

  v1 = *(_DWORD *)(result + 8);
  if (v1 < 0)
  {
    v2 = result;
    v3 = (_OWORD *)(result + 16);
    result = *(_QWORD *)(result + 16);
    *((_DWORD *)v3 - 2) = v1 & 0x7FFFFFFF;
    if (result)
    {
      if ((*(_BYTE *)(v2 + 24) & 1) != 0)
        result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 40))(result, *(_QWORD *)(v2 + 32));
      *v3 = 0u;
      v3[1] = 0u;
    }
    v4 = *(unsigned int *)(v2 + 80);
    if ((_DWORD)v4 != -1)
      result = ((uint64_t (*)(char *, uint64_t))off_24ED2CD50[v4])(&v5, v2 + 48);
    *(_DWORD *)(v2 + 80) = -1;
  }
  return result;
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2re13DynamicStringENS8_4DataEmEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSC_1EJS9_SA_mEEEEEEDcSE_DpT0_(uint64_t a1, _QWORD *a2)
{
  double result;

  if (*a2)
  {
    if ((a2[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a2 + 40))(*a2, a2[2]);
    result = 0.0;
    *(_OWORD *)a2 = 0u;
    *((_OWORD *)a2 + 1) = 0u;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2re13DynamicStringENS8_4DataEmEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSC_1EJS9_SA_mEEEEEEDcSE_DpT0_(uint64_t a1, id *a2)
{

}

void re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data,unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  __int128 v8;
  unsigned int v9;
  uint64_t v10;
  unint64_t v11;
  signed int v12;
  _BYTE v13[44];

  v4 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    if (a2 && *(_DWORD *)(a1 + 24) != a2 && *(_DWORD *)(a1 + 28) <= a2)
    {
      memset(v13, 0, 36);
      *(_QWORD *)&v13[36] = 0x7FFFFFFFLL;
      re::HashTable<re::StringID,re::RigDataTypeClass,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v13, v4, a2);
      v5 = *(_OWORD *)v13;
      *(_OWORD *)v13 = *(_OWORD *)a1;
      *(_OWORD *)a1 = v5;
      v6 = *(_QWORD *)&v13[16];
      *(_QWORD *)&v13[16] = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 16) = v6;
      v8 = *(_OWORD *)&v13[24];
      *(_OWORD *)&v13[24] = *(_OWORD *)(a1 + 24);
      v7 = *(_DWORD *)&v13[32];
      *(_OWORD *)(a1 + 24) = v8;
      v9 = v7;
      if (v7)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          if ((*(_DWORD *)(*(_QWORD *)&v13[16] + v10 + 8) & 0x80000000) != 0)
          {
            re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data,unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(_QWORD *)(*(_QWORD *)&v13[16] + v10) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(*(_QWORD *)&v13[16] + v10), (re::DynamicString *)(*(_QWORD *)&v13[16] + v10 + 16), *(_QWORD *)&v13[16] + v10 + 48);
            v9 = *(_DWORD *)&v13[32];
          }
          ++v11;
          v10 += 88;
        }
        while (v11 < v9);
      }
      re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data,unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v13);
    }
  }
  else
  {
    if (a2)
      v12 = a2;
    else
      v12 = 3;
  }
}

uint64_t re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data,unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, re::DynamicString *a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      re::HashTable<re::DynamicString,std::variant<re::DynamicString,re::Data,unsigned long>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(a1, (2 * *(_DWORD *)(a1 + 28)));
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
    v13 = *(_DWORD *)(v12 + 88 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v13 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v12 + 88 * v10 + 8) = v13 | 0x80000000;
  v14 = 88 * v10;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + v14 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v14) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + v14 + 16), a4);
  v15 = *(_QWORD *)(a1 + 16) + 88 * v10;
  *(_BYTE *)(v15 + 48) = 0;
  v15 += 48;
  *(_DWORD *)(v15 + 32) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<re::DynamicString,re::Data,unsigned long>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<re::DynamicString,re::Data,unsigned long>,(std::__variant_detail::_Trait)1>>(v15, a5);
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<re::DynamicString,re::Data,unsigned long>>::__generic_construct[abi:nn180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<re::DynamicString,re::Data,unsigned long>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  char v7;

  v3 = result;
  v4 = *(unsigned int *)(result + 32);
  if ((_DWORD)v4 != -1)
    result = ((uint64_t (*)(char *, uint64_t))off_24ED2CD50[v4])(&v7, result);
  *(_DWORD *)(v3 + 32) = -1;
  v5 = *(unsigned int *)(a2 + 32);
  if ((_DWORD)v5 != -1)
  {
    result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_24ED2CD68[v5])(&v6, v3, a2);
    *(_DWORD *)(v3 + 32) = v5;
  }
  return result;
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re13DynamicStringENS8_4DataEmEEEE19__generic_constructB8nn180100INS0_18__move_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSI_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_mEEEOSQ_EEEDcSI_DpT0_(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  double result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  result = 0.0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_QWORD *)(a2 + 24) = a3[3];
  v4 = a3[1];
  *(_QWORD *)a2 = *a3;
  *a3 = 0;
  v5 = a3[2];
  a3[3] = 0;
  v7 = *(_QWORD *)(a2 + 8);
  v6 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a2 + 8) = v4;
  *(_QWORD *)(a2 + 16) = v5;
  a3[1] = v7;
  a3[2] = v6;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re13DynamicStringENS8_4DataEmEEEE19__generic_constructB8nn180100INS0_18__move_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSI_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_mEEEOSQ_EEEDcSI_DpT0_(uint64_t a1, _QWORD *a2, uint64_t *a3)
{
  uint64_t v3;

  v3 = *a3;
  *a3 = 0;
  *a2 = v3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJN2re13DynamicStringENS8_4DataEmEEEE19__generic_constructB8nn180100INS0_18__move_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSI_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_mEEEOSQ_EEEDcSI_DpT0_(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

uint64_t *re::allocInfo_AssetService(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_40);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_40))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FB788, 0);
    *(uint64_t *)((char *)&qword_2540FB798 + 6) = 0;
    qword_2540FB798 = 0;
    qword_2540FB7A8 = 0;
    qword_2540FB7B0 = 0xFFFFFFFFLL;
    qword_2540FB788 = (uint64_t)&off_24ED7DAA8;
    qword_2540FB7B8 = (uint64_t)"AssetService";
    dword_2540FB7C0 = 0;
    unk_2540FB7C8 = 0u;
    unk_2540FB7D8 = 0u;
    unk_2540FB7E8 = 0u;
    qword_2540FB7F8 = 0;
    __cxa_guard_release(&_MergedGlobals_40);
  }
  return &qword_2540FB788;
}

void re::initInfo_AssetService(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x308AF415FCB3338ALL;
  v5[1] = "AssetService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_AssetService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_AssetService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"AssetService", (uint64_t (*)(re::internal *))re::allocInfo_AssetService, (re::IntrospectionBase *(*)(void))re::initInfo_AssetService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::AssetService>, this);
}

re::RealityArchiveWriter *re::RealityArchiveWriter::RealityArchiveWriter(re::RealityArchiveWriter *this)
{
  _anonymous_namespace_ *v2;

  ArcSharedObject::ArcSharedObject(this, 0);
  *(_QWORD *)this = &off_24ED2CD90;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_QWORD *)this + 7) = 0;
  re::DynamicString::setCapacity((_QWORD *)this + 4, 0);
  *((_DWORD *)this + 16) = 1;
  return this;
}

void re::RealityArchiveWriter::~RealityArchiveWriter(re::RealityArchiveWriter *this)
{
  uint64_t v2;
  _OWORD *v3;
  _QWORD *v4;

  *(_QWORD *)this = &off_24ED2CD90;
  v3 = (_OWORD *)((char *)this + 32);
  v2 = *((_QWORD *)this + 4);
  if (v2)
  {
    if ((*((_BYTE *)this + 40) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *((_QWORD *)this + 6));
    *v3 = 0u;
    v3[1] = 0u;
  }
  v4 = (_QWORD *)*((_QWORD *)this + 3);
  if (v4)
  {
    zip_close(v4);
    *((_QWORD *)this + 3) = 0;
  }
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  re::RealityArchiveWriter::~RealityArchiveWriter(this);
  JUMPOUT(0x2276933B8);
}

uint64_t re::RealityArchiveWriter::open@<X0>(re::RealityArchiveWriter *this@<X0>, re *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t result;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;

  if (*((_QWORD *)this + 3))
  {
  }
  else if (re::ensureFolderExistsForFile(a2, (const char *)a2))
  {
    if (!*((_QWORD *)this + 3))
    {
      zip_file_create((const char *)a2);
      *((_QWORD *)this + 3) = v10;
      if (v10)
      {
        *(_QWORD *)(v10 + 104) = 4096;
        *(_QWORD *)&v11 = a2;
        *((_QWORD *)&v11 + 1) = strlen((const char *)a2);
        result = (uint64_t)re::DynamicString::operator=((re::RealityArchiveWriter *)((char *)this + 32), (uint64_t)&v11);
        *(_BYTE *)a3 = 1;
        return result;
      }
    }
    result = re::DynamicString::format((re::DynamicString *)"Failed to open reality archive for writing at path '%s'.", (re::DynamicString *)&v11, a2);
  }
  else
  {
    result = re::DynamicString::format((re::DynamicString *)"Could not create parent folders for file path %s.", (re::DynamicString *)&v11, a2);
  }
  v7 = v11;
  v8 = v12;
  v9 = v13;
  *(_BYTE *)a3 = 0;
  *(_OWORD *)(a3 + 8) = v7;
  *(_QWORD *)(a3 + 24) = v8;
  *(_QWORD *)(a3 + 32) = v9;
  return result;
}

uint64_t re::RealityArchiveWriter::getCompressionMethod(re::RealityArchiveWriter *this, uint64_t a2)
{
  unsigned int v2;
  uint64_t result;

  v2 = *((_DWORD *)this + 16);
  if (v2 < 3)
    return (0x20301u >> (8 * v2)) & 3;
  re::internal::assertLog((re::internal *)4, a2, "assertion failure: '%s' (%s:line %i) Unknown compression method set", "!\"Unreachable code\"", "convertToArchiveCompression", 47);
  result = _os_crash();
  __break(1u);
  return result;
}

__n128 re::RealityArchiveWriter::writeEntry@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, const __CFData *a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  _QWORD *v7;
  unint64_t v10;
  _WORD *entry;
  uint64_t v12;
  uint64_t v13;
  CFIndex Length;
  Bytef *BytePtr;
  __n128 result;
  __n128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __n128 v22;
  uint64_t v23;
  uint64_t v24;

  v7 = *(_QWORD **)(a1 + 24);
  if (v7)
  {
    if (a4 == 3)
    {
      LOWORD(v10) = 8;
    }
    else if (a4 == 2)
    {
      LOWORD(v10) = 99;
    }
    else if (a4)
    {
      LOWORD(v10) = 0;
    }
    else
    {
      v10 = 0xE006300630008uLL >> (16 * (*(_BYTE *)(a1 + 64) - 1));
      if ((*(_DWORD *)(a1 + 64) - 1) >= 4)
        LOWORD(v10) = 0;
    }
    entry = (_WORD *)zip_create_entry(v7, a2, v10);
    if (entry)
    {
      v12 = zip_entry_save_data_begin(entry);
      if (v12)
      {
        v13 = v12;
        Length = CFDataGetLength(a3);
        BytePtr = (Bytef *)CFDataGetBytePtr(a3);
        if (zip_entry_save_data_write(BytePtr, Length, v13) != Length)
        {
          re::DynamicString::format((re::DynamicString *)"Failed to write data to entry '%s'.", (re::DynamicString *)&v22, a2);
          v17 = v22;
          v18 = v23;
          v19 = v24;
          *(_BYTE *)a5 = 0;
          *(__n128 *)(a5 + 8) = v17;
          *(_QWORD *)(a5 + 24) = v18;
          *(_QWORD *)(a5 + 32) = v19;
          zip_entry_save_data_end(v13);
          return result;
        }
        if ((zip_entry_save_data_end(v13) & 1) != 0)
        {
          *(_BYTE *)a5 = 1;
          return result;
        }
        re::DynamicString::format((re::DynamicString *)"Failed to finalize write of entry '%s'.", (re::DynamicString *)&v22, a2);
      }
      else
      {
        re::DynamicString::format((re::DynamicString *)"Failed to initialize entry '%s' for writing.", (re::DynamicString *)&v22, a2);
      }
    }
    else
    {
      re::DynamicString::format((re::DynamicString *)"Failed to create archive entry named '%s'.", (re::DynamicString *)&v22, a2);
    }
  }
  else
  {
  }
  result = v22;
  v20 = v23;
  v21 = v24;
  *(_BYTE *)a5 = 0;
  *(__n128 *)(a5 + 8) = result;
  *(_QWORD *)(a5 + 24) = v20;
  *(_QWORD *)(a5 + 32) = v21;
  return result;
}

__n128 re::RealityArchiveWriter::close@<Q0>(re::RealityArchiveWriter *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  _QWORD **v5;
  uint64_t v6;
  __n128 result;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  __n128 v14;
  uint64_t v15;
  uint64_t v16;

  v5 = (_QWORD **)((char *)this + 24);
  v4 = *((_QWORD *)this + 3);
  if (!v4)
  {
    v11 = "This RealityArchiveWriter is not opened for writing.";
LABEL_12:
    result = v14;
    v12 = v15;
    v13 = v16;
    *(_BYTE *)a2 = 0;
    *(__n128 *)(a2 + 8) = result;
    *(_QWORD *)(a2 + 24) = v12;
    *(_QWORD *)(a2 + 32) = v13;
    return result;
  }
  v6 = zip_save_manifest(v4, 0, v5, 1uLL);
  if ((v6 & 1) == 0)
  {
    v11 = "Failed to save archive manifest.";
    goto LABEL_12;
  }
  if (*v5)
  {
    v8 = zip_close(*v5);
    *v5 = 0;
    if ((v8 & 1) == 0)
    {
      v11 = "Failed to write and close archive.";
      goto LABEL_12;
    }
  }
  v9 = *((_QWORD *)this + 5);
  if ((v9 & 1) != 0)
  {
    *((_QWORD *)this + 5) = 1;
    v10 = (_BYTE *)*((_QWORD *)this + 6);
  }
  else
  {
    *((_BYTE *)this + 40) = v9 & 1;
    v10 = (char *)this + 41;
  }
  *v10 = 0;
  *(_BYTE *)a2 = 1;
  return result;
}

uint64_t *re::allocInfo_ResourceSharingService(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_41);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_41))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FB808, 0);
    *(uint64_t *)((char *)&qword_2540FB818 + 6) = 0;
    qword_2540FB818 = 0;
    qword_2540FB828 = 0;
    qword_2540FB830 = 0xFFFFFFFFLL;
    qword_2540FB808 = (uint64_t)&off_24ED7DAA8;
    qword_2540FB838 = (uint64_t)"ResourceSharingService";
    dword_2540FB840 = 0;
    unk_2540FB848 = 0u;
    unk_2540FB858 = 0u;
    unk_2540FB868 = 0u;
    qword_2540FB878 = 0;
    __cxa_guard_release(&_MergedGlobals_41);
  }
  return &qword_2540FB808;
}

void re::initInfo_ResourceSharingService(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0xEF2E39053FE8140ELL;
  v5[1] = "ResourceSharingService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_ResourceSharingService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_ResourceSharingService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ResourceSharingService", (uint64_t (*)(re::internal *))re::allocInfo_ResourceSharingService, (re::IntrospectionBase *(*)(void))re::initInfo_ResourceSharingService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ResourceSharingService>, this);
}

uint64_t *re::allocInfo_ResourceFetchService(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_42);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_42))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FB888, 0);
    *(uint64_t *)((char *)&qword_2540FB898 + 6) = 0;
    qword_2540FB898 = 0;
    qword_2540FB8A8 = 0;
    qword_2540FB8B0 = 0xFFFFFFFFLL;
    qword_2540FB888 = (uint64_t)&off_24ED7DAA8;
    qword_2540FB8B8 = (uint64_t)"ResourceFetchService";
    dword_2540FB8C0 = 0;
    unk_2540FB8C8 = 0u;
    unk_2540FB8D8 = 0u;
    unk_2540FB8E8 = 0u;
    qword_2540FB8F8 = 0;
    __cxa_guard_release(&_MergedGlobals_42);
  }
  return &qword_2540FB888;
}

void re::initInfo_ResourceFetchService(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0xB75BF8A4312FB3D2;
  v5[1] = "ResourceFetchService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_ResourceFetchService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_ResourceFetchService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"ResourceFetchService", (uint64_t (*)(re::internal *))re::allocInfo_ResourceFetchService, (re::IntrospectionBase *(*)(void))re::initInfo_ResourceFetchService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::ResourceFetchService>, this);
}

re::AssetPath *re::AssetPath::AssetPath(re::AssetPath *this, re::Allocator *a2)
{
  *(_DWORD *)this = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 1) = a2;
  re::DynamicString::setCapacity((_QWORD *)this + 1, 0);
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = a2;
  re::DynamicString::setCapacity((_QWORD *)this + 5, 0);
  *((_QWORD *)this + 9) = 0;
  return this;
}

uint64_t re::AssetPath::reset(uint64_t this)
{
  uint64_t v1;
  _BYTE *v2;
  uint64_t v3;
  _BYTE *v4;

  *(_DWORD *)this = 0;
  v1 = *(_QWORD *)(this + 16);
  if ((v1 & 1) != 0)
  {
    *(_QWORD *)(this + 16) = 1;
    v2 = *(_BYTE **)(this + 24);
  }
  else
  {
    *(_BYTE *)(this + 16) = v1 & 1;
    v2 = (_BYTE *)(this + 17);
  }
  *v2 = 0;
  v3 = *(_QWORD *)(this + 48);
  if ((v3 & 1) != 0)
  {
    *(_QWORD *)(this + 48) = 1;
    v4 = *(_BYTE **)(this + 56);
  }
  else
  {
    *(_BYTE *)(this + 48) = v3 & 1;
    v4 = (_BYTE *)(this + 49);
  }
  *v4 = 0;
  *(_QWORD *)(this + 72) = 0;
  return this;
}

__n128 re::AssetPath::hadParseError@<Q0>(uint64_t a1@<X0>, const char *a2@<X1>, const char **a3@<X2>, uint64_t a4@<X8>)
{
  _anonymous_namespace_ *v7;
  __n128 result;
  uint64_t v9;
  uint64_t v10;
  __n128 v11;
  uint64_t v12;
  uint64_t v13;

  v7 = (_anonymous_namespace_ *)re::AssetPath::reset(a1);
  v11.n128_u64[1] = 0;
  v12 = 0;
  v13 = 0;
  re::DynamicString::setCapacity(&v11, 0);
  re::DynamicString::appendf((re::DynamicString *)&v11, "Invalid asset path: %s '%s'", a2, *a3);
  result = v11;
  v9 = v12;
  v10 = v13;
  *(_BYTE *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 200;
  *(_QWORD *)(a4 + 16) = &re::AssetErrorCategory(void)::instance;
  *(__n128 *)(a4 + 24) = result;
  *(_QWORD *)(a4 + 40) = v9;
  *(_QWORD *)(a4 + 48) = v10;
  return result;
}

BOOL re::AssetPath::tryParseBuiltInPrefix(re::AssetPath *this, const char *a2, size_t a3, BOOL *a4)
{
  BOOL v8;
  int v9;
  int v10;
  _BOOL8 matched;
  _BOOL8 result;
  const char *v13[2];

  if (!matchPrefix("app", a2, a3))
  {
    if (matchPrefix("framework", a2, a3))
    {
      v9 = 2;
LABEL_5:
      *(_DWORD *)this = v9;
      v8 = 1;
      goto LABEL_19;
    }
    if (matchPrefix("assetId", a2, a3))
    {
      v8 = 0;
      v10 = 8;
    }
    else
    {
      matched = matchPrefix("engine", a2, a3);
      if (matched)
      {
        *(_DWORD *)this = 2;
        v13[0] = re::bundleFrameworkIdentifier((re *)matched);
        v13[1] = (const char *)strlen(v13[0]);
        re::DynamicString::operator=((re::AssetPath *)((char *)this + 8), (uint64_t)v13);
        v8 = 0;
        goto LABEL_19;
      }
      if (matchPrefix("memory", a2, a3))
      {
        v8 = 0;
        v10 = 3;
      }
      else if (matchPrefix("singlefilearchive", a2, a3))
      {
        v8 = 0;
        v10 = 7;
      }
      else
      {
        if (matchPrefix("peer", a2, a3))
        {
          v9 = 4;
          goto LABEL_5;
        }
        result = matchPrefix("sourcepath", a2, a3);
        if (!result)
          return result;
        v8 = 0;
        v10 = 5;
      }
    }
    *(_DWORD *)this = v10;
    goto LABEL_19;
  }
  v8 = 1;
  *(_DWORD *)this = 1;
LABEL_19:
  *a4 = v8;
  return 1;
}

BOOL matchPrefix(const char *a1, const char *a2, size_t a3)
{
  return strlen(a1) == a3 && !memcmp(a2, a1, a3);
}

BOOL re::AssetPath::tryParseExternalPrefix(uint64_t a1, const char *a2, size_t a3, os_unfair_lock_s *a4)
{
  os_unfair_lock_s *v8;
  _BOOL8 v9;
  uint64_t v11;
  char v12;

  v8 = a4 + 16;
  os_unfair_lock_lock(a4 + 16);
  v9 = re::HashTable<re::DynamicString,unsigned long,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::containsKey((uint64_t)&a4[30], (uint64_t)&v11);
  os_unfair_lock_unlock(v8);
  if (v9)
  {
    *(_DWORD *)a1 = 6;
    re::DynamicString::operator=((re::DynamicString *)(a1 + 8), (re::DynamicString *)&v11);
  }
  if (v11 && (v12 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v11 + 40))();
  return v9;
}

BOOL re::AssetPath::tryParseOtherResolverPrefix(re::AssetPath *this, const char *a2, size_t a3, os_unfair_lock_s *a4)
{
  const char *v8;
  uint64_t ProviderForScheme;
  uint64_t v11;
  char v12;
  _BYTE v13[23];

  if ((v12 & 1) != 0)
    v8 = *(const char **)&v13[7];
  else
    v8 = v13;
  ProviderForScheme = re::AssetProviderRegistry::tryGetProviderForScheme(a4, v8);
  if (ProviderForScheme)
  {
    *(_DWORD *)this = 9;
    re::DynamicString::operator=((re::AssetPath *)((char *)this + 8), (re::DynamicString *)&v11);
  }
  if (v11 && (v12 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v11 + 40))();
  return ProviderForScheme != 0;
}

void re::AssetPath::parseRootAndFilePath(char *__s@<X1>, uint64_t a2@<X0>, const char **a3@<X2>, _BYTE *a4@<X8>)
{
  char *v8;
  char *v9;
  char *v10;
  const char *v11;

  v8 = strchr(__s, 47);
  if (!v8)
  {
    v11 = "Missing slash after prefix";
LABEL_8:
    re::AssetPath::hadParseError(a2, v11, a3, (uint64_t)a4);
    return;
  }
  v9 = v8;
  re::DynamicString::assign((re::DynamicString *)(a2 + 8), __s, v8 - __s);
  if ((*(_BYTE *)(a2 + 16) & 1) != 0)
  {
    v10 = *(char **)(a2 + 24);
    if (!v10)
      goto LABEL_9;
  }
  else
  {
    v10 = (char *)(a2 + 17);
  }
  if (strpbrk(v10, ":<>|\"?*"))
  {
    v11 = "Invalid characters in root";
    goto LABEL_8;
  }
LABEL_9:
  re::AssetPath::parseFilePath(v9, a2, (uint64_t)a3, 1, a4);
}

void re::AssetPath::parseFilePath(char *__s@<X1>, uint64_t a2@<X0>, uint64_t a3@<X2>, int a4@<W3>, _BYTE *a5@<X8>)
{
  char *v7;
  char *v10;
  char *v11;
  _anonymous_namespace_ *v12;
  const re::internal::AssetTypeRegistry *v13;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  const char *v17;
  re::AssetPath *v18;
  uint64_t v19;
  int v20;
  const char *ParentDirectory;
  size_t v22;
  size_t v23;
  __n128 v24;
  char *v25;
  int v26;
  int v27;
  char *v28;
  char *v29;
  _QWORD v30[2];
  uint64_t *v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t *v35;
  unint64_t v36;
  char *v37;
  uint64_t v38;

  v7 = __s;
  v10 = strrchr(__s, 46);
  if (!v10)
  {
    re::AssetPath::hadParseError(a2, "Missing asset type suffix", (const char **)a3, (uint64_t)a5);
    return;
  }
  v11 = v10;
  v12 = (_anonymous_namespace_ *)(v10 + 1);
  v36 = 0;
  v37 = 0;
  v38 = 0;
  re::DynamicString::setCapacity(&v35, 0);
  if (!v14)
  {
    v16 = re::internal::AssetTypeRegistry::assetTypeWithExtension(*(re::internal::AssetTypeRegistry **)(a3 + 16), (const char *)v12);
    *(_QWORD *)(a2 + 72) = v16;
    if (!v16)
    {
      v17 = "Unknown asset type suffix";
      goto LABEL_21;
    }
LABEL_9:
    v15 = strlen(v7);
    if (!v7)
      goto LABEL_12;
    goto LABEL_10;
  }
  *(_QWORD *)(a2 + 72) = v14;
  if (!dyld_program_sdk_at_least() || (*(_DWORD *)a2 - 3) < 6)
    goto LABEL_9;
  re::DynamicString::assign((re::DynamicString *)&v35, v7, v11 - v7);
  if ((v36 & 1) != 0)
  {
    v7 = v37;
    v15 = v36 >> 1;
    if (!v37)
      goto LABEL_12;
  }
  else
  {
    v7 = (char *)&v36 + 1;
    v15 = v36 >> 1;
  }
LABEL_10:
  if (strpbrk(v7, ":<>|\"?*") && *(_DWORD *)a2 != 6)
  {
    v17 = "Contains invalid characters in file path";
    goto LABEL_21;
  }
LABEL_12:
  if (!strstr(v7, "//"))
  {
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v18 = (re::AssetPath *)re::DynamicString::setCapacity(&v31, 0);
    if (!v15)
    {
      re::internal::assertLog((re::internal *)6, v19, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
      _os_crash();
      __break(1u);
      return;
    }
    v20 = *v7;
    if (v20 == 47 || a4)
    {
      if (v20 == 47 && *(_DWORD *)a2 != 3 && *(_DWORD *)a2 != 5)
        ++v7;
    }
    else
    {
      ParentDirectory = re::AssetPath::getParentDirectory(v18, *(const re::AssetPath **)(a3 + 8));
      re::DynamicString::append((re::DynamicString *)&v31, ParentDirectory, v22);
      v23 = strlen(v7);
      re::DynamicString::append((re::DynamicString *)&v31, v7, v23);
      if ((v32 & 1) != 0)
      {
        v7 = v33;
        if (!v33)
        {
          v25 = 0;
          goto LABEL_35;
        }
      }
      else
      {
        v7 = (char *)&v32 + 1;
      }
    }
    v25 = v7 - 1;
    do
      v26 = *++v25;
    while (v26 == 47);
LABEL_35:
    v27 = 0;
    do
    {
      if (!v25)
        break;
      v28 = strchr(v25, 47);
      if (!v28)
        break;
      v29 = v28;
      if (v28 - v25 == 2)
      {
        if (!strncmp(v25, "..", 2uLL))
          --v27;
        else
          ++v27;
        if (v27 < 0)
        {
          v24 = re::AssetPath::hadParseError(a2, "Unsupported relative path", (const char **)a3, (uint64_t)a5);
          goto LABEL_51;
        }
      }
      else if (v28 - v25 == 1)
      {
        if (*v25 != 46)
          ++v27;
      }
      else
      {
        ++v27;
      }
      v25 = v29 + 1;
    }
    while (v29[1]);
    v30[0] = v7;
    v30[1] = strlen(v7);
    re::AssetPath::standardizePath(v30, a2 + 40);
    *a5 = 1;
LABEL_51:
    if (v31 && (v32 & 1) != 0)
      (*(void (**)(void))(*v31 + 40))();
    goto LABEL_22;
  }
  v17 = "Paths can't have double slashes";
LABEL_21:
  v24 = re::AssetPath::hadParseError(a2, v17, (const char **)a3, (uint64_t)a5);
LABEL_22:
  if (v35)
  {
    if ((v36 & 1) != 0)
      (*(void (**)(__n128))(*v35 + 40))(v24);
  }
}

const char *re::AssetPath::getParentDirectory(re::AssetPath *this, const re::AssetPath *a2)
{
  const char *v3;
  char *v4;

  if (!a2)
    return "";
  if (*(_DWORD *)a2 == 6)
  {
    v3 = (*((_QWORD *)a2 + 2) & 1) != 0 ? (const char *)*((_QWORD *)a2 + 3) : (char *)a2 + 17;
    if (!strcmp(v3, "invalidResolver"))
      return "i/n/v/a/l/i/d/";
  }
  if ((*((_BYTE *)a2 + 48) & 1) != 0)
    v4 = (char *)*((_QWORD *)a2 + 7);
  else
    v4 = (char *)a2 + 49;
  if (strrchr(v4, 47))
    return v4;
  else
    return "";
}

uint64_t `anonymous namespace'::tryParseCompiledExtension(_anonymous_namespace_ *this, re::internal::AssetTypeRegistry *a2, const re::internal::AssetTypeRegistry *a3)
{
  if (!strncmp("compiled", (const char *)this, 8uLL))
    return re::internal::AssetTypeRegistry::assetTypeWithName(a2, (char *)this + 8);
  else
    return 0;
}

_BYTE *re::AssetPath::standardizePath(_QWORD *a1, uint64_t a2)
{
  _anonymous_namespace_ *v4;
  size_t v5;
  _BYTE *result;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  size_t v11;
  _BYTE *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  _BYTE v21[8];
  uint64_t v22;
  _BYTE v23[8];
  uint64_t v24;
  _QWORD v25[2];

  v4 = *(_anonymous_namespace_ **)a2;
  if (*(_QWORD *)a2)
  {
    if ((*(_BYTE *)(a2 + 8) & 1) != 0)
      v4 = (_anonymous_namespace_ *)(*(uint64_t (**)(_anonymous_namespace_ *, _QWORD))(*(_QWORD *)v4 + 40))(v4, *(_QWORD *)(a2 + 16));
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
  }
  v5 = a1[1] + 1;
  result = re::DynamicString::setCapacity((_QWORD *)a2, v5);
  v25[0] = "/";
  v25[1] = 1;
  if (!a1[1])
    return result;
  v7 = 0;
  while (1)
  {
    result = re::StringSlice::findFirstOf(a1, (uint64_t)v25, v7, (uint64_t)v23);
    v9 = a1[1];
    v10 = v23[0] ? v24 + 1 : a1[1];
    v11 = v10 - v7;
    if (v10 - v7 != 2)
      break;
    if (v9 <= v7)
      goto LABEL_41;
    v12 = (_BYTE *)*a1;
    if (*(_BYTE *)(*a1 + v7) != 46)
      goto LABEL_30;
    v20 = v7 + 1;
    if (v9 <= v7 + 1)
      goto LABEL_43;
    if (v12[v20] != 47)
      goto LABEL_30;
LABEL_31:
    v7 = v10;
    if (v10 >= a1[1])
      return result;
  }
  if (v11 != 3)
  {
    v12 = (_BYTE *)*a1;
LABEL_30:
    result = re::DynamicString::append((re::DynamicString *)a2, &v12[v7], v11);
    goto LABEL_31;
  }
  if (v9 > v7)
  {
    v12 = (_BYTE *)*a1;
    if (*(_BYTE *)(*a1 + v7) != 46)
      goto LABEL_30;
    v13 = v7 + 1;
    if (v9 <= v7 + 1)
      goto LABEL_42;
    if (v12[v13] != 46)
      goto LABEL_30;
    v14 = v7 + 2;
    if (v9 <= v7 + 2)
      goto LABEL_44;
    if (v12[v14] != 47)
      goto LABEL_30;
    v15 = *(_QWORD *)(a2 + 8);
    if ((v15 & 1) != 0)
      v16 = v15 >> 1;
    else
      v16 = v15 >> 1;
    if (v16 >= 2)
    {
      re::DynamicString::rfind(a2, 47, v16 - 2, (uint64_t)v21);
      if (v21[0])
      {
        v18 = v22 + 1;
        v19 = (_QWORD *)a2;
LABEL_38:
        result = re::DynamicString::resize(v19, v18, 0);
        goto LABEL_31;
      }
      if (!a1[1])
        goto LABEL_45;
      v12 = (_BYTE *)*a1;
    }
    v19 = (_QWORD *)a2;
    if (*v12 != 47)
    {
      v18 = 0;
      goto LABEL_38;
    }
    re::DynamicString::resize((_QWORD *)a2, 1uLL, 0);
    result = (_BYTE *)re::DynamicString::operator[](a2, 0);
    *result = 47;
    goto LABEL_31;
  }
  re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, v9);
  _os_crash();
  __break(1u);
LABEL_41:
  re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v7, v9);
  _os_crash();
  __break(1u);
LABEL_42:
  re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v13, v9);
  _os_crash();
  __break(1u);
LABEL_43:
  re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v20, v9);
  _os_crash();
  __break(1u);
LABEL_44:
  re::internal::assertLog((re::internal *)6, v8, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, v14, v9);
  _os_crash();
  __break(1u);
LABEL_45:
  re::internal::assertLog((re::internal *)6, v17, "assertion failure: '%s' (%s:line %i) Index out of range. index = %zu, size = %zu", "index < size()", "operator[]", 251, 0, 0);
  result = (_BYTE *)_os_crash();
  __break(1u);
  return result;
}

BOOL re::AssetPath::putCurrentAppNameInRoot(re::AssetPath *this)
{
  id v2;
  unint64_t v3;
  unint64_t v4;
  _BOOL8 v5;
  uint64_t v7;
  char v8;
  id v9;

  re::Bundle::application(&v9);
  v2 = v9;
  if (v9)
  {
    re::Bundle::ID(&v9, (re::DynamicString *)&v7);
    re::DynamicString::operator=((re::AssetPath *)((char *)this + 8), (re::DynamicString *)&v7);
    if (v7 && (v8 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v7 + 40))();
    v3 = *((_QWORD *)this + 2);
    if ((v3 & 1) != 0)
      v4 = v3 >> 1;
    else
      v4 = v3 >> 1;
    v5 = v4 != 0;
    v2 = v9;
  }
  else
  {
    v5 = 0;
  }

  return v5;
}

double re::AssetPath::parse@<D0>(re::AssetPath *this@<X0>, char *a2@<X1>, const re::AssetPath *a3@<X2>, const re::internal::AssetTypeRegistry *a4@<X3>, os_unfair_lock_s *a5@<X4>, _BYTE *a6@<X8>)
{
  char *v12;
  double result;
  char *v14;
  size_t v15;
  char *v16;
  int v17;
  _BYTE *v18;
  re::AssetPath *v19;
  int v20;
  const char *v21;
  BOOL v22;
  const char *v23[3];

  re::AssetPath::reset((uint64_t)this);
  v23[0] = a2;
  v23[1] = (const char *)a3;
  v23[2] = (const char *)a4;
  v12 = strchr(a2, 58);
  if (!v12)
  {
    if (!*a2)
    {
      *(_DWORD *)this = 0;
      *a6 = 1;
      return result;
    }
    if (!a3)
      goto LABEL_16;
    v17 = *(_DWORD *)a3;
    if (*(_DWORD *)a3 <= 8u)
    {
      if (((1 << v17) & 0x1EE) != 0)
      {
        *(_DWORD *)this = v17;
        re::DynamicString::operator=((re::AssetPath *)((char *)this + 8), (const re::AssetPath *)((char *)a3 + 8));
        goto LABEL_18;
      }
      if (!v17)
      {
LABEL_16:
        if (!re::AssetPath::putCurrentAppNameInRoot(this))
        {
          v21 = "Can't find current app name";
          goto LABEL_22;
        }
        *(_DWORD *)this = 1;
LABEL_18:
        v18 = a6;
        v19 = this;
        v16 = a2;
        v20 = 0;
LABEL_19:
        re::AssetPath::parseFilePath(v16, (uint64_t)v19, (uint64_t)v23, v20, v18);
        return result;
      }
    }
    v21 = "Invalid parent asset path";
    goto LABEL_22;
  }
  v14 = v12;
  v15 = v12 - a2;
  v22 = 0;
  if (re::AssetPath::tryParseBuiltInPrefix(this, a2, v12 - a2, &v22)
    || re::AssetPath::tryParseExternalPrefix((uint64_t)this, a2, v15, a5)
    || re::AssetPath::tryParseOtherResolverPrefix(this, a2, v15, a5))
  {
    v16 = v14 + 1;
    if (v22)
    {
      re::AssetPath::parseRootAndFilePath(v16, (uint64_t)this, v23, a6);
      return result;
    }
    v18 = a6;
    v19 = this;
    v20 = 1;
    goto LABEL_19;
  }
  v21 = "Unknown prefix";
LABEL_22:
  *(_QWORD *)&result = re::AssetPath::hadParseError((uint64_t)this, v21, v23, (uint64_t)a6).n128_u64[0];
  return result;
}

re::DynamicString *re::AssetPath::fullAssetPath(re::DynamicString *this, re::DynamicString *a2)
{
  re::DynamicString *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  const char *v14;
  re::DynamicString *v15;
  size_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  const char *v21;
  unint64_t v22;
  unint64_t v23;
  const char *v24;
  re::DynamicString *v25;
  size_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  const char *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  size_t v38;
  size_t v39;
  const char *v40;
  size_t v41;
  const char *v42;
  size_t v43;
  size_t v44;
  _QWORD v45[2];

  v3 = this;
  switch(*(_DWORD *)this)
  {
    case 0:
      v45[0] = "";
      v45[1] = 0;
      return re::DynamicString::operator=(a2, (uint64_t)v45);
    case 1:
      v9 = *((_QWORD *)this + 2);
      if ((v9 & 1) != 0)
        v10 = v9 >> 1;
      else
        v10 = v9 >> 1;
      v11 = (uint64_t)this + 40;
      v12 = *((_QWORD *)this + 6);
      if ((v12 & 1) != 0)
        v13 = v12 >> 1;
      else
        v13 = v12 >> 1;
      re::DynamicString::setCapacity(a2, v10 + v13 + 7);
      v14 = "app:";
      v15 = a2;
      v16 = 4;
      goto LABEL_25;
    case 2:
      v17 = *((_QWORD *)this + 2);
      if ((v17 & 1) != 0)
        v18 = v17 >> 1;
      else
        v18 = v17 >> 1;
      v11 = (uint64_t)this + 40;
      v19 = *((_QWORD *)this + 6);
      if ((v19 & 1) != 0)
        v20 = v19 >> 1;
      else
        v20 = v19 >> 1;
      re::DynamicString::setCapacity(a2, v18 + v20 + 12);
      v14 = "framework:";
      v15 = a2;
      v16 = 10;
LABEL_25:
      re::DynamicString::append(v15, v14, v16);
      if ((*((_BYTE *)v3 + 16) & 1) != 0)
        v21 = (const char *)*((_QWORD *)v3 + 3);
      else
        v21 = (char *)v3 + 17;
      v39 = strlen(v21);
      re::DynamicString::append(a2, v21, v39);
      re::DynamicString::append(a2, "/", 1uLL);
      if ((*((_BYTE *)v3 + 48) & 1) != 0)
        v40 = (const char *)*((_QWORD *)v3 + 7);
      else
        v40 = (char *)v3 + 49;
      v41 = strlen(v40);
      re::DynamicString::append(a2, v40, v41);
      if ((this & 1) != 0)
        return this;
      re::DynamicString::append(a2, ".", 1uLL);
      v42 = *(const char **)(*((_QWORD *)v3 + 9) + 8);
      goto LABEL_66;
    case 3:
      v22 = *((_QWORD *)this + 6);
      if ((v22 & 1) != 0)
        v23 = v22 >> 1;
      else
        v23 = v22 >> 1;
      re::DynamicString::setCapacity(a2, v23 + 8);
      v24 = "memory:";
      v25 = a2;
      v26 = 7;
      goto LABEL_63;
    case 4:
      v27 = *((_QWORD *)this + 2);
      if ((v27 & 1) != 0)
        v28 = v27 >> 1;
      else
        v28 = v27 >> 1;
      v29 = *((_QWORD *)this + 6);
      if ((v29 & 1) != 0)
        v30 = v29 >> 1;
      else
        v30 = v29 >> 1;
      re::DynamicString::setCapacity(a2, v28 + v30 + 7);
      re::DynamicString::append(a2, "peer:", 5uLL);
      if ((*((_BYTE *)v3 + 16) & 1) != 0)
        v31 = (const char *)*((_QWORD *)v3 + 3);
      else
        v31 = (char *)v3 + 17;
      v43 = strlen(v31);
      re::DynamicString::append(a2, v31, v43);
      v24 = "/";
      goto LABEL_62;
    case 5:
      v32 = *((_QWORD *)this + 6);
      if ((v32 & 1) != 0)
        v33 = v32 >> 1;
      else
        v33 = v32 >> 1;
      re::DynamicString::setCapacity(a2, v33 + 12);
      v24 = "sourcepath:";
      v25 = a2;
      v26 = 11;
      goto LABEL_63;
    case 6:
    case 9:
      v4 = *((_QWORD *)this + 2);
      if ((v4 & 1) != 0)
        v5 = v4 >> 1;
      else
        v5 = v4 >> 1;
      v6 = *((_QWORD *)this + 6);
      if ((v6 & 1) != 0)
        v7 = v6 >> 1;
      else
        v7 = v6 >> 1;
      re::DynamicString::setCapacity(a2, v5 + v7 + 2);
      if ((*((_BYTE *)v3 + 16) & 1) != 0)
        v8 = (const char *)*((_QWORD *)v3 + 3);
      else
        v8 = (char *)v3 + 17;
      v38 = strlen(v8);
      re::DynamicString::append(a2, v8, v38);
      v24 = ":";
LABEL_62:
      v25 = a2;
      v26 = 1;
      goto LABEL_63;
    case 7:
      v34 = *((_QWORD *)this + 6);
      if ((v34 & 1) != 0)
        v35 = v34 >> 1;
      else
        v35 = v34 >> 1;
      re::DynamicString::setCapacity(a2, v35 + 19);
      v24 = "singlefilearchive:";
      v25 = a2;
      v26 = 18;
      goto LABEL_63;
    case 8:
      v36 = *((_QWORD *)this + 6);
      if ((v36 & 1) != 0)
        v37 = v36 >> 1;
      else
        v37 = v36 >> 1;
      re::DynamicString::setCapacity(a2, v37 + 9);
      v24 = "assetId:";
      v25 = a2;
      v26 = 8;
LABEL_63:
      re::DynamicString::append(v25, v24, v26);
      if ((*((_BYTE *)v3 + 48) & 1) != 0)
        v42 = (const char *)*((_QWORD *)v3 + 7);
      else
        v42 = (char *)v3 + 49;
LABEL_66:
      v44 = strlen(v42);
      this = (re::DynamicString *)re::DynamicString::append(a2, v42, v44);
      break;
    default:
      return this;
  }
  return this;
}

re::DynamicString *re::AssetPath::fullAssetPath@<X0>(re::AssetPath *this@<X0>, re::DynamicString *a2@<X8>)
{
  uint64_t v4;

  v4 = *((_QWORD *)this + 1);
  *((_QWORD *)a2 + 2) = 0;
  *((_QWORD *)a2 + 3) = 0;
  *(_QWORD *)a2 = v4;
  *((_QWORD *)a2 + 1) = 0;
  re::DynamicString::setCapacity(a2, 0);
  return re::AssetPath::fullAssetPath(this, a2);
}

re::DynamicString *re::AssetPath::makeRelativeAssetPath@<X0>(re::AssetPath *this@<X0>, const re::AssetPath *a2@<X1>, re::DynamicString *a3@<X8>)
{
  BOOL v6;
  uint64_t v7;
  const char *v10;
  const char *v11;
  _anonymous_namespace_ *v12;
  re::AssetPath *v13;
  size_t v14;
  const char *ParentDirectory;
  size_t v16;
  const char *v17;
  const char *v18;
  const char *v19;
  size_t v20;
  size_t v21;

  v6 = *(_DWORD *)this != *(_DWORD *)a2 || (*(_DWORD *)this | 8) == 8;
  if (v6
    || ((*((_QWORD *)this + 2) & 1) != 0 ? (v10 = (const char *)*((_QWORD *)this + 3)) : (v10 = (char *)this + 17),
        (*((_QWORD *)a2 + 2) & 1) != 0 ? (v11 = (const char *)*((_QWORD *)a2 + 3)) : (v11 = (char *)a2 + 17),
        v12 = (_anonymous_namespace_ *)strcmp(v10, v11),
        (_DWORD)v12))
  {
    v7 = *((_QWORD *)a2 + 1);
    *((_QWORD *)a3 + 2) = 0;
    *((_QWORD *)a3 + 3) = 0;
    *(_QWORD *)a3 = v7;
    *((_QWORD *)a3 + 1) = 0;
    re::DynamicString::setCapacity(a3, 0);
    return re::AssetPath::fullAssetPath(a2, a3);
  }
  else
  {
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
    v13 = (re::AssetPath *)re::DynamicString::setCapacity(a3, 0);
    ParentDirectory = re::AssetPath::getParentDirectory(v13, this);
    v16 = v14;
    v17 = *(const char **)(*((_QWORD *)a2 + 9) + 8);
    if ((*((_BYTE *)a2 + 48) & 1) != 0)
      v18 = (const char *)*((_QWORD *)a2 + 7);
    else
      v18 = (char *)a2 + 49;
    if (!strncmp(v18, ParentDirectory, v14))
    {
      v19 = &v18[v16];
    }
    else
    {
      re::DynamicString::append(a3, "/", 1uLL);
      if ((*((_QWORD *)a2 + 6) & 1) != 0)
        v19 = (const char *)*((_QWORD *)a2 + 7);
      else
        v19 = (char *)a2 + 49;
    }
    v20 = strlen(v19);
    re::DynamicString::append(a3, v19, v20);
    re::DynamicString::append(a3, ".", 1uLL);
    v21 = strlen(v17);
    return (re::DynamicString *)re::DynamicString::append(a3, v17, v21);
  }
}

re::DynamicString *re::AssetPath::assetPathForNetwork@<X0>(re::AssetPath *this@<X0>, const char *a2@<X1>, re::DynamicString *a3@<X8>)
{
  NSObject *v5;
  _anonymous_namespace_ *v6;
  size_t v9;
  const char *v10;
  uint64_t v11;
  size_t v12;
  NSObject *v13;
  _BYTE *v14;
  _anonymous_namespace_ *v15;
  char v16;
  _BYTE v17[23];
  uint8_t buf[4];
  _BYTE *v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)this == 3)
  {
    v9 = strlen(a2);
    re::DynamicString::append(a3, a2, v9);
    re::DynamicString::append(a3, "/", 1uLL);
    if ((*((_BYTE *)this + 48) & 1) != 0)
      v10 = (const char *)*((_QWORD *)this + 7);
    else
      v10 = (char *)this + 49;
    v12 = strlen(v10);
    return (re::DynamicString *)re::DynamicString::append(a3, v10, v12);
  }
  else if (*(_DWORD *)this == 5)
  {
    v5 = *re::assetsLogObjects(this);
    v6 = (_anonymous_namespace_ *)os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if ((_DWORD)v6)
    {
      v13 = v5;
      re::AssetPath::fullAssetPath(this, (re::DynamicString *)&v15);
      if ((v16 & 1) != 0)
        v14 = *(_BYTE **)&v17[7];
      else
        v14 = v17;
      *(_DWORD *)buf = 136315138;
      v19 = v14;
      _os_log_error_impl(&dword_224FE9000, v13, OS_LOG_TYPE_ERROR, "Can't get network asset handle for source asset path '%s'", buf, 0xCu);

      v6 = v15;
      if (v15)
      {
        if ((v16 & 1) != 0)
          v6 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(*(_QWORD *)v15 + 40))();
      }
    }
  }
  else
  {
    v11 = *((_QWORD *)this + 1);
    *((_QWORD *)a3 + 2) = 0;
    *((_QWORD *)a3 + 3) = 0;
    *(_QWORD *)a3 = v11;
    *((_QWORD *)a3 + 1) = 0;
    re::DynamicString::setCapacity(a3, 0);
    return re::AssetPath::fullAssetPath(this, a3);
  }
}

uint64_t re::AssetPath::filePathToAsset(re::AssetPath *this, re::DynamicString *a2, uint64_t a3, os_unfair_lock_s *a4)
{
  int v4;
  uint64_t BundleResource;
  const char *v8;
  re::Bundle *v9;
  re::Bundle *v10;
  void *v11;
  id v12;
  void *v13;
  id v14;
  const char *v15;
  re *v16;
  NSObject *v17;
  char *v19;
  id v20;
  id v21;
  id v22;
  __int128 buf;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v4 = a3;
  BundleResource = 0;
  switch(*(_DWORD *)this)
  {
    case 0:
    case 3:
    case 4:
    case 7:
    case 8:
      return BundleResource;
    case 1:
      v8 = *(const char **)(*((_QWORD *)this + 9) + 8);
      if ((*((_BYTE *)this + 16) & 1) != 0)
        v9 = (re::Bundle *)*((_QWORD *)this + 3);
      else
        v9 = (re::AssetPath *)((char *)this + 17);
      re::Bundle::searchForAppOrAppExtension(v9, &buf);
      v11 = (void *)buf;
      if (!(_QWORD)buf)
      {
        re::Bundle::application(&v22);
        v12 = v22;
        v13 = (void *)buf;
        v22 = 0;
        *(_QWORD *)&buf = v12;

        v11 = (void *)buf;
      }
      v21 = v11;

      v14 = (id)buf;
      goto LABEL_26;
    case 2:
      if ((*((_BYTE *)this + 16) & 1) != 0)
        v10 = (re::Bundle *)*((_QWORD *)this + 3);
      else
        v10 = (re::AssetPath *)((char *)this + 17);
      v15 = *(const char **)(*((_QWORD *)this + 9) + 8);
      re::Bundle::findWithBundleID(v10, &v22);
      if (v22)
      {
        v20 = v22;

      }
      else
      {
        v17 = *re::assetsLogObjects(v16);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          if ((*((_BYTE *)this + 16) & 1) != 0)
            v19 = (char *)*((_QWORD *)this + 3);
          else
            v19 = (char *)this + 17;
          LODWORD(buf) = 136315138;
          *(_QWORD *)((char *)&buf + 4) = v19;
          _os_log_error_impl(&dword_224FE9000, v17, OS_LOG_TYPE_ERROR, "Unable to make compiled asset '%s' file path because no valid framework was found", (uint8_t *)&buf, 0xCu);
        }
        BundleResource = 0;
      }
      v14 = v22;
LABEL_26:

      break;
    case 5:
      re::DynamicString::operator=(a2, (re::AssetPath *)((char *)this + 40));
      if ((v4 & 1) == 0)
      {
        re::DynamicString::operator=(a2, (re::DynamicString *)&buf);
        if ((_QWORD)buf)
        {
          if ((BYTE8(buf) & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)buf + 40))();
        }
      }
      BundleResource = 1;
      break;
    case 6:
      re::AssetPath::getPathFromResolver((re::AssetPath *)&buf, this, a4);
      BundleResource = (_BYTE)buf != 0;
      if ((_BYTE)buf)
      {
        re::DynamicString::operator=(a2, (re::DynamicString *)((char *)&buf + 8));
        if ((_BYTE)buf)
        {
          if (*((_QWORD *)&buf + 1) && (v24 & 1) != 0)
            (*(void (**)(void))(**((_QWORD **)&buf + 1) + 40))();
        }
      }
      break;
    default:
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, a4, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "filePathToAsset", 770);
      _os_crash();
      __break(1u);
      JUMPOUT(0x2251E77B4);
  }
  return BundleResource;
}

uint64_t `anonymous namespace'::findBundleResource(re::DynamicString *a1, id *a2, _anonymous_namespace_ *a3, const char *a4, int a5, uint64_t a6)
{
  char *v12;
  char v13;
  const char *v14;
  uint64_t result;
  const char *v16;
  uint64_t v17;
  NSObject *v18;
  _BYTE *v19;
  char *v20;
  NSObject *v21;
  _BOOL4 v22;
  char *v23;
  int v24;
  uint64_t v25;
  __int16 v26;
  _BYTE *v27;
  __int16 v28;
  char *v29;
  _BYTE buf[12];
  __int16 v31;
  _BYTE v32[10];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v13 = (char)v12;
  if ((v12 & 1) != 0 || a5)
  {
    v14 = (*((_QWORD *)a3 + 1) & 1) != 0 ? (const char *)*((_QWORD *)a3 + 2) : (char *)a3 + 9;
    v12 = (char *)re::Bundle::pathForResource(a2, v14, a1);
    if ((v12 & 1) != 0)
      return 1;
  }
  if ((v13 & 1) == 0)
  {
    if ((buf[8] & 1) != 0)
      v16 = *(const char **)&v32[2];
    else
      v16 = &buf[9];
    if (re::Bundle::pathForResource(a2, v16, a1))
    {
      v17 = dyld_program_sdk_at_least();
      if ((v17 & 1) != 0)
      {
        if (*(_QWORD *)buf)
        {
          if ((buf[8] & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)buf + 40))();
        }
        return 1;
      }
      v18 = *re::assetsLogObjects((re *)v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        if ((buf[8] & 1) != 0)
          v19 = *(_BYTE **)&v32[2];
        else
          v19 = &buf[9];
        if ((*((_QWORD *)a3 + 1) & 1) != 0)
          v20 = (char *)*((_QWORD *)a3 + 2);
        else
          v20 = (char *)a3 + 9;
        v24 = 136315650;
        v25 = a6;
        v26 = 2080;
        v27 = v19;
        v28 = 2080;
        v29 = v20;
        _os_log_impl(&dword_224FE9000, v18, OS_LOG_TYPE_DEFAULT, "%s compiled resource '%s' exists, but was requested as '%s'", (uint8_t *)&v24, 0x20u);
      }
    }
    v12 = *(char **)buf;
    if (*(_QWORD *)buf && (buf[8] & 1) != 0)
      v12 = (char *)(*(uint64_t (**)(void))(**(_QWORD **)buf + 40))();
  }
  v21 = *re::assetsLogObjects((re *)v12);
  v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v22)
  {
    if ((*((_QWORD *)a3 + 1) & 1) != 0)
      v23 = (char *)*((_QWORD *)a3 + 2);
    else
      v23 = (char *)a3 + 9;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = a6;
    v31 = 2080;
    *(_QWORD *)v32 = v23;
    _os_log_impl(&dword_224FE9000, v21, OS_LOG_TYPE_DEFAULT, "Failed to find %s resource file '%s'", buf, 0x16u);
    return 0;
  }
  return result;
}

re::DynamicString *`anonymous namespace'::setExtension@<X0>(_anonymous_namespace_ *this@<X0>, const re::DynamicString *a2@<X1>, re::DynamicString *a3@<X8>)
{
  unsigned __int8 v7;
  re::DynamicString *result;
  size_t v9;

  result = re::DynamicString::DynamicString(a3, this);
  if ((v7 & 1) == 0)
  {
    re::DynamicString::append(a3, ".", 1uLL);
    v9 = strlen((const char *)a2);
    return (re::DynamicString *)re::DynamicString::append(a3, (const char *)a2, v9);
  }
  return result;
}

void re::AssetPath::getPathFromResolver(re::AssetPath *this, const re::AssetProviderRegistry *a2, os_unfair_lock_s *a3)
{
  NSObject *v4;
  uint8_t v5[16];

  if (a3)
  {
    re::AssetProviderRegistry::getPathFromResolver(a3, (const re::AssetProviderRegistry *)((char *)a2 + 8), (const re::AssetProviderRegistry *)((char *)a2 + 40), (uint64_t)this);
  }
  else
  {
    v4 = *re::assetsLogObjects(this);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v5 = 0;
      _os_log_error_impl(&dword_224FE9000, v4, OS_LOG_TYPE_ERROR, "Tried to open resolver asset path without a resolve manager defined", v5, 2u);
    }
    *(_BYTE *)this = 0;
  }
}

BOOL re::AssetPath::temp_filePathToSourceAssetInBundle(re::AssetPath *this, re::DynamicString *a2, os_unfair_lock_s *a3)
{
  _BOOL8 v5;
  re::Bundle *v6;
  re::Bundle *v7;
  const char *v8;
  re *v9;
  const char *v10;
  re *v11;
  const char *v12;
  NSObject *v13;
  char *v14;
  char *v15;
  _BOOL8 v16;
  char *v17;
  _BOOL8 v18;
  char *v19;
  const char *v20;
  id v22;
  uint8_t buf[4];
  _BYTE v24[12];
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v5 = 0;
  switch(*(_DWORD *)this)
  {
    case 0:
    case 3:
    case 4:
    case 7:
      return v5;
    case 1:
      if ((*((_BYTE *)this + 16) & 1) != 0)
        v6 = (re::Bundle *)*((_QWORD *)this + 3);
      else
        v6 = (re::AssetPath *)((char *)this + 17);
      re::Bundle::searchForAppOrAppExtension(v6, &v22);
      if (v22)
      {
        if ((*((_BYTE *)this + 48) & 1) != 0)
          v10 = (const char *)*((_QWORD *)this + 7);
        else
          v10 = (char *)this + 49;
        v16 = re::Bundle::pathForResource(&v22, v10, a2);
        if (v16)
          goto LABEL_36;
        v13 = *re::assetsLogObjects((re *)v16);
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          goto LABEL_49;
        if ((*((_BYTE *)this + 48) & 1) != 0)
          v17 = (char *)*((_QWORD *)this + 7);
        else
          v17 = (char *)this + 49;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)v24 = v17;
        v20 = "Failed to find app resource file '%s'";
      }
      else
      {
        v13 = *re::assetsLogObjects(v9);
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          goto LABEL_49;
        if ((*((_BYTE *)this + 16) & 1) != 0)
          v14 = (char *)*((_QWORD *)this + 3);
        else
          v14 = (char *)this + 17;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)v24 = v14;
        v20 = "Unable to make source asset file path because missing app '%s'";
      }
      goto LABEL_48;
    case 2:
      if ((*((_BYTE *)this + 16) & 1) != 0)
        v7 = (re::Bundle *)*((_QWORD *)this + 3);
      else
        v7 = (re::AssetPath *)((char *)this + 17);
      re::Bundle::findWithBundleID(v7, &v22);
      if (!v22)
      {
        v13 = *re::assetsLogObjects(v11);
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          goto LABEL_49;
        if ((*((_BYTE *)this + 16) & 1) != 0)
          v15 = (char *)*((_QWORD *)this + 3);
        else
          v15 = (char *)this + 17;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)v24 = v15;
        v20 = "Unable to make compiled asset '%s' file path because no valid framework was found";
        goto LABEL_48;
      }
      if ((*((_BYTE *)this + 48) & 1) != 0)
        v12 = (const char *)*((_QWORD *)this + 7);
      else
        v12 = (char *)this + 49;
      v18 = re::Bundle::pathForResource(&v22, v12, a2);
      if (v18)
      {
LABEL_36:
        v5 = 1;
        goto LABEL_50;
      }
      v13 = *re::assetsLogObjects((re *)v18);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        if ((*((_BYTE *)this + 48) & 1) != 0)
          v19 = (char *)*((_QWORD *)this + 7);
        else
          v19 = (char *)this + 49;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)v24 = v19;
        v20 = "Failed to find framework resource file '%s'";
LABEL_48:
        _os_log_error_impl(&dword_224FE9000, v13, OS_LOG_TYPE_ERROR, v20, buf, 0xCu);
      }
LABEL_49:
      v5 = 0;
LABEL_50:

      return v5;
    case 5:
      if ((*((_BYTE *)this + 48) & 1) != 0)
        v8 = (const char *)*((_QWORD *)this + 7);
      else
        v8 = (char *)this + 49;
      re::DynamicString::assignf(a2, "%s", v8);
      return 1;
    case 6:
      re::AssetPath::getPathFromResolver((re::AssetPath *)buf, this, a3);
      v5 = buf[0] != 0;
      if (buf[0])
      {
        re::DynamicString::operator=(a2, (re::DynamicString *)&v24[4]);
        if (buf[0])
        {
          if (*(_QWORD *)&v24[4] && (v25 & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)&v24[4] + 40))();
        }
      }
      return v5;
    default:
      re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) ", "!\"Unreachable code\"", "temp_filePathToSourceAssetInBundle", 825);
      _os_crash();
      __break(1u);
      JUMPOUT(0x2251E7E64);
  }
}

uint64_t re::AssetPath::initMemoryAssetPath(_QWORD *a1, const char *a2, uint64_t a3)
{
  uint64_t v6;
  _BYTE *v7;
  uint64_t result;
  uint64_t v9;
  char v10;
  _OWORD v11[2];

  *(_DWORD *)a1 = 3;
  v6 = a1[2];
  if ((v6 & 1) != 0)
  {
    a1[2] = 1;
    v7 = (_BYTE *)a1[3];
  }
  else
  {
    *((_BYTE *)a1 + 16) = v6 & 1;
    v7 = (char *)a1 + 17;
  }
  *v7 = 0;
  a1[9] = a3;
  re::DynamicString::operator=((re::DynamicString *)(a1 + 5), (re::DynamicString *)v11);
  if (*(_QWORD *)&v11[0])
  {
    if ((BYTE8(v11[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v11[0] + 40))();
    memset(v11, 0, sizeof(v11));
  }
  result = v9;
  if (v9)
  {
    if ((v10 & 1) != 0)
      return (*(uint64_t (**)(void))(*(_QWORD *)v9 + 40))();
  }
  return result;
}

re::DynamicString *re::AssetPath::initSingleFileArchiveAssetPath(uint64_t a1, char *__s, uint64_t a3)
{
  uint64_t v5;
  _BYTE *v6;
  re::DynamicString *result;
  _QWORD v8[2];

  *(_DWORD *)a1 = 7;
  v5 = *(_QWORD *)(a1 + 16);
  if ((v5 & 1) != 0)
  {
    *(_QWORD *)(a1 + 16) = 1;
    v6 = *(_BYTE **)(a1 + 24);
  }
  else
  {
    *(_BYTE *)(a1 + 16) = v5 & 1;
    v6 = (_BYTE *)(a1 + 17);
  }
  *v6 = 0;
  v8[0] = __s;
  v8[1] = strlen(__s);
  result = re::DynamicString::operator=((re::DynamicString *)(a1 + 40), (uint64_t)v8);
  *(_QWORD *)(a1 + 72) = a3;
  return result;
}

uint64_t re::AssetPath::initAssetIdAssetPath(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _BYTE *v6;
  uint64_t result;
  uint64_t v8;
  char v9;

  *(_DWORD *)a1 = 8;
  v5 = *(_QWORD *)(a1 + 16);
  if ((v5 & 1) != 0)
  {
    *(_QWORD *)(a1 + 16) = 1;
    v6 = *(_BYTE **)(a1 + 24);
  }
  else
  {
    *(_BYTE *)(a1 + 16) = v5 & 1;
    v6 = (_BYTE *)(a1 + 17);
  }
  *v6 = 0;
  re::DynamicString::format((re::DynamicString *)"%llu.%s", (re::DynamicString *)&v8, a2, *(_QWORD *)(a3 + 8));
  re::DynamicString::operator=((re::DynamicString *)(a1 + 40), (re::DynamicString *)&v8);
  result = v8;
  if (v8 && (v9 & 1) != 0)
    result = (*(uint64_t (**)(void))(*(_QWORD *)v8 + 40))();
  *(_QWORD *)(a1 + 72) = a3;
  return result;
}

BOOL re::AssetPath::getAssetId(re::AssetPath *this, unint64_t *a2)
{
  const char *v2;

  if (*(_DWORD *)this != 8)
    return 0;
  if ((*((_BYTE *)this + 48) & 1) != 0)
    v2 = (const char *)*((_QWORD *)this + 7);
  else
    v2 = (char *)this + 49;
  return sscanf(v2, "%llu", a2) == 1;
}

char *`anonymous namespace'::hasExtension(uint64_t a1, const char *a2)
{
  char *v3;
  char *result;

  if ((*(_QWORD *)(a1 + 8) & 1) != 0)
    v3 = *(char **)(a1 + 16);
  else
    v3 = (char *)(a1 + 9);
  result = strrchr(v3, 46);
  if (result)
    return (char *)(strcmp(result + 1, a2) == 0);
  return result;
}

re::DynamicString *re::AssetPath::initPeerAssetPath(uint64_t a1, char *__s, const char *a3, uint64_t a4)
{
  re::DynamicString *v7;
  size_t v8;
  re::DynamicString *result;
  char *v10;
  size_t v11;

  *(_DWORD *)a1 = 4;
  v7 = (re::DynamicString *)(a1 + 8);
  v10 = __s;
  v11 = strlen(__s);
  re::DynamicString::operator=(v7, (uint64_t)&v10);
  v8 = strlen(a3);
  v10 = (char *)a3;
  v11 = v8;
  result = re::DynamicString::operator=((re::DynamicString *)(a1 + 40), (uint64_t)&v10);
  *(_QWORD *)(a1 + 72) = a4;
  return result;
}

re::DynamicString *re::AssetPath::invalidAssetPath@<X0>(re::AssetPath *this@<X0>, uint64_t a2@<X8>)
{
  _anonymous_namespace_ *v3;
  re::DynamicString *result;
  const char *v5;
  uint64_t v6;

  *(_DWORD *)a2 = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  v3 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)(a2 + 8), 0);
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  re::DynamicString::setCapacity((_QWORD *)(a2 + 40), 0);
  *(_QWORD *)(a2 + 72) = 0;
  *(_DWORD *)a2 = 6;
  v5 = "invalidResolver";
  v6 = 15;
  re::DynamicString::operator=((re::DynamicString *)(a2 + 8), (uint64_t)&v5);
  v5 = "none";
  v6 = 4;
  result = re::DynamicString::operator=((re::DynamicString *)(a2 + 40), (uint64_t)&v5);
  *(_QWORD *)(a2 + 72) = 0;
  return result;
}

const char *re::AssetPath::removingCompiledExtension@<X0>(re::AssetPath *this@<X0>, uint64_t a2@<X8>)
{
  const char *result;
  const char *v6;
  char v7;

  result = strrchr((char *)this, 46);
  if (result && (v6 = result, result = (const char *)strncmp(".compiled", result, 9uLL), !(_DWORD)result))
  {
    *(_QWORD *)(a2 + 8) = this;
    *(_QWORD *)(a2 + 16) = v6 - (const char *)this;
    v7 = 1;
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)a2 = v7;
  return result;
}

re::AssetPath *re::AssetPath::fixLegacyPath(re::AssetPath *this, const char *a2)
{
  re::AssetPath *v2;
  const char *v3;
  _BYTE v5[8];
  uint64_t v6;
  char __s1[8];
  uint64_t v8;

  v2 = this;
  v8 = *MEMORY[0x24BDAC8D0];
  strcpy(__s1, "engine:");
  if (!strncmp(__s1, (const char *)this, 7uLL)
    || !strncmp("framework:", (const char *)v2, 0xAuLL)
    && re::isEngineFrameworkPath((re::AssetPath *)((char *)v2 + 10), v3))
  {
    re::AssetPath::removingCompiledExtension(v2, (uint64_t)v5);
    if (v5[0])
      return (re::AssetPath *)v6;
  }
  strlen((const char *)v2);
  return v2;
}

char *re::AssetPath::getAssetTypeNameFromPath(re::AssetPath *this, const char *a2)
{
  char *result;

  result = strrchr((char *)this, 46);
  if (result)
  {
    if (!strncmp("compiled", (const char *)this, 8uLL))
      return (char *)this + 8;
    else
      return 0;
  }
  return result;
}

uint64_t re::AssetPath::getAssetTypeFromFilePath(re::AssetPath *this, re::internal::AssetTypeRegistry *a2, const re::internal::AssetTypeRegistry *a3)
{
  uint64_t result;
  const re::internal::AssetTypeRegistry *v5;
  const char *v6;

  result = (uint64_t)strrchr((char *)this, 46);
  if (result)
  {
    v6 = (const char *)(result + 1);
    if (!result)
      return re::internal::AssetTypeRegistry::assetTypeWithExtension(a2, v6);
  }
  return result;
}

BOOL re::AssetPath::pathIsAppBased(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  const char *v3;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = v1 >> 1;
  if ((v1 & 1) == 0)
    v2 = (v1 >> 1) & 0x7C;
  if (v2 < 4)
    return 0;
  if ((v1 & 1) != 0)
    v3 = *(const char **)(a1 + 16);
  else
    v3 = (const char *)(a1 + 9);
  return strncmp(v3, "app:", 4uLL) == 0;
}

char *re::AssetPath::updateWithCompiledExtension(char *result, uint64_t a2)
{
  _anonymous_namespace_ *v2;
  const char *v3;
  char *v4;
  size_t v5;
  _OWORD v6[2];

  if (a2)
  {
    v2 = (_anonymous_namespace_ *)result;
    v3 = *(const char **)(a2 + 8);
    v4 = (*((_QWORD *)result + 1) & 1) != 0 ? (char *)*((_QWORD *)result + 2) : result + 9;
    result = strrchr(v4, 46);
    if (result)
    {
      result = (char *)strcmp(result + 1, v3);
      if ((_DWORD)result)
      {
        if (*(_QWORD *)&v6[0])
        {
          if ((BYTE8(v6[0]) & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)&v6[0] + 40))();
          memset(v6, 0, sizeof(v6));
        }
        re::DynamicString::append(v2, ".", 1uLL);
        v5 = strlen(v3);
        return (char *)re::DynamicString::append(v2, v3, v5);
      }
    }
  }
  return result;
}

uint64_t zip_copy_with_read_handle(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  size_t v6;
  void *v7;
  __int128 v8;
  unint64_t v9;
  uint64_t v10;
  std::string::size_type *v11;
  std::string::size_type v12;
  unint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  std::string::size_type *v18;
  std::string::size_type v19;
  unint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  __int128 v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  unint64_t v40;
  char *v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  BOOL v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD *v67;
  char *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  BOOL v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  int64_t v77;
  char *v78;
  unint64_t v79;
  char *v80;
  uint64_t v81;
  char *v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  char *v86;
  uint64_t v87;
  void *v88;
  _QWORD *v89;
  char *v90;
  char *v91;
  void *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  unint64_t v98;
  char *v99;
  uint64_t v100;
  BOOL v101;
  uint64_t v102;
  uint64_t v103;
  char *v104;
  uint64_t v105;
  _QWORD *v106;
  void *v107;
  __int128 v108;
  uint64_t i;
  uint64_t v110;
  uint64_t v111;
  _QWORD *v112;
  char *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  char *v120;
  int64_t v121;
  char *v122;
  unint64_t v123;
  char *v124;
  uint64_t v125;
  char *v126;
  uint64_t *v127;
  uint64_t v128;
  uint64_t v129;
  char *v130;
  uint64_t v131;
  void *v132;
  char *v133;
  unint64_t v134;
  uint64_t v135;
  char *v136;
  uint64_t v137;
  unint64_t v138;
  unint64_t v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  std::string::size_type v144;
  _QWORD *v145;
  unint64_t v146;
  uint64_t v147;
  unint64_t v148;
  _QWORD *v149;
  uint64_t *v150;
  unint64_t v151;
  uint64_t *v152;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t *v157;
  void *v158;
  __int128 v159;
  __int128 v160;
  uint64_t v161;

  v4 = operator new();
  *(_QWORD *)(v4 + 72) = 0;
  *(_QWORD *)(v4 + 80) = 0;
  *(_QWORD *)(v4 + 88) = 0;
  *(int64x2_t *)(v4 + 96) = vdupq_n_s64(1uLL);
  *(_QWORD *)(v4 + 120) = 0;
  *(_QWORD *)(v4 + 128) = 0;
  *(_QWORD *)(v4 + 112) = 0;
  *(_WORD *)(v4 + 136) = 768;
  *(_OWORD *)(v4 + 144) = 0u;
  v5 = (_QWORD *)(v4 + 144);
  *(_OWORD *)(v4 + 160) = 0u;
  *(_OWORD *)(v4 + 176) = 0u;
  *(_DWORD *)(v4 + 192) = 0;
  *(_QWORD *)v4 = a2;
  *(_OWORD *)(v4 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v4 + 24) = *(_OWORD *)(a1 + 24);
  *(_QWORD *)(v4 + 40) = *(_QWORD *)(a1 + 40);
  *(_OWORD *)(v4 + 48) = *(_OWORD *)(a1 + 48);
  *(_QWORD *)(v4 + 64) = *(_QWORD *)(a1 + 64);
  v6 = *(_QWORD *)(a1 + 80);
  v7 = malloc_type_malloc(v6, 0xC2A086EBuLL);
  if (*(_BYTE *)(v4 + 88))
    free(*(void **)(v4 + 72));
  *(_QWORD *)(v4 + 72) = v7;
  *(_QWORD *)(v4 + 80) = v6;
  *(_BYTE *)(v4 + 88) = 1;
  memcpy(v7, *(const void **)(a1 + 72), *(_QWORD *)(a1 + 80));
  *(_BYTE *)(v4 + 88) = 1;
  v8 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)(v4 + 96) = *(_OWORD *)(a1 + 96);
  *(_OWORD *)(v4 + 112) = v8;
  *(_QWORD *)(v4 + 128) = *(_QWORD *)(a1 + 128);
  *(_WORD *)(v4 + 136) = *(_WORD *)(a1 + 136);
  v156 = a1;
  if (v4 == a1)
    goto LABEL_159;
  v9 = *(_QWORD *)(a1 + 176);
  v10 = *(_QWORD *)(a1 + 152);
  v11 = (std::string::size_type *)(v10 + 8 * (v9 / 0x27));
  if (*(_QWORD *)(a1 + 160) == v10)
  {
    v12 = 0;
    v15 = 0;
    v14 = (_QWORD *)(v10 + 8 * ((*(_QWORD *)(v156 + 184) + v9) / 0x27));
  }
  else
  {
    v12 = *(_QWORD *)(v10 + 8 * (v9 / 0x27)) + 104 * (v9 % 0x27);
    v13 = *(_QWORD *)(v156 + 184) + v9;
    v14 = (_QWORD *)(v10 + 8 * (v13 / 0x27));
    v15 = *v14 + 104 * (v13 % 0x27);
  }
  if (v15 == v12)
  {
    v16 = 0;
    v157 = (uint64_t *)(v4 + 184);
LABEL_12:
    v24 = *(_QWORD *)(v4 + 176);
    v25 = *(_QWORD *)(v4 + 152);
    v26 = (_QWORD *)(v25 + 8 * (v24 / 0x27));
    if (*(_QWORD *)(v4 + 160) == v25)
      v27 = 0;
    else
      v27 = *v26 + 104 * (v24 % 0x27);
    *(_QWORD *)&v159 = v11;
    *((_QWORD *)&v159 + 1) = v12;
    std::__deque_iterator<zip_entry_t,zip_entry_t const*,zip_entry_t const&,zip_entry_t const* const*,long,39l>::operator+=[abi:nn180100](&v159, v16);
    v28 = v159;
    *(_QWORD *)&v159 = v26;
    *((_QWORD *)&v159 + 1) = v27;
    std::__for_each_segment[abi:nn180100]<std::__deque_iterator<zip_entry_t,zip_entry_t const*,zip_entry_t const&,zip_entry_t const* const*,long,39l>,std::__copy_loop<std::_ClassicAlgPolicy>::_CopySegment<std::__deque_iterator<zip_entry_t,zip_entry_t const*,zip_entry_t const&,zip_entry_t const* const*,long,39l>,std::__deque_iterator<zip_entry_t,zip_entry_t*,zip_entry_t&,zip_entry_t**,long,39l>>>(v11, v12, (std::string::size_type *)v28, *((std::string::size_type *)&v28 + 1), (uint64_t)&v159);
    v30 = *(_QWORD *)(v4 + 176);
    v29 = *(_QWORD *)(v4 + 184);
    v31 = ((v30 + v29) * (unsigned __int128)0xA41A41A41A41A41BLL) >> 64;
    v32 = (v31 + ((v30 + v29 - v31) >> 1)) >> 5;
    v34 = *(_QWORD *)(v4 + 152);
    v33 = *(_QWORD *)(v4 + 160);
    v35 = (_QWORD *)(v34 + 8 * v32);
    if (v33 == v34)
      v36 = 0;
    else
      v36 = *v35 + 104 * (v30 + v29 - 39 * v32);
    if (v36 != *((_QWORD *)&v159 + 1))
    {
      v37 = (uint64_t)(*((_QWORD *)&v159 + 1) - *(_QWORD *)v159) >> 3;
      v38 = 39 * ((uint64_t)((uint64_t)v35 - v159) >> 3)
          + 0x4EC4EC4EC4EC4EC5 * ((v36 - *v35) >> 3)
          - 0x4EC4EC4EC4EC4EC5 * v37;
      if (v38 >= 1)
      {
        v39 = (_QWORD *)(v34 + 8 * (v30 / 0x27));
        if (v33 == v34)
          v40 = 0;
        else
          v40 = *v39 + 104 * (v30 % 0x27);
        if (*((_QWORD *)&v159 + 1) == v40)
          v60 = 0;
        else
          v60 = 39 * ((uint64_t)(v159 - (_QWORD)v39) >> 3)
              + 0x4EC4EC4EC4EC4EC5 * v37
              - 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v40 - *v39) >> 3);
        *(_QWORD *)&v159 = v34 + 8 * (v30 / 0x27);
        *((_QWORD *)&v159 + 1) = v40;
        std::__deque_iterator<zip_entry_t,zip_entry_t const*,zip_entry_t const&,zip_entry_t const* const*,long,39l>::operator+=[abi:nn180100](&v159, v60);
        v61 = *((_QWORD *)&v159 + 1);
        if (*((_QWORD *)&v159 + 1) != v36)
        {
          v62 = (_QWORD *)v159;
          do
          {
            if (*(char *)(v61 + 31) < 0)
              operator delete(*(void **)(v61 + 8));
            v61 += 104;
            if (v61 - *v62 == 4056)
            {
              v63 = v62[1];
              ++v62;
              v61 = v63;
            }
          }
          while (v61 != v36);
          v34 = *(_QWORD *)(v4 + 152);
          v33 = *(_QWORD *)(v4 + 160);
          v30 = *(_QWORD *)(v4 + 176);
          v29 = *(_QWORD *)(v4 + 184);
        }
        v64 = 39 * ((v33 - v34) >> 3) - 1;
        if (v33 == v34)
          v64 = 0;
        *v157 = v29 - v38;
        if (v64 - (v29 - v38 + v30) >= 0x4E)
        {
          do
          {
            operator delete(*(void **)(v33 - 8));
            v65 = *(_QWORD *)(v4 + 152);
            v33 = *(_QWORD *)(v4 + 160) - 8;
            v66 = 39 * ((v33 - v65) >> 3) - 1;
            *(_QWORD *)(v4 + 160) = v33;
            if (v33 == v65)
              v66 = 0;
          }
          while ((unint64_t)(v66 - (*(_QWORD *)(v4 + 184) + *(_QWORD *)(v4 + 176))) > 0x4D);
        }
      }
    }
    goto LABEL_159;
  }
  v16 = 39 * (v14 - v11)
      + 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v15 - *v14) >> 3)
      - 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v12 - *v11) >> 3);
  v17 = *(_QWORD *)(v4 + 184);
  v157 = (uint64_t *)(v4 + 184);
  if (v17 >= v16)
    goto LABEL_12;
  *(_QWORD *)&v159 = v11;
  *((_QWORD *)&v159 + 1) = v12;
  std::__deque_iterator<zip_entry_t,zip_entry_t const*,zip_entry_t const&,zip_entry_t const* const*,long,39l>::operator+=[abi:nn180100](&v159, v17);
  v19 = *((_QWORD *)&v159 + 1);
  v18 = (std::string::size_type *)v159;
  v20 = *(_QWORD *)(v4 + 176);
  v21 = *(_QWORD *)(v4 + 152);
  v22 = (_QWORD *)(v21 + 8 * (v20 / 0x27));
  if (*(_QWORD *)(v4 + 160) == v21)
    v23 = 0;
  else
    v23 = *v22 + 104 * (v20 % 0x27);
  *(_QWORD *)&v159 = v22;
  *((_QWORD *)&v159 + 1) = v23;
  std::__for_each_segment[abi:nn180100]<std::__deque_iterator<zip_entry_t,zip_entry_t const*,zip_entry_t const&,zip_entry_t const* const*,long,39l>,std::__copy_loop<std::_ClassicAlgPolicy>::_CopySegment<std::__deque_iterator<zip_entry_t,zip_entry_t const*,zip_entry_t const&,zip_entry_t const* const*,long,39l>,std::__deque_iterator<zip_entry_t,zip_entry_t*,zip_entry_t&,zip_entry_t**,long,39l>>>(v11, v12, v18, v19, (uint64_t)&v159);
  v42 = *(char **)(v4 + 152);
  v41 = *(char **)(v4 + 160);
  v43 = (v41 - v42) >> 3;
  if (v41 == v42)
    v44 = 0;
  else
    v44 = 39 * v43 - 1;
  v45 = *(_QWORD *)(v4 + 176);
  v46 = *(_QWORD *)(v4 + 184);
  v47 = v16 - v46;
  v48 = v45 + v46;
  v49 = v44 - (v45 + v46);
  v50 = v16 - v46 >= v49;
  v51 = v16 - v46 - v49;
  if (v51 != 0 && v50)
  {
    if (v41 == v42)
      v52 = v51 + 1;
    else
      v52 = v51;
    if (v52 % 0x27)
      v53 = v52 / 0x27 + 1;
    else
      v53 = v52 / 0x27;
    if (v53 >= v45 / 0x27)
      v54 = v45 / 0x27;
    else
      v54 = v53;
    if (v53 <= v45 / 0x27)
    {
      for (*(_QWORD *)(v4 + 176) = v45 - 39 * v54; v54; --v54)
      {
        v67 = *(_QWORD **)(v4 + 152);
        v70 = *v67;
        v68 = (char *)(v67 + 1);
        v69 = v70;
        *(_QWORD *)(v4 + 152) = v68;
        if (v41 == *(char **)(v4 + 168))
        {
          v71 = (uint64_t)&v68[-*v5];
          if ((unint64_t)v68 <= *v5)
          {
            if (v41 == (char *)*v5)
              v79 = 1;
            else
              v79 = (uint64_t)&v41[-*v5] >> 2;
            v80 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<zip_entry_t *>>(v79);
            v82 = &v80[8 * (v79 >> 2)];
            v83 = *(uint64_t **)(v4 + 152);
            v41 = v82;
            v84 = *(_QWORD *)(v4 + 160) - (_QWORD)v83;
            if (v84)
            {
              v41 = &v82[v84 & 0xFFFFFFFFFFFFFFF8];
              v85 = 8 * (v84 >> 3);
              v86 = &v80[8 * (v79 >> 2)];
              do
              {
                v87 = *v83++;
                *(_QWORD *)v86 = v87;
                v86 += 8;
                v85 -= 8;
              }
              while (v85);
            }
            v88 = *(void **)(v4 + 144);
            *(_QWORD *)(v4 + 144) = v80;
            *(_QWORD *)(v4 + 152) = v82;
            *(_QWORD *)(v4 + 160) = v41;
            *(_QWORD *)(v4 + 168) = &v80[8 * v81];
            if (v88)
            {
              operator delete(v88);
              v41 = *(char **)(v4 + 160);
            }
          }
          else
          {
            v72 = v71 >> 3;
            v73 = v71 >> 3 < -1;
            v74 = (v71 >> 3) + 2;
            if (v73)
              v75 = v74;
            else
              v75 = v72 + 1;
            v76 = &v68[-8 * (v75 >> 1)];
            v77 = v41 - v68;
            if (v41 != v68)
            {
              memmove(&v68[-8 * (v75 >> 1)], v68, v41 - v68);
              v41 = *(char **)(v4 + 152);
            }
            v78 = &v41[-8 * (v75 >> 1)];
            v41 = &v76[v77];
            *(_QWORD *)(v4 + 152) = v78;
            *(_QWORD *)(v4 + 160) = &v76[v77];
          }
        }
        *(_QWORD *)v41 = v69;
        v41 = (char *)(*(_QWORD *)(v4 + 160) + 8);
        *(_QWORD *)(v4 + 160) = v41;
      }
    }
    else
    {
      v55 = v53 - v54;
      v56 = *(_QWORD *)(v4 + 168) - *(_QWORD *)(v4 + 144);
      if (v53 - v54 <= (v56 >> 3) - v43)
      {
        if (v55)
        {
          while (*(_QWORD *)(v4 + 168) != *(_QWORD *)(v4 + 160))
          {
            *(_QWORD *)&v159 = operator new(0xFD8uLL);
            std::__split_buffer<zip_entry_t *>::push_back(v5, &v159);
            --v53;
            if (!--v55)
            {
              v41 = *(char **)(v4 + 160);
              goto LABEL_119;
            }
          }
          for (i = 0; i != v55; ++i)
          {
            *(_QWORD *)&v159 = operator new(0xFD8uLL);
            std::__split_buffer<zip_entry_t *>::push_front((uint64_t)v5, &v159);
            v41 = *(char **)(v4 + 160);
            if (&v41[-*(_QWORD *)(v4 + 152)] == (char *)8)
              v110 = 38;
            else
              v110 = 39;
            v111 = v110 + *(_QWORD *)(v4 + 176);
            *(_QWORD *)(v4 + 176) = v111;
          }
          v54 = v53;
        }
        else
        {
LABEL_119:
          v111 = *(_QWORD *)(v4 + 176);
        }
        for (*(_QWORD *)(v4 + 176) = v111 - 39 * v54; v54; --v54)
        {
          v112 = *(_QWORD **)(v4 + 152);
          v115 = *v112;
          v113 = (char *)(v112 + 1);
          v114 = v115;
          *(_QWORD *)(v4 + 152) = v113;
          if (v41 == *(char **)(v4 + 168))
          {
            v116 = (uint64_t)&v113[-*v5];
            if ((unint64_t)v113 <= *v5)
            {
              if (v41 == (char *)*v5)
                v123 = 1;
              else
                v123 = (uint64_t)&v41[-*v5] >> 2;
              v124 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<zip_entry_t *>>(v123);
              v126 = &v124[8 * (v123 >> 2)];
              v127 = *(uint64_t **)(v4 + 152);
              v41 = v126;
              v128 = *(_QWORD *)(v4 + 160) - (_QWORD)v127;
              if (v128)
              {
                v41 = &v126[v128 & 0xFFFFFFFFFFFFFFF8];
                v129 = 8 * (v128 >> 3);
                v130 = &v124[8 * (v123 >> 2)];
                do
                {
                  v131 = *v127++;
                  *(_QWORD *)v130 = v131;
                  v130 += 8;
                  v129 -= 8;
                }
                while (v129);
              }
              v132 = *(void **)(v4 + 144);
              *(_QWORD *)(v4 + 144) = v124;
              *(_QWORD *)(v4 + 152) = v126;
              *(_QWORD *)(v4 + 160) = v41;
              *(_QWORD *)(v4 + 168) = &v124[8 * v125];
              if (v132)
              {
                operator delete(v132);
                v41 = *(char **)(v4 + 160);
              }
            }
            else
            {
              v117 = v116 >> 3;
              v73 = v116 >> 3 < -1;
              v118 = (v116 >> 3) + 2;
              if (v73)
                v119 = v118;
              else
                v119 = v117 + 1;
              v120 = &v113[-8 * (v119 >> 1)];
              v121 = v41 - v113;
              if (v41 != v113)
              {
                memmove(&v113[-8 * (v119 >> 1)], v113, v41 - v113);
                v41 = *(char **)(v4 + 152);
              }
              v122 = &v41[-8 * (v119 >> 1)];
              v41 = &v120[v121];
              *(_QWORD *)(v4 + 152) = v122;
              *(_QWORD *)(v4 + 160) = &v120[v121];
            }
          }
          *(_QWORD *)v41 = v114;
          v41 = (char *)(*(_QWORD *)(v4 + 160) + 8);
          *(_QWORD *)(v4 + 160) = v41;
        }
      }
      else
      {
        if (v56 >> 2 <= v55 + v43)
          v57 = v55 + v43;
        else
          v57 = v56 >> 2;
        v58 = v43 - v54;
        v161 = v4 + 168;
        if (v57)
          v57 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<zip_entry_t *>>(v57);
        else
          v59 = 0;
        v154 = -39 * v54;
        v155 = v47;
        *(_QWORD *)&v159 = v57;
        *((_QWORD *)&v159 + 1) = v57 + 8 * v58;
        *(_QWORD *)&v160 = *((_QWORD *)&v159 + 1);
        *((_QWORD *)&v160 + 1) = v57 + 8 * v59;
        do
        {
          v158 = operator new(0xFD8uLL);
          std::__split_buffer<zip_entry_t *>::push_back(&v159, &v158);
          --v55;
        }
        while (v55);
        v89 = *(_QWORD **)(v4 + 152);
        if (v54)
        {
          v90 = (char *)v160;
          do
          {
            if (v90 == *((char **)&v160 + 1))
            {
              v91 = (char *)*((_QWORD *)&v159 + 1);
              v92 = (void *)v159;
              if (*((_QWORD *)&v159 + 1) <= (unint64_t)v159)
              {
                if (v90 == (char *)v159)
                  v98 = 1;
                else
                  v98 = (uint64_t)&v90[-v159] >> 2;
                v99 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<zip_entry_t *>>(v98);
                v102 = v90 - v91;
                v101 = v90 == v91;
                v90 = &v99[8 * (v98 >> 2)];
                if (!v101)
                {
                  v90 = &v99[8 * (v98 >> 2) + (v102 & 0xFFFFFFFFFFFFFFF8)];
                  v103 = 8 * (v102 >> 3);
                  v104 = &v99[8 * (v98 >> 2)];
                  do
                  {
                    v105 = *(_QWORD *)v91;
                    v91 += 8;
                    *(_QWORD *)v104 = v105;
                    v104 += 8;
                    v103 -= 8;
                  }
                  while (v103);
                }
                *(_QWORD *)&v159 = v99;
                *((_QWORD *)&v159 + 1) = &v99[8 * (v98 >> 2)];
                *(_QWORD *)&v160 = v90;
                *((_QWORD *)&v160 + 1) = &v99[8 * v100];
                if (v92)
                  operator delete(v92);
              }
              else
              {
                v93 = (uint64_t)(*((_QWORD *)&v159 + 1) - v159) >> 3;
                if (v93 >= -1)
                  v94 = v93 + 1;
                else
                  v94 = v93 + 2;
                v95 = *((_QWORD *)&v159 + 1) - 8 * (v94 >> 1);
                v96 = &v90[-*((_QWORD *)&v159 + 1)];
                if (v90 != *((char **)&v159 + 1))
                {
                  memmove((void *)(*((_QWORD *)&v159 + 1) - 8 * (v94 >> 1)), *((const void **)&v159 + 1), (size_t)&v90[-*((_QWORD *)&v159 + 1)]);
                  v90 = v91;
                }
                v97 = &v90[-8 * (v94 >> 1)];
                v90 = &v96[v95];
                *((_QWORD *)&v159 + 1) = v97;
                *(_QWORD *)&v160 = &v96[v95];
              }
            }
            *(_QWORD *)v90 = *v89;
            v90 = (char *)(v160 + 8);
            *(_QWORD *)&v160 = v160 + 8;
            v89 = (_QWORD *)(*(_QWORD *)(v4 + 152) + 8);
            *(_QWORD *)(v4 + 152) = v89;
            --v54;
          }
          while (v54);
        }
        v106 = *(_QWORD **)(v4 + 160);
        if (v106 != v89)
        {
          do
            std::__split_buffer<zip_entry_t *>::push_front((uint64_t)&v159, --v106);
          while (v106 != *(_QWORD **)(v4 + 152));
        }
        v107 = *(void **)(v4 + 144);
        v108 = v160;
        *(_OWORD *)(v4 + 144) = v159;
        *(_OWORD *)(v4 + 160) = v108;
        v47 = v155;
        *(_QWORD *)(v4 + 176) += v154;
        if (v107)
        {
          operator delete(v107);
          v41 = *(char **)(v4 + 160);
        }
        else
        {
          v41 = (char *)v108;
        }
      }
    }
    v46 = *(_QWORD *)(v4 + 184);
    v42 = *(char **)(v4 + 152);
    v48 = *(_QWORD *)(v4 + 176) + v46;
  }
  v133 = &v42[8 * (v48 / 0x27)];
  if (v41 == v42)
    v134 = 0;
  else
    v134 = *(_QWORD *)v133 + 104 * (v48 % 0x27);
  *(_QWORD *)&v159 = &v42[8 * (v48 / 0x27)];
  *((_QWORD *)&v159 + 1) = v134;
  std::__deque_iterator<zip_entry_t,zip_entry_t const*,zip_entry_t const&,zip_entry_t const* const*,long,39l>::operator+=[abi:nn180100](&v159, v47);
  v135 = *((_QWORD *)&v159 + 1);
  if (v134 != *((_QWORD *)&v159 + 1))
  {
    v136 = (char *)v159;
    do
    {
      if (v133 == v136)
        v137 = v135;
      else
        v137 = *(_QWORD *)v133 + 4056;
      if (v134 == v137)
      {
        v137 = v134;
        v145 = (_QWORD *)(v4 + 184);
      }
      else
      {
        v138 = v134 + 8;
        do
        {
          *(_QWORD *)(v138 - 8) = *(_QWORD *)v19;
          v139 = v138 - 8;
          if (*(char *)(v19 + 31) < 0)
          {
            std::string::__init_copy_ctor_external((std::string *)v138, *(const std::string::value_type **)(v19 + 8), *(_QWORD *)(v19 + 16));
          }
          else
          {
            v140 = *(_OWORD *)(v19 + 8);
            *(_QWORD *)(v138 + 16) = *(_QWORD *)(v19 + 24);
            *(_OWORD *)v138 = v140;
          }
          *(_OWORD *)(v138 + 24) = *(_OWORD *)(v19 + 32);
          v141 = *(_OWORD *)(v19 + 48);
          v142 = *(_OWORD *)(v19 + 64);
          v143 = *(_OWORD *)(v19 + 80);
          *(_WORD *)(v138 + 88) = *(_WORD *)(v19 + 96);
          *(_OWORD *)(v138 + 56) = v142;
          *(_OWORD *)(v138 + 72) = v143;
          *(_OWORD *)(v138 + 40) = v141;
          v19 += 104;
          if (v19 - *v18 == 4056)
          {
            v144 = v18[1];
            ++v18;
            v19 = v144;
          }
          v138 += 104;
        }
        while (v139 + 104 != v137);
        v145 = (_QWORD *)(v4 + 184);
        v46 = *v157;
      }
      v46 += 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v137 - v134) >> 3);
      *v145 = v46;
      if (v133 == v136)
        break;
      v146 = *((_QWORD *)v133 + 1);
      v133 += 8;
      v134 = v146;
    }
    while (v146 != v135);
  }
LABEL_159:
  v147 = *(_QWORD *)(v4 + 152);
  if (*(_QWORD *)(v4 + 160) != v147)
  {
    v148 = *(_QWORD *)(v4 + 176);
    v149 = (_QWORD *)(v147 + 8 * (v148 / 0x27));
    v150 = (uint64_t *)(*v149 + 104 * (v148 % 0x27));
    v151 = *(_QWORD *)(v147 + 8 * ((*(_QWORD *)(v4 + 184) + v148) / 0x27))
         + 104 * ((*(_QWORD *)(v4 + 184) + v148) % 0x27);
    while (v150 != (uint64_t *)v151)
    {
      *v150 = v4;
      v150 += 13;
      if ((uint64_t *)((char *)v150 - *v149) == (uint64_t *)4056)
      {
        v152 = (uint64_t *)v149[1];
        ++v149;
        v150 = v152;
      }
    }
  }
  *(_DWORD *)(v4 + 192) = *(_DWORD *)(v156 + 192);
  return v4;
}

uint64_t zip_find_central_directory(_QWORD *a1)
{
  void **v2;
  void **v3;
  _QWORD *v4;
  unint64_t v5;
  void **v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _BOOL4 v18;
  uint64_t i;
  unint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  int v34[10];
  uint64_t v35;
  uint64_t v36;
  char v37[8];
  uint64_t v38;
  char v39[12];
  unsigned int v40;
  unsigned int v41;
  unsigned __int16 size;
  _DWORD size_2[3];

  if ((*((_BYTE *)a1 + 137) & 1) == 0)
    return 0;
  *((_BYTE *)a1 + 137) &= ~2u;
  v2 = (void **)a1[19];
  v3 = (void **)a1[20];
  if (v3 == v2)
  {
    v4 = a1 + 23;
    v3 = (void **)a1[19];
  }
  else
  {
    v4 = a1 + 23;
    v5 = a1[22];
    v6 = &v2[v5 / 0x27];
    v7 = (unint64_t)*v6;
    v8 = (unint64_t)*v6 + 104 * (v5 % 0x27);
    v9 = (unint64_t)v2[(a1[23] + v5) / 0x27] + 104 * ((a1[23] + v5) % 0x27);
    if (v8 != v9)
    {
      do
      {
        if (*(char *)(v8 + 31) < 0)
        {
          operator delete(*(void **)(v8 + 8));
          v7 = (unint64_t)*v6;
        }
        v8 += 104;
        if (v8 - v7 == 4056)
        {
          v10 = (unint64_t)v6[1];
          ++v6;
          v7 = v10;
          v8 = v10;
        }
      }
      while (v8 != v9);
      v2 = (void **)a1[19];
      v3 = (void **)a1[20];
    }
  }
  *v4 = 0;
  v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v12 = a1[20];
      v2 = (void **)(a1[19] + 8);
      a1[19] = v2;
      v11 = v12 - (_QWORD)v2;
    }
    while (v11 > 0x10);
  }
  if (v11 >> 3 == 1)
  {
    v13 = 19;
  }
  else
  {
    if (v11 >> 3 != 2)
      goto LABEL_18;
    v13 = 39;
  }
  a1[22] = v13;
LABEL_18:
  v14 = ((uint64_t (*)(_QWORD, _QWORD, uint64_t))a1[1])(*a1, 0, 2);
  if (v14 >= 0x16)
  {
    v15 = v14;
    v16 = 0;
    if (v14 - 22 >= 0x10000)
      v17 = 0x10000;
    else
      v17 = v14 - 22;
    v18 = 1;
    for (i = -22; ; --i)
    {
      size_2[0] = 0;
      ((void (*)(_QWORD, unint64_t, _QWORD))a1[1])(*a1, v15 + i, 0);
      if (((uint64_t (*)(_QWORD, _DWORD *, uint64_t))a1[2])(*a1, size_2, 4) != 4)
        goto LABEL_42;
      if (size_2[0] == 101010256)
        break;
      v18 = v16 < v17;
      if (v17 + 1 == ++v16)
        return 0;
    }
    v21 = v15 + i;
    ((void (*)(_QWORD, unint64_t, _QWORD))a1[1])(*a1, v15 + i, 0);
    v22 = ((uint64_t (*)(_QWORD, char *, uint64_t))a1[2])(*a1, v39, 22);
    v23 = 0;
    if (v22 != 22)
      return v18 & v23;
    v24 = size;
    if (!size)
      goto LABEL_33;
    v25 = malloc_type_malloc(size, 0xC2A086EBuLL);
    if (*((_BYTE *)a1 + 88))
      free((void *)a1[9]);
    a1[9] = v25;
    a1[10] = v24;
    *((_BYTE *)a1 + 88) = 1;
    if (((uint64_t (*)(_QWORD, void *, uint64_t))a1[2])(*a1, v25, v24) == a1[10])
    {
LABEL_33:
      if (v21 < 0x14)
      {
        v26 = 0;
      }
      else
      {
        v26 = v15 - v16 - 42;
        ((void (*)(_QWORD, uint64_t, _QWORD))a1[1])(*a1, v26, 0);
        v27 = ((uint64_t (*)(_QWORD, _DWORD *, uint64_t))a1[2])(*a1, size_2, 4);
        v23 = 0;
        if (v27 != 4)
          return v18 & v23;
      }
      if (size_2[0] != 117853008)
      {
        ((void (*)(_QWORD, _QWORD, _QWORD))a1[1])(*a1, v41, 0);
        v31 = ((uint64_t (*)(_QWORD, _DWORD *, uint64_t))a1[2])(*a1, size_2, 4);
        v23 = 0;
        if (v31 != 4)
          return v18 & v23;
        if (size_2[0] == 33639248)
        {
          v28 = v41;
          v32 = v40;
          a1[6] = v41;
          v30 = v32 + v28;
        }
        else
        {
          v33 = v40;
          v28 = v15 - v40 - v16 - 22;
          a1[6] = v28;
          v30 = v15 + v33 - v16 - 22;
        }
LABEL_48:
        a1[7] = v28;
        a1[8] = v30;
        v23 = 1;
        return v18 & v23;
      }
      ((void (*)(_QWORD, uint64_t, _QWORD))a1[1])(*a1, v26, 0);
      if (((uint64_t (*)(_QWORD, char *, uint64_t))a1[2])(*a1, v37, 20) == 20)
      {
        ((void (*)(_QWORD, uint64_t, _QWORD))a1[1])(*a1, v38, 0);
        if (((uint64_t (*)(_QWORD, int *, uint64_t))a1[2])(*a1, v34, 56) == 56 && v34[0] == 101075792)
        {
          v29 = v35;
          v28 = v36;
          a1[6] = v36;
          v30 = v29 + v28;
          goto LABEL_48;
        }
      }
    }
LABEL_42:
    v23 = 0;
    return v18 & v23;
  }
  return 0;
}

unint64_t zip_load_entry_from_central_directory(_QWORD *a1)
{
  unint64_t v2;
  unint64_t v4;
  void **v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int8x16_t v16;
  uint64_t v17;
  unint64_t v18;
  unsigned __int16 v19;
  unsigned __int16 v20;
  _WORD v21[8];
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned __int16 __len;
  unsigned __int16 __len_2;
  unsigned __int16 __len_4;
  unsigned int v28;
  __int128 __b;
  uint64_t v30;
  _QWORD *v31;
  void *__p[2];
  __int128 v33;
  int8x16_t v34;
  _DWORD v35[10];
  __int16 v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  if (!a1[6])
    return 0;
  if ((*((_BYTE *)a1 + 137) & 1) == 0)
    return 0;
  v2 = a1[7];
  if (v2 >= a1[8])
    return 0;
  ((void (*)(_QWORD, _QWORD, _QWORD))a1[1])(*a1, a1[7], 0);
  if (((uint64_t (*)(_QWORD, _WORD *, uint64_t))a1[2])(*a1, v21, 46) != 46 || *(_DWORD *)v21 != 33639248)
    return 0;
  v31 = a1;
  *(_OWORD *)__p = 0u;
  v33 = 0u;
  v34 = 0u;
  memset(v35, 0, 36);
  std::string::basic_string[abi:nn180100](&__b, __len, 0);
  if (SBYTE7(v33) < 0)
    operator delete(__p[0]);
  *(_QWORD *)&v33 = v30;
  *(_OWORD *)__p = __b;
  v36 = v21[7];
  v35[0] = v22;
  v35[9] = *(_DWORD *)&v21[5];
  if (v30 >= 0)
    v6 = __p;
  else
    v6 = (void **)__p[0];
  v7 = ((uint64_t (*)(_QWORD, void **, _QWORD))a1[2])(*a1, v6, __len);
  if (v7 == __len)
  {
    v8 = v2 + v7 + 46;
    v9 = v8 + __len_2;
    if (v8 < v9)
    {
      v10 = 0;
      while (1)
      {
        if (((uint64_t (*)(_QWORD, unsigned __int16 *, uint64_t))a1[2])(*a1, &v19, 4) != 4)
          goto LABEL_41;
        if (v19 == 65534)
          break;
        if (v19 == 1)
        {
          __b = 0uLL;
          v30 = 0;
          if (v20 >= 0x18u)
            v11 = 24;
          else
            v11 = v20;
          if (((uint64_t (*)(_QWORD, __int128 *, uint64_t))a1[2])(*a1, &__b, v11) != v11 || v20 < 8u)
            goto LABEL_41;
          if (v24 == -1)
          {
            v34.i64[0] = __b;
            v12 = 1;
          }
          else
          {
            v12 = 0;
          }
          v13 = (unint64_t)v20 >> 3;
          if (v23 == -1)
          {
            if (v12 >= v13)
              goto LABEL_41;
            v14 = *((_QWORD *)&__b + v12++);
            v34.i64[1] = v14;
          }
          if (v28 == -1)
          {
            if (v12 >= v13)
              goto LABEL_41;
            *((_QWORD *)&v33 + 1) = *((_QWORD *)&__b + v12);
          }
          v8 += v20 + 4;
          v10 = 1;
          if (v8 >= v9)
            goto LABEL_46;
        }
        else
        {
LABEL_30:
          v8 += v20 + 4;
          if (v8 >= v9)
          {
            if ((v10 & 1) != 0)
              goto LABEL_46;
            goto LABEL_43;
          }
        }
      }
      if (v20 != 32 || ((uint64_t (*)(_QWORD, _DWORD *, uint64_t))a1[2])(*a1, &v35[1], 32) != 32)
        goto LABEL_41;
      goto LABEL_30;
    }
LABEL_43:
    v15 = v28;
    v16.i64[0] = v23;
    v16.i64[1] = v24;
    v34 = vextq_s8(v16, v16, 8uLL);
    v17 = a1[16];
    if (a1[15] > (unint64_t)v28)
      a1[16] = ++v17;
    *((_QWORD *)&v33 + 1) = v15 | (v17 << 32);
    a1[15] = v15;
LABEL_46:
    a1[7] += __len + (unint64_t)__len_2 + __len_4 + 46;
    std::deque<zip_entry_t>::push_back(a1 + 18, (uint64_t)&v31);
    v18 = a1[23] + a1[22] - 1;
    v4 = *(_QWORD *)(a1[19] + 8 * (v18 / 0x27)) + 104 * (v18 % 0x27);
  }
  else
  {
LABEL_41:
    v4 = 0;
  }
  if (SBYTE7(v33) < 0)
    operator delete(__p[0]);
  return v4;
}

__n128 std::deque<zip_entry_t>::push_back(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  __int128 v9;
  __n128 result;
  __int128 v11;
  __int128 v12;

  v4 = a1[2];
  v5 = a1[1];
  v6 = 39 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5)
    v6 = 0;
  v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<zip_entry_t>::__add_back_capacity(a1);
    v5 = a1[1];
    v7 = a1[5] + a1[4];
  }
  v8 = *(_QWORD *)(v5 + 8 * (v7 / 0x27)) + 104 * (v7 % 0x27);
  *(_QWORD *)v8 = *(_QWORD *)a2;
  v9 = *(_OWORD *)(a2 + 8);
  *(_QWORD *)(v8 + 24) = *(_QWORD *)(a2 + 24);
  *(_OWORD *)(v8 + 8) = v9;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 24) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_OWORD *)(v8 + 32) = *(_OWORD *)(a2 + 32);
  v11 = *(_OWORD *)(a2 + 64);
  result = *(__n128 *)(a2 + 80);
  v12 = *(_OWORD *)(a2 + 48);
  *(_WORD *)(v8 + 96) = *(_WORD *)(a2 + 96);
  *(_OWORD *)(v8 + 64) = v11;
  *(__n128 *)(v8 + 80) = result;
  *(_OWORD *)(v8 + 48) = v12;
  ++a1[5];
  return result;
}

{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  std::string *v11;
  __int128 v12;
  uint64_t v13;
  __n128 result;
  __int128 v15;
  __int128 v16;

  v4 = a1[2];
  v5 = a1[1];
  v6 = 39 * ((v4 - v5) >> 3) - 1;
  if (v4 == v5)
    v6 = 0;
  v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<zip_entry_t>::__add_back_capacity(a1);
    v5 = a1[1];
    v7 = a1[5] + a1[4];
  }
  v8 = *(_QWORD *)(v5 + 8 * (v7 / 0x27));
  v9 = v7 % 0x27;
  v10 = (_QWORD *)(v8 + 104 * (v7 % 0x27));
  *v10 = *(_QWORD *)a2;
  v11 = (std::string *)(v10 + 1);
  if (*(char *)(a2 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)(a2 + 8), *(_QWORD *)(a2 + 16));
  }
  else
  {
    v12 = *(_OWORD *)(a2 + 8);
    v11->__r_.__value_.__r.__words[2] = *(_QWORD *)(a2 + 24);
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v12;
  }
  v13 = v8 + 104 * v9;
  *(_OWORD *)(v13 + 32) = *(_OWORD *)(a2 + 32);
  result = *(__n128 *)(a2 + 48);
  v15 = *(_OWORD *)(a2 + 64);
  v16 = *(_OWORD *)(a2 + 80);
  *(_WORD *)(v13 + 96) = *(_WORD *)(a2 + 96);
  *(_OWORD *)(v13 + 64) = v15;
  *(_OWORD *)(v13 + 80) = v16;
  *(__n128 *)(v13 + 48) = result;
  ++a1[5];
  return result;
}

uint64_t zip_load_all_from_central_directory(_QWORD *a1)
{
  uint64_t v2;

  if (!zip_find_central_directory(a1))
    return 0;
  v2 = -1;
  do
    ++v2;
  while (zip_load_entry_from_central_directory(a1));
  return v2;
}

unint64_t zip_load_entry_from_file_header(_QWORD *a1)
{
  uint64_t v2;
  BOOL v3;
  unint64_t v4;
  int8x16_t v6;
  void **v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  unint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  unsigned __int16 v33;
  unsigned __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  unsigned int v40;
  unsigned int v41;
  _WORD __len[11];
  uint64_t v43;
  _QWORD *v44;
  void *__p[2];
  uint64_t v46;
  uint64_t v47;
  int8x16_t v48;
  _OWORD v49[2];
  int v50;
  int v51;
  __int16 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  if ((*((_BYTE *)a1 + 137) & 2) == 0)
    return 0;
  *((_BYTE *)a1 + 137) &= ~1u;
  v2 = a1[7];
  ((void (*)(_QWORD, uint64_t, _QWORD))a1[1])(*a1, v2, 0);
  v3 = ((uint64_t (*)(_QWORD, int *, uint64_t))a1[2])(*a1, &v35, 30) == 30 && v35 == 67324752;
  if (!v3)
    return 0;
  v44 = a1;
  v46 = 0;
  *(_OWORD *)__p = 0u;
  v48 = 0u;
  memset(v49, 0, sizeof(v49));
  v50 = 0;
  v47 = v2;
  std::string::basic_string[abi:nn180100](&__len[3], __len[0], 0);
  if (SHIBYTE(v46) < 0)
    operator delete(__p[0]);
  v46 = v43;
  *(_OWORD *)__p = *(_OWORD *)&__len[3];
  v52 = v38;
  LODWORD(v49[0]) = v39;
  v51 = v37;
  v6.i64[0] = v40;
  v6.i64[1] = v41;
  v48 = vextq_s8(v6, v6, 8uLL);
  if (v43 >= 0)
    v7 = __p;
  else
    v7 = (void **)__p[0];
  v8 = ((uint64_t (*)(_QWORD, void **, _QWORD))a1[2])(*a1, v7, __len[0]);
  v9 = __len[0];
  if (v8 == __len[0])
  {
    v10 = v2 + v8 + 30;
    v11 = __len[1];
    v12 = v10 + __len[1];
    if (v10 >= v12)
    {
LABEL_26:
      v13 = v9 + v11 + 30;
      if ((v36 & 8) == 0)
      {
        v14 = v48.i64[1] + v13 + a1[7];
        a1[7] = v14;
LABEL_28:
        a1[6] = v14;
        std::deque<zip_entry_t>::push_back(a1 + 18, (uint64_t)&v44);
        v15 = a1[23] + a1[22] - 1;
        v4 = *(_QWORD *)(a1[19] + 8 * (v15 / 0x27)) + 104 * (v15 % 0x27);
        goto LABEL_34;
      }
      v16 = (char *)malloc_type_malloc(0x10000uLL, 0xC2A086EBuLL);
      v17 = ((uint64_t (*)(_QWORD, _QWORD, uint64_t))a1[1])(*a1, 0, 2);
      if (v17 - v47 >= 8 && (*((_BYTE *)a1 + 137) & 2) != 0)
      {
        v18 = v17;
        v19 = v47 + v13;
        if (v19 + 28 <= v17)
        {
          do
          {
            v20 = v18 - v19 >= 0x10000 ? 0x10000 : v18 - v19;
            ((void (*)(_QWORD, uint64_t, _QWORD))a1[1])(*a1, v19, 0);
            if (((uint64_t (*)(_QWORD, char *, unint64_t))a1[2])(*a1, v16, v20) != v20)
              break;
            if (v20 >= 0x1D)
            {
              v21 = 0;
              v22 = -v19;
              v23 = v16;
              v24 = v20;
              while (1)
              {
                if (*(_DWORD *)&v16[v21] == 134695760)
                {
                  v25 = v21 + 4;
                  v26 = 4;
                  while (1)
                  {
                    v27 = *(_DWORD *)&v23[v26];
                    if (v27 == 33639248 || v27 == 67324752)
                      break;
                    if (v24 == ++v26)
                      goto LABEL_51;
                  }
                  if (v24 != v26)
                    break;
                }
LABEL_51:
                --v22;
                --v24;
                ++v23;
                v3 = v21++ == v20 - 29;
                if (v3)
                  goto LABEL_53;
              }
              a1[7] = v26 - v22;
              if (v26 == 24)
              {
                v30 = *(_DWORD *)&v16[v25];
                v31 = *(_QWORD *)&v16[v25 + 4];
                v32 = *(_QWORD *)&v16[v25 + 12];
              }
              else
              {
                if (v26 != 16)
                  break;
                v30 = *(_DWORD *)&v16[v25];
                v31 = *(unsigned int *)&v16[v25 + 4];
                v32 = *(unsigned int *)&v16[v25 + 8];
              }
              LODWORD(v49[0]) = v30;
              v48.i64[0] = v32;
              v48.i64[1] = v31;
              ((void (*)(_QWORD))a1[1])(*a1);
              free(v16);
              v14 = a1[7];
              goto LABEL_28;
            }
LABEL_53:
            v29 = v20 + v19;
            v19 = v20 + v19 - 28;
          }
          while (v29 <= v18);
        }
      }
      free(v16);
    }
    else
    {
      while (((uint64_t (*)(_QWORD, unsigned __int16 *, uint64_t))a1[2])(*a1, &v33, 4) == 4)
      {
        if (v33 == 1)
        {
          *(_OWORD *)&__len[3] = 0uLL;
          if (v34 < 0x10u || ((uint64_t (*)(_QWORD, _WORD *, uint64_t))a1[2])(*a1, &__len[3], 16) != 16)
            break;
          v48 = *(int8x16_t *)&__len[3];
        }
        else if (v33 == 65534
               && (v34 != 32
                || ((uint64_t (*)(_QWORD, char *, uint64_t))a1[2])(*a1, (char *)v49 + 4, 32) != 32))
        {
          break;
        }
        v10 += v34 + 4;
        if (v10 >= v12)
        {
          v9 = __len[0];
          v11 = __len[1];
          goto LABEL_26;
        }
      }
    }
  }
  v4 = 0;
LABEL_34:
  if (SHIBYTE(v46) < 0)
    operator delete(__p[0]);
  return v4;
}

unint64_t zip_create_entry(_QWORD *a1, uint64_t a2, __int16 a3)
{
  unint64_t v5;
  unint64_t v6;
  _QWORD *v8;
  void *__p[2];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _WORD v13[13];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  memset(v13, 0, sizeof(v13));
  v12 = 0u;
  v11 = 0u;
  v10 = 0u;
  *(_OWORD *)__p = 0u;
  v8 = a1;
  MEMORY[0x227692F50](__p);
  *((_QWORD *)&v10 + 1) = -1;
  v11 = 0u;
  v12 = 0u;
  memset(v13, 0, 20);
  v13[10] = a3;
  *(_DWORD *)&v13[11] = 0;
  if (SBYTE7(v10) < 0 && (unint64_t)__p[1] >> 16)
  {
    v5 = 0;
LABEL_5:
    operator delete(__p[0]);
    return v5;
  }
  std::deque<zip_entry_t>::push_back(a1 + 18, (uint64_t)&v8);
  v6 = a1[23] + a1[22] - 1;
  v5 = *(_QWORD *)(a1[19] + 8 * (v6 / 0x27)) + 104 * (v6 % 0x27);
  if (SBYTE7(v10) < 0)
    goto LABEL_5;
  return v5;
}

_WORD *zip_append_entry(_QWORD *a1, uint64_t a2, __int16 a3, Bytef *a4, unint64_t a5)
{
  _WORD *result;
  _WORD *v8;

  result = (_WORD *)zip_create_entry(a1, a2, a3);
  if (result)
  {
    v8 = result;
    if (zip_entry_save_data(result, a4, a5))
      return v8;
    else
      return 0;
  }
  return result;
}

uint64_t zip_save_central_directory(_QWORD *a1)
{
  uint64_t v1;
  unint64_t entry;
  uint64_t result;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  int v14;
  _QWORD *v15;
  int v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  _BOOL4 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  BOOL v35;
  BOOL v36;
  int v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  _BYTE v46[12];
  int v47;
  uint64_t v48;
  unint64_t v49;
  __int128 v50;
  unint64_t v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;

  v54 = *MEMORY[0x24BDAC8D0];
  v1 = a1[14];
  if (!v1)
    return 1;
  if (a1[6] % a1[13])
  {
    *((_BYTE *)a1 + 137) &= 0xFCu;
    entry = zip_create_entry(a1, (uint64_t)".align/", 0);
    *(_QWORD *)(entry + 32) = a1[6];
    result = (uint64_t)zip_write_file_header(entry, a1[13], 3);
    if (!result)
      return result;
    a1[6] += result;
    v1 = a1[14];
  }
  ((void (*)(_QWORD))a1[1])(*a1);
  v5 = a1[19];
  if (a1[20] == v5)
  {
    v8 = a1 + 23;
  }
  else
  {
    v6 = a1[22];
    v7 = *(_QWORD *)(v5 + 8 * (v6 / 0x27)) + 104 * (v6 % 0x27);
    v8 = a1 + 23;
    v9 = *(_QWORD *)(v5 + 8 * ((a1[23] + v6) / 0x27)) + 104 * ((a1[23] + v6) % 0x27);
    if (v7 != v9)
    {
      v10 = (_QWORD *)(v5 + 8 * (v6 / 0x27));
      while (1)
      {
        LODWORD(v11) = *(char *)(v7 + 31);
        if ((v11 & 0x80000000) != 0 && *(_QWORD *)(v7 + 16) >> 16)
          return 0;
        if (*((_BYTE *)a1 + 136) || *(_DWORD *)(v7 + 52) || *(_DWORD *)(v7 + 44))
          break;
        v31 = *(unsigned int *)(v7 + 36);
        *(_DWORD *)v46 = 33639248;
        *(_WORD *)&v46[4] = 4926;
        if (v31)
          goto LABEL_14;
        v13 = 0;
        v12 = 20;
LABEL_15:
        v11 = v11;
        *(_WORD *)&v46[6] = v12;
        *(_WORD *)&v46[8] = 0;
        *(_WORD *)&v46[10] = *(_WORD *)(v7 + 92);
        v14 = *(_DWORD *)(v7 + 56);
        v47 = *(_DWORD *)(v7 + 94);
        LODWORD(v48) = v14;
        if ((v11 & 0x80) != 0)
          v11 = *(unsigned __int16 *)(v7 + 16);
        v15 = (_QWORD *)(v7 + 8);
        WORD2(v49) = v11;
        LODWORD(v50) = 0;
        WORD2(v50) = 0;
        if (*(char *)(v7 + 31) < 0)
        {
          v17 = *(_QWORD *)(v7 + 16);
          v16 = -2119958528;
          if (v17)
          {
            v18 = (_QWORD *)*v15;
LABEL_22:
            if (*((_BYTE *)v18 + v17 - 1) == 47)
              v16 = 1107230720;
            else
              v16 = -2119958528;
          }
        }
        else
        {
          v16 = -2119958528;
          v17 = *(unsigned __int8 *)(v7 + 31);
          if (*(_BYTE *)(v7 + 31))
          {
            v18 = (_QWORD *)(v7 + 8);
            goto LABEL_22;
          }
        }
        *(_DWORD *)((char *)&v50 + 6) = v16;
        v19 = *(_QWORD *)(v7 + 60);
        v20 = *(_DWORD *)(v7 + 48);
        if (v13)
          v20 = -1;
        v21 = *(_DWORD *)(v7 + 40);
        if (v13)
          v21 = -1;
        HIDWORD(v48) = v20;
        LODWORD(v49) = v21;
        v22 = *(_DWORD *)(v7 + 32);
        v23 = 28;
        if (v13)
          v22 = -1;
        else
          v23 = 0;
        *(_DWORD *)((char *)&v50 + 10) = v22;
        v24 = v19 | *(_QWORD *)(v7 + 68) | *(_QWORD *)(v7 + 76) | *(_QWORD *)(v7 + 84);
        v35 = v24 == 0;
        v25 = v24 != 0;
        v26 = 36;
        if (v35)
          v26 = 0;
        v27 = v26 + v23;
        HIWORD(v49) = v27;
        if ((unint64_t)(v27 + v11) >> 16)
          return 0;
        v28 = ((uint64_t (*)(_QWORD, _BYTE *, uint64_t))a1[3])(*a1, v46, 46);
        a1[14] += v28;
        if (v28 != 46)
          return 0;
        if (*(char *)(v7 + 31) < 0)
          v15 = (_QWORD *)*v15;
        v29 = ((uint64_t (*)(_QWORD, _QWORD *, _QWORD))a1[3])(*a1, v15, WORD2(v49));
        a1[14] += v29;
        if (v29 != WORD2(v49))
          return 0;
        if (v13)
        {
          v52 = *(_OWORD *)(v7 + 40);
          v53 = *(_QWORD *)(v7 + 32);
          if (!zip_write_extra_field(a1, 1, (uint64_t)&v52, 24))
            return 0;
        }
        if (v25 && !zip_write_extra_field(a1, 65534, v7 + 60, 32))
          return 0;
        v7 += 104;
        if (v7 - *v10 == 4056)
        {
          v30 = v10[1];
          ++v10;
          v7 = v30;
        }
        if (v7 == v9)
        {
          v8 = a1 + 23;
          goto LABEL_51;
        }
      }
      *(_DWORD *)v46 = 33639248;
      *(_WORD *)&v46[4] = 4926;
LABEL_14:
      v12 = 45;
      v13 = 1;
      goto LABEL_15;
    }
  }
LABEL_51:
  v32 = a1[14] - v1;
  v33 = a1[6];
  v34 = v33 + v32;
  a1[8] = v33 + v32;
  if (*((_BYTE *)a1 + 136))
    v35 = 0;
  else
    v35 = HIDWORD(v33) == 0;
  v36 = v35 && HIDWORD(v32) == 0;
  v37 = !v36;
  v38 = a1[23];
  if (!v36)
  {
    *(_DWORD *)v46 = 101075792;
    *(_QWORD *)&v46[4] = -101075744;
    v48 = 0;
    v49 = v38;
    v47 = 2954046;
    *(_QWORD *)&v50 = v38;
    *((_QWORD *)&v50 + 1) = v32;
    v51 = v33;
    v39 = ((uint64_t (*)(_QWORD, _BYTE *, uint64_t))a1[3])(*a1, v46, 56);
    a1[14] += v39;
    if (v39 != 56)
      return 0;
    *(_QWORD *)&v52 = 117853008;
    *((_QWORD *)&v52 + 1) = v34;
    LODWORD(v53) = 1;
    v40 = ((uint64_t (*)(_QWORD, __int128 *, uint64_t))a1[3])(*a1, &v52, 20);
    a1[14] += v40;
    if (v40 != 20)
      return 0;
    v38 = *v8;
  }
  if (!(v38 >> 16))
  {
    v41 = a1[10];
    if (!(v41 >> 16))
    {
      *(_QWORD *)v46 = 101010256;
      *(_WORD *)&v46[8] = v38;
      *(_WORD *)&v46[10] = v38;
      v42 = v37 ? -1 : v32;
      v47 = v42;
      v43 = (v37 & 1) != 0 ? -1 : *((_DWORD *)a1 + 12);
      LODWORD(v48) = v43;
      WORD2(v48) = v41;
      v44 = ((uint64_t (*)(_QWORD, _BYTE *, uint64_t))a1[3])(*a1, v46, 22);
      a1[14] += v44;
      if (v44 == 22)
      {
        if (!a1[10]
          || (v45 = ((uint64_t (*)(_QWORD, _QWORD))a1[3])(*a1, a1[9]), a1[14] += v45, v45 == a1[10]))
        {
          a1[14] = 0;
          return 1;
        }
      }
    }
  }
  return 0;
}

BOOL zip_write_extra_field(_QWORD *a1, __int16 a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  _WORD v10[2];

  v10[0] = a2;
  v10[1] = a4;
  v7 = ((uint64_t (*)(_QWORD, _WORD *, uint64_t))a1[3])(*a1, v10, 4);
  a1[14] += v7;
  if (v7 != 4)
    return 0;
  v8 = ((uint64_t (*)(_QWORD, uint64_t, uint64_t))a1[3])(*a1, a3, a4);
  a1[14] += v8;
  return v8 == a4;
}

_QWORD **zip_clone_entry(uint64_t a1, _QWORD **a2)
{
  _OWORD *v4;
  BOOL v5;
  BOOL v7;
  int v8;
  _QWORD *v9;
  _QWORD **entry;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  void *v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  __int128 v24;
  char *v26;
  CC_SHA256_CTX c;
  unsigned __int8 md[16];
  __int128 v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v4 = (_OWORD *)((char *)a2 + 60);
  if (*(_QWORD **)((char *)a2 + 60))
    v5 = 0;
  else
    v5 = *(_QWORD **)((char *)a2 + 68) == 0;
  v7 = v5 && *(_QWORD **)((char *)a2 + 76) == 0 && *(_QWORD **)((char *)a2 + 84) == 0;
  v8 = !v7;
  if (!v7 || !*((_WORD *)a2 + 46))
  {
    *(_BYTE *)(a1 + 137) &= 0xFCu;
    v9 = a2 + 1;
    if (*((char *)a2 + 31) < 0)
      v9 = (_QWORD *)*v9;
    entry = (_QWORD **)zip_create_entry((_QWORD *)a1, (uint64_t)v9, *((_WORD *)a2 + 46));
    *(_OWORD *)(entry + 5) = *(_OWORD *)(a2 + 5);
    entry[4] = *(_QWORD **)(a1 + 48);
    *(_DWORD *)((char *)entry + 94) = *(_DWORD *)((char *)a2 + 94);
    *((_DWORD *)entry + 14) = *((_DWORD *)a2 + 14);
    v11 = v4[1];
    *(_OWORD *)((char *)entry + 60) = *v4;
    *(_OWORD *)((char *)entry + 76) = v11;
    v12 = zip_entry_data_offset(a2);
    if (v12)
    {
      v13 = v12;
      v14 = v12 - (_QWORD)a2[4];
      if (v14 <= 0x10000)
      {
        v15 = malloc_type_malloc(0x10000uLL, 0xC2A086EBuLL);
        ((void (*)(_QWORD, _QWORD *, _QWORD))(*a2)[1])(**a2, a2[4], 0);
        if (((uint64_t (*)(_QWORD, void *, unint64_t))(*a2)[2])(**a2, v15, v14) == v14)
        {
          ((void (*)(_QWORD, _QWORD *, _QWORD))(*entry)[1])(**entry, entry[4], 0);
          v16 = *entry;
          v17 = ((uint64_t (*)(_QWORD, void *, unint64_t))(*entry)[3])(**entry, v15, v14);
          v16[14] += v17;
          if (v17 == v14)
          {
            v18 = entry[4];
            CC_SHA256_Init(&c);
            if (!a2[6])
            {
LABEL_29:
              *(_QWORD *)(a1 + 48) += (char *)entry[6] + v14;
              if (!v8 && entry[5])
              {
                CC_SHA256_Final(md, &c);
                v24 = v29;
                *(_OWORD *)((char *)entry + 60) = *(_OWORD *)md;
                *(_OWORD *)((char *)entry + 76) = v24;
              }
              goto LABEL_35;
            }
            v19 = 0;
            v26 = (char *)v18 + v14;
            while (1)
            {
              ((void (*)(_QWORD, unint64_t, _QWORD))(*a2)[1])(**a2, v19 + v13, 0);
              v20 = (unint64_t)a2[6] - v19 >= 0x10000 ? 0x10000 : (uint64_t)a2[6] - v19;
              v21 = ((uint64_t (*)(_QWORD, void *, uint64_t))(*a2)[2])(**a2, v15, v20);
              ((void (*)(_QWORD, char *, _QWORD))(*entry)[1])(**entry, &v26[v19], 0);
              v22 = *entry;
              v23 = ((uint64_t (*)(_QWORD, void *, uint64_t))(*entry)[3])(**entry, v15, v21);
              v22[14] += v23;
              if (v21 != v23)
                break;
              if (!v8)
                CC_SHA256_Update(&c, v15, v21);
              v19 += v21;
              if (v19 >= (unint64_t)a2[6])
                goto LABEL_29;
            }
          }
        }
        entry = 0;
LABEL_35:
        free(v15);
        return entry;
      }
    }
  }
  return 0;
}

void *zip_set_comment(uint64_t a1, const void *a2, size_t size)
{
  void *v6;

  v6 = malloc_type_malloc(size, 0xC2A086EBuLL);
  if (*(_BYTE *)(a1 + 88))
    free(*(void **)(a1 + 72));
  *(_QWORD *)(a1 + 72) = v6;
  *(_QWORD *)(a1 + 80) = size;
  *(_BYTE *)(a1 + 88) = 1;
  return memcpy(v6, a2, size);
}

double zip_calculate_signature@<D0>(_QWORD *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  __int128 v14;
  BOOL v15;
  CC_LONG v18;
  double result;
  CC_SHA256_CTX c;
  __int128 data;
  __int128 v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v3 = a1[23];
  if (v3)
  {
    CC_SHA256_Init(&c);
    v5 = 0;
    while (1)
    {
      v6 = v5 + a1[22];
      v7 = *(_QWORD *)(a1[19] + 8 * (v6 / 0x27));
      v8 = v6 % 0x27;
      v9 = v7 + 104 * (v6 % 0x27);
      v10 = (const char *)(v9 + 8);
      if (*(char *)(v9 + 31) < 0)
      {
        v11 = *(_QWORD *)(v7 + 104 * v8 + 16);
        if (!v11)
          goto LABEL_9;
        v12 = *(const char **)v10;
      }
      else
      {
        v11 = *(unsigned __int8 *)(v9 + 31);
        if (!*(_BYTE *)(v9 + 31))
          goto LABEL_9;
        v12 = (const char *)(v9 + 8);
      }
      if (v12[v11 - 1] != 47)
      {
LABEL_9:
        data = 0u;
        v22 = 0u;
        v13 = v7 + 104 * v8;
        v14 = *(_OWORD *)(v13 + 76);
        data = *(_OWORD *)(v13 + 60);
        v22 = v14;
        if ((_QWORD)data)
          v15 = 0;
        else
          v15 = *((_QWORD *)&data + 1) == 0;
        if (v15 && (_QWORD)v14 == 0 && *((_QWORD *)&v14 + 1) == 0)
          break;
        if (*(char *)(v9 + 31) < 0)
          v10 = *(const char **)v10;
        v18 = strlen(v10);
        CC_SHA256_Update(&c, v10, v18);
        CC_SHA256_Update(&c, &data, 0x20u);
      }
      if (v3 == ++v5)
      {
        CC_SHA256_Final((unsigned __int8 *)a2, &c);
        return result;
      }
    }
  }
  result = 0.0;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  return result;
}

uint64_t zip_close(_QWORD *a1)
{
  uint64_t v2;
  void (*v3)(_QWORD);
  void **v4;

  v2 = zip_save_central_directory(a1);
  v3 = (void (*)(_QWORD))a1[4];
  if (v3)
    v3(*a1);
  std::deque<zip_entry_t>::~deque[abi:nn180100]((uint64_t)(a1 + 18));
  v4 = (void **)(a1 + 9);
  if (*((_BYTE *)a1 + 88))
    free(*v4);
  *v4 = 0;
  a1[10] = 0;
  *((_BYTE *)a1 + 88) = 0;
  MEMORY[0x2276933B8](a1, 0x1080C4077E95D12);
  return v2;
}

BOOL zip_verify_crc_archive(_QWORD *a1)
{
  Bytef *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  int *data_begin;
  unsigned int v13;
  unint64_t v14;
  uInt v15;
  unint64_t v16;
  int v17;
  unint64_t v18;

  v2 = (Bytef *)malloc_type_malloc(0x10000uLL, 0xC2A086EBuLL);
  v3 = a1[23];
  if (v3)
  {
    v4 = a1[22];
    v5 = *(_QWORD *)(a1[19] + 8 * (v4 / 0x27));
    if (v5)
    {
      v6 = 0;
      v7 = 0;
      v8 = v4 % 0x27;
      v9 = v5 + 104 * (v4 % 0x27);
      while (1)
      {
        v10 = (_QWORD *)(v5 + 104 * v8 + 8);
        if (*(char *)(v9 + 31) < 0)
        {
          v11 = *(_QWORD *)(v5 + 104 * v8 + 16);
          if (v11)
          {
            v10 = (_QWORD *)*v10;
LABEL_9:
            if (*((_BYTE *)v10 + v11 - 1) == 47)
              goto LABEL_16;
          }
        }
        else
        {
          v11 = *(unsigned __int8 *)(v9 + 31);
          if (*(_BYTE *)(v9 + 31))
            goto LABEL_9;
        }
        data_begin = (int *)zip_entry_load_data_begin(v9);
        v13 = crc32(0, 0, 0);
        v14 = zip_entry_load_data_read((uint64_t)v2, 0x10000uLL, (uint64_t)data_begin);
        if (v14)
        {
          v15 = v14;
          do
          {
            v13 = crc32(v13, v2, v15);
            v16 = zip_entry_load_data_read((uint64_t)v2, 0x10000uLL, (uint64_t)data_begin);
            v15 = v16;
          }
          while (v16);
        }
        v17 = *(_DWORD *)(v5 + 104 * v8 + 56);
        if (data_begin)
          zip_entry_load_data_end(data_begin);
        if (v17 != v13)
          goto LABEL_21;
LABEL_16:
        v7 = ++v6 >= v3;
        if (v6 != v3)
        {
          v18 = a1[22] + v6;
          v5 = *(_QWORD *)(a1[19] + 8 * (v18 / 0x27));
          v8 = v18 % 0x27;
          v9 = v5 + 104 * (v18 % 0x27);
          if (v5)
            continue;
        }
        goto LABEL_21;
      }
    }
    v7 = 0;
  }
  else
  {
    v7 = 1;
  }
LABEL_21:
  free(v2);
  return v7;
}

uint64_t std::deque<zip_entry_t>::~deque[abi:nn180100](uint64_t a1)
{
  void **v2;
  void **v3;
  _QWORD *v4;
  unint64_t v5;
  void **v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;

  v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    v4 = (_QWORD *)(a1 + 40);
    v3 = *(void ***)(a1 + 8);
  }
  else
  {
    v4 = (_QWORD *)(a1 + 40);
    v5 = *(_QWORD *)(a1 + 32);
    v6 = &v2[v5 / 0x27];
    v7 = (unint64_t)*v6;
    v8 = (unint64_t)*v6 + 104 * (v5 % 0x27);
    v9 = (unint64_t)v2[(*(_QWORD *)(a1 + 40) + v5) / 0x27] + 104 * ((*(_QWORD *)(a1 + 40) + v5) % 0x27);
    if (v8 != v9)
    {
      do
      {
        if (*(char *)(v8 + 31) < 0)
        {
          operator delete(*(void **)(v8 + 8));
          v7 = (unint64_t)*v6;
        }
        v8 += 104;
        if (v8 - v7 == 4056)
        {
          v10 = (unint64_t)v6[1];
          ++v6;
          v7 = v10;
          v8 = v10;
        }
      }
      while (v8 != v9);
      v2 = *(void ***)(a1 + 8);
      v3 = *(void ***)(a1 + 16);
    }
  }
  *v4 = 0;
  v11 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = *(void ***)(a1 + 16);
      v2 = (void **)(*(_QWORD *)(a1 + 8) + 8);
      *(_QWORD *)(a1 + 8) = v2;
      v11 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v12 = v11 >> 3;
  if (v12 == 1)
  {
    v13 = 19;
    goto LABEL_16;
  }
  if (v12 == 2)
  {
    v13 = 39;
LABEL_16:
    *(_QWORD *)(a1 + 32) = v13;
  }
  if (v2 != v3)
  {
    do
    {
      v14 = *v2++;
      operator delete(v14);
    }
    while (v2 != v3);
    v16 = *(_QWORD *)(a1 + 8);
    v15 = *(_QWORD *)(a1 + 16);
    if (v15 != v16)
      *(_QWORD *)(a1 + 16) = v15 + ((v16 - v15 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *std::__deque_iterator<zip_entry_t,zip_entry_t const*,zip_entry_t const&,zip_entry_t const* const*,long,39l>::operator+=[abi:nn180100](_QWORD *result, uint64_t a2)
{
  _QWORD *v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  _QWORD *v6;

  if (a2)
  {
    v2 = (_QWORD *)*result;
    v3 = a2 + 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(result[1] - *(_QWORD *)*result) >> 3);
    if ((uint64_t)v3 < 1)
    {
      v5 = 38 - v3;
      v6 = &v2[-(v5 / 0x27)];
      *result = v6;
      v4 = *v6 + 104 * (39 * (v5 / 0x27) - v5) + 3952;
    }
    else
    {
      *result = &v2[v3 / 0x27];
      v4 = v2[v3 / 0x27] + 104 * (v3 % 0x27);
    }
    result[1] = v4;
  }
  return result;
}

double std::__for_each_segment[abi:nn180100]<std::__deque_iterator<zip_entry_t,zip_entry_t const*,zip_entry_t const&,zip_entry_t const* const*,long,39l>,std::__copy_loop<std::_ClassicAlgPolicy>::_CopySegment<std::__deque_iterator<zip_entry_t,zip_entry_t const*,zip_entry_t const&,zip_entry_t const* const*,long,39l>,std::__deque_iterator<zip_entry_t,zip_entry_t*,zip_entry_t&,zip_entry_t**,long,39l>>>(std::string::size_type *a1, std::string::size_type a2, std::string::size_type *a3, std::string::size_type a4, uint64_t a5)
{
  _QWORD *size;
  std::string::size_type v8;
  std::string::size_type *v10;
  std::string::size_type i;
  std::string::size_type v12;
  double result;
  std::string v14;

  size = *(_QWORD **)a5;
  v8 = *(_QWORD *)(a5 + 8);
  if (a1 != a3)
  {
    v10 = a1 + 1;
    for (i = *a1 + 4056; ; i = v12 + 4056)
    {
      std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<zip_entry_t const*,std::__deque_iterator<zip_entry_t,zip_entry_t*,zip_entry_t&,zip_entry_t**,long,39l>,0>(&v14, a2, i, size, v8);
      v8 = v14.__r_.__value_.__r.__words[2];
      size = (_QWORD *)v14.__r_.__value_.__l.__size_;
      *(_QWORD *)a5 = v14.__r_.__value_.__l.__size_;
      *(_QWORD *)(a5 + 8) = v8;
      if (v10 == a3)
        break;
      v12 = *v10++;
      a2 = v12;
    }
    a2 = *a3;
  }
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<zip_entry_t const*,std::__deque_iterator<zip_entry_t,zip_entry_t*,zip_entry_t&,zip_entry_t**,long,39l>,0>(&v14, a2, a4, size, v8);
  result = *(double *)&v14.__r_.__value_.__l.__size_;
  *(_OWORD *)a5 = *(_OWORD *)&v14.__r_.__value_.__r.__words[1];
  return result;
}

std::string *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<zip_entry_t const*,std::__deque_iterator<zip_entry_t,zip_entry_t*,zip_entry_t&,zip_entry_t**,long,39l>,0>(std::string *result, std::string::size_type a2, std::string::size_type a3, _QWORD *a4, std::string::size_type a5)
{
  _QWORD *v6;
  std::string::size_type v7;
  std::string::__raw *v8;
  std::string::size_type v9;
  uint64_t v10;
  uint64_t v11;
  std::string::size_type v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  std::string::size_type v16;
  std::string::size_type v17;

  v6 = a4;
  v7 = a2;
  v8 = (std::string::__raw *)result;
  if (a2 == a3)
  {
    v9 = a2;
  }
  else
  {
    v9 = a3;
    v10 = *a4;
    while (1)
    {
      v11 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v10 - a5 + 4056) >> 3);
      if (0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v9 - v7) >> 3) < v11)
        v11 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v9 - v7) >> 3);
      if (v11)
      {
        v12 = v7 + 104 * v11;
        do
        {
          *(_QWORD *)a5 = *(_QWORD *)v7;
          result = std::string::operator=((std::string *)(a5 + 8), (const std::string *)(v7 + 8));
          *(_OWORD *)(a5 + 32) = *(_OWORD *)(v7 + 32);
          v14 = *(_OWORD *)(v7 + 64);
          v13 = *(_OWORD *)(v7 + 80);
          v15 = *(_OWORD *)(v7 + 48);
          *(_WORD *)(a5 + 96) = *(_WORD *)(v7 + 96);
          *(_OWORD *)(a5 + 64) = v14;
          *(_OWORD *)(a5 + 80) = v13;
          *(_OWORD *)(a5 + 48) = v15;
          a5 += 104;
          v7 += 104;
        }
        while (v7 != v12);
        v7 = v12;
      }
      if (v7 == v9)
        break;
      v16 = v6[1];
      ++v6;
      v10 = v16;
      a5 = v16;
    }
    if (*v6 + 4056 == a5)
    {
      v17 = v6[1];
      ++v6;
      a5 = v17;
    }
  }
  v8->__words[0] = v9;
  v8->__words[1] = (std::string::size_type)v6;
  v8->__words[2] = a5;
  return result;
}

void std::__split_buffer<zip_entry_t *>::push_back(_QWORD *a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  char *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;

  v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    v5 = (char *)a1[1];
    v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1)
        v16 = 1;
      else
        v16 = (uint64_t)&v4[-*a1] >> 2;
      v17 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<zip_entry_t *>>(v16);
      v19 = &v17[8 * (v16 >> 2)];
      v20 = (uint64_t *)a1[1];
      v4 = v19;
      v21 = a1[2] - (_QWORD)v20;
      if (v21)
      {
        v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        v22 = 8 * (v21 >> 3);
        v23 = &v17[8 * (v16 >> 2)];
        do
        {
          v24 = *v20++;
          *(_QWORD *)v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        v4 = (char *)a1[2];
      }
    }
    else
    {
      v7 = v6 >> 3;
      v8 = v6 >> 3 < -1;
      v9 = (v6 >> 3) + 2;
      if (v8)
        v10 = v9;
      else
        v10 = v7 + 1;
      v11 = -(v10 >> 1);
      v12 = v10 >> 1;
      v13 = &v5[-8 * v12];
      v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        v4 = (char *)a1[1];
      }
      v15 = &v4[8 * v11];
      v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(_QWORD *)v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<zip_entry_t *>::push_front(uint64_t a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;

  v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    v6 = *(_BYTE **)(a1 + 16);
    v7 = *(_BYTE **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4)
        v11 = 1;
      else
        v11 = (v7 - v4) >> 2;
      v12 = 2 * v11;
      v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<zip_entry_t *>>(v11);
      v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      v15 = *(uint64_t **)(a1 + 8);
      v16 = v5;
      v17 = *(_QWORD *)(a1 + 16) - (_QWORD)v15;
      if (v17)
      {
        v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        v18 = 8 * (v17 >> 3);
        v19 = v5;
        do
        {
          v20 = *v15++;
          *(_QWORD *)v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      v21 = *(char **)a1;
      *(_QWORD *)a1 = v13;
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = v16;
      *(_QWORD *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v8 = (v7 - v6) >> 3;
      if (v8 >= -1)
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v9 >> 1;
      v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        v4 = *(char **)(a1 + 16);
      }
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    v5 = *(char **)(a1 + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  *(_QWORD *)(a1 + 8) -= 8;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<zip_entry_t *>>(unint64_t a1)
{
  if (a1 >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  return operator new(8 * a1);
}

_QWORD *std::string::basic_string[abi:nn180100](_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

void std::deque<zip_entry_t>::__add_back_capacity(_QWORD *a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  _QWORD *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  int64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  _QWORD *i;
  char *v26;
  __int128 v27;
  unint64_t v28;
  char *v29;
  char *v30;
  uint64_t v31;
  char *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  char *v38;
  _QWORD *v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  void *v48;
  __int128 v49;
  __int128 v50;
  _QWORD *v51;

  v2 = a1[4];
  v3 = v2 >= 0x27;
  v4 = v2 - 39;
  if (v3)
  {
    a1[4] = v4;
    v5 = (_QWORD *)a1[1];
    v6 = (char *)a1[2];
    v9 = *v5;
    v7 = (char *)(v5 + 1);
    v8 = v9;
    a1[1] = v7;
    if (v6 != (char *)a1[3])
    {
LABEL_31:
      *(_QWORD *)v6 = v8;
      a1[2] += 8;
      return;
    }
    v10 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1)
        v28 = 1;
      else
        v28 = (uint64_t)&v6[-*a1] >> 2;
      v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<zip_entry_t *>>(v28);
      v30 = &v29[8 * (v28 >> 2)];
      v32 = &v29[8 * v31];
      v33 = (uint64_t *)a1[1];
      v6 = v30;
      v34 = a1[2] - (_QWORD)v33;
      if (v34)
      {
        v6 = &v30[v34 & 0xFFFFFFFFFFFFFFF8];
        v35 = 8 * (v34 >> 3);
        v36 = &v29[8 * (v28 >> 2)];
        do
        {
          v37 = *v33++;
          *(_QWORD *)v36 = v37;
          v36 += 8;
          v35 -= 8;
        }
        while (v35);
      }
      goto LABEL_28;
    }
LABEL_5:
    v11 = v10 >> 3;
    v12 = v10 >> 3 < -1;
    v13 = (v10 >> 3) + 2;
    if (v12)
      v14 = v13;
    else
      v14 = v11 + 1;
    v15 = -(v14 >> 1);
    v16 = v14 >> 1;
    v17 = &v7[-8 * v16];
    v18 = v6 - v7;
    if (v6 != v7)
    {
      memmove(&v7[-8 * v16], v7, v6 - v7);
      v7 = (char *)a1[1];
    }
    v6 = &v17[v18];
    a1[1] = &v7[8 * v15];
    a1[2] = &v17[v18];
    goto LABEL_31;
  }
  v19 = a1[2];
  v20 = (v19 - a1[1]) >> 3;
  v21 = a1[3];
  v22 = v21 - *a1;
  if (v20 < v22 >> 3)
  {
    if (v21 != v19)
    {
      *(_QWORD *)&v49 = operator new(0xFD8uLL);
      std::__split_buffer<zip_entry_t *>::push_back(a1, &v49);
      return;
    }
    *(_QWORD *)&v49 = operator new(0xFD8uLL);
    std::__split_buffer<zip_entry_t *>::push_front((uint64_t)a1, &v49);
    v39 = (_QWORD *)a1[1];
    v6 = (char *)a1[2];
    v40 = *v39;
    v7 = (char *)(v39 + 1);
    v8 = v40;
    a1[1] = v7;
    if (v6 != (char *)a1[3])
      goto LABEL_31;
    v10 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1)
        v41 = 1;
      else
        v41 = (uint64_t)&v6[-*a1] >> 2;
      v29 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<zip_entry_t *>>(v41);
      v30 = &v29[8 * (v41 >> 2)];
      v32 = &v29[8 * v42];
      v43 = (uint64_t *)a1[1];
      v6 = v30;
      v44 = a1[2] - (_QWORD)v43;
      if (v44)
      {
        v6 = &v30[v44 & 0xFFFFFFFFFFFFFFF8];
        v45 = 8 * (v44 >> 3);
        v46 = &v29[8 * (v41 >> 2)];
        do
        {
          v47 = *v43++;
          *(_QWORD *)v46 = v47;
          v46 += 8;
          v45 -= 8;
        }
        while (v45);
      }
LABEL_28:
      v38 = (char *)*a1;
      *a1 = v29;
      a1[1] = v30;
      a1[2] = v6;
      a1[3] = v32;
      if (v38)
      {
        operator delete(v38);
        v6 = (char *)a1[2];
      }
      goto LABEL_31;
    }
    goto LABEL_5;
  }
  if (v21 == *a1)
    v23 = 1;
  else
    v23 = v22 >> 2;
  v51 = a1 + 3;
  *(_QWORD *)&v49 = std::__allocate_at_least[abi:nn180100]<std::allocator<zip_entry_t *>>(v23);
  *((_QWORD *)&v49 + 1) = v49 + 8 * v20;
  *(_QWORD *)&v50 = *((_QWORD *)&v49 + 1);
  *((_QWORD *)&v50 + 1) = v49 + 8 * v24;
  v48 = operator new(0xFD8uLL);
  std::__split_buffer<zip_entry_t *>::push_back(&v49, &v48);
  for (i = (_QWORD *)a1[2]; i != (_QWORD *)a1[1]; std::__split_buffer<zip_entry_t *>::push_front((uint64_t)&v49, i))
    --i;
  v26 = (char *)*a1;
  v27 = v50;
  *(_OWORD *)a1 = v49;
  *((_OWORD *)a1 + 1) = v27;
  if (v26)
    operator delete(v26);
}

_QWORD *re::internal::AssetNetworkLoader::init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  void **v12;
  NSObject *v13;
  void *v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *result;
  uint64_t v18;
  uint64_t v19;
  int v20;
  id *v21;
  NSObject *v22;
  id v23;
  _QWORD v24[3];
  _QWORD *v25;
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  _QWORD v30[3];
  _QWORD *v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 160) = re::globalAllocators((re *)a1)[2];
  *(_QWORD *)(a1 + 16) = a4;
  v30[0] = &off_24ED2CE08;
  v30[1] = a1;
  v31 = v30;
  v6 = *(_QWORD *)(a1 + 8);
  v29 = v28;
  v28[0] = &off_24ED2CE08;
  v28[1] = a1;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v6 + 24))(v6, v28);
  v7 = v29;
  if (v29 == v28)
  {
    v8 = 4;
    v7 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v8 = 5;
  }
  (*(void (**)(void))(*v7 + 8 * v8))();
LABEL_6:
  v26[0] = &off_24ED2CE98;
  v26[1] = a1;
  v27 = v26;
  v9 = *(_QWORD *)(a1 + 8);
  v25 = v24;
  v24[0] = &off_24ED2CE98;
  v24[1] = a1;
  (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v9 + 32))(v9, v24);
  v10 = v25;
  if (v25 == v24)
  {
    v11 = 4;
    v10 = v24;
  }
  else
  {
    if (!v25)
      goto LABEL_11;
    v11 = 5;
  }
  (*(void (**)(void))(*v10 + 8 * v11))();
LABEL_11:
  re::dispatch::Queue::global((re::dispatch::Queue *)0x21, 0, &v23);
  v19 = 0x100000001;
  v20 = 1;
  v21 = &v23;
  re::dispatch::Queue::make("com.apple.re.AssetNetworkLoaderBackgroundSerializer", (int *)&v19, &v22);
  v12 = (void **)(a1 + 264);
  if ((NSObject **)(a1 + 264) != &v22)
  {
    v13 = v22;
    v22 = 0;
    v14 = *v12;
    *v12 = v13;

  }
  v15 = v27;
  if (v27 == v26)
  {
    v16 = 4;
    v15 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_18;
    v16 = 5;
  }
  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_18:
  result = v31;
  if (v31 == v30)
  {
    v18 = 4;
    result = v30;
  }
  else
  {
    if (!v31)
      return result;
    v18 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v18))();
}

_QWORD *re::internal::AssetNetworkLoader::deinit(re::internal::AssetNetworkLoader *this)
{
  uint64_t v2;
  uint64_t v3;
  re::AssetHandle *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  os_unfair_lock_s *v17;
  re *v18;
  uint64_t v19;
  _anonymous_namespace_ *v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  __n128 v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  int v31;
  unsigned int v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  __n128 *v40;
  int v41;
  uint64_t v42;
  __n128 *v43;
  uint64_t v44;
  int v45;
  double v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *result;
  uint64_t v52;
  _OWORD v53[2];
  char v54[8];
  os_unfair_lock_s *v55;
  _BYTE v56[24];
  _BYTE *v57;
  _BYTE v58[24];
  _BYTE *v59;
  uint64_t v60;

  v60 = *MEMORY[0x24BDAC8D0];
  atomic_store(1u, (unsigned __int8 *)this + 256);
  v2 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = 0;
  if (v2)
  {
    v3 = v2 << 6;
    v4 = (re::AssetHandle *)(*((_QWORD *)this + 7) + 40);
    do
    {
      re::AssetHandle::~AssetHandle(v4);
      v5 = *((_QWORD *)v4 - 4);
      if (v5)
      {
        if ((*((_BYTE *)v4 - 24) & 1) != 0)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 40))(v5, *((_QWORD *)v4 - 2));
        *((_OWORD *)v4 - 2) = 0u;
        *((_OWORD *)v4 - 1) = 0u;
      }
      v4 = (re::AssetHandle *)((char *)v4 + 64);
      v3 -= 64;
    }
    while (v3);
  }
  ++*((_DWORD *)this + 12);
  os_unfair_lock_lock((os_unfair_lock_t)this + 48);
  v6 = *((_QWORD *)this + 27);
  *((_QWORD *)this + 27) = 0;
  if (v6)
  {
    v7 = 112 * v6;
    v8 = (_QWORD *)(*((_QWORD *)this + 29) + 96);
    do
    {
      v9 = *(v8 - 4);
      if (v9)
      {
        if (*v8)
          (*(void (**)(uint64_t))(*(_QWORD *)v9 + 40))(v9);
        *v8 = 0;
        *(v8 - 3) = 0;
        *(v8 - 2) = 0;
        *(v8 - 4) = 0;
        ++*((_DWORD *)v8 - 2);
      }
      v10 = *(v8 - 8);
      if (v10)
      {
        if ((*(_BYTE *)(v8 - 7) & 1) != 0)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 40))(v10, *(v8 - 6));
        *((_OWORD *)v8 - 4) = 0u;
        *((_OWORD *)v8 - 3) = 0u;
      }
      re::AssetHandle::~AssetHandle((re::AssetHandle *)(v8 - 11));
      v8 += 14;
      v7 -= 112;
    }
    while (v7);
  }
  ++*((_DWORD *)this + 56);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 48);
  v11 = *((unsigned int *)this + 24);
  if ((_DWORD)v11)
  {
    v12 = 0;
    v13 = (int *)(*((_QWORD *)this + 10) + 8);
    while (1)
    {
      v14 = *v13;
      v13 += 20;
      if (v14 < 0)
        break;
      if (v11 == ++v12)
      {
        LODWORD(v12) = *((_DWORD *)this + 24);
        break;
      }
    }
  }
  else
  {
    LODWORD(v12) = 0;
  }
  v15 = *((_DWORD *)this + 24);
  if ((_DWORD)v11 != (_DWORD)v12)
  {
    v16 = v12;
    do
    {
      re::AssetHandle::AssetHandle((re::AssetHandle *)v54, (const re::AssetHandle *)(*((_QWORD *)this + 10) + 80 * v16 + 56));
      if (v55)
      {
        v17 = v55 + 96;
        os_unfair_lock_lock(v55 + 96);
        v18 = *(re **)this;
        v19 = (uint64_t)v55;
        re::AssetManager::putEntryInFailedState_entryStateLocked(v18, v19, 302, (uint64_t)v53);
        if (*(_QWORD *)&v53[0])
        {
          if ((BYTE8(v53[0]) & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)&v53[0] + 40))();
          memset(v53, 0, sizeof(v53));
        }
        os_unfair_lock_unlock(v17);
      }
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v54);
      v15 = *((_DWORD *)this + 24);
      if (v15 <= (int)v12 + 1)
        v21 = v12 + 1;
      else
        v21 = *((_DWORD *)this + 24);
      while (1)
      {
        v16 = (v12 + 1);
        if (v21 - 1 == (_DWORD)v12)
          break;
        LODWORD(v12) = v12 + 1;
        v22 = v16;
        if ((*(_DWORD *)(*((_QWORD *)this + 10) + 80 * v16 + 8) & 0x80000000) != 0)
          goto LABEL_40;
      }
      v22 = v21;
LABEL_40:
      LODWORD(v12) = v22;
    }
    while ((_DWORD)v11 != v22);
  }
  if (*((_DWORD *)this + 23))
  {
    v23 = *((unsigned int *)this + 22);
    if ((_DWORD)v23)
    {
      memset_pattern16(*((void **)this + 9), &unk_2260EB7B0, 4 * v23);
      v15 = *((_DWORD *)this + 24);
    }
    if (v15)
    {
      v24 = 0;
      v25 = 0;
      do
      {
        re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::PendingRequestedAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(*((_QWORD *)this + 10) + v24);
        ++v25;
        v24 += 80;
      }
      while (v25 < *((unsigned int *)this + 24));
    }
    *((_DWORD *)this + 23) = 0;
    *((_DWORD *)this + 24) = 0;
    v26 = *((_DWORD *)this + 26) + 1;
    *((_DWORD *)this + 25) = 0x7FFFFFFF;
    *((_DWORD *)this + 26) = v26;
  }
  v27.n128_f64[0] = re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::PendingRequestedAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 8);
  v28 = *((unsigned int *)this + 36);
  if ((_DWORD)v28)
  {
    v29 = 0;
    v30 = (int *)(*((_QWORD *)this + 16) + 8);
    while (1)
    {
      v31 = *v30;
      v30 += 22;
      if (v31 < 0)
        break;
      if (v28 == ++v29)
      {
        LODWORD(v29) = *((_DWORD *)this + 36);
        break;
      }
    }
  }
  else
  {
    LODWORD(v29) = 0;
  }
  v32 = *((_DWORD *)this + 36);
  if ((_DWORD)v28 != (_DWORD)v29)
  {
    v33 = v29;
    do
    {
      (*(void (**)(_QWORD, _QWORD, __n128))(**((_QWORD **)this + 20) + 40))(*((_QWORD *)this + 20), *(_QWORD *)(*((_QWORD *)this + 16) + 88 * v33 + 56), v27);
      v32 = *((_DWORD *)this + 36);
      if (v32 <= (int)v29 + 1)
        v34 = v29 + 1;
      else
        v34 = *((_DWORD *)this + 36);
      v35 = v29;
      while (1)
      {
        v33 = (v35 + 1);
        if (v34 - 1 == v35)
          break;
        ++v35;
        LODWORD(v29) = v33;
        if ((*(_DWORD *)(*((_QWORD *)this + 16) + 88 * v33 + 8) & 0x80000000) != 0)
          goto LABEL_64;
      }
      LODWORD(v29) = v34;
LABEL_64:
      ;
    }
    while ((_DWORD)v28 != (_DWORD)v29);
  }
  if (*((_DWORD *)this + 35))
  {
    v36 = *((unsigned int *)this + 34);
    if ((_DWORD)v36)
    {
      memset_pattern16(*((void **)this + 15), &unk_2260EB7B0, 4 * v36);
      v32 = *((_DWORD *)this + 36);
    }
    if (v32)
    {
      v37 = 0;
      v38 = 0;
      v27 = 0uLL;
      do
      {
        v39 = *((_QWORD *)this + 16);
        v40 = (__n128 *)(v39 + v37);
        v41 = *(_DWORD *)(v39 + v37 + 8);
        if (v41 < 0)
        {
          v40->n128_u32[2] = v41 & 0x7FFFFFFF;
          v44 = v40[1].n128_i64[0];
          v43 = v40 + 1;
          v42 = v44;
          if (v44)
          {
            if ((*(_BYTE *)(v39 + v37 + 24) & 1) != 0)
            {
              (*(void (**)(uint64_t, _QWORD, __n128))(*(_QWORD *)v42 + 40))(v42, *(_QWORD *)(v39 + v37 + 32), v27);
              v27 = 0uLL;
            }
            *v43 = v27;
            v43[1] = v27;
            v32 = *((_DWORD *)this + 36);
          }
        }
        ++v38;
        v37 += 88;
      }
      while (v38 < v32);
    }
    *((_DWORD *)this + 35) = 0;
    *((_DWORD *)this + 36) = 0;
    v45 = *((_DWORD *)this + 38) + 1;
    *((_DWORD *)this + 37) = 0x7FFFFFFF;
    *((_DWORD *)this + 38) = v45;
  }
  v46 = re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::FragmentedNetworkAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)this + 14, v27.n128_f64[0]);
  *((_QWORD *)this + 20) = 0;
  v47 = *((_QWORD *)this + 1);
  v59 = 0;
  (*(void (**)(uint64_t, _BYTE *, double))(*(_QWORD *)v47 + 32))(v47, v58, v46);
  v48 = v59;
  if (v59 == v58)
  {
    v49 = 4;
    v48 = v58;
  }
  else
  {
    if (!v59)
      goto LABEL_82;
    v49 = 5;
  }
  (*(void (**)(void))(*v48 + 8 * v49))();
LABEL_82:
  v50 = *((_QWORD *)this + 1);
  v57 = 0;
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v50 + 24))(v50, v56);
  result = v57;
  if (v57 == v56)
  {
    v52 = 4;
    result = v56;
    goto LABEL_86;
  }
  if (v57)
  {
    v52 = 5;
LABEL_86:
    result = (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v52))();
  }
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  return result;
}

uint64_t re::internal::AssetNetworkLoader::sendFailureResponse(re *a1, uint64_t a2, uint64_t a3, re::DynamicString *a4)
{
  NSObject *v8;
  _BOOL8 v9;
  uint64_t v10;
  _anonymous_namespace_ *v11;
  unsigned __int8 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  re *v17;
  NSObject *v18;
  uint64_t v19;
  const char *v20;
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint8_t v25[4];
  uint64_t v26;
  uint8_t buf[4];
  _BYTE v28[20];
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v8 = *re::assetsLogObjects(a1);
  v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    if ((*(_QWORD *)(a3 + 168) & 1) != 0)
      v10 = *(_QWORD *)(a3 + 176);
    else
      v10 = a3 + 169;
    *(_DWORD *)buf = 134218242;
    *(_QWORD *)v28 = a2;
    *(_WORD *)&v28[8] = 2080;
    *(_QWORD *)&v28[10] = v10;
    _os_log_impl(&dword_224FE9000, v8, OS_LOG_TYPE_DEFAULT, "Sending peer asset load failure to '%llu' for '%s'", buf, 0x16u);
  }
  *(_QWORD *)&v28[12] = 0;
  v29 = 0;
  v30 = 0;
  re::DynamicString::setCapacity(&v28[4], 0);
  *(_DWORD *)buf = 102;
  v11 = re::DynamicString::operator=((re::DynamicString *)&v28[4], a4);
  v12 = atomic_load((unsigned __int8 *)&qword_2540FB908);
  if ((v12 & 1) == 0 && __cxa_guard_acquire(&qword_2540FB908))
  {
    _MergedGlobals_43 = re::introspect_AssetSimpleMessage(0);
    __cxa_guard_release(&qword_2540FB908);
  }
  v23 = 0;
  v24 = 0;
  if ((v13 & 1) == 0)
  {
    v18 = *re::assetsLogObjects((re *)v13);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      goto LABEL_15;
    if ((*(_QWORD *)(a3 + 168) & 1) != 0)
      v22 = *(_QWORD *)(a3 + 176);
    else
      v22 = a3 + 169;
    *(_DWORD *)v25 = 136315138;
    v26 = v22;
    v20 = "Failed to serialize network message for '%s'";
    goto LABEL_23;
  }
  v14 = *((_QWORD *)a1 + 1);
  v15 = v24;
  v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v14 + 16))(v14, a2, v24, v23);
  if ((v16 & 1) == 0)
  {
    v18 = *re::assetsLogObjects(v17);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      if ((*(_QWORD *)(a3 + 168) & 1) != 0)
        v19 = *(_QWORD *)(a3 + 176);
      else
        v19 = a3 + 169;
      *(_DWORD *)v25 = 136315138;
      v26 = v19;
      v20 = "Failed to send failure message for '%s'";
LABEL_23:
      _os_log_error_impl(&dword_224FE9000, v18, OS_LOG_TYPE_ERROR, v20, v25, 0xCu);
    }
  }
LABEL_15:
  result = *(_QWORD *)&v28[4];
  if (*(_QWORD *)&v28[4])
  {
    if ((v28[12] & 1) != 0)
      return (*(uint64_t (**)(void))(**(_QWORD **)&v28[4] + 40))();
  }
  return result;
}

re::AssetHandle *re::DynamicArray<re::internal::NetworkLoadRequestData>::add(uint64_t a1, _QWORD *a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  re::AssetHandle *result;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  if (v5 >= v4)
  {
    v6 = v5 + 1;
    if (v4 < v5 + 1)
    {
      if (*(_QWORD *)a1)
      {
        v7 = 2 * v4;
        v8 = v4 == 0;
        v9 = 8;
        if (!v8)
          v9 = v7;
        if (v9 <= v6)
          v10 = v6;
        else
          v10 = v9;
        re::DynamicArray<re::internal::NetworkLoadRequestData>::setCapacity((_QWORD *)a1, v10);
      }
      else
      {
        re::DynamicArray<re::internal::NetworkLoadRequestData>::setCapacity((_QWORD *)a1, v6);
        ++*(_DWORD *)(a1 + 24);
      }
    }
    v5 = *(_QWORD *)(a1 + 16);
  }
  v11 = (_QWORD *)(*(_QWORD *)(a1 + 32) + (v5 << 6));
  *v11 = *a2;
  re::DynamicString::DynamicString((re::DynamicString *)(v11 + 1), (const re::DynamicString *)(a2 + 1));
  result = re::AssetHandle::AssetHandle((re::AssetHandle *)(v11 + 5), (const re::AssetHandle *)(a2 + 5));
  ++*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

void re::internal::AssetNetworkLoader::queueAssetSerializationResponse(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v8[5];
  _BYTE v9[24];
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  _BYTE v16[24];

  re::AssetHandle::AssetHandle((re::AssetHandle *)v16, (const re::AssetHandle *)(a2 + 5));
  re::DynamicString::DynamicString((re::DynamicString *)&v13, (const re::DynamicString *)(a2 + 1));
  v4 = *a2;
  v8[0] = MEMORY[0x24BDAC760];
  v8[1] = 1174405120;
  v8[2] = ___ZN2re8internal18AssetNetworkLoader31queueAssetSerializationResponseERKNS0_22NetworkLoadRequestDataE_block_invoke;
  v8[3] = &__block_descriptor_tmp_2;
  v8[4] = a1;
  re::AssetHandle::AssetHandle((re::AssetHandle *)v9, (const re::AssetHandle *)v16);
  re::DynamicString::DynamicString((re::DynamicString *)&v10, (const re::DynamicString *)&v13);
  v12 = v4;
  dispatch_async(*(dispatch_queue_t *)(a1 + 264), v8);
  if ((_QWORD)v10)
  {
    if ((BYTE8(v10) & 1) != 0)
      (*(void (**)(_QWORD, _QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v10 + 40))(v10, v11, v5, v6, v7);
    v10 = 0u;
    v11 = 0u;
  }
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v9);
  if (v13 && (v14 & 1) != 0)
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v13 + 40))(v13, v15);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)v16);
}

void ___ZN2re8internal18AssetNetworkLoader31queueAssetSerializationResponseERKNS0_22NetworkLoadRequestDataE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  _BOOL8 v4;
  unsigned __int8 v5;
  uint64_t v6;
  unint64_t v7;
  NSObject *v8;
  uint64_t v9;
  _anonymous_namespace_ *v10;
  _anonymous_namespace_ *v11;
  _anonymous_namespace_ *v12;
  uint64_t (***v13)(_QWORD, _QWORD *, uint64_t, uint64_t, _BYTE *);
  re::internal::AssetEntry *v14;
  const char *v15;
  unsigned __int8 v16;
  uint64_t v17;
  _anonymous_namespace_ *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  re *v22;
  re *v23;
  char v24;
  NSObject *v25;
  _BOOL8 v26;
  char *v27;
  NSObject *v28;
  char *v29;
  const char *v30;
  uint64_t v31;
  char v32;
  NSObject *v33;
  unsigned __int8 v34;
  re *v35;
  NSObject *v36;
  _anonymous_namespace_ *v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  BOOL v42;
  unint64_t v43;
  unint64_t v44;
  NSObject *v45;
  uint64_t v46;
  _QWORD *v47;
  char *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _QWORD *v56;
  char *v57;
  const char *v58;
  _QWORD *v59;
  char *v60;
  char *v61;
  re::AssetHandle *v62;
  _QWORD v63[2];
  uint64_t *v64;
  __int128 v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  char v69;
  _BYTE v70[7];
  const char *v71;
  const re::IntrospectionBase *v72;
  _OWORD v73[3];
  uint8_t v74[24];
  uint8_t v75[4];
  char *v76;
  uint64_t v77;
  char v78;
  uint64_t v79;
  _BYTE buf[24];
  uint64_t v81;
  __int128 v82;
  __int128 v83;
  uint64_t *v84;
  __int128 v85;
  int v86;
  uint64_t v87;
  __int128 v88;
  __int128 v89;
  uint64_t v90;
  uint64_t v91;

  v91 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *re::assetsLogObjects((re *)a1);
  v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG);
  if (v4)
  {
    v47 = re::AssetHandle::assetInfo((re::AssetHandle *)(a1 + 40));
    if ((v47[17] & 1) != 0)
      v48 = (char *)v47[18];
    else
      v48 = (char *)v47 + 137;
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v48;
    _os_log_debug_impl(&dword_224FE9000, v3, OS_LOG_TYPE_DEBUG, "Async network serialization of '%s'", buf, 0xCu);
  }
  v5 = atomic_load((unsigned __int8 *)(v2 + 256));
  if ((v5 & 1) == 0)
  {
    v6 = *(_QWORD *)(a1 + 48);
    if (v6)
      v7 = *(_QWORD *)(v6 + 264);
    else
      v7 = 0;
    v62 = (re::AssetHandle *)(a1 + 40);
    v10 = (_anonymous_namespace_ *)re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(*(_QWORD *)v2 + 1104), v7);
    memset(v73, 0, 32);
    re::DynamicString::setCapacity(v73, 0);
    LODWORD(v72) = 101;
    re::DynamicString::operator=((re::DynamicString *)v73, (re::DynamicString *)(a1 + 64));
    v11 = (_anonymous_namespace_ *)(*(_QWORD *(**)(uint64_t *__return_ptr))(**(_QWORD **)(v2 + 8) + 40))(&v68);
    v67 = 0;
    v65 = 0uLL;
    v66 = 0;
    v12 = (_anonymous_namespace_ *)re::DynamicArray<char>::setCapacity(&v64, 0x100uLL);
    ++v66;
    v63[0] = &off_24ED7C100;
    v63[1] = &v64;
    v13 = *(uint64_t (****)(_QWORD, _QWORD *, uint64_t, uint64_t, _BYTE *))(v2 + 16);
    v14 = *(re::internal::AssetEntry **)(a1 + 48);
    if ((v69 & 1) != 0)
      v15 = v71;
    else
      v15 = v70;
    v16 = atomic_load((unsigned __int8 *)&qword_2540FB908);
    if ((v16 & 1) == 0 && __cxa_guard_acquire(&qword_2540FB908))
    {
      _MergedGlobals_43 = re::introspect_AssetSimpleMessage(0);
      __cxa_guard_release(&qword_2540FB908);
    }
    if ((v17 & 1) == 0)
    {
      v25 = *re::assetsLogObjects((re *)v17);
      v26 = os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
      if (v26)
      {
        if ((*((_QWORD *)v14 + 21) & 1) != 0)
          v27 = (char *)*((_QWORD *)v14 + 22);
        else
          v27 = (char *)v14 + 169;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v27;
        _os_log_error_impl(&dword_224FE9000, v25, OS_LOG_TYPE_ERROR, "Failed to serialize network message for '%s'", buf, 0xCu);
      }
      goto LABEL_40;
    }
    v18 = re::AssetHandle::AssetHandle((re::AssetHandle *)v74, v14);
    v19 = *((_QWORD *)v14 + 3);
    re::DefaultAssetSerialize::DefaultAssetSerialize((re::DefaultAssetSerialize *)buf, (const re::AssetHandle *)v74);
    *(_QWORD *)buf = off_24ED2D398;
    LOBYTE(v87) = 0;
    re::DynamicString::DynamicString((re::DynamicString *)&v88, (const re::DynamicString *)&v77);
    v90 = v19;
    if (v77 && (v78 & 1) != 0)
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v77 + 40))(v77, v79, v20);
    v21 = (*(uint64_t (**)(_anonymous_namespace_ *))(*(_QWORD *)v10 + 112))(v10);
    re::AssetHandle::serializableAsset((re::AssetHandle *)v74, &v77);
    v22 = (re *)(**v13)(v13, v63, v21, v77, buf);
    if ((v22 & 1) != 0)
    {
      v23 = (re *)(*(uint64_t (**)(_anonymous_namespace_ *, _QWORD *, uint64_t, _QWORD))(*(_QWORD *)v10 + 56))(v10, v63, v77, 0);
      if ((v23 & 1) != 0)
      {
        v24 = 1;
        goto LABEL_34;
      }
      v28 = *re::assetsLogObjects(v23);
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
LABEL_33:
        v24 = 0;
LABEL_34:
        std::unique_ptr<re::RigHierarchy,std::function<void ()(re::RigHierarchy*)>>::~unique_ptr[abi:nn180100](&v77);
        *(_QWORD *)buf = off_24ED2D398;
        if ((_QWORD)v88)
        {
          if ((BYTE8(v88) & 1) != 0)
            (*(void (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)v88 + 40))(v88, v89, v31);
          v88 = 0u;
          v89 = 0u;
        }
        *(_QWORD *)buf = &off_24ED2D3D0;
        re::Optional<re::AssetPath>::~Optional((uint64_t)&buf[8]);
        re::AssetHandle::~AssetHandle((re::AssetHandle *)v74);
        if ((v24 & 1) != 0)
        {
          v32 = 0;
LABEL_42:
          v34 = atomic_load((unsigned __int8 *)(v2 + 256));
          if ((v34 & 1) != 0)
          {
            v45 = *re::assetsLogObjects((re *)v26);
            if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
            {
              if ((*(_BYTE *)(a1 + 72) & 1) != 0)
                v46 = *(_QWORD *)(a1 + 80);
              else
                v46 = a1 + 73;
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = v46;
              _os_log_impl(&dword_224FE9000, v45, OS_LOG_TYPE_DEFAULT, "Deiniting AssetNetworkLoader: Skipping asset serialization response for %s", buf, 0xCu);
            }
          }
          else
          {
            os_unfair_lock_lock((os_unfair_lock_t)(v2 + 192));
            v36 = *re::assetsLogObjects(v35);
            if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
            {
              v59 = re::AssetHandle::assetInfo(v62);
              if ((v59[17] & 1) != 0)
                v60 = (char *)v59[18];
              else
                v60 = (char *)v59 + 137;
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = v60;
              _os_log_debug_impl(&dword_224FE9000, v36, OS_LOG_TYPE_DEBUG, "Completed network serialization of Asset '%s'", buf, 0xCu);
            }
            *(_QWORD *)buf = *(_QWORD *)(a1 + 96);
            re::AssetHandle::AssetHandle((re::AssetHandle *)&buf[8], v62);
            v37 = re::DynamicString::DynamicString((re::DynamicString *)&v82, (const re::DynamicString *)(a1 + 64));
            v84 = v64;
            v85 = v65;
            v64 = 0;
            v65 = 0uLL;
            v87 = v67;
            v67 = 0;
            ++v66;
            v86 = 1;
            LOBYTE(v88) = v32;
            v38 = *(_QWORD *)(v2 + 208);
            v39 = *(_QWORD *)(v2 + 216);
            if (v39 >= v38)
            {
              v40 = v39 + 1;
              if (v38 < v39 + 1)
              {
                if (*(_QWORD *)(v2 + 200))
                {
                  v41 = 2 * v38;
                  v42 = v38 == 0;
                  v43 = 8;
                  if (!v42)
                    v43 = v41;
                  if (v43 <= v40)
                    v44 = v40;
                  else
                    v44 = v43;
                  re::DynamicArray<re::internal::AssetNetworkLoader::SerializedAssetResponse>::setCapacity((_QWORD *)(v2 + 200), v44);
                }
                else
                {
                  re::DynamicArray<re::internal::AssetNetworkLoader::SerializedAssetResponse>::setCapacity((_QWORD *)(v2 + 200), v40);
                  ++*(_DWORD *)(v2 + 224);
                }
              }
              v39 = *(_QWORD *)(v2 + 216);
            }
            v49 = *(_QWORD *)(v2 + 232) + 112 * v39;
            *(_QWORD *)v49 = *(_QWORD *)buf;
            *(_QWORD *)(v49 + 8) = 0;
            *(_QWORD *)(v49 + 16) = 0;
            *(_QWORD *)(v49 + 24) = 0;
            *(_QWORD *)(v49 + 16) = *(_QWORD *)&buf[16];
            *(_QWORD *)&buf[16] = 0;
            v50 = *(_QWORD *)(v49 + 8);
            *(_QWORD *)(v49 + 8) = 0;
            *(_QWORD *)(v49 + 8) = *(_QWORD *)&buf[8];
            *(_QWORD *)&buf[8] = v50;
            v51 = *(_QWORD *)(v49 + 24);
            *(_QWORD *)(v49 + 24) = v81;
            v81 = v51;
            *(_OWORD *)(v49 + 32) = 0u;
            *(_OWORD *)(v49 + 48) = 0u;
            *(_QWORD *)(v49 + 32) = v82;
            *(_QWORD *)&v82 = 0;
            v52 = *(_QWORD *)(v49 + 48);
            *(_QWORD *)(v49 + 48) = v83;
            *(_QWORD *)&v83 = v52;
            *(_QWORD *)(v49 + 56) = *((_QWORD *)&v83 + 1);
            *((_QWORD *)&v83 + 1) = 0;
            v53 = *(_QWORD *)(v49 + 40);
            *(_QWORD *)(v49 + 40) = *((_QWORD *)&v82 + 1);
            *((_QWORD *)&v82 + 1) = v53;
            *(_QWORD *)(v49 + 96) = 0;
            *(_DWORD *)(v49 + 88) = 0;
            *(_QWORD *)(v49 + 72) = 0;
            *(_QWORD *)(v49 + 80) = 0;
            *(_QWORD *)(v49 + 64) = 0;
            *(_QWORD *)(v49 + 64) = v84;
            v84 = 0;
            *(_QWORD *)(v49 + 72) = v85;
            *(_QWORD *)&v85 = 0;
            v54 = *(_QWORD *)(v49 + 80);
            *(_QWORD *)(v49 + 80) = *((_QWORD *)&v85 + 1);
            *((_QWORD *)&v85 + 1) = v54;
            v55 = *(_QWORD *)(v49 + 96);
            *(_QWORD *)(v49 + 96) = v87;
            v87 = v55;
            ++v86;
            ++*(_DWORD *)(v49 + 88);
            *(_BYTE *)(v49 + 104) = v88;
            ++*(_QWORD *)(v2 + 216);
            ++*(_DWORD *)(v2 + 224);
            if (v84)
            {
              if (v55)
                (*(void (**)(void))(*v84 + 40))();
              v87 = 0;
              v85 = 0uLL;
              v84 = 0;
              ++v86;
            }
            if ((_QWORD)v82)
            {
              if ((BYTE8(v82) & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v82 + 40))();
              v82 = 0u;
              v83 = 0u;
            }
            re::AssetHandle::~AssetHandle((re::AssetHandle *)&buf[8]);
            os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 192));
          }
          if (v64 && v67)
            (*(void (**)(void))(*v64 + 40))();
          if (v68 && (v69 & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v68 + 40))();
          if (*(_QWORD *)&v73[0])
          {
            if ((BYTE8(v73[0]) & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)&v73[0] + 40))();
          }
          return;
        }
LABEL_40:
        v33 = *re::assetsLogObjects((re *)v26);
        v26 = os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
        if (v26)
        {
          v56 = re::AssetHandle::assetInfo(v62);
          if ((v56[17] & 1) != 0)
            v57 = (char *)v56[18];
          else
            v57 = (char *)v56 + 137;
          if ((v69 & 1) != 0)
            v58 = v71;
          else
            v58 = v70;
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = v57;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v58;
          _os_log_error_impl(&dword_224FE9000, v33, OS_LOG_TYPE_ERROR, "Failed to create a response message for '%s' for peer '%s'", buf, 0x16u);
        }
        v32 = 1;
        goto LABEL_42;
      }
      if ((*((_QWORD *)v14 + 21) & 1) != 0)
        v61 = (char *)*((_QWORD *)v14 + 22);
      else
        v61 = (char *)v14 + 169;
      *(_DWORD *)v75 = 136315138;
      v76 = v61;
      v30 = "Serializing compiled file blob failed '%s'";
    }
    else
    {
      v28 = *re::assetsLogObjects(v22);
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        goto LABEL_33;
      if ((*((_QWORD *)v14 + 21) & 1) != 0)
        v29 = (char *)*((_QWORD *)v14 + 22);
      else
        v29 = (char *)v14 + 169;
      *(_DWORD *)v75 = 136315138;
      v76 = v29;
      v30 = "Serializing compiled file failed '%s'";
    }
    _os_log_error_impl(&dword_224FE9000, v28, OS_LOG_TYPE_ERROR, v30, v75, 0xCu);
    goto LABEL_33;
  }
  v8 = *re::assetsLogObjects((re *)v4);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    if ((*(_BYTE *)(a1 + 72) & 1) != 0)
      v9 = *(_QWORD *)(a1 + 80);
    else
      v9 = a1 + 73;
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v9;
    _os_log_impl(&dword_224FE9000, v8, OS_LOG_TYPE_DEFAULT, "Deiniting AssetNetworkLoader: Skipping asset serialization for %s", buf, 0xCu);
  }
}

re::DynamicString *__copy_helper_block_8_40c22_ZTSN2re11AssetHandleE64c24_ZTSN2re13DynamicStringE(uint64_t a1, uint64_t a2)
{
  re::AssetHandle::AssetHandle((re::AssetHandle *)(a1 + 40), (const re::AssetHandle *)(a2 + 40));
  return re::DynamicString::DynamicString((re::DynamicString *)(a1 + 64), (const re::DynamicString *)(a2 + 64));
}

void __destroy_helper_block_8_40c22_ZTSN2re11AssetHandleE64c24_ZTSN2re13DynamicStringE(uint64_t a1)
{
  uint64_t v2;
  _OWORD *v3;

  v3 = (_OWORD *)(a1 + 64);
  v2 = *(_QWORD *)(a1 + 64);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 72) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 80));
    *v3 = 0u;
    v3[1] = 0u;
  }
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(a1 + 40));
}

void re::internal::AssetNetworkLoader::receiveAssetResponse(re::internal::AssetNetworkLoader *this, uint64_t a2, re::internal::AssetEntry *a3, _anonymous_namespace_ *a4, unint64_t a5)
{
  os_unfair_lock_s *v10;
  re *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  _anonymous_namespace_ *v16;
  unint64_t v17;
  int v18;
  _QWORD *v19;
  uint64_t v20;
  re *v21;
  NSObject *v22;
  char *v23;
  re *v24;
  NSObject *v25;
  char *v26;
  _BYTE v27[16];
  void (**v28)(re::ExternalMemorySeekableInputStream *__hidden);
  char v29;
  _anonymous_namespace_ *v30;
  unint64_t v31;
  void (**v32)(re::FixedArrayInputStream *__hidden);
  __int16 v33;
  _QWORD *v34;
  void *v35;
  _anonymous_namespace_ *v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  _OWORD v41[2];
  _anonymous_namespace_ *v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  char v46;
  uint8_t v47[24];
  uint8_t v48[4];
  char *v49;
  uint8_t buf[96];
  char v51;
  _QWORD v52[9];

  v52[6] = *MEMORY[0x24BDAC8D0];
  v10 = (os_unfair_lock_s *)((char *)a3 + 384);
  os_unfair_lock_lock((os_unfair_lock_t)a3 + 96);
  if (*((_BYTE *)a3 + 417))
  {
    v12 = re::internal::AssetTypeRegistry::assetLoaderWithAssetType(*(_QWORD *)(*(_QWORD *)this + 1104), *((_QWORD *)a3 + 33));
    re::AssetHandle::AssetHandle((re::AssetHandle *)v47, a3);
    re::DynamicString::format((re::DynamicString *)"%llu", (re::DynamicString *)&v45, a2);
    v13 = *(_QWORD *)this;
    re::DefaultAssetSerialize::DefaultAssetSerialize((re::DefaultAssetSerialize *)buf, (const re::AssetHandle *)v47);
    *(_QWORD *)buf = off_24ED2D398;
    v51 = 1;
    re::DynamicString::DynamicString((re::DynamicString *)v52, (const re::DynamicString *)&v45);
    v52[4] = v13;
    *((_BYTE *)a3 + 417) = 0;
    v43 = a5;
    v44 = 0;
    v42 = a4;
    v14 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint8_t *, _anonymous_namespace_ *, unint64_t, unint64_t *))(**((_QWORD **)this + 2) + 8))(*((_QWORD *)this + 2), *(_QWORD *)this, *((_QWORD *)a3 + 33), buf, a4, a5, &v44);
    if (v14)
    {
      v15 = (void *)v14;
      v16 = (_anonymous_namespace_ *)re::Slice<unsigned char>::range(&v42, v44, a5);
      v18 = v17;
      v42 = v16;
      v43 = v17;
      v28 = &off_24ED7BDD0;
      v29 = 0;
      v30 = v16;
      v31 = v17;
      v19[1] = 0;
      v19[2] = 0;
      *v19 = 0;
      v33 = 256;
      v32 = &off_24ED7C2E0;
      v34 = v19;
      v35 = &unk_24ED1E828;
      v36 = v16;
      v37 = v18;
      v38 = v18;
      v39 = 0;
      v40 = v18;
      if (*((_QWORD *)a3 + 14) == -1)
        v20 = 0;
      else
        v20 = *((_QWORD *)a3 + 14);
      re::AssetSignpost::ScopeGuard::ScopeGuard((re::AssetSignpost::ScopeGuard *)v27, 2056, v20, **((const char ***)a3 + 33));
      v21 = (re *)(*(uint64_t (**)(uint64_t, void *, void (***)(re::ExternalMemorySeekableInputStream *__hidden), _QWORD))(*(_QWORD *)v12 + 24))(v12, v15, &v28, 0);
      if ((v21 & 1) != 0)
      {
        re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v27);
        re::AssetManager::processLoadedAsset_entryStateLocked(*(os_unfair_lock_s **)this, a3, v15);
      }
      else
      {
        v25 = *re::assetsLogObjects(v21);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          if ((*((_QWORD *)a3 + 21) & 1) != 0)
            v26 = (char *)*((_QWORD *)a3 + 22);
          else
            v26 = (char *)a3 + 169;
          *(_DWORD *)v48 = 136315138;
          v49 = v26;
          _os_log_error_impl(&dword_224FE9000, v25, OS_LOG_TYPE_ERROR, "Failed to create runtime data for network asset '%s'", v48, 0xCu);
        }
        re::internal::AriadneSignpostScopeGuard::~AriadneSignpostScopeGuard((re::internal::AriadneSignpostScopeGuard *)v27);
      }
      v28 = &off_24ED7BDD0;
      re::internal::MemoryInputStream<re::FixedArray<char>>::~MemoryInputStream((uint64_t)&v32);
    }
    else
    {
      v24 = *(re **)this;
      re::AssetManager::putEntryInFailedState_entryStateLocked(v24, (uint64_t)a3, 302, (uint64_t)v41);
      if (*(_QWORD *)&v41[0])
      {
        if ((BYTE8(v41[0]) & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&v41[0] + 40))();
        memset(v41, 0, sizeof(v41));
      }
    }
    *(_QWORD *)buf = off_24ED2D398;
    if (v52[0])
    {
      if ((v52[1] & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v52[0] + 40))();
      memset(v52, 0, 32);
    }
    *(_QWORD *)buf = &off_24ED2D3D0;
    re::Optional<re::AssetPath>::~Optional((uint64_t)&buf[8]);
    if (v45 && (v46 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v45 + 40))();
    re::AssetHandle::~AssetHandle((re::AssetHandle *)v47);
  }
  else
  {
    v22 = *re::assetsLogObjects(v11);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      if ((*((_QWORD *)a3 + 21) & 1) != 0)
        v23 = (char *)*((_QWORD *)a3 + 22);
      else
        v23 = (char *)a3 + 169;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v23;
      _os_log_error_impl(&dword_224FE9000, v22, OS_LOG_TYPE_ERROR, "Received unexpected asset response '%s'", buf, 0xCu);
    }
  }
  os_unfair_lock_unlock(v10);
}

uint64_t re::Slice<unsigned char>::range(_QWORD *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  uint64_t result;

  v3 = a1[1];
  if (v3 < a2)
  {
    re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. fromInclusive = %zu, size = %zu", "fromInclusive <= size()", "range", 241, a2, v3);
    _os_crash();
    __break(1u);
  }
  else if (v3 >= a3)
  {
    return *a1 + a2;
  }
  re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Index out of range. toExclusive = %zu, size = %zu", "toExclusive <= size()", "range", 242, a2, v3);
  result = _os_crash();
  __break(1u);
  return result;
}

void re::internal::AssetNetworkLoader::receiveAssetFailure(re **this, os_unfair_lock_s *a2)
{
  os_unfair_lock_s *v4;
  _anonymous_namespace_ *v5;
  re *v6;
  NSObject *v7;
  char *v8;
  _OWORD v9[2];
  uint8_t buf[4];
  char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  v4 = a2 + 96;
  os_unfair_lock_lock(a2 + 96);
  if (BYTE1(a2[104]._os_unfair_lock_opaque))
  {
    v6 = *this;
    re::AssetManager::putEntryInFailedState_entryStateLocked(v6, (uint64_t)a2, 302, (uint64_t)v9);
    if (*(_QWORD *)&v9[0])
    {
      if ((BYTE8(v9[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v9[0] + 40))();
      memset(v9, 0, sizeof(v9));
    }
  }
  else
  {
    v7 = *re::assetsLogObjects(v5);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      if ((*(_QWORD *)&a2[42]._os_unfair_lock_opaque & 1) != 0)
        v8 = *(char **)&a2[44]._os_unfair_lock_opaque;
      else
        v8 = (char *)&a2[42]._os_unfair_lock_opaque + 1;
      *(_DWORD *)buf = 136315138;
      v11 = v8;
      _os_log_error_impl(&dword_224FE9000, v7, OS_LOG_TYPE_ERROR, "Received unexpected asset request failure '%s'", buf, 0xCu);
    }
  }
  os_unfair_lock_unlock(v4);
}

uint64_t *re::internal::AssetNetworkLoader::receiveMessageFromNetworkPeer(re::internal::AssetNetworkLoader *this, unint64_t a2, char *a3, unsigned int a4)
{
  uint64_t v8;
  re *v9;
  unsigned __int8 v10;
  const re::IntrospectionBase *v11;
  uint64_t *v12;
  uint64_t v13;
  const re::internal::AssetTypeRegistry *v14;
  os_unfair_lock_s *v15;
  _anonymous_namespace_ *v16;
  char *v17;
  re *v18;
  double v19;
  re::internal::AssetNetworkLoader *v20;
  const char *v21;
  NSObject *v22;
  re *v23;
  NSObject *v24;
  const char *v25;
  char *v26;
  const char *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  re *v32;
  os_unfair_lock_s *v33;
  uint64_t v34;
  NSObject *v35;
  re *v36;
  unsigned int v37;
  int v38;
  re *v39;
  os_unfair_lock_s *v40;
  re::AssetHandle *v41;
  NSObject *v42;
  _QWORD *v43;
  char *v44;
  NSObject *v45;
  uint64_t v46;
  re::AssetHandle *v47;
  uint64_t *result;
  uint64_t v49;
  const char *v50;
  size_t v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  int v56;
  _BOOL4 v57;
  NSObject *v58;
  uint64_t v59;
  _BYTE *v60;
  re *v61;
  NSObject *v62;
  uint64_t v63;
  unsigned __int8 *AssetAsync_entryStateLocked;
  NSObject *v65;
  char *v66;
  re::AssetHandle *v67;
  __int128 v68;
  uint64_t v69;
  _QWORD *v70;
  char *v71;
  int v72;
  int v73;
  _QWORD *v74;
  char *v75;
  int v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  NSObject *log;
  uint64_t v84;
  unint64_t v85;
  char *__src;
  __int128 v87;
  __int128 v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t buf;
  _OWORD v92[2];
  __int128 v93;
  __int128 v94;
  uint64_t v95;
  uint64_t *v96;
  uint64_t *v97;
  uint64_t v98;
  char *v99;
  uint64_t v100;
  unsigned int v101;
  int v102;
  int v103;
  _QWORD v104[2];
  uint64_t v105;
  uint64_t v106;
  uint8_t v107[32];
  _BYTE v108[56];
  uint64_t v109;
  uint64_t v110;

  v110 = *MEMORY[0x24BDAC8D0];
  v104[0] = &off_24ED7C9D0;
  v104[1] = a3;
  v8 = a4;
  v105 = a4;
  v106 = 0;
  v98 = 0;
  v99 = 0;
  v100 = 0;
  v9 = (re *)re::DynamicString::setCapacity(&v97, 0);
  v10 = atomic_load((unsigned __int8 *)&qword_2540FB908);
  if ((v10 & 1) == 0)
  {
    v9 = (re *)__cxa_guard_acquire(&qword_2540FB908);
    if ((_DWORD)v9)
    {
      _MergedGlobals_43 = re::introspect_AssetSimpleMessage(0);
      __cxa_guard_release(&qword_2540FB908);
    }
  }
  v11 = (const re::IntrospectionBase *)_MergedGlobals_43;
  v12 = re::globalAllocators(v9);
  if ((v13 & 1) != 0)
  {
    v85 = a2;
    v14 = *(const re::internal::AssetTypeRegistry **)(*(_QWORD *)this + 1104);
    v15 = *(os_unfair_lock_s **)(*(_QWORD *)this + 1192);
    LODWORD(buf) = 0;
    memset(v92, 0, sizeof(v92));
    v16 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v92, 0);
    v94 = 0u;
    v93 = 0u;
    re::DynamicString::setCapacity(&v93, 0);
    v95 = 0;
    if ((v98 & 1) != 0)
      v17 = v99;
    else
      v17 = (char *)&v98 + 1;
    v19 = re::AssetPath::parse((re::AssetPath *)&buf, v17, 0, v14, v15, v108);
    if (!v108[0])
    {
      v23 = *(re **)&v108[24];
      if (*(_QWORD *)&v108[24] && (v108[32] & 1) != 0)
        v23 = (re *)(*(uint64_t (**)(_QWORD, _QWORD, double))(**(_QWORD **)&v108[24] + 40))(*(_QWORD *)&v108[24], *(_QWORD *)&v108[40], v19);
      v24 = *re::assetsLogObjects(v23);
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        goto LABEL_81;
      *(_WORD *)v108 = 0;
      v25 = "Received invalid asset network message: failed to parse asset path";
      goto LABEL_26;
    }
    if ((_DWORD)buf == 3)
    {
      if (((_DWORD)v96 - 104) > 0xFFFFFFFC)
      {
        re::DynamicString::format((re::DynamicString *)"%llu", (re::DynamicString *)v108, v85);
        if ((v108[8] & 1) != 0)
          v26 = *(char **)&v108[16];
        else
          v26 = &v108[9];
        if ((BYTE8(v93) & 1) != 0)
          v27 = (const char *)v94;
        else
          v27 = (char *)&v93 + 9;
        re::AssetPath::initPeerAssetPath((uint64_t)&buf, v26, v27, v95);
        v20 = this;
        if (*(_QWORD *)v108 && (v108[8] & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)v108 + 40))();
        goto LABEL_36;
      }
      v24 = *re::assetsLogObjects(v18);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v108 = 0;
        v25 = "Received invalid asset network message: only responses can have memory asset paths";
LABEL_26:
        _os_log_error_impl(&dword_224FE9000, v24, OS_LOG_TYPE_ERROR, v25, v108, 2u);
      }
    }
    else
    {
      v20 = this;
      if ((_DWORD)buf != 4)
      {
LABEL_36:
        *(_QWORD *)v108 = *(_QWORD *)&v92[0];
        memset(&v108[8], 0, 24);
        re::DynamicString::setCapacity(v108, 0);
        re::AssetPath::fullAssetPath((re::DynamicString *)&buf, (re::DynamicString *)v108);
        v28 = re::Hash<re::DynamicString>::operator()((uint64_t)v107, (uint64_t)v108);
        v84 = (uint64_t)v20 + 64;
        if (*((_QWORD *)v20 + 8)
          && (v29 = *(unsigned int *)(*((_QWORD *)v20 + 9) + 4 * (v28 % *((unsigned int *)v20 + 22))),
              (_DWORD)v29 != 0x7FFFFFFF))
        {
          v31 = *((_QWORD *)v20 + 10);
          while (!re::DynamicString::operator==(v31 + 80 * v29 + 16, (uint64_t)v108))
          {
            v29 = *(_DWORD *)(v31 + 80 * v29 + 8) & 0x7FFFFFFF;
            if (v29 == 0x7FFFFFFF)
            {
              v30 = 0;
              goto LABEL_44;
            }
          }
          v30 = v31 + 80 * v29 + 48;
LABEL_44:
          v20 = this;
        }
        else
        {
          v30 = 0;
        }
        v32 = *(re **)v108;
        if (*(_QWORD *)v108 && (v108[8] & 1) != 0)
          v32 = (re *)(*(uint64_t (**)(void))(**(_QWORD **)v108 + 40))();
        if ((_DWORD)v96 == 100)
        {
          v33 = re::AssetManager::assetHandle(*(os_unfair_lock_s **)v20, (const re::AssetPath *)&buf, 1, &v89);
          v34 = v90;
          if (!v90)
          {
LABEL_80:
            re::AssetHandle::~AssetHandle((re::AssetHandle *)&v89);
            goto LABEL_81;
          }
          v35 = *re::assetsLogObjects((re *)v33);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
          {
            re::AssetPath::fullAssetPath((re::AssetPath *)&buf, (re::DynamicString *)v108);
            v60 = (v108[8] & 1) != 0 ? *(_BYTE **)&v108[16] : &v108[9];
            *(_DWORD *)v107 = 134218242;
            *(_QWORD *)&v107[4] = v85;
            *(_WORD *)&v107[12] = 2080;
            *(_QWORD *)&v107[14] = v60;
            _os_log_debug_impl(&dword_224FE9000, v35, OS_LOG_TYPE_DEBUG, "Received peer asset load request from '%llu' for '%s'", v107, 0x16u);
            if (*(_QWORD *)v108)
            {
              if ((v108[8] & 1) != 0)
                (*(void (**)(void))(**(_QWORD **)v108 + 40))();
            }
          }
          v88 = 0uLL;
          v87 = *(unint64_t *)&v92[0];
          re::DynamicString::setCapacity(&v87, 0);
          re::AssetPath::fullAssetPath((re::DynamicString *)&buf, (re::DynamicString *)&v87);
          os_unfair_lock_lock((os_unfair_lock_t)(v34 + 384));
          v37 = atomic_load((unsigned int *)(v34 + 704));
          v38 = *(_DWORD *)(v34 + 420);
          if (v38 == 2)
          {
            v45 = *re::assetsLogObjects(v36);
            if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
            {
              if ((BYTE8(v87) & 1) != 0)
                v66 = (char *)v88;
              else
                v66 = (char *)&v87 + 9;
              *(_DWORD *)v108 = 136315138;
              *(_QWORD *)&v108[4] = v66;
              v50 = "Requested asset %s, is set to not sync over the network";
              goto LABEL_133;
            }
          }
          else
          {
            if (v38 == 1)
            {
              re::DynamicString::DynamicString((re::DynamicString *)v108, (const re::DynamicString *)&v87);
              v39 = v20;
              goto LABEL_67;
            }
            if (v37 == 2)
            {
              memset(&v108[16], 0, 24);
              re::DynamicString::setCapacity(&v108[8], 0);
              v47 = re::AssetHandle::AssetHandle((re::AssetHandle *)v107, (re::internal::AssetEntry *)v34);
              *(_OWORD *)&v108[40] = *(_OWORD *)v107;
              memset(v107, 0, 24);
              v109 = *(_QWORD *)&v107[16];
              re::AssetHandle::~AssetHandle(v47);
              *(_QWORD *)v108 = v85;
              re::DynamicString::operator=((re::DynamicString *)&v108[8], (re::DynamicString *)&v87);
              re::internal::AssetNetworkLoader::queueAssetSerializationResponse((uint64_t)v20, (uint64_t *)v108);
              goto LABEL_73;
            }
            if (*(_DWORD *)(v34 + 120))
            {
              if (!*(_BYTE *)(v34 + 312))
              {
                AssetAsync_entryStateLocked = re::AssetManager::loadAssetAsync_entryStateLocked(*(unsigned __int8 **)v20, (re::internal::AssetEntry *)v34, 0);
                if (v37 == 3)
                {
                  v65 = *re::assetsLogObjects((re *)AssetAsync_entryStateLocked);
                  if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
                  {
                    if ((*(_QWORD *)(v34 + 168) & 1) != 0)
                      v78 = *(_QWORD *)(v34 + 176);
                    else
                      v78 = v34 + 169;
                    v79 = *(_QWORD *)(v34 + 728);
                    v80 = *(_QWORD *)(v79 + 224);
                    v81 = *(_QWORD *)(v79 + 232);
                    v82 = v79 + 225;
                    if ((v80 & 1) != 0)
                      v82 = v81;
                    *(_DWORD *)v108 = 136315394;
                    *(_QWORD *)&v108[4] = v78;
                    *(_WORD *)&v108[12] = 2080;
                    *(_QWORD *)&v108[14] = v82;
                    _os_log_error_impl(&dword_224FE9000, v65, OS_LOG_TYPE_ERROR, "Network asset requested failed: Asset loading failed '%s' (%s)", v108, 0x16u);
                  }
                  re::DynamicString::DynamicString((re::DynamicString *)v108, (const re::DynamicString *)&v87);
                  re::internal::AssetNetworkLoader::sendFailureResponse(this, v85, v34, (re::DynamicString *)v108);
                  v46 = *(_QWORD *)v108;
                  if (!*(_QWORD *)v108)
                    goto LABEL_76;
                  goto LABEL_68;
                }
                re::DynamicString::DynamicString((re::DynamicString *)&v108[8]);
                *(_QWORD *)&v108[40] = 0;
                *(_QWORD *)&v108[48] = 0;
                v109 = 0;
                v67 = re::AssetHandle::AssetHandle((re::AssetHandle *)v107, (re::internal::AssetEntry *)v34);
                v68 = *(_OWORD *)&v108[40];
                *(_OWORD *)&v108[40] = *(_OWORD *)v107;
                *(_OWORD *)v107 = v68;
                v69 = v109;
                v109 = *(_QWORD *)&v107[16];
                *(_QWORD *)&v107[16] = v69;
                re::AssetHandle::~AssetHandle(v67);
                *(_QWORD *)v108 = v85;
                re::DynamicString::operator=((re::DynamicString *)&v108[8], (re::DynamicString *)&v87);
                re::DynamicArray<re::internal::NetworkLoadRequestData>::add((uint64_t)v20 + 24, v108);
LABEL_73:
                re::AssetHandle::~AssetHandle((re::AssetHandle *)&v108[40]);
                if (*(_QWORD *)&v108[8] && (v108[16] & 1) != 0)
                  (*(void (**)(void))(**(_QWORD **)&v108[8] + 40))();
                goto LABEL_76;
              }
              v45 = *re::assetsLogObjects(v36);
              if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
              {
                if ((*(_QWORD *)(v34 + 168) & 1) != 0)
                  v49 = *(_QWORD *)(v34 + 176);
                else
                  v49 = v34 + 169;
                *(_DWORD *)v108 = 136315138;
                *(_QWORD *)&v108[4] = v49;
                v50 = "Network asset requested failed: Memory asset is not loaded '%s'";
LABEL_133:
                _os_log_error_impl(&dword_224FE9000, v45, OS_LOG_TYPE_ERROR, v50, v108, 0xCu);
              }
            }
            else
            {
              v45 = *re::assetsLogObjects(v36);
              if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
              {
                if ((*(_QWORD *)(v34 + 168) & 1) != 0)
                  v59 = *(_QWORD *)(v34 + 176);
                else
                  v59 = v34 + 169;
                *(_DWORD *)v108 = 136315138;
                *(_QWORD *)&v108[4] = v59;
                v50 = "Network asset requested failed: Asset is empty '%s'";
                goto LABEL_133;
              }
            }
          }
          re::DynamicString::DynamicString((re::DynamicString *)v108, (const re::DynamicString *)&v87);
          v39 = this;
LABEL_67:
          re::internal::AssetNetworkLoader::sendFailureResponse(v39, v85, v34, (re::DynamicString *)v108);
          v46 = *(_QWORD *)v108;
          if (!*(_QWORD *)v108)
          {
LABEL_76:
            os_unfair_lock_unlock((os_unfair_lock_t)(v34 + 384));
            if ((_QWORD)v87)
            {
              if ((BYTE8(v87) & 1) != 0)
                (*(void (**)(void))(*(_QWORD *)v87 + 40))();
              v87 = 0u;
              v88 = 0u;
            }
            goto LABEL_80;
          }
LABEL_68:
          if ((v108[8] & 1) != 0)
            (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v46 + 40))(v46, *(_QWORD *)&v108[16]);
          memset(v108, 0, 32);
          goto LABEL_76;
        }
        if (!v30)
          goto LABEL_81;
        v40 = *(os_unfair_lock_s **)(v30 + 16);
        if (!v40)
          goto LABEL_81;
        v41 = (re::AssetHandle *)(v30 + 8);
        switch((_DWORD)v96)
        {
          case 'g':
            v51 = v105 - v106;
            v52 = &a3[v8 - (v105 - v106)];
            if (v102)
            {
              __src = v52;
              v53 = re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::FragmentedNetworkAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator[]((uint64_t)v20 + 112, (uint64_t)&v97);
              v54 = v53;
              v55 = *(char **)(v53 + 16);
              *(_QWORD *)(v53 + 16) = &v55[v51];
              v56 = *(_DWORD *)(v53 + 32);
              if (v56 != v102)
              {
                log = *re::assetsLogObjects((re *)v53);
                v57 = os_log_type_enabled(log, OS_LOG_TYPE_ERROR);
                v56 = v102;
                if (v57)
                {
                  v76 = *(_DWORD *)(v54 + 32);
                  if ((v98 & 1) != 0)
                    v77 = v99;
                  else
                    v77 = (char *)&v98 + 1;
                  *(_DWORD *)v108 = 67109634;
                  *(_DWORD *)&v108[4] = v102;
                  *(_WORD *)&v108[8] = 1024;
                  *(_DWORD *)&v108[10] = v76;
                  *(_WORD *)&v108[14] = 2080;
                  *(_QWORD *)&v108[16] = v77;
                  _os_log_error_impl(&dword_224FE9000, log, OS_LOG_TYPE_ERROR, "Received asset fragment number %u when expecting fragment number %u for asset %s. This will quite possibly corrupt the asset.", v108, 0x18u);
                  v56 = v102;
                }
              }
              *(_DWORD *)(v54 + 32) = v56 + 1;
              v52 = __src;
            }
            else
            {
              v55 = (char *)(*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)v20 + 20) + 32))(*((_QWORD *)v20 + 20), v101, 0);
              *(_QWORD *)v108 = v85;
              *(_QWORD *)&v108[8] = v55;
              *(_QWORD *)&v108[16] = &v55[v51];
              *(_DWORD *)&v108[24] = v101;
              *(_DWORD *)&v108[28] = v103;
              *(_DWORD *)&v108[32] = v102 + 1;
              re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::FragmentedNetworkAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew((uint64_t)v20 + 112, (const re::DynamicString *)&v97, (__int128 *)v108);
            }
            v61 = (re *)memcpy(v55, v52, v51);
            v62 = *re::assetsLogObjects(v61);
            if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
            {
              v72 = v102;
              v73 = v103;
              v74 = re::AssetHandle::assetInfo(v41);
              if ((v74[17] & 1) != 0)
                v75 = (char *)v74[18];
              else
                v75 = (char *)v74 + 137;
              *(_DWORD *)v108 = 67110402;
              *(_DWORD *)&v108[4] = v72;
              *(_WORD *)&v108[8] = 1024;
              *(_DWORD *)&v108[10] = v73;
              *(_WORD *)&v108[14] = 2048;
              *(_QWORD *)&v108[16] = v85;
              *(_WORD *)&v108[24] = 2080;
              *(_QWORD *)&v108[26] = v75;
              *(_WORD *)&v108[34] = 2048;
              *(_QWORD *)&v108[36] = v51;
              *(_WORD *)&v108[44] = 1024;
              *(_DWORD *)&v108[46] = a4;
              _os_log_debug_impl(&dword_224FE9000, v62, OS_LOG_TYPE_DEBUG, "Received peer fragmented asset (%u / %u) load response from '%llu' for '%s' payloadSize = %zu, bufferSize = %u", v108, 0x32u);
            }
            if (v102 != v103 - 1)
              goto LABEL_81;
            v63 = re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::FragmentedNetworkAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator[]((uint64_t)v20 + 112, (uint64_t)&v97);
            re::internal::AssetNetworkLoader::receiveMessageFromNetworkPeer(v20, v85, *(const void **)(v63 + 8), *(_DWORD *)(v63 + 24));
            re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::FragmentedNetworkAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove((uint64_t)v20 + 112, (uint64_t)&v97);
            (*(void (**)(_QWORD, _QWORD))(**((_QWORD **)v20 + 20) + 40))(*((_QWORD *)v20 + 20), *(_QWORD *)(v63 + 8));
            goto LABEL_122;
          case 'f':
            v58 = *re::assetsLogObjects(v32);
            if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG))
            {
              v70 = re::AssetHandle::assetInfo(v41);
              if ((v70[17] & 1) != 0)
                v71 = (char *)v70[18];
              else
                v71 = (char *)v70 + 137;
              *(_DWORD *)v108 = 134218242;
              *(_QWORD *)&v108[4] = v85;
              *(_WORD *)&v108[12] = 2080;
              *(_QWORD *)&v108[14] = v71;
              _os_log_debug_impl(&dword_224FE9000, v58, OS_LOG_TYPE_DEBUG, "Received peer asset load failure from '%llu' for '%s'", v108, 0x16u);
            }
            re::internal::AssetNetworkLoader::receiveAssetFailure((re **)v20, v40);
            goto LABEL_122;
          case 'e':
            v42 = *re::assetsLogObjects(v32);
            if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
            {
              v43 = re::AssetHandle::assetInfo(v41);
              if ((v43[17] & 1) != 0)
                v44 = (char *)v43[18];
              else
                v44 = (char *)v43 + 137;
              *(_DWORD *)v108 = 134218242;
              *(_QWORD *)&v108[4] = v85;
              *(_WORD *)&v108[12] = 2080;
              *(_QWORD *)&v108[14] = v44;
              _os_log_impl(&dword_224FE9000, v42, OS_LOG_TYPE_DEFAULT, "Received peer asset load response from '%llu' for '%s'", v108, 0x16u);
            }
            re::internal::AssetNetworkLoader::receiveAssetResponse(v20, v85, (re::internal::AssetEntry *)v40, (_anonymous_namespace_ *)&a3[v8 - (v105 - v106)], v105 - v106);
LABEL_122:
            re::AssetPath::fullAssetPath((re::AssetPath *)&buf, (re::DynamicString *)v108);
            re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::PendingRequestedAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(v84, (uint64_t)v108);
            if (*(_QWORD *)v108 && (v108[8] & 1) != 0)
              (*(void (**)(void))(**(_QWORD **)v108 + 40))();
            goto LABEL_81;
        }
        v24 = *re::assetsLogObjects(v32);
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          goto LABEL_81;
        *(_WORD *)v108 = 0;
        v25 = "Received invalid asset network message: unknown message type";
        goto LABEL_26;
      }
      if ((_DWORD)v96 == 100)
      {
        if ((BYTE8(v93) & 1) != 0)
          v21 = (const char *)v94;
        else
          v21 = (char *)&v93 + 9;
        re::AssetPath::initMemoryAssetPath(&buf, v21, v95);
        goto LABEL_36;
      }
      v24 = *re::assetsLogObjects(v18);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v108 = 0;
        v25 = "Received invalid asset network message: only requests can have peer asset paths";
        goto LABEL_26;
      }
    }
LABEL_81:
    if ((_QWORD)v93)
    {
      if ((BYTE8(v93) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v93 + 40))();
      v93 = 0u;
      v94 = 0u;
    }
    if (*(_QWORD *)&v92[0] && (BYTE8(v92[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v92[0] + 40))();
    goto LABEL_88;
  }
  v22 = *re::assetsLogObjects((re *)v13);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf) = 0;
    _os_log_error_impl(&dword_224FE9000, v22, OS_LOG_TYPE_ERROR, "Received invalid asset network message: failed to parse message", (uint8_t *)&buf, 2u);
  }
LABEL_88:
  result = v97;
  if (v97)
  {
    if ((v98 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v97 + 40))();
  }
  return result;
}

void re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::PendingRequestedAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  int v11;
  char v12;

  v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v12, a2);
  if (*(_QWORD *)a1)
  {
    v5 = v4 % *(unsigned int *)(a1 + 24);
    v6 = *(_QWORD *)(a1 + 8);
    v7 = *(unsigned int *)(v6 + 4 * v5);
    if ((_DWORD)v7 != 0x7FFFFFFF)
    {
      v8 = *(_QWORD *)(a1 + 16);
      if (re::DynamicString::operator==(v8 + 80 * v7 + 16, a2))
      {
        *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v8 + 80 * v7 + 8) & 0x7FFFFFFF;
LABEL_8:
        re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::PendingRequestedAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::EntryWithHash::free(*(_QWORD *)(a1 + 16) + 80 * v7);
        v11 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v7 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v7 + 8) & 0x80000000 | *(_DWORD *)(a1 + 36);
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v7;
        *(_DWORD *)(a1 + 40) = v11 + 1;
      }
      else
      {
        while (1)
        {
          v9 = v7;
          v10 = *(_DWORD *)(v8 + 80 * v7 + 8);
          v7 = v10 & 0x7FFFFFFF;
          if ((v10 & 0x7FFFFFFF) == 0x7FFFFFFF)
            break;
          if (re::DynamicString::operator==(v8 + 80 * v7 + 16, a2))
          {
            *(_DWORD *)(v8 + 80 * v9 + 8) = *(_DWORD *)(v8 + 80 * v9 + 8) & 0x80000000 | *(_DWORD *)(v8 + 80 * v7 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
}

uint64_t re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::FragmentedNetworkAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addNew(uint64_t a1, const re::DynamicString *a2, __int128 *a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  char v12;

  v6 = re::Hash<re::DynamicString>::operator()((uint64_t)&v12, (uint64_t)a2);
  v7 = v6;
  if (!*(_QWORD *)a1)
  {
    LODWORD(v8) = 0;
    goto LABEL_8;
  }
  v8 = v6 % *(unsigned int *)(a1 + 24);
  v9 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * v8);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
LABEL_8:
    result = re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::FragmentedNetworkAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, v8, v7, a2, a3);
    ++*(_DWORD *)(a1 + 40);
    return result;
  }
  v10 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    result = re::DynamicString::operator==(v10 + 88 * v9 + 16, (uint64_t)a2);
    if ((result & 1) != 0)
      return result;
    v9 = *(_DWORD *)(v10 + 88 * v9 + 8) & 0x7FFFFFFF;
    if (v9 == 0x7FFFFFFF)
      goto LABEL_8;
  }
}

uint64_t re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::FragmentedNetworkAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::operator[](uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v9;

  v4 = re::Hash<re::DynamicString>::operator()((uint64_t)&v9, a2);
  v5 = 0x7FFFFFFFLL;
  if (*(_QWORD *)a1)
  {
    v6 = *(unsigned int *)(*(_QWORD *)(a1 + 8) + 4 * (v4 % *(unsigned int *)(a1 + 24)));
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a1 + 16);
      v5 = 0x7FFFFFFFLL;
      while (!re::DynamicString::operator==(v7 + 88 * v6 + 16, a2))
      {
        v6 = *(_DWORD *)(v7 + 88 * v6 + 8) & 0x7FFFFFFF;
        if (v6 == 0x7FFFFFFF)
          return *(_QWORD *)(a1 + 16) + 88 * v5 + 48;
      }
      v5 = v6;
    }
  }
  return *(_QWORD *)(a1 + 16) + 88 * v5 + 48;
}

unint64_t re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::FragmentedNetworkAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(uint64_t a1, uint64_t a2)
{
  unint64_t result;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int *v14;
  int v15;
  uint64_t v16;
  _OWORD *v17;
  unint64_t v18;
  int v19;
  char v20;

  result = re::Hash<re::DynamicString>::operator()((uint64_t)&v20, a2);
  if (*(_QWORD *)a1)
  {
    v5 = result % *(unsigned int *)(a1 + 24);
    v6 = *(_QWORD *)(a1 + 8);
    v7 = *(unsigned int *)(v6 + 4 * v5);
    if ((_DWORD)v7 != 0x7FFFFFFF)
    {
      v8 = *(_QWORD *)(a1 + 16);
      result = re::DynamicString::operator==(v8 + 88 * v7 + 16, a2);
      if ((result & 1) != 0)
      {
        *(_DWORD *)(v6 + 4 * v5) = *(_DWORD *)(v8 + 88 * v7 + 8) & 0x7FFFFFFF;
LABEL_8:
        v11 = *(_QWORD *)(a1 + 16);
        v12 = v11 + 88 * v7;
        v15 = *(_DWORD *)(v12 + 8);
        v14 = (int *)(v12 + 8);
        v13 = v15;
        if (v15 < 0)
        {
          *v14 = v13 & 0x7FFFFFFF;
          v16 = v11 + 88 * v7;
          v18 = *(_QWORD *)(v16 + 16);
          v17 = (_OWORD *)(v16 + 16);
          result = v18;
          if (v18)
          {
            if ((*(_BYTE *)(v11 + 88 * v7 + 24) & 1) != 0)
              result = (*(uint64_t (**)(unint64_t, _QWORD))(*(_QWORD *)result + 40))(result, *(_QWORD *)(v11 + 88 * v7 + 32));
            *v17 = 0u;
            v17[1] = 0u;
          }
          v11 = *(_QWORD *)(a1 + 16);
          v13 = *(_DWORD *)(v11 + 88 * v7 + 8);
        }
        v19 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(v11 + 88 * v7 + 8) = *(_DWORD *)(a1 + 36) | v13 & 0x80000000;
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v7;
        *(_DWORD *)(a1 + 40) = v19 + 1;
      }
      else
      {
        while (1)
        {
          v9 = v7;
          v10 = *(_DWORD *)(v8 + 88 * v7 + 8);
          v7 = v10 & 0x7FFFFFFF;
          if ((v10 & 0x7FFFFFFF) == 0x7FFFFFFF)
            break;
          result = re::DynamicString::operator==(v8 + 88 * v7 + 16, a2);
          if ((result & 1) != 0)
          {
            *(_DWORD *)(v8 + 88 * v9 + 8) = *(_DWORD *)(v8 + 88 * v9 + 8) & 0x80000000 | *(_DWORD *)(v8 + 88 * v7 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
  return result;
}

uint64_t re::internal::AssetNetworkLoader::sendRequestToNetworkPeer_entryStateLocked(uint64_t a1, uint64_t a2, uint64_t a3, re::DynamicString *a4)
{
  NSObject *v8;
  _BOOL8 v9;
  _anonymous_namespace_ *v10;
  unsigned __int8 v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  _anonymous_namespace_ *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  re *v21;
  re *v22;
  uint64_t result;
  uint64_t v24;
  uint64_t v25;
  _BYTE v26[24];
  _OWORD v27[2];
  _OWORD v28[2];
  uint64_t v29;
  uint64_t v30;
  char v31;
  uint8_t buf[4];
  _BYTE v33[20];
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v8 = *re::assetsLogObjects((re *)a1);
  v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG);
  if (v9)
  {
    if ((*(_QWORD *)(a2 + 168) & 1) != 0)
      v24 = *(_QWORD *)(a2 + 176);
    else
      v24 = a2 + 169;
    *(_DWORD *)buf = 134218242;
    *(_QWORD *)v33 = a3;
    *(_WORD *)&v33[8] = 2080;
    *(_QWORD *)&v33[10] = v24;
    _os_log_debug_impl(&dword_224FE9000, v8, OS_LOG_TYPE_DEBUG, "Sending peer asset load request to '%llu' for '%s'", buf, 0x16u);
  }
  *(_QWORD *)&v33[12] = 0;
  v34 = 0;
  v35 = 0;
  re::DynamicString::setCapacity(&v33[4], 0);
  *(_DWORD *)buf = 100;
  v10 = re::DynamicString::operator=((re::DynamicString *)&v33[4], a4);
  v11 = atomic_load((unsigned __int8 *)&qword_2540FB908);
  if ((v11 & 1) == 0 && __cxa_guard_acquire(&qword_2540FB908))
  {
    _MergedGlobals_43 = re::introspect_AssetSimpleMessage(0);
    __cxa_guard_release(&qword_2540FB908);
  }
  v29 = 0;
  v30 = 0;
  if ((v12 & 1) != 0)
  {
    v13 = v30;
    v14 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), a3, v30, v29);
    if ((v14 & 1) != 0)
    {
      *(_BYTE *)(a2 + 417) = 1;
      v25 = a3;
      re::AssetHandle::AssetHandle((re::AssetHandle *)v26, (re::internal::AssetEntry *)a2);
      v16 = re::Hash<re::DynamicString>::operator()((uint64_t)&v31, (uint64_t)a4);
      v17 = v16;
      if (*(_QWORD *)(a1 + 64))
      {
        v18 = v16 % *(unsigned int *)(a1 + 88);
        v19 = *(unsigned int *)(*(_QWORD *)(a1 + 72) + 4 * v18);
        if ((_DWORD)v19 != 0x7FFFFFFF)
        {
          v20 = *(_QWORD *)(a1 + 80);
          while (!re::DynamicString::operator==(v20 + 80 * v19 + 16, (uint64_t)a4))
          {
            v19 = *(_DWORD *)(v20 + 80 * v19 + 8) & 0x7FFFFFFF;
            if (v19 == 0x7FFFFFFF)
              goto LABEL_20;
          }
          goto LABEL_21;
        }
      }
      else
      {
        LODWORD(v18) = 0;
      }
LABEL_20:
      re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::PendingRequestedAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1 + 64, v18, v17, a4, &v25);
      ++*(_DWORD *)(a1 + 104);
LABEL_21:
      re::AssetHandle::~AssetHandle((re::AssetHandle *)v26);
      goto LABEL_22;
    }
    v22 = *(re **)a1;
    re::AssetManager::putEntryInFailedState_entryStateLocked(v22, a2, 302, (uint64_t)v27);
    if (*(_QWORD *)&v27[0])
    {
      if ((BYTE8(v27[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v27[0] + 40))();
      memset(v27, 0, sizeof(v27));
    }
  }
  else
  {
    v21 = *(re **)a1;
    re::AssetManager::putEntryInFailedState_entryStateLocked(v21, a2, 302, (uint64_t)v28);
    if (*(_QWORD *)&v28[0])
    {
      if ((BYTE8(v28[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v28[0] + 40))();
      memset(v28, 0, sizeof(v28));
    }
  }
LABEL_22:
  result = *(_QWORD *)&v33[4];
  if (*(_QWORD *)&v33[4])
  {
    if ((v33[12] & 1) != 0)
      return (*(uint64_t (**)(_QWORD))(**(_QWORD **)&v33[4] + 40))(*(_QWORD *)&v33[4]);
  }
  return result;
}

uint64_t re::DynamicArray<re::internal::NetworkLoadRequestData>::removeAt(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2 <= a2)
  {
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  if (v2 - 1 > a2)
  {
    v4 = *(_QWORD *)(a1 + 32);
    v5 = v4 + (v2 << 6);
    v6 = v4 + (a2 << 6);
    *(_QWORD *)v6 = *(_QWORD *)(v5 - 64);
    re::DynamicString::operator=((re::DynamicString *)(v6 + 8), (re::DynamicString *)(v5 - 56));
    v7 = *(_OWORD *)(v6 + 40);
    *(_QWORD *)(v6 + 40) = 0;
    v8 = *(_QWORD *)(v5 - 16);
    *(_QWORD *)(v6 + 40) = *(_QWORD *)(v5 - 24);
    *(_QWORD *)(v6 + 48) = v8;
    *(_OWORD *)(v5 - 24) = v7;
    v9 = *(_QWORD *)(v6 + 56);
    *(_QWORD *)(v6 + 56) = *(_QWORD *)(v5 - 8);
    *(_QWORD *)(v5 - 8) = v9;
    v2 = *(_QWORD *)(a1 + 16);
  }
  v10 = *(_QWORD *)(a1 + 32) + (v2 << 6);
  re::AssetHandle::~AssetHandle((re::AssetHandle *)(v10 - 24));
  result = *(_QWORD *)(v10 - 56);
  if (result)
  {
    if ((*(_BYTE *)(v10 - 48) & 1) != 0)
      result = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)result + 40))(result, *(_QWORD *)(v10 - 40));
    *(_OWORD *)(v10 - 56) = 0u;
    *(_OWORD *)(v10 - 40) = 0u;
  }
  --*(_QWORD *)(a1 + 16);
  ++*(_DWORD *)(a1 + 24);
  return result;
}

uint64_t re::internal::AssetNetworkLoader::update(re::internal::AssetNetworkLoader *this)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  re *v8;
  unsigned int v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t *v22;
  re::DynamicString *v23;
  int v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  _BOOL8 v28;
  _QWORD *v29;
  char *v30;
  uint64_t v31;
  _anonymous_namespace_ *v32;
  uint64_t v33;
  size_t v34;
  re *v35;
  NSObject *v36;
  _anonymous_namespace_ *v37;
  unsigned __int8 v38;
  const re::IntrospectionBase *v39;
  _anonymous_namespace_ *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  size_t v46;
  NSObject *v47;
  uint64_t v48;
  size_t v49;
  int v50;
  _BYTE *v51;
  uint64_t v52;
  BOOL v53;
  NSObject *v54;
  NSObject *v55;
  char *v56;
  NSObject *v57;
  uint8_t *v58;
  _QWORD *v59;
  char *v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  char *v64;
  NSObject *v65;
  uint8_t *v66;
  uint64_t v67;
  _BYTE *v68;
  re::DynamicString *v70;
  uint64_t *v71;
  unint64_t v72;
  uint64_t v73;
  __int128 v74;
  int v75;
  uint64_t *v76;
  _OWORD v77[2];
  _OWORD v78[2];
  void (**v79)(re::MemoryStreamWriter *__hidden);
  uint64_t v80;
  size_t v81;
  uint64_t v82;
  void (**v83)(re::NullStreamWriter *__hidden);
  int v84;
  uint8_t buf[48];
  __int128 v86;
  __int128 v87;
  _BYTE v88[12];
  __int16 v89;
  uint64_t v90;
  __int16 v91;
  int v92;
  __int16 v93;
  unsigned int v94;
  __int16 v95;
  size_t v96;
  __int16 v97;
  size_t v98;
  uint8_t v99[4];
  _BYTE v100[36];
  int v101;
  int v102;
  unsigned int v103;
  uint64_t v104;

  v104 = *MEMORY[0x24BDAC8D0];
  if ((int)*((_QWORD *)this + 5) >= 1)
  {
    v2 = *((_QWORD *)this + 5) + 1;
    while (1)
    {
      v3 = (v2 - 2);
      v4 = *((_QWORD *)this + 5);
      if (v4 <= v3)
      {
        *(_QWORD *)v88 = 0;
        v86 = 0u;
        v87 = 0u;
        memset(buf, 0, sizeof(buf));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v99 = 136315906;
        *(_QWORD *)v100 = "operator[]";
        *(_WORD *)&v100[8] = 1024;
        *(_DWORD *)&v100[10] = 789;
        *(_WORD *)&v100[14] = 2048;
        *(_QWORD *)&v100[16] = (v2 - 2);
        *(_WORD *)&v100[24] = 2048;
        *(_QWORD *)&v100[26] = v4;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      v5 = *((_QWORD *)this + 7);
      v6 = (uint64_t *)(v5 + (v3 << 6));
      v7 = v6[6];
      os_unfair_lock_lock((os_unfair_lock_t)(v7 + 384));
      v9 = atomic_load((unsigned int *)(v7 + 704));
      if (!v9)
      {
        v10 = *re::assetsLogObjects(v8);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          if ((*(_BYTE *)(v7 + 168) & 1) != 0)
            v14 = *(_QWORD *)(v7 + 176);
          else
            v14 = v7 + 169;
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v14;
          _os_log_error_impl(&dword_224FE9000, v10, OS_LOG_TYPE_ERROR, "Network asset requested failed: Asset didn't load '%s'", buf, 0xCu);
        }
        v11 = *v6;
        re::DynamicString::DynamicString((re::DynamicString *)v77, (const re::DynamicString *)(v5 + (v3 << 6) + 8));
        re::internal::AssetNetworkLoader::sendFailureResponse(this, v11, v7, (re::DynamicString *)v77);
        if (*(_QWORD *)&v77[0])
        {
          if ((BYTE8(v77[0]) & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)&v77[0] + 40))();
          memset(v77, 0, sizeof(v77));
        }
        goto LABEL_18;
      }
      if (v9 == 3)
        break;
      if (v9 == 2)
      {
        re::internal::AssetNetworkLoader::queueAssetSerializationResponse((uint64_t)this, (uint64_t *)(v5 + (v3 << 6)));
LABEL_18:
        re::DynamicArray<re::internal::NetworkLoadRequestData>::removeAt((uint64_t)this + 24, (v2 - 2));
      }
      os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 384));
      if ((unint64_t)--v2 <= 1)
        goto LABEL_31;
    }
    v12 = *re::assetsLogObjects(v8);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      if ((*(_BYTE *)(v7 + 168) & 1) != 0)
        v15 = *(_QWORD *)(v7 + 176);
      else
        v15 = v7 + 169;
      v16 = *(_QWORD *)(v7 + 728);
      v17 = *(_QWORD *)(v16 + 224);
      v18 = *(_QWORD *)(v16 + 232);
      v19 = v16 + 225;
      if ((v17 & 1) != 0)
        v19 = v18;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v15;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v19;
      _os_log_error_impl(&dword_224FE9000, v12, OS_LOG_TYPE_ERROR, "Network asset requested failed: Asset loading failed '%s' (%s)", buf, 0x16u);
    }
    v13 = *v6;
    re::DynamicString::DynamicString((re::DynamicString *)v78, (const re::DynamicString *)(v5 + (v3 << 6) + 8));
    re::internal::AssetNetworkLoader::sendFailureResponse(this, v13, v7, (re::DynamicString *)v78);
    if (*(_QWORD *)&v78[0])
    {
      if ((BYTE8(v78[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v78[0] + 40))();
      memset(v78, 0, sizeof(v78));
    }
    goto LABEL_18;
  }
LABEL_31:
  os_unfair_lock_lock((os_unfair_lock_t)this + 48);
  memset(buf, 0, 24);
  v73 = 0;
  v74 = 0u;
  *(_QWORD *)&buf[32] = 0;
  v76 = 0;
  v75 = 1;
  *(_DWORD *)&buf[24] = 1;
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)&v73, (uint64_t)this + 200);
  re::DynamicArray<re::DataArray<re::RigGraphNode>::ElementBlock>::operator=((uint64_t)this + 200, (uint64_t)buf);
  re::DynamicArray<re::internal::AssetNetworkLoader::SerializedAssetResponse>::deinit((uint64_t)buf);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 48);
  if (*((_QWORD *)&v74 + 1))
  {
    v21 = v76;
    v22 = &v76[14 * *((_QWORD *)&v74 + 1)];
    v23 = (re::DynamicString *)&v100[4];
    while (1)
    {
      v24 = *((unsigned __int8 *)v21 + 104);
      v25 = *re::assetsLogObjects((re *)v20);
      if (v24)
      {
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          v59 = re::AssetHandle::assetInfo((re::AssetHandle *)(v21 + 1));
          if ((v59[17] & 1) != 0)
            v60 = (char *)v59[18];
          else
            v60 = (char *)v59 + 137;
          v61 = *v21;
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = v60;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v61;
          _os_log_error_impl(&dword_224FE9000, v25, OS_LOG_TYPE_ERROR, "Failed to serialize reponse for asset '%s' for Peer '%llu'", buf, 0x16u);
        }
        v26 = *v21;
        v27 = v21[2];
        re::DynamicString::DynamicString((re::DynamicString *)buf, (const re::DynamicString *)(v21 + 4));
        re::internal::AssetNetworkLoader::sendFailureResponse(this, v26, v27, (re::DynamicString *)buf);
        v20 = *(_QWORD *)buf;
        if (*(_QWORD *)buf && (buf[8] & 1) != 0)
          v20 = (*(uint64_t (**)(void))(**(_QWORD **)buf + 40))();
        goto LABEL_100;
      }
      v28 = os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT);
      if (v28)
      {
        v29 = re::AssetHandle::assetInfo((re::AssetHandle *)(v21 + 1));
        if ((v29[17] & 1) != 0)
          v30 = (char *)v29[18];
        else
          v30 = (char *)v29 + 137;
        v31 = *v21;
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v30;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v31;
        _os_log_impl(&dword_224FE9000, v25, OS_LOG_TYPE_DEFAULT, "Sending network response for asset '%s' to Peer '%llu'", buf, 0x16u);
      }
      v32 = (_anonymous_namespace_ *)re::AssetSimpleMessage::maxBytesPerPacket((re::AssetSimpleMessage *)v28);
      v33 = v21[10];
      if (!v32 || (v34 = (size_t)v32, v72 = v21[10], v72 <= (unint64_t)v32))
      {
        v20 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1), *v21, v21[12], v33);
        v53 = v20;
        goto LABEL_66;
      }
      memset(&buf[8], 0, 32);
      re::DynamicString::setCapacity(&buf[8], 0);
      *(_DWORD *)buf = 101;
      v35 = re::DynamicString::operator=((re::DynamicString *)&buf[8], (re::DynamicString *)(v21 + 4));
      LODWORD(v86) = (v33 - 1) / v34 + 1;
      *(_DWORD *)&buf[40] = v33;
      *(_DWORD *)&buf[44] = -1;
      v36 = *re::assetsLogObjects(v35);
      v37 = (_anonymous_namespace_ *)os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)v37)
      {
        v66 = &buf[17];
        if ((buf[16] & 1) != 0)
          v66 = *(uint8_t **)&buf[24];
        v67 = *v21;
        *(_DWORD *)v99 = 136315650;
        *(_QWORD *)v100 = v66;
        *(_WORD *)&v100[8] = 2048;
        *(_QWORD *)&v100[10] = v67;
        *(_WORD *)&v100[18] = 1024;
        *(_DWORD *)&v100[20] = v86;
        _os_log_debug_impl(&dword_224FE9000, v36, OS_LOG_TYPE_DEBUG, "Asset %s for peer %llu needs to be fragmented (%u)", v99, 0x1Cu);
      }
      v38 = atomic_load((unsigned __int8 *)&qword_2540FB908);
      if ((v38 & 1) == 0)
      {
        v37 = (_anonymous_namespace_ *)__cxa_guard_acquire(&qword_2540FB908);
        if ((_DWORD)v37)
        {
          _MergedGlobals_43 = re::introspect_AssetSimpleMessage(0);
          __cxa_guard_release(&qword_2540FB908);
        }
      }
      v39 = (const re::IntrospectionBase *)_MergedGlobals_43;
      memset(&v100[12], 0, 24);
      re::DynamicString::setCapacity(v23, 0);
      v40 = re::DynamicString::operator=(v23, (re::DynamicString *)&buf[8]);
      v101 = *(_DWORD *)&buf[40];
      v83 = &off_24ED7C150;
      v84 = 0;
      if ((v41 & 1) == 0)
        break;
      v42 = v84;
      if (!v84)
      {
        v57 = *re::assetsLogObjects((re *)v41);
        if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
        {
          v58 = &buf[17];
          if ((buf[16] & 1) != 0)
            v58 = *(uint8_t **)&buf[24];
LABEL_107:
          *(_DWORD *)v88 = 136315138;
          *(_QWORD *)&v88[4] = v58;
          _os_log_error_impl(&dword_224FE9000, v57, OS_LOG_TYPE_ERROR, "Failed to serialize network message for '%s'", v88, 0xCu);
          v50 = 0;
          v62 = 0;
          goto LABEL_93;
        }
LABEL_82:
        v50 = 0;
        v62 = 0;
        goto LABEL_93;
      }
      v103 = (*(_DWORD *)&buf[40] - 1) / v34 + 1;
      *(_DWORD *)v99 = 103;
      v44 = v43;
      v102 = 0;
      if (v103)
      {
        v70 = v23;
        v71 = v22;
        v45 = 0;
        while (1)
        {
          if (v34 >= v72 - v45)
            v46 = v72 - v45;
          else
            v46 = v34;
          v79 = &off_24ED7C6A0;
          v80 = v44;
          v81 = v46 + v42;
          v82 = 0;
          v47 = *re::assetsLogObjects((re *)v43);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
          {
            v51 = &v100[13];
            if ((v100[12] & 1) != 0)
              v51 = *(_BYTE **)&v100[20];
            v52 = *v21;
            *(_DWORD *)v88 = 136316418;
            *(_QWORD *)&v88[4] = v51;
            v89 = 2048;
            v90 = v52;
            v91 = 1024;
            v92 = v102;
            v93 = 1024;
            v94 = v103;
            v95 = 2048;
            v96 = v46;
            v97 = 2048;
            v98 = v46 + v42;
            _os_log_debug_impl(&dword_224FE9000, v47, OS_LOG_TYPE_DEBUG, "Sending '%s' fragmented to peer '%llu', current fragment (%u/ %u) payloadSize = %zu, bytesSent = %zu", v88, 0x36u);
          }
          if ((v48 & 1) == 0)
            break;
          if (v81 - v82 >= v46)
            v49 = v46;
          else
            v49 = v81 - v82;
          memcpy((void *)(v80 + v82), (const void *)(v21[12] + v45), v49);
          v82 += v49;
          v43 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, size_t))(**((_QWORD **)this + 1) + 16))(*((_QWORD *)this + 1), *v21, v44, v46 + v42);
          v50 = v43;
          if (++v102 < v103)
          {
            v45 += v46;
            if ((v43 & 1) != 0)
              continue;
          }
          v23 = v70;
          v22 = v71;
          goto LABEL_92;
        }
        v65 = *re::assetsLogObjects((re *)v48);
        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
        {
          v68 = &v100[13];
          if ((v100[12] & 1) != 0)
            v68 = *(_BYTE **)&v100[20];
          *(_DWORD *)v88 = 136315138;
          *(_QWORD *)&v88[4] = v68;
          _os_log_error_impl(&dword_224FE9000, v65, OS_LOG_TYPE_ERROR, "Failed to serialize network message for '%s'", v88, 0xCu);
        }
        v62 = 0;
        v50 = 1;
        v23 = v70;
        v22 = v71;
      }
      else
      {
        v50 = 1;
LABEL_92:
        v62 = 1;
      }
LABEL_93:
      if (*(_QWORD *)&v100[4] && (v100[12] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v100[4] + 40))();
      v20 = *(_QWORD *)&buf[8];
      if (*(_QWORD *)&buf[8] && (buf[16] & 1) != 0)
        v20 = (*(uint64_t (**)(void))(**(_QWORD **)&buf[8] + 40))();
      v53 = v50 != 0;
      if (!v62)
        goto LABEL_100;
LABEL_66:
      v54 = *re::assetsLogObjects((re *)v20);
      v20 = os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)v20)
      {
        v63 = *v21;
        if ((v21[5] & 1) != 0)
          v64 = (char *)v21[6];
        else
          v64 = (char *)v21 + 41;
        *(_DWORD *)buf = 134218242;
        *(_QWORD *)&buf[4] = v63;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v64;
        _os_log_debug_impl(&dword_224FE9000, v54, OS_LOG_TYPE_DEBUG, "Sending peer asset load result to '%llu' for '%s'", buf, 0x16u);
        if (!v53)
        {
LABEL_68:
          v55 = *re::assetsLogObjects((re *)v20);
          v20 = os_log_type_enabled(v55, OS_LOG_TYPE_ERROR);
          if ((_DWORD)v20)
          {
            if ((v21[5] & 1) != 0)
              v56 = (char *)v21[6];
            else
              v56 = (char *)v21 + 41;
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v56;
            _os_log_error_impl(&dword_224FE9000, v55, OS_LOG_TYPE_ERROR, "Failed to send message for '%s'", buf, 0xCu);
          }
        }
      }
      else if (!v53)
      {
        goto LABEL_68;
      }
LABEL_100:
      v21 += 14;
      if (v21 == v22)
        return re::DynamicArray<re::internal::AssetNetworkLoader::SerializedAssetResponse>::deinit((uint64_t)&v73);
    }
    v57 = *re::assetsLogObjects((re *)v41);
    if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
    {
      v58 = &buf[17];
      if ((buf[16] & 1) != 0)
        v58 = *(uint8_t **)&buf[24];
      goto LABEL_107;
    }
    goto LABEL_82;
  }
  return re::DynamicArray<re::internal::AssetNetworkLoader::SerializedAssetResponse>::deinit((uint64_t)&v73);
}

_QWORD *re::DynamicArray<re::internal::AssetNetworkLoader::SerializedAssetResponse>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::internal::AssetNetworkLoader::SerializedAssetResponse>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (is_mul_ok(a2, 0x70uLL))
        {
          v2 = 112 * a2;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, 112 * a2, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_24;
            goto LABEL_11;
          }
        }
        else
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 112, a2);
          _os_crash();
          __break(1u);
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_24:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = 0;
        v11 = 112 * v9;
        do
        {
          v12 = &v7[v10 / 8];
          v13 = v8 + v10;
          *v12 = *(_QWORD *)(v8 + v10);
          v12[1] = 0;
          v12[2] = 0;
          v12[3] = 0;
          v12[2] = *(_QWORD *)(v8 + v10 + 16);
          *(_QWORD *)(v13 + 16) = 0;
          v14 = v7[v10 / 8 + 1];
          v12[1] = 0;
          v12[1] = *(_QWORD *)(v8 + v10 + 8);
          *(_QWORD *)(v8 + v10 + 8) = v14;
          v15 = v7[v10 / 8 + 3];
          v12[3] = *(_QWORD *)(v8 + v10 + 24);
          *(_QWORD *)(v13 + 24) = v15;
          *((_OWORD *)v12 + 2) = 0u;
          *((_OWORD *)v12 + 3) = 0u;
          v16 = (_QWORD *)(v8 + v10 + 32);
          v12[4] = *v16;
          *v16 = 0;
          v12[7] = *(_QWORD *)(v8 + v10 + 56);
          *(_QWORD *)(v13 + 56) = 0;
          v18 = v7[v10 / 8 + 5];
          v17 = v7[v10 / 8 + 6];
          v19 = *(_QWORD *)(v8 + v10 + 48);
          v12[5] = *(_QWORD *)(v8 + v10 + 40);
          v12[6] = v19;
          *(_QWORD *)(v13 + 40) = v18;
          *(_QWORD *)(v13 + 48) = v17;
          v12[12] = 0;
          *((_DWORD *)v12 + 22) = 0;
          v12[9] = 0;
          v12[10] = 0;
          v12[8] = 0;
          v20 = (_QWORD *)(v8 + v10 + 64);
          v21 = *(_QWORD *)(v8 + v10 + 72);
          v12[8] = *v20;
          *v20 = 0;
          v12[9] = v21;
          *(_QWORD *)(v13 + 72) = 0;
          v22 = v7[v10 / 8 + 10];
          v12[10] = *(_QWORD *)(v8 + v10 + 80);
          *(_QWORD *)(v13 + 80) = v22;
          v23 = v7[v10 / 8 + 12];
          v12[12] = *(_QWORD *)(v8 + v10 + 96);
          *(_QWORD *)(v13 + 96) = v23;
          *(_DWORD *)(v13 + 88) = *(_DWORD *)(v8 + v10 + 88) + 1;
          *((_DWORD *)v12 + 22) = LODWORD(v7[v10 / 8 + 11]) + 1;
          *((_BYTE *)v12 + 104) = *(_BYTE *)(v8 + v10 + 104);
          if (*v20)
          {
            if (v23)
              (*(void (**)(_QWORD))(*(_QWORD *)*v20 + 40))(*v20);
            *(_QWORD *)(v13 + 96) = 0;
            *(_QWORD *)(v8 + v10 + 72) = 0;
            *(_QWORD *)(v8 + v10 + 80) = 0;
            *v20 = 0;
            ++*(_DWORD *)(v13 + 88);
          }
          if (*v16)
          {
            if ((*(_BYTE *)(v13 + 40) & 1) != 0)
              (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*v16 + 40))(*v16, *(_QWORD *)(v13 + 48));
            *(_OWORD *)v16 = 0u;
            *(_OWORD *)(v8 + v10 + 48) = 0u;
          }
          re::AssetHandle::~AssetHandle((re::AssetHandle *)(v8 + v10 + 8));
          v10 += 112;
        }
        while (v11 != v10);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_24;
    }
  }
  return result;
}

void std::__function::__func<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_0,std::allocator<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_0>,void ()(unsigned long long,void const*,unsigned int)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_0,std::allocator<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_0>,void ()(unsigned long long,void const*,unsigned int)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24ED2CE08;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_0,std::allocator<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_0>,void ()(unsigned long long,void const*,unsigned int)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED2CE08;
  a2[1] = v2;
  return result;
}

uint64_t *std::__function::__func<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_0,std::allocator<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_0>,void ()(unsigned long long,void const*,unsigned int)>::operator()(uint64_t a1, unint64_t *a2, char **a3, unsigned int *a4)
{
  return re::internal::AssetNetworkLoader::receiveMessageFromNetworkPeer(*(re::internal::AssetNetworkLoader **)(a1 + 8), *a2, *a3, *a4);
}

uint64_t std::__function::__func<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_0,std::allocator<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_0>,void ()(unsigned long long,void const*,unsigned int)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_0,std::allocator<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_0>,void ()(unsigned long long,void const*,unsigned int)>::target_type()
{
}

void std::__function::__func<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_1,std::allocator<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_1>,void ()(unsigned long long)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_1,std::allocator<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_1>,void ()(unsigned long long)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24ED2CE98;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_1,std::allocator<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_1>,void ()(unsigned long long)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED2CE98;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_1,std::allocator<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_1>,void ()(unsigned long long)>::operator()(_anonymous_namespace_ *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  re *v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  int v8;
  NSObject *v9;
  _BOOL4 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  re::DynamicString *v24;
  uint64_t v25;
  os_unfair_lock_s *v26;
  re *v27;
  re *v28;
  NSObject *v29;
  unsigned int v30;
  unsigned int v31;
  char *v32;
  _OWORD v33[2];
  uint64_t v34;
  char v35;
  _QWORD v36[2];
  uint64_t v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  const char *v42;
  __int16 v43;
  int v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  unint64_t v48;
  uint8_t buf[32];
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;

  v53 = *MEMORY[0x24BDAC8D0];
  v2 = *a2;
  v3 = *((_QWORD *)a1 + 1);
  v39 = 0;
  v36[1] = 0;
  v37 = 0;
  v38 = 0;
  re::DynamicArray<re::DynamicString>::setCapacity(v36, 0);
  ++v38;
  v4 = (re *)re::DynamicString::format((re::DynamicString *)"%llu", (re::DynamicString *)&v34, v2);
  v5 = *(unsigned int *)(v3 + 96);
  if ((_DWORD)v5)
  {
    v6 = 0;
    v7 = (int *)(*(_QWORD *)(v3 + 80) + 8);
    while (1)
    {
      v8 = *v7;
      v7 += 20;
      if (v8 < 0)
        break;
      if (v5 == ++v6)
      {
        LODWORD(v6) = *(_DWORD *)(v3 + 96);
        break;
      }
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if ((_DWORD)v5 != (_DWORD)v6)
  {
    v21 = v6;
    do
    {
      v22 = *(_QWORD *)(v3 + 80);
      v23 = v22 + 80 * v21;
      if (*(_QWORD *)(v23 + 48) == v2)
      {
        v24 = (re::DynamicString *)(v23 + 16);
        v25 = *(_QWORD *)(v22 + 80 * v21 + 64);
        if (v25)
        {
          v26 = (os_unfair_lock_s *)(v25 + 384);
          os_unfair_lock_lock((os_unfair_lock_t)(v25 + 384));
          if (*(_BYTE *)(v25 + 417))
          {
            v28 = *(re **)v3;
            re::DynamicString::format((re::DynamicString *)"Network peer %llu has left", (re::DynamicString *)v33, v2);
            re::AssetManager::putEntryInFailedState_entryStateLocked(v28, v25, 302, (uint64_t)v33);
            if (*(_QWORD *)&v33[0])
            {
              if ((BYTE8(v33[0]) & 1) != 0)
                (*(void (**)(void))(**(_QWORD **)&v33[0] + 40))();
              memset(v33, 0, sizeof(v33));
            }
            re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)v36, v24);
          }
          else
          {
            v29 = *re::assetsLogObjects(v27);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            {
              if ((*(_BYTE *)(v22 + 80 * v21 + 24) & 1) != 0)
                v32 = *(char **)(v22 + 80 * v21 + 32);
              else
                v32 = (char *)v24 + 9;
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = v32;
              _os_log_error_impl(&dword_224FE9000, v29, OS_LOG_TYPE_ERROR, "Pending requested asset state is inconsistent: expected loading-from-peer state: %s", buf, 0xCu);
            }
          }
          os_unfair_lock_unlock(v26);
        }
        else
        {
          v4 = re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)v36, v24);
        }
      }
      v30 = *(_DWORD *)(v3 + 96);
      if (v30 <= (int)v6 + 1)
        v30 = v6 + 1;
      while (1)
      {
        v21 = (v6 + 1);
        if (v30 - 1 == (_DWORD)v6)
          break;
        LODWORD(v6) = v6 + 1;
        v31 = v21;
        if ((*(_DWORD *)(*(_QWORD *)(v3 + 80) + 80 * v21 + 8) & 0x80000000) != 0)
          goto LABEL_49;
      }
      v31 = v30;
LABEL_49:
      LODWORD(v6) = v31;
    }
    while ((_DWORD)v5 != v31);
  }
  if (v37)
  {
    v9 = *re::assetsLogObjects(v4);
    v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    v11 = v37;
    if (v10)
    {
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = v37;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v2;
      _os_log_impl(&dword_224FE9000, v9, OS_LOG_TYPE_DEFAULT, "%zu network asset load outstanding request(s) to peer '%llu' are being abandoned due to that peer leaving", buf, 0x16u);
      v11 = v37;
    }
    if (v11)
    {
      v12 = v39;
      v13 = v39 + 32 * v11;
      do
      {
        re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::PendingRequestedAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(v3 + 64, v12);
        v14 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, v12);
        if (*(_QWORD *)(v3 + 112))
        {
          v15 = *(unsigned int *)(*(_QWORD *)(v3 + 120) + 4 * (v14 % *(unsigned int *)(v3 + 136)));
          if ((_DWORD)v15 != 0x7FFFFFFF)
          {
            v16 = *(_QWORD *)(v3 + 128);
            while (!re::DynamicString::operator==(v16 + 88 * v15 + 16, v12))
            {
              v15 = *(_DWORD *)(v16 + 88 * v15 + 8) & 0x7FFFFFFF;
              if (v15 == 0x7FFFFFFF)
                goto LABEL_20;
            }
            (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(v3 + 160) + 40))(*(_QWORD *)(v3 + 160), *(_QWORD *)(v16 + 88 * v15 + 56));
            re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::FragmentedNetworkAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(v3 + 112, v12);
          }
        }
LABEL_20:
        v12 += 32;
      }
      while (v12 != v13);
    }
  }
  if ((int)*(_QWORD *)(v3 + 40) >= 1)
  {
    v17 = *(_QWORD *)(v3 + 40) + 1;
    do
    {
      v18 = (v17 - 2);
      v19 = *(_QWORD *)(v3 + 40);
      if (v19 <= v18)
      {
        v40 = 0;
        v51 = 0u;
        v52 = 0u;
        v50 = 0u;
        memset(buf, 0, sizeof(buf));
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        v41 = 136315906;
        v42 = "operator[]";
        v43 = 1024;
        v44 = 789;
        v45 = 2048;
        v46 = (v17 - 2);
        v47 = 2048;
        v48 = v19;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      if (*(_QWORD *)(*(_QWORD *)(v3 + 56) + (v18 << 6)) == v2)
        re::DynamicArray<re::internal::NetworkLoadRequestData>::removeAt(v3 + 24, (v17 - 2));
      --v17;
    }
    while (v17 > 1);
  }
  if (v34 && (v35 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v34 + 40))();
  return re::DynamicArray<re::DynamicString>::deinit((uint64_t)v36);
}

uint64_t std::__function::__func<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_1,std::allocator<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_1>,void ()(unsigned long long)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_1,std::allocator<re::internal::AssetNetworkLoader::init(re::AssetManager *,re::AssetNetworkMessaging *,re::NetworkAssetSerializationService *)::$_1>,void ()(unsigned long long)>::target_type()
{
}

_QWORD *re::DynamicArray<re::internal::NetworkLoadRequestData>::setCapacity(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v3 = result[1];
  if (v3 != a2)
  {
    v5 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (!*v5)
      {
        result = (_QWORD *)re::DynamicArray<re::internal::NetworkLoadRequestData>::setCapacity(v5, a2);
        ++*((_DWORD *)v5 + 6);
        return result;
      }
      if (a2)
      {
        if (a2 >> 58)
        {
          re::internal::assertLog((re::internal *)6, a2, "assertion failure: '%s' (%s:line %i) Size overflow in DynamicArray<T>::setCapacity(). Element size = %zu, capacity = %zu", "!overflow", "setCapacity", 615, 64, a2);
          _os_crash();
          __break(1u);
        }
        else
        {
          v2 = a2 << 6;
          result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, a2 << 6, 8);
          if (result)
          {
            v7 = result;
            if (!v5[1])
              goto LABEL_20;
            goto LABEL_11;
          }
        }
        re::internal::assertLog((re::internal *)6, v6, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, v2, *(_QWORD *)(*v5 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
        return result;
      }
      v7 = 0;
      if (!v3)
      {
LABEL_20:
        v5[4] = v7;
        v5[1] = a2;
        return result;
      }
LABEL_11:
      v8 = v5[4];
      v9 = v5[2];
      if (v9)
      {
        v10 = (_QWORD *)(v8 + 32);
        v11 = v9 << 6;
        v12 = v7;
        do
        {
          *v12 = *(v10 - 4);
          *(_OWORD *)(v12 + 1) = 0u;
          *(_OWORD *)(v12 + 3) = 0u;
          v12[1] = *(v10 - 3);
          *(v10 - 3) = 0;
          v12[4] = *v10;
          *v10 = 0;
          v14 = v12[2];
          v13 = v12[3];
          v15 = *(v10 - 1);
          v12[2] = *(v10 - 2);
          v12[3] = v15;
          *(v10 - 2) = v14;
          *(v10 - 1) = v13;
          v12[5] = 0;
          v12[6] = 0;
          v12[7] = 0;
          v12[6] = v10[2];
          v10[2] = 0;
          v16 = v12[5];
          v12[5] = 0;
          v12[5] = v10[1];
          v10[1] = v16;
          v17 = v12[7];
          v12[7] = v10[3];
          v10[3] = v17;
          re::AssetHandle::~AssetHandle((re::AssetHandle *)(v10 + 1));
          if (*(v10 - 3))
          {
            if ((*(_BYTE *)(v10 - 2) & 1) != 0)
              (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*(v10 - 3) + 40))(*(v10 - 3), *(v10 - 1));
            *(_OWORD *)(v10 - 3) = 0u;
            *(_OWORD *)(v10 - 1) = 0u;
          }
          v10 += 8;
          v12 += 8;
          v11 -= 64;
        }
        while (v11);
        v8 = v5[4];
      }
      result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)*v5 + 40))(*v5, v8);
      goto LABEL_20;
    }
  }
  return result;
}

_QWORD *re::DynamicArray<char>::setCapacity(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  void *v6;

  v2 = result[1];
  if (v2 != a2)
  {
    v4 = result;
    if (result[2] <= a2)
    {
      result = (_QWORD *)*result;
      if (*v4)
      {
        if (!a2)
        {
          v6 = 0;
          if (!v2)
            goto LABEL_8;
          goto LABEL_7;
        }
        result = (_QWORD *)(*(uint64_t (**)(_QWORD *, unint64_t, uint64_t))(*result + 32))(result, a2, 1);
        if (result)
        {
          v6 = result;
          if (!v4[1])
          {
LABEL_8:
            v4[4] = v6;
            v4[1] = a2;
            return result;
          }
LABEL_7:
          memcpy(v6, (const void *)v4[4], v4[2]);
          result = (_QWORD *)(*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)*v4 + 40))(*v4, v4[4]);
          goto LABEL_8;
        }
        re::internal::assertLog((re::internal *)6, v5, "assertion failure: '%s' (%s:line %i) DynamicArray<T> is out of memory (tried to allocate %zu bytes from allocator '%s').", "newData", "setCapacity", 619, a2, *(_QWORD *)(*v4 + 8));
        result = (_QWORD *)_os_crash();
        __break(1u);
      }
      else
      {
        result = (_QWORD *)re::DynamicArray<char>::setCapacity(v4, a2);
        ++*((_DWORD *)v4 + 6);
      }
    }
  }
  return result;
}

uint64_t re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::FragmentedNetworkAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, const re::DynamicString *a4, __int128 *a5)
{
  uint64_t v10;
  int v11;
  int v12;
  signed int v13;
  uint64_t v14;
  BOOL v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  signed int v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  _BYTE v32[44];

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      v12 = *(_DWORD *)(a1 + 28);
      v13 = 2 * v12;
      v14 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v13)
          v15 = (_DWORD)v10 == v13;
        else
          v15 = 1;
        if (!v15 && (v12 & 0x80000000) == 0)
        {
          memset(v32, 0, 36);
          *(_QWORD *)&v32[36] = 0x7FFFFFFFLL;
          re::HashTable<re::StringID,re::RigDataTypeClass,re::Hash<re::StringID>,re::EqualTo<re::StringID>,false,false>::init((uint64_t)v32, v14, v13);
          v16 = *(_OWORD *)v32;
          *(_OWORD *)v32 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v16;
          v17 = *(_QWORD *)&v32[16];
          v18 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v32[16] = v18;
          *(_QWORD *)(a1 + 16) = v17;
          v20 = *(_OWORD *)&v32[24];
          *(_OWORD *)&v32[24] = *(_OWORD *)(a1 + 24);
          v19 = *(_OWORD *)&v32[24];
          *(_OWORD *)(a1 + 24) = v20;
          v21 = DWORD2(v19);
          if (DWORD2(v19))
          {
            v22 = 0;
            v23 = v18 + 48;
            do
            {
              if ((*(_DWORD *)(v23 - 40) & 0x80000000) != 0)
                re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::FragmentedNetworkAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(_QWORD *)(v23 - 48) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v23 - 48), v23 - 32, v23);
              ++v22;
              v23 += 88;
            }
            while (v22 < v21);
          }
          re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::FragmentedNetworkAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v32, *(double *)&v19);
        }
      }
      else
      {
        if (v13)
          v26 = 2 * v12;
        else
          v26 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v24 = *(_QWORD *)(a1 + 16);
    v25 = *(_DWORD *)(v24 + 88 * v10 + 8);
  }
  else
  {
    v24 = *(_QWORD *)(a1 + 16);
    v25 = *(_DWORD *)(v24 + 88 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v25 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v24 + 88 * v10 + 8) = v25 | 0x80000000;
  v27 = 88 * v10;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + v27 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + v27 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + v27) = a3;
  re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + v27 + 16), a4);
  v28 = *(_QWORD *)(a1 + 16) + 88 * v10;
  v29 = *a5;
  v30 = a5[1];
  *(_QWORD *)(v28 + 80) = *((_QWORD *)a5 + 4);
  *(_OWORD *)(v28 + 48) = v29;
  *(_OWORD *)(v28 + 64) = v30;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return v10;
}

re::DynamicString *re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::PendingRequestedAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, const re::DynamicString *a4, _QWORD *a5)
{
  uint64_t v10;
  int v11;
  int v12;
  signed int v13;
  uint64_t v14;
  BOOL v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  __int128 v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  signed int v26;
  re::DynamicString *result;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE v31[44];

  v10 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v10 == 0x7FFFFFFF)
  {
    v10 = *(unsigned int *)(a1 + 32);
    v11 = v10;
    if ((_DWORD)v10 == *(_DWORD *)(a1 + 24))
    {
      v12 = *(_DWORD *)(a1 + 28);
      v13 = 2 * v12;
      v14 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v13)
          v15 = (_DWORD)v10 == v13;
        else
          v15 = 1;
        if (!v15 && (v12 & 0x80000000) == 0)
        {
          memset(v31, 0, 36);
          *(_QWORD *)&v31[36] = 0x7FFFFFFFLL;
          re::HashTable<re::ecs2::Scene *,re::BucketArray<RESubscriptionHandle,8ul>,re::Hash<re::ecs2::Scene *>,re::EqualTo<re::ecs2::Scene *>,true,false>::init((uint64_t)v31, v14, v13);
          v16 = *(_OWORD *)v31;
          *(_OWORD *)v31 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v16;
          v17 = *(_QWORD *)&v31[16];
          v18 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v31[16] = v18;
          *(_QWORD *)(a1 + 16) = v17;
          v20 = *(_OWORD *)&v31[24];
          *(_OWORD *)&v31[24] = *(_OWORD *)(a1 + 24);
          v19 = *(_DWORD *)&v31[32];
          *(_OWORD *)(a1 + 24) = v20;
          v21 = v19;
          if (v19)
          {
            v22 = 0;
            v23 = v18 + 48;
            do
            {
              if ((*(_DWORD *)(v23 - 40) & 0x80000000) != 0)
                re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::PendingRequestedAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove(a1, *(_QWORD *)(v23 - 48) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v23 - 48), v23 - 32, v23);
              ++v22;
              v23 += 80;
            }
            while (v22 < v21);
          }
          re::HashTable<re::DynamicString,re::internal::AssetNetworkLoader::PendingRequestedAsset,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)v31);
        }
      }
      else
      {
        if (v13)
          v26 = 2 * v12;
        else
          v26 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v11 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v11 + 1;
    v24 = *(_QWORD *)(a1 + 16);
    v25 = *(_DWORD *)(v24 + 80 * v10 + 8);
  }
  else
  {
    v24 = *(_QWORD *)(a1 + 16);
    v25 = *(_DWORD *)(v24 + 80 * v10 + 8);
    *(_DWORD *)(a1 + 36) = v25 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v24 + 80 * v10 + 8) = v25 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10) = a3;
  result = re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(a1 + 16) + 80 * v10 + 16), a4);
  v28 = (_QWORD *)(*(_QWORD *)(a1 + 16) + 80 * v10);
  v28[6] = *a5;
  v28[7] = 0;
  v28[8] = 0;
  v28[9] = 0;
  v28[8] = a5[2];
  a5[2] = 0;
  v29 = v28[7];
  v28[7] = 0;
  v28[7] = a5[1];
  a5[1] = v29;
  v30 = v28[9];
  v28[9] = a5[3];
  a5[3] = v30;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v10;
  ++*(_DWORD *)(a1 + 28);
  return result;
}

uint64_t *re::allocInfo_FileAssetLoadDescriptorParameters(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_44);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_44))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FB928, 0);
    *(uint64_t *)((char *)&qword_2540FB938 + 6) = 0;
    qword_2540FB938 = 0;
    qword_2540FB948 = 0;
    qword_2540FB950 = 0xFFFFFFFFLL;
    qword_2540FB928 = (uint64_t)&off_24ED7DAA8;
    qword_2540FB958 = (uint64_t)"FileAssetLoadDescriptorParameters";
    dword_2540FB960 = 0;
    unk_2540FB968 = 0u;
    unk_2540FB978 = 0u;
    unk_2540FB988 = 0u;
    qword_2540FB998 = 0;
    __cxa_guard_release(&_MergedGlobals_44);
  }
  return &qword_2540FB928;
}

void re::initInfo_FileAssetLoadDescriptorParameters(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  unsigned __int8 v4;
  re *v5;
  uint64_t *v6;
  const re::IntrospectionBase *v7;
  void *v8;
  uint64_t v9;
  __int128 v10;
  _QWORD v11[2];
  __int128 v12;

  v11[0] = 0x2764D90FB3166F26;
  v11[1] = "FileAssetLoadDescriptorParameters";
  re::StringID::destroyString((re::StringID *)v11);
  *((_OWORD *)this + 2) = v12;
  v4 = atomic_load((unsigned __int8 *)&qword_2540FB920);
  if ((v4 & 1) == 0)
  {
    v5 = (re *)__cxa_guard_acquire(&qword_2540FB920);
    if ((_DWORD)v5)
    {
      v6 = re::introspectionAllocator(v5);
      v8 = re::IntrospectionInfo<re::DynamicString>::get(1, v7);
      v9 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6 + 32))(v6, 72, 8);
      *(_DWORD *)v9 = 1;
      *(_QWORD *)(v9 + 8) = "path";
      *(_QWORD *)(v9 + 16) = v8;
      *(_QWORD *)(v9 + 24) = 0;
      *(_QWORD *)(v9 + 32) = 1;
      *(_DWORD *)(v9 + 40) = 0;
      *(_QWORD *)(v9 + 48) = 0;
      *(_QWORD *)(v9 + 56) = 0;
      *(_DWORD *)(v9 + 64) = 0;
      qword_2540FB918 = v9;
      __cxa_guard_release(&qword_2540FB920);
    }
  }
  *((_QWORD *)this + 2) = 0x2000000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 1;
  *((_QWORD *)this + 8) = &qword_2540FB918;
  *((_QWORD *)this + 9) = re::internal::defaultConstruct<re::FileAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 10) = re::internal::defaultDestruct<re::FileAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = re::internal::defaultConstructV2<re::FileAssetLoadDescriptorParameters>;
  *((_QWORD *)this + 14) = re::internal::defaultDestructV2<re::FileAssetLoadDescriptorParameters>;
  re::IntrospectionRegistry::add(this, v3);
  v10 = v12;
}

_QWORD *re::internal::defaultConstruct<re::FileAssetLoadDescriptorParameters>(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  return re::DynamicString::setCapacity((_QWORD *)a3, 0);
}

double re::internal::defaultDestruct<re::FileAssetLoadDescriptorParameters>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  double result;

  if (*a3)
  {
    if ((a3[1] & 1) != 0)
      (*(void (**)(_QWORD, _QWORD))(*(_QWORD *)*a3 + 40))(*a3, a3[2]);
    result = 0.0;
    *(_OWORD *)a3 = 0u;
    *((_OWORD *)a3 + 1) = 0u;
  }
  return result;
}

_QWORD *re::internal::defaultConstructV2<re::FileAssetLoadDescriptorParameters>(_anonymous_namespace_ *a1)
{
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  return re::DynamicString::setCapacity(a1, 0);
}

double re::internal::defaultDestructV2<re::FileAssetLoadDescriptorParameters>(uint64_t *a1)
{
  uint64_t v2;
  double result;

  v2 = *a1;
  if (v2)
  {
    if ((a1[1] & 1) != 0)
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[2]);
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
  }
  return result;
}

_anonymous_namespace_ *re::FileAssetProvider::FileAssetProvider(_anonymous_namespace_ *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 v8;
  __guard *v9;
  int v11;

  ArcSharedObject::ArcSharedObject(a1, 0);
  *(_QWORD *)a1 = &off_24ED2CF28;
  *((_QWORD *)a1 + 3) = 0;
  *((_QWORD *)a1 + 4) = 0;
  *((_QWORD *)a1 + 5) = 0;
  if ((v8 & 1) == 0)
  {
    if (v11)
    {
      re::introspect<re::FileAssetLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"FileAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_FileAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_FileAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::FileAssetLoadDescriptorParameters>, 0);
    }
  }
  re::FileAssetProvider::s_loadDescriptorParametersIntrospect = v9[64];
  *((_QWORD *)a1 + 4) = a3;
  *((_QWORD *)a1 + 5) = a4;
  *((_QWORD *)a1 + 3) = a2;
  return a1;
}

void re::FileAssetProvider::~FileAssetProvider(re::FileAssetProvider *this)
{
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

uint64_t re::FileAssetProvider::makeDescriptor@<X0>(_anonymous_namespace_ *a1@<X0>, re::DynamicString *a2@<X1>, uint64_t a3@<X8>)
{
  _anonymous_namespace_ *v6;
  _anonymous_namespace_ *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  _OWORD v11[2];
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 24) = 0;
  v6 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)a3, 0);
  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 40) = 0;
  *(_DWORD *)(a3 + 56) = 0;
  *(_QWORD *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_DWORD *)(a3 + 96) = 0;
  *(_OWORD *)(a3 + 104) = 0u;
  *(_OWORD *)(a3 + 120) = 0u;
  *(_QWORD *)(a3 + 136) = 0;
  re::DynamicString::setCapacity((_QWORD *)(a3 + 112), 0);
  v12 = (uint64_t *)"FileAsset";
  v13 = 9;
  re::DynamicString::operator=((re::DynamicString *)a3, (uint64_t)&v12);
  v7 = re::DynamicString::operator=((re::DynamicString *)(a3 + 112), a2);
  v13 = 0;
  v14 = 0;
  v15 = 0;
  re::DynamicString::setCapacity(&v12, 0);
  re::DynamicString::operator=((re::DynamicString *)&v12, a1);
  re::DynamicString::DynamicString((re::DynamicString *)v11, (const re::DynamicString *)&v12);
  re::AssetLoadDescriptor::setIntrospectableData((char **)a3, (const re::IntrospectionBase *)re::FileAssetProvider::s_loadDescriptorParametersIntrospect, (const re::IntrospectionBase **)v11, 0);
  if (*(_QWORD *)&v11[0])
  {
    if ((BYTE8(v11[0]) & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)&v11[0] + 40))();
    memset(v11, 0, sizeof(v11));
  }
  result = (uint64_t)v12;
  if (v12)
  {
    if ((v13 & 1) != 0)
      return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(*v12 + 40))(v12, v14, v8, v9);
  }
  return result;
}

re::DynamicString *re::FileAssetProvider::load@<X0>(re::internal::AssetTypeRegistry **this@<X0>, const re::AssetLoadDescriptor *a2@<X1>, re::AssetSerializationScheme *a3@<X3>, uint64_t a4@<X8>)
{
  const char *v9;
  _anonymous_namespace_ *v10;
  re::DynamicString *result;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t Descriptor;
  char *v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;

  if ((*((_BYTE *)a2 + 8) & 1) != 0)
    v9 = (const char *)*((_QWORD *)a2 + 2);
  else
    v9 = (char *)a2 + 9;
  v10 = (_anonymous_namespace_ *)strcmp(v9, "FileAsset");
  if ((_DWORD)v10)
  {
    v12 = v23;
    v13 = v24;
    v14 = v25;
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v12;
    *(_QWORD *)(a4 + 24) = v13;
    *(_QWORD *)(a4 + 32) = v14;
  }
  else
  {
    *((_QWORD *)&v23 + 1) = 0;
    v24 = 0;
    v25 = 0;
    re::DynamicString::setCapacity(&v23, 0);
    Descriptor = re::AssetLoadDescriptor::getIntrospectableData<re::FileAssetLoadDescriptorParameters>(a2, (uint64_t **)&v23);
    if ((Descriptor & 1) != 0)
    {
      if ((*((_BYTE *)a2 + 120) & 1) != 0)
        v16 = (char *)*((_QWORD *)a2 + 16);
      else
        v16 = (char *)a2 + 121;
      re::loadCompiledOrSourceFile((char *)&v23, v16, this + 3, (uint64_t)a3, a4);
    }
    else
    {
      v17 = v20;
      v18 = v21;
      v19 = v22;
      *(_BYTE *)a4 = 0;
      *(_OWORD *)(a4 + 8) = v17;
      *(_QWORD *)(a4 + 24) = v18;
      *(_QWORD *)(a4 + 32) = v19;
    }
    result = (re::DynamicString *)v23;
    if ((_QWORD)v23)
    {
      if ((BYTE8(v23) & 1) != 0)
        return (re::DynamicString *)(*(uint64_t (**)(void))(*(_QWORD *)v23 + 40))();
    }
  }
  return result;
}

uint64_t re::AssetLoadDescriptor::getIntrospectableData<re::FileAssetLoadDescriptorParameters>(re::AssetLoadDescriptor *a1, uint64_t **a2)
{
  uint64_t **v2;
  unsigned __int8 v3;
  __guard *v4;
  int v6;
  int v7;
  re::AssetLoadDescriptor *v9;

  v2 = a2;
  if ((v3 & 1) == 0)
  {
    v9 = a1;
    v7 = v6;
    v2 = a2;
    a1 = v9;
    if (v7)
    {
      re::introspect<re::FileAssetLoadDescriptorParameters>(void)::info = re::internal::getOrCreateInfo((re::internal *)"FileAssetLoadDescriptorParameters", (uint64_t (*)(re::internal *))re::allocInfo_FileAssetLoadDescriptorParameters, (re::IntrospectionBase *(*)(void))re::initInfo_FileAssetLoadDescriptorParameters, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::FileAssetLoadDescriptorParameters>, 0);
      v2 = a2;
      a1 = v9;
    }
  }
  return re::AssetLoadDescriptor::getIntrospectableData(a1, (re **)v4[64], v2, 0);
}

uint64_t *re::FileAssetProvider::resolveChild@<X0>(const re::AssetLoadDescriptor *a1@<X1>, re::AssetProvider *a2@<X2>, const char *a3@<X3>, uint64_t a4@<X8>)
{
  const char *v9;
  _anonymous_namespace_ *v10;
  uint64_t *result;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  re::PathBuffer *v15;
  _anonymous_namespace_ *v16;
  uint64_t v17;
  __n128 v18;
  uint64_t v19;
  uint64_t v20;
  _OWORD v21[2];
  _BYTE v22[40];
  __int128 v23;
  int v24;
  __int128 v25;
  __int128 v26;
  int v27;
  _BYTE v28[24];
  __int128 v29;
  _BYTE v30[40];
  __int128 v31;
  int v32;
  __int128 v33;
  __int128 v34;
  int v35;
  _BYTE v36[24];
  __int128 v37;
  uint64_t v38;
  char v39;
  uint64_t *v40;
  uint64_t v41;
  re::PathBuffer *v42;
  uint64_t v43;

  if ((*((_BYTE *)a1 + 8) & 1) != 0)
    v9 = (const char *)*((_QWORD *)a1 + 2);
  else
    v9 = (char *)a1 + 9;
  v10 = (_anonymous_namespace_ *)strcmp(v9, "FileAsset");
  if ((_DWORD)v10)
  {
    result = (uint64_t *)re::DynamicString::format((re::DynamicString *)"Scheme %s does not match scheme %s.", (re::DynamicString *)v30, v9, "FileAsset");
    v12 = *(_OWORD *)v30;
    v13 = *(_OWORD *)&v30[16];
    *(_BYTE *)a4 = 0;
    *(_OWORD *)(a4 + 8) = v12;
    *(_OWORD *)(a4 + 24) = v13;
  }
  else
  {
    v41 = 0;
    v42 = 0;
    v43 = 0;
    re::DynamicString::setCapacity(&v40, 0);
    v14 = re::AssetLoadDescriptor::getIntrospectableData<re::FileAssetLoadDescriptorParameters>(a1, &v40);
    if ((v14 & 1) != 0)
    {
      if ((v41 & 1) != 0)
        v15 = v42;
      else
        v15 = (re::PathBuffer *)((char *)&v41 + 1);
      v16 = (_anonymous_namespace_ *)re::AssetProvider::resolveChildPath(a2, v15, &v38);
      re::FileAssetProvider::makeDescriptor((_anonymous_namespace_ *)&v38, (re::DynamicString *)v21, (uint64_t)v22);
      v17 = *(_QWORD *)v22;
      memset(v22, 0, sizeof(v22));
      *(_QWORD *)v30 = v17;
      *(_OWORD *)&v30[24] = *(_OWORD *)&v22[24];
      *(_OWORD *)&v30[8] = *(_OWORD *)&v22[8];
      v31 = v23;
      v23 = 0u;
      ++v24;
      v32 = 1;
      v33 = v25;
      v34 = v26;
      v25 = 0u;
      v26 = 0u;
      ++v27;
      v35 = 1;
      *(_OWORD *)v36 = *(_OWORD *)v28;
      memset(v28, 0, sizeof(v28));
      v37 = v29;
      *(_QWORD *)&v36[16] = *(_QWORD *)&v28[16];
      v29 = 0uLL;
      v18.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional(a4, (uint64_t)v30);
      if (*(_QWORD *)&v36[8])
      {
        if ((v36[16] & 1) != 0)
          (*(void (**)(double))(**(_QWORD **)&v36[8] + 40))(v18.n128_f64[0]);
        v18 = 0uLL;
        *(_OWORD *)&v36[8] = 0u;
        v37 = 0u;
      }
      if (*((_QWORD *)&v33 + 1))
      {
        if (*(_QWORD *)v36)
          (*(void (**)(__n128))(**((_QWORD **)&v33 + 1) + 40))(v18);
        *(_QWORD *)v36 = 0;
        v34 = 0uLL;
        *((_QWORD *)&v33 + 1) = 0;
        ++v35;
      }
      if (*(_QWORD *)&v30[32])
      {
        if ((_QWORD)v33)
          (*(void (**)(__n128))(**(_QWORD **)&v30[32] + 40))(v18);
        *(_QWORD *)&v33 = 0;
        v31 = 0uLL;
        *(_QWORD *)&v30[32] = 0;
        ++v32;
      }
      if (*(_QWORD *)v30)
      {
        if ((v30[8] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)v30 + 40))(v18);
        v18 = 0uLL;
        memset(v30, 0, 32);
      }
      if (*(_QWORD *)&v28[8])
      {
        if ((v28[16] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)&v28[8] + 40))(v18);
        v18 = 0uLL;
        *(_OWORD *)&v28[8] = 0u;
        v29 = 0u;
      }
      if (*((_QWORD *)&v25 + 1))
      {
        if (*(_QWORD *)v28)
          (*(void (**)(__n128))(**((_QWORD **)&v25 + 1) + 40))(v18);
        *(_QWORD *)v28 = 0;
        v26 = 0uLL;
        *((_QWORD *)&v25 + 1) = 0;
        ++v27;
      }
      if (*(_QWORD *)&v22[32])
      {
        if ((_QWORD)v25)
          (*(void (**)(__n128))(**(_QWORD **)&v22[32] + 40))(v18);
        *(_QWORD *)&v25 = 0;
        v23 = 0uLL;
        *(_QWORD *)&v22[32] = 0;
        ++v24;
      }
      if (*(_QWORD *)v22)
      {
        if ((v22[8] & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)v22 + 40))(v18);
        v18 = 0uLL;
        memset(v22, 0, 32);
      }
      if (*(_QWORD *)&v21[0])
      {
        if ((BYTE8(v21[0]) & 1) != 0)
          (*(void (**)(__n128))(**(_QWORD **)&v21[0] + 40))(v18);
        v18 = 0uLL;
        memset(v21, 0, sizeof(v21));
      }
      if (v38 && (v39 & 1) != 0)
        (*(void (**)(__n128))(*(_QWORD *)v38 + 40))(v18);
    }
    else
    {
      v18 = *(__n128 *)v30;
      v19 = *(_QWORD *)&v30[16];
      v20 = *(_QWORD *)&v30[24];
      *(_BYTE *)a4 = 0;
      *(__n128 *)(a4 + 8) = v18;
      *(_QWORD *)(a4 + 24) = v19;
      *(_QWORD *)(a4 + 32) = v20;
    }
    result = v40;
    if (v40)
    {
      if ((v41 & 1) != 0)
        return (uint64_t *)(*(uint64_t (**)(__n128))(*v40 + 40))(v18);
    }
  }
  return result;
}

uint64_t *re::FileAssetProvider::getDescription(re::FileAssetProvider *this, const re::AssetLoadDescriptor *a2, re::DynamicString *a3)
{
  uint64_t *result;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[2];

  v7 = 0;
  v8 = 0;
  v9 = 0;
  re::DynamicString::setCapacity(&v6, 0);
  if (re::AssetLoadDescriptor::getIntrospectableData<re::FileAssetLoadDescriptorParameters>(a2, &v6))
  {
    re::DynamicString::operator=(a3, (re::DynamicString *)&v6);
  }
  else
  {
    v10[0] = "mangled";
    v10[1] = 7;
    re::DynamicString::operator=(a3, (uint64_t)v10);
  }
  result = v6;
  if (v6)
  {
    if ((v7 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v6 + 40))();
  }
  return result;
}

uint64_t *re::FileAssetProvider::getAssetPathForRelease@<X0>(_anonymous_namespace_ *a1@<X0>, re::AssetLoadDescriptor *a2@<X1>, const re::internal::AssetTypeRegistry *a3@<X2>, os_unfair_lock_s *a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v9;
  char *v10;
  _anonymous_namespace_ *v11;
  _anonymous_namespace_ *v12;
  char *v13;
  double v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *result;
  uint64_t v19;
  __int128 v20;
  uint64_t v21;
  char v22[24];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  _BYTE v34[23];
  uint64_t *v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;

  v36 = 0;
  v37 = 0;
  v38 = 0;
  re::DynamicString::setCapacity(&v35, 0);
  v9 = re::AssetLoadDescriptor::getIntrospectableData<re::FileAssetLoadDescriptorParameters>(a2, &v35);
  if ((v9 & 1) != 0)
  {
    if ((v36 & 1) != 0)
      v10 = v37;
    else
      v10 = (char *)&v36 + 1;
    v11 = (_anonymous_namespace_ *)re::DynamicString::format((re::DynamicString *)"sourcepath:%s", (re::DynamicString *)&v32, v10);
    LODWORD(v25) = 0;
    v27 = 0;
    v28 = 0;
    v26 = 0;
    v12 = (_anonymous_namespace_ *)re::DynamicString::setCapacity((_QWORD *)&v25 + 1, 0);
    *((_QWORD *)&v29 + 1) = 0;
    v30 = 0uLL;
    re::DynamicString::setCapacity(&v29, 0);
    v31 = 0;
    if ((v33 & 1) != 0)
      v13 = *(char **)&v34[7];
    else
      v13 = v34;
    v14 = re::AssetPath::parse((re::AssetPath *)&v25, v13, 0, a3, a4, v22);
    if (!v22[0] && (_QWORD)v23)
    {
      if ((BYTE8(v23) & 1) != 0)
        (*(void (**)(double))(*(_QWORD *)v23 + 40))(v14);
      v23 = 0u;
      v24 = 0u;
    }
    re::DynamicString::DynamicString((re::DynamicString *)&v19, (const re::DynamicString *)&v32);
    *(_BYTE *)a5 = 1;
    *(_QWORD *)(a5 + 8) = v19;
    *(_QWORD *)(a5 + 32) = v21;
    *(_OWORD *)(a5 + 16) = v20;
    if ((_QWORD)v29)
    {
      if ((BYTE8(v29) & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v29 + 40))();
      v29 = 0u;
      v30 = 0u;
    }
    if (*((_QWORD *)&v25 + 1) && (v26 & 1) != 0)
      (*(void (**)(void))(**((_QWORD **)&v25 + 1) + 40))();
    if (v32 && (v33 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v32 + 40))();
  }
  else
  {
    v15 = v25;
    v16 = v26;
    v17 = v27;
    *(_BYTE *)a5 = 0;
    *(_OWORD *)(a5 + 8) = v15;
    *(_QWORD *)(a5 + 24) = v16;
    *(_QWORD *)(a5 + 32) = v17;
  }
  result = v35;
  if (v35)
  {
    if ((v36 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(void))(*v35 + 40))();
  }
  return result;
}

uint64_t *re::FileAssetProvider::makeDescriptorFromAssetPath@<X0>(re::FileAssetProvider *this@<X0>, const char ***a2@<X1>, uint64_t a3@<X8>)
{
  _anonymous_namespace_ *v5;
  const char *v6;
  __n128 v7;
  uint64_t *result;
  _OWORD v9[2];
  _OWORD v10[2];
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v24 = 0;
  v25 = 0;
  v26 = 0;
  re::DynamicString::setCapacity(&v23, 0);
  v5 = (_anonymous_namespace_ *)re::AssetPath::filePathToAsset((re::AssetPath *)a2, (re::DynamicString *)&v23, 1, 0);
  v6 = *a2[9];
  re::FileAssetProvider::makeDescriptor((_anonymous_namespace_ *)&v23, (re::DynamicString *)v9, (uint64_t)v10);
  v7.n128_f64[0] = re::Optional<re::AssetLoadDescriptor>::Optional(a3, (uint64_t)v10);
  if ((_QWORD)v21)
  {
    if ((BYTE8(v21) & 1) != 0)
      (*(void (**)(double))(*(_QWORD *)v21 + 40))(v7.n128_f64[0]);
    v7 = 0uLL;
    v21 = 0u;
    v22 = 0u;
  }
  if (v16)
  {
    if (v20)
      (*(void (**)(__n128))(*(_QWORD *)v16 + 40))(v7);
    v20 = 0;
    v17 = 0;
    v18 = 0;
    v16 = 0;
    ++v19;
  }
  if (v11)
  {
    if (v15)
      (*(void (**)(__n128))(*(_QWORD *)v11 + 40))(v7);
    v15 = 0;
    v12 = 0;
    v13 = 0;
    v11 = 0;
    ++v14;
  }
  if (*(_QWORD *)&v10[0])
  {
    if ((BYTE8(v10[0]) & 1) != 0)
      (*(void (**)(__n128))(**(_QWORD **)&v10[0] + 40))(v7);
    v7 = 0uLL;
    memset(v10, 0, sizeof(v10));
  }
  if (*(_QWORD *)&v9[0])
  {
    if ((BYTE8(v9[0]) & 1) != 0)
      (*(void (**)(__n128))(**(_QWORD **)&v9[0] + 40))(v7);
    v7 = 0uLL;
    memset(v9, 0, sizeof(v9));
  }
  result = v23;
  if (v23)
  {
    if ((v24 & 1) != 0)
      return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t, __n128))(*v23 + 40))(v23, v25, v7);
  }
  return result;
}

const char *re::FileAssetProvider::schemeName(re::FileAssetProvider *this)
{
  return "FileAsset";
}

uint64_t *re::allocInfo_NetworkAssetService(re *this)
{
  unsigned __int8 v1;

  v1 = atomic_load((unsigned __int8 *)&_MergedGlobals_45);
  if ((v1 & 1) == 0 && __cxa_guard_acquire(&_MergedGlobals_45))
  {
    ArcSharedObject::ArcSharedObject((ArcSharedObject *)&qword_2540FB9A8, 0);
    *(uint64_t *)((char *)&qword_2540FB9B8 + 6) = 0;
    qword_2540FB9B8 = 0;
    qword_2540FB9C8 = 0;
    qword_2540FB9D0 = 0xFFFFFFFFLL;
    qword_2540FB9A8 = (uint64_t)&off_24ED7DAA8;
    qword_2540FB9D8 = (uint64_t)"NetworkAssetService";
    dword_2540FB9E0 = 0;
    unk_2540FB9E8 = 0u;
    unk_2540FB9F8 = 0u;
    unk_2540FBA08 = 0u;
    qword_2540FBA18 = 0;
    __cxa_guard_release(&_MergedGlobals_45);
  }
  return &qword_2540FB9A8;
}

void re::initInfo_NetworkAssetService(re *this, re::IntrospectionBase *a2)
{
  const re::IntrospectionBase *v3;
  __int128 v4;
  _QWORD v5[2];
  __int128 v6;

  v5[0] = 0x999814F5B285CDA6;
  v5[1] = "NetworkAssetService";
  re::StringID::destroyString((re::StringID *)v5);
  *((_OWORD *)this + 2) = v6;
  *((_QWORD *)this + 2) = 0x800000008;
  *((_DWORD *)this + 6) = 8;
  *((_WORD *)this + 14) = 0;
  *((_DWORD *)this + 14) = 0;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 8) = &re::initInfo_NetworkAssetService(re::IntrospectionBase *)::structureAttributes;
  re::IntrospectionRegistry::add(this, v3);
  v4 = v6;
}

uint64_t re::introspect_NetworkAssetService(re::IntrospectionBase **this)
{
  return re::internal::getOrCreateInfo((re::internal *)"NetworkAssetService", (uint64_t (*)(re::internal *))re::allocInfo_NetworkAssetService, (re::IntrospectionBase *(*)(void))re::initInfo_NetworkAssetService, (void (*)(re::IntrospectionBase *))&re::internal::introspectionInfoStorage<re::NetworkAssetService>, this);
}

uint64_t reality_v1_entry_load_data_begin(uint64_t a1)
{
  uint64_t v2;
  const char *v3;
  uint64_t data_begin;
  int *v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  _QWORD v11[2];
  const char *v12;
  size_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v2 = operator new();
  *(_DWORD *)v2 = 0;
  *(_QWORD *)(v2 + 8) = 0;
  *(_QWORD *)(v2 + 16) = 0;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_QWORD *)(v2 + 64) = 0;
  v3 = (const char *)(a1 + 8);
  if (*(char *)(a1 + 31) < 0)
    v3 = *(const char **)v3;
  v12 = v3;
  v13 = strlen(v3);
  v11[0] = ".arz";
  v11[1] = 4;
  if (ends_with(&v12, v11, 0))
  {
    data_begin = zip_entry_load_data_begin(a1);
    if (data_begin)
    {
      v5 = (int *)data_begin;
      LODWORD(v13) = 0;
      v12 = 0;
      v6 = zip_entry_load_data_read((uint64_t)&v12, 0xCuLL, data_begin);
      zip_entry_load_data_end(v5);
      if (v6)
      {
        v7 = guess_compression_from_magic_number((unsigned __int8 *)&v12);
        if (v7)
        {
          v8 = v7;
          *(_QWORD *)(v2 + 48) = 0x10000;
          *(_QWORD *)(v2 + 40) = malloc_type_malloc(0x10000uLL, 0xC0AA2B9AuLL);
          *(_QWORD *)(v2 + 16) = *(_QWORD *)(a1 + 40);
          *(_QWORD *)(v2 + 32) = reality_compression_stream_begin(v8, 1);
        }
      }
    }
  }
  v9 = zip_entry_load_data_begin(a1);
  *(_QWORD *)(v2 + 24) = v9;
  if (!v9)
  {
    MEMORY[0x2276933B8](v2, 0x10E0C40EA9D672BLL);
    return 0;
  }
  return v2;
}

unint64_t reality_v1_entry_load_data_read(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _BOOL4 v11;
  int v12;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;

  if (!*(_QWORD *)(a3 + 32))
    return zip_entry_load_data_read(a1, a2, *(_QWORD *)(a3 + 24));
  v6 = 0;
  if (a2)
  {
    v7 = *(_QWORD *)(a3 + 64);
    while (1)
    {
      if (v7)
      {
        v8 = *(_QWORD *)(a3 + 8);
      }
      else
      {
        v9 = *(_QWORD *)(a3 + 40);
        v10 = *(_QWORD *)(a3 + 48);
        *(_QWORD *)(a3 + 56) = v9;
        v7 = zip_entry_load_data_read(v9, v10, *(_QWORD *)(a3 + 24));
        *(_QWORD *)(a3 + 64) = v7;
        v8 = *(_QWORD *)(a3 + 8) + v7;
        *(_QWORD *)(a3 + 8) = v8;
      }
      v11 = v8 == *(_QWORD *)(a3 + 16);
      v17 = *(_QWORD *)(a3 + 56);
      v18 = v7;
      v19 = v6 + a1;
      v20 = a2 - v6;
      v16 = 0;
      v14 = 0u;
      v15 = 0u;
      reality_compression_process_stream_chunk(v11, (uint64_t)&v17, *(_QWORD *)(a3 + 32), (uint64_t)&v14);
      v12 = v14;
      if (!(_DWORD)v14)
        break;
      v7 = v18;
      *(_QWORD *)(a3 + 56) = v17;
      *(_QWORD *)(a3 + 64) = v7;
      v6 += v15;
      if (v12 == 1 || v6 >= a2)
        return v6;
    }
    v6 = 0;
    *(_DWORD *)a3 = 1;
  }
  return v6;
}

void reality_v1_entry_load_data_end(uint64_t a1)
{
  compression_stream **v2;

  zip_entry_load_data_end(*(int **)(a1 + 24));
  v2 = *(compression_stream ***)(a1 + 32);
  if (v2)
    reality_compression_stream_end(v2);
  JUMPOUT(0x2276933B8);
}

_QWORD *re::internal::AssetDependencyWalker::findAssetHandles(_QWORD *a1, const re::IntrospectionBase **a2, uint64_t a3)
{
  _QWORD *result;
  uint64_t v4;
  _QWORD v5[3];
  _QWORD *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v5[0] = &off_24ED2CFC8;
  v5[1] = a3;
  v6 = v5;
  re::IntrospectionWalker::walk(a1, a2, (uint64_t)v5);
  result = v6;
  if (v6 == v5)
  {
    v4 = 4;
    result = v5;
  }
  else
  {
    if (!v6)
      return result;
    v4 = 5;
  }
  return (_QWORD *)(*(uint64_t (**)(void))(*result + 8 * v4))();
}

void std::__function::__func<re::internal::AssetDependencyWalker::findAssetHandles(re::IntrospectionBase const&,void const*,std::function<void ()(re::AssetHandle *)>)::$_0,std::allocator<re::internal::AssetDependencyWalker::findAssetHandles(re::IntrospectionBase const&,void const*,std::function<void ()(re::AssetHandle *)>)::$_0>,void ()(re::IntrospectionBase const&,void const*)>::~__func()
{
  JUMPOUT(0x2276933B8);
}

_QWORD *std::__function::__func<re::internal::AssetDependencyWalker::findAssetHandles(re::IntrospectionBase const&,void const*,std::function<void ()(re::AssetHandle *)>)::$_0,std::allocator<re::internal::AssetDependencyWalker::findAssetHandles(re::IntrospectionBase const&,void const*,std::function<void ()(re::AssetHandle *)>)::$_0>,void ()(re::IntrospectionBase const&,void const*)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;

  result = operator new(0x10uLL);
  v3 = *(_QWORD *)(a1 + 8);
  *result = &off_24ED2CFC8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<re::internal::AssetDependencyWalker::findAssetHandles(re::IntrospectionBase const&,void const*,std::function<void ()(re::AssetHandle *)>)::$_0,std::allocator<re::internal::AssetDependencyWalker::findAssetHandles(re::IntrospectionBase const&,void const*,std::function<void ()(re::AssetHandle *)>)::$_0>,void ()(re::IntrospectionBase const&,void const*)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(result + 8);
  *a2 = &off_24ED2CFC8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<re::internal::AssetDependencyWalker::findAssetHandles(re::IntrospectionBase const&,void const*,std::function<void ()(re::AssetHandle *)>)::$_0,std::allocator<re::internal::AssetDependencyWalker::findAssetHandles(re::IntrospectionBase const&,void const*,std::function<void ()(re::AssetHandle *)>)::$_0>,void ()(re::IntrospectionBase const&,void const*)>::operator()(uint64_t result, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (*(_DWORD *)(a2 + 16) == 11
    && *(uint64_t (**)(_QWORD *, uint64_t, re::DynamicString *, re::AssetSerializationScheme *))(a2 + 72) == re::AssetHandle::introspectionSerialize)
  {
    v3 = *(_QWORD *)(result + 8);
    v6 = *a3;
    v4 = *(_QWORD *)(v3 + 24);
    if (v4)
    {
      return (*(uint64_t (**)(uint64_t, uint64_t *))(*(_QWORD *)v4 + 48))(v4, &v6);
    }
    else
    {
      v5 = std::__throw_bad_function_call[abi:nn180100]();
      return std::__function::__func<re::internal::AssetDependencyWalker::findAssetHandles(re::IntrospectionBase const&,void const*,std::function<void ()(re::AssetHandle *)>)::$_0,std::allocator<re::internal::AssetDependencyWalker::findAssetHandles(re::IntrospectionBase const&,void const*,std::function<void ()(re::AssetHandle *)>)::$_0>,void ()(re::IntrospectionBase const&,void const*)>::target(v5);
    }
  }
  return result;
}

uint64_t std::__function::__func<re::internal::AssetDependencyWalker::findAssetHandles(re::IntrospectionBase const&,void const*,std::function<void ()(re::AssetHandle *)>)::$_0,std::allocator<re::internal::AssetDependencyWalker::findAssetHandles(re::IntrospectionBase const&,void const*,std::function<void ()(re::AssetHandle *)>)::$_0>,void ()(re::IntrospectionBase const&,void const*)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<re::internal::AssetDependencyWalker::findAssetHandles(re::IntrospectionBase const&,void const*,std::function<void ()(re::AssetHandle *)>)::$_0,std::allocator<re::internal::AssetDependencyWalker::findAssetHandles(re::IntrospectionBase const&,void const*,std::function<void ()(re::AssetHandle *)>)::$_0>,void ()(re::IntrospectionBase const&,void const*)>::target_type()
{
}

uint64_t reality_archive_file_upgrade(const char *a1, const char *a2, int a3)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  std::string::size_type size;
  char v20;
  std::string *v21;
  std::string *v22;
  std::string *v23;
  std::string *v24;
  uint64_t v25;
  int v26;
  int v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t v30;
  int v31;
  int v32;
  _QWORD *v33;
  std::string *v34;
  BOOL v35;
  BOOL v36;
  __int16 v37;
  unsigned int v38;
  __int16 v39;
  unint64_t entry;
  _WORD *v41;
  uint64_t data_begin;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  _QWORD *v47;
  const char *v48;
  std::string v50;
  _QWORD *v51;

  v5 = zip_file_open(a1);
  v6 = (_QWORD *)v5;
  if (!v5)
    return (uint64_t)v6;
  *(_QWORD *)(v5 + 104) = 4096;
  zip_file_create(a2);
  v51 = v7;
  if (!v7)
    goto LABEL_95;
  v8 = v7;
  v7[13] = 4096;
  v9 = v6[23];
  v10 = malloc_type_malloc(0x10000uLL, 0xC2A086EBuLL);
  if (!v9)
  {
    v47 = v8;
    v48 = a2;
LABEL_88:
    zip_save_manifest((uint64_t)v47, v48, &v51, 1uLL);
    if (!zip_close(v6))
    {
      v6 = 0;
      goto LABEL_92;
    }
    if (v8)
    {
      v6 = (_QWORD *)zip_close(v8);
      free(v10);
    }
    else
    {
      free(v10);
      return 1;
    }
    return (uint64_t)v6;
  }
  v11 = 0;
  if (a3)
    v12 = 1;
  else
    v12 = 2;
  while (1)
  {
    v13 = v6[22] + v11;
    v14 = *(_QWORD *)(v6[19] + 8 * (v13 / 0x27));
    v15 = v13 % 0x27;
    v16 = v14 + 104 * v15;
    v17 = (char *)(v16 + 8);
    if (*(char *)(v16 + 31) < 0)
      break;
    if (!*(_BYTE *)(v16 + 31) || v17[*(unsigned __int8 *)(v16 + 31) - 1] != 47)
      goto LABEL_15;
LABEL_13:
    zip_clone_entry((uint64_t)v51, (_QWORD **)v16);
    if (++v11 == v9)
    {
      v8 = v51;
      v47 = v51;
      v48 = a2;
      goto LABEL_88;
    }
  }
  v18 = *(_QWORD *)(v14 + 104 * v15 + 16);
  if (v18 && *(_BYTE *)(*(_QWORD *)v17 + v18 - 1) == 47)
    goto LABEL_13;
  v17 = *(char **)v17;
LABEL_15:
  std::string::basic_string[abi:nn180100]<0>(&v50, v17);
  size = HIBYTE(v50.__r_.__value_.__r.__words[2]);
  v20 = HIBYTE(v50.__r_.__value_.__r.__words[2]);
  v21 = (std::string *)v50.__r_.__value_.__r.__words[0];
  if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = v50.__r_.__value_.__l.__size_;
  else
    v21 = &v50;
  if (size)
  {
    v22 = (std::string *)((char *)v21 + size);
    v23 = v21;
    v24 = v22;
    do
    {
      if (v23->__r_.__value_.__s.__data_[0] == 46)
      {
        v25 = 1u;
        while (v25 != 4)
        {
          if ((std::string *)((char *)v23 + v25) == v22)
            goto LABEL_29;
          v26 = v23->__r_.__value_.__s.__data_[v25];
          v27 = aArz[v25++];
          if (v26 != v27)
            goto LABEL_21;
        }
        v24 = v23;
      }
LABEL_21:
      v23 = (std::string *)((char *)v23 + 1);
    }
    while (v23 != v22);
LABEL_29:
    if (v24 != v22 && (char *)v24 - (char *)v21 != -1)
    {
      std::string::erase(&v50, (char *)v24 - (char *)v21, 0xFFFFFFFFFFFFFFFFLL);
      v20 = HIBYTE(v50.__r_.__value_.__r.__words[2]);
    }
  }
  if (v20 < 0)
  {
    if (v50.__r_.__value_.__l.__size_ == 11)
    {
      v34 = (std::string *)v50.__r_.__value_.__r.__words[0];
      v36 = *(_QWORD *)v50.__r_.__value_.__l.__data_ == 0x6A2E726564616568
         && *(_QWORD *)(v50.__r_.__value_.__r.__words[0] + 3) == 0x6E6F736A2E726564;
      v33 = v51;
      if (v36)
        goto LABEL_63;
    }
    else
    {
      if (v50.__r_.__value_.__l.__size_ == 13)
      {
        v28 = (unint64_t *)v50.__r_.__value_.__r.__words[0];
        goto LABEL_39;
      }
      v33 = v51;
    }
    v32 = v12;
    goto LABEL_66;
  }
  if (v20 == 11)
  {
    v35 = v50.__r_.__value_.__r.__words[0] == 0x6A2E726564616568
       && *(std::string::size_type *)((char *)v50.__r_.__value_.__r.__words + 3) == 0x6E6F736A2E726564;
    v34 = &v50;
    v33 = v51;
    if (!v35)
      goto LABEL_57;
LABEL_63:
    v37 = 0;
    goto LABEL_73;
  }
  if (v20 != 13)
  {
    v34 = &v50;
    v33 = v51;
LABEL_57:
    v32 = v12;
    goto LABEL_67;
  }
  v28 = (unint64_t *)&v50;
LABEL_39:
  v29 = bswap64(*v28);
  v30 = 0x61737365744D6170;
  if (v29 == 0x61737365744D6170
    && (v29 = bswap64(*(unint64_t *)((char *)v28 + 5)), v30 = 0x4D61702E6A736F6ELL, v29 == 0x4D61702E6A736F6ELL))
  {
    v31 = 0;
  }
  else if (v29 < v30)
  {
    v31 = -1;
  }
  else
  {
    v31 = 1;
  }
  if (v31)
    v32 = v12;
  else
    v32 = 0;
  v33 = v51;
  if ((v20 & 0x80) == 0)
  {
    v34 = &v50;
    goto LABEL_67;
  }
LABEL_66:
  v34 = (std::string *)v50.__r_.__value_.__r.__words[0];
LABEL_67:
  v38 = v32 - 2;
  if (v32 == 1)
    v39 = 8;
  else
    v39 = 0;
  if (v38 >= 2)
    v37 = v39;
  else
    v37 = 99;
LABEL_73:
  entry = zip_create_entry(v33, (uint64_t)v34, v37);
  if (entry)
  {
    v41 = (_WORD *)entry;
    data_begin = reality_v1_entry_load_data_begin(v16);
    if (data_begin)
    {
      v43 = data_begin;
      v44 = zip_entry_save_data_begin(v41);
      if (v44)
      {
        v45 = v44;
        do
        {
          v46 = reality_v1_entry_load_data_read((uint64_t)v10, 0x10000uLL, v43);
          if (!v46)
            reality_v1_entry_load_data_end(v43);
        }
        while (zip_entry_save_data_write((Bytef *)v10, v46, v45) == v46);
        zip_entry_save_data_end(v45);
      }
      reality_v1_entry_load_data_end(v43);
    }
  }
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v50.__r_.__value_.__l.__data_);
  v8 = v51;
LABEL_92:
  free(v10);
  if (v8)
    zip_close(v8);
  if (v6)
  {
LABEL_95:
    zip_close(v6);
    return 0;
  }
  return (uint64_t)v6;
}

uint64_t re::internal::PushLoadManager::pushLoadAsset(uint64_t a1, unint64_t a2, char *a3, unint64_t a4, unint64_t a5, unsigned int a6, int a7)
{
  _QWORD *v14;
  uint64_t v15;
  uint64_t result;
  _anonymous_namespace_ *v17;
  const char **v18;
  _anonymous_namespace_ *v19;
  _anonymous_namespace_ *v20;
  const char *v21;
  os_unfair_lock_s *v22;
  re::internal::AssetEntry *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30[3];
  uint64_t v31;
  re::internal::AssetEntry *v32;
  _OWORD v33[2];
  unint64_t v34;
  _BYTE buf[24];
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  __int128 v41;
  __int128 v42;
  int v43;
  _QWORD v44[9];

  v44[6] = *MEMORY[0x24BDAC8D0];
  v34 = a2;
  v14 = (_QWORD *)(a1 + 24);
  v15 = re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet(a1 + 24, a2);
  if (v15)
  {
    result = *(_QWORD *)(v15 + 8);
    if (result)
      return re::internal::AssetEntry::fromPeerID(result, (uint64_t)buf);
    return result;
  }
  v17 = (_anonymous_namespace_ *)re::internal::AssetTypeRegistry::assetTypeWithName(*(re::internal::AssetTypeRegistry **)(*(_QWORD *)(a1 + 72) + 1104), a3);
  if (v17)
  {
    v18 = (const char **)v17;
    *(_QWORD *)&buf[8] = 0;
    *(_QWORD *)&buf[16] = 0;
    v36 = 0;
    v19 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(buf, 0);
    v37 = 0;
    v38 = 0;
    v40 = 0;
    v39 = 0;
    v41 = 0u;
    v42 = 0u;
    v43 = 0;
    memset(v44, 0, 40);
    v20 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v44[1], 0);
    v21 = *v18;
    re::NetworkAssetLoadDescriptor::init((uint64_t)buf, (const re::IntrospectionBase *)a2, (re::DynamicString *)v33);
    if (*(_QWORD *)&v33[0])
    {
      if ((BYTE8(v33[0]) & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&v33[0] + 40))();
      memset(v33, 0, sizeof(v33));
    }
    v22 = *(os_unfair_lock_s **)(a1 + 72);
    os_unfair_lock_lock(v22 + 16);
    re::AssetManager::assetHandle_assetTablesLocked((re::AssetManager *)v22, (const re::AssetLoadDescriptor *)buf, a2, &v31);
    os_unfair_lock_unlock(v22 + 16);
    re::internal::AssetEntry::setOwnerPeerID(v32, a4);
    re::internal::AssetEntry::setFromPeerID(v32, a5);
    v23 = v32;
    atomic_store(a6, (unsigned int *)v32 + 172);
    if (a7)
      *((_BYTE *)v23 + 259) = 1;
    memset(v30, 0, sizeof(v30));
    re::AssetHandle::operator=(v30, &v31);
    v24 = 0x94D049BB133111EBLL
        * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    v25 = v24 ^ (v24 >> 31);
    if (*v14)
    {
      v26 = v25 % *(unsigned int *)(a1 + 48);
      v27 = *(unsigned int *)(*(_QWORD *)(a1 + 32) + 4 * v26);
      if ((_DWORD)v27 != 0x7FFFFFFF)
      {
        v28 = *(_QWORD *)(a1 + 40);
        if (*(_QWORD *)(v28 + 48 * v27 + 16) == a2)
        {
LABEL_24:
          re::AssetHandle::loadAsync((re::AssetHandle *)&v31);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)v30);
          re::AssetHandle::~AssetHandle((re::AssetHandle *)&v31);
          if (v44[1])
          {
            if ((v44[2] & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v44[1] + 40))();
            memset(&v44[1], 0, 32);
          }
          if (*((_QWORD *)&v41 + 1))
          {
            if (v44[0])
              (*(void (**)(void))(**((_QWORD **)&v41 + 1) + 40))();
            v44[0] = 0;
            v42 = 0uLL;
            *((_QWORD *)&v41 + 1) = 0;
            ++v43;
          }
          if (v37)
          {
            if ((_QWORD)v41)
              (*(void (**)(void))(*(_QWORD *)v37 + 40))();
            *(_QWORD *)&v41 = 0;
            v38 = 0;
            v39 = 0;
            v37 = 0;
            ++v40;
          }
          result = *(_QWORD *)buf;
          if (*(_QWORD *)buf && (buf[8] & 1) != 0)
            return (*(uint64_t (**)(void))(**(_QWORD **)buf + 40))();
          return result;
        }
        while (1)
        {
          LODWORD(v27) = *(_DWORD *)(v28 + 48 * v27 + 8) & 0x7FFFFFFF;
          if ((_DWORD)v27 == 0x7FFFFFFF)
            break;
          if (*(_QWORD *)(v28 + 48 * v27 + 16) == a2)
            goto LABEL_24;
        }
      }
    }
    else
    {
      LODWORD(v26) = 0;
    }
    re::HashTable<unsigned long long,re::internal::PushLoadManager::PushLoadedAsset,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove((uint64_t)v14, v26, v25, &v34, v30);
    ++*(_DWORD *)(a1 + 64);
    goto LABEL_24;
  }
  v29 = *re::assetsLogObjects(0);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = a3;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = a2;
    _os_log_error_impl(&dword_224FE9000, v29, OS_LOG_TYPE_ERROR, "Could not find asset type named '%s' in the type registry. Aborting push-load for asset %llu.", buf, 0x16u);
  }
  result = *(_QWORD *)(a1 + 80);
  if (result)
    return (*(uint64_t (**)(uint64_t, unint64_t, unint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)result + 112))(result, a2, a5, 3, 0, 200);
  return result;
}

void re::internal::PushLoadManager::releaseAsset(re::internal::PushLoadManager *this, unint64_t a2)
{
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = (char *)this + 24;
  v4 = re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)this + 24, a2);
  if (v4)
  {
    v5 = *(_QWORD *)(v4 + 8);
    if (v5)
      re::internal::AssetEntry::fromPeerID(v5, (uint64_t)&v6);
    re::HashTable<unsigned long long,re::internal::PushLoadManager::PushLoadedAsset,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)v3, a2);
  }
}

void re::HashTable<unsigned long long,re::internal::PushLoadManager::PushLoadedAsset,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int *v13;
  int v14;
  int v15;

  if (*(_QWORD *)a1)
  {
    v3 = 0x94D049BB133111EBLL
       * ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) ^ ((0xBF58476D1CE4E5B9 * (a2 ^ (a2 >> 30))) >> 27));
    v4 = (v3 ^ (v3 >> 31)) % *(unsigned int *)(a1 + 24);
    v5 = *(_QWORD *)(a1 + 8);
    v6 = *(unsigned int *)(v5 + 4 * v4);
    if ((_DWORD)v6 != 0x7FFFFFFF)
    {
      v7 = *(_QWORD *)(a1 + 16);
      if (*(_QWORD *)(v7 + 48 * v6 + 16) == a2)
      {
        *(_DWORD *)(v5 + 4 * v4) = *(_DWORD *)(v7 + 48 * v6 + 8) & 0x7FFFFFFF;
LABEL_8:
        v10 = *(_QWORD *)(a1 + 16);
        v11 = v10 + 48 * v6;
        v14 = *(_DWORD *)(v11 + 8);
        v13 = (int *)(v11 + 8);
        v12 = v14;
        if (v14 < 0)
        {
          *v13 = v12 & 0x7FFFFFFF;
          re::AssetHandle::~AssetHandle((re::AssetHandle *)(v10 + 48 * v6 + 24));
          v10 = *(_QWORD *)(a1 + 16);
          v12 = *(_DWORD *)(v10 + 48 * v6 + 8);
        }
        v15 = *(_DWORD *)(a1 + 40);
        *(_DWORD *)(v10 + 48 * v6 + 8) = *(_DWORD *)(a1 + 36) | v12 & 0x80000000;
        --*(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 36) = v6;
        *(_DWORD *)(a1 + 40) = v15 + 1;
      }
      else
      {
        while (1)
        {
          v8 = v6;
          v9 = *(_DWORD *)(v7 + 48 * v6 + 8);
          v6 = v9 & 0x7FFFFFFF;
          if ((v9 & 0x7FFFFFFF) == 0x7FFFFFFF)
            break;
          if (*(_QWORD *)(v7 + 48 * v6 + 16) == a2)
          {
            *(_DWORD *)(v7 + 48 * v8 + 8) = *(_DWORD *)(v7 + 48 * v8 + 8) & 0x80000000 | *(_DWORD *)(v7 + 48 * v6 + 8) & 0x7FFFFFFF;
            goto LABEL_8;
          }
        }
      }
    }
  }
}

uint64_t re::internal::PushLoadManager::onPeerDisconnected(re::internal::PushLoadManager *this, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  int *v6;
  int v7;
  char *v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  unsigned int v14;
  unsigned int v15;
  unint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t result;
  char v20[8];
  uint64_t v21;
  _QWORD v22[2];
  uint64_t v23;
  int v24;
  unint64_t *v25;

  v25 = 0;
  v22[1] = 0;
  v23 = 0;
  v22[0] = 0;
  v24 = 0;
  v4 = *((unsigned int *)this + 14);
  if ((_DWORD)v4)
  {
    v5 = 0;
    v6 = (int *)(*((_QWORD *)this + 5) + 8);
    while (1)
    {
      v7 = *v6;
      v6 += 12;
      if (v7 < 0)
        break;
      if (v4 == ++v5)
      {
        LODWORD(v5) = *((_DWORD *)this + 14);
        break;
      }
    }
  }
  else
  {
    LODWORD(v5) = 0;
  }
  if ((_DWORD)v4 != (_DWORD)v5)
  {
    v8 = (char *)this + 24;
    v9 = v5;
    v10 = *((_DWORD *)this + 14);
    do
    {
      v11 = *((_QWORD *)this + 5) + 48 * v9;
      v12 = *(_QWORD *)(v11 + 32);
      if (v12)
      {
        re::internal::AssetEntry::fromPeerID(v12, (uint64_t)v20);
        if (v20[0])
          v13 = v21 == a2;
        else
          v13 = 0;
        if (v13)
          re::DynamicArray<re::TransitionCondition *>::add(v22, (_QWORD *)(v11 + 16));
        v10 = *((_DWORD *)this + 14);
      }
      if (v10 <= (int)v5 + 1)
        v14 = v5 + 1;
      else
        v14 = v10;
      while (1)
      {
        v9 = (v5 + 1);
        if (v14 - 1 == (_DWORD)v5)
          break;
        LODWORD(v5) = v5 + 1;
        v15 = v9;
        if ((*(_DWORD *)(*((_QWORD *)this + 5) + 48 * v9 + 8) & 0x80000000) != 0)
          goto LABEL_24;
      }
      v15 = v14;
LABEL_24:
      LODWORD(v5) = v15;
    }
    while ((_DWORD)v4 != v15);
    if (v23)
    {
      v16 = v25;
      v17 = 8 * v23;
      do
      {
        v18 = *v16++;
        re::HashTable<unsigned long long,re::internal::PushLoadManager::PushLoadedAsset,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::remove((uint64_t)v8, v18);
        v17 -= 8;
      }
      while (v17);
    }
  }
  result = v22[0];
  if (v22[0])
  {
    if (v25)
      return (*(uint64_t (**)(void))(*(_QWORD *)v22[0] + 40))();
  }
  return result;
}

void re::internal::PushLoadManager::~PushLoadManager(re::internal::PushLoadManager *this)
{
  *(_QWORD *)this = &off_24ED2D058;
  re::HashTable<unsigned long long,re::internal::PushLoadManager::PushLoadedAsset,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 3);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
}

{
  *(_QWORD *)this = &off_24ED2D058;
  re::HashTable<unsigned long long,re::internal::PushLoadManager::PushLoadedAsset,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)this + 3);
  *(_QWORD *)this = &off_24ED426B8;
  objc_destructInstance((char *)this + 8);
  JUMPOUT(0x2276933B8);
}

double re::HashTable<unsigned long long,re::internal::PushLoadManager::PushLoadedAsset,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit(uint64_t *a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t i;
  uint64_t v6;
  int v7;
  double result;

  v2 = *a1;
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 8);
    if ((_DWORD)v3)
    {
      v4 = 0;
      for (i = 0; i < v3; ++i)
      {
        v6 = a1[2] + v4;
        v7 = *(_DWORD *)(v6 + 8);
        if (v7 < 0)
        {
          *(_DWORD *)(v6 + 8) = v7 & 0x7FFFFFFF;
          re::AssetHandle::~AssetHandle((re::AssetHandle *)(v6 + 24));
          v3 = *((unsigned int *)a1 + 8);
        }
        v4 += 48;
      }
      v2 = *a1;
    }
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v2 + 40))(v2, a1[1]);
    *((_DWORD *)a1 + 8) = 0;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    *(_QWORD *)&result = 0x7FFFFFFFLL;
    *(uint64_t *)((char *)a1 + 36) = 0x7FFFFFFFLL;
  }
  return result;
}

void re::HashTable<unsigned long long,re::internal::PushLoadManager::PushLoadedAsset,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(uint64_t a1, unsigned int a2, unint64_t a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v9;
  int v10;
  int v11;
  signed int v12;
  uint64_t v13;
  BOOL v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  signed int v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  _BYTE v28[44];

  v9 = *(unsigned int *)(a1 + 36);
  if ((_DWORD)v9 == 0x7FFFFFFF)
  {
    v9 = *(unsigned int *)(a1 + 32);
    v10 = v9;
    if ((_DWORD)v9 == *(_DWORD *)(a1 + 24))
    {
      v11 = *(_DWORD *)(a1 + 28);
      v12 = 2 * v11;
      v13 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
      {
        if (v12)
          v14 = (_DWORD)v9 == v12;
        else
          v14 = 1;
        if (!v14 && (v11 & 0x80000000) == 0)
        {
          memset(v28, 0, 36);
          *(_QWORD *)&v28[36] = 0x7FFFFFFFLL;
          re::HashTable<unsigned long long,re::ecs2::EntityHandle,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::init((uint64_t)v28, v13, v12);
          v15 = *(_OWORD *)v28;
          *(_OWORD *)v28 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          v16 = *(_QWORD *)&v28[16];
          v17 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)&v28[16] = v17;
          *(_QWORD *)(a1 + 16) = v16;
          v19 = *(_OWORD *)&v28[24];
          *(_OWORD *)&v28[24] = *(_OWORD *)(a1 + 24);
          v18 = *(_DWORD *)&v28[32];
          *(_OWORD *)(a1 + 24) = v19;
          v20 = v18;
          if (v18)
          {
            v21 = v17 + 16;
            do
            {
              if ((*(_DWORD *)(v21 - 8) & 0x80000000) != 0)
                re::HashTable<unsigned long long,re::internal::PushLoadManager::PushLoadedAsset,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::addAsMove(a1, *(_QWORD *)(v21 - 16) % (unint64_t)*(unsigned int *)(a1 + 24), *(_QWORD *)(v21 - 16), v21, v21 + 8);
              v21 += 48;
              --v20;
            }
            while (v20);
          }
          re::HashTable<unsigned long long,re::internal::PushLoadManager::PushLoadedAsset,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::deinit((uint64_t *)v28);
        }
      }
      else
      {
        if (v12)
          v24 = 2 * v11;
        else
          v24 = 3;
      }
      a2 = a3 % *(unsigned int *)(a1 + 24);
      v10 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 32) = v10 + 1;
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 48 * v9 + 8);
  }
  else
  {
    v22 = *(_QWORD *)(a1 + 16);
    v23 = *(_DWORD *)(v22 + 48 * v9 + 8);
    *(_DWORD *)(a1 + 36) = v23 & 0x7FFFFFFF;
  }
  *(_DWORD *)(v22 + 48 * v9 + 8) = v23 | 0x80000000;
  *(_DWORD *)(*(_QWORD *)(a1 + 16) + 48 * v9 + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 48 * v9 + 8) & 0x80000000 | *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * v9) = a3;
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * v9 + 16) = *a4;
  v25 = (_QWORD *)(*(_QWORD *)(a1 + 16) + 48 * v9);
  v25[3] = 0;
  v25[4] = 0;
  v25[5] = 0;
  v25[4] = a5[1];
  a5[1] = 0;
  v26 = v25[3];
  v25[3] = 0;
  v25[3] = *a5;
  *a5 = v26;
  v27 = v25[5];
  v25[5] = a5[2];
  a5[2] = v27;
  *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4 * a2) = v9;
  ++*(_DWORD *)(a1 + 28);
}

uint64_t re::AssetSerializationScheme::storedCodingKey(re::AssetSerializationScheme *this, re::DynamicString *a2, const re::AssetHandle *a3)
{
  unint64_t v5;
  uint64_t v6;
  uint64_t v8;
  unint64_t v9;
  _QWORD v10[2];

  re::AssetHandle::serializationString(a2, (re::DynamicString *)&v8);
  if ((v9 & 1) != 0)
    v5 = v9 >> 1;
  else
    v5 = v9 >> 1;
  if (v5)
  {
    re::DynamicString::operator=(this, (re::DynamicString *)&v8);
  }
  else
  {
    if (*((_QWORD *)a2 + 1))
    {
      v6 = 0;
      goto LABEL_9;
    }
    v10[0] = &str_36;
    v10[1] = 0;
    re::DynamicString::operator=(this, (uint64_t)v10);
  }
  v6 = 1;
LABEL_9:
  if (v8 && (v9 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v8 + 40))();
  return v6;
}

uint64_t re::AssetSerializationScheme::deviceCodingKey(re::DynamicString *a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t result;
  _BYTE v7[8];
  uint64_t v8;
  char v9;

  v4 = *(_QWORD *)(a4 + 8);
  if (!v4)
    return 0;
  result = *(_QWORD *)(v4 + 24);
  if (!result)
    return result;
  re::AssetManager::deviceAssetPath(result, a4, a2, a3, v7);
  if (!v7[0])
    return 0;
  re::DynamicString::operator=(a1, (re::DynamicString *)&v8);
  if (v7[0] && v8 && (v9 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v8 + 40))();
  return 1;
}

BOOL re::AssetSerializationScheme::relativeCodingKey(re::DynamicString *a1, re::AssetHandle *this, _BYTE *a3)
{
  int v3;
  re::AssetPath *v5;
  const re::AssetPath *v6;
  uint64_t v8;
  char v9;

  v3 = *a3;
  if (*a3)
  {
    v5 = (re::AssetPath *)(a3 + 8);
    v6 = (const re::AssetPath *)re::AssetHandle::legacy_assetPath(this);
    re::AssetPath::makeRelativeAssetPath(v5, v6, (re::DynamicString *)&v8);
    re::DynamicString::operator=(a1, (re::DynamicString *)&v8);
    if (v8)
    {
      if ((v9 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v8 + 40))();
    }
  }
  return v3 != 0;
}

uint64_t re::AssetSerializationScheme::commonCodingKey(re::AssetSerializationScheme *a1, re::DynamicString *a2, const re::AssetHandle *a3, unsigned __int8 *a4)
{
  unsigned __int8 v8[88];

  re::Optional<re::AssetPath>::Optional((uint64_t)v8, a4);
  re::AssetSerializationScheme::commonCodingKeyInternal(a1, a2, a3, v8);
  re::Optional<re::AssetPath>::~Optional((uint64_t)v8);
  return 1;
}

uint64_t re::AssetSerializationScheme::commonCodingKeyInternal(re::AssetSerializationScheme *a1, re::DynamicString *a2, const re::AssetHandle *a3, unsigned __int8 *a4)
{
  BOOL v9;
  char *v10;
  const char *v11;
  size_t v12;
  _BYTE v13[88];
  _QWORD v14[2];

  if ((re::AssetSerializationScheme::storedCodingKey(a1, a2, a3) & 1) != 0)
    return 1;
  if ((re::AssetSerializationScheme::deviceCodingKey(a1, 0, (uint64_t)a3, (uint64_t)a2) & 1) != 0)
    return 2;
  re::Optional<re::AssetPath>::Optional((uint64_t)v13, a4);
  v9 = re::AssetSerializationScheme::relativeCodingKey(a1, a2, v13);
  re::Optional<re::AssetPath>::~Optional((uint64_t)v13);
  if (v9)
    return 3;
  v10 = (char *)re::AssetHandle::assetInfo(a2);
  if ((*((_QWORD *)v10 + 13) & 1) != 0)
    v11 = (const char *)*((_QWORD *)v10 + 14);
  else
    v11 = v10 + 105;
  v12 = strlen(v11);
  v14[0] = v11;
  v14[1] = v12;
  re::DynamicString::operator=(a1, (uint64_t)v14);
  return 4;
}

uint64_t re::AssetSerializationScheme::relativeHandle(uint64_t *a1, re::AssetManager *this, char *a3, _BYTE *a4)
{
  if (*a4)
    return re::AssetManager::assetHandleWithParentAssetPath(this, a3, (const re::AssetPath *)(a4 + 8), 1, a1);
  else
    return re::AssetManager::assetHandle(this, a3, 1, 1, a1);
}

uint64_t re::ZeroAssetSerialization::fromHandle(uint64_t a1)
{
  ++*(_DWORD *)(a1 + 12);
  return 0;
}

uint64_t re::ZeroAssetSerialization::toHandle(uint64_t a1)
{
  ++*(_DWORD *)(a1 + 12);
  return 0;
}

re::DefaultAssetSerialize *re::DefaultAssetSerialize::DefaultAssetSerialize(re::DefaultAssetSerialize *this, const re::AssetHandle *a2)
{
  char *v3;
  re::DynamicString *v4;
  unsigned __int8 v6[88];

  *(_QWORD *)this = &off_24ED2D3D0;
  *((_BYTE *)this + 8) = 0;
  v3 = (char *)this + 8;
  if (a2)
    v4 = (re::DynamicString *)re::AssetHandle::legacy_assetPath(a2);
  else
    v4 = 0;
  optionalFromPointer<re::AssetPath>(v4, (uint64_t)v6);
  re::Optional<re::AssetPath>::operator=((uint64_t)v3, v6);
  re::Optional<re::AssetPath>::~Optional((uint64_t)v6);
  return this;
}

re::DynamicString *optionalFromPointer<re::AssetPath>@<X0>(re::DynamicString *result@<X0>, uint64_t a2@<X8>)
{
  re::DynamicString *v3;

  if (result)
  {
    v3 = result;
    *(_BYTE *)a2 = 1;
    *(_DWORD *)(a2 + 8) = *(_DWORD *)result;
    re::DynamicString::DynamicString((re::DynamicString *)(a2 + 16), (re::DynamicString *)((char *)result + 8));
    result = re::DynamicString::DynamicString((re::DynamicString *)(a2 + 48), (re::DynamicString *)((char *)v3 + 40));
    *(_QWORD *)(a2 + 80) = *((_QWORD *)v3 + 9);
  }
  else
  {
    *(_BYTE *)a2 = 0;
  }
  return result;
}

uint64_t re::Optional<re::AssetPath>::operator=(uint64_t a1, unsigned __int8 *a2)
{
  int v3;
  BOOL v4;
  BOOL v5;
  BOOL v7;
  uint64_t v8;
  _OWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v3 = *a2;
  if (*(_BYTE *)a1)
    v4 = 0;
  else
    v4 = v3 == 0;
  if (!v4)
  {
    if (*(_BYTE *)a1)
      v5 = v3 == 0;
    else
      v5 = 0;
    if (v5)
    {
      v9 = (_OWORD *)(a1 + 48);
      v8 = *(_QWORD *)(a1 + 48);
      if (v8)
      {
        if ((*(_BYTE *)(a1 + 56) & 1) != 0)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v8 + 40))(v8, *(_QWORD *)(a1 + 64));
        *v9 = 0u;
        *(_OWORD *)(a1 + 64) = 0u;
      }
      v10 = *(_QWORD *)(a1 + 16);
      if (v10)
      {
        if ((*(_BYTE *)(a1 + 24) & 1) != 0)
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v10 + 40))(v10, *(_QWORD *)(a1 + 32));
        *(_OWORD *)(a1 + 16) = 0u;
        *(_OWORD *)(a1 + 32) = 0u;
      }
      *(_BYTE *)a1 = 0;
    }
    else
    {
      if (*(_BYTE *)a1)
        v7 = 1;
      else
        v7 = v3 == 0;
      if (v7)
      {
        *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
        re::DynamicString::operator=((re::DynamicString *)(a1 + 16), (re::DynamicString *)(a2 + 16));
        re::DynamicString::operator=((re::DynamicString *)(a1 + 48), (re::DynamicString *)(a2 + 48));
      }
      else
      {
        *(_BYTE *)a1 = 1;
        *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
        *(_OWORD *)(a1 + 16) = 0u;
        *(_OWORD *)(a1 + 32) = 0u;
        *(_QWORD *)(a1 + 40) = *((_QWORD *)a2 + 5);
        v11 = *((_QWORD *)a2 + 3);
        *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
        *((_QWORD *)a2 + 2) = 0;
        v12 = *((_QWORD *)a2 + 4);
        *((_QWORD *)a2 + 5) = 0;
        v14 = *(_QWORD *)(a1 + 24);
        v13 = *(_QWORD *)(a1 + 32);
        *(_QWORD *)(a1 + 24) = v11;
        *(_QWORD *)(a1 + 32) = v12;
        *((_QWORD *)a2 + 3) = v14;
        *((_QWORD *)a2 + 4) = v13;
        *(_OWORD *)(a1 + 48) = 0u;
        *(_OWORD *)(a1 + 64) = 0u;
        *(_QWORD *)(a1 + 72) = *((_QWORD *)a2 + 9);
        v15 = *((_QWORD *)a2 + 7);
        *(_QWORD *)(a1 + 48) = *((_QWORD *)a2 + 6);
        *((_QWORD *)a2 + 6) = 0;
        v16 = *((_QWORD *)a2 + 8);
        *((_QWORD *)a2 + 9) = 0;
        v18 = *(_QWORD *)(a1 + 56);
        v17 = *(_QWORD *)(a1 + 64);
        *(_QWORD *)(a1 + 56) = v15;
        *(_QWORD *)(a1 + 64) = v16;
        *((_QWORD *)a2 + 7) = v18;
        *((_QWORD *)a2 + 8) = v17;
      }
      *(_QWORD *)(a1 + 80) = *((_QWORD *)a2 + 10);
    }
  }
  return a1;
}

uint64_t re::DefaultAssetSerialize::fromHandle(re::DefaultAssetSerialize *this, re::DynamicString *a2, const re::AssetHandle *a3)
{
  unsigned __int8 v6[88];

  re::Optional<re::AssetPath>::Optional((uint64_t)v6, (unsigned __int8 *)this + 8);
  re::AssetSerializationScheme::commonCodingKey(a2, a3, (const re::AssetHandle *)0xC, v6);
  re::Optional<re::AssetPath>::~Optional((uint64_t)v6);
  return 1;
}

void re::DefaultAssetSerialize::toHandle(re::DefaultAssetSerialize *this, re::AssetHandle *a2, const char *a3, re::Allocator *a4)
{
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, a4, "assertion failure: '%s' (%s:line %i) Cannot deserialize using DefaultAssetSerialize class", "!\"Unreachable code\"", "toHandle", 151);
  _os_crash();
  __break(1u);
}

re::DirectAssetDeserialize *re::DirectAssetDeserialize::DirectAssetDeserialize(re::DirectAssetDeserialize *this, AssetService *a2, const re::AssetPath *a3)
{
  char *v4;
  unsigned __int8 v6[88];

  *(_QWORD *)this = &off_24ED2D0D0;
  *((_BYTE *)this + 8) = 0;
  v4 = (char *)this + 8;
  *((_QWORD *)this + 12) = a2;
  optionalFromPointer<re::AssetPath>(a3, (uint64_t)v6);
  re::Optional<re::AssetPath>::operator=((uint64_t)v4, v6);
  re::Optional<re::AssetPath>::~Optional((uint64_t)v6);
  return this;
}

BOOL re::DirectAssetDeserialize::toHandle(re::DirectAssetDeserialize *this, re::AssetHandle *a2, char *a3, re::Allocator *a4)
{
  re::AssetManager *v6;
  __int128 v7;
  uint64_t v8;
  _BYTE v10[88];
  __int128 v11;
  uint64_t v12;

  v6 = (re::AssetManager *)*((_QWORD *)this + 12);
  re::Optional<re::AssetPath>::Optional((uint64_t)v10, (unsigned __int8 *)this + 8);
  re::AssetSerializationScheme::relativeHandle((uint64_t *)&v11, v6, a3, v10);
  v7 = *(_OWORD *)a2;
  *(_OWORD *)a2 = v11;
  v11 = v7;
  v8 = *((_QWORD *)a2 + 2);
  *((_QWORD *)a2 + 2) = v12;
  v12 = v8;
  re::AssetHandle::~AssetHandle((re::AssetHandle *)&v11);
  re::Optional<re::AssetPath>::~Optional((uint64_t)v10);
  return *((_QWORD *)a2 + 1) != 0;
}

void re::DirectAssetDeserialize::fromHandle(re::DirectAssetDeserialize *this, re::DynamicString *a2, const re::AssetHandle *a3)
{
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) Cannot serialize using DirectAssetDeserialize class", "!\"Unreachable code\"", "fromHandle", 176);
  _os_crash();
  __break(1u);
}

void re::DeferredAssetDeserialize::fromHandle(re::DeferredAssetDeserialize *this, re::DynamicString *a2, const re::AssetHandle *a3)
{
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) Cannot serialize using DeferredAssetDeserialize class", "!\"Unreachable code\"", "fromHandle", 183);
  _os_crash();
  __break(1u);
}

uint64_t re::DeferredAssetDeserialize::toHandle(re::DeferredAssetDeserialize *this, re::AssetHandle *a2, re::AssetPath *a3, re::Allocator *a4)
{
  re::AssetHandle::setSerializationString(a2, a3, a4);
  return 1;
}

re::RemappedAssetSerialize *re::RemappedAssetSerialize::RemappedAssetSerialize(re::RemappedAssetSerialize *this, const re::AssetPath *a2, const re::AssetPathMapping *a3)
{
  char *v5;
  unsigned __int8 v7[88];

  *(_QWORD *)this = &off_24ED2D100;
  *((_BYTE *)this + 8) = 0;
  v5 = (char *)this + 8;
  optionalFromPointer<re::AssetPath>(a2, (uint64_t)v7);
  re::Optional<re::AssetPath>::operator=((uint64_t)v5, v7);
  re::Optional<re::AssetPath>::~Optional((uint64_t)v7);
  *((_QWORD *)this + 12) = a3;
  return this;
}

uint64_t re::RemappedAssetSerialize::fromHandle(re::RemappedAssetSerialize *this, re::DynamicString *a2, const re::AssetHandle *a3)
{
  re::AssetPathMapping *v6;
  unsigned __int8 v8[88];

  v6 = (re::AssetPathMapping *)*((_QWORD *)this + 12);
  if (!v6 || (re::AssetPathMapping::lookupString(v6, a2, a3) & 1) == 0)
  {
    re::Optional<re::AssetPath>::Optional((uint64_t)v8, (unsigned __int8 *)this + 8);
    re::AssetSerializationScheme::commonCodingKey(a2, a3, (const re::AssetHandle *)0xC, v8);
    re::Optional<re::AssetPath>::~Optional((uint64_t)v8);
  }
  return 1;
}

void re::RemappedAssetSerialize::toHandle(re::RemappedAssetSerialize *this, re::AssetHandle *a2, const char *a3, re::Allocator *a4)
{
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, a4, "assertion failure: '%s' (%s:line %i) Cannot deserialize using RemappedAssetSerialize class", "!\"Unreachable code\"", "toHandle", 211);
  _os_crash();
  __break(1u);
}

BOOL re::RealityFileAssetSerialize::fromHandle(re::RealityFileAssetSerialize *this, re::DynamicString *a2, const re::AssetHandle *a3)
{
  re::AssetPathMapping *v6;
  const char *v7;
  BOOL v8;
  uint64_t v9;
  const char *v10;
  BOOL v11;
  int v12;
  unsigned __int8 v13;
  const char *v14;
  size_t v15;
  re *v16;
  NSObject *v17;
  char *v19;
  unsigned __int8 v20[88];
  char v21[8];
  uint64_t v22;
  char v23;
  uint8_t buf[4];
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v6 = (re::AssetPathMapping *)*((_QWORD *)this + 12);
  if (v6 && re::AssetPathMapping::lookupString(v6, a2, a3))
  {
    if (re::AssetPath::pathIsAppBased((uint64_t)a2))
    {
      re::Defaults::BOOLValue((re::Defaults *)"AllowAppBasedAssetPaths", v7, v21);
      if (v21[0])
        v8 = v21[1] == 0;
      else
        v8 = 1;
      return !v8;
    }
    re::AssetHandle::getLegacyAppPath(a3, v21);
    if (!v21[0])
      return 1;
  }
  else
  {
    re::AssetHandle::getLegacyAppPath(a3, v21);
    if (!v21[0])
    {
      re::Optional<re::AssetPath>::Optional((uint64_t)v20, (unsigned __int8 *)this + 8);
      v12 = re::AssetSerializationScheme::commonCodingKeyInternal(a2, a3, (const re::AssetHandle *)0xC, v20);
      re::Optional<re::AssetPath>::~Optional((uint64_t)v20);
      v9 = 1;
      if (!*((_BYTE *)this + 104) && v12 == 3)
      {
        v13 = atomic_load((unsigned __int8 *)&qword_2540FBA28);
        if ((v13 & 1) == 0 && __cxa_guard_acquire(&qword_2540FBA28))
        {
          _MergedGlobals_46 = 1;
          __cxa_guard_release(&qword_2540FBA28);
        }
        if ((*((_QWORD *)a2 + 1) & 1) != 0)
          v14 = (const char *)*((_QWORD *)a2 + 2);
        else
          v14 = (char *)a2 + 9;
        if (_MergedGlobals_46)
          v15 = 8;
        else
          v15 = 0;
        v16 = (re *)strncmp(v14, "assetId:", v15);
        if (!(_DWORD)v16)
        {
          v17 = *re::assetsLogObjects(v16);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            if ((*((_QWORD *)a2 + 1) & 1) != 0)
              v19 = (char *)*((_QWORD *)a2 + 2);
            else
              v19 = (char *)a2 + 9;
            *(_DWORD *)buf = 136315138;
            v25 = v19;
            _os_log_error_impl(&dword_224FE9000, v17, OS_LOG_TYPE_ERROR, "RealityFileAssetSerialize generated an AssetId-based serialization string: '%s'.", buf, 0xCu);
          }
          v9 = 0;
        }
      }
      goto LABEL_17;
    }
  }
  re::DynamicString::operator=(a2, (re::DynamicString *)&v22);
  re::Defaults::BOOLValue((re::Defaults *)"AllowAppBasedAssetPaths", v10, (char *)buf);
  if (buf[0])
    v11 = buf[1] == 0;
  else
    v11 = 1;
  v9 = !v11;
LABEL_17:
  if (v21[0] && v22 && (v23 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v22 + 40))();
  return v9;
}

void re::RealityFileAssetSerialize::toHandle(re::RealityFileAssetSerialize *this, re::AssetHandle *a2, const char *a3, re::Allocator *a4)
{
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, a4, "assertion failure: '%s' (%s:line %i) Cannot deserialize using RealityFileAssetSerialize class", "!\"Unreachable code\"", "toHandle", 265);
  _os_crash();
  __break(1u);
}

void re::RealityFileAssetDeserialization::fromHandle(re::RealityFileAssetDeserialization *this, re::DynamicString *a2, const re::AssetHandle *a3)
{
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) Cannot serialize using RealityFileAssetDeserialization class", "!\"Unreachable code\"", "fromHandle", 277);
  _os_crash();
  __break(1u);
}

uint64_t re::RealityFileAssetDeserialization::toHandle(re::RealityFileAssetDeserialization *this, re::AssetHandle *a2, const char *a3, re::Allocator *a4)
{
  const char *v8;
  uint64_t v9;
  uint64_t v11;
  char v12;
  char v13[2];

  if (!re::AssetPath::pathIsAppBased((uint64_t)&v11)
    || (re::Defaults::BOOLValue((re::Defaults *)"AllowAppBasedAssetPaths", v8, v13), v9 = 0, v13[0]) && v13[1])
  {
    v9 = (*(uint64_t (**)(_QWORD, re::AssetHandle *, const char *, re::Allocator *))(**((_QWORD **)this + 1)
                                                                                             + 24))(*((_QWORD *)this + 1), a2, a3, a4);
  }
  if (v11 && (v12 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v11 + 40))();
  return v9;
}

uint64_t re::NetworkAssetSerialization::fromHandle(re::NetworkAssetSerialization *this, re::DynamicString *a2, os_unfair_lock_s **a3)
{
  _QWORD *v6;
  const char *v7;
  uint64_t v8;
  os_unfair_lock_s *v9;
  const char **v10;
  const char *v11;
  os_unfair_lock_s *v12;
  os_unfair_lock_s *v13;
  uint32_t os_unfair_lock_opaque;
  re::AssetPath *v15;
  const char *v16;
  const char *v18;
  uint64_t v19;

  if (a3[1])
  {
    v6 = re::AssetHandle::assetInfo((re::AssetHandle *)a3);
    if (v6[10] == -1)
      LODWORD(v8) = 0;
    else
      v8 = v6[10];
    v9 = a3[1];
    if (v9 && (v10 = *(const char ***)&v9[66]._os_unfair_lock_opaque) != 0)
      v11 = *v10;
    else
      v11 = 0;
    re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x80A, v8, v11, v7);
  }
  if ((re::AssetSerializationScheme::storedCodingKey(a2, (re::DynamicString *)a3, (const re::AssetHandle *)a3) & 1) == 0
    && (re::AssetSerializationScheme::deviceCodingKey(a2, 1, 12, (uint64_t)a3) & 1) == 0)
  {
    v12 = a3[1];
    if (v12
      && (v13 = v12 + 96,
          os_unfair_lock_lock(v12 + 96),
          os_unfair_lock_opaque = v12[105]._os_unfair_lock_opaque,
          os_unfair_lock_unlock(v13),
          os_unfair_lock_opaque == 2))
    {
      v18 = "nosync";
      v19 = 6;
      re::DynamicString::operator=(a2, (uint64_t)&v18);
    }
    else
    {
      v15 = (re::AssetPath *)re::AssetHandle::legacy_assetPath((re::AssetHandle *)a3);
      if ((*((_BYTE *)this + 112) & 1) != 0)
        v16 = (const char *)*((_QWORD *)this + 15);
      else
        v16 = (char *)this + 113;
      re::AssetPath::assetPathForNetwork(v15, v16, (re::DynamicString *)&v18);
      re::DynamicString::operator=(a2, (re::DynamicString *)&v18);
      if (v18 && (v19 & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v18 + 40))();
    }
  }
  return 1;
}

uint64_t re::NetworkAssetSerialization::toHandle(re::NetworkAssetSerialization *this, re::AssetHandle *a2, char *__s1, re::Allocator *a4)
{
  const re::AssetPath *v7;
  uint64_t *v8;
  const char *v9;
  re *v10;
  os_unfair_lock_s *v11;
  os_unfair_lock_s *v12;
  re::internal::AssetIdLoadDescriptorTable *v13;
  re::AssetManager *v14;
  __int128 v15;
  uint64_t v16;
  _QWORD *v17;
  char *v18;
  os_unfair_lock_s *v19;
  char *v20;
  const char *v21;
  uint64_t v22;
  const re::DynamicString **v23;
  uint64_t v24;
  NSObject *v25;
  _BYTE *v26;
  NSObject *v27;
  _anonymous_namespace_ *v28;
  _anonymous_namespace_ *v29;
  const re::IntrospectionBase *v30;
  const char *v31;
  __int128 v32;
  uint64_t v33;
  _QWORD *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  const char **v38;
  const char *v39;
  uint8_t *v41;
  _BYTE v42[88];
  const re::IntrospectionBase *v43;
  _BYTE v44[8];
  _DWORD v45[6];
  char v46;
  _BYTE v47[24];
  _BYTE v48[23];
  const char **v49;
  _QWORD v50[4];
  __int128 v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint8_t buf[32];
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  __int128 v60;
  __int128 v61;
  int v62;
  _QWORD v63[9];

  v63[6] = *MEMORY[0x24BDAC8D0];
  if (strcmp(__s1, "nosync"))
  {
    if (*((_BYTE *)this + 8))
      v7 = (re::NetworkAssetSerialization *)((char *)this + 16);
    else
      v7 = 0;
    v8 = re::AssetManager::parseAssetPath(*((re::AssetManager **)this + 17), __s1, v7, 1, (uint64_t)v44);
    if (v44[0])
    {
      if (v45[0] != 8)
      {
LABEL_13:
        v14 = (re::AssetManager *)*((_QWORD *)this + 17);
        re::Optional<re::AssetPath>::Optional((uint64_t)v42, (unsigned __int8 *)this + 8);
        re::AssetSerializationScheme::relativeHandle((uint64_t *)buf, v14, __s1, v42);
        v15 = *(_OWORD *)a2;
        *(_OWORD *)a2 = *(_OWORD *)buf;
        *(_OWORD *)buf = v15;
        v16 = *((_QWORD *)a2 + 2);
        *((_QWORD *)a2 + 2) = *(_QWORD *)&buf[16];
        *(_QWORD *)&buf[16] = v16;
        re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
        re::Optional<re::AssetPath>::~Optional((uint64_t)v42);
        if (*((_DWORD *)re::AssetHandle::assetInfo(a2) + 22) == 4)
        {
          v17 = re::AssetHandle::legacy_assetPath(a2);
          v18 = (v17[2] & 1) != 0 ? (char *)v17[3] : (char *)v17 + 17;
          if ((*(unsigned int (**)(re::NetworkAssetSerialization *, char *))(*(_QWORD *)this + 32))(this, v18))
          {
            v19 = (os_unfair_lock_s *)*((_QWORD *)this + 17);
            v20 = (char *)re::AssetHandle::legacy_assetPath(a2);
            if ((v20[48] & 1) != 0)
              v21 = (const char *)*((_QWORD *)v20 + 7);
            else
              v21 = v20 + 49;
            v22 = *((_QWORD *)a2 + 1);
            if (v22)
              v23 = *(const re::DynamicString ***)(v22 + 264);
            else
              v23 = 0;
            re::AssetManager::assetHandleMemoryPath(v19, v21, v23, (uint64_t *)buf);
            v32 = *(_OWORD *)a2;
            *(_OWORD *)a2 = *(_OWORD *)buf;
            *(_OWORD *)buf = v32;
            v33 = *((_QWORD *)a2 + 2);
            *((_QWORD *)a2 + 2) = *(_QWORD *)&buf[16];
            *(_QWORD *)&buf[16] = v33;
            re::AssetHandle::~AssetHandle((re::AssetHandle *)buf);
          }
        }
        if (*((_QWORD *)a2 + 1))
        {
          v34 = re::AssetHandle::assetInfo(a2);
          if (v34[10] == -1)
            LODWORD(v36) = 0;
          else
            v36 = v34[10];
          v37 = *((_QWORD *)a2 + 1);
          if (v37 && (v38 = *(const char ***)(v37 + 264)) != 0)
            v39 = *v38;
          else
            v39 = 0;
          re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x80B, v36, v39, v35);
        }
        v24 = 1;
        goto LABEL_62;
      }
      v43 = 0;
      if ((v47[23] & 1) != 0)
        v9 = *(const char **)&v48[7];
      else
        v9 = v48;
      v10 = (re *)sscanf(v9, "%llu", &v43);
      if ((_DWORD)v10 == 1)
      {
        v11 = (os_unfair_lock_s *)*((_QWORD *)this + 17);
        v12 = v11 + 16;
        os_unfair_lock_lock(v11 + 16);
        v13 = (re::internal::AssetIdLoadDescriptorTable *)&v11[30];
        *(_QWORD *)buf = v43;
        if (!re::HashTable<unsigned long long,re::DynamicArray<re::AssetLoadDescriptor>,re::Hash<unsigned long long>,re::EqualTo<unsigned long long>,true,false>::tryGet((uint64_t)v13, (uint64_t *)buf))
        {
          memset(buf, 0, sizeof(buf));
          v28 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(buf, 0);
          v56 = 0;
          v57 = 0;
          v58 = 0;
          v60 = 0u;
          v61 = 0u;
          v59 = 0;
          v62 = 0;
          memset(v63, 0, 40);
          v29 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v63[1], 0);
          v30 = v43;
          v31 = *v49;
          re::NetworkAssetLoadDescriptor::init((uint64_t)buf, v30, (re::DynamicString *)v50);
          if (v50[0])
          {
            if ((v50[1] & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v50[0] + 40))();
            memset(v50, 0, sizeof(v50));
          }
          v54 = 0;
          v52 = 0;
          v51 = 0uLL;
          v53 = 0;
          re::DynamicArray<re::AssetLoadDescriptor>::add((_anonymous_namespace_ *)&v51, (re::DynamicString *)buf);
          re::internal::AssetIdLoadDescriptorTable::addNewImmutable(v13, (unint64_t)v43, (uint64_t *)&v51);
          re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)&v51);
          if (v63[1])
          {
            if ((v63[2] & 1) != 0)
              (*(void (**)(void))(*(_QWORD *)v63[1] + 40))();
            memset(&v63[1], 0, 32);
          }
          if (*((_QWORD *)&v60 + 1))
          {
            if (v63[0])
              (*(void (**)(void))(**((_QWORD **)&v60 + 1) + 40))();
            v63[0] = 0;
            v61 = 0uLL;
            *((_QWORD *)&v60 + 1) = 0;
            ++v62;
          }
          if (v56)
          {
            if ((_QWORD)v60)
              (*(void (**)(void))(*(_QWORD *)v56 + 40))();
            *(_QWORD *)&v60 = 0;
            v57 = 0;
            v58 = 0;
            v56 = 0;
            ++v59;
          }
          if (*(_QWORD *)buf && (buf[8] & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)buf + 40))();
        }
        os_unfair_lock_unlock(v12);
        goto LABEL_13;
      }
      v27 = *re::assetsLogObjects(v10);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        re::AssetPath::fullAssetPath((re::AssetPath *)v45, (re::DynamicString *)buf);
        v41 = (buf[8] & 1) != 0 ? *(uint8_t **)&buf[16] : &buf[9];
        LODWORD(v51) = 136315138;
        *(_QWORD *)((char *)&v51 + 4) = v41;
        _os_log_error_impl(&dword_224FE9000, v27, OS_LOG_TYPE_ERROR, "invalid asset path asset Id: %s", (uint8_t *)&v51, 0xCu);
        if (*(_QWORD *)buf)
        {
          if ((buf[8] & 1) != 0)
            (*(void (**)(void))(**(_QWORD **)buf + 40))();
        }
      }
    }
    else
    {
      v25 = *re::assetsLogObjects((re *)v8);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        if ((v46 & 1) != 0)
          v26 = *(_BYTE **)&v47[7];
        else
          v26 = v47;
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = __s1;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v26;
        _os_log_error_impl(&dword_224FE9000, v25, OS_LOG_TYPE_ERROR, "asset string '%s' parse failed: %s", buf, 0x16u);
      }
    }
    v24 = 0;
LABEL_62:
    re::Result<re::AssetPath,re::DetailedError>::~Result((uint64_t)v44);
    return v24;
  }
  return 1;
}

uint64_t re::PassthroughAssetSerialization::fromHandle(re::PassthroughAssetSerialization *this, re::DynamicString *a2, const re::AssetHandle *a3)
{
  uint64_t v5;
  char v6;

  re::AssetHandle::serializationString(a3, (re::DynamicString *)&v5);
  re::DynamicString::operator=(a2, (re::DynamicString *)&v5);
  if (v5 && (v6 & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v5 + 40))();
  return 1;
}

uint64_t re::PassthroughAssetSerialization::toHandle(re::PassthroughAssetSerialization *this, re::AssetHandle *a2, re::AssetPath *a3, re::Allocator *a4)
{
  re::AssetHandle::setSerializationString(a2, a3, a4);
  return 1;
}

void re::PeanutToAlmondAssetSerialization::fromHandle(re::PeanutToAlmondAssetSerialization *this, re::DynamicString *a2, const re::AssetHandle *a3)
{
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, "assertion failure: '%s' (%s:line %i) Unexpected asset serialization, PeanutToAlmond not supported!", "!\"Unreachable code\"", "fromHandle", 462);
  _os_crash();
  __break(1u);
}

BOOL re::PeanutToAlmondAssetSerialization::toHandle(re::AssetManager **this, re::AssetHandle *a2, char *__s, re::Allocator *a4)
{
  char *v5;
  size_t v8;
  _anonymous_namespace_ *v9;
  _anonymous_namespace_ *v10;
  size_t v11;
  char *v12;
  _BOOL8 v13;
  size_t v14;
  char *v15;
  size_t v16;
  re *v17;
  re::DynamicString *v18;
  unint64_t v19;
  re::AssetPath *v20;
  NSObject *v22;
  NSObject *v23;
  _BYTE v24[8];
  uint64_t v25;
  uint64_t v26;
  _QWORD v27[2];
  _QWORD v28[2];
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  __int128 v33;
  re::AssetPath *v34;
  uint64_t v35;
  char v36[8];
  char __s2[16];
  _BYTE buf[24];
  uint64_t v39;
  uint64_t v40;

  v5 = __s;
  v40 = *MEMORY[0x24BDAC8D0];
  v8 = strlen(__s);
  v9 = (_anonymous_namespace_ *)strncmp("reality:", v5, 8uLL);
  if ((_DWORD)v9)
  {
    *(_QWORD *)&buf[8] = 0;
    *(_QWORD *)&buf[16] = 0;
    v39 = 0;
    re::DynamicString::setCapacity(buf, 0);
    v10 = (_anonymous_namespace_ *)re::AssetPath::removingCompiledExtension((re::AssetPath *)v5, (uint64_t)v24);
    if (v24[0])
    {
      v31 = 0;
      v32 = 0;
      if (v26)
        v11 = v26 + 1;
      else
        v11 = 0;
      v30 = 0;
      re::DynamicString::setCapacity(&v29, v11);
      re::DynamicString::operator=((re::DynamicString *)&v29, (uint64_t)&v25);
      re::DynamicString::operator=((re::DynamicString *)buf, (re::DynamicString *)&v29);
      if (v29 && (v30 & 1) != 0)
        (*(void (**)(void))(*v29 + 40))();
      if ((buf[8] & 1) != 0)
        v5 = *(char **)&buf[16];
      else
        v5 = &buf[9];
    }
    re::AssetHandle::setSerializationString(a2, (re::AssetPath *)v5, a4);
    if (*(_QWORD *)buf && (buf[8] & 1) != 0)
      (*(void (**)(void))(**(_QWORD **)buf + 40))();
    return 1;
  }
  else
  {
    strcpy(__s2, ".reality/");
    v12 = strstr(v5 + 8, __s2);
    v13 = v12 != 0;
    if (v12)
    {
      v28[0] = v5 + 8;
      v28[1] = v12 - v5;
      *(_QWORD *)&buf[16] = 0;
      v39 = 0;
      if (v12 == v5)
        v14 = 0;
      else
        v14 = v12 - (v5 + 8) + 9;
      *(_QWORD *)buf = a4;
      *(_QWORD *)&buf[8] = 0;
      re::DynamicString::setCapacity(buf, v14);
      re::DynamicString::operator=((re::DynamicString *)buf, (uint64_t)v28);
      strcpy(v36, "assets/");
      v15 = strstr(v5 + 8, v36);
      if (v15)
      {
        v27[0] = v15 + 7;
        v27[1] = &v5[v8] - (v15 + 7);
        v31 = 0;
        v32 = 0;
        if (&v5[v8] == v15 + 7)
          v16 = 0;
        else
          v16 = &v5[v8] - (v15 + 7) + 1;
        v29 = (uint64_t *)a4;
        v30 = 0;
        re::DynamicString::setCapacity(&v29, v16);
        re::DynamicString::operator=((re::DynamicString *)&v29, (uint64_t)v27);
        re::AssetManager::tryGetImmutableRealityFileAsset(this[1], (const re::DynamicString *)buf, (const re::DynamicString *)&v29, (uint64_t)v24);
        if (v24[0])
        {
          v18 = (re::DynamicString *)re::AssetHandle::legacy_assetPath((re::AssetHandle *)&v25);
          v19 = *((_QWORD *)v18 + 1);
          v34 = 0;
          v35 = 0;
          v33 = v19;
          re::DynamicString::setCapacity(&v33, 0);
          re::AssetPath::fullAssetPath(v18, (re::DynamicString *)&v33);
          if ((BYTE8(v33) & 1) != 0)
            v20 = v34;
          else
            v20 = (re::AssetPath *)((char *)&v33 + 9);
          re::AssetHandle::setSerializationString(a2, v20, a4);
          if ((_QWORD)v33 && (BYTE8(v33) & 1) != 0)
            (*(void (**)(void))(*(_QWORD *)v33 + 40))();
        }
        else
        {
          v23 = *re::assetsLogObjects(v17);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(v33) = 136315138;
            *(_QWORD *)((char *)&v33 + 4) = v5;
            _os_log_impl(&dword_224FE9000, v23, OS_LOG_TYPE_DEFAULT, "PeanutToAlmond Asset Deserialization: No existing asset found for %s", (uint8_t *)&v33, 0xCu);
          }
        }
        if (v24[0])
          re::AssetHandle::~AssetHandle((re::AssetHandle *)&v25);
        if (v29 && (v30 & 1) != 0)
          (*(void (**)(void))(*v29 + 40))();
      }
      if (*(_QWORD *)buf && (buf[8] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)buf + 40))();
    }
    else
    {
      v22 = *re::assetsLogObjects(0);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = __s2;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v5;
        _os_log_error_impl(&dword_224FE9000, v22, OS_LOG_TYPE_ERROR, "PeanutToAlmond Asset Deserialization failure: Invalid AssetHandle: No %s extension found in legacy reality file path '%s'", buf, 0x16u);
      }
    }
  }
  return v13;
}

uint64_t re::AlmondToPeanutAssetSerialization::fromHandle(re::AlmondToPeanutAssetSerialization *this, re::AssetPath **a2, const re::AssetHandle *a3)
{
  uint64_t v6;
  const re::internal::AssetTypeRegistry *v7;
  re::AssetPath *v8;
  uint64_t AssetTypeFromFilePath;
  char *v10;
  _anonymous_namespace_ *v11;
  char *v12;
  double v13;
  const char *v14;
  uint64_t v15;
  _QWORD *v16;
  re *v17;
  const char *v18;
  size_t v19;
  NSObject *v20;
  const char *v22;
  void *v23;
  uint64_t v24;
  char v25;
  _BYTE v26[7];
  const char *v27;
  char v28[8];
  _QWORD v29[5];
  uint64_t v30;
  char v31[24];
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  _QWORD v35[4];
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  __int128 buf;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v6 = *((_QWORD *)this + 2);
  if (!v6
    || ((*(uint64_t (**)(uint64_t, re::AssetPath **, const re::AssetHandle *))(*(_QWORD *)v6 + 16))(v6, a2, a3) & 1) == 0)
  {
    re::AssetHandle::serializationString(a3, (re::DynamicString *)&v34);
    re::DynamicString::operator=((re::DynamicString *)a2, (re::DynamicString *)&v34);
    if (v34)
    {
      if ((v35[0] & 1) != 0)
        (*(void (**)(void))(*(_QWORD *)v34 + 40))();
    }
  }
  if (((unint64_t)a2[1] & 1) != 0)
    v8 = a2[2];
  else
    v8 = (re::AssetPath *)((char *)a2 + 9);
  AssetTypeFromFilePath = re::AssetPath::getAssetTypeFromFilePath(v8, *(re::internal::AssetTypeRegistry **)(*((_QWORD *)this + 1) + 1104), v7);
  v10 = re::AssetPath::updateWithCompiledExtension((char *)a2, AssetTypeFromFilePath);
  LODWORD(v34) = 0;
  memset(v35, 0, sizeof(v35));
  v11 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(v35, 0);
  v37 = 0u;
  v36 = 0u;
  re::DynamicString::setCapacity(&v36, 0);
  v38 = 0;
  if (((unint64_t)a2[1] & 1) != 0)
    v12 = (char *)a2[2];
  else
    v12 = (char *)a2 + 9;
  v13 = re::AssetPath::parse((re::AssetPath *)&v34, v12, 0, *(const re::internal::AssetTypeRegistry **)(*((_QWORD *)this + 1) + 1104), *(os_unfair_lock_s **)(*((_QWORD *)this + 1) + 1192), v31);
  if (!v31[0] && (_QWORD)v32)
  {
    if ((BYTE8(v32) & 1) != 0)
      (*(void (**)(double))(*(_QWORD *)v32 + 40))(v13);
    v32 = 0u;
    v33 = 0u;
  }
  v30 = 0;
  if ((_DWORD)v34 == 8
    && ((BYTE8(v36) & 1) != 0 ? (v14 = (const char *)v37) : (v14 = (char *)&v36 + 9), sscanf(v14, "%llu", &v30) == 1))
  {
    v15 = v30;
  }
  else
  {
    v16 = re::AssetHandle::assetInfo(a3);
    v15 = v16[10];
    if ((unint64_t)(v15 + 1) < 2)
      goto LABEL_40;
    v30 = v16[10];
  }
  re::AssetManager::loadDescriptorsFromAssetId(*((os_unfair_lock_s **)this + 1), v15, v28);
  if (v28[0] && v29[2])
  {
    re::AssetManager::convertToAssetPath(*((_QWORD *)this + 1), v29[4], 3, (uint64_t)&v23);
    if ((_BYTE)v23)
    {
      if ((v25 & 1) != 0)
        v18 = v27;
      else
        v18 = v26;
      v19 = strlen(v18);
      *(_QWORD *)&buf = v18;
      *((_QWORD *)&buf + 1) = v19;
    }
    else
    {
      v20 = *re::assetsLogObjects(v17);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        if ((v25 & 1) != 0)
          v22 = v27;
        else
          v22 = v26;
        LODWORD(buf) = 136315138;
        *(_QWORD *)((char *)&buf + 4) = v22;
        _os_log_error_impl(&dword_224FE9000, v20, OS_LOG_TYPE_ERROR, "AlmondToPeanut AssetHandle Serialization Error: %s", (uint8_t *)&buf, 0xCu);
      }
      *(_QWORD *)&buf = &str_36;
      *((_QWORD *)&buf + 1) = 0;
    }
    re::DynamicString::operator=((re::DynamicString *)a2, (uint64_t)&buf);
    if (v24 && (v25 & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v24 + 40))();
  }
  else
  {
    v23 = &str_36;
    v24 = 0;
    re::DynamicString::operator=((re::DynamicString *)a2, (uint64_t)&v23);
  }
  if (v28[0])
    re::DynamicArray<re::AssetLoadDescriptor>::deinit((uint64_t)v29);
LABEL_40:
  if ((_QWORD)v36)
  {
    if ((BYTE8(v36) & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v36 + 40))();
    v36 = 0u;
    v37 = 0u;
  }
  if (v35[0] && (v35[1] & 1) != 0)
    (*(void (**)(void))(*(_QWORD *)v35[0] + 40))();
  return 1;
}

void re::AlmondToPeanutAssetSerialization::toHandle(re::AlmondToPeanutAssetSerialization *this, re::AssetHandle *a2, const char *a3, re::Allocator *a4)
{
  re::internal::assertLog((re::internal *)4, (uint64_t)a2, a3, a4, "assertion failure: '%s' (%s:line %i) Unexpected asset deserialization, AlmondToPeanut not supported!", "!\"Unreachable code\"", "toHandle", 579);
  _os_crash();
  __break(1u);
}

void re::ZeroAssetSerialization::~ZeroAssetSerialization(re::ZeroAssetSerialization *this)
{
  JUMPOUT(0x2276933B8);
}

void re::DefaultAssetSerialize::~DefaultAssetSerialize(re::DefaultAssetSerialize *this)
{
  *(_QWORD *)this = &off_24ED2D3D0;
  re::Optional<re::AssetPath>::~Optional((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &off_24ED2D3D0;
  re::Optional<re::AssetPath>::~Optional((uint64_t)this + 8);
  JUMPOUT(0x2276933B8);
}

void re::DirectAssetDeserialize::~DirectAssetDeserialize(re::DirectAssetDeserialize *this)
{
  *(_QWORD *)this = &off_24ED2D0D0;
  re::Optional<re::AssetPath>::~Optional((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &off_24ED2D0D0;
  re::Optional<re::AssetPath>::~Optional((uint64_t)this + 8);
  JUMPOUT(0x2276933B8);
}

void re::DeferredAssetDeserialize::~DeferredAssetDeserialize(re::DeferredAssetDeserialize *this)
{
  JUMPOUT(0x2276933B8);
}

void re::RemappedAssetSerialize::~RemappedAssetSerialize(re::RemappedAssetSerialize *this)
{
  *(_QWORD *)this = &off_24ED2D100;
  re::Optional<re::AssetPath>::~Optional((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &off_24ED2D100;
  re::Optional<re::AssetPath>::~Optional((uint64_t)this + 8);
  JUMPOUT(0x2276933B8);
}

void re::RealityFileAssetSerialize::~RealityFileAssetSerialize(re::RealityFileAssetSerialize *this)
{
  *(_QWORD *)this = &off_24ED2D100;
  re::Optional<re::AssetPath>::~Optional((uint64_t)this + 8);
}

{
  *(_QWORD *)this = &off_24ED2D100;
  re::Optional<re::AssetPath>::~Optional((uint64_t)this + 8);
  JUMPOUT(0x2276933B8);
}

void re::RealityFileAssetDeserialization::~RealityFileAssetDeserialization(re::RealityFileAssetDeserialization *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::NetworkAssetSerialization::isLocalPeerID(re::NetworkAssetSerialization *this, const char *a2)
{
  return 0;
}

void re::PassthroughAssetSerialization::~PassthroughAssetSerialization(re::PassthroughAssetSerialization *this)
{
  JUMPOUT(0x2276933B8);
}

void re::PeanutToAlmondAssetSerialization::~PeanutToAlmondAssetSerialization(re::PeanutToAlmondAssetSerialization *this)
{
  JUMPOUT(0x2276933B8);
}

void re::AlmondToPeanutAssetSerialization::~AlmondToPeanutAssetSerialization(re::AlmondToPeanutAssetSerialization *this)
{
  JUMPOUT(0x2276933B8);
}

uint64_t re::Optional<re::AssetPath>::Optional(uint64_t a1, unsigned __int8 *a2)
{
  int v3;

  v3 = *a2;
  *(_BYTE *)a1 = v3;
  if (v3)
  {
    *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
    re::DynamicString::DynamicString((re::DynamicString *)(a1 + 16), (const re::DynamicString *)(a2 + 16));
    re::DynamicString::DynamicString((re::DynamicString *)(a1 + 48), (const re::DynamicString *)(a2 + 48));
    *(_QWORD *)(a1 + 80) = *((_QWORD *)a2 + 10);
  }
  return a1;
}

uint64_t re::directMeshConnectionId(void **a1)
{
  void *v1;
  audit_token_t v3;
  audit_token_t atoken;

  v1 = *a1;
  if (v1)
    objc_msgSend(v1, "auditToken");
  else
    memset(&v3, 0, sizeof(v3));
  atoken = v3;
  return audit_token_to_pid(&atoken);
}

void re::ResourceFetchManager::xpcInterface(_QWORD *a1@<X8>)
{
  void *v3;
  void *v4;
  id v5;

  objc_msgSend(MEMORY[0x24BDD1990], "interfaceWithProtocol:", &unk_255838AC8);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x24BDBCF20], "setWithObject:", objc_opt_class());
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "setClasses:forSelector:argumentIndex:ofReply:", v4, sel_associateConnectionWithPeerID_clientPorts_, 1, 0);

  v5 = v3;
  *a1 = v5;

}

void re::ResourceFetchManager::~ResourceFetchManager(void **this)
{
  char *v2;
  char *v3;
  char *v4;

  re::ResourceFetchManager::deinit(this);

  v2 = (char *)this[34];
  if (v2)
  {

    this[34] = 0;
  }
  v3 = (char *)this[33];
  if (v3)
  {

    this[33] = 0;
  }
  v4 = (char *)this[32];
  if (v4)
  {

    this[32] = 0;
  }

  re::DynamicArray<re::SharedPtr<re::ResourceFetchManager::Request>>::deinit((uint64_t)(this + 14));
  re::DynamicArray<re::ResourceFetchManager::Connection>::deinit((uint64_t)(this + 9));

}

{
  re::ResourceFetchManager::~ResourceFetchManager(this);
  JUMPOUT(0x2276933ACLL);
}

void **re::ResourceFetchManager::deinit(void **this)
{
  void **v1;
  void *v2;
  id *v3;
  id *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  int v9;
  id v10;
  void *v11;
  uint64_t v12;
  void *v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  re::PeerIDValidator *v28;
  __int128 *v29;
  void *v30;
  void *v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  id v35;
  char *v36;
  __int128 v37;
  __int128 v38;
  int v39;
  id v40;

  if (*((_BYTE *)this + 8))
  {
    v1 = this;
    MEMORY[0x22768FF80](5, 0, re::ResourceFetchManager::renderServerContextDidCommit, this);
    objc_msgSend(v1[3], "invalidate");
    os_unfair_lock_lock((os_unfair_lock_t)v1 + 16);
    v2 = v1[11];
    if (v2)
    {
      v3 = (id *)v1[13];
      v4 = &v3[8 * (_QWORD)v2];
      do
      {
        v5 = v1[34];
        v6 = v5[15];
        if (v6)
        {
          v7 = 48 * v6;
          v8 = (uint64_t *)(v5[17] + 40);
          do
          {
            v9 = objc_msgSend(v3[1], "pid");
            v10 = v3[1];
            if (v10)
            {
              objc_msgSend(v10, "auditToken");
              v10 = v3[1];
            }
            else
            {
              v37 = 0u;
              v38 = 0u;
            }
            v11 = (void *)objc_msgSend(v10, "peerID", v37, v38);
            v39 = v9;
            v40 = v11;
            v12 = *v8;
            v8 += 6;
            (*(void (**)(uint64_t, int *, __int128 *, id *))(*(_QWORD *)v12 + 16))(v12, &v39, &v37, &v40);
            v7 -= 48;
          }
          while (v7);
        }
        v3 += 8;
      }
      while (v3 != v4);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)v1 + 16);
    os_unfair_lock_lock((os_unfair_lock_t)v1 + 16);
    objc_msgSend(v1[2], "invalidate");
    v13 = v1[11];
    if (v13)
    {
      v14 = (char *)v1[13];
      v15 = &v14[64 * (_QWORD)v13];
      do
      {
        v16 = *((unsigned int *)v14 + 12);
        if ((_DWORD)v16)
        {
          v17 = 0;
          v18 = (int *)(*((_QWORD *)v14 + 4) + 8);
          while (1)
          {
            v19 = *v18;
            v18 += 22;
            if (v19 < 0)
              break;
            if (v16 == ++v17)
            {
              LODWORD(v17) = *((_DWORD *)v14 + 12);
              break;
            }
          }
        }
        else
        {
          LODWORD(v17) = 0;
        }
        if ((_DWORD)v16 != (_DWORD)v17)
        {
          v20 = v17;
          do
          {
            v21 = *((_QWORD *)v14 + 4) + 88 * v20;
            v22 = *(_QWORD *)(v21 + 64);
            if (v22)
            {
              v23 = *(uint64_t **)(v21 + 80);
              v24 = 8 * v22;
              do
              {
                v25 = *v23++;
                *(_QWORD *)(v25 + 16) = 0;
                v24 -= 8;
              }
              while (v24);
            }
            if (v16 <= (int)v17 + 1)
              v26 = v17 + 1;
            else
              v26 = v16;
            while (1)
            {
              v20 = (v17 + 1);
              if (v26 - 1 == (_DWORD)v17)
                break;
              LODWORD(v17) = v17 + 1;
              v27 = v20;
              if ((*(_DWORD *)(*((_QWORD *)v14 + 4) + 88 * v20 + 8) & 0x80000000) != 0)
                goto LABEL_31;
            }
            v27 = v26;
LABEL_31:
            LODWORD(v17) = v27;
          }
          while ((_DWORD)v16 != v27);
        }
        re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear((uint64_t)(v14 + 16));
        v28 = (re::PeerIDValidator *)objc_msgSend(*((id *)v14 + 1), "peerID");
        v29 = re::PeerIDValidator::instance(v28);
        re::PeerIDValidator::remove_impl((re::PeerIDValidator *)v29, (unint64_t)v28);
        objc_msgSend(*(id *)v14, "invalidate");
        objc_msgSend(*((id *)v14 + 1), "invalidate");
        re::ObjCObject::operator=((void **)v14, 0);
        v30 = (void *)*((_QWORD *)v14 + 1);
        *((_QWORD *)v14 + 1) = 0;

        v14 += 64;
      }
      while (v14 != v15);
    }
    v31 = v1[16];
    if (v31)
    {
      v32 = (uint64_t *)v1[18];
      v33 = 8 * (_QWORD)v31;
      do
      {
        v34 = *v32++;
        re::makeResourceSharingError((__CFString *)0x191, 0, &v40);
        v35 = v40;
        v40 = 0;
        LOBYTE(v37) = 0;
        *((_QWORD *)&v37 + 1) = v35;
        (*(void (**)(_QWORD, __int128 *))(**(_QWORD **)(v34 + 96) + 16))(*(_QWORD *)(v34 + 96), &v37);

        v33 -= 8;
      }
      while (v33);
    }
    re::DynamicArray<re::SharedPtr<re::ResourceFetchManager::Request>>::deinit((uint64_t)(v1 + 14));
    re::DynamicArray<re::ResourceFetchManager::Connection>::deinit((uint64_t)(v1 + 9));
    os_unfair_lock_unlock((os_unfair_lock_t)v1 + 16);
    re::DynamicArray<re::ResourceFetchManager::ConnectionAddedHandler>::deinit((uint64_t)v1[34] + 64);
    re::DynamicArray<re::ResourceFetchManager::ConnectionAddedHandler>::deinit((uint64_t)v1[34] + 104);
    v36 = (char *)v1[34];
    if (v36)
    {

      v1[34] = 0;
    }
    re::ObjCObject::operator=(v1 + 4, 0);
    re::ObjCObject::operator=(v1 + 3, 0);
    this = re::ObjCObject::operator=(v1 + 2, 0);
    *((_BYTE *)v1 + 8) = 0;
  }
  return this;
}

void re::ResourceFetchManager::renderServerContextDidCommit(re::ResourceFetchManager *this, os_unfair_lock_s *a2, void *a3, void *a4)
{
  int ProcessId;
  void *v6;
  os_unfair_lock_s *v7;
  id v8;
  uint64_t v9;
  uint64_t v10;
  os_unfair_lock_s *v11;
  void **v12;
  uint64_t v13;
  id *v14;
  id v15;
  id v16;

  ProcessId = CARenderContextGetProcessId();
  v16 = (id)voucher_copy();

  v6 = v16;
  if (v16)
  {
    v7 = a2 + 16;
    v8 = v16;
    os_unfair_lock_lock(a2 + 16);
    v9 = *(_QWORD *)&a2[22]._os_unfair_lock_opaque;
    if (v9)
    {
      v10 = *(_QWORD *)&a2[26]._os_unfair_lock_opaque;
      v11 = a2 + 48;
      v12 = (void **)&a2[50];
      v13 = v9 << 6;
      v14 = (id *)(v10 + 8);
      do
      {
        if (*v14 && objc_msgSend(*v14, "pid") == ProcessId)
        {
          v15 = v8;
          os_unfair_lock_lock(v11);
          re::ObjCObject::operator=(v12, v15);
          os_unfair_lock_unlock(v11);

          objc_msgSend(*v14, "setVoucher:", v15);
        }
        v14 += 8;
        v13 -= 64;
      }
      while (v13);
    }
    os_unfair_lock_unlock(v7);

    v6 = v16;
  }

}

void re::ResourceFetchManager::init(re::ResourceFetchManager *this, id *a2)
{
  REResourceFetchServer *v3;
  void **v4;
  id v5;
  void *v6;
  NSObject *v7;
  NSObject *v8;
  dispatch_queue_t v9;
  NSObject *v10;
  NSObject *v11;
  dispatch_queue_t v12;
  _anonymous_namespace_ *v13;
  re *v14;
  uint64_t *v15;
  uint64_t v16;
  re *v17;
  uint64_t v18;
  id v19;

  re::ObjCObject::operator=((id *)this + 6, a2);
  v3 = -[REResourceFetchServer initWithResourceFetchManager:]([REResourceFetchServer alloc], "initWithResourceFetchManager:", this);
  re::ObjCObject::operator=((void **)this + 2, v3);

  re::xpc::Listener::makeAnonymous(&v19);
  v4 = (void **)((char *)this + 24);
  if ((id *)((char *)this + 24) != &v19)
  {
    v5 = v19;
    v19 = 0;
    v6 = *v4;
    *v4 = v5;

  }
  re::xpc::Listener::setDelegate((id *)this + 3, (uint64_t *)this + 2);
  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v7 = objc_claimAutoreleasedReturnValue();
  dispatch_queue_attr_make_with_qos_class(v7, QOS_CLASS_USER_INITIATED, 0);
  v8 = objc_claimAutoreleasedReturnValue();

  v9 = dispatch_queue_create("com.apple.CoreRE.ResourceFetchManager-service-queue", v8);
  re::ObjCObject::operator=((void **)this + 4, v9);

  re::xpc::Connection::setQueue((id *)this + 3, (re::ResourceFetchManager *)((char *)this + 32));
  dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x24BDAC9C0], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v10 = objc_claimAutoreleasedReturnValue();
  dispatch_queue_attr_make_with_qos_class(v10, QOS_CLASS_USER_INITIATED, 0);
  v11 = objc_claimAutoreleasedReturnValue();

  v12 = dispatch_queue_create("com.apple.CoreRE.ResourceFetchManager-decode-queue", v11);
  re::ObjCObject::operator=((void **)this + 5, v12);

  os_unfair_lock_lock((os_unfair_lock_t)this + 16);
  re::DynamicArray<re::ResourceFetchManager::Connection>::setCapacity((_QWORD *)this + 9, 8uLL);
  ++*((_DWORD *)this + 24);
  re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity((_QWORD *)this + 14, 0x40uLL);
  ++*((_DWORD *)this + 34);
  os_unfair_lock_unlock((os_unfair_lock_t)this + 16);
  v15 = re::globalAllocators(v14);
  v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v15[2] + 32))(v15[2], 144, 8);
  *(_OWORD *)v16 = 0u;
  *(_OWORD *)(v16 + 16) = 0u;
  *(_OWORD *)(v16 + 32) = 0u;
  *(_OWORD *)(v16 + 48) = 0u;
  *(_OWORD *)(v16 + 64) = 0u;
  *(_OWORD *)(v16 + 80) = 0u;
  *(_OWORD *)(v16 + 96) = 0u;
  *(_OWORD *)(v16 + 112) = 0u;
  *(_OWORD *)(v16 + 128) = 0u;
  ArcSharedObject::ArcSharedObject((ArcSharedObject *)v16, 0);
  *(_QWORD *)v16 = &off_24ED2D6A0;
  *(_QWORD *)(v16 + 48) = re::globalAllocators(v17)[2];
  *(_QWORD *)(v16 + 136) = 0;
  *(_DWORD *)(v16 + 88) = 0;
  *(_OWORD *)(v16 + 72) = 0u;
  *(_OWORD *)(v16 + 56) = 0u;
  *(_DWORD *)(v16 + 128) = 0;
  *(_OWORD *)(v16 + 96) = 0u;
  *(_OWORD *)(v16 + 112) = 0u;
  v18 = *((_QWORD *)this + 34);
  *((_QWORD *)this + 34) = v16;
  if (v18)

  objc_msgSend(*((id *)this + 3), "resume");
  CARenderNotificationAddObserver();
  *((_BYTE *)this + 8) = 1;

}

uint64_t re::DynamicArray<re::ResourceFetchManager::ConnectionAddedHandler>::deinit(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = *(_QWORD *)a1;
  if (result)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      if (v4)
      {
        v5 = 48 * v4;
        v6 = v3 + 8;
        do
        {
          re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::destroyCallable(v6);
          v6 += 48;
          v5 -= 48;
        }
        while (v5);
        result = *(_QWORD *)a1;
        v3 = *(_QWORD *)(a1 + 32);
      }
      result = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, v3);
    }
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    ++*(_DWORD *)(a1 + 24);
  }
  return result;
}

void re::ResourceFetchManager::xpcEndpoint(id *this@<X0>, _QWORD *a2@<X8>)
{
  re::xpc::Listener::endpoint(this + 3, a2);
}

BOOL re::ResourceFetchManager::hasPendingRequestedResources(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  _BOOL8 v3;

  v2 = this + 16;
  os_unfair_lock_lock(this + 16);
  v3 = *(_QWORD *)&this[32]._os_unfair_lock_opaque != 0;
  os_unfair_lock_unlock(v2);
  return v3;
}

uint64_t re::ResourceFetchManager::hasConnectionToPeer(os_unfair_lock_s *this, const char *a2)
{
  unint64_t v3;
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  id *v8;
  uint64_t v9;

  v3 = strtoull_l(a2, 0, 10, 0);
  v4 = this + 16;
  os_unfair_lock_lock(this + 16);
  v5 = *(_QWORD *)&this[22]._os_unfair_lock_opaque;
  if (v5)
  {
    v6 = *(_QWORD *)&this[26]._os_unfair_lock_opaque;
    v7 = v5 << 6;
    v8 = (id *)(v6 + 8);
    while (!*v8 || objc_msgSend(*v8, "peerID") != v3)
    {
      v8 += 8;
      v7 -= 64;
      if (!v7)
        goto LABEL_6;
    }
    v9 = 1;
  }
  else
  {
LABEL_6:
    v9 = 0;
  }
  os_unfair_lock_unlock(v4);
  return v9;
}

void re::ResourceFetchManager::fetchResource(re::AssetPath *this@<X2>, uint64_t a2@<X0>, const char *a3@<X1>, uint64_t a4@<X3>, unsigned int **a5@<X8>)
{
  const char *v10;
  re::AssetPath *v11;
  char *AssetTypeNameFromPath;
  const char *v13;
  re *v14;
  int v15;
  re *v17;
  os_unfair_lock_s *v18;
  re *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  void *v24;
  void *v25;
  NSObject *v26;
  void *v27;
  unsigned int *v28;
  _anonymous_namespace_ *v29;
  _anonymous_namespace_ *v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  re *v35;
  uint64_t *v36;
  uint64_t v37;
  re *v38;
  void *v39;
  re *v40;
  unsigned int *v41;
  _anonymous_namespace_ *v42;
  uint64_t *v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unsigned int *v49;
  uint64_t v50;
  unint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  char *v58;
  _BYTE *v59;
  size_t v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  re::DynamicString *v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t *v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  void *v78;
  uint64_t *v79;
  uint64_t *v80;
  NSObject *v81;
  uint64_t v82;
  unsigned int **v83;
  char v84[8];
  void *v85;
  char v86[8];
  void *v87;
  unsigned int v88[2];
  uint64_t *v89;
  uint64_t v90;
  uint64_t v91;
  void *v92;
  void *__dst;
  uint64_t v94;
  _OWORD v95[2];
  __int128 v96;
  __int128 v97;
  uint64_t v98;
  uint64_t *v99;
  uint64_t v100;
  uint64_t (*v101)(uint64_t, uint64_t);
  void (*v102)(uint64_t);
  const char *v103;
  BOOL v104[8];
  uint64_t v105;
  uint64_t __src;
  _BYTE v107[24];
  uint64_t v108;
  _BYTE *v109;
  uint8_t v110[4];
  _BYTE v111[14];
  __int16 v112;
  uint64_t v113;
  __int16 v114;
  uint64_t v115;
  uint8_t buf[88];
  uint64_t v117;

  v117 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)v88 = 0;
  re::AssetPath::getAssetId(this, (unint64_t *)v88);
  if ((*((_QWORD *)this + 6) & 1) != 0)
    v11 = (re::AssetPath *)*((_QWORD *)this + 7);
  else
    v11 = (re::AssetPath *)((char *)this + 49);
  AssetTypeNameFromPath = re::AssetPath::getAssetTypeNameFromPath(v11, v10);
  re::AssetSignpost::fireImpulse((re::AssetSignpost *)0x80C, v88[0], AssetTypeNameFromPath, v13);
  v14 = (re *)strtoull_l(a3, 0, 10, 0);
  v15 = *(_DWORD *)this;
  if (*(_DWORD *)this != 8 && v15 != 4)
  {
    if (v15)
    {
      v26 = re::resourceSharingLogObjects(v14)[1];
      if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_224FE9000, v26, OS_LOG_TYPE_FAULT, "Only peer asset paths can be fetched from another process", buf, 2u);
      }
      re::makeResourceSharingError((__CFString *)0x1F4, 0, buf);
      v27 = *(void **)buf;
      *(_QWORD *)buf = 0;
      v84[0] = 0;
      v85 = v27;
      (*(void (**)(_QWORD, char *))(**(_QWORD **)(a4 + 32) + 16))(*(_QWORD *)(a4 + 32), v84);
      v25 = v85;
    }
    else
    {
      v23 = re::resourceSharingLogObjects(v14)[1];
      if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_224FE9000, v23, OS_LOG_TYPE_FAULT, "Invalid resource fetch request for empty asset path", buf, 2u);
      }
      re::makeResourceSharingError((__CFString *)0x1F4, 0, buf);
      v24 = *(void **)buf;
      *(_QWORD *)buf = 0;
      v86[0] = 0;
      v87 = v24;
      (*(void (**)(_QWORD, char *))(**(_QWORD **)(a4 + 32) + 16))(*(_QWORD *)(a4 + 32), v86);
      v25 = v87;
    }

    v28 = 0;
    goto LABEL_115;
  }
  v17 = v14;
  v18 = (os_unfair_lock_s *)(a2 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 64));
  v98 = 0;
  v99 = &v98;
  v100 = 0x3812000000;
  v101 = __Block_byref_object_copy_;
  v102 = __Block_byref_object_dispose_;
  v103 = "";
  *(_QWORD *)v104 = 0;
  v20 = *(_QWORD *)(a2 + 88);
  if (v20)
  {
    v21 = *(_QWORD *)(a2 + 104);
    v22 = v20 << 6;
    while (1)
    {
      v19 = *(re **)(v21 + 8);
      if (v19)
      {
        v19 = (re *)-[re peerID](v19, "peerID");
        if (v19 == v17)
          break;
      }
      v21 += 64;
      v22 -= 64;
      if (!v22)
        goto LABEL_107;
    }
    v97 = 0u;
    v96 = 0u;
    v29 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&v96, 0);
    v83 = a5;
    if (*(_DWORD *)this == 4)
    {
      *(_DWORD *)buf = 0;
      memset(&buf[8], 0, 32);
      v30 = (_anonymous_namespace_ *)re::DynamicString::setCapacity(&buf[8], 0);
      memset(&buf[40], 0, 32);
      re::DynamicString::setCapacity(&buf[40], 0);
      *(_QWORD *)&buf[72] = 0;
      if ((*((_QWORD *)this + 6) & 1) != 0)
        v31 = (const char *)*((_QWORD *)this + 7);
      else
        v31 = (char *)this + 49;
      re::AssetPath::initMemoryAssetPath(buf, v31, *((_QWORD *)this + 9));
      v91 = 0;
      v92 = 0;
      v89 = *(uint64_t **)&buf[8];
      v90 = 0;
      re::DynamicString::setCapacity(&v89, 0);
      re::AssetPath::fullAssetPath((re::DynamicString *)buf, (re::DynamicString *)&v89);
      re::DynamicString::operator=((re::DynamicString *)&v96, (re::DynamicString *)&v89);
      if (v89 && (v90 & 1) != 0)
        (*(void (**)(void))(*v89 + 40))();
      if (*(_QWORD *)&buf[40])
      {
        if ((buf[48] & 1) != 0)
          (*(void (**)(void))(**(_QWORD **)&buf[40] + 40))();
        memset(&buf[40], 0, 32);
      }
      v32 = *(_QWORD *)&buf[8];
      if (*(_QWORD *)&buf[8] && (buf[16] & 1) != 0)
      {
        v33 = *(_QWORD *)&buf[24];
LABEL_40:
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v32 + 40))(v32, v33);
      }
    }
    else
    {
      *(_QWORD *)buf = *((_QWORD *)this + 1);
      memset(&buf[8], 0, 24);
      re::DynamicString::setCapacity(buf, 0);
      re::AssetPath::fullAssetPath(this, (re::DynamicString *)buf);
      re::DynamicString::operator=((re::DynamicString *)&v96, (re::DynamicString *)buf);
      v32 = *(_QWORD *)buf;
      if (*(_QWORD *)buf && (buf[8] & 1) != 0)
      {
        v33 = *(_QWORD *)&buf[16];
        goto LABEL_40;
      }
    }
    v34 = *(void **)(v21 + 8);
    re::DynamicString::DynamicString((re::DynamicString *)v95, (const re::DynamicString *)&v96);
    v108 = *(_QWORD *)(a4 + 24);
    v109 = 0;
    re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)v107, a4);
    v35 = v34;
    v36 = re::globalAllocators(v35);
    v37 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v36[2] + 32))(v36[2], 112, 8);
    *(_OWORD *)(v37 + 8) = 0u;
    *(_OWORD *)(v37 + 40) = 0u;
    *(_OWORD *)(v37 + 56) = 0u;
    *(_OWORD *)(v37 + 24) = 0u;
    *(_OWORD *)(v37 + 72) = 0u;
    *(_OWORD *)(v37 + 88) = 0u;
    *(_QWORD *)(v37 + 104) = 0;
    *(_DWORD *)(v37 + 8) = 1;
    *(_QWORD *)v37 = &off_24ED2D5C8;
    *(_OWORD *)(v37 + 48) = 0u;
    *(_OWORD *)(v37 + 16) = 0u;
    *(_OWORD *)(v37 + 32) = 0u;
    v38 = (re *)re::DynamicString::setCapacity((_QWORD *)(v37 + 32), 0);
    *(_QWORD *)(v37 + 88) = re::globalAllocators(v38)[2];
    *(_QWORD *)(v37 + 96) = 0;
    *(_BYTE *)(v37 + 104) = 0;
    v39 = *(void **)(v37 + 24);
    *(_QWORD *)(v37 + 16) = a2;
    *(_QWORD *)(v37 + 24) = v35;
    v40 = v35;

    re::DynamicString::operator=((re::DynamicString *)(v37 + 32), (re::DynamicString *)v95);
    re::FunctionBase<24ul,void ()(void)>::operator=<24ul>(v37 + 64, (uint64_t)v107);

    v41 = (unsigned int *)v99[6];
    v99[6] = v37;
    if (v41)
      re::details::release<re::ResourceRequest>(v41);
    if (v109)
    {
      (**(void (***)(_BYTE *))v109)(v109);
      if (v109 != v107)
        (*(void (**)(uint64_t))(*(_QWORD *)v108 + 40))(v108);
      v109 = 0;
    }
    v42 = *(_anonymous_namespace_ **)&v95[0];
    if (*(_QWORD *)&v95[0])
    {
      if ((BYTE8(v95[0]) & 1) != 0)
        v42 = (_anonymous_namespace_ *)(*(uint64_t (**)(void))(**(_QWORD **)&v95[0] + 40))();
      memset(v95, 0, sizeof(v95));
    }
    v43 = v99;
    v45 = *(_QWORD *)(a2 + 120);
    v44 = *(_QWORD *)(a2 + 128);
    if (v44 >= v45)
    {
      v46 = v44 + 1;
      if (v45 < v44 + 1)
      {
        if (*(_QWORD *)(a2 + 112))
        {
          v47 = 2 * v45;
          if (!v45)
            v47 = 8;
          if (v47 <= v46)
            v48 = v46;
          else
            v48 = v47;
          re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity((_QWORD *)(a2 + 112), v48);
        }
        else
        {
          re::DynamicArray<re::SharedPtr<re::ecs2::Scene>>::setCapacity((_QWORD *)(a2 + 112), v46);
          ++*(_DWORD *)(a2 + 136);
        }
      }
      v44 = *(_QWORD *)(a2 + 128);
    }
    v49 = (unsigned int *)v43[6];
    *(_QWORD *)(*(_QWORD *)(a2 + 144) + 8 * v44) = v49;
    if (v49)
    {
      re::details::retain<re::ResourceFetchManager::Request>(v49);
      v44 = *(_QWORD *)(a2 + 128);
    }
    *(_QWORD *)(a2 + 128) = v44 + 1;
    ++*(_DWORD *)(a2 + 136);
    v50 = v99[6] + 32;
    v51 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, v50);
    v52 = (_QWORD *)(v21 + 16);
    if (*(_QWORD *)(v21 + 16))
    {
      v53 = *(unsigned int *)(*(_QWORD *)(v21 + 24) + 4 * (v51 % *(unsigned int *)(v21 + 40)));
      if ((_DWORD)v53 != 0x7FFFFFFF)
      {
        v54 = *(_QWORD *)(v21 + 32);
        while (1)
        {
          v51 = re::DynamicString::operator==(v54 + 88 * v53 + 16, v50);
          if ((v51 & 1) != 0)
            break;
          v53 = *(_DWORD *)(v54 + 88 * v53 + 8) & 0x7FFFFFFF;
          if (v53 == 0x7FFFFFFF)
            goto LABEL_69;
        }
        v61 = v99[6] + 32;
        v62 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, v61);
        if (*v52)
        {
          v63 = *(_QWORD *)(v21 + 32);
          v64 = *(unsigned int *)(*(_QWORD *)(v21 + 24) + 4 * (v62 % *(unsigned int *)(v21 + 40)));
          if ((_DWORD)v64 != 0x7FFFFFFF)
          {
            while (!re::DynamicString::operator==(v63 + 88 * v64 + 16, v61))
            {
              v64 = *(_DWORD *)(v63 + 88 * v64 + 8) & 0x7FFFFFFF;
              if (v64 == 0x7FFFFFFF)
                goto LABEL_93;
            }
            goto LABEL_94;
          }
        }
        else
        {
          v63 = *(_QWORD *)(v21 + 32);
        }
LABEL_93:
        v64 = 0x7FFFFFFFLL;
LABEL_94:
        v71 = v99[6];
        v72 = v63 + 88 * v64;
        v75 = *(_QWORD *)(v72 + 64);
        v74 = (uint64_t *)(v72 + 64);
        v73 = v75;
        if (v75 >= *(v74 - 1))
        {
          re::DynamicArray<float *>::growCapacity((_QWORD *)(v63 + 88 * v64 + 48), v73 + 1);
          v73 = *v74;
        }
        v76 = v63 + 88 * v64;
        *(_QWORD *)(*(_QWORD *)(v76 + 80) + 8 * v73) = v71;
        *v74 = v73 + 1;
        ++*(_DWORD *)(v76 + 72);
        goto LABEL_97;
      }
    }
LABEL_69:
    v55 = v99[6];
    __src = v55;
    __dst = 0;
    v90 = 0;
    v91 = 0;
    LODWORD(v92) = 0;
    re::DynamicArray<float *>::setCapacity(&v89, 1uLL);
    v56 = (_DWORD)v92 + 1;
    LODWORD(v92) = (_DWORD)v92 + 1;
    if (v91)
    {
      if (v91 == -1)
      {
        v105 = 0;
        memset(buf, 0, 80);
        os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
        *(_DWORD *)v110 = 136315906;
        *(_QWORD *)v111 = "copy";
        *(_WORD *)&v111[8] = 1024;
        *(_DWORD *)&v111[10] = 643;
        v112 = 2048;
        v113 = 0;
        v114 = 2048;
        v115 = 0;
        _os_log_send_and_compose_impl();
        _os_crash_msg();
        __break(1u);
      }
      *(_QWORD *)__dst = v55;
    }
    else
    {
      re::DynamicArray<float *>::growCapacity(&v89, 1uLL);
      v57 = v91;
      v58 = (char *)__dst;
      v59 = &v107[8 * v91 - 8];
      if (v91)
      {
        memcpy(__dst, &__src, 8 * v91);
        v60 = 8 - 8 * v57;
      }
      else
      {
        v60 = 8;
      }
      memcpy(&v58[8 * v57], v59, v60);
      v91 = 1;
      v56 = (int)v92;
    }
    v65 = (re::DynamicString *)(v55 + 32);
    LODWORD(v92) = v56 + 1;
    v66 = re::Hash<re::DynamicString>::operator()((uint64_t)buf, v55 + 32);
    v67 = v66;
    if (*v52)
    {
      v68 = v66 % *(unsigned int *)(v21 + 40);
      v69 = *(unsigned int *)(*(_QWORD *)(v21 + 24) + 4 * v68);
      if ((_DWORD)v69 != 0x7FFFFFFF)
      {
        v70 = *(_QWORD *)(v21 + 32);
        while (!re::DynamicString::operator==(v70 + 88 * v69 + 16, (uint64_t)v65))
        {
          v69 = *(_DWORD *)(v70 + 88 * v69 + 8) & 0x7FFFFFFF;
          if (v69 == 0x7FFFFFFF)
          {
            v52 = (_QWORD *)(v21 + 16);
            goto LABEL_88;
          }
        }
        goto LABEL_89;
      }
    }
    else
    {
      LODWORD(v68) = 0;
    }
LABEL_88:
    re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::addAsMove((uint64_t)v52, v68, v67, v65, (uint64_t)&v89);
    ++*(_DWORD *)(v21 + 56);
LABEL_89:
    if (v89 && __dst)
      (*(void (**)(void))(*v89 + 40))();
LABEL_97:
    a5 = v83;
    if ((BYTE8(v96) & 1) != 0)
      v77 = v97;
    else
      v77 = (unint64_t)&v96 | 9;
    objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v77);
    v78 = (void *)objc_claimAutoreleasedReturnValue();
    v79 = (uint64_t *)MEMORY[0x24BDAC760];
    *(_QWORD *)buf = MEMORY[0x24BDAC760];
    *(_QWORD *)&buf[8] = 3321888768;
    *(_QWORD *)&buf[16] = ___ZZN2re20ResourceFetchManager13fetchResourceEPKcRKNS_9AssetPathENS_8FunctionIFvNS_6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEEEEEENK3__0clERNS0_14SharedXPCStateE_block_invoke;
    *(_QWORD *)&buf[24] = &unk_24ED2D638;
    *(_QWORD *)&buf[40] = a2;
    re::DynamicString::DynamicString((re::DynamicString *)&buf[48], (const re::DynamicString *)&v96);
    *(_QWORD *)&buf[32] = &v98;
    re::xpc::Connection::remoteObjectProxyWithErrorHandler((id *)v21, (uint64_t)buf, &v89);
    v80 = v89;

    v89 = v79;
    v90 = 3221225472;
    v91 = (uint64_t)___ZZN2re20ResourceFetchManager13fetchResourceEPKcRKNS_9AssetPathENS_8FunctionIFvNS_6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEEEEEENK3__0clERNS0_14SharedXPCStateE_block_invoke_159;
    v92 = &unk_24ED2D670;
    __dst = &v98;
    v94 = a2;
    objc_msgSend(v80, "fetchResourceAtAssetPath:withReply:", v78, &v89);

    v18 = (os_unfair_lock_s *)(a2 + 64);
    if (*(_QWORD *)&buf[48])
    {
      if ((buf[56] & 1) != 0)
        (*(void (**)(void))(**(_QWORD **)&buf[48] + 40))();
      memset(&buf[48], 0, 32);
    }

    v19 = (re *)v96;
    if ((_QWORD)v96 && (BYTE8(v96) & 1) != 0)
      v19 = (re *)(*(uint64_t (**)(void))(*(_QWORD *)v96 + 40))();
  }
LABEL_107:
  v28 = (unsigned int *)v99[6];
  if (v28)
    goto LABEL_111;
  v81 = re::resourceSharingLogObjects(v19)[1];
  if (os_log_type_enabled(v81, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)v110 = 134217984;
    *(_QWORD *)v111 = v17;
    _os_log_fault_impl(&dword_224FE9000, v81, OS_LOG_TYPE_FAULT, "No resource fetch connection exists for peer '%llu'", v110, 0xCu);
  }
  re::makeResourceSharingError((__CFString *)0x1F4, 0, &v96);
  v82 = v96;
  *(_QWORD *)&v96 = 0;
  v110[0] = 0;
  *(_QWORD *)&v111[4] = v82;
  (*(void (**)(_QWORD, uint8_t *))(**(_QWORD **)(a4 + 32) + 16))(*(_QWORD *)(a4 + 32), v110);

  v28 = (unsigned int *)v99[6];
  if (v28)
LABEL_111:
    re::details::retain<re::ResourceFetchManager::Request>(v28);
  _Block_object_dispose(&v98, 8);
  if (*(_QWORD *)v104)
    re::details::release<re::ResourceRequest>(*(unsigned int **)v104);
  os_unfair_lock_unlock(v18);
LABEL_115:
  *a5 = v28;
}

void re::ResourceFetchManager::setRequestOptions(uint64_t a1, uint64_t a2, void **a3)
{
  os_unfair_lock_s *v6;
  re *v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  void *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  id v21;
  void *v22;
  const char *v23;
  NSObject *v24;
  uint32_t v25;
  int v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v6 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  if (*(_QWORD *)(a2 + 16))
  {
    if (*(_BYTE *)(a2 + 104))
    {
      v8 = re::resourceSharingLogObjects(v7)[1];
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        if ((*(_BYTE *)(a2 + 40) & 1) != 0)
          v9 = *(_QWORD *)(a2 + 48);
        else
          v9 = a2 + 41;
        v26 = 136315138;
        v27 = v9;
        v23 = "Resource request for '%s' is cancelled, ignoring set-options request";
        v24 = v8;
        v25 = 12;
LABEL_23:
        _os_log_debug_impl(&dword_224FE9000, v24, OS_LOG_TYPE_DEBUG, v23, (uint8_t *)&v26, v25);
      }
    }
    else
    {
      v13 = *(_QWORD *)(a1 + 88);
      if (v13)
      {
        v7 = *(re **)(a1 + 104);
        v14 = v13 << 6;
        while (*((_QWORD *)v7 + 1) != *(_QWORD *)(a2 + 24))
        {
          v7 = (re *)((char *)v7 + 64);
          v14 -= 64;
          if (!v14)
            goto LABEL_13;
        }
        re::ResourceFetchManager::Connection::remoteObjectProxy((id *)v7);
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        v18 = *a3;
        v19 = (void *)MEMORY[0x24BDD17C8];
        if ((*(_BYTE *)(a2 + 40) & 1) != 0)
          v20 = *(_QWORD *)(a2 + 48);
        else
          v20 = a2 + 41;
        v21 = v18;
        objc_msgSend(v19, "stringWithUTF8String:", v20);
        v22 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v17, "setSubscriptionOptions:forResourceAtAssetPath:", v21, v22);

      }
      else
      {
LABEL_13:
        v15 = re::resourceSharingLogObjects(v7)[1];
        if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
        {
          v16 = *(_QWORD *)(a2 + 24);
          v26 = 138412290;
          v27 = v16;
          _os_log_fault_impl(&dword_224FE9000, v15, OS_LOG_TYPE_FAULT, "No resource fetch connection exists for client %@", (uint8_t *)&v26, 0xCu);
        }
      }
    }
  }
  else
  {
    v10 = re::resourceSharingLogObjects(v7)[1];
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      v11 = *(_QWORD *)(a2 + 24);
      if ((*(_BYTE *)(a2 + 40) & 1) != 0)
        v12 = *(_QWORD *)(a2 + 48);
      else
        v12 = a2 + 41;
      v26 = 138412546;
      v27 = v11;
      v28 = 2080;
      v29 = v12;
      v23 = "Resource connection %@ is closed, ignoring set-options request for '%s'";
      v24 = v10;
      v25 = 22;
      goto LABEL_23;
    }
  }
  os_unfair_lock_unlock(v6);
}

void re::ResourceFetchManager::cancelRequest(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  re *v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  unint64_t v24;
  NSObject *v25;
  unint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  const char *v30;
  NSObject *v31;
  uint32_t v32;
  void *v33;
  uint64_t v34;
  _OWORD buf[5];
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v4 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  if (*(_QWORD *)(a2 + 16))
  {
    if (!*(_BYTE *)(a2 + 104))
    {
      *(_BYTE *)(a2 + 104) = 1;
      v11 = *(_QWORD *)(a1 + 88);
      if (v11)
      {
        v12 = *(_QWORD *)(a1 + 104) + 16;
        v13 = v11 << 6;
        while (*(_QWORD *)(v12 - 8) != *(_QWORD *)(a2 + 24))
        {
          v12 += 64;
          v13 -= 64;
          if (!v13)
            goto LABEL_13;
        }
        v17 = a2 + 32;
        v18 = re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet(v12, a2 + 32);
        if (v18)
        {
          v19 = v18;
          v20 = *(_QWORD **)(v18 + 32);
          v21 = *(_QWORD *)(v18 + 16);
          v22 = v20;
          if (v21)
          {
            v23 = 8 * v21;
            v22 = *(_QWORD **)(v18 + 32);
            while (*v22 != a2)
            {
              ++v22;
              v23 -= 8;
              if (!v23)
              {
                v22 = &v20[v21];
                break;
              }
            }
          }
          v24 = v22 - v20;
          if (v24 == v21)
          {
            v25 = re::resourceSharingLogObjects((re *)v18)[1];
            if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
            {
              if ((*(_BYTE *)(a2 + 40) & 1) != 0)
                v34 = *(_QWORD *)(a2 + 48);
              else
                v34 = a2 + 41;
              LODWORD(buf[0]) = 134218242;
              *(_QWORD *)((char *)buf + 4) = a2;
              WORD6(buf[0]) = 2080;
              *(_QWORD *)((char *)buf + 14) = v34;
              _os_log_fault_impl(&dword_224FE9000, v25, OS_LOG_TYPE_FAULT, "Request %p for '%s' is not registered with the resource fetch manager", (uint8_t *)buf, 0x16u);
            }
            v26 = *(_QWORD *)(v19 + 16);
          }
          else
          {
            if (v21 <= v24)
            {
              memset(buf, 0, sizeof(buf));
              os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
              _os_log_send_and_compose_impl();
              _os_crash_msg();
              __break(1u);
            }
            v26 = v21 - 1;
            if (v21 - 1 > v24)
              v20[v24] = v20[v21 - 1];
            *(_QWORD *)(v18 + 16) = v26;
            ++*(_DWORD *)(v18 + 24);
          }
          if (!v26)
          {
            re::ResourceFetchManager::Connection::remoteObjectProxy((id *)(v12 - 16));
            v28 = (void *)objc_claimAutoreleasedReturnValue();
            if ((*(_BYTE *)(a2 + 40) & 1) != 0)
              v29 = *(_QWORD *)(a2 + 48);
            else
              v29 = a2 + 41;
            objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v29);
            v33 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v28, "unsubscribeFromResourceAtAssetPath:", v33);

            re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::remove(v12, v17);
          }
          goto LABEL_42;
        }
        v14 = re::resourceSharingLogObjects(0)[1];
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
          goto LABEL_42;
        if ((*(_BYTE *)(a2 + 40) & 1) != 0)
          v27 = *(_QWORD *)(a2 + 48);
        else
          v27 = a2 + 41;
        LODWORD(buf[0]) = 136315138;
        *(_QWORD *)((char *)buf + 4) = v27;
        v16 = "No request for '%s' is registered with the resource fetch manager";
      }
      else
      {
LABEL_13:
        v14 = re::resourceSharingLogObjects(v5)[1];
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
          goto LABEL_42;
        v15 = *(_QWORD *)(a2 + 24);
        LODWORD(buf[0]) = 138412290;
        *(_QWORD *)((char *)buf + 4) = v15;
        v16 = "No resource fetch connection exists for client %@";
      }
      _os_log_fault_impl(&dword_224FE9000, v14, OS_LOG_TYPE_FAULT, v16, (uint8_t *)buf, 0xCu);
      goto LABEL_42;
    }
    v6 = re::resourceSharingLogObjects(v5)[1];
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      if ((*(_BYTE *)(a2 + 40) & 1) != 0)
        v7 = *(_QWORD *)(a2 + 48);
      else
        v7 = a2 + 41;
      LODWORD(buf[0]) = 136315138;
      *(_QWORD *)((char *)buf + 4) = v7;
      v30 = "Resource request for '%s' was already cancelled";
      v31 = v6;
      v32 = 12;
LABEL_39:
      _os_log_debug_impl(&dword_224FE9000, v31, OS_LOG_TYPE_DEBUG, v30, (uint8_t *)buf, v32);
    }
  }
  else
  {
    v8 = re::resourceSharingLogObjects(v5)[1];
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      v9 = *(_QWORD *)(a2 + 24);
      if ((*(_BYTE *)(a2 + 40) & 1) != 0)
        v10 = *(_QWORD *)(a2 + 48);
      else
        v10 = a2 + 41;
      LODWORD(buf[0]) = 138412546;
      *(_QWORD *)((char *)buf + 4) = v9;
      WORD6(buf[0]) = 2080;
      *(_QWORD *)((char *)buf + 14) = v10;
      v30 = "Resource connection %@ is closed, ignoring cancellation of request for '%s'";
      v31 = v8;
      v32 = 22;
      goto LABEL_39;
    }
  }
LABEL_42:
  os_unfair_lock_unlock(v4);
}

void re::ResourceFetchManager::executeWithMostRecentTransportVoucher(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  id v5;
  id v6;
  id v7;
  id v8;

  v4 = (os_unfair_lock_s *)(a1 + 192);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 192));
  v8 = *(id *)(a1 + 200);
  os_unfair_lock_unlock(v4);
  if (v8)
  {
    v5 = v8;
    v6 = (id)voucher_adopt();

    (*(void (**)(_QWORD))(**(_QWORD **)(a2 + 32) + 16))(*(_QWORD *)(a2 + 32));
    v7 = v6;

  }
  else
  {
    (*(void (**)(_QWORD))(**(_QWORD **)(a2 + 32) + 16))(*(_QWORD *)(a2 + 32));
  }

}

void re::ResourceFetchManager::executeWithMostRecentTransportVoucherForPeerID(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  id *v8;
  uint64_t v9;
  void *v10;
  id v11;
  id v12;
  id v13;
  id v14;

  v6 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  v7 = *(_QWORD *)(a1 + 88);
  if (v7)
  {
    v8 = (id *)(*(_QWORD *)(a1 + 104) + 8);
    v9 = v7 << 6;
    while (!*v8 || objc_msgSend(*v8, "peerID") != a2)
    {
      v8 += 8;
      v9 -= 64;
      if (!v9)
        goto LABEL_6;
    }
    objc_msgSend(*v8, "voucher");
    v11 = (id)objc_claimAutoreleasedReturnValue();

    os_unfair_lock_unlock(v6);
    if (v11)
    {
      v14 = v11;
      v12 = (id)voucher_adopt();

      (*(void (**)(_QWORD))(**(_QWORD **)(a3 + 32) + 16))(*(_QWORD *)(a3 + 32));
      v13 = v12;

      v10 = v14;
      goto LABEL_8;
    }
  }
  else
  {
LABEL_6:
    os_unfair_lock_unlock(v6);
  }
  (*(void (**)(_QWORD))(**(_QWORD **)(a3 + 32) + 16))(*(_QWORD *)(a3 + 32));
  v10 = 0;
LABEL_8:

}

void re::ResourceFetchManager::setPushLoadHandler(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  id v5;

  v2 = *a2;
  v3 = *(_QWORD *)(a1 + 256);
  if (v3 != *a2)
  {
    if (v2)
    {
      v5 = (id)(v2 + 8);
      v3 = *(_QWORD *)(a1 + 256);
    }
    if (v3)

    *(_QWORD *)(a1 + 256) = v2;
  }
}

void re::ResourceFetchManager::reportLoadState(os_unfair_lock_s *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  os_unfair_lock_s *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  re *v17;
  NSObject *v18;
  void *v19;
  int v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  v12 = this + 16;
  os_unfair_lock_lock(this + 16);
  v13 = *(_QWORD *)&this[22]._os_unfair_lock_opaque;
  if (v13)
  {
    v14 = *(_QWORD *)&this[26]._os_unfair_lock_opaque;
    v15 = v13 << 6;
    while (1)
    {
      v16 = *(void **)(v14 + 8);
      if (v16)
      {
        if (objc_msgSend(v16, "peerID") == a3)
          break;
      }
      v14 += 64;
      v15 -= 64;
      if (!v15)
        goto LABEL_6;
    }
    re::ResourceFetchManager::Connection::remoteObjectProxy((id *)v14);
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v19, "reportLoadState:forAssetId:assetSize:errorCode:", a4, a2, a5, a6);

    os_unfair_lock_unlock(v12);
  }
  else
  {
LABEL_6:
    os_unfair_lock_unlock(v12);
    v18 = re::resourceSharingLogObjects(v17)[1];
    if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
    {
      v20 = 134218240;
      v21 = a3;
      v22 = 2048;
      v23 = a2;
      _os_log_fault_impl(&dword_224FE9000, v18, OS_LOG_TYPE_FAULT, "No resource fetch connection exists for peer '%llu'. Cannot report load state for asset '%llu'.", (uint8_t *)&v20, 0x16u);
    }
  }
}

void ___ZN2re20ResourceFetchManager13addConnectionENS_3xpc10ConnectionE_block_invoke(id *a1)
{
  NSObject *v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  id v6;
  id v7;
  uint8_t buf[4];
  id v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = re::resourceSharingLogObjects((re *)a1)[1];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = a1[4];
    *(_DWORD *)buf = 138412290;
    v9 = v3;
    _os_log_impl(&dword_224FE9000, v2, OS_LOG_TYPE_DEFAULT, "Resource connection with client %@ was interrupted", buf, 0xCu);
  }
  v4 = objc_msgSend(a1[4], "resourceFetchManager");
  if (v4)
  {
    v5 = v4;
    v6 = a1[4];
    v7 = v6;
    re::ResourceFetchManager::connectionInterruptedOrInvalidated(v5, &v7);

  }
}

void re::ResourceFetchManager::connectionInterruptedOrInvalidated(uint64_t a1, id *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  id v8;
  int v9;
  id v10;
  void *v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  os_unfair_lock_s *v15;
  re *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  id v23;
  id v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  id v42;
  id v43;
  re::PeerIDValidator *v44;
  __int128 *v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  void *v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  unint64_t v61;
  uint64_t v62;
  unint64_t v63;
  _DWORD *v64;
  unint64_t *v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unsigned int v69;
  unsigned int v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  void **v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  unint64_t *v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  re *v86;
  NSObject *v87;
  id v88;
  id v89;
  NSObject *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  _DWORD *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  unint64_t v98;
  _OWORD v99[2];
  uint64_t v100;
  int v101;
  const char *v102;
  __int16 v103;
  int v104;
  __int16 v105;
  unint64_t v106;
  __int16 v107;
  unint64_t v108;
  uint8_t buf[16];
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  uint64_t v114;

  v114 = *MEMORY[0x24BDAC8D0];
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  v4 = *(_QWORD *)(a1 + 272);
  v5 = *(_QWORD *)(v4 + 120);
  if (v5)
  {
    v6 = 48 * v5;
    v7 = (uint64_t *)(*(_QWORD *)(v4 + 136) + 40);
    do
    {
      v8 = *a2;
      v9 = objc_msgSend(v8, "pid");
      v10 = *a2;
      v11 = v10;
      if (v10)
        objc_msgSend(v10, "auditToken");
      else
        memset(v99, 0, sizeof(v99));
      v12 = *a2;
      v13 = objc_msgSend(v12, "peerID");
      v101 = v9;
      *(_QWORD *)buf = v13;
      v14 = *v7;
      v7 += 6;
      (*(void (**)(uint64_t, int *, _OWORD *, uint8_t *))(*(_QWORD *)v14 + 16))(v14, &v101, v99, buf);

      v6 -= 48;
    }
    while (v6);
  }
  v15 = (os_unfair_lock_s *)(a1 + 64);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
  v17 = *(_QWORD *)(a1 + 88);
  if (!v17)
  {
LABEL_11:
    v22 = re::resourceSharingLogObjects(v16)[1];
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      v23 = *a2;
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v23;
      v24 = v23;
      v25 = v22;
      _os_log_debug_impl(&dword_224FE9000, v25, OS_LOG_TYPE_DEBUG, "Resource fetch connection with client %@ interrupted/invalidated: not found in connection list", buf, 0xCu);

    }
    goto LABEL_72;
  }
  v18 = 0;
  v19 = *(_QWORD *)(a1 + 104);
  v20 = 32;
  while (1)
  {
    v21 = v19 + v20;
    if (*(id *)(v19 + v20 - 24) == *a2)
      break;
    ++v18;
    v20 += 64;
    if (v17 == v18)
      goto LABEL_11;
  }
  v26 = v21 - 16;
  v27 = *(unsigned int *)(v21 + 16);
  if ((_DWORD)v27)
  {
    v28 = 0;
    v29 = (int *)(*(_QWORD *)(v19 + v20) + 8);
    while (1)
    {
      v30 = *v29;
      v29 += 22;
      if (v30 < 0)
        break;
      if (v27 == ++v28)
      {
        LODWORD(v28) = v27;
        break;
      }
    }
  }
  else
  {
    LODWORD(v28) = 0;
  }
  if ((_DWORD)v27 != (_DWORD)v28)
  {
    v31 = v28;
    do
    {
      v32 = *(_QWORD *)(v19 + v20) + 88 * v31;
      v33 = *(_QWORD *)(v32 + 64);
      if (v33)
      {
        v34 = *(uint64_t **)(v32 + 80);
        v35 = 8 * v33;
        do
        {
          v36 = *v34++;
          *(_QWORD *)(v36 + 16) = 0;
          v35 -= 8;
        }
        while (v35);
      }
      if (v27 <= (int)v28 + 1)
        v37 = v28 + 1;
      else
        v37 = v27;
      while (1)
      {
        v31 = (v28 + 1);
        if (v37 - 1 == (_DWORD)v28)
          break;
        LODWORD(v28) = v28 + 1;
        v38 = v31;
        if ((*(_DWORD *)(*(_QWORD *)(v19 + v20) + 88 * v31 + 8) & 0x80000000) != 0)
          goto LABEL_31;
      }
      v38 = v37;
LABEL_31:
      LODWORD(v28) = v38;
    }
    while ((_DWORD)v27 != v38);
  }
  re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear(v26);
  v39 = *(_QWORD *)(a1 + 264);
  if (v39)
  {
    v40 = re::directMeshConnectionId(a2);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v39 + 40))(v39, v40);
  }
  v41 = *(_QWORD *)(a1 + 256);
  if (v41)
  {
    v42 = (id)(v41 + 8);
    v43 = *a2;
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v41 + 48))(v41, objc_msgSend(v43, "peerID"));

  }
  v44 = (re::PeerIDValidator *)objc_msgSend(*a2, "peerID");
  v45 = re::PeerIDValidator::instance(v44);
  re::PeerIDValidator::remove_impl((re::PeerIDValidator *)v45, (unint64_t)v44);
  v46 = *(_QWORD *)(a1 + 88);
  if (v46 <= v18)
  {
    v100 = 0;
    v112 = 0u;
    v113 = 0u;
    v110 = 0u;
    v111 = 0u;
    *(_OWORD *)buf = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v101 = 136315906;
    v102 = "operator[]";
    v103 = 1024;
    v104 = 789;
    v105 = 2048;
    v106 = v18;
    v107 = 2048;
    v108 = v46;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
    goto LABEL_76;
  }
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 104) + v20 - 32), "invalidate");
  v46 = *(_QWORD *)(a1 + 88);
  if (v46 <= v18)
  {
LABEL_76:
    v100 = 0;
    v112 = 0u;
    v113 = 0u;
    v110 = 0u;
    v111 = 0u;
    *(_OWORD *)buf = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v101 = 136315906;
    v102 = "operator[]";
    v103 = 1024;
    v104 = 789;
    v105 = 2048;
    v106 = v18;
    v107 = 2048;
    v108 = v46;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
LABEL_77:
    v100 = 0;
    v112 = 0u;
    v113 = 0u;
    v110 = 0u;
    v111 = 0u;
    *(_OWORD *)buf = 0u;
    os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
    v101 = 136315906;
    v102 = "removeAt";
    v103 = 1024;
    v104 = 931;
    v105 = 2048;
    v106 = v18;
    v107 = 2048;
    v108 = v46;
    _os_log_send_and_compose_impl();
    _os_crash_msg();
    __break(1u);
  }
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 104) + v20 - 24), "invalidate");
  v46 = *(_QWORD *)(a1 + 88);
  if (v46 <= v18)
    goto LABEL_77;
  if (v46 - 1 > v18)
  {
    v96 = v41;
    v47 = *(_QWORD *)(a1 + 104);
    v48 = v47 + (v46 << 6);
    v49 = v47 + v20;
    v50 = v20 - (v46 << 6);
    if (v50 != -32)
    {
      v51 = *(_QWORD *)(v48 - 64);
      *(_QWORD *)(v48 - 64) = 0;
      v52 = *(void **)(v49 - 32);
      *(_QWORD *)(v49 - 32) = v51;

    }
    v53 = *(_QWORD *)(v48 - 56);
    *(_QWORD *)(v48 - 56) = 0;
    v54 = *(void **)(v49 - 24);
    *(_QWORD *)(v49 - 24) = v53;

    if (v50 != -32)
    {
      v55 = (uint64_t *)(v48 - 48);
      v58 = *(_QWORD *)(v49 - 16);
      v57 = (uint64_t *)(v49 - 16);
      v56 = v58;
      if (!v58 || (v59 = *v55, v56 == *v55))
      {
        re::HashSetBase<re::RigGraphSystem::BuildTask *,re::RigGraphSystem::BuildTask *,re::internal::ValueAsKey<re::RigGraphSystem::BuildTask *>,re::Hash<re::RigGraphSystem::BuildTask *>,re::EqualTo<re::RigGraphSystem::BuildTask *>,true,false>::swap(v57, v55);
      }
      else
      {
        re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::clear((uint64_t)v57);
        if (v59)
        {
          v95 = v47 + v20;
          v60 = *(_DWORD *)(v48 - 20);
          if (*(_DWORD *)(v47 + v20 + 8) < v60)
            re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity((uint64_t)v57, v60);
          v91 = (uint64_t)v57;
          v61 = *(unsigned int *)(v48 - 16);
          if ((_DWORD)v61)
          {
            v62 = 0;
            v63 = 0;
            v64 = (_DWORD *)(v47 + v20);
            v94 = (_DWORD *)(v47 + v20);
            v92 = v48;
            v93 = v47;
            do
            {
              v65 = (unint64_t *)(*(_QWORD *)(v48 - 32) + v62);
              if ((v65[1] & 0x80000000) != 0)
              {
                v97 = *(_QWORD *)(v48 - 32);
                v66 = *v65;
                v67 = *(unsigned int *)(v95 + 8);
                v68 = *v65 % v67;
                v69 = v64[5];
                if (v69 == 0x7FFFFFFF)
                {
                  v69 = v64[4];
                  v70 = v69;
                  if (v69 == (_DWORD)v67)
                  {
                    re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::setCapacity(v91, 2 * v64[3]);
                    v64 = v94;
                    v68 = v66 % *(unsigned int *)(v95 + 8);
                    v70 = v94[4];
                  }
                  v64[4] = v70 + 1;
                  v71 = *(_QWORD *)(v47 + v20);
                  v72 = *(_DWORD *)(v71 + 88 * v69 + 8);
                }
                else
                {
                  v71 = *(_QWORD *)(v47 + v20);
                  v72 = *(_DWORD *)(v71 + 88 * v69 + 8);
                  v64[5] = v72 & 0x7FFFFFFF;
                }
                *(_DWORD *)(v71 + 88 * v69 + 8) = v72 | 0x80000000;
                v98 = v68;
                v73 = *(_QWORD *)(v47 + v20) + 88 * v69;
                *(_DWORD *)(v73 + 8) = *(_DWORD *)(v73 + 8) & 0x80000000 | *(_DWORD *)(*((_QWORD *)v64 - 1) + 4 * v68);
                *(_QWORD *)(*(_QWORD *)(v47 + v20) + 88 * v69) = v66;
                re::DynamicString::DynamicString((re::DynamicString *)(*(_QWORD *)(v47 + v20) + 88 * v69 + 16), (const re::DynamicString *)(v65 + 2));
                v74 = *(_QWORD *)(v47 + v20);
                v75 = v74 + 88 * v69;
                *(_QWORD *)(v75 + 48) = 0;
                v76 = v75 + 48;
                *(_QWORD *)(v76 + 32) = 0;
                v77 = (void **)(v76 + 32);
                *(_QWORD *)(v76 + 8) = 0;
                *(_QWORD *)(v76 + 16) = 0;
                *(_DWORD *)(v76 + 24) = 0;
                v78 = v65[6];
                if (v78)
                {
                  v79 = v74 + 88 * v69;
                  v80 = *(_QWORD *)(v97 + v62 + 64);
                  *(_QWORD *)v76 = v78;
                  re::DynamicArray<float *>::setCapacity((_QWORD *)v76, v80);
                  v82 = *(_QWORD *)(v79 + 64);
                  v81 = (unint64_t *)(v79 + 64);
                  ++*((_DWORD *)v81 + 2);
                  v83 = *(_QWORD *)(v97 + v62 + 64);
                  if (v83 >= v82)
                  {
                    re::DynamicArray<float *>::setCapacity((_QWORD *)v76, v83);
                    v84 = *v81;
                    if (*v81)
                    {
                      memmove(*v77, *(const void **)(v97 + v62 + 80), 8 * v84);
                      v84 = *v81;
                    }
                    memcpy((char *)*v77 + 8 * v84, (const void *)(*(_QWORD *)(v97 + v62 + 80) + 8 * v84), 8 * v83 - 8 * v84);
                  }
                  else if (v83)
                  {
                    memmove(*v77, *(const void **)(v97 + v62 + 80), 8 * v83);
                  }
                  *v81 = v83;
                }
                v15 = (os_unfair_lock_s *)(a1 + 64);
                v64 = v94;
                *(_DWORD *)(*((_QWORD *)v94 - 1) + 4 * v98) = v69;
                ++v94[3];
                v48 = v92;
                v47 = v93;
                v61 = *(unsigned int *)(v92 - 16);
              }
              ++v63;
              v62 += 88;
            }
            while (v63 < v61);
          }
          ++*(_DWORD *)(v47 + v20 + 24);
        }
      }
    }
    v46 = *(_QWORD *)(a1 + 88);
    v41 = v96;
  }
  v85 = *(_QWORD *)(a1 + 104) + (v46 << 6);
  re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::deinit((uint64_t *)(v85 - 48));

  --*(_QWORD *)(a1 + 88);
  ++*(_DWORD *)(a1 + 96);
  v87 = re::resourceSharingLogObjects(v86)[1];
  if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
  {
    v88 = *a2;
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)&buf[4] = v88;
    v89 = v88;
    v90 = v87;
    _os_log_debug_impl(&dword_224FE9000, v90, OS_LOG_TYPE_DEBUG, "Resource fetch connection with client %@ interrupted/invalidated: removed from connection list", buf, 0xCu);

    if (!v41)
      goto LABEL_72;
    goto LABEL_71;
  }
  if (v41)
LABEL_71:

LABEL_72:
  os_unfair_lock_unlock(v15);
}

void ___ZN2re20ResourceFetchManager13addConnectionENS_3xpc10ConnectionE_block_invoke_66(id *a1)
{
  NSObject *v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  id v6;
  id v7;
  uint8_t buf[4];
  id v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  v2 = re::resourceSharingLogObjects((re *)a1)[1];
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = a1[4];
    *(_DWORD *)buf = 138412290;
    v9 = v3;
    _os_log_impl(&dword_224FE9000, v2, OS_LOG_TYPE_DEFAULT, "Resource connection with client %@ was invalidated", buf, 0xCu);
  }
  v4 = objc_msgSend(a1[4], "resourceFetchManager");
  if (v4)
  {
    v5 = v4;
    v6 = a1[4];
    v7 = v6;
    re::ResourceFetchManager::connectionInterruptedOrInvalidated(v5, &v7);

  }
}

void re::ResourceFetchManager::connectedPeers(os_unfair_lock_s *this@<X0>, uint64_t a2@<X8>)
{
  os_unfair_lock_s *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  id *v9;
  uint64_t v10;

  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)a2 = 0;
  v4 = this + 16;
  *(_DWORD *)(a2 + 24) = 0;
  os_unfair_lock_lock(this + 16);
  v5 = *(_QWORD *)&this[22]._os_unfair_lock_opaque;
  if (v5)
  {
    re::DynamicArray<float *>::setCapacity((_QWORD *)a2, v5);
    v6 = *(_QWORD *)&this[22]._os_unfair_lock_opaque;
    if (v6)
    {
      v7 = *(_QWORD *)&this[26]._os_unfair_lock_opaque;
      v8 = v6 << 6;
      v9 = (id *)(v7 + 8);
      do
      {
        if (*v9 && objc_msgSend(*v9, "peerID"))
        {
          v10 = objc_msgSend(*v9, "peerID");
          re::DynamicArray<re::TransitionCondition *>::add((_QWORD *)a2, &v10);
        }
        v9 += 8;
        v8 -= 64;
      }
      while (v8);
    }
  }
  os_unfair_lock_unlock(v4);
}

void re::ResourceFetchManager::assetPathsFetchedFromPeerId(os_unfair_lock_s *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;

  *(_QWORD *)(a3 + 32) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)a3 = 0;
  v6 = this + 16;
  *(_DWORD *)(a3 + 24) = 0;
  os_unfair_lock_lock(this + 16);
  v7 = *(_QWORD *)&this[22]._os_unfair_lock_opaque;
  if (v7)
  {
    v8 = *(_QWORD *)&this[26]._os_unfair_lock_opaque;
    v9 = v8 + (v7 << 6);
    do
    {
      v10 = *(void **)(v8 + 8);
      if (v10 && objc_msgSend(v10, "peerID") && objc_msgSend(*(id *)(v8 + 8), "peerID") == a2)
      {
        v11 = *(unsigned int *)(v8 + 44);
        if (*(_QWORD *)(a3 + 8) < v11)
          re::DynamicArray<re::DynamicString>::setCapacity((_QWORD *)a3, v11);
        v12 = *(unsigned int *)(v8 + 48);
        if ((_DWORD)v12)
        {
          v13 = 0;
          v14 = (int *)(*(_QWORD *)(v8 + 32) + 8);
          while (1)
          {
            v15 = *v14;
            v14 += 22;
            if (v15 < 0)
              break;
            if (v12 == ++v13)
            {
              LODWORD(v13) = *(_DWORD *)(v8 + 48);
              break;
            }
          }
        }
        else
        {
          LODWORD(v13) = 0;
        }
        if ((_DWORD)v12 != (_DWORD)v13)
        {
          v16 = v13;
          do
          {
            re::DynamicArray<re::DynamicString>::add((_anonymous_namespace_ *)a3, (re::DynamicString *)(*(_QWORD *)(v8 + 32) + 88 * v16 + 16));
            if (*(_DWORD *)(v8 + 48) <= (v13 + 1))
              v17 = v13 + 1;
            else
              v17 = *(_DWORD *)(v8 + 48);
            v18 = v13;
            while (1)
            {
              v16 = (v18 + 1);
              if (v17 - 1 == v18)
                break;
              ++v18;
              LODWORD(v13) = v16;
              if ((*(_DWORD *)(*(_QWORD *)(v8 + 32) + 88 * v16 + 8) & 0x80000000) != 0)
                goto LABEL_24;
            }
            LODWORD(v13) = v17;
LABEL_24:
            ;
          }
          while ((_DWORD)v12 != (_DWORD)v13);
        }
      }
      v8 += 64;
    }
    while (v8 != v9);
  }
  os_unfair_lock_unlock(v6);
}

uint64_t re::ResourceFetchManager::taskIdentifierPortForPeerID(os_unfair_lock_s *this, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  id *v8;
  uint64_t v9;
  void *v11;
  void *v12;

  v4 = this + 16;
  os_unfair_lock_lock(this + 16);
  v5 = *(_QWORD *)&this[22]._os_unfair_lock_opaque;
  if (v5)
  {
    v6 = *(_QWORD *)&this[26]._os_unfair_lock_opaque;
    v7 = v5 << 6;
    v8 = (id *)(v6 + 8);
    while (!*v8 || !objc_msgSend(*v8, "peerID") || objc_msgSend(*v8, "peerID") != a2)
    {
      v8 += 8;
      v7 -= 64;
      if (!v7)
        goto LABEL_7;
    }
    objc_msgSend(*v8, "clientPorts");
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    v12 = v11;
    if (v11)
      v9 = objc_msgSend(v11, "taskIdentifierToken");
    else
      v9 = 0;

  }
  else
  {
LABEL_7:
    v9 = 0;
  }
  os_unfair_lock_unlock(v4);
  return v9;
}

void re::ResourceFetchManager::resourcePayloadDidUpdate(uint64_t a1, id *a2, const re::DynamicString *a3, id *a4)
{
  void *v8;
  NSObject *v9;
  uint64_t v10;
  id v11;
  _QWORD v12[4];
  char v13;
  id v14;
  _QWORD block[5];
  id v16;
  _QWORD v17[4];
  char v18;
  id v19;

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  v8 = *(void **)(a1 + 48);
  block[0] = MEMORY[0x24BDAC760];
  block[1] = 3321888768;
  block[2] = ___ZN2re20ResourceFetchManager24resourcePayloadDidUpdateENS0_12ClientObjectENS_13DynamicStringENS_6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEE_block_invoke;
  block[3] = &__block_descriptor_96_a8_32c160_ZTSKZN2re20ResourceFetchManager24resourcePayloadDidUpdateENS0_12ClientObjectENS_13DynamicStringENS_6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEEE3__0_e5_v8__0l;
  v10 = a1;
  v9 = v8;
  v11 = *a2;
  re::DynamicString::DynamicString((re::DynamicString *)v12, a3);
  v13 = *(_BYTE *)a4;
  v14 = a4[1];
  block[4] = v10;
  v16 = v11;
  re::DynamicString::DynamicString((re::DynamicString *)v17, (const re::DynamicString *)v12);
  v18 = v13;
  v19 = v14;
  dispatch_async(v9, block);

  if (v12[0])
  {
    if ((v12[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v12[0] + 40))();
    memset(v12, 0, sizeof(v12));
  }

  if (v17[0])
  {
    if ((v17[1] & 1) != 0)
      (*(void (**)(void))(*(_QWORD *)v17[0] + 40))();
    memset(v17, 0, sizeof(v17));
  }

}

void ___ZN2re20ResourceFetchManager24resourcePayloadDidUpdateENS0_12ClientObjectENS_13DynamicStringENS_6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  os_unfair_lock_s *v3;
  re *v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  unsigned int **v8;
  uint64_t v9;
  unsigned int *v10;
  char v11;
  unsigned int **v12;
  uint64_t v13;
  _anonymous_namespace_ *v14;
  uint64_t v15;
  unsigned int **v16;
  uint64_t i;
  unsigned int *v18;
  char v19;
  unint64_t v20;
  unint64_t v22;
  unint64_t v23;
  BOOL v24;
  unint64_t *v25;
  unint64_t v26;
  NSObject *v27;
  void *v28;
  uint64_t v29;
  void *v30;
  NSObject *v31;
  id v32;
  uint64_t *v33;
  unint64_t v34;
  int v35;
  unint64_t v36;
  unint64_t *v37;
  uint8_t buf[4];
  _BYTE v39[18];
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(a1 + 80))
    objc_msgSend(*(id *)(a1 + 88), "setClientObject:", *(_QWORD *)(a1 + 40));
  v33 = 0;
  v34 = 0;
  v35 = 1;
  v3 = (os_unfair_lock_s *)(v2 + 64);
  v36 = 0;
  v37 = 0;
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 64));
  v5 = *(_QWORD *)(v2 + 88);
  if (!v5)
  {
LABEL_7:
    v7 = re::resourceSharingLogObjects(v4)[1];
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
      goto LABEL_8;
    v30 = *(void **)(a1 + 40);
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)v39 = v30;
    v31 = v7;
    v32 = v30;
    _os_log_fault_impl(&dword_224FE9000, v31, OS_LOG_TYPE_FAULT, "No resource fetch connection exists for client %@", buf, 0xCu);
LABEL_58:

    goto LABEL_8;
  }
  v4 = (re *)(*(_QWORD *)(v2 + 104) + 16);
  v6 = v5 << 6;
  while (*((_QWORD *)v4 - 1) != *(_QWORD *)(a1 + 40))
  {
    v4 = (re *)((char *)v4 + 64);
    v6 -= 64;
    if (!v6)
      goto LABEL_7;
  }
  v14 = (_anonymous_namespace_ *)re::HashTable<re::DynamicString,re::DynamicArray<re::ResourceFetchManager::Request *>,re::Hash<re::DynamicString>,re::EqualTo<re::DynamicString>,true,false>::tryGet((uint64_t)v4, a1 + 48);
  if (!v14)
  {
    v27 = re::resourceSharingLogObjects(0)[1];
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      goto LABEL_8;
    v28 = *(void **)(a1 + 40);
    if ((*(_BYTE *)(a1 + 56) & 1) != 0)
      v29 = *(_QWORD *)(a1 + 64);
    else
      v29 = a1 + 57;
    *(_DWORD *)buf = 138412546;
    *(_QWORD *)v39 = v28;
    *(_WORD *)&v39[8] = 2080;
    *(_QWORD *)&v39[10] = v29;
    v31 = v27;
    v32 = v28;
    _os_log_impl(&dword_224FE9000, v31, OS_LOG_TYPE_DEFAULT, "Resource connection %@ ignored a message: no requests for '%s' are registered", buf, 0x16u);
    goto LABEL_58;
  }
  v15 = *((_QWORD *)v14 + 2);
  if (v15)
  {
    v16 = (unsigned int **)*((_QWORD *)v14 + 4);
    for (i = 8 * v15; i; i -= 8)
    {
      v18 = *v16;
      if (*v16)
        re::details::retain<re::ResourceFetchManager::Request>(*v16);
      if (v33)
      {
        v19 = v35;
        if ((v35 & 1) == 0)
        {
          v20 = v34 + 1;
          if (v34 < v36 || v36 >= v20)
            goto LABEL_48;
          v22 = 2 * v36;
          goto LABEL_44;
        }
        v20 = v34 + 1;
        if (v34 + 1 >= 2)
        {
          v22 = 2;
LABEL_44:
          if (v22 <= v20)
            v23 = v20;
          else
            v23 = v22;
          v14 = (_anonymous_namespace_ *)re::DynamicOverflowArray<re::SharedPtr<re::ResourceFetchManager::Request>,1ul>::setCapacity((uint64_t *)&v33, v23);
          v19 = v35;
        }
      }
      else
      {
        v14 = (_anonymous_namespace_ *)re::DynamicOverflowArray<re::SharedPtr<re::ResourceFetchManager::Request>,1ul>::setCapacity((uint64_t *)&v33, v34 + 1);
        v19 = v35 + 2;
        v35 += 2;
      }
LABEL_48:
      v24 = (v19 & 1) == 0;
      v25 = v37;
      v26 = v34;
      if (!v24)
        v25 = &v36;
      v25[v34] = (unint64_t)v18;
      v34 = v26 + 1;
      v35 += 2;
      ++v16;
    }
  }
LABEL_8:
  os_unfair_lock_unlock(v3);
  if ((v35 & 1) != 0)
    v8 = (unsigned int **)&v36;
  else
    v8 = (unsigned int **)v37;
  if (v34)
  {
    v9 = 8 * v34;
    do
    {
      v10 = *v8;
      if (*v8)
        re::details::retain<re::ResourceFetchManager::Request>(*v8);
      buf[0] = *(_BYTE *)(a1 + 80);
      *(_QWORD *)&v39[4] = *(id *)(a1 + 88);
      (*(void (**)(_QWORD, uint8_t *))(**((_QWORD **)v10 + 12) + 16))(*((_QWORD *)v10 + 12), buf);

      re::details::release<re::ResourceRequest>(v10);
      ++v8;
      v9 -= 8;
    }
    while (v9);
  }
  if (v33)
  {
    v11 = v35;
    if (v34)
    {
      if ((v35 & 1) != 0)
        v12 = (unsigned int **)&v36;
      else
        v12 = (unsigned int **)v37;
      v13 = 8 * v34;
      do
      {
        if (*v12)
        {
          re::details::release<re::ResourceRequest>(*v12);
          *v12 = 0;
        }
        ++v12;
        v13 -= 8;
      }
      while (v13);
      v11 = v35;
    }
    if ((v11 & 1) == 0)
      (*(void (**)(uint64_t *, unint64_t *))(*v33 + 40))(v33, v37);
  }
}

id __copy_helper_block_a8_32c160_ZTSKZN2re20ResourceFetchManager24resourcePayloadDidUpdateENS0_12ClientObjectENS_13DynamicStringENS_6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEEE3__0(uint64_t a1, uint64_t a2)
{
  void *v4;
  id result;

  v4 = *(void **)(a2 + 40);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = v4;
  re::DynamicString::DynamicString((re::DynamicString *)(a1 + 48), (const re::DynamicString *)(a2 + 48));
  *(_BYTE *)(a1 + 80) = *(_BYTE *)(a2 + 80);
  result = *(id *)(a2 + 88);
  *(_QWORD *)(a1 + 88) = result;
  return result;
}

void __destroy_helper_block_a8_32c160_ZTSKZN2re20ResourceFetchManager24resourcePayloadDidUpdateENS0_12ClientObjectENS_13DynamicStringENS_6ResultINS_21SharedResourcePayloadENS_12WrappedErrorEEEE3__0(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 48);
  if (v2)
  {
    if ((*(_BYTE *)(a1 + 56) & 1) != 0)
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 40))(v2, *(_QWORD *)(a1 + 64));
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
  }

}

void re::ResourceFetchManager::receiveFetchResponse(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  unsigned int *v5;
  id v6;
  id v7;
  id v8;
  id v9;
  _QWORD v10[5];
  BOOL v11[8];
  id v12;
  id v13;

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 32));
  v4 = *(id *)(a1 + 48);
  v10[0] = MEMORY[0x24BDAC760];
  v10[1] = 3321888768;
  v10[2] = ___ZN2re20ResourceFetchManager20receiveFetchResponseENS0_13FetchResponseE_block_invoke;
  v10[3] = &__block_descriptor_64_a8_32c80_ZTSKZN2re20ResourceFetchManager20receiveFetchResponseENS0_13FetchResponseEE3__0_e5_v8__0l;
  v5 = *(unsigned int **)a2;
  if (*(_QWORD *)a2)
    re::details::retain<re::ResourceFetchManager::Request>(*(unsigned int **)a2);
  v6 = *(id *)(a2 + 8);
  v7 = *(id *)(a2 + 16);
  v10[4] = a1;
  *(_QWORD *)v11 = v5;
  if (v5)
    re::details::retain<re::ResourceFetchManager::Request>(v5);
  v12 = v6;
  v13 = v7;
  v8 = v7;
  v9 = v6;
  dispatch_async(v4, v10);

  if (v5)
    re::details::release<re::ResourceRequest>(v5);

  if (*(_QWORD *)v11)
    re::details::release<re::ResourceRequest>(*(unsigned int **)v11);
}

void ___ZN2re20ResourceFetchManager20receiveFetchResponseENS0_13FetchResponseE_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  id v5;
  void *v6;
  id v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  unsigned int *v17;
  NSObject *v18;
  void *v19;
  char v20[8];
  id v21;
  uint64_t v22;
  int v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  unint64_t v28;
  __int16 v29;
  unint64_t v30;
  uint8_t buf[16];
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  v4 = *(void **)(a1 + 56);
  if (v4)
  {
    v5 = v4;
    v20[0] = 0;
LABEL_5:
    v21 = v5;
    (*(void (**)(_QWORD, char *))(**(_QWORD **)(v3 + 96) + 16))(*(_QWORD *)(v3 + 96), v20);
    v7 = v21;
    goto LABEL_6;
  }
  v6 = *(void **)(a1 + 48);
  if (v6)
  {
    objc_msgSend(v6, "setClientObject:", *(_QWORD *)(v3 + 24));
    v5 = *(id *)(a1 + 48);
    v20[0] = 1;
    goto LABEL_5;
  }
  v18 = re::resourceSharingLogObjects(0)[1];
  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_224FE9000, v18, OS_LOG_TYPE_FAULT, "Invalid resource fetch response, both payload and error are nil", buf, 2u);
  }
  re::makeResourceSharingError((__CFString *)0x1F5, 0, buf);
  v19 = *(void **)buf;
  *(_QWORD *)buf = 0;
  v20[0] = 0;
  v21 = v19;
  (*(void (**)(_QWORD, char *))(**(_QWORD **)(v3 + 96) + 16))(*(_QWORD *)(v3 + 96), v20);

  v7 = *(id *)buf;
LABEL_6:

  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 64));
  v8 = *(_QWORD **)(v2 + 144);
  v9 = *(_QWORD *)(v2 + 128);
  v10 = &v8[v9];
  v11 = v8;
  if (v9)
  {
    v12 = 8 * v9;
    v11 = *(_QWORD **)(v2 + 144);
    while (*v11 != *(_QWORD *)(a1 + 40))
    {
      ++v11;
      v12 -= 8;
      if (!v12)
      {
        v11 = &v8[v9];
        break;
      }
    }
  }
  v13 = v11 - v8;
  if (v13 != v9)
  {
    if (v9 <= v13)
    {
      v22 = 0;
      v34 = 0u;
      v35 = 0u;
      v32 = 0u;
      v33 = 0u;
      *(_OWORD *)buf = 0u;
      os_log_type_enabled(MEMORY[0x24BDACB70], OS_LOG_TYPE_ERROR);
      v23 = 136315906;
      v24 = "removeAt";
      v25 = 1024;
      v26 = 931;
      v27 = 2048;
      v28 = v13;
      v29 = 2048;
      v30 = v9;
      _os_log_send_and_compose_impl();
      _os_crash_msg();
      __break(1u);
    }
    v14 = v9 - 1;
    if (v9 - 1 > v13)
    {
      v15 = v8[v13];
      v8[v13] = *(v10 - 1);
      *(v10 - 1) = v15;
      v8 = *(_QWORD **)(v2 + 144);
    }
    v16 = &v8[v9];
    v17 = (unsigned int *)*(v16 - 1);
    if (v17)
    {
      re::details::release<re::ResourceRequest>(v17);
      *(v16 - 1) = 0;
      v14 = *(_QWORD *)(v2 + 128) - 1;
    }
    *(_QWORD *)(v2 + 128) = v14;
    ++*(_DWORD *)(v2 + 136);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 64));
}

id __copy_helper_block_a8_32c80_ZTSKZN2re20ResourceFetchManager20receiveFetchResponseENS0_13FetchResponseEE3__0(_QWORD *a1, uint64_t a2)
{
  unsigned int *v4;
  id result;

  v4 = *(unsigned int **)(a2 + 40);
  a1[4] = *(_QWORD *)(a2 + 32);
  a1[5] = v4;
  if (v4)
    re::details::retain<re::ResourceFetchManager::Request>(v4);
  a1[6] = *(id *)(a2 + 48);
  result = *(id *)(a2 + 56);
  a1[7] = result;
  return result;
}

void __destroy_helper_block_a8_32c80_ZTSKZN2re20ResourceFetchManager20receiveFetchResponseENS0_13FetchResponseEE3__0(uint64_t a1)
{
  unsigned int *v2;

  v2 = *(unsigned int **)(a1 + 40);
  if (v2)
  {
    re::details::release<re::ResourceRequest>(v2);
    *(_QWORD *)(a1 + 40) = 0;
  }
}

void re::ResourceFetchManager::setDirectMeshHandler(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  id v5;

  v2 = *a2;
  v3 = *(_QWORD *)(a1 + 264);
  if (v3 != *a2)
  {
    if (v2)
    {
      v5 = (id)(v2 + 8);
      v3 = *(_QWORD *)(a1 + 264);
    }
    if (v3)

    *(_QWORD *)(a1 + 264) = v2;
  }
}

uint64_t re::ResourceFetchManager::setReferenceObjectHandler(uint64_t a1, uint64_t a2)
{
  return re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>(*(_QWORD *)(a1 + 272) + 24, a2);
}

uint64_t re::ResourceFetchManager::addOnConnectionAddedHandler(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _anonymous_namespace_ *v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  BOOL v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  _BYTE v15[24];
  uint64_t v16;
  _BYTE *v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 280);
  *(_QWORD *)(a1 + 280) = v3 + 1;
  v16 = *(_QWORD *)(a2 + 24);
  v17 = 0;
  v4 = (_anonymous_namespace_ *)re::FunctionBase<24ul,REEventHandlerResult ()(re::ecs2::Scene *,RESceneDidAddEvent const&)>::operator=<24ul>((uint64_t)v15, a2);
  v5 = *(_QWORD *)(a1 + 272);
  v6 = *(_QWORD *)(v5 + 72);
  v7 = *(_QWORD *)(v5 + 80);
  if (v7 >= v6)
  {
    v8 = v7 + 1;
    if (v6 < v7 + 1)
    {
      if (*(_QWORD *)(v5 + 64))
      {
        v9 = 2 * v6;
        v10 = v6 == 0;
        v11 = 8;
        if (!v10)
          v11 = v9;
        if (v11 <= v8)
          v12 = v8;
        else
          v12 = v11;
        re::DynamicArray<re::ResourceFetchManager::ConnectionAddedHandler>::setCapacity((_QWORD *)(v5 + 64), v12);
      }
      else
      {
        re::DynamicArray<re::ResourceFetchManager::ConnectionAddedHandler>::setCapacity((_QWORD *)(v5 + 64), v8);
        ++*(_DWORD *)(v5 + 88);
      }
    }
    v7 = *(_QWORD *)(v5 + 80);
  }
  v13 = (_QWORD *)(*(_QWORD *)(v5 + 96) + 48 * v7);
  *v13 = v3;
  v13[4] = v16;
  v13[5] = 0;
  re::FunctionBase<24ul,void ()(void)>::operator=<24ul>((uint64_t)(v13 + 1), (uint64_t)v15);
  ++*(_QWORD *)(v5 + 80);
  ++*(_DWORD *)(v5 + 88);
  if (v17)
  {
    (**(void (***)(_BYTE *))v17)(v17);
    if (v17 != v15)
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 40))(v16);
  }
  return v3;
}

